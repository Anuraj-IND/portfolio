"use strict";

function SpecialGraphics(sgParent, sgData = null, sgSlideType, styleData, moodName = "simplecss", arrAssets, isPlayAnimation = true, textElementData = null, socialiconsData = null) {
    // console.log("SG - init");
    this.sgParent = sgParent;
    this.sgParent.style.opacity = 0;
    this.sgData = sgData;
    this.sgSlideType = sgSlideType;
    this.styleData = styleData;
    this.moodName = moodName;
    this.arrAssetsToLoad = arrAssets;
    this.arrAssets = [];
    this.properties = {};
    this.isPlayAnimation = isPlayAnimation;
    this.textElementData = textElementData;
    this.socialiconsData = socialiconsData;

    this.specialGraphicsUtils = new window["SpecialGraphicsUtils"]();
    this.assetLoader = new window["SGAssetLoader"]();
    this.eventManager = new window["EventManager"]();

    this.specialGraphicsUtils.setAssetType(this.sgSlideType);
    this.arrSlides = [];

    if (sgData.length > 2) sgParent.parentElement.parentElement.setAttribute("fulloptions", "true");
    else sgParent.parentElement.parentElement.setAttribute("fulloptions", "false");

    this.highlightCompleteCallback = this.highlightCompleteCallback.bind(this);
    this.sgParent.setAttribute("data-slidetype", this.sgSlideType);
    if (sgSlideType == "coverpage") this.sgParent.setAttribute("data-assetname", this.styleData.styleName);
}

SpecialGraphics.prototype.highlightCompleteCallback = function (assetParent) {
    if (assetParent) {
        let sgTitleNode = assetParent.querySelector("[id*='sgTitleNode']");
        let sgSubTitleNode = assetParent.querySelector("[id*='sgSubTitleNode']");
        // let sgTitleLabelNode = assetParent.querySelector("[id*='sgTitleLabelNode']");
        if (sgTitleNode.onTextChange && sgTitleNode) sgTitleNode.onTextChange(sgTitleNode);
        if (sgSubTitleNode.onTextChange && sgSubTitleNode) sgSubTitleNode.onTextChange(sgSubTitleNode);
        // if (sgTitleLabelNode.onTextChange && sgTitleLabelNode) sgTitleLabelNode.onTextChange(sgTitleLabelNode);
    }
};
SpecialGraphics.prototype.initSpecialGraphicsCreation = function () {
    if (this.isPresent == false) {
        this.sgParent.innerHTML = "";

        let slideType = this.styleData.styleName.includes("simple-typography") || this.styleData.styleName.includes("simple-photography") ? "genericquote" : this.sgSlideType;
        slideType = slideType == "imagestack" && this.styleData.styleName.includes(this.moodName.toLowerCase()) ? "moodimagestack" : slideType;
        slideType = slideType == "imagestack" && this.styleData.styleName.includes("genericstyle") ? "genericimagestack" : slideType;
        slideType = this.styleData.type && this.styleData.type.includes("GenericCoverpage") ? "genericcoverpage" : slideType;
        this.sgParent.className = slideType;
        let nodesData = this.sgData;

        //Creating stylesheet for animations
        let styleClass = this.sgParent.querySelector("[id='CssAnimStyle']");
        if (!styleClass) {
            var style = document.createElement("style");
            style.id = "CssAnimStyle";
            this.sgParent.appendChild(style);
        }

        this.arrAssets = [];
        if (this.arrAssetsToLoad && this.arrAssetsToLoad.length > 0) {
            for (let ll = 0; ll < this.arrAssetsToLoad.length; ll++) {
                this.arrAssets.push(this.arrAssetsToLoad[ll]);
            }
        }
        //Loading assets
        this.assetLoader
            .loadAssets(this.arrAssets, this.appStaticURL)
            .then((responseData) => {
                this.assetsLoadComplete(responseData);
                //Creating slides based on content
                for (let i = 0; i < nodesData.length; i++) {
                    let detailsObject = {};
                    detailsObject.sgParent = this.sgParent;
                    detailsObject.nodesData = nodesData[i];
                    detailsObject.sgSlideType = this.sgSlideType;
                    detailsObject.index = i;
                    detailsObject.totalLength = nodesData.length;
                    detailsObject.styleData = this.styleData;
                    detailsObject.moodName = this.moodName;
                    detailsObject.arrAssets = this.arrAssets;
                    detailsObject.isPlayAnimation = this.isPlayAnimation;
                    detailsObject.textElementData = this.textElementData;
                    detailsObject.appStaticURL = this.appStaticURL;
                    detailsObject.appBaseURL = this.appBaseURL;
                    detailsObject.isPresent = this.isPresent;
                    detailsObject.socialiconsData = this.socialiconsData;
                    detailsObject.isWidget = this.isWidget;
                    detailsObject.metaData = this.metaData;

                    detailsObject.eventManager = this.eventManager;
                    detailsObject.specialGraphicsUtils = this.specialGraphicsUtils;
                    detailsObject.textElementCreationCallBack = this.textelementcreation;
                    detailsObject.fontSizeChangeOnTextChange = this.fontSizeChangeOnTextChange;

                    let slides = new window["SpecialGraphicsSlides"](detailsObject);
                    slides.specialGraphicsUtils.checkTitleVisibility(this.sgParent);
                    this.arrSlides.push(slides);
                    //listener for completing one slide
                    this.specialGraphicsSlideCreationComplete(i);
                    this.doFontFitForAll(slides);
                }
                //listener for completing All slide
                this.specialGraphicsCreationComplete();
            })
            .catch(function (rej) {
                console.log("SG - Error on Specialgraphics init");
                console.log(rej);
                // this.specialGraphicsCreationComplete();
            });
    } else this.specialGraphicsCreationComplete();
};

SpecialGraphics.prototype.doFontFitForAll = function (slides) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + slides.index + "']");
    let title = assetParent.querySelector("[id='sgTitleNode']");
    let subTitle = assetParent.querySelector("[id='sgSubTitleNode']");
    let titleLabel = assetParent.querySelector("[id='sgTitleLabelNode']");
    let presentorName = assetParent.querySelector("[id='sgPresentorNameNode']");
    let presentorDesigination = assetParent.querySelector("[id='sgPresentorDesiginationNode']");
    let authorNameNode = assetParent.querySelector("[id='sgAuthorNameNode']");
    let sgAuthorDesignationNode = assetParent.querySelector("[id='sgAuthorDesignationNode']");

    slides.specialGraphicsUtils.checkTitleVisibility(this.sgParent);

    if (title) slides.setTextFocus(title);
    if (subTitle) slides.setTextFocus(subTitle);
    if (titleLabel) slides.setTextFocus(titleLabel);
    if (presentorName) slides.setTextFocus(presentorName);
    if (presentorDesigination) slides.setTextFocus(presentorDesigination);
    if (authorNameNode) slides.setTextFocus(authorNameNode);
    if (sgAuthorDesignationNode) slides.setTextFocus(sgAuthorDesignationNode);
};
//After asset load setting up local array updated.
SpecialGraphics.prototype.assetsLoadComplete = function (arrAssets) {
    this.arrAssets = arrAssets;
};

//Positioning text element when changes detect in variation changes.
SpecialGraphics.prototype.textElementPositioning = function (pos) {
    try {
        if (this.arrSlides[pos]) this.arrSlides[pos].textElementPositioning();
    } catch (error) {
        console.log("SG - Error on textElementPositioning - " + error);
    }
};

//Completion for each slide
SpecialGraphics.prototype.specialGraphicsSlideCreationComplete = function (index) {};

//Completion of All slide
SpecialGraphics.prototype.specialGraphicsCreationComplete = function () {
    console.log("SG - Render Complete old imagestack");
    this.sgParent.style.opacity = 1;

    let position = this.isFromLastSlide && this.isFromLastSlide == true ? this.sgData.length - 1 : 0;
    this.eventManager.dispatch("positionchangecallback", position);
    if (this.isPresent == false && this.reBuildSectiontitleCallback && this.sgSlideType == "sectiontitle") this.reBuildSectiontitleCallback();

    if (this.isPresent == false && this.reApplyHighlightStyle) this.reApplyHighlightStyle(this.sgParent);
    this.specialGraphicsUtils.updateColorClassName(this.styleData.styleName, this.sgParent);

    if (this.completeCallBack && this.completeCallBack.func) {
        this.completeCallBack.func(this.completeCallBack.params);
        this.completeCallBack = null;
    }
    if (this.rebuildCompleteCallBack && this.rebuildCompleteCallBack.func) {
        this.rebuildCompleteCallBack.func(this.rebuildCompleteCallBack.params);
        this.rebuildCompleteCallBack = null;
    }
};

//Adding listeners in event manager
SpecialGraphics.prototype.addListener = function (event, callback) {
    this.eventManager.addListener(event, callback);
};

//Removing listeners in event manager
SpecialGraphics.prototype.removeListener = function (event, callback) {
    this.eventManager.removeListener(event, callback);
};

//Clear all the listeners and callbacks - ABORT method
SpecialGraphics.prototype.clearListener = function () {
    this.eventManager.clear();
    this.completeCallBack = null;
};

SpecialGraphics.prototype.focusOutElement = function (elementID) {
    try {
        let element = this.sgParent.querySelector("[id=" + elementID + "]");
        if (element) {
            element.setAttribute("focusout", "mannual");
            element.blur();
        }
    } catch (error) {}
};

"use strict";

function SpecialGraphicsSlides(detailsObject) {
    SpecialGraphicsSlidesBase.call(this, detailsObject);
}

SpecialGraphicsSlides.prototype = Object.create(SpecialGraphicsSlidesBase.prototype);
SpecialGraphicsSlides.prototype.constructor = SpecialGraphicsSlides;

// Init specialgraphics  - If cover/cta/quote we create some custom elements here.
SpecialGraphicsSlides.prototype.initCustomData = function () {
    if (this.sgSlideType == "coverpage" || this.sgSlideType == "cta") {
        this.createCoverpageData();
        if (this.sgSlideType == "coverpage") this.createCoverStylesData();
        if (this.sgSlideType == "cta") this.createCtaStylesData();
    } else if (this.sgSlideType == "quote") {
        this.createQuoteData();

        let sgSubTitleNode = this.sgParent.querySelector("[id='sgSubTitleNode']");
        if (sgSubTitleNode) sgSubTitleNode.parentElement.removeChild(sgSubTitleNode);

        let sgTitleLabelNode = this.sgParent.querySelector("[id='sgTitleLabelNode']");
        if (sgTitleLabelNode) sgTitleLabelNode.parentElement.removeChild(sgTitleLabelNode);

        let coverImageParent = this.sgParent.querySelector("[id='coverImageParent']");
        if (coverImageParent) coverImageParent.parentElement.removeChild(coverImageParent);
    }
};

//Create CTA styles related stuffs here
SpecialGraphicsSlides.prototype.createCtaStylesData = function () {
    let assetParent = this.sgParent.querySelector("[id='assetParent0']");
    if (this.styleData.styleName.includes("contactstyle")) {
        let oldContactParent = assetParent.querySelector("[id='contactParent']");
        if (oldContactParent) oldContactParent.parentElement.removeChild(oldContactParent);

        let contactParent = document.createElement("div");
        contactParent.id = "contactParent";
        this.setTextType(contactParent);
        contactParent.className = "contactParent";
        assetParent.appendChild(contactParent);
        this.createContactData(contactParent, "venue", "mailingAddress", "Mailing Address");
        this.createContactData(contactParent, "creatoremail", "emailAddress", "E-Mail Address");
        this.createContactData(contactParent, "phone", "phoneNumber", "Phone Number");
    }

    if (!this.sgParent.querySelector("[id='covershape']")) {
        let ctashape = document.createElement("div");
        ctashape.id = "covershape";
        ctashape.className = "ctashape moodanimation ";
        ctashape.style.pointerEvents = "none";
        ctashape.setAttribute("data-type", "TEXT");
        assetParent.appendChild(ctashape);
        this.specialGraphicsUtils.setOpacityAttribute(ctashape);

        if (this.moodName == "minimalistcss") {
            let covershapeInner = document.createElement("div");
            covershapeInner.id = "covershapeInner";
            covershapeInner.className = "ctashapeInner";
            covershapeInner.style.pointerEvents = "none";
            covershapeInner.setAttribute("data-type", "TEXT");
            ctashape.appendChild(covershapeInner);
        }
    }

    if (this.styleData.styleName.includes("socialstyle")) {
        // For CTA SOCIAL
        let oldCustomLinkParent = assetParent.querySelector("[id='customLinkIconParent']");
        if (oldCustomLinkParent) oldCustomLinkParent.parentElement.removeChild(oldCustomLinkParent);

        let customLinkIconParent = document.createElement("div");
        customLinkIconParent.id = "customLinkIconParent";
        customLinkIconParent.className = "customLinkIconParent";
        this.setTextType(customLinkIconParent);
        assetParent.appendChild(customLinkIconParent);

        let customLinkIconInnerParent = document.createElement("div");
        customLinkIconInnerParent.id = "customLinkIconInnerParent";
        customLinkIconInnerParent.className = "customLinkIconInnerParent";
        this.setTextType(customLinkIconInnerParent);
        customLinkIconParent.appendChild(customLinkIconInnerParent);

        for (let i = 1; i < 6; i++) {
            let socialHead = i == 1 ? "LinkedIn" : i == 2 ? "Twitter" : i == 3 ? "Facebook" : i == 4 ? "Instagram" : "Skype";
            let customSocialLink = document.createElement("div");
            customSocialLink.id = "sgCustomSocialLink" + i;
            customSocialLink.className = "customSocialLink";
            this.setTextType(customSocialLink);
            customLinkIconInnerParent.appendChild(customSocialLink);

            let iconNode = document.createElement("div");
            iconNode.id = "customSocialLinkIcon" + i;
            iconNode.className = "customSocialLinkIcon" + this.moodanimation;
            this.setTextType(iconNode);
            customSocialLink.appendChild(iconNode);

            this.specialGraphicsUtils.socialIconsPropertyApplyFromMood(this.socialiconsData, iconNode, assetParent);
            // if (this.socialiconsData) {
            //     let shape = this.socialiconsData.shape;
            //     let style = this.socialiconsData.style;
            //     let bgColor = this.socialiconsData.bgcolor ? this.socialiconsData.bgcolor : "item1";
            //     if (this.socialiconsData.iconcolor) assetParent.style.setProperty("--socialIconColor", this.socialiconsData.iconcolor);
            //     if (style == "outline") {
            //         iconNode.style.background = "unset";
            //         iconNode.style.border = "2px solid var(--" + bgColor + "-color)";
            //         iconNode.classList.add("accent1-fill");
            //     } else if (style == "solid") {
            //         iconNode.style.backgroundColor = "var(--" + bgColor + "-color)";
            //     }
            //     if (style == "outlinegradient") {
            //         iconNode.style.border = "double " + style.replace("outlinegradient", "") + "transparent";
            //         iconNode.style.backgroundImage = "linear-gradient(white, white), radial-gradient(circle at bottom right, var(--item6-color), var(--item1-color))";
            //         iconNode.style.backgroundOrigin = "border-box";
            //         iconNode.style.backgroundClip = "content-box, border-box";
            //     }
            //     if (style == "solidgradient") {
            //         iconNode.style.backgroundColor = "unset";
            //         iconNode.style.background = "linear-gradient(to right bottom, var(--item1-color), var(--item6-color))";
            //     }
            //     if (shape == "none") {
            //         iconNode.classList.add("accent1-fill");
            //         iconNode.style.border = "unset";
            //         iconNode.style.background = "unset";
            //     } else if (shape == "rounded" || shape == "circle" || shape == "square") {
            //         iconNode.style.border = "2px solid var(--" + bgColor + "-color)";
            //         iconNode.style.borderRadius = shape == "rounded" ? "12px" : shape == "circle" ? "100%" : "0px";
            //     }
            // }

            let socialIconTextParent = document.createElement("div");
            socialIconTextParent.id = "socialIconTextParent";
            socialIconTextParent.className = "socialIconTextParent";
            this.setTextType(socialIconTextParent);
            customSocialLink.appendChild(socialIconTextParent);

            let socialIconTextTitle = this.specialGraphicsUtils.createTextElement(
                socialIconTextParent,
                socialHead,
                "socialIconTextTitle" + i,
                "socialIconTextTitle " + this.styleData.fontData.address + " secondary-color " + this.selectionLayerClass + this.moodanimation,
                "customsociallink" + i
            );
            socialIconTextTitle.contentEditable = "false";
            socialIconTextTitle.style.pointerEvents = "all";
            this.setTextFocus(socialIconTextTitle);

            let socialIconTextSubTitle = this.specialGraphicsUtils.createTextElement(
                socialIconTextParent,
                this.sgData["customsociallinksub" + i],
                "socialIconTextSubTitle" + i,
                "socialIconTextSubTitle " + this.styleData.fontData.addressprompt + " " + this.selectionLayerClass + this.moodanimation,
                "customsociallinksub" + i
            );
            socialIconTextSubTitle.contentEditable = "true";
            socialIconTextSubTitle.setAttribute("data-prompt-text", "Enter Social link text");
            socialIconTextSubTitle.style.pointerEvents = "all";
            this.setTextFocus(socialIconTextSubTitle);
        }
    }
    if (this.styleData.styleName.includes("referencestyle")) {
        // For CTA REFERENCE
        let oldReferenceParent = assetParent.querySelector("[id='referenceParent']");
        if (oldReferenceParent) oldReferenceParent.parentElement.removeChild(oldReferenceParent);

        let referenceParent = document.createElement("div");
        referenceParent.id = "referenceParent";
        referenceParent.className = "referenceParent";
        this.setTextType(referenceParent);
        assetParent.appendChild(referenceParent);

        this.createReferenceData(referenceParent, "reference1", "referenceLink1", "Reference Link", "sgreferenceLinkHead1");
        this.createReferenceData(referenceParent, "reference2", "referenceLink2", "Reference Link", "sgreferenceLinkHead2");
        this.createReferenceData(referenceParent, "reference3", "referenceLink3", "Reference Link", "sgreferenceLinkHead3");
        this.createReferenceData(referenceParent, "reference4", "referenceLink4", "Reference Link", "sgreferenceLinkHead4");
    }
};

//Create Coverpage styles related stuffs here
SpecialGraphicsSlides.prototype.createCoverStylesData = function () {
    let assetParent = this.sgParent.querySelector("[id='assetParent0']");
    let covershape = document.createElement("div");
    covershape.id = "covershape";
    covershape.className = "covershape " + this.moodanimation + " ";
    covershape.style.pointerEvents = "none";
    covershape.setAttribute("data-type", "TEXT");
    assetParent.appendChild(covershape);
    this.specialGraphicsUtils.setOpacityAttribute(covershape);

    if (this.moodName == "minimalistcss") {
        let covershapeInner = document.createElement("div");
        covershapeInner.id = "covershapeInner";
        covershapeInner.className = "covershapeInner";
        covershapeInner.style.pointerEvents = "none";
        covershapeInner.setAttribute("data-type", "TEXT");
        covershape.appendChild(covershapeInner);
    }

    let textData = this.styleData.styleName.includes("annualreportstyle") ? "2020" : "10";
    textData = this.sgData.covernumber != undefined && this.sgData.covernumber != "undefined" && this.sgData.covernumber != null && this.sgData.covernumber != "" ? this.sgData.covernumber : textData;
    if (this.styleData.styleName.includes("thingstodo") && textData.length > 2) textData = textData.substring(0, 2);

    let covernumberParent = document.createElement("div");
    covernumberParent.id = "covernumber";
    covernumberParent.className = "covernumber " + this.moodanimation;
    covernumberParent.setAttribute("data-type", "TEXT");
    covernumberParent.setAttribute("data-showselector", "false");
    assetParent.appendChild(covernumberParent);
    this.specialGraphicsUtils.setOpacityAttribute(covernumberParent);

    let className = this.styleData.fontData.covernumber + " ";
    let covernumber = this.specialGraphicsUtils.createTextElement(covernumberParent, textData, "covernumbercontent", "covernumbercontent " + className + this.selectionLayerClass, "covernumber");
    covernumber.contentEditable = "true";
    covernumber.style.pointerEvents = "auto";
    covernumber.setAttribute("data-prompt-text", this.styleData.styleName.includes("annualreportstyle") ? "2020" : "10");
    this.setTextFocus(covernumber);

    if (this.styleData.styleName.includes("profilestyle")) {
        // For CTA SOCIAL
        let presenterTextParent = assetParent.querySelector("[id='presenterTextParent']");
        let customLinkIconParent = document.createElement("div");
        customLinkIconParent.id = "customLinkIconParent";
        customLinkIconParent.className = "customLinkIconParent";
        this.setTextType(customLinkIconParent);
        presenterTextParent.appendChild(customLinkIconParent);

        for (let i = 1; i < 3; i++) {
            let customSocialLink = document.createElement("div");
            customSocialLink.id = "sgCustomSocialLink" + i;
            customSocialLink.className = "customSocialLink";
            this.setTextType(customSocialLink);
            customLinkIconParent.appendChild(customSocialLink);

            let iconNode = document.createElement("div");
            iconNode.id = "customSocialLinkIcon" + i;
            let extraClassName = this.styleData.styleName.includes("simplecssprofilestyle2") || this.styleData.styleName.includes("minimalistcssprofilestyle2") ? " accent1-fill " : "";
            iconNode.className = "customSocialLinkIcon" + this.moodanimation + extraClassName;
            this.setTextType(iconNode);
            customSocialLink.appendChild(iconNode);

            this.specialGraphicsUtils.socialIconsPropertyApplyFromMood(this.socialiconsData, iconNode, assetParent);

            // if (this.socialiconsData) {
            //     let shape = this.socialiconsData.shape;
            //     let style = this.socialiconsData.style;
            //     if (style == "outline") {
            //         iconNode.style.background = "unset";
            //         iconNode.style.border = "2px solid var(--item1-color)";
            //         iconNode.classList.add("accent1-fill");
            //     }
            //     if (style == "solidgradient") {
            //         iconNode.style.backgroundColor = "unset";
            //         iconNode.style.background = "linear-gradient(to right bottom, var(--item1-color), var(--item6-color))";
            //     }
            //     if (style == "outlinegradient") {
            //         iconNode.style.border = "double " + style.replace("outlinegradient", "") + "transparent";
            //         iconNode.style.backgroundImage = "linear-gradient(white, white), radial-gradient(circle at bottom right, var(--item6-color), var(--item1-color))";
            //         iconNode.style.backgroundOrigin = "border-box";
            //         iconNode.style.backgroundClip = "content-box, border-box";
            //     }
            //     if (shape == "none") {
            //         iconNode.classList.add("accent1-fill");
            //         iconNode.style.border = "unset";
            //         iconNode.style.background = "unset";
            //     } else if (shape == "rounded" || shape == "circle" || shape == "square") {
            //         iconNode.style.border = "2px solid var(--item1-color)";
            //         iconNode.style.borderRadius = shape == "rounded" ? "12px" : shape == "circle" ? "100%" : "0px";
            //     }
            // }

            let socialIconTextParent = document.createElement("div");
            socialIconTextParent.id = "socialIconTextParent";
            socialIconTextParent.className = "socialIconTextParent";
            this.setTextType(socialIconTextParent);
            customSocialLink.appendChild(socialIconTextParent);

            let socialIconTextSubTitle = this.specialGraphicsUtils.createTextElement(
                socialIconTextParent,
                this.sgData["customsociallinksub" + i],
                "socialIconTextSubTitle" + i,
                "socialIconTextSubTitle p4 " + this.selectionLayerClass + this.moodanimation,
                "customsociallinksub" + i
            );
            socialIconTextSubTitle.contentEditable = "true";
            socialIconTextSubTitle.setAttribute("data-prompt-text", "Enter Social link text");
            socialIconTextSubTitle.style.pointerEvents = "all";
            this.setTextFocus(socialIconTextSubTitle);
        }
    }
};

//Create common coverpage data
SpecialGraphicsSlides.prototype.createCoverpageData = function () {
    let textBaseParent = this.sgParent.querySelector("[id='textBaseParentNode']");

    let presenterParent = document.createElement("div");
    presenterParent.id = "presenterParent";
    presenterParent.className = "presenterParent";
    this.setTextType(presenterParent);
    textBaseParent.appendChild(presenterParent);

    let presenterTextParent = document.createElement("div");
    presenterTextParent.id = "presenterTextParent";
    presenterTextParent.style.position = "relative";
    presenterTextParent.className = "presenterTextParent";
    this.setTextType(presenterTextParent);
    presenterParent.appendChild(presenterTextParent);

    this.createPresenterName(presenterTextParent);
    this.createPresentorDesignation(presenterTextParent);
    this.createPresentorImageNode(presenterParent);

    this.createLogoImageNode(textBaseParent);
    this.createVenue(textBaseParent);
};

//Create common Quote data
SpecialGraphicsSlides.prototype.createQuoteData = function () {
    let textBaseParent = this.sgParent.querySelector("[id='textBaseParentNode']");

    this.createQuoteIcon(textBaseParent);

    let authorParent = document.createElement("div");
    authorParent.id = "authorParent";
    authorParent.className = "authorParent";
    textBaseParent.appendChild(authorParent);

    let authorInnerParent = document.createElement("div");
    authorInnerParent.id = "authorInnerParent";
    authorInnerParent.className = "authorInnerParent";
    authorParent.appendChild(authorInnerParent);

    this.createAuthorName(authorInnerParent);
    this.createAuthorDesignation(authorInnerParent);
    let parentNode = this.sgParent.querySelector("[id='assetParent" + this.index + "']");
    let parentElementForImage = parentNode;
    if (this.styleData.styleName.includes("simple-typography1") || this.styleData.styleName.includes("simple-photography1") || this.styleData.styleName.includes("simple-photography2"))
        parentElementForImage = authorParent;
    this.createAuthorImageNode(parentElementForImage);
    this.createLogoImageNode(parentNode);

    // quotetakeaway
    this.createQuotePlaceHolder(parentNode);
};

//Create presenter image node
SpecialGraphicsSlides.prototype.createPresentorImageNode = function (parentNode) {
    let presenterImageParent = document.createElement("div");
    presenterImageParent.id = "presenterImageParent";
    presenterImageParent.className = "presenterImageParent" + this.selectionLayerClass + this.moodanimation;
    parentNode.appendChild(presenterImageParent);

    let colorDiv = document.createElement("div");
    colorDiv.id = "presentorColorDiv";
    colorDiv.className = "presentorColorDiv" + " theme-bg-color " + this.moodanimation;
    presenterImageParent.appendChild(colorDiv);

    let width = parseFloat(window.getComputedStyle(presenterImageParent)["width"]);
    let height = parseFloat(window.getComputedStyle(presenterImageParent)["height"]);
    // Left Top will differ for each mood. so update it here for image editig
    let presenterImage = this.specialGraphicsUtils.createImageElement(
        presenterImageParent,
        "presenterImage",
        "",
        this.sgData.creatorimage,
        width,
        height,
        1120,
        560,
        "creatorimage",
        this.sgData,
        "sgPresentorImageNode"
    );

    let offsetVal = this.getOffsetRectByParent(parentNode, presenterImageParent);
    let offsetVal2 = this.getOffsetRectByParent(this.sgParent, presenterImageParent);
    presenterImage.setAttribute("data-x", offsetVal2.left - offsetVal.left);
    presenterImage.setAttribute("data-y", offsetVal.top);
    // console.log(offsetVal);
    // console.log(offsetVal2);
};

//Create quote icon for quote assets
SpecialGraphicsSlides.prototype.createQuoteIcon = function (parentNode) {
    let quoteParent = document.createElement("div");
    quoteParent.id = "quoteParent";
    quoteParent.className = "quoteParent" + this.moodanimation;
    quoteParent.style.pointerEvents = "none";
    parentNode.appendChild(quoteParent);

    let quoteIcon = document.createElement("div");
    quoteIcon.id = "quoteIcon";
    quoteIcon.className = "quoteIcon";
    quoteIcon.style.pointerEvents = "none";
    quoteIcon.setAttribute("data-type", "TEXT");
    quoteParent.appendChild(quoteIcon);
};

//Create Logo image with parent node
SpecialGraphicsSlides.prototype.createLogoImageNode = function (parentNode) {
    let oldImageParent = parentNode.querySelector("[id='logoImageParent']");
    if (oldImageParent) oldImageParent.parentElement.removeChild(oldImageParent);

    let logoImageParent = document.createElement("div");
    logoImageParent.id = "logoImageParent";
    logoImageParent.className = "logoImageParent" + this.selectionLayerClass + this.moodanimation;
    parentNode.appendChild(logoImageParent);

    let isRight = this.styleData.logoPosition && this.styleData.logoPosition == "right" ? true : false;

    let left = window.getComputedStyle(logoImageParent)["left"];
    if (left && parseFloat(left)) isRight = parseFloat(left) < 640 ? false : true;
    if (
        this.styleData.styleName.includes("simplecssreferencestyle1") ||
        this.styleData.styleName.includes("simplecsseventstyle2") ||
        this.styleData.styleName.includes("simplecsscontactstyle2") ||
        this.styleData.styleName.includes("boldcsseventstyle2") ||
        this.styleData.styleName.includes("boldcsssocialstyle2") ||
        this.styleData.styleName.includes("boldcssquotetextstyle2") ||
        this.styleData.styleName.includes("boldcssquotetitlestyle2") ||
        this.styleData.styleName.includes("boldcssannualreportstyle1") ||
        this.styleData.styleName.includes("boldcsstitlestyle2") ||
        this.styleData.styleName.includes("classiccsstitlestyle2")
    ) {
        left = "1000px";
        isRight = true;
    }
    if (
        this.styleData.styleName.includes("boldcsscontactstyle1") ||
        this.styleData.styleName.includes("boldcssthanksstyle2") ||
        this.styleData.styleName.includes("minimalistcsslogostyle1") ||
        this.styleData.styleName.includes("minimalistcssquotetitlestyle2") ||
        this.styleData.styleName.includes("minimalistcssquoteimagestyle2") ||
        this.styleData.styleName.includes("minimalistcsscontactstyle1") ||
        this.styleData.styleName.includes("minimalistcsssocialstyle2") ||
        this.styleData.styleName.includes("minimalistcssreferencestyle1") ||
        this.styleData.styleName.includes("minimalistcssreferencestyle2") ||
        this.styleData.styleName.includes("simplecssthanksstyle2") ||
        this.styleData.styleName.includes("simplecssquoteimagestyle1") ||
        this.styleData.styleName.includes("classiccsslogostyle2") ||
        this.styleData.styleName.includes("minimalistcssannualreportstyle2") ||
        this.styleData.styleName.includes("boldcsscontactstyle2") ||
        this.styleData.styleName.includes("elegantcssthanksstyle2") ||
        this.styleData.styleName.includes("simplecssreferencestyle2") ||
        this.styleData.styleName.includes("simplecsscontactstyle1") ||
        this.styleData.styleName.includes("minimalistcssthanksstyle2") ||
        this.styleData.styleName.includes("simplecsssocialstyle2")
    )
        left = "535px";

    let width = parseFloat(window.getComputedStyle(logoImageParent)["width"]);
    let height = parseFloat(window.getComputedStyle(logoImageParent)["height"]);
    let logoImage = this.specialGraphicsUtils.createImageElement(logoImageParent, "logoImage", "", this.sgData.logoimage, width, height, 339.52, 40, "logoimage", this.sgData, "sgLogoImageNode");
    // Left Top will differ for each mood. so update it here for image editig
    logoImage.setAttribute("data-imagecropalignment", left == "535px" ? "center" : isRight == true ? "right" : "left");

    let offsetVal = this.getOffsetRectByParent(this.sgParent, logoImageParent);
    logoImage.setAttribute("data-x", offsetVal.left);
    logoImage.setAttribute("data-y", offsetVal.top);
    // logoImage.setAttribute("data-x", logoImageParent.offsetLeft);
    // logoImage.setAttribute("data-y", logoImageParent.offsetTop);

    this.specialGraphicsUtils.setOpacityAttribute(logoImage);
};

//Create Author image with parent node
SpecialGraphicsSlides.prototype.createAuthorImageNode = function (parentNode) {
    let oldImageParent = parentNode.querySelector("[id='authorImageParent']");
    if (oldImageParent) oldImageParent.parentElement.removeChild(oldImageParent);

    let authorImageParent = document.createElement("div");
    authorImageParent.id = "authorImageParent";
    authorImageParent.className = "authorImageParent" + this.selectionLayerClass + this.moodanimation;
    parentNode.appendChild(authorImageParent);

    let width = parseFloat(window.getComputedStyle(authorImageParent)["width"]);
    let height = parseFloat(window.getComputedStyle(authorImageParent)["height"]);
    let authorImage = this.specialGraphicsUtils.createImageElement(authorImageParent, "authorImage", "", this.sgData.authorimage, width, height, 0, 0, "authorimage", this.sgData, "sgAuthorImageNode");

    authorImage.setAttribute("data-x", authorImageParent.offsetLeft);
    authorImage.setAttribute("data-y", authorImageParent.offsetTop);
};

//Create Presenter Name node
SpecialGraphicsSlides.prototype.createPresenterName = function (textParent) {
    let className = this.styleData.fontData.creatorname + " ";
    let createNameNode = this.specialGraphicsUtils.createTextElement(
        textParent,
        this.sgData.creatorname,
        "sgPresentorNameNode",
        "presenterName " + className + this.selectionLayerClass + this.moodanimation,
        "creatorname"
    );
    createNameNode.contentEditable = "true";
    createNameNode.setAttribute("data-prompt-text", this.styleData.presenterNamePrompt);
    this.setTextFocus(createNameNode);
};

//Create Presenter Name node
SpecialGraphicsSlides.prototype.createQuotePlaceHolder = function (parentNode) {
    if (this.styleData.styleName.includes("quotetakeawaybased") || this.styleData.styleName.includes("quotetitlebased")) {
        let quotePlaceHolderParent = document.createElement("div");
        quotePlaceHolderParent.id = "quotePlaceHolderParent";
        quotePlaceHolderParent.className = "quotePlaceHolderParent moodanimation";
        parentNode.appendChild(quotePlaceHolderParent);

        let className = this.styleData.fontData.quotetakeaway + " ";
        let quotePlaceHolder = this.specialGraphicsUtils.createTextElement(
            quotePlaceHolderParent,
            this.sgData.quotetakeaway,
            "sgQuoteTextNode",
            "quoteText " + className + this.selectionLayerClass,
            "quotetakeaway"
        );
        quotePlaceHolder.contentEditable = "true";
        quotePlaceHolder.setAttribute("data-prompt-text", this.styleData.presenterNamePrompt);
        quotePlaceHolder.setAttribute("increaseHeight", "PlaceHolder" + (this.styleData.styleName.includes("quotetitlebased") ? "2" : ""));
        this.setTextFocus(quotePlaceHolder);
    }
};

//Create Presenter Desigination node
SpecialGraphicsSlides.prototype.createPresentorDesignation = function (textParent) {
    let className = this.styleData.fontData.desigination + " ";
    let presenterDesignationNode = this.specialGraphicsUtils.createTextElement(
        textParent,
        this.sgData.creatordesignation,
        "sgPresentorDesiginationNode",
        "presenterDesigination " + className + this.selectionLayerClass + this.moodanimation,
        "creatordesignation"
    );
    presenterDesignationNode.contentEditable = "true";
    presenterDesignationNode.setAttribute("data-prompt-text", this.styleData.presenterDesignationPrompt);
    this.setTextFocus(presenterDesignationNode);
};

//Create Presenter Email node
SpecialGraphicsSlides.prototype.createPresentorEmail = function (textParent) {
    let presenterBase = this.createSocialIconBase(textParent, "Email");
    let className = this.styleData.socialIconClass;
    let createEmailNode = this.specialGraphicsUtils.createTextElement(presenterBase, this.sgData.creatoremail, "sgPresentorEmailNode", "socialIconText " + className, "creatoremail");
    createEmailNode.contentEditable = "true";
    presenterBase.style.display = this.sgData.creatoremail == "" && this.isPlayAnimation == true ? "none" : "flex";
    createEmailNode.setAttribute("data-prompt-text", this.styleData.presenterEmail);
    this.setTextFocus(createEmailNode);
    this.createSocialIconNode(presenterBase);
};

//Create Venue node
SpecialGraphicsSlides.prototype.createVenue = function (textParent) {
    let className = this.styleData.fontData.venue + " ";
    let presenterVenueNode = this.specialGraphicsUtils.createTextElement(
        textParent,
        this.sgData.venue,
        "sgVenueNode",
        "venueText " + className + this.selectionLayerClass + this.moodanimation,
        "venue"
    );
    presenterVenueNode.contentEditable = "true";
    presenterVenueNode.setAttribute("data-prompt-text", this.styleData.venuePrompt);
    this.setTextFocus(presenterVenueNode);
};

//Craete author name node
SpecialGraphicsSlides.prototype.createAuthorName = function (textParent) {
    let className = this.styleData.fontData.authorname + " ";
    let authorNameNode = this.specialGraphicsUtils.createTextElement(
        textParent,
        this.sgData.authorname,
        "sgAuthorNameNode",
        "authorName " + className + this.selectionLayerClass + this.moodanimation,
        "authorname"
    );
    authorNameNode.contentEditable = "true";
    authorNameNode.setAttribute("data-prompt-text", this.styleData.authorNamePrompt);
    this.setTextFocus(authorNameNode);
    return authorNameNode;
};

//Craete author desigination node
SpecialGraphicsSlides.prototype.createAuthorDesignation = function (textParent) {
    let className = this.styleData.fontData.authordesigination + " ";
    let authorDesignationNode = this.specialGraphicsUtils.createTextElement(
        textParent,
        this.sgData.authordesignation,
        "sgAuthorDesignationNode",
        "authorDesignation " + className + this.selectionLayerClass + this.moodanimation,
        "authordesignation"
    );
    authorDesignationNode.contentEditable = "true";
    authorDesignationNode.setAttribute("data-prompt-text", this.styleData.authorDesignationPrompt);
    this.setTextFocus(authorDesignationNode);
    return authorDesignationNode;
};

//Create contact style asset's data here
SpecialGraphicsSlides.prototype.createContactData = function (parent, key, id, prompt) {
    let elmentParent = document.createElement("div");
    elmentParent.id = "sg" + id + "Parent";
    elmentParent.className = id + "Parent";
    this.setTextType(elmentParent);
    parent.appendChild(elmentParent);

    let contactIconNode = document.createElement("div");
    contactIconNode.id = id + "IconNode";
    contactIconNode.className = id + "IconNode" + this.moodanimation + " accent1-fill ";
    elmentParent.appendChild(contactIconNode);

    let textParent = document.createElement("div");
    textParent.id = id + "textParent";
    textParent.className = id + "TextParent";
    this.setTextType(textParent);
    elmentParent.appendChild(textParent);

    let className = " " + this.styleData.fontData.socialicontitle + " ";
    let promptText = document.createElement("div");
    promptText.id = key + "promptText";
    promptText.className = " promptText " + className + this.moodanimation;
    promptText.innerText = prompt;
    this.setTextType(promptText);
    textParent.appendChild(promptText);
    this.specialGraphicsUtils.setOpacityAttribute(promptText);

    let ctextCassName = " " + this.styleData.fontData.socialiconcontent + " ";
    let elementNode = this.specialGraphicsUtils.createTextElement(textParent, this.sgData[key], "sg" + id, id + ctextCassName + this.selectionLayerClass + this.moodanimation, key);
    elementNode.contentEditable = "true";
    elementNode.setAttribute("data-prompt-text", this.styleData[id + "Prompt"]);
    this.setTextFocus(elementNode);
};

// Create Reference style asset's data here
SpecialGraphicsSlides.prototype.createReferenceData = function (parent, key, id, prompt, referenceID = null) {
    let elmentParent = document.createElement("div");
    elmentParent.id = "sg" + id + "Parent";
    elmentParent.className = id + "Parent";
    elmentParent.style.position = "relative";
    this.setTextType(elmentParent);
    parent.appendChild(elmentParent);

    let className = this.styleData.fontData.referencetitle + " ";

    let promptText = this.specialGraphicsUtils.createTextElement(elmentParent, this.sgData[key], referenceID, "promptText " + className + this.selectionLayerClass + this.moodanimation, key);
    promptText.setAttribute("data-prompt-text", this.styleData["referenceHeadPrompt"]);
    promptText.contentEditable = "true";
    this.setTextFocus(promptText);

    let ctextCassName = this.styleData.fontData.referencecontent + " ";
    let elementNode = this.specialGraphicsUtils.createTextElement(
        elmentParent,
        this.sgData["referencesub" + key.replace("reference", "")],
        "sg" + id,
        id + ctextCassName + this.selectionLayerClass + this.moodanimation,
        "referencesub" + key.replace("reference", "")
    );
    elementNode.contentEditable = "true";
    elementNode.setAttribute("data-prompt-text", this.styleData["referencePrompt"]);
    this.setTextFocus(elementNode);
};

//Setting up focus callback
SpecialGraphicsSlides.prototype.focusCallBack = function (event) {
    SpecialGraphicsSlidesBase.prototype.focusCallBack.call(this, event);
};

"use strict";

//Specialgraphics base - all base nodes will create here
function SpecialGraphicsSlidesBase(detailsObject) {
    this.sgParent = detailsObject.sgParent;
    this.sgData = detailsObject.nodesData;
    this.sgSlideType = detailsObject.sgSlideType;
    this.index = detailsObject.index;
    this.styleData = detailsObject.styleData;
    this.moodName = detailsObject.moodName;
    this.arrAssets = detailsObject.arrAssets;
    this.isPlayAnimation = detailsObject.isPlayAnimation;
    this.elementData = detailsObject.textElementData;
    this.textElementData = this.elementData ? this.elementData.elementData : null;
    this.appBaseURL = detailsObject.appBaseURL;
    this.appStaticURL = detailsObject.appStaticURL;
    this.isPresent = detailsObject.isPresent;
    this.isWidget = detailsObject.isWidget;
    this.totalLength = detailsObject.totalLength;
    this.metaData = detailsObject.metaData;
    this.textElementCreationCallBack = detailsObject.textElementCreationCallBack;
    this.fontSizeChangeOnTextChange = detailsObject.fontSizeChangeOnTextChange;
    this.selectionLayerClass = " slideGraphicElementTransformHoverState ";
    this.moodanimation = " moodanimation ";

    this.eventManager = detailsObject.eventManager;
    this.specialGraphicsUtils = detailsObject.specialGraphicsUtils;
    this.specialGraphicsUtils.setAssetType(this.sgSlideType);

    this.focusCallBack = this.focusCallBack.bind(this);
    this.pasteCallBack = this.pasteCallBack.bind(this);
    this.keyUpListener = this.keyUpListener.bind(this);
    this.setTextChangeListner = this.setTextChangeListner.bind(this);

    this.createTextNodes();
    for (let i = 0; i < this.arrAssets.length; i++) {
        let name = "";
        if (this.arrAssets[i].id.includes("skype")) name = "Skype";
        if (this.arrAssets[i].id.includes("twitter")) name = "Twitter";
        if (this.arrAssets[i].id.includes("facebook")) name = "Facebook";
        if (this.arrAssets[i].id.includes("instagram")) name = "Instagram";
        if (this.arrAssets[i].id.includes("linkedin")) name = "Linkedin";
        if (this.arrAssets[i].id.includes("mail")) name = "Email";
        if (this.arrAssets[i].id.includes("phone")) name = "Phone";
        if (this.arrAssets[i].id.includes("home")) name = "Home";
        let contactBase = this.sgParent.querySelector("[id='presenter" + name + "Base']");
        if (contactBase && contactBase.querySelector("[id='socialIconNode']")) contactBase.querySelector("[id='socialIconNode']").innerHTML = this.arrAssets[i].data;
        if (name == "Home" && this.sgParent.querySelector("[id='mailingAddressIconNode']")) this.sgParent.querySelector("[id='mailingAddressIconNode']").innerHTML = this.arrAssets[i].data;
        if (name == "Email" && this.sgParent.querySelector("[id='emailAddressIconNode']")) this.sgParent.querySelector("[id='emailAddressIconNode']").innerHTML = this.arrAssets[i].data;
        if (name == "Phone" && this.sgParent.querySelector("[id='phoneNumberIconNode']")) this.sgParent.querySelector("[id='phoneNumberIconNode']").innerHTML = this.arrAssets[i].data;
    }
}

//Create common base text nodes like title,subtitle,label etc.,
SpecialGraphicsSlidesBase.prototype.createTextNodes = function (event) {
    let innerParent = this.sgParent.querySelector("[id='assetParent" + this.index + "']");
    if (innerParent == null) {
        //Creating main parent for each slides under SVG Div.
        this.innerParent = document.createElement("div");
        this.innerParent.id = "assetParent" + this.index;
        this.setTextType(this.innerParent);

        let styleName = "assetParent";
        let imagestackIntro = (this.sgSlideType == "imagestack" || this.sgSlideType == "textstack") && this.index == 0 && this.totalLength != 1 ? " introSlide " : "";
        this.innerParent.className = styleName + " " + this.styleData.styleName + imagestackIntro;
        this.sgParent.appendChild(this.innerParent);
    } else this.innerParent = innerParent;

    if (this.index != 0) this.innerParent.style.opacity = 0;

    //Creating text nodes
    let textParentNode = this.createTextParent(this.innerParent);
    this.createCoverImageNode(this.innerParent);
    let nodeTitle = this.createTitleTextNode(textParentNode, this.innerParent);
    let nodeSubtitle = this.createSubTitleTextNode(textParentNode, this.innerParent);
    let nodeSlideLabel = this.createTitleLabelTextNode(textParentNode, this.innerParent);
    this.createNumberTextNode(this.innerParent);

    if (this.textElementData && this.textElementData.titlesubtitlelabelgap) {
        //Setting up the title subtitle gap values to elements based on mood
        if (nodeSlideLabel) {
            let titleLabelGap = Number(this.textElementData.titlesubtitlelabelgap[0]);
            nodeSlideLabel.parentElement.style.marginBottom = titleLabelGap + "px";
        }
        if (nodeSubtitle) {
            let titleSubtitleGap = Number(this.textElementData.titlesubtitlelabelgap[1]);
            nodeSubtitle.parentElement.style.marginTop = titleSubtitleGap + "px";
        }
    } else {
        if (nodeSlideLabel) nodeSlideLabel.parentElement.style.removeProperty("margin-bottom");
        if (nodeSubtitle) nodeSubtitle.parentElement.style.removeProperty("margin-top");
    }

    //Create Text Element function
    // setTimeout(() => {
    this.createTextElement();
    // }, 0);
    // Creating extra nodes for coverpage,cta,quote and etc assets.
    this.initCustomData();
};

//Create textparent - it will change depends on component
SpecialGraphicsSlidesBase.prototype.createTextParent = function (parent) {
    // Check and remove old textbase
    let oldTextNaseParent = parent.querySelector("[id='textBaseParentNode']");
    if (oldTextNaseParent) oldTextNaseParent.parentElement.removeChild(oldTextNaseParent);
    //Creating Text parent.
    let textBaseParentNode = document.createElement("div");
    textBaseParentNode.id = "textBaseParentNode";
    textBaseParentNode.className = "textBaseParentNode";
    this.setTextType(textBaseParentNode);
    parent.appendChild(textBaseParentNode);

    if (this.sgSlideType == "imagestack" || this.sgSlideType == "textstack") {
        let textBgColorDiv = document.createElement("div");
        textBgColorDiv.id = "textBgColorDiv";
        this.setTextType(textBgColorDiv);
        let themeColorName = this.moodName == "boldcss" ? "background-bg-color" : "background-bg-color";
        textBgColorDiv.className = "textBgColorDiv " + themeColorName + " " + this.moodanimation;
        textBaseParentNode.appendChild(textBgColorDiv);
        let opacity = parseFloat(window.getComputedStyle(textBgColorDiv)["opacity"]);
        opacity = !opacity || isNaN(opacity) ? 1 : opacity;
        textBgColorDiv.setAttribute("data-opacity", opacity);
        this.specialGraphicsUtils.setOpacityAttribute(textBgColorDiv);
    }

    //Creating Text parent.
    let textParentNode = document.createElement("div");
    textParentNode.id = "textParent";
    this.setTextType(textParentNode);
    textParentNode.className = "textParent";
    textBaseParentNode.appendChild(textParentNode);

    let textInnerParentNode = document.createElement("div");
    textInnerParentNode.id = "textInnerParentNode";
    this.setTextType(textInnerParentNode);
    textInnerParentNode.className = "textInnerParent";
    textParentNode.appendChild(textInnerParentNode);

    return textInnerParentNode;
};

SpecialGraphicsSlidesBase.prototype.getOffsetRectByParent = function (parent, element) {
    let top = element.offsetTop;
    let left = element.offsetLeft;
    let elementParent = element.parentElement;

    while (parent != elementParent) {
        top = top + elementParent.offsetTop;
        left = left + elementParent.offsetLeft;
        elementParent = elementParent.parentElement;
    }

    return { top: top, left: left, width: element.offsetWidth, height: element.offsetHeight };
};

//Positioning the text element
SpecialGraphicsSlidesBase.prototype.textElementPositioning = function (instance = null) {
    let ins = instance ? instance : this;
    if (ins) ins.createTextElement();
};

//Craete text element
SpecialGraphicsSlidesBase.prototype.createTextElement = function () {
    try {
        let isHeroText = this.styleData && this.styleData.styleName && this.styleData.styleName == "herotext" ? true : false;
        if (this.isPresent != true || this.isWidget == true) {
            let assetParent = this.sgParent.querySelector("[id='assetParent" + this.index + "']");
            if ((assetParent && assetParent.classList.contains("introSlide") && isHeroText == true) || isHeroText == false) {
                let textParent = assetParent.querySelector("[id='textParent']");
                let textInnerParentNode = assetParent.querySelector("[id='textInnerParentNode']");

                let titleTextParent = assetParent ? assetParent.querySelector("[id*='titleTextParent']") : null;
                if (titleTextParent) {
                    titleTextParent.style.removeProperty("margin-bottom");
                    titleTextParent.style.removeProperty("margin-top");
                }

                let obj = {};
                obj.isSpecialGraphics = true;
                obj.assetParent = assetParent;
                obj.textParent = textParent;
                obj.textInnerParentNode = textInnerParentNode;
                if (this.textElementCreationCallBack) this.textElementCreationCallBack(obj);
            }
        }
    } catch (error) {
        console.log("SG - Error while creating text element - " + error);
    }
};

//Seting text type to avoid inline floater and selector
SpecialGraphicsSlidesBase.prototype.setTextType = function (element) {
    element.setAttribute("data-type", "TEXT");
    element.setAttribute("data-showselector", "false");
};

//Create coverimage overlay
SpecialGraphicsSlidesBase.prototype.createCoverOverlay = function (parent) {
    let isOverLayDiv = parent.querySelector("[id='coverImageOverlay']");
    if (!isOverLayDiv) {
        let coverImageOverlay = document.createElement("div");
        coverImageOverlay.id = "coverImageOverlay";
        coverImageOverlay.className = "coverImageOverlay";
        coverImageOverlay.style.pointerEvents = "none";
        coverImageOverlay.setAttribute("data-type", "overlay");
        parent.appendChild(coverImageOverlay);
        coverImageOverlay.setAttribute("data-nodetype", "imageOverlay");
    }
};

//Create coverimage background
SpecialGraphicsSlidesBase.prototype.createCoverBackground = function (parent) {
    let coverImageBackground = document.createElement("div");
    coverImageBackground.id = "coverImageBackground";
    coverImageBackground.className = "coverImageBackground " + this.moodanimation;
    coverImageBackground.style.pointerEvents = "none";
    coverImageBackground.setAttribute("data-nodetype", "imageBackground");
    parent.appendChild(coverImageBackground);
};

//Setting up text focus and text paste focus
SpecialGraphicsSlidesBase.prototype.setTextFocus = function (textNode, doFontFit = true) {
    this.eventManager.addEvent(textNode, "focusout", this.focusCallBack);
    this.eventManager.addEvent(textNode, "focusin", this.focusCallBack);
    this.eventManager.addEvent(textNode, "paste", this.pasteCallBack);

    let setListener = true;
    if (this.metaData && this.metaData.text && this.metaData.text.text1 && this.metaData.text.text1.singlecolor) setListener = false;
    if (setListener == true && (textNode.id == "sgTitleNode" || textNode.id == "sgSubTitleNode" || textNode.id == "sgTitleLabelNode")) {
        if (this.styleData.styleName != "herotext") {
            this.eventManager.addEvent(textNode, "keyup", this.keyUpListener);
            this.eventManager.addEvent(textNode, "mouseup", this.keyUpListener);
        }
        this.eventManager.addEvent(textNode, "mouseover", this.focusCallBack);
        this.eventManager.addEvent(textNode, "mouseout", this.focusCallBack);
    }

    if (doFontFit == true) {
        this.eventManager.addObserver(this.setTextChangeListner(textNode));
        textNode.style.removeProperty("font-size");
        this.specialGraphicsUtils.doCheckMaxHeight(textNode, this.sgParent);
        this.specialGraphicsUtils.doFontFitForCss(textNode, this.sgParent);
    }
};

//Creating coverimage node - changing depends on component
SpecialGraphicsSlidesBase.prototype.createCoverImageNode = function (parentNode) {
    let parent = parentNode;
    if (this.sgSlideType == "imagestack") {
        // Check and remove old textbase
        let oldImageParent = parent.querySelector("[id='assetImageParent']");
        if (oldImageParent) oldImageParent.parentElement.removeChild(oldImageParent);

        let assetImageParent = document.createElement("div");
        assetImageParent.id = "assetImageParent";
        assetImageParent.className = "assetImageParent";
        this.setTextType(assetImageParent);
        parentNode.appendChild(assetImageParent);
        parent = assetImageParent;
    }

    let coverImageParent = document.createElement("div");
    coverImageParent.id = "coverImageParent";
    coverImageParent.className = "coverImageParent" + this.selectionLayerClass + this.moodanimation;
    coverImageParent.setAttribute("data-nodetype", "contentContainer");
    parent.appendChild(coverImageParent);

    let coverParentNode = coverImageParent;
    if (this.sgSlideType == "imagestack") {
        let contentBackground = document.createElement("div");
        contentBackground.id = "contentBackground " + this.index;
        contentBackground.className = "contentBackground " + this.moodanimation;
        contentBackground.style.position = "absolute";
        contentBackground.style.pointerEvents = "none";
        contentBackground.style.width = "100%";
        contentBackground.style.height = "100%";
        contentBackground.setAttribute("data-nodetype", "contentBackground");
        coverImageParent.appendChild(contentBackground);

        let coverParent = document.createElement("div");
        coverParent.id = "coverParent" + this.index;
        coverParent.className = "coverParent";
        coverParent.setAttribute("data-nodetype", "imageHolder");
        coverImageParent.appendChild(coverParent);
        coverImageParent.classList.remove("moodanimation");
        coverParentNode = coverParent;
    }
    this.createCoverBackground(coverParentNode);

    let width = parseFloat(window.getComputedStyle(coverImageParent)["width"]);
    let height = parseFloat(window.getComputedStyle(coverImageParent)["height"]);

    var svgElementDiv = document.createElement("div");
    if ((this.sgSlideType == "imagestack" || this.sgSlideType == "sectiontitle") && this.styleData && this.styleData.isSVGAsset != null && this.styleData.isSVGAsset == "true") {
        // This is for change image / icon from inline floater change
        this.sgParent.setAttribute("data-svgsupport", "true");
        //Creating svg node
        svgElementDiv.id = "svgElementDiv";
        svgElementDiv.className = "svgElementDiv accent1-fill";
        svgElementDiv.style.pointerEvents = "none";
        if (this.arrAssets.filter((obj) => obj.id == "svgdata" + this.index).length > 0) svgElementDiv.innerHTML = this.arrAssets.filter((obj) => obj.id == "svgdata" + this.index)[0].data;
        else if (this.arrAssets.filter((obj) => obj.id == "svgdata").length > 0) svgElementDiv.innerHTML = this.arrAssets.filter((obj) => obj.id == "svgdata")[0].data;
        else svgElementDiv.innerHTML = "";
        coverParentNode.appendChild(svgElementDiv);
        if (svgElementDiv.children.length > 0) {
            svgElementDiv.children[0].style.width = "100%";
            svgElementDiv.children[0].style.height = "100%";
        }
        svgElementDiv.style.display = "none";
    } else this.sgParent.setAttribute("data-svgsupport", "false");
    this.sgData.coverimage = this.specialGraphicsUtils.checkAppStaticURLSG(this.sgData.coverimage, this.appStaticURL);
    //Creating Image node
    let coverimage = this.specialGraphicsUtils.createImageElement(coverParentNode, "coverImage", this.index, this.sgData.coverimage, width, height, 0, 0, "coverimage", this.sgData);
    this.specialGraphicsUtils.setOpacityAttribute(coverParentNode);
    coverimage.setAttribute("data-nodetype", "imageNode");
    if ((this.sgData.coverimage.includes("/placeholderimages/") && this.sgParent.getAttribute("data-svgsupport") == "true") || (this.sgData.coverimage.includes(".svg") && this.sgParent.getAttribute("data-svgsupport") == "true")) {
        svgElementDiv.style.display = "block";
        coverimage.style.display = "none";
    }
    this.createCoverOverlay(coverParentNode);

    this.eventManager.addEvent(coverimage, "dblclick", this.imageDoubleClickEvent);

    if (this.isPresent != true && this.sgSlideType == "coverpage" && this.sgData.title.trim().length != 0 && this.sgData.coverimage.includes("placeholderimages/coverimage"))
        this.specialGraphicsUtils.searchImage(this.sgParent, this.appBaseURL, this.sgData.title, null, this);
};
SpecialGraphicsSlidesBase.prototype.imageDoubleClickEvent = function (event) {
    if (this.imageDoubleClickFunctionality) this.imageDoubleClickFunctionality(event.target.id);
};
//Create inner text parent for grouping text elements
SpecialGraphicsSlidesBase.prototype.createTextInnerParentNode = function (parentNode, id) {
    let textInnerParentNode = document.createElement("div");
    textInnerParentNode.id = id;
    this.setTextType(textInnerParentNode);
    textInnerParentNode.className = id + this.selectionLayerClass;
    parentNode.appendChild(textInnerParentNode);

    // let sgDeleteNode = document.createElement("div");
    // sgDeleteNode.id = id == "titleTextParent" ? "sgDeleteNodeTitle" : id == "subTitleTextParent" ? "sgDeleteNodeSubTitle" : "sgDeleteNodeTitleLabel";
    // sgDeleteNode.className = id == "titleTextParent" ? "sgDeleteNodeTitle" : id == "subTitleTextParent" ? "sgDeleteNodeSubTitle" : "sgDeleteNodeTitleLabel";
    // textInnerParentNode.appendChild(sgDeleteNode);
    return textInnerParentNode;
};

//Create title node here
SpecialGraphicsSlidesBase.prototype.createTitleTextNode = function (parentNode, assetParent) {
    let titleTextParent = this.createTextInnerParentNode(parentNode, "titleTextParent");
    let className = " " + this.styleData.fontData.title + " transparentBg ";
    if ((this.sgSlideType == "imagestack" || this.sgSlideType == "textstack") && assetParent && assetParent.classList.contains("introSlide") == true)
        className = (this.styleData.fontData.introtitle ? this.styleData.fontData.introtitle : "h2") + "  secondary-color transparentBg ";
    let titleNode = this.specialGraphicsUtils.createTextElement(titleTextParent, this.sgData.title, "sgTitleNode", "titleNode " + className + this.moodanimation, "title");

    titleNode.innerHTML = this.sgData.title;

    let modifiedString = TextHighLightUtils.highlightToString(titleNode.innerHTML);
    titleNode.innerHTML = modifiedString;
    titleNode.innerText = modifiedString;
    TextHighLightUtils.updateHighlight(titleNode, titleNode.innerHTML);

    titleNode.contentEditable = "true";
    if (this.sgSlideType == "imagestack" || this.sgSlideType == "textstack" || this.styleData.imagestackPosition)
        titleNode.setAttribute("ImagestackPosition", assetParent && assetParent.classList.contains("introSlide") == true ? "textstack" : this.styleData.imagestackPosition);
    let promptText = this.styleData.titlePrompt;
    if ((this.sgSlideType == "imagestack" || this.sgSlideType == "textstack") && assetParent && assetParent.classList.contains("introSlide") == true) promptText = " Click here to edit title ";
    titleNode.setAttribute("data-prompt-text", promptText);
    titleNode.setAttribute("data-animation", "title");
    titleNode.setAttribute("data-index", this.index);
    if (this.styleData.fontfit != null && this.styleData.fontfit != undefined) this.setTextFocus(titleNode, this.styleData.fontfit);
    else this.setTextFocus(titleNode);
    titleNode.setAttribute("data-font", this.styleData.fontData.titleClass ? this.styleData.fontData.titleClass : "h2");
    if (this.styleData.textColor && this.index != 0) titleNode.style.setProperty("color", this.styleData.textColor, "important");

    if (this.sgData["title-user-font-size"]) {
        let oldValue = this.specialGraphicsUtils.getClassNameFromNode(titleNode);
        titleNode.setAttribute("data-defaultclass", oldValue);

        titleNode.setAttribute("user-font-size", this.sgData["title-user-font-size"]);
        this.specialGraphicsUtils.removeAllFontClass(titleNode);
        titleNode.classList.add(this.sgData["title-user-font-size"]);
        // titleNode.style.setProperty("font-size", this.sgData["title-user-font-size"] + "px", "important");
    }
    return titleNode;
};

//Create subtitle node here
SpecialGraphicsSlidesBase.prototype.createSubTitleTextNode = function (parentNode, assetParent) {
    let subTitleTextParent = this.createTextInnerParentNode(parentNode, "subTitleTextParent");
    let className = " " + this.styleData.fontData.subtitle + " transparentBg ";
    if ((this.sgSlideType == "imagestack" || this.sgSlideType == "textstack") && assetParent && assetParent.classList.contains("introSlide") == true)
        className = (this.styleData.fontData.introsubtitle ? this.styleData.fontData.introsubtitle : "p1") + "  tertiary-color transparentBg ";
    let subTitleNode = this.specialGraphicsUtils.createTextElement(subTitleTextParent, this.sgData.subtitle, "sgSubTitleNode", "subTitleNode " + className + this.moodanimation, "subtitle");
    subTitleNode.contentEditable = "true";
    let promptText = this.styleData.subTitlePrompt;
    if ((this.sgSlideType == "imagestack" || this.sgSlideType == "textstack") && assetParent && assetParent.classList.contains("introSlide") == true) promptText = " Click here to edit subtitle ";
    subTitleNode.setAttribute("data-prompt-text", promptText);
    if (this.sgSlideType == "imagestack" || this.sgSlideType == "textstack" || this.styleData.imagestackPosition)
        subTitleNode.setAttribute("ImagestackPosition", assetParent && assetParent.classList.contains("introSlide") == true ? "textstack" : this.styleData.imagestackPosition);
    this.setTextFocus(subTitleNode);
    subTitleNode.setAttribute("data-animation", "subtitle");
    subTitleNode.setAttribute("data-index", this.index);
    subTitleNode.setAttribute("data-font", this.styleData.fontData.subtitleClass ? this.styleData.fontData.subtitleClass : "p2");
    if (this.styleData.textColor && this.index != 0) subTitleNode.style.setProperty("color", this.styleData.textColor, "important");
    if (this.sgData["subtitle-user-font-size"]) {
        let oldValue = this.specialGraphicsUtils.getClassNameFromNode(subTitleNode);
        subTitleNode.setAttribute("data-defaultclass", oldValue);

        subTitleNode.setAttribute("user-font-size", this.sgData["subtitle-user-font-size"]);
        this.specialGraphicsUtils.removeAllFontClass(subTitleNode);
        subTitleNode.classList.add(this.sgData["subtitle-user-font-size"]);
        // subTitleNode.style.setProperty("font-size", this.sgData["subtitle-user-font-size"] + "px", "important");
    }
    return subTitleNode;
};

//Create titlelabel node here
SpecialGraphicsSlidesBase.prototype.createTitleLabelTextNode = function (parentNode, assetParent) {
    let titleLabelTextParent = this.createTextInnerParentNode(parentNode, "titleLabelTextParent");
    let className = " " + this.styleData.fontData.label + " transparentBg ";
    if ((this.sgSlideType == "imagestack" || this.sgSlideType == "textstack") && assetParent && assetParent.classList.contains("introSlide") == true)
        className = (this.styleData.fontData.introlabel ? this.styleData.fontData.introlabel : "p1") + "  theme-color transparentBg ";
    let titleLabelNode = this.specialGraphicsUtils.createTextElement(titleLabelTextParent, this.sgData.titlelabel, "sgTitleLabelNode", "titleLabelNode " + className + this.moodanimation, "titlelabel");
    titleLabelNode.contentEditable = "true";
    let promptText = this.styleData.titleLabelPrompt;
    if ((this.sgSlideType == "imagestack" || this.sgSlideType == "textstack") && assetParent && assetParent.classList.contains("introSlide") == true) promptText = " Click here to edit label ";
    titleLabelNode.setAttribute("data-prompt-text", promptText);
    if (this.sgSlideType == "imagestack" || this.sgSlideType == "textstack" || this.styleData.imagestackPosition)
        titleLabelNode.setAttribute("ImagestackPosition", assetParent && assetParent.classList.contains("introSlide") == true ? "textstack" : this.styleData.imagestackPosition);
    this.setTextFocus(titleLabelNode);
    titleLabelNode.setAttribute("data-animation", "label");
    titleLabelNode.setAttribute("data-index", this.index);
    titleLabelNode.setAttribute("data-font", this.styleData.fontData.labelClass ? this.styleData.fontData.labelClass : "p2");
    if (this.styleData.textColor && this.index != 0) titleLabelNode.style.setProperty("color", this.styleData.textColor, "important");
    if (this.sgData["titlelabel-user-font-size"]) {
        let oldValue = this.specialGraphicsUtils.getClassNameFromNode(titleLabelNode);
        titleLabelNode.setAttribute("data-defaultclass", oldValue);

        titleLabelNode.setAttribute("user-font-size", this.sgData["titlelabel-user-font-size"]);
        this.specialGraphicsUtils.removeAllFontClass(titleLabelNode);
        titleLabelNode.classList.add(this.sgData["titlelabel-user-font-size"]);
        // titleLabelNode.style.setProperty("font-size", this.sgData["titlelabel-user-font-size"] + "px", "important");
    }
    return titleLabelNode;
};

//Create number node
SpecialGraphicsSlidesBase.prototype.createNumberTextNode = function (parentNode) {
    let oldNumberNode = parentNode.querySelector("[id='sgNumberTextNode']");
    if (oldNumberNode) oldNumberNode.parentElement.removeChild(oldNumberNode);

    let numberParent = document.createElement("div");
    numberParent.id = "sgNumberTextParent";
    numberParent.className = "sgNumberTextParent clsSeqTitleParent " + this.moodanimation;
    this.setTextType(numberParent);
    parentNode.appendChild(numberParent);

    let className = " " + this.styleData.fontData.number + " clsSeqText ";
    let textNumber = this.sgData.numbertext.length > 2 ? this.sgData.numbertext.substring(1, 3) : this.sgData.numbertext;
    textNumber = parseInt(textNumber) < 10 ? textNumber.replace("0", "") : textNumber;
    if (this.moodName == "minimalcss" || this.moodName == "keynotecss" || this.moodName == "bubblecss" || this.moodName == "elegantcss") textNumber = parseInt(textNumber) > 9 ? textNumber : "0" + textNumber;
    let numberNode = this.specialGraphicsUtils.createTextElement(numberParent, textNumber, "sgNumberTextNode", "numberTextNode " + className, "numbertext");
    numberNode.contentEditable = "false";
    numberNode.style.pointerEvents = "none";
    if (numberNode.contentEditable != "false") this.setTextFocus(numberNode, false);

    let opacity = parseFloat(window.getComputedStyle(numberNode)["opacity"]);
    opacity = !opacity || isNaN(opacity) ? 1 : opacity;
    numberNode.setAttribute("data-opacity", opacity);
    if (this.styleData.textColor && this.styleData.textColor == "black" && this.index != 0) numberNode.style.setProperty("color", "rgba(var(--tertiary-color-rgb),1)", "important");
    else if (this.styleData.textColor && this.index != 0) numberNode.style.setProperty("color", this.styleData.textColor, "important");
};

//Paste callback for text elements
SpecialGraphicsSlidesBase.prototype.pasteCallBack = function (event) {
    event.preventDefault();
    let strUnformattedText = event.clipboardData.getData("text/plain");
    document.execCommand("insertText", false, strUnformattedText);

    this.specialGraphicsUtils.doFontFitForCss(event.target, this.sgParent);
};

//text focusin//focusout callback
SpecialGraphicsSlidesBase.prototype.focusCallBack = function (event) {
    let element = event.target;
    if (element && event.type == "mouseover") {
        let node = element;
        if (element.tagName.toLocaleLowerCase() == "span" || element.tagName.toLocaleLowerCase() == "p") {
            if (element.parentElement.tagName.toLocaleLowerCase() == "div") node = element.parentElement;
            else if (element.parentElement.parentElement && element.parentElement.parentElement.tagName.toLocaleLowerCase() == "div") node = element.parentElement.parentElement;
        }
        this.showHideAddButtons(node, this.sgParent);
    } else if (event.type == "mouseout") {
    } else if (event.type == "focusout") {
        var oldText = element.getAttribute("data-heading") ? element.getAttribute("data-heading") : "";
        let isMannualFocusOut = element.hasAttribute("focusout") && element.getAttribute("focusout") == "mannual" ? true : false;
        if (oldText != element.innerHTML && oldText != element.innerText && isMannualFocusOut == false) {
            element.setAttribute("data-heading", element.innerHTML);
            // this.eventManager.dispatch("textchangecallback", element.innerText, element.id);
            this.eventManager.dispatch("textchangecallback", element.innerHTML, element.id, element.hasAttribute("data-index") ? element.getAttribute("data-index") : -1);
            if (element.innerHTML.trim().length == 0) {
                let content = this.specialGraphicsUtils.getHeroTextDefaultContent(element);
                if (content) {
                    element.setAttribute("data-heading", content);
                    element.innerText = content;
                }
            }
            // if (element.innerHTML.includes("<br>") || element.innerHTML.includes("\n")) element.style.whiteSpace = "pre";
            // else element.style.removeProperty("white-space");
        }
        element.scrollTop = 0;
        if (element.getElementsByTagName("ul").length > 0) element.getElementsByTagName("ul")[0].scrollTop = 0;
        if (element.innerText == "" || element.innerText == "<br>" || element.innerHTML == "<br>" || element.innerText == "\n") element.innerText = "";
    } else if (event.type == "focusin") {
        element.setAttribute("data-oldtext", element.innerHTML);
        element.removeAttribute("data-changetext");
        // this.showHideAddButtons(element, this.sgParent);
    }
    if (element.id == "sgTitleNode" || element.id == "sgSubTitleNode" || element.id == "sgTitleLabelNode") {
        // if (event.type == "focusin") element.style.removeProperty("max-height");
        // else
        // if (element.onTextUpdate && event.type == "focusout") element.onTextUpdate(element);
        if (
            element.parentElement &&
            element.parentElement.parentElement &&
            element.parentElement.parentElement.parentElement &&
            element.parentElement.parentElement.parentElement &&
            element.parentElement.parentElement.parentElement.parentElement
        ) {
            if (event.type == "focusin") element.parentElement.parentElement.parentElement.parentElement.style.overflow = "hidden";
            else element.parentElement.parentElement.parentElement.parentElement.style.removeProperty("overflow");
        }
    } else if (event.type == "focusout") {
        element.scrollTop = 0;
        if (element.getElementsByTagName("ul").length > 0) element.getElementsByTagName("ul")[0].scrollTop = 0;
    }
};

SpecialGraphicsSlidesBase.prototype.keyUpListener = function (event) {
    this.eventManager.dispatch("keyup", event);
};

//Setting up Text change listener
SpecialGraphicsSlidesBase.prototype.setTextChangeListner = function (element) {
    if (element) {
        var config = {
            subtree: true,
            characterData: true,
            childList: true,
        };
        var callback = function (mutations) {
            if (element.hasAttribute("data-mutation") == false) {
                element.style.removeProperty("white-space");
                this.specialGraphicsUtils.mutationCallBack(mutations, element);
                let isCoverNumber2 = this.styleData.styleName.includes("thingstodostyle") ? true : false;
                if (this.sgSlideType == "coverpage" && element.innerText.length > (isCoverNumber2 == true ? 2 : 4) && element.dataset.cssslide && element.dataset.cssslide.includes("covernumber")) {
                    element.innerHTML = element.innerText.substring(0, isCoverNumber2 == true ? 2 : 4);

                    var range, selection;
                    if (document.createRange) {
                        //This will used to trim the text to particular length
                        //Firefox, Chrome, Opera, Safari, IE 9+
                        range = document.createRange(); //Create a range (a range is a like the selection but invisible)
                        range.selectNodeContents(element); //Select the entire contents of the element with the range
                        range.collapse(false); //collapse the range to the end point. false means collapse to end rather than the start
                        selection = window.getSelection(); //get the selection object (allows you to change selection)
                        selection.removeAllRanges(); //remove any selections already made
                        selection.addRange(range); //make the range you have just created the visible selection
                    }
                }

                if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(element);

                let isChangingText = !element.hasAttribute("data-changetext") || (element.hasAttribute("data-changetext") && element.getAttribute("data-changetext") != "true") ? false : true;

                if (element.onTextChange && (element.id == "sgTitleNode" || element.id == "sgSubTitleNode") && isChangingText == false) element.onTextChange(element);
                else if (element.herotextcallback) element.herotextcallback(element, false);
                else this.specialGraphicsUtils.doFontFitForCss(element, this.sgParent, null, this.textElementPositioning, this);
                this.createTextElement();
                // if (isChangingText == false) {
                //     this.showHideAddButtons(element, this.sgParent);
                //     element.removeAttribute("data-changetext");
                // }
                if (element.textChange) element.textChange(element);
            } else element.removeAttribute("data-mutation");
        };
        let observer = new MutationObserver(callback.bind(this));
        observer.observe(element, config);
        return observer;
    }
};

SpecialGraphicsSlidesBase.prototype.showHideAddButtons = function (element, parent) {
    if (element.id == "sgTitleNode" || element.id == "sgSubTitleNode" || element.id == "sgTitleLabelNode") {
        let textParent = element.parentElement.parentElement;
        textParent = !textParent ? parent : textParent;
        let subtitleNode = textParent ? textParent.querySelector("[id='sgSubTitleNode']") : null;
        subtitleNode = !subtitleNode && parent ? parent.querySelector("[id='sgSubTitleNode']") : subtitleNode;
        let titleLabelNode = textParent ? textParent.querySelector("[id='sgTitleLabelNode']") : null;
        titleLabelNode = !titleLabelNode && parent ? parent.querySelector("[id='sgTitleLabelNode']") : titleLabelNode;

        let obj = {};
        obj.hasSubtitle = subtitleNode && subtitleNode.style.display == "none" ? false : true;
        obj.hasLabel = titleLabelNode && titleLabelNode.style.display == "none" ? false : true;
        obj.targetNode = element.parentElement;
        obj.isTitleNode = element.id == "sgTitleNode" ? true : false;
        obj.slidetype = this.sgSlideType;
        obj.hasPlaceholder = true;
        obj.hasCtaButton = true;

        this.eventManager.dispatch("positionAddControlButtonsSG", obj);
    }
};

"use strict";

function EventManager() {
    this.events = [];
    this.observers = [];
    this.eventListeners = [];
}

EventManager.prototype.constructor = EventManager;

EventManager.prototype.addListener = function (event, callback) {
    if (typeof callback !== "function") {
        if (callback) console.log(`The listener callback must be a function, the given type is ${typeof callback}`);
        return false;
    }
    if (typeof event !== "string") {
        if (callback) console.log(`The event name must be a string, the given type is ${typeof event}`);
        return false;
    }
    if (this.eventListeners[event] === undefined) {
        this.eventListeners[event] = {
            listeners: [],
        };
    }
    this.eventListeners[event].listeners.push(callback);
};

EventManager.prototype.removeListener = function (event, callback) {
    if (this.eventListeners[event] === undefined) {
        console.log(`This event: ${event} does not exist`);
        return false;
    }

    this.eventListeners[event].listeners = this.eventListeners[event].listeners.filter((listener) => {
        return listener.toString() !== callback.toString();
    });
};

EventManager.prototype.dispatch = function (event, details, data1, data2) {
    if (this.eventListeners[event] === undefined) {
        // if (event) console.log(`This event: ${event} does not exist`);
        return false;
    }
    this.eventListeners[event].listeners.forEach((listener) => {
        listener(details, data1, data2);
    });
};

EventManager.prototype.addEvent = function (noddeItem, eventName, invokeMethod) {
    noddeItem.addEventListener(eventName, invokeMethod);
    this.events.push({ noddeItem: noddeItem, eventName: eventName, invokeMethod: invokeMethod });
};

EventManager.prototype.removeEvent = function (noddeItem, eventName) {
    for (let i = 0; i < this.events.length; i++) {
        if (this.events[i].noddeItem == noddeItem && this.events[i].eventName == eventName) {
            let noddeItem = this.events[i].noddeItem;
            noddeItem.removeEventListener(this.events[i].eventName, this.events[i].invokeMethod);
            this.events.splice(i, 1);
            break;
        }
    }
};

EventManager.prototype.clear = function () {
    // while (this.events.length > 0) {
    //     let noddeItem = this.events[0].noddeItem;
    //     noddeItem.removeEventListener(this.events[0].eventName, this.events[0].invokeMethod);
    //     this.events.splice(0, 1);
    // }

    for (let i = 0; i < this.events.length; i++) {
        try {
            let event = this.events[i];
            let noddeItem = event.noddeItem;
            noddeItem.removeEventListener(event.eventName, event.invokeMethod);
            $(noddeItem).off();
        } catch (error) {}
    }

    while (this.observers.length > 0) {
        if (this.observers[0]) this.observers[0].disconnect();
        this.observers.splice(0, 1);
    }

    while (this.eventListeners.length > 0) {
        this.eventListeners.splice(0, 1);
    }
};

EventManager.prototype.addObserver = function (observer) {
    this.observers.push(observer);
};

EventManager.prototype.removeObserver = function (observer) {
    if (observer) observer.disconnect();
};

"use strict";

function SGBaseClass(sgParent, sgData = null, moodName = "simplecss", metaData = null, styleName = null, isPlayAnimation = true, textElement = null, socialData = null, fontData = null, slideType = "textstack", styleData = null, objDataToSG = null) {
    //This is test code updated on 29th may for GULP check. - balakumar
    this.sgParent = sgParent;
    this.sgParent.style.opacity = 1;
    this.sgData = sgData;
    this.moodName = moodName;
    this.metaData = metaData;
    this.styleName = styleName;
    this.isPlayAnimation = isPlayAnimation;
    this.socialiconsData = socialData;
    this.styleData = styleData;
    this.fontData = fontData;
    this.textElement = textElement;
    this.objDataToSG = objDataToSG;
    this.slideContent = objDataToSG && objDataToSG.slide ? objDataToSG.slide : null;

    this.titleClass = " h4 secondary-color ";
    this.subTitleClass = " p3 tertiary-color ";
    this.titleLabelClass = " p3 theme-color ";
    this.numberClass = " n1 tertiary-color ";

    this.specialGraphicsUtils = new window["SpecialGraphicsUtils"]();
    this.specialGraphicsUtils.setAssetType(slideType);
    this.specialGraphicsAnimationUtils = new window["SpecialGraphicsAnimationUtils"]();
    this.assetLoader = new window["SGAssetLoader"]();
    this.eventManager = new window["EventManager"]();
    // this.getMapLink = this.getMapLink.bind(this);
    this.updateAeNode = this.updateAeNode.bind(this);
    this.pasteCallBack = this.pasteCallBack.bind(this);
    this.focusCallBack = this.focusCallBack.bind(this);
    this.keyUpListener = this.keyUpListener.bind(this);
    this.lottieLoadCallback = this.lottieLoadCallback.bind(this);
    this.ratingStarClickEvent = this.ratingStarClickEvent.bind(this);
    this.imageDoubleClickEvent = this.imageDoubleClickEvent.bind(this);
    this.textElementPositioning = this.textElementPositioning.bind(this);
    this.highlightCompleteCallback = this.highlightCompleteCallback.bind(this);
    this.doFontFitFromTextSizeChange = this.doFontFitFromTextSizeChange.bind(this);
    // this.applyContrastOnMapTypeChange = this.applyContrastOnMapTypeChange.bind(this);
    this.onTextChangeUpdatePlaceholderNode = this.onTextChangeUpdatePlaceholderNode.bind(this);
    this.specialGraphicsCreationComplete = this.specialGraphicsCreationComplete.bind(this);
    this.currentNodeIndex = 1;

    this.selectionLayerClass = " ";
    // this.selectionLayerClass = " slideGraphicElementTransformHoverState ";
    this.moodanimation = " moodanimation ";

    let styleClass = this.sgParent.querySelector("[id='CssAnimStyle']");
    if (!styleClass) {
        var style = document.createElement("style");
        style.id = "CssAnimStyle";
        this.sgParent.appendChild(style);
    }

    if (metaData && metaData.moodAnimation) sgParent.setAttribute("data-customtransition", metaData.moodAnimation);
    else sgParent.setAttribute("data-customtransition", "");
}

SGBaseClass.prototype.initSpecialGraphicsCreation = function () {};

//Completion of All slide
SGBaseClass.prototype.specialGraphicsCreationComplete = function () {
    if (window.location.hostname == "localhost") console.log("Render Complete");
    this.sgParent.style.opacity = 1;

    if (this.reBuildSectiontitleCallback && this.sgSlideType == "sectiontitle") this.reBuildSectiontitleCallback();
    if (this.isPresent == false && this.reApplyHighlightStyle) this.reApplyHighlightStyle(this.sgParent);

    if (this.completeCallBack && this.completeCallBack.func) {
        this.completeCallBack.func(this.completeCallBack.params);
        this.completeCallBack = null;
    }
    if (this.rebuildCompleteCallBack && this.rebuildCompleteCallBack.func) {
        this.rebuildCompleteCallBack.func(this.rebuildCompleteCallBack.params);
        this.rebuildCompleteCallBack = null;
    }
};

SGBaseClass.prototype.floaterNavigation = function (index) {};

SGBaseClass.prototype.gotoAndStopFirstNode = function (completeCallback) {
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager);
};

SGBaseClass.prototype.hideAnimation = function (completeCallback) {
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", completeCallback, this.isPlayAnimation, this.eventManager);
};
SGBaseClass.prototype.next = function (completeCallback) {};

SGBaseClass.prototype.previous = function (completeCallback) {};

SGBaseClass.prototype.changeVariation = function (slideDomContentGroup) {};

SGBaseClass.prototype.changeText = function (updatedText, elementId, targetIndex, textType) {};

//Adding listeners in event manager
SGBaseClass.prototype.addListener = function (event, callback) {
    this.eventManager.addListener(event, callback);
};

//Removing listeners in event manager
SGBaseClass.prototype.removeListener = function (event, callback) {
    this.eventManager.removeListener(event, callback);
};

//Clear all the listeners and callbacks - ABORT method
SGBaseClass.prototype.clearListener = function (removeCallback = true) {
    this.eventManager.clear();
    if (removeCallback) this.completeCallBack = null;
};

//Create text nodes common method
SGBaseClass.prototype.createTextInnerParentNode = function (id, parent) {
    let textInnerParentNode = document.createElement("div");
    textInnerParentNode.id = id;
    this.setTextType(textInnerParentNode);
    textInnerParentNode.className = id;
    parent.appendChild(textInnerParentNode);
    return textInnerParentNode;
};

//Paste callback for text elements
SGBaseClass.prototype.pasteCallBack = function (event) {
    event.preventDefault();
    let strUnformattedText = event.clipboardData.getData("text/plain");
    document.execCommand("insertText", false, strUnformattedText);

    this.specialGraphicsUtils.doCheckMaxHeight(event.target, this.sgParent);
    this.specialGraphicsUtils.doFontFitForCss(event.target, this.sgParent);
};

//text focusin//focusout callback
SGBaseClass.prototype.focusCallBack = function (event) {
    let element = event ? event.target : null;
    if (element && event.type == "mouseover") {
        if (element && !element.hasAttribute("data-agendaindex")) {
            if (element.tagName.toLocaleLowerCase() == "span" || element.tagName.toLocaleLowerCase() == "p") {
                if (element.parentElement.tagName.toLocaleLowerCase() == "div") element = element.parentElement;
                else if (element.parentElement.parentElement && element.parentElement.parentElement.tagName.toLocaleLowerCase() == "div") element = element.parentElement.parentElement;
            }
            this.showHideAddButtons(element, this.sgParent);
        }
    } else if (event.type == "mouseout") {
    } else if (element && event.type == "focusout") {
        var oldText = element.getAttribute("data-heading") ? element.getAttribute("data-heading") : "";
        element = this.getTargetElementIfList(element);

        let istextchangingonnode = element.hasAttribute("istextchangingonnode");
        // console.log("SGGG = istextchangingonnode = " + istextchangingonnode);
        element.removeAttribute("istextchangingonnode");

        oldText = element.id.includes("sgSubTitleNode") && element.hasAttribute("data-oldtext") ? element.getAttribute("data-oldtext") : oldText;
        let isMannualFocusOut = element.hasAttribute("focusout") && element.getAttribute("focusout") == "mannual" ? true : false;
        if (oldText != element.innerHTML && isMannualFocusOut == false && istextchangingonnode) {
            // if (this.fontSizeChangeOnTextChange && !element.id.includes("phTextNode")) this.fontSizeChangeOnTextChange(element);
            if (this.doCheckTextLineHeightDiff) this.doCheckTextLineHeightDiff(element);
            // if (this.onTextChangeUpdate) this.onTextChangeUpdate(element);
            element.setAttribute("data-heading", element.innerText);
            this.eventManager.dispatch("textchangecallback", element.innerHTML, element.id, element.hasAttribute("data-index") ? element.getAttribute("data-index") : -1);
        }
        if (element.hasAttribute("data-formatted")) {
            let formattedInd = element.getAttribute("data-formatted");
            var lastChar = element.innerHTML.substr(element.innerHTML.length - formattedInd.length);
            // console.log("SGG - lastChar = " + lastChar);
            if (lastChar != formattedInd) element.innerHTML = element.innerHTML + element.getAttribute("data-formatted");
        }
        let isSubtitle = element.id.includes("sgSubTitleNode");
        if (!isSubtitle && (element.innerText == "" || element.innerText == "<br>" || element.innerHTML == "<br>" || element.innerText == "\n")) element.innerText = "";
        if (oldText != element.innerHTML && !element.hasAttribute("dofocusout") && !element.id.includes("phTextNode")) this.specialGraphicsUtils.doFontFitForCss(element, this.sgParent, null, this.textElementPositioning, this);
        //Check max width and set it to all tetx elements
        if (this.textMaxWidthCheck) this.textMaxWidthCheck();

        let elementStyle = window.getComputedStyle(element);
        if (elementStyle["white-space"] == "nowrap") element.scrollLeft = 0;

        if (element.getElementsByTagName("ul").length > 0) {
            let ulNode = element.getElementsByTagName("ul")[0];
            if (ulNode?.getElementsByTagName("li").length > 0) {
                let liNode = ulNode.getElementsByTagName("li")[0];
                if (liNode) {
                    let lineheight = window.getComputedStyle(liNode)["line-height"];
                    ulNode.style.setProperty("--subTitleHolderMH", lineheight);
                }
            }
        }

        if (element.hasAttribute("rotatednode") || elementStyle?.["white-space"] == "nowrap") element.scrollLeft = 0;
        else {
            element.scrollTop = 0;
            if (element.id.includes("imageCaption")) element.scrollLeft = 0;
            if (element.getElementsByTagName("ul").length > 0) element.getElementsByTagName("ul")[0].scrollTop = 0;
        }
        if (element.id.includes("sgreferenceLink") && this.sgParent && this.sgParent.querySelector("[id='referenceParent']")) {
            let lh = parseFloat(elementStyle["line-height"]);
            this.sgParent.querySelector("[id='referenceParent']").style.setProperty("--minH", lh + "px");
        }
    } else if (element && event.type == "focusin") {
        element = this.getTargetElementIfList(element);

        element.setAttribute("data-oldtext", element.innerHTML);
        element.removeAttribute("focusout");
        element.removeAttribute("istextchangingonnode");
        element.removeAttribute("data-changetext");
        if (element.hasAttribute("data-formatted")) {
            let formattedInd = element.getAttribute("data-formatted");
            var lastChar = element.innerHTML.substr(element.innerHTML.length - formattedInd.length);
            // console.log("SGG - lastChar = " + lastChar);
            if (lastChar == formattedInd) element.innerHTML = element.innerHTML.slice(0, -formattedInd.length);
        }
    }
    if ((element.id == "sgTitleNode" || element.id == "sgSubTitleNode" || element.id == "sgTitleLabelNode") && (event.type == "focusin" || event.type == "focusout")) {
        if (element.parentElement && element.parentElement.parentElement && element.parentElement.parentElement.parentElement && element.parentElement.parentElement.parentElement && element.parentElement.parentElement.parentElement.parentElement) {
            if (event.type == "focusin") element.parentElement.parentElement.parentElement.parentElement.style.overflow = "hidden";
            else element.parentElement.parentElement.parentElement.parentElement.style.removeProperty("overflow");
        }
    } else if (element && event.type == "focusout") {
        if (element.hasAttribute("rotatednode")) element.scrollLeft = 0;
        else {
            element.scrollTop = 0;
            if (element.getElementsByTagName("ul").length > 0) element.getElementsByTagName("ul")[0].scrollTop = 0;
        }
    }
};

SGBaseClass.prototype.getTargetElementIfList = function (element) {
    if (!element) return element;
    let isListedNode = element && (element.tagName.toLocaleLowerCase() == "ul" || element.tagName.toLocaleLowerCase() == "li" || element.id.includes("sgSubTitleNode"));
    if (isListedNode && element && element.tagName.toLocaleLowerCase() == "ul") element = element.parentElement;
    if (isListedNode && element && element.tagName.toLocaleLowerCase() == "li") element = element.parentElement.parentElement;
    return element;
};
SGBaseClass.prototype.removeHighlightFocus = function (assetParent, textNode) {
    let doHighlight = assetParent && assetParent.hasAttribute("highlight") && assetParent.getAttribute("highlight") == "false" ? false : true;
    if (doHighlight == false && textNode) {
        this.eventManager.removeEvent(textNode, "keyup");
        this.eventManager.removeEvent(textNode, "mouseup");
    }
};

//Setting up text focus and text paste focus
SGBaseClass.prototype.setTextFocus = function (textNode, doFontFit = true, assetParent = null, addObserver = false) {
    if (!textNode) return;
    textNode.setAttribute("listener", "true");

    this.eventManager.addEvent(textNode, "focusout", this.focusCallBack);
    this.eventManager.addEvent(textNode, "focusin", this.focusCallBack);
    this.eventManager.addEvent(textNode, "paste", this.pasteCallBack);

    let doHighlight = assetParent && assetParent.hasAttribute("highlight") && assetParent.getAttribute("highlight") == "false" ? false : true;
    // if (textNode.id.includes("sgTitleNode") || textNode.id.includes("sgSubTitleNode") || textNode.id.includes("sgTitleLabelNode")) {
    if (doHighlight) {
        this.eventManager.addEvent(textNode, "keyup", this.keyUpListener);
        this.eventManager.addEvent(textNode, "mouseup", this.keyUpListener);
        this.eventManager.addEvent(textNode, "keydown", this.keyDownListener);
        textNode.setAttribute("resetlistener", "true");
    }
    this.eventManager.addEvent(textNode, "mouseover", this.focusCallBack);
    this.eventManager.addEvent(textNode, "mouseout", this.focusCallBack);
    // }

    if (addObserver) this.eventManager.addObserver(this.setTextChangeListner(textNode));
    if (doFontFit == true) {
        this.eventManager.addObserver(this.setTextChangeListner(textNode));
        textNode.style.removeProperty("font-size");
        this.specialGraphicsUtils.doFontFitForCss(textNode, this.sgParent);
    }
};

SGBaseClass.prototype.resetListener = function (textNode) {
    this.setTextFocus(textNode);
};

SGBaseClass.prototype.keyUpListener = function (event) {
    this.eventManager.dispatch("keyup", event);
};

SGBaseClass.prototype.keyDownListener = function (event) {
    let element = event ? event.target : null;
    if (element && event.type == "keydown" && element.tagName.toLocaleLowerCase() == "div") {
        let key = event.keyCode || event.charCode;
        if (key == 13) {
            document.execCommand("insertLineBreak");
            event.preventDefault();
        }
    }
};

SGBaseClass.prototype.showHideAddButtons = function (ele, parent, returnData = false) {
    let element = this.getTargetElementIfList(ele);
    if (element.id.includes("sgTitleNode") || element.id.includes("sgSubTitleNode") || element.id.includes("sgTitleLabelNode")) {
        let textParent = element.parentElement.parentElement;
        textParent = !textParent ? parent : textParent;
        let subtitleNode = textParent ? textParent.querySelector("[id*='sgSubTitleNode']") : null;
        if (!subtitleNode && this.getTargetElement) subtitleNode = this.getTargetElement("sgSubTitleNode");
        subtitleNode = !subtitleNode && parent ? parent.querySelector("[id*='sgSubTitleNode']") : subtitleNode;
        let titleLabelNode = textParent ? textParent.querySelector("[id*='sgTitleLabelNode']") : null;
        if (!titleLabelNode && this.getTargetElement) titleLabelNode = this.getTargetElement("sgTitleLabelNode");
        titleLabelNode = !titleLabelNode && parent ? parent.querySelector("[id*='sgTitleLabelNode']") : titleLabelNode;

        let obj = {};
        obj.hasSubtitle = subtitleNode && (subtitleNode.style.display == "none" || subtitleNode.parentElement.style.display == "none") ? false : true;
        obj.hasLabel = titleLabelNode && (titleLabelNode.style.display == "none" || titleLabelNode.parentElement.style.display == "none") ? false : true;
        obj.targetNode = element.parentElement;
        obj.isTitleNode = element.id.includes("sgTitleNode") ? true : false;
        obj.slidetype = this.sgSlideType;
        if (this.sgSlideType && this.sgSlideType == "quote") {
            obj.hasLabel = true;
            obj.hasSubtitle = true;
        }
        let assetParent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
        if (this.sgParent.querySelector("[id='lytAssetTextParent" + (this.currentNodeIndex - 1) + "']")) assetParent = this.sgParent.querySelector("[id='lytAssetTextParent" + (this.currentNodeIndex - 1) + "']");
        if (assetParent && assetParent.querySelector("[id*='placeHolderParent']")) {
            let holderNode = assetParent.querySelector("[id*='placeHolderParent']");
            obj.hasPlaceholder = holderNode.style.display == "none" ? false : true;
        } else obj.hasPlaceholder = true;
        if (assetParent && assetParent.querySelector("[id*='ctaButtonParent']")) {
            let holderNode = assetParent.querySelector("[id*='ctaButtonParent']");
            obj.hasCtaButton = holderNode.style.display == "none" ? false : true;
        } else obj.hasCtaButton = true;
        if (this.carouselType && this.carouselType == "type9" && element.id.includes("sgTitleNode0")) {
            obj.hasPlaceholder = true;
            obj.hasCtaButton = true;
        }
        if (returnData) return obj;
        else this.eventManager.dispatch("positionAddControlButtonsSG", obj);
    }
};

SGBaseClass.prototype.setTextChangeListner = function (element) {
    if (element) {
        var config = {
            subtree: true,
            characterData: true,
            childList: true,
        };
        var callback = function (mutations) {
            if (element.hasAttribute("data-mutation") == false) {
                // element.style.removeProperty("white-space");
                this.specialGraphicsUtils.mutationCallBack(mutations, element);
                let isCoverNumber = element.hasAttribute("data-limit") ? true : false;
                let length = isCoverNumber == true ? parseFloat(element.getAttribute("data-limit")) : -1;
                if (length > 0 && element.innerText.length > length && element.dataset.cssslide && element.dataset.cssslide.includes("covernumber")) {
                    element.innerHTML = element.innerText.substring(0, length);

                    var range, selection;
                    if (document.createRange) {
                        //Firefox, Chrome, Opera, Safari, IE 9+
                        range = document.createRange(); //Create a range (a range is a like the selection but invisible)
                        range.selectNodeContents(element); //Select the entire contents of the element with the range
                        range.collapse(false); //collapse the range to the end point. false means collapse to end rather than the start
                        selection = window.getSelection(); //get the selection object (allows you to change selection)
                        selection.removeAllRanges(); //remove any selections already made
                        selection.addRange(range); //make the range you have just created the visible selection
                    }
                }
                let isChangingText = !element.hasAttribute("data-changetext") || (element.hasAttribute("data-changetext") && element.getAttribute("data-changetext") != "true") ? false : true;

                // //This one used for reduce font classname depends on number of lines.
                // if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(element);

                element.setAttribute("istextchangingonnode", "true");

                if (!element.id.includes("phTextNode")) {
                    let isSpeakerNodes = element.id.includes("sgSpeaker") && (element.id.includes("Primary") || element.id.includes("Secondary"));
                    if (isSpeakerNodes && this.onTextChangeUpdateSpeakerNode) this.onTextChangeUpdateSpeakerNode(element);
                    if (this.onTextChange && (element.id.includes("sgTitleNode") || element.id.includes("sgSubTitleNode") || element.id.includes("sgTitleLabelNode")) && isChangingText == false) {
                        this.onTextChange(element);
                        if (this.doCheckTextLineHeightDiff) this.doCheckTextLineHeightDiff(element);
                    } else if (element.herotextcallback) element.herotextcallback(element, false);
                    else if (element.commonheightfit) element.commonheightfit(element);
                    // else if (element.contactnodesheightfit) element.contactnodesheightfit(element);
                    else if (element.socialheightfit) element.socialheightfit(element);
                    else this.specialGraphicsUtils.doFontFitForCss(element, this.sgParent, null, this.textElementPositioning, this);
                }
                //For agenda primary and secondary
                if (element.onTextChangeNode) element.onTextChangeNode(element, false);

                let assetparentIndex = this.currentNodeIndex - 1;
                if (element.id.includes("sgTitleNode0") || element.id.includes("sgSubTitleNode0") || element.id.includes("sgTitleLabelNode0")) assetparentIndex = 0;

                let assetParent = this.sgParent.querySelector("[id='assetParent" + assetparentIndex + "']");
                if (assetParent) {
                    let textParentElement = assetParent ? assetParent.querySelector("[id='textInnerParentNode']") : null;
                    let parentNode = assetParent ? assetParent : textParentElement ? textParentElement.parentElement : null;
                    if (element.hasAttribute("data-parentid")) {
                        let parentID = element.getAttribute("data-parentid");
                        if (assetParent && assetParent.querySelector("[id='" + parentID + "']")) {
                            parentNode = assetParent.querySelector("[id='" + parentID + "']");
                            textParentElement = parentNode;
                        }
                    }
                    this.textElementPositioning(parentNode, textParentElement, assetparentIndex);
                }
                //This one used for reduce font classname depends on number of lines.
                // if (this.fontSizeChangeOnTextChange && !element.id.includes("phTextNode")) this.fontSizeChangeOnTextChange(element);
                if (isChangingText == false) {
                    // this.showHideAddButtons(element, assetParent);
                    element.removeAttribute("data-changetext");
                }
            } else element.removeAttribute("data-mutation");
        };
        let observer = new MutationObserver(callback.bind(this));
        observer.observe(element, config);
        return observer;
    }
};

SGBaseClass.prototype.focusOutElement = function (elementID) {
    try {
        let element = this.sgParent.querySelector("[id=" + elementID + "]");
        if (element) {
            element.setAttribute("focusout", "mannual");
            element.blur();
        }
    } catch (error) {}
};

SGBaseClass.prototype.createSingleTitle = function (parent, index = 0) {
    let titleTextParent = this.createTextInnerParentNode("titleTextParent", parent);
    let commonClass = " transparentBg " + this.moodanimation;
    let className = this.titleClass.replace("secondary-color", "");
    className = this.fontData && this.fontData.title ? this.fontData.title : className;
    let titleNode = this.specialGraphicsUtils.createTextElement(titleTextParent, this.sgData[index].title, "sgTitleNode", "titleNode " + className + commonClass, "title");
    this.setCommonSelector(titleNode);
    titleNode.contentEditable = "true";
    let promptText = this.styleData && this.styleData.titlePrompt ? this.styleData.titlePrompt : "Type an image caption";
    titleNode.setAttribute("data-prompt-text", promptText);
    titleNode.setAttribute("ImagestackPosition", "textstack");
    titleNode.setAttribute("data-index", index);
    titleNode.setAttribute("data-animation", "title");
    let assetParent = this.sgParent ? this.sgParent.querySelector("[id='assetParent" + index + "']") : null;
    titleNode.setAttribute("data-font", this.fontData && this.fontData.title ? this.fontData.title : "h2");

    this.applyTextBaseProps(titleNode, index, "title");
    this.setTextFocus(titleNode, true, assetParent);
    // if (this.sgData[index]["titleletterspacing"]) titleNode.style.letterSpacing = this.sgData[index]["titleletterspacing"];
    // if (this.sgData[index]["titlelineheight"]) titleNode.style.lineHeight = this.sgData[index]["titlelineheight"];
    // if (this.sgData[index]["titleopacity"]) titleNode.style.opacity = this.sgData[index]["titleopacity"];
    // if (this.sgData[index]["titletexttransform"]) titleNode.style.textTransform = this.sgData[index]["titletexttransform"];
    // if (this.sgData[index]["titletextsize"]) {
    //     titleNode.style.fontSize = this.sgData[index]["titletextsize"];
    //     titleNode.setAttribute("user-text-size", titleNode.style.fontSize);
    // }
    // if (this.sgData[index]["title-user-font-size"]) {
    //     let oldValue = this.specialGraphicsUtils.getClassNameFromNode(titleNode);
    //     titleNode.setAttribute("data-defaultclass", oldValue);

    //     titleNode.setAttribute("user-font-size", this.sgData[index]["title-user-font-size"]);
    //     this.specialGraphicsUtils.removeAllFontClass(titleNode);
    //     titleNode.classList.add(this.sgData[index]["title-user-font-size"]);
    // }

    this.specialGraphicsUtils.doCheckMaxHeight(titleNode);
    return titleTextParent;
};
SGBaseClass.prototype.createSingleSubTitle = function (parent, index = 0) {
    let subTitleTextParent = this.createTextInnerParentNode("subTitleTextParent", parent);
    let commonClass = " transparentBg " + this.moodanimation;
    let subtitleClassName = this.subTitleClass.replace("tertiary-color", "");
    subtitleClassName = this.fontData && this.fontData.subtitle ? this.fontData.subtitle : subtitleClassName;
    let subTitleNode = this.specialGraphicsUtils.createTextElement(subTitleTextParent, this.sgData[index].subtitle, "sgSubTitleNode", "subTitleNode moodClsSubTitle " + subtitleClassName + commonClass, "subtitle");
    this.setCommonSelector(subTitleNode);
    subTitleNode.contentEditable = "true";
    let subtitlePromptText = this.styleData && this.styleData.subTitlePrompt ? this.styleData.subTitlePrompt : "A brief explanation about the image you have used";
    subTitleNode.setAttribute("data-prompt-text", subtitlePromptText);
    subTitleNode.setAttribute("ImagestackPosition", "textstack");
    subTitleNode.setAttribute("data-index", index);
    subTitleNode.setAttribute("data-animation", "subtitle");
    let assetParent = this.sgParent ? this.sgParent.querySelector("[id='assetParent" + index + "']") : null;
    subTitleNode.setAttribute("data-font", this.fontData && this.fontData.subtitle ? this.fontData.subtitle : "p2");

    this.applyTextBaseProps(subTitleNode, index, "subtitle");
    this.setTextFocus(subTitleNode, true, assetParent);
    // if (this.sgData[index]["subtitle-user-font-size"]) {
    //     let clsName = this.sgData[index]["subtitle-user-font-size"];
    //     let oldValue = this.specialGraphicsUtils.getClassNameFromNode(subTitleNode);
    //     subTitleNode.setAttribute("data-defaultclass", oldValue);

    //     subTitleNode.setAttribute("user-font-size", clsName);
    //     this.specialGraphicsUtils.removeAllFontClass(subTitleNode);
    //     subTitleNode.classList.add(clsName);
    // }
    // if (this.sgData[index]["subtitleletterspacing"]) subTitleNode.style.letterSpacing = this.sgData[index]["subtitleletterspacing"];
    // if (this.sgData[index]["subtitlelineheight"]) subTitleNode.style.lineHeight = this.sgData[index]["subtitlelineheight"];
    // if (this.sgData[index]["subtitleopacity"]) subTitleNode.style.opacity = this.sgData[index]["subtitleopacity"];
    // if (this.sgData[index]["subtitletexttransform"]) subTitleNode.style.textTransform = this.sgData[index]["subtitletexttransform"];
    // if (this.sgData[index]["subtitletextsize"]) {
    //     subTitleNode.style.fontSize = this.sgData[index]["subtitletextsize"];
    //     subTitleNode.setAttribute("user-text-size", subTitleNode.style.fontSize);
    // }

    this.specialGraphicsUtils.doCheckMaxHeight(subTitleNode);

    return subTitleTextParent;
};
SGBaseClass.prototype.createSingleLabel = function (parent, index = 0) {
    let labelTextParent = this.createTextInnerParentNode("titleLabelTextParent", parent);
    labelTextParent.style.order = "unset";
    let commonClass = " transparentBg " + this.moodanimation;
    let labelClassName = this.titleLabelClass.replace("theme-color", "");
    labelClassName = this.fontData && this.fontData.label ? this.fontData.label : labelClassName;
    let titleLabelNode = this.specialGraphicsUtils.createTextElement(labelTextParent, this.sgData[index].titlelabel, "sgTitleLabelNode", "titleLabelNode " + labelClassName + commonClass, "titlelabel");
    this.setCommonSelector(titleLabelNode);
    titleLabelNode.contentEditable = "true";
    titleLabelNode.setAttribute("data-animation", "label");
    let labelPromptText = this.styleData && this.styleData.titleLabelPrompt ? this.styleData.titleLabelPrompt : "Title label here";
    titleLabelNode.setAttribute("data-prompt-text", labelPromptText);
    titleLabelNode.setAttribute("ImagestackPosition", "textstack");
    titleLabelNode.setAttribute("data-index", index);
    let assetParent = this.sgParent ? this.sgParent.querySelector("[id='assetParent" + index + "']") : null;
    titleLabelNode.setAttribute("data-font", this.fontData && this.fontData.label ? this.fontData.label : "p2");

    this.applyTextBaseProps(titleLabelNode, index, "titlelabel");
    this.setTextFocus(titleLabelNode, true, assetParent);
    // if (this.sgData[index]["titlelabel-user-font-size"]) {
    //     let oldValue = this.specialGraphicsUtils.getClassNameFromNode(titleLabelNode);
    //     titleLabelNode.setAttribute("data-defaultclass", oldValue);

    //     titleLabelNode.setAttribute("user-font-size", this.sgData[index]["titlelabel-user-font-size"]);
    //     this.specialGraphicsUtils.removeAllFontClass(titleLabelNode);
    //     titleLabelNode.classList.add(this.sgData[index]["titlelabel-user-font-size"]);
    // }
    // if (this.sgData[index]["titlelabelletterspacing"]) titleLabelNode.style.letterSpacing = this.sgData[index]["titlelabelletterspacing"];
    // if (this.sgData[index]["titlelabellineheight"]) titleLabelNode.style.lineHeight = this.sgData[index]["titlelabellineheight"];
    // if (this.sgData[index]["titlelabelopacity"]) titleLabelNode.style.opacity = this.sgData[index]["titlelabelopacity"];
    // if (this.sgData[index]["titlelabeltexttransform"]) titleLabelNode.style.textTransform = this.sgData[index]["titlelabeltexttransform"];
    // if (this.sgData[index]["titlelabeltextsize"]) {
    //     titleLabelNode.style.fontSize = this.sgData[index]["titlelabeltextsize"];
    //     titleLabelNode.setAttribute("user-text-size", titleLabelNode.style.fontSize);
    // }
    this.specialGraphicsUtils.doCheckMaxHeight(titleLabelNode);

    return labelTextParent;
};

SGBaseClass.prototype.applyTextBaseProps = function (textNode, index = 0, attribute) {
    if (this.sgData[index][attribute + "-user-font-size"]) {
        let clsName = this.sgData[index][attribute + "-user-font-size"];
        let oldValue = this.specialGraphicsUtils.getClassNameFromNode(textNode);
        textNode.setAttribute("data-defaultclass", oldValue);

        textNode.setAttribute("user-font-size", clsName);
        this.specialGraphicsUtils.removeAllFontClass(textNode);
        textNode.classList.add(clsName);
    }
    if (this.sgData[index][attribute + "letterspacing"]) textNode.style.letterSpacing = this.sgData[index][attribute + "letterspacing"];
    if (this.sgData[index][attribute + "lineheight"]) textNode.style.lineHeight = this.sgData[index][attribute + "lineheight"];
    if (this.sgData[index][attribute + "opacity"]) textNode.style.opacity = this.sgData[index][attribute + "opacity"];
    if (this.sgData[index][attribute + "texttransform"]) textNode.style.textTransform = this.sgData[index][attribute + "texttransform"];
    if (this.sgData[index][attribute + "textcolor"]) textNode.style.setProperty("color", this.sgData[index][attribute + "textcolor"], "important");
    if (this.sgData[index][attribute + "textgrayscale"]) textNode.style.textgrayscale = this.sgData[index][attribute + "textgrayscale"];
    if (this.sgData[index][attribute + "fontstyle"] == "true") textNode.style.fontStyle = "italic";
    if (this.sgData[index][attribute + "fontweight"] == "true") textNode.style.fontWeight = "bold";
    if (this.sgData[index][attribute + "textalign"]) {
        let strValue = this.sgData[index][attribute + "textalign"];
        textNode.style.setProperty("text-align", strValue, "important");
        if (textNode.getElementsByTagName("ul").length > 0) textNode.style.setProperty("justify-content", strValue == "left" ? "flex-start" : strValue == "right" ? "flex-end" : "center", "important");
    }
    if (this.sgData[index][attribute + "textsize"]) {
        textNode.style.fontSize = this.sgData[index][attribute + "textsize"];
        textNode.setAttribute("user-text-size", textNode.style.fontSize);
    }
};
SGBaseClass.prototype.createTitleSet = function (textParentElement, index = 0, assetParent = null) {
    // this.createTextBg(textParentElement);
    let titleLabelTextParent = this.createTextInnerParentNode("titleLabelTextParent", textParentElement);
    let titleTextParent = this.createTextInnerParentNode("titleTextParent", textParentElement);
    let subTitleTextParent = this.createTextInnerParentNode("subTitleTextParent", textParentElement);

    let commonClass = " transparentBg " + this.moodanimation;
    let className = this.titleClass.replace("secondary-color", "");
    className = this.fontData && this.fontData.title ? this.fontData.title : className;
    if (assetParent && assetParent.classList.contains("introSlide") == true) className = this.fontData && this.fontData.introtitle ? this.fontData.introtitle : className;
    let titleNode = this.specialGraphicsUtils.createTextElement(titleTextParent, this.sgData[index].title, "sgTitleNode", "titleNode " + className + commonClass, "title");
    this.setCommonSelector(titleNode);
    titleNode.contentEditable = "true";
    titleNode.setAttribute("data-animation", "title");
    let promptText = this.styleData && this.styleData.titlePrompt ? this.styleData.titlePrompt : "Type an image caption";
    titleNode.setAttribute("data-prompt-text", promptText);
    titleNode.setAttribute("ImagestackPosition", assetParent && assetParent.classList.contains("introSlide") == true ? "textstack" : this.styleName.includes("minimalistcss") ? "agenda" : "textstackSingle");
    titleNode.setAttribute("data-index", index);
    titleNode.setAttribute("data-font", className);
    // if (this.sgData[index]["title-user-font-size"]) {
    //     let oldValue = this.specialGraphicsUtils.getClassNameFromNode(titleNode);
    //     titleNode.setAttribute("data-defaultclass", oldValue);

    //     titleNode.setAttribute("user-font-size", this.sgData[index]["title-user-font-size"]);
    //     this.specialGraphicsUtils.removeAllFontClass(titleNode);
    //     titleNode.classList.add(this.sgData[index]["title-user-font-size"]);
    // }
    // if (this.sgData[index]["titleletterspacing"]) titleNode.style.letterSpacing = this.sgData[index]["titleletterspacing"];
    // if (this.sgData[index]["titlelineheight"]) titleNode.style.lineHeight = this.sgData[index]["titlelineheight"];
    // if (this.sgData[index]["titleopacity"]) titleNode.style.opacity = this.sgData[index]["titleopacity"];
    // if (this.sgData[index]["titletexttransform"]) titleNode.style.textTransform = this.sgData[index]["titletexttransform"];
    // if (this.sgData[index]["titletextsize"]) {
    //     titleNode.style.fontSize = this.sgData[index]["titletextsize"];
    //     titleNode.setAttribute("user-text-size", titleNode.style.fontSize);
    // }
    this.applyTextBaseProps(titleNode, index, "title");
    this.setTextFocus(titleNode, true, assetParent);

    let labelClassName = this.titleLabelClass.replace("theme-color", "");
    labelClassName = this.fontData && this.fontData.label ? this.fontData.label : labelClassName;
    if (assetParent && assetParent.classList.contains("introSlide") == true) labelClassName = this.fontData && this.fontData.introlabel ? this.fontData.introlabel : labelClassName;
    let titleLabelNode = this.specialGraphicsUtils.createTextElement(titleLabelTextParent, this.sgData[index].titlelabel, "sgTitleLabelNode", "titleLabelNode " + labelClassName + commonClass, "titlelabel");
    this.setCommonSelector(titleLabelNode);
    titleLabelNode.contentEditable = "true";
    titleLabelNode.setAttribute("data-animation", "label");
    let labelPromptText = this.styleData && this.styleData.titleLabelPrompt ? this.styleData.titleLabelPrompt : "Title label here";
    titleLabelNode.setAttribute("data-prompt-text", labelPromptText);
    titleLabelNode.setAttribute("ImagestackPosition", assetParent && assetParent.classList.contains("introSlide") == true ? "textstack" : this.styleName.includes("minimalistcss") ? "agenda" : "textstackSingle");
    titleLabelNode.setAttribute("data-font", labelClassName);
    titleLabelNode.setAttribute("data-index", index);
    // if (this.sgData[index]["titlelabelopacity"]) titleLabelNode.style.opacity = this.sgData[index]["titlelabelopacity"];
    // if (this.sgData[index]["titlelabeltexttransform"]) titleLabelNode.style.textTransform = this.sgData[index]["titlelabeltexttransform"];
    // if (this.sgData[index]["titlelabeltextsize"]) {
    //     titleLabelNode.style.fontSize = this.sgData[index]["titlelabeltextsize"];
    //     titleLabelNode.setAttribute("user-text-size", titleLabelNode.style.fontSize);
    // }

    // if (this.sgData[index]["titlelabel-user-font-size"]) {
    //     let oldValue = this.specialGraphicsUtils.getClassNameFromNode(titleLabelNode);
    //     titleLabelNode.setAttribute("data-defaultclass", oldValue);

    //     titleLabelNode.setAttribute("user-font-size", this.sgData[index]["titlelabel-user-font-size"]);
    //     this.specialGraphicsUtils.removeAllFontClass(titleLabelNode);
    //     titleLabelNode.classList.add(this.sgData[index]["titlelabel-user-font-size"]);
    // }
    this.applyTextBaseProps(titleLabelNode, index, "titlelabel");
    this.setTextFocus(titleLabelNode, true, assetParent);

    let subtitleClassName = this.subTitleClass.replace("tertiary-color", "");
    subtitleClassName = this.fontData && this.fontData.subtitle ? this.fontData.subtitle : subtitleClassName;
    if (assetParent && assetParent.classList.contains("introSlide") == true) subtitleClassName = this.fontData && this.fontData.introsubtitle ? this.fontData.introsubtitle : subtitleClassName;
    let subTitleNode = this.specialGraphicsUtils.createTextElement(subTitleTextParent, "", "sgSubTitleNode", "subTitleNode moodClsSubTitle transparentBg moodanimation " + subtitleClassName, "subtitle");
    this.setCommonSelector(subTitleNode);
    // let subTitleNode = this.specialGraphicsUtils.createTextElement(subTitleTextParent, this.sgData[index].subtitle, "sgSubTitleNode", "subTitleNode " + subtitleClassName + commonClass, "subtitle");
    // subTitleNode.contentEditable = "true";
    let subtitlePromptText = this.styleData && this.styleData.subTitlePrompt ? this.styleData.subTitlePrompt : "A brief explanation about the image you have used";
    subTitleNode.setAttribute("data-prompt-text", subtitlePromptText);
    subTitleNode.setAttribute("ImagestackPosition", assetParent && assetParent.classList.contains("introSlide") == true ? "textstack" : this.styleName.includes("minimalistcss") ? "agenda" : "textstackSingle");
    subTitleNode.setAttribute("data-font", subtitleClassName);
    subTitleNode.setAttribute("data-animation", "subtitle");
    subTitleNode.setAttribute("data-index", index);
    let clsName = this.sgData?.[index]?.["subtitle-user-font-size"];
    this.applyTextBaseProps(subTitleNode, index, "subtitle");
    this.setTextFocus(subTitleNode, true, assetParent);
    // if (this.sgData[index]["subtitle-user-font-size"]) {
    //     clsName = this.sgData[index]["subtitle-user-font-size"];
    //     let oldValue = this.specialGraphicsUtils.getClassNameFromNode(subTitleNode);
    //     subTitleNode.setAttribute("data-defaultclass", oldValue);

    //     subTitleNode.setAttribute("user-font-size", clsName);
    //     this.specialGraphicsUtils.removeAllFontClass(subTitleNode);
    //     subTitleNode.classList.add(clsName);
    // }
    // if (this.sgData[index]["subtitleletterspacing"]) subTitleNode.style.letterSpacing = this.sgData[index]["subtitleletterspacing"];
    // if (this.sgData[index]["subtitlelineheight"]) subTitleNode.style.lineHeight = this.sgData[index]["subtitlelineheight"];
    // if (this.sgData[index]["subtitleopacity"]) subTitleNode.style.opacity = this.sgData[index]["subtitleopacity"];
    // if (this.sgData[index]["subtitletexttransform"]) subTitleNode.style.textTransform = this.sgData[index]["subtitletexttransform"];
    // if (this.sgData[index]["subtitletextsize"]) {
    //     subTitleNode.style.fontSize = this.sgData[index]["subtitletextsize"];
    //     subTitleNode.setAttribute("user-text-size", subTitleNode.style.fontSize);
    // }

    let ul = document.createElement("ul");
    ul.contentEditable = "true";
    ul.setAttribute("data-cssslide", "slide0subtitle");
    let listtype = this.sgData[index]["subtitlelisttype"] ? this.sgData[index]["subtitlelisttype"] : "sgparagraph";
    listtype = listtype == "orderList" ? "sgnumbered" : listtype == "unorderlist" ? "sgbulleted" : listtype == "paragraph" ? "sgparagraph" : listtype;
    ul.className = "clsSubTitleText transparentBg " + listtype;
    this.setCommonSelector(ul);
    ul.setAttribute("data-focus-parent", "nodeGroup");
    ul.setAttribute("name", "secondaryText");
    ul.setAttribute("data-name", "text");
    ul.setAttribute("data-id", "secondaryText");
    ul.setAttribute("id", "secondaryText" + index);
    ul.setAttribute("data-type", "secondaryText");
    ul.setAttribute("data-default-event", true);
    ul.setAttribute("data-observer", true);
    ul.setAttribute("data-highlight-event", true);
    ul.setAttribute("data-ignore-general-selector", "1");
    ul.setAttribute("data-prompt-text", subtitlePromptText);
    ul.setAttribute("data-index", index);
    // ul.setAttribute("data-animation", "secondarytext");
    // subTitleNode.setAttribute("data-mutation", true);
    subTitleNode.appendChild(ul);
    // if (this.sgData[index]["subtitleletterspacing"]) ul.style.letterSpacing = this.sgData[index]["subtitleletterspacing"];
    // if (this.sgData[index]["subtitlelineheight"]) ul.style.lineHeight = this.sgData[index]["subtitlelineheight"];
    this.applyTextBaseProps(ul, index, "subtitle");
    if (clsName) {
        this.specialGraphicsUtils.removeAllFontClass(ul);
        ul.classList.add(clsName);
    }
    if (this.sgData[index]["subtitlelistcontent"]) {
        let arrListContent = this.sgData[index]["subtitlelistcontent"].split("////");
        for (let a = 0; a < arrListContent.length; a++) {
            let li = document.createElement("li");
            ul.appendChild(li);
            li.setAttribute("data-type", "secondaryText");
            li.setAttribute("data-index", index);
            li.setAttribute("data-ignore-general-selector", "1");
            li.className = "secondaryTextItemNormal";
            li.setAttribute("id", "secondaryTextItem");
            li.setAttribute("name", "secondaryTextItem");
            li.setAttribute("data-id", "secondaryTextItem");
            li.setAttribute("data-prompt-text", subtitlePromptText);
            li.innerHTML = arrListContent[a];

            let modifiedString = TextHighLightUtils.highlightToString(li.innerHTML);
            li.innerHTML = modifiedString;
            li.innerText = modifiedString;
            TextHighLightUtils.updateHighlight(li, modifiedString);
            this.specialGraphicsUtils.setHighlightData(li);
            let lineheight = window.getComputedStyle(li)["line-height"];
            ul.style.setProperty("--subTitleHolderMH", lineheight);
        }
        let slideParent = this.slideContent ? this.slideContent : this.sgParent.parentElement.parentElement;
        let sgDomDataNodes = slideParent ? slideParent.querySelector("[id='AESpecialGraphics']").children : null;
        if (sgDomDataNodes && sgDomDataNodes.length > 0 && sgDomDataNodes[0].children.length > 0 && sgDomDataNodes[index]) {
            let subTitleDom = sgDomDataNodes[index].getElementsByTagName("subtitle");
            if (subTitleDom && subTitleDom[0]) {
                subTitleDom[0].setAttribute("data-text", subTitleNode.innerText);
                subTitleDom[0].setAttribute("data-html", subTitleNode.innerHTML);
            }
        }
    } else {
        let li = document.createElement("li");
        ul.appendChild(li);
        li.setAttribute("data-type", "secondaryText");
        li.setAttribute("data-index", index);
        li.setAttribute("data-ignore-general-selector", "1");
        li.className = "secondaryTextItemNormal";
        li.setAttribute("id", "secondaryTextItem");
        li.setAttribute("name", "secondaryTextItem");
        li.setAttribute("data-id", "secondaryTextItem");
        li.setAttribute("data-prompt-text", subtitlePromptText);
        li.innerHTML = this.sgData[index].subtitle;

        let modifiedString = TextHighLightUtils.highlightToString(li.innerHTML);
        li.innerHTML = modifiedString;
        li.innerText = modifiedString;
        TextHighLightUtils.updateHighlight(li, modifiedString);
        this.specialGraphicsUtils.setHighlightData(li);

        let lineheight = window.getComputedStyle(li)["line-height"];
        ul.style.setProperty("--subTitleHolderMH", lineheight);
    }
    if (this.textElement && this.textElement.elementData && this.textElement.elementData.titlesubtitlelabelgap) {
        //Setting up the title subtitle gap values to elements based on mood
        if (titleLabelNode) {
            let titleLabelGap = Number(this.textElement.elementData.titlesubtitlelabelgap[0]);
            titleLabelNode.parentElement.style.marginBottom = titleLabelGap + "px";
        }
        if (subTitleNode) {
            let titleSubtitleGap = Number(this.textElement.elementData.titlesubtitlelabelgap[1]);
            subTitleNode.parentElement.style.marginTop = titleSubtitleGap + "px";
        }
    } else {
        if (titleLabelNode) titleLabelNode.style.removeProperty("margin-bottom");
        if (subTitleNode) subTitleNode.style.removeProperty("margin-top");
    }

    this.textElementPositioning(assetParent ? assetParent : textParentElement.parentElement, textParentElement, index);

    let obj = {};
    obj.title = titleNode;
    obj.subtitle = subTitleNode;
    obj.label = titleLabelNode;
    return obj;
};

SGBaseClass.prototype.createTextBg = function (textBaseParentNode) {
    let textBgColorDiv = document.createElement("div");
    textBgColorDiv.id = "textBgColorDiv";
    this.setTextType(textBgColorDiv);
    textBgColorDiv.setAttribute("data-animation", "textbg");
    let themeColorName = "background-bg-color";
    textBgColorDiv.className = "textBgColorDiv " + themeColorName + " moodanimation ";
    textBaseParentNode.appendChild(textBgColorDiv);
    let opacity = parseFloat(window.getComputedStyle(textBgColorDiv)["opacity"]);
    opacity = !opacity || isNaN(opacity) ? 1 : opacity;
    textBgColorDiv.setAttribute("data-opacity", opacity);
    this.specialGraphicsUtils.setOpacityAttribute(textBgColorDiv);
};

SGBaseClass.prototype.createTextElement = function (newParent = null, index = 0) {
    if (this.isPresent != true || this.isWidget == true) {
        if (this.carouselType == "type9" && index != 0) return;

        let assetParent = this.sgParent.querySelector("[id='assetParent" + index + "']");
        let agendaSlide = this.sgParent.querySelector("[id='agendaSlide']");
        let textInnerParentNode = assetParent ? assetParent.querySelector("[id*='textInnerParentNode']") : null;

        let titleTextParent = assetParent ? assetParent.querySelector("[id*='titleTextParent']") : newParent ? newParent.querySelector("[id*='titleTextParent']") : null;
        let lytAssetTextParent = this.sgParent.querySelector("[id='lytAssetTextParent" + index + "']");
        if (!titleTextParent && lytAssetTextParent?.querySelector("[id*='titleTextParent']")) titleTextParent = lytAssetTextParent.querySelector("[id*='titleTextParent']");
        if (titleTextParent) {
            titleTextParent.style.removeProperty("margin-bottom");
            titleTextParent.style.removeProperty("margin-top");
        }
        let arrAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
        let color = "";
        for (let a = 0; a < arrAssetParent.length; a++) {
            let arrTextElementParentSG = arrAssetParent[a].querySelector("[id*='textElementParentSG']");
            if (arrTextElementParentSG) {
                let child = arrTextElementParentSG.querySelector("[data-type='TEXT_ELEMENT']");
                color = child && child.hasAttribute("data-bg-color") ? child.getAttribute("data-bg-color") : null;
                if (isWidget != true && a == index) arrTextElementParentSG.parentElement.removeChild(arrTextElementParentSG);
            }
        }

        let obj = {};
        obj.isSpecialGraphics = true;

        obj.assetParent = assetParent ? assetParent : agendaSlide ? agendaSlide : newParent;
        obj.textInnerParentNode = textInnerParentNode ? textInnerParentNode : newParent;

        if (!obj.textInnerParentNode && this.sgParent.hasAttribute("singlenode") && this.sgParent.getAttribute("singlenode") == "true" && (this.textElement?.elementData?.textelementproperties || this.textElement?.elementData?.textelement)) {
            let textElementStyle = obj.assetParent.getAttribute("data-textelementstyle");
            let props = this.textElement.elementData.textelementproperties;
            let textElementSelected = props ? (props[textElementStyle] ? props[textElementStyle] : Object.keys(props).length > 0 ? props[Object.keys(props)[0]] : null) : this.textElement?.elementData?.textelement ? this.textElement.elementData.textelement : null;
            if (textElementSelected) {
                let target = textElementSelected && textElementSelected.target ? textElementSelected.target : null;
                let labelParent = obj.assetParent.querySelector("[id*='titleLabelTextParent']");
                let subtitleParent = obj.assetParent.querySelector("[id*='subTitleTextParent']");
                let titleParent = obj.assetParent.querySelector("[id*='titleTextParent']");

                if (target && target == "title" && titleParent) obj.textInnerParentNode = titleParent.parentElement;
                if (target && target == "label" && labelParent) obj.textInnerParentNode = labelParent.parentElement;
                if (target && target == "subtitle" && subtitleParent) obj.textInnerParentNode = subtitleParent.parentElement;
                if (target && (target == "subtitle" || target == "label") && titleParent) {
                    let isVisible = target == "subtitle" && subtitleParent && subtitleParent.style.display == "none" ? false : true;
                    isVisible = target == "label" && labelParent && labelParent.style.display == "none" ? false : isVisible;
                    if (isVisible == false) obj.textInnerParentNode = titleParent.parentElement;
                }
            }
        }
        // console.log("SGG - textInnerParentNode - " + (obj.textInnerParentNode ? obj.textInnerParentNode.id : "null"));
        // console.log("SGG - assetParent - " + (obj.assetParent ? obj.assetParent.id : "null"));
        if (this.textelementcreation && obj.textInnerParentNode) this.textelementcreation(obj);

        if (color && color != "") {
            //retaining text element colors
            let arrTextElementParentSGAfter = this.sgParent.querySelectorAll("[id*='textElementParentSG']");
            for (let a = 0; a < arrTextElementParentSGAfter.length; a++) {
                let child = arrTextElementParentSGAfter[a].querySelector("[data-type='TEXT_ELEMENT']");
                if (child) child.setAttribute("data-bg-color", color);
            }
        }
    }
};

//Creating coverimage node - changing depends on component
SGBaseClass.prototype.createCoverImageNode = function (parent, index = 0, type = "", isSvgSupport = false, tagName = "coverimage") {
    this.createCoverBackground(parent, type);

    let width = 0; //parseFloat(window.getComputedStyle(parent)["width"]);
    let height = 0; //parseFloat(window.getComputedStyle(parent)["height"]);
    if (parent.style.width.includes("%")) {
        let parentWidth = window.getComputedStyle(parent.parentElement.parentElement).width;
        let finalWidth = parseFloat(parentWidth) * (parseFloat(parent.style.width) / 100);
        if (isNaN(parseFloat(finalWidth)) && parseFloat(finalWidth) && parseFloat(finalWidth) > 0) width = parseFloat(finalWidth);
    }
    if (parent.style.height.includes("%")) {
        let parentHeight = window.getComputedStyle(parent.parentElement.parentElement).height;
        let finalHeight = parseFloat(parentHeight) * (parseFloat(parent.style.height) / 100);
        if (isNaN(parseFloat(finalHeight)) && parseFloat(finalHeight) && parseFloat(finalHeight) > 0) height = parseFloat(finalHeight);
    }

    var svgElementDiv = document.createElement("div");
    if (isSvgSupport == true || (this.styleData && this.styleData.isSVGAsset != null && (this.styleData.isSVGAsset == "true" || this.styleData.isSVGAsset == true))) {
        // This is for change image / icon from inline floater change
        this.sgParent.setAttribute("data-svgsupport", "true");
        //Creating svg node
        svgElementDiv.id = "svgElementDiv";
        svgElementDiv.className = "svgElementDiv accent1-fill";
        svgElementDiv.style.pointerEvents = "none";
        parent.appendChild(svgElementDiv);
        if (svgElementDiv.children.length > 0) {
            svgElementDiv.children[0].style.width = "100%";
            svgElementDiv.children[0].style.height = "100%";
        }
        svgElementDiv.style.display = "none";
    } else this.sgParent.setAttribute("data-svgsupport", "false");

    let src = this.sgData[index][tagName];
    if (src == "undefined") src = null;
    if (!src || (src.includes(".svg") && !isSvgSupport)) src = "genericassets/placeholderimages/coverimage.jpg";
    src = this.specialGraphicsUtils.checkAppStaticURLSG(src, this.appStaticURL);
    //Creating Image node
    let coverimage = this.specialGraphicsUtils.createImageElement(parent, "coverImage", index, src, width, height, 0, 0, tagName, this.sgData[index], null, tagName);
    coverimage.style.pointerEvents = "none";
    this.specialGraphicsUtils.setOpacityAttribute(parent);

    if (this.sgData[index]?.[tagName + "imageprompt"] && this.imageLoadUsingPrompt && this.sgData[index][tagName + "needassetupdate"] == "true") this.imageLoadUsingPrompt(coverimage, this.sgData[index][tagName + "imageprompt"], index > 0 ? index - 1 : index);
    else if (this.sgData[index]?.[tagName + "imageprompt"]) coverimage.parentElement.setAttribute("data-node-graphic-text", this.sgData[index][tagName + "imageprompt"]);

    if (type == "generic") coverimage.setAttribute("data-nodetype", "imageNode");
    if (this.sgData[index] && this.sgData[index][tagName] && this.sgData[index][tagName].includes(".svg") && this.sgParent.getAttribute("data-svgsupport") == "true") {
        svgElementDiv.style.display = "flex";
        coverimage.style.display = "none";
    }
    this.createCoverOverlay(parent, type);
    this.createCoverCaption(parent, index, tagName);

    this.eventManager.addEvent(coverimage.parentElement, "dblclick", this.imageDoubleClickEvent);
    coverimage.parentElement.setAttribute("clicklistener", "true");
};

SGBaseClass.prototype.updateAeNode = function (index, tagName) {
    this.specialGraphicsUtils.updateOnDummyDiv(this.sgParent, index, tagName);
};
SGBaseClass.prototype.setCommonSelector = function (target) {
    target.setAttribute("data-dck-selector", true);
};
SGBaseClass.prototype.imageDoubleClickEvent = function (event) {
    let isSvgElement = false;
    if (event.target.querySelector("[id='svgElementDiv']")) {
        let eleStyle = window.getComputedStyle(event.target.querySelector("[id='svgElementDiv']"));
        isSvgElement = eleStyle.display == "flex" || eleStyle.display == "block";
        if (isSvgElement) {
            event.preventDefault();
            event.stopPropagation();
            return null;
        }
    }
    if (!isSvgElement && this.imageDoubleClickFunctionality) this.imageDoubleClickFunctionality(event.target.id);
};
//Create coverimage caption
SGBaseClass.prototype.createCoverCaption = function (parent, index, tagName) {
    let className = (this.styleData.fontData[tagName + "caption"] ? this.styleData.fontData[tagName + "caption"] : "p7") + " ";
    let data = this.sgData[index];
    let imagecaption = data && data[tagName + "caption"] && data[tagName + "caption"] != "undefined" ? data[tagName + "caption"] : "";
    let imageCaptionNode = this.specialGraphicsUtils.createTextElement(parent, imagecaption, "imageCaption", "coverimageCaption " + className + this.selectionLayerClass, tagName + "caption");
    this.setCommonSelector(imageCaptionNode);
    imageCaptionNode.contentEditable = "true";
    imageCaptionNode.setAttribute("data-prompt-text", this.styleData.imagecaptionPrompt ? this.styleData.imagecaptionPrompt : "This is image caption text");
    imageCaptionNode.setAttribute("data-fontfit", "false");
    this.setTextFocus(imageCaptionNode);
    imageCaptionNode.style.display = "none";
    if (data && data[tagName + "captionshow"] && data[tagName + "captionshow"] == "true") imageCaptionNode.style.display = "flex";
    if (data && data[tagName + "captionposition"]) imageCaptionNode.classList.add(data[tagName + "captionposition"]);
};
//Create coverimage overlay
SGBaseClass.prototype.createCoverOverlay = function (parent, type = "") {
    let coverImageOverlay = document.createElement("div");
    coverImageOverlay.id = "coverImageOverlay";
    coverImageOverlay.className = "coverImageOverlay";
    coverImageOverlay.style.pointerEvents = "none";
    coverImageOverlay.setAttribute("data-type", "overlay");
    // coverImageOverlay.style.backgroundColor = "unset";
    // coverImageOverlay.style.backgroundImage = "unset";
    parent.appendChild(coverImageOverlay);
    if (type == "generic") coverImageOverlay.setAttribute("data-nodetype", "imageOverlay");
};

//Create coverimage overlay
SGBaseClass.prototype.createCoverBackground = function (parent, type = "") {
    let coverImageBackground = document.createElement("div");
    coverImageBackground.id = "coverImageBackground";
    coverImageBackground.className = "coverImageBackground ";
    coverImageBackground.style.pointerEvents = "none";
    parent.appendChild(coverImageBackground);
    if (type == "generic") coverImageBackground.setAttribute("data-nodetype", "imageBackground");
};

//Create number node
SGBaseClass.prototype.createNumberTextNode = function (parentNode, index, numberContent, isSection = false) {
    let oldNumberNode = parentNode.querySelector("[id='sgNumberTextNode']");
    if (oldNumberNode) oldNumberNode.parentElement.removeChild(oldNumberNode);

    let numberParent = document.createElement("div");
    numberParent.id = "sgNumberTextParent";
    numberParent.setAttribute("data-animation", "number");
    numberParent.className = "sgNumberTextParent clsSeqTitleParent " + this.moodanimation + this.selectionLayerClass;
    this.setTextType(numberParent);
    parentNode.appendChild(numberParent);

    let className = " " + this.fontData.number + " clsSeqText ";

    let textNumber = isSection ? "" : this.sgData[index].numbertext ? this.sgData[index].numbertext : "1";
    if (textNumber == "010") textNumber.replace("0", "");
    textNumber = parseInt(textNumber) < 10 ? textNumber.replace("0", "") : textNumber;

    if (this.objDataToSG && this.objDataToSG.numberFormat) numberContent = this.specialGraphicsUtils.getSeqMoodStyle(this.objDataToSG.numberFormat, index);

    if (this.moodName == "minimalcss" || this.moodName == "keynotecss" || this.moodName == "bubblecss" || this.moodName == "elegantcss") textNumber = parseInt(textNumber) > 9 ? textNumber : "0" + textNumber;

    if (numberContent) textNumber = numberContent;
    let numberNode = this.specialGraphicsUtils.createTextElement(numberParent, textNumber, "sgNumberTextNode" + index, "numberTextNode " + className, "numbertext");
    // this.setCommonSelector(numberNode);
    numberNode.contentEditable = "false";
    numberNode.style.pointerEvents = "none";
    if (isSection) numberNode.classList.add("sgSectionNumber");

    this.applyTextBaseProps(numberNode, 0, "numbertext");
    this.setTextFocus(numberNode, false);

    let opacity = parseFloat(window.getComputedStyle(numberNode)["opacity"]);
    opacity = !opacity || isNaN(opacity) ? 1 : opacity;
    numberNode.setAttribute("data-opacity", opacity);

    return numberNode;
};

//Seting text type to avoid inline floater and selector
SGBaseClass.prototype.imageBase = function (parentNode, index = 0, anim = true) {
    let assetImageParent = document.createElement("div");
    assetImageParent.id = "assetImageParent" + index;
    assetImageParent.className = "assetImageParent";
    this.setTextType(assetImageParent);
    parentNode.appendChild(assetImageParent);

    return this.createCoverImageParent(assetImageParent, index, anim);
};

SGBaseClass.prototype.createCoverImageParent = function (assetImageParent, index = 0, anim = true, propData = null, nodeID = "") {
    let coverImageParent = document.createElement("div");
    coverImageParent.id = "coverImageParent" + nodeID;
    coverImageParent.className = "coverImageParent" + nodeID + this.selectionLayerClass + (anim == true ? this.moodanimation : "");
    coverImageParent.setAttribute("data-type", "IMAGE");
    coverImageParent.setAttribute("data-animation", "coverimage");
    coverImageParent.setAttribute("data-nodetype", "contentContainer");
    assetImageParent.appendChild(coverImageParent);

    if (this.sgData[index]["coverimage" + nodeID + "navigateurl"]) this.updateAgendaLink(null, this.sgData[index]["coverimage" + nodeID + "navigateurl"], coverImageParent.id, true, null, index, coverImageParent);

    let contentBackground = document.createElement("div");
    contentBackground.id = "contentBackground";
    contentBackground.className = "contentBackground";
    contentBackground.style.position = "absolute";
    contentBackground.style.pointerEvents = "none";
    contentBackground.style.width = "100%";
    contentBackground.style.height = "100%";
    contentBackground.setAttribute("data-nodetype", "contentBackground");
    coverImageParent.appendChild(contentBackground);

    let coverParent = document.createElement("div");
    coverParent.id = "coverParent" + (nodeID ? nodeID : index);
    coverParent.className = "coverParent" + nodeID;
    coverParent.setAttribute("data-nodetype", "imageHolder");
    coverImageParent.appendChild(coverParent);
    coverParent.setAttribute("data-type", "IMAGE");
    this.setCommonSelector(coverParent);

    let moodImageProps = this.objDataToSG?.fullMoodsData?.image;
    let isSupportBorder = propData?.borderoption && propData.borderoption == "enable" ? true : false;
    if (isSupportBorder) {
        let borderClassName;
        // Image border style from mood level
        if (moodImageProps?.borderstyle) borderClassName = moodImageProps.borderstyle;
        if (moodImageProps?.borderoptionenabled) coverParent.setAttribute("borderoptionenabled", moodImageProps.borderoptionenabled);

        // Image border style from menu level
        if (propData?.borderstyle) borderClassName = propData.borderstyle;
        if (propData?.borderoptionenabled) coverParent.setAttribute("borderoptionenabled", propData.borderoptionenabled);
        // Image border style from old data
        if (this.sgData && this.sgData[index] && this.sgData[index]["coverimage" + nodeID + "border"]) borderClassName = this.sgData[index]["coverimage" + nodeID + "border"];
        if (borderClassName) {
            coverParent.classList.add(borderClassName);
            coverParent.setAttribute("borderstyle", borderClassName);
        }
    }
    let hasGutter = false;
    // Gutter option from mood level
    if (moodImageProps?.gutteroptionenabled == "true") hasGutter = true;
    // Gutter option from prop level
    if (propData?.gutteroptionenabled == "true") hasGutter = true;
    if (hasGutter) coverParent.setAttribute("gutteroptionenabled", "true");

    return coverParent;
};

SGBaseClass.prototype.createTextBase = function (parent, index) {
    let textBaseParentNode = document.createElement("div");
    textBaseParentNode.className = "textBaseParentNode";
    textBaseParentNode.id = "textBaseParentNode" + index;
    parent.appendChild(textBaseParentNode);
    this.setTextType(textBaseParentNode);

    let textBgColorDiv = document.createElement("div");
    textBgColorDiv.id = "textBgColorDiv";
    this.setTextType(textBgColorDiv);
    textBgColorDiv.className = "textBgColorDiv " + this.moodanimation;
    textBaseParentNode.appendChild(textBgColorDiv);
    let opacity = parseFloat(window.getComputedStyle(textBgColorDiv)["opacity"]);
    opacity = !opacity || isNaN(opacity) ? 1 : opacity;
    textBgColorDiv.setAttribute("data-opacity", opacity);
    this.specialGraphicsUtils.setOpacityAttribute(textBgColorDiv);

    //Creating Text parent.
    let textParentNode = document.createElement("div");
    textParentNode.id = "textParent";
    this.setTextType(textParentNode);
    textParentNode.className = "textParent";
    textBaseParentNode.appendChild(textParentNode);

    let textInnerParentNode = document.createElement("div");
    textInnerParentNode.id = "textInnerParentNode";
    this.setTextType(textInnerParentNode);
    textInnerParentNode.className = "textInnerParent";
    textParentNode.appendChild(textInnerParentNode);

    return textInnerParentNode;
};

SGBaseClass.prototype.setTextType = function (element) {
    element.setAttribute("data-type", "TEXT");
    element.setAttribute("data-showselector", "false");
};
SGBaseClass.prototype.textElementPositioning = function (assetParent, textInnerParentNode, index) {
    let oldDisplay = assetParent?.style?.display == "none" ? "none" : "";
    if (oldDisplay == "none") assetParent.style.display = "flex";

    let textBaseNode = assetParent && assetParent.querySelector("[id*='textBaseParentNode']") ? assetParent.querySelector("[id*='textBaseParentNode']") : null;
    if (textBaseNode) this.createTextElement(textBaseNode, index);
    else this.createTextElement(textInnerParentNode, index);

    if (oldDisplay == "none") assetParent.style.display = "none";
};

//Create Asset Parent
SGBaseClass.prototype.createAssetParent = function (index = 0, sgParent) {
    let assetParent = sgParent.querySelector("[id='assetParent" + index + "']");
    if (assetParent == null) {
        //Creating main parent for each slides under SVG Div.
        assetParent = document.createElement("div");
        assetParent.id = "assetParent" + index;
        // this.setTextType(assetParent);

        assetParent.className = " assetParent " + this.styleName;
        sgParent.appendChild(assetParent);
    }
    return assetParent;
};

//Create customer Logo image with parent node
SGBaseClass.prototype.createPresenterCustomerLogoImageNode = function (parentNode, sgParent, index = 0, source, isCustomer) {
    let type = isCustomer ? "customer" : "presenter";
    let oldImageParent = parentNode.querySelector("[id='" + type + "LogoContentParent']");
    if (oldImageParent) oldImageParent.parentElement.removeChild(oldImageParent);

    //Creating presenter image main parent
    let customerLogoContentParent = document.createElement("div");
    customerLogoContentParent.id = type + "LogoContentParent";
    customerLogoContentParent.setAttribute("data-type", "IMAGE");
    customerLogoContentParent.className = type + "LogoContentParent " + this.moodanimation;
    customerLogoContentParent.style.position = "relative";
    customerLogoContentParent.setAttribute("data-animation", type == "presenter" ? "presenterlogo" : "customerlogo");
    customerLogoContentParent.setAttribute("data-nodetype", "contentContainer");
    parentNode.appendChild(customerLogoContentParent);

    //Creating presenter image content background
    let contentBackground = document.createElement("div");
    contentBackground.id = "contentBackground";
    contentBackground.className = "contentBackground";
    contentBackground.style.position = "absolute";
    contentBackground.style.pointerEvents = "none";
    contentBackground.style.width = "100%";
    contentBackground.style.height = "100%";
    contentBackground.setAttribute("data-nodetype", "contentBackground");
    customerLogoContentParent.appendChild(contentBackground);

    let customerLogoImageParent = document.createElement("div");
    customerLogoImageParent.id = type + "LogoImageParent";
    customerLogoImageParent.className = type + "LogoImageParent" + this.selectionLayerClass;
    this.setCommonSelector(customerLogoImageParent);
    customerLogoContentParent.appendChild(customerLogoImageParent);
    customerLogoImageParent.setAttribute("data-nodetype", "imageHolder");

    //Creating presenter image background
    let logoImageBackground = document.createElement("div");
    logoImageBackground.id = type + "LogoImageBackground";
    logoImageBackground.className = "logoImageBackground ";
    logoImageBackground.style.pointerEvents = "none";
    logoImageBackground.style.position = "absolute";
    logoImageBackground.setAttribute("data-nodetype", "imageBackground");
    customerLogoImageParent.appendChild(logoImageBackground);

    let sgData = this.sgData[index];

    //Creating overlay div
    let overlayDiv = document.createElement("div");
    overlayDiv.id = type + "LogoOverlayDiv";
    overlayDiv.className = "logoOverlayDiv" + this.moodanimation;
    overlayDiv.setAttribute("data-nodetype", "imageOverlay");
    customerLogoImageParent.appendChild(overlayDiv);

    if (sgData[type + "logoimagedata"]) customerLogoImageParent.setAttribute("data-" + type + "logodata", sgData[type + "logoimagedata"]);
    if (sgData[type + "logoimagetype"]) customerLogoImageParent.setAttribute("data-" + type + "logotype", sgData[type + "logoimagetype"]);
    if (sgData[type + "logoimageaspect"]) customerLogoImageParent.setAttribute("data-" + type + "logoaspect", sgData[type + "logoimageaspect"]);
    if (sgData[type + "logoimagebaseurl"]) customerLogoImageParent.setAttribute("data-" + type + "logobaseurl", sgData[type + "logoimagebaseurl"]);
    if (sgData[type + "logoimagefulldata"]) customerLogoImageParent.setAttribute("data-" + type + "logofulldata", sgData[type + "logoimagefulldata"]);
};

//Create Logo image with parent node
SGBaseClass.prototype.createLogoImageNode = function (parentNode, sgParent, index = 0, source, contrast = true) {
    let oldImageParent = parentNode.querySelector("[id='logoContentParent']");
    if (oldImageParent) oldImageParent.parentElement.removeChild(oldImageParent);

    //Creating presenter image main parent
    let logoContentParent = document.createElement("div");
    logoContentParent.id = "logoContentParent";
    logoContentParent.className = "logoContentParent " + this.moodanimation;
    logoContentParent.style.position = "relative";
    logoContentParent.setAttribute("data-type", "IMAGE");
    logoContentParent.setAttribute("data-animation", "logo");
    logoContentParent.setAttribute("data-nodetype", "contentContainer");
    parentNode.appendChild(logoContentParent);

    //Creating presenter image content background
    let contentBackground = document.createElement("div");
    contentBackground.id = "contentBackground";
    contentBackground.className = "contentBackground";
    contentBackground.style.position = "absolute";
    contentBackground.style.pointerEvents = "none";
    contentBackground.style.width = "100%";
    contentBackground.style.height = "100%";
    contentBackground.setAttribute("data-nodetype", "contentBackground");
    logoContentParent.appendChild(contentBackground);

    let logoImageParent = document.createElement("div");
    logoImageParent.id = "logoImageParent";
    logoImageParent.className = "logoImageParent" + this.selectionLayerClass;
    this.setCommonSelector(logoImageParent);
    logoContentParent.appendChild(logoImageParent);
    logoImageParent.setAttribute("data-nodetype", "imageHolder");

    //Creating presenter image background
    let logoImageBackground = document.createElement("div");
    logoImageBackground.id = "logoImageBackground";
    logoImageBackground.className = "logoImageBackground";
    logoImageBackground.style.pointerEvents = "none";
    logoImageBackground.style.position = "absolute";
    logoImageBackground.setAttribute("data-nodetype", "imageBackground");
    logoImageParent.appendChild(logoImageBackground);

    let width = parseFloat(window.getComputedStyle(logoImageParent)["width"]);
    let height = parseFloat(window.getComputedStyle(logoImageParent)["height"]);
    let sgData = this.sgData[index];
    let src = source ? source : sgData.logoimage;
    src = this.specialGraphicsUtils.checkAppStaticURLSG(src, this.appStaticURL);
    if (!src) src = this.objDataToSG?.companylogo || this.appStaticURL + "genericassets/placeholderimages/logoimage.png";
    let cc = contrast ? "logoBrightnessSG" : "";
    let logoImage = this.specialGraphicsUtils.createImageElement(logoImageParent, "logoImage " + cc, "", src, width, height, 0, 0, "logoimage", sgData, "sgLogoImageNode");

    logoImage.style.minHeight = height + "px";
    let offsetVal = this.getOffsetRectByParent(sgParent, logoImageParent);
    logoImage.setAttribute("data-x", offsetVal.left);
    logoImage.setAttribute("data-y", offsetVal.top);
    logoImage.setAttribute("data-nodetype", "imageNode");

    this.eventManager.addEvent(logoImage, "dblclick", this.imageDoubleClickEvent);
    logoImage.setAttribute("clicklistener", "true");

    //Creating overlay div
    let overlayDiv = document.createElement("div");
    overlayDiv.id = "logoOverlayDiv";
    overlayDiv.className = "logoOverlayDiv" + this.moodanimation;
    overlayDiv.setAttribute("data-nodetype", "imageOverlay");
    logoImageParent.appendChild(overlayDiv);
    this.specialGraphicsUtils.setOpacityAttribute(logoImage);
    if (sgData.logoimagedata) logoImageParent.setAttribute("data-logodata", sgData.logoimagedata);
    if (sgData.logoimagetype) logoImageParent.setAttribute("data-logotype", sgData.logoimagetype);
};

//Getting offset by Parent
SGBaseClass.prototype.getOffsetRectByParent = function (parent, element) {
    let top = element.offsetTop;
    let left = element.offsetLeft;
    let elementParent = element.parentElement;

    while (parent != elementParent) {
        top = top + elementParent.offsetTop;
        left = left + elementParent.offsetLeft;
        elementParent = elementParent.parentElement;
    }

    return { top: top, left: left, width: element.offsetWidth, height: element.offsetHeight };
};

//Create Customer parent
SGBaseClass.prototype.createCustomerBaseWithData = function (parent, nodeObj = null) {
    let customerParent = document.createElement("div");
    customerParent.id = "customerParent";
    customerParent.className = "presenterParent";
    this.setTextType(customerParent);
    parent.appendChild(customerParent);

    let customerTextParent = document.createElement("div");
    customerTextParent.id = "customerTextParent";
    customerTextParent.style.position = "relative";
    customerTextParent.className = "presenterTextParent";
    this.setTextType(customerTextParent);
    customerParent.appendChild(customerTextParent);

    this.createCustomerName(customerTextParent, nodeObj);

    let customerLine = document.createElement("div");
    customerLine.id = "customerLine";
    customerLine.setAttribute("data-animation", "creatorname");
    customerLine.className = "presenterLine " + this.moodanimation;
    customerTextParent.appendChild(customerLine);

    this.createCustomerDesignation(customerTextParent, nodeObj);
    this.createCustomerImageNode(customerParent);
    return customerParent;
};

SGBaseClass.prototype.createCustomerImageWithData = function (parent) {
    this.createCustomerImageNode(parent);
    return parent.querySelector("[id='customerContentParent']");
};
SGBaseClass.prototype.createCustomerTextWithData = function (parent, nodeObj) {
    let customerParent = document.createElement("div");
    customerParent.id = "customerParent";
    customerParent.className = "presenterParent";
    customerParent.setAttribute("presenteralone", "true");
    this.setTextType(customerParent);
    parent.appendChild(customerParent);

    let customerTextParent = document.createElement("div");
    customerTextParent.id = "customerTextParent";
    customerTextParent.style.position = "relative";
    customerTextParent.className = "presenterTextParent";
    this.setTextType(customerTextParent);
    customerParent.appendChild(customerTextParent);

    this.createCustomerName(customerTextParent, nodeObj);

    let customerLine = document.createElement("div");
    customerLine.id = "customerLine";
    customerLine.className = "presenterLine " + this.moodanimation;
    customerLine.setAttribute("data-animation", "creatorname");
    customerTextParent.appendChild(customerLine);

    this.createCustomerDesignation(customerTextParent, nodeObj);
    return customerParent;
};
//Create Presenter Name node
SGBaseClass.prototype.createCustomerName = function (textParent, nodeObj) {
    let className = this.styleData.fontData.customername + " ";
    let customerName = this.sgData[0]?.customername != null && this.sgData[0]?.customername != undefined ? this.sgData[0].customername : this.sgData.customername;
    let customerNameParent = document.createElement("div");
    customerNameParent.id = "sgCustomerNameParentNode";
    customerNameParent.className = "presenterNameParent";
    textParent.appendChild(customerNameParent);

    let customerNameNode = this.specialGraphicsUtils.createTextElement(customerNameParent, customerName, "sgCustomerNameNode", "presenterName " + className + this.selectionLayerClass + this.moodanimation, "customername");
    this.setCommonSelector(customerNameNode);
    if (nodeObj && nodeObj.image && nodeObj.image.isseparate && nodeObj.image.isseparate == "true") {
        customerNameNode.removeAttribute("data-fontfit");
    } //else customerNameNode.setAttribute("data-fontfit", "false");
    if (nodeObj && nodeObj.namelinecount) customerNameNode.setAttribute("data-linecount", nodeObj.namelinecount);
    customerNameNode.contentEditable = "true";
    customerNameNode.setAttribute("data-prompt-text", this.styleData.customerNamePrompt ? this.styleData.customerNamePrompt : "Customer Name");
    customerNameNode.setAttribute("data-animation", "customername");

    let elementStyle = window.getComputedStyle(customerNameNode);
    let lineHeight = parseFloat(elementStyle["line-height"]);
    customerNameNode.style.minHeight = lineHeight + "px";

    this.applyTextBaseProps(customerNameNode, 0, "customername");
    this.setTextFocus(customerNameNode);
};
//Create Presenter Desigination node
SGBaseClass.prototype.createCustomerDesignation = function (textParent, nodeObj) {
    let className = this.styleData.fontData.customerdesignation + " ";
    let customerDesigination = this.sgData[0]?.customerdesignation != null && this.sgData[0]?.customerdesignation != undefined ? this.sgData[0].customerdesignation : this.sgData.customerdesignation;

    let customerDesiginationParent = document.createElement("div");
    customerDesiginationParent.id = "sgCustomerDesiginationParentNode";
    customerDesiginationParent.className = "presenterNameParent";
    textParent.appendChild(customerDesiginationParent);

    let customerDesignationNode = this.specialGraphicsUtils.createTextElement(customerDesiginationParent, customerDesigination, "sgCustomerDesiginationNode", "presenterDesigination " + className + this.selectionLayerClass + this.moodanimation, "customerdesignation");
    this.setCommonSelector(customerDesignationNode);
    if (nodeObj && nodeObj.image && nodeObj.image.isseparate && nodeObj.image.isseparate == "true") {
        customerDesignationNode.removeAttribute("data-fontfit");
    }
    customerDesignationNode.setAttribute("data-animation", "customerdesignation");
    // else customerDesignationNode.setAttribute("data-fontfit", "false");
    if (nodeObj && nodeObj.desiginationlinecount) customerDesignationNode.setAttribute("data-linecount", nodeObj.desiginationlinecount);
    customerDesignationNode.contentEditable = "true";
    customerDesignationNode.setAttribute("data-prompt-text", this.styleData.customerDesignationPrompt ? this.styleData.customerDesignationPrompt : "Customer Designation");
    this.applyTextBaseProps(customerDesignationNode, 0, "customerdesignation");
    this.setTextFocus(customerDesignationNode);
};
//Create presenter image node
SGBaseClass.prototype.createCustomerImageNode = function (parentNode) {
    //Creating customer image main parent
    let customerContentParent = document.createElement("div");
    customerContentParent.id = "customerContentParent";
    customerContentParent.className = "presenterContentParent " + this.moodanimation;
    customerContentParent.style.position = "relative";
    customerContentParent.setAttribute("data-type", "IMAGE");
    customerContentParent.setAttribute("data-animation", "customerimage");
    customerContentParent.setAttribute("data-nodetype", "contentContainer");
    parentNode.appendChild(customerContentParent);

    //Creating customer image content background
    let contentBackground = document.createElement("div");
    contentBackground.id = "contentBackground";
    contentBackground.className = "contentBackground";
    contentBackground.style.position = "absolute";
    contentBackground.style.pointerEvents = "none";
    contentBackground.style.width = "100%";
    contentBackground.style.height = "100%";
    contentBackground.setAttribute("data-nodetype", "contentBackground");
    customerContentParent.appendChild(contentBackground);

    //Creating customer image holder
    let customerImageParent = document.createElement("div");
    customerImageParent.id = "customerImageParent";
    customerImageParent.setAttribute("data-nodetype", "imageHolder");
    customerImageParent.setAttribute("data-type", "IMAGE");
    customerImageParent.className = "presenterImageParent" + this.selectionLayerClass;
    this.setCommonSelector(customerImageParent);
    customerContentParent.appendChild(customerImageParent);

    //Creating customer image background
    let customerImageBackground = document.createElement("div");
    customerImageBackground.id = "customerImageBackground";
    customerImageBackground.className = "presenterImageBackground";
    customerImageBackground.style.pointerEvents = "none";
    customerImageBackground.style.position = "absolute";
    customerImageBackground.setAttribute("data-nodetype", "imageBackground");
    customerImageParent.appendChild(customerImageBackground);

    //Creating customer image node
    let width = parseFloat(window.getComputedStyle(customerImageParent)["width"]);
    let height = parseFloat(window.getComputedStyle(customerImageParent)["height"]);
    let customerImageData = this.sgData[0]?.customerimage != null && this.sgData[0]?.customerimage != undefined ? this.sgData[0].customerimage : this.sgData.customerimage;
    if (!customerImageData || customerImageData == "undefined") customerImageData = this.appStaticURL + "genericassets/placeholderimages/creatorimage.jpg";
    customerImageData = this.specialGraphicsUtils.checkAppStaticURLSG(customerImageData, this.appStaticURL);
    let customerImage = this.specialGraphicsUtils.createImageElement(customerImageParent, "presenterImage", "", customerImageData, width, height, 0, 0, "customerimage", this.sgData[0] ? this.sgData[0] : this.sgData, "sgCustomerImageNode");
    customerImage.setAttribute("data-nodetype", "imageNode");

    customerImage.style.width = "100%";
    let offsetVal = this.getOffsetRectByParent(parentNode, customerImageParent);
    let offsetVal2 = this.getOffsetRectByParent(this.sgParent, customerImageParent);
    customerImage.setAttribute("data-x", offsetVal2.left - offsetVal.left);
    customerImage.setAttribute("data-y", offsetVal.top);

    this.eventManager.addEvent(customerImage.parentElement, "dblclick", this.imageDoubleClickEvent);
    customerImage.parentElement.setAttribute("clicklistener", "true");

    let nameDesigination = this.sgData[0]?.["customername"] + "$$" + this.sgData[0]?.["customerdesignation"];
    let assetText = this.sgData[0]?.["customerimageprompt"] || nameDesigination || "";
    if (assetText && this.imageLoadUsingPrompt && this.sgData[0]["customerimageneedassetupdate"] == "true") this.imageLoadUsingPrompt(customerImage, assetText, 0, "person");
    else if (assetText) customerImage.parentElement.setAttribute("data-node-graphic-text", assetText);

    //Creating overlay div
    let colorDiv = document.createElement("div");
    colorDiv.id = "customerColorDiv";
    colorDiv.className = "customerColorDiv " + this.moodanimation;
    colorDiv.setAttribute("data-nodetype", "imageOverlay");
    colorDiv.setAttribute("data-cssslide", "slide0customerimage");
    customerImageParent.appendChild(colorDiv);
};
//Create Presenter parent
SGBaseClass.prototype.createPresenterBaseWithData = function (parent, type, nodeObj = null) {
    let presenterParent = document.createElement("div");
    presenterParent.id = "presenterParent";
    presenterParent.className = "presenterParent";
    this.setTextType(presenterParent);
    parent.appendChild(presenterParent);

    let presenterTextParent = document.createElement("div");
    presenterTextParent.id = "presenterTextParent";
    presenterTextParent.style.position = "relative";
    presenterTextParent.className = "presenterTextParent";
    this.setTextType(presenterTextParent);
    presenterParent.appendChild(presenterTextParent);

    this.createPresenterName(presenterTextParent, type, nodeObj);

    let presenterLine = document.createElement("div");
    presenterLine.id = "presenterLine";
    presenterLine.className = "presenterLine " + this.moodanimation;
    presenterTextParent.appendChild(presenterLine);

    this.createPresentorDesignation(presenterTextParent, type, nodeObj);
    this.createPresentorImageNode(presenterParent);
    return presenterParent;
};
SGBaseClass.prototype.createPresenterImageWithData = function (parent) {
    this.createPresentorImageNode(parent);
    return parent.querySelector("[id='presenterContentParent']");
};
SGBaseClass.prototype.createPresenterTextWithData = function (parent, nodeObj) {
    let presenterAloneParent = document.createElement("div");
    presenterAloneParent.id = "presenterParent";
    presenterAloneParent.className = "presenterParent";
    presenterAloneParent.setAttribute("presenteralone", "true");
    this.setTextType(presenterAloneParent);
    parent.appendChild(presenterAloneParent);

    let presenterTextAloneParent = document.createElement("div");
    presenterTextAloneParent.id = "presenterTextParent";
    presenterTextAloneParent.style.position = "relative";
    presenterTextAloneParent.className = "presenterTextParent";
    this.setTextType(presenterTextAloneParent);
    presenterAloneParent.appendChild(presenterTextAloneParent);

    this.createPresenterName(presenterTextAloneParent, null, nodeObj);

    let presenterLine = document.createElement("div");
    presenterLine.id = "presenterLine";
    presenterLine.className = "presenterLine " + this.moodanimation;
    presenterTextAloneParent.appendChild(presenterLine);

    this.createPresentorDesignation(presenterTextAloneParent, null, nodeObj);

    return presenterAloneParent;
};
//Create Presenter Name node
SGBaseClass.prototype.createPresenterName = function (textParent, type, nodeObj) {
    let className = this.styleData.fontData.creatorname + " ";
    let sgDataValue = this.sgData?.[0]?.creatorname ? this.sgData[0] : this.sgData;
    let creatorName = this.sgData?.[0]?.creatorname ? this.sgData[0].creatorname : this.sgData.creatorname;

    let presenterNameParent = document.createElement("div");
    presenterNameParent.id = "sgPresentorNameParentNode";
    presenterNameParent.className = "presenterNameParent";
    textParent.appendChild(presenterNameParent);

    let presenterNameNode = this.specialGraphicsUtils.createTextElement(presenterNameParent, creatorName, "sgPresentorNameNode", "presenterName " + className + this.selectionLayerClass + this.moodanimation, "creatorname");
    this.setCommonSelector(presenterNameNode);
    presenterNameNode.setAttribute("data-animation", "creatorname");
    if (nodeObj?.image?.isseparate && nodeObj.image.isseparate == "true") {
        presenterNameNode.removeAttribute("data-fontfit");
    }
    // else presenterNameNode.setAttribute("data-fontfit", "false");
    if (nodeObj?.namelinecount) presenterNameNode.setAttribute("data-linecount", nodeObj.namelinecount);
    presenterNameNode.contentEditable = "true";
    presenterNameNode.setAttribute("data-prompt-text", this.styleData.presenterNamePrompt);
    if (type && type == "cus") presenterNameNode.setAttribute("data-prompt-text", "Customer Name");

    let elementStyle = window.getComputedStyle(presenterNameNode);
    let lineHeight = parseFloat(elementStyle["line-height"]);
    presenterNameNode.style.minHeight = lineHeight + "px";

    this.applyTextBaseProps(presenterNameNode, 0, "creatorname");
    this.setTextFocus(presenterNameNode);
};
//Create Presenter Desigination node
SGBaseClass.prototype.createPresentorDesignation = function (textParent, type, nodeObj) {
    let className = this.styleData.fontData.desigination + " ";
    let creatorDesigination = this.sgData[0]?.creatordesignation != null && this.sgData[0]?.creatordesignation != undefined ? this.sgData[0].creatordesignation : this.sgData.creatordesignation;

    let presenterDesignationParent = document.createElement("div");
    presenterDesignationParent.id = "sgPresentorDesiginationParentNode";
    presenterDesignationParent.className = "presenterDesiginationParent";
    textParent.appendChild(presenterDesignationParent);

    let presenterDesignationNode = this.specialGraphicsUtils.createTextElement(presenterDesignationParent, creatorDesigination, "sgPresentorDesiginationNode", "presenterDesigination " + className + this.selectionLayerClass + this.moodanimation, "creatordesignation");
    this.setCommonSelector(presenterDesignationNode);
    if (nodeObj && nodeObj.image && nodeObj.image.isseparate && nodeObj.image.isseparate == "true") {
        presenterDesignationNode.removeAttribute("data-fontfit");
    }
    presenterDesignationNode.setAttribute("data-animation", "desigination");
    // else presenterDesignationNode.setAttribute("data-fontfit", "false");
    if (nodeObj && nodeObj.desiginationlinecount) presenterDesignationNode.setAttribute("data-linecount", nodeObj.desiginationlinecount);
    presenterDesignationNode.contentEditable = "true";
    presenterDesignationNode.setAttribute("data-prompt-text", this.styleData.presenterDesignationPrompt);
    if (type && type == "cus") presenterDesignationNode.setAttribute("data-prompt-text", "Customer Designation");
    this.applyTextBaseProps(presenterDesignationNode, 0, "creatordesignation");
    this.setTextFocus(presenterDesignationNode);
};
//Create presenter image node
SGBaseClass.prototype.createPresentorImageNode = function (parentNode) {
    //Creating presenter image main parent
    let presenterContentParent = document.createElement("div");
    presenterContentParent.id = "presenterContentParent";
    presenterContentParent.className = "presenterContentParent " + this.moodanimation;
    presenterContentParent.style.position = "relative";
    presenterContentParent.setAttribute("data-type", "IMAGE");
    presenterContentParent.setAttribute("data-animation", "creatorimage");
    presenterContentParent.setAttribute("data-nodetype", "contentContainer");
    parentNode.appendChild(presenterContentParent);

    //Creating presenter image content background
    let contentBackground = document.createElement("div");
    contentBackground.id = "contentBackground";
    contentBackground.className = "contentBackground";
    contentBackground.style.position = "absolute";
    contentBackground.style.pointerEvents = "none";
    contentBackground.style.width = "100%";
    contentBackground.style.height = "100%";
    contentBackground.setAttribute("data-nodetype", "contentBackground");
    presenterContentParent.appendChild(contentBackground);

    //Creating presenter image holder
    let presenterImageParent = document.createElement("div");
    presenterImageParent.id = "presenterImageParent";
    presenterImageParent.setAttribute("data-nodetype", "imageHolder");
    presenterImageParent.setAttribute("data-type", "IMAGE");
    presenterImageParent.className = "presenterImageParent" + this.selectionLayerClass;
    this.setCommonSelector(presenterImageParent);
    presenterContentParent.appendChild(presenterImageParent);

    //Creating presenter image background
    let presenterImageBackground = document.createElement("div");
    presenterImageBackground.id = "presenterImageBackground";
    presenterImageBackground.className = "presenterImageBackground";
    presenterImageBackground.style.pointerEvents = "none";
    presenterImageBackground.style.position = "absolute";
    presenterImageBackground.setAttribute("data-nodetype", "imageBackground");
    presenterImageParent.appendChild(presenterImageBackground);

    //Creating presenter image node
    let width = parseFloat(window.getComputedStyle(presenterImageParent)["width"]);
    let height = parseFloat(window.getComputedStyle(presenterImageParent)["height"]);
    let creatorImage = this.sgData[0]?.creatorimage != null && this.sgData[0]?.creatorimage != undefined ? this.sgData[0].creatorimage : this.sgData.creatorimage;
    creatorImage = this.specialGraphicsUtils.checkAppStaticURLSG(creatorImage, this.appStaticURL);
    let presenterImage = this.specialGraphicsUtils.createImageElement(presenterImageParent, "presenterImage", "", creatorImage, width, height, 0, 0, "creatorimage", this.sgData[0] ? this.sgData[0] : this.sgData, "sgPresentorImageNode");
    presenterImage.setAttribute("data-nodetype", "imageNode");

    presenterImage.style.width = "100%";
    presenterImage.style.height = "100%";
    presenterImage.style.objectFit = "cover";
    let offsetVal = this.getOffsetRectByParent(parentNode, presenterImageParent);
    let offsetVal2 = this.getOffsetRectByParent(this.sgParent, presenterImageParent);
    presenterImage.setAttribute("data-x", offsetVal2.left - offsetVal.left);
    presenterImage.setAttribute("data-y", offsetVal.top);

    this.eventManager.addEvent(presenterImage.parentElement, "dblclick", this.imageDoubleClickEvent);
    presenterImage.parentElement.setAttribute("clicklistener", "true");

    let nameDesigination = this.sgData[0]?.["creatorname"] + "$$" + this.sgData[0]?.["creatordesignation"];
    let assetText = this.sgData[0]?.["creatorimageprompt"] || nameDesigination || "";
    if (assetText && this.imageLoadUsingPrompt && this.sgData[0]["creatorimageneedassetupdate"] == "true") this.imageLoadUsingPrompt(presenterImage, assetText, 0, "person");
    else if (assetText) presenterImage.parentElement.setAttribute("data-node-graphic-text", assetText);

    //Creating overlay div
    let colorDiv = document.createElement("div");
    colorDiv.id = "presentorColorDiv";
    colorDiv.setAttribute("data-animation", "covershape1");
    colorDiv.className = "presentorColorDiv" + this.moodanimation;
    colorDiv.setAttribute("data-nodetype", "imageOverlay");
    colorDiv.setAttribute("data-cssslide", "slide0creatorimage");
    presenterImageParent.appendChild(colorDiv);
    this.specialGraphicsUtils.setOpacityAttribute(colorDiv);

    let index = 0;
    // Setting overlay enable/disable
    let tagWord = "creator";
    if (this.sgData[index] && colorDiv && this.sgData[index][tagWord + "imageoverlayshow"]) {
        colorDiv.style.display = this.sgData[index][tagWord + "imageoverlayshow"] == "true" ? "block" : "none";
        if (presenterContentParent && this.sgData[index][tagWord + "imageoverlayshow"] == "true") presenterContentParent.setAttribute("data-isoverlay", "true");
    } else if (colorDiv) colorDiv.style.display = "none";

    // Setting overlay opacity
    if (this.sgData[index] && this.sgData[index][tagWord + "imageopacity"] && colorDiv) colorDiv.style.opacity = this.sgData[index][tagWord + "imageopacity"];
};
SGBaseClass.prototype.createCoverNumber = function (parentNode, type = "yr", propertyValue = null, flexValue = null) {
    let textData = propertyValue ? propertyValue : type == "yr" ? "2020" : "10";
    textData = this.sgData[0].covernumber != undefined && this.sgData[0].covernumber != "undefined" && this.sgData[0].covernumber != null ? this.sgData[0].covernumber : textData;
    if (type == "num" && textData.length > 2) textData = textData.substring(0, 2);

    let covernumberParent = document.createElement("div");
    covernumberParent.id = "covernumber";
    covernumberParent.className = "covernumber " + this.moodanimation;
    covernumberParent.setAttribute("data-type", "TEXT");
    covernumberParent.setAttribute("data-showselector", "false");
    covernumberParent.setAttribute("data-animation", "covernumber");
    parentNode.appendChild(covernumberParent);
    this.specialGraphicsUtils.setOpacityAttribute(covernumberParent);
    if (flexValue) covernumberParent.style.flex = flexValue;

    let className = this.styleData.fontData.number + " ";
    let covernumber = this.specialGraphicsUtils.createTextElement(covernumberParent, textData, "covernumbercontent", "covernumbercontent " + className + this.selectionLayerClass, "covernumber");
    this.setCommonSelector(covernumber);
    covernumber.contentEditable = "true";
    covernumber.style.pointerEvents = "auto";
    covernumber.setAttribute("data-prompt-text", propertyValue ? propertyValue : type == "yr" ? "2022" : "10");

    this.applyTextBaseProps(covernumber, 0, "covernumber");
    this.setTextFocus(covernumber);
};
//Create Social icon node for coverpage
SGBaseClass.prototype.createSocialIconCover = function (parent) {
    let customLinkIconParent = document.createElement("div");
    customLinkIconParent.id = "customLinkIconParent";
    customLinkIconParent.className = "customLinkIconParent";
    this.setTextType(customLinkIconParent);
    parent.appendChild(customLinkIconParent);

    for (let i = 1; i < 3; i++) {
        let customSocialLink = document.createElement("div");
        customSocialLink.id = "sgCustomSocialLink" + i;
        customSocialLink.className = "customSocialLink";
        this.setTextType(customSocialLink);
        customLinkIconParent.appendChild(customSocialLink);

        let iconNodeParent = document.createElement("div");
        iconNodeParent.id = "iconParent" + i;
        iconNodeParent.className = "iconParent";
        this.setTextType(iconNodeParent);
        iconNodeParent.style.position = "relative";
        iconNodeParent.setAttribute("data-nodetype", "contentContainer");
        customSocialLink.appendChild(iconNodeParent);

        let contentBackground = document.createElement("div");
        contentBackground.id = "contentBackground";
        contentBackground.className = "contentBackground";
        contentBackground.style.position = "absolute";
        contentBackground.style.pointerEvents = "none";
        contentBackground.style.width = "100%";
        contentBackground.style.height = "100%";
        this.setTextType(contentBackground);
        contentBackground.setAttribute("data-nodetype", "contentBackground");
        iconNodeParent.appendChild(contentBackground);

        let iconHolder = document.createElement("div");
        iconHolder.id = "customSocialLinkIcon" + i;
        // iconHolder.setAttribute("data-animation", "socialicon");
        iconHolder.className = "customSocialLinkIcon" + this.moodanimation;
        iconHolder.setAttribute("data-nodetype", "iconHolder");
        iconNodeParent.appendChild(iconHolder);

        let iconBackground = document.createElement("div");
        iconBackground.id = "iconBackground";
        iconBackground.className = "iconBackground";
        iconBackground.style.pointerEvents = "none";
        this.setTextType(iconBackground);
        iconBackground.setAttribute("data-nodetype", "iconBackground");
        iconHolder.appendChild(iconBackground);

        let iconOverlay = document.createElement("div");
        iconOverlay.id = "iconOverlay";
        iconOverlay.className = "iconOverlay " + this.moodanimation;
        iconOverlay.style.pointerEvents = "none";
        this.setTextType(iconOverlay);
        iconOverlay.setAttribute("data-nodetype", "iconOverlay");
        iconHolder.appendChild(iconOverlay);

        this.specialGraphicsUtils.socialIconsPropertyApplyFromMood(this.socialiconsData, iconHolder);

        let socialIconTextParent = document.createElement("div");
        socialIconTextParent.id = "socialIconTextParent";
        socialIconTextParent.className = "socialIconTextParent";
        this.setTextType(socialIconTextParent);
        customSocialLink.appendChild(socialIconTextParent);

        let socialIconTextSubTitle = this.specialGraphicsUtils.createTextElement(
            socialIconTextParent,
            this.sgData[0]["customsociallinksub" + i],
            "socialIconTextSubTitle" + i,
            "socialIconTextSubTitle  " + this.styleData.fontData.socialiconcontent + " " + this.selectionLayerClass + this.moodanimation,
            "customsociallinksub" + i
        );
        this.setCommonSelector(socialIconTextSubTitle);
        socialIconTextSubTitle.contentEditable = "true";
        socialIconTextSubTitle.setAttribute("data-prompt-text", "Enter Social link text");
        socialIconTextSubTitle.style.pointerEvents = "all";
        this.setTextFocus(socialIconTextSubTitle);
    }
};
//Create Mood shapes
SGBaseClass.prototype.createMoodShapes = function (parent, count = 4, property = null) {
    for (let i = 0; i < count; i++) {
        let covershape = document.createElement("div");
        covershape.id = "covershape" + (i + 1);
        covershape.className = "covershape" + (i + 1) + " " + this.moodanimation + " ";
        covershape.style.pointerEvents = "none";
        covershape.setAttribute("data-animation", "covershape" + (i + 1));
        covershape.setAttribute("data-type", "TEXT");
        parent.appendChild(covershape);
        this.specialGraphicsUtils.setOpacityAttribute(covershape);

        if (property && property["shape" + (i + 1)] && property["shape" + (i + 1)].nested) {
            let covershapeInner = document.createElement("div");
            covershapeInner.id = "covershapeInner" + (i + 1);
            covershapeInner.className = "covershapeInner";
            covershapeInner.style.pointerEvents = "none";
            covershapeInner.setAttribute("data-type", "TEXT");
            covershape.appendChild(covershapeInner);
            if (this.moodName == "bubblecss") covershapeInner.classList.add("bubbleAnimationSG");
        }
    }
};
SGBaseClass.prototype.loadAssets = function (arrAssets, successCallback, errorCallback, objData) {
    let assetLoader = new window["SGAssetLoader"]();
    assetLoader
        .loadAssets(arrAssets, this.appStaticURL)
        .then((responseData) => {
            successCallback ? successCallback(responseData, objData) : "";
        })
        .catch(function (rej) {
            if (errorCallback) errorCallback();
            console.log("SG - Error on Specialgraphics base");
            console.log(rej);
        });
};
SGBaseClass.prototype.createVenue = function (parent) {
    let venueParent = document.createElement("div");
    venueParent.id = "sgVenueParent";
    this.setTextType(venueParent);
    venueParent.setAttribute("data-animation", "venue");
    venueParent.className = "venueParent" + this.moodanimation;
    venueParent.style.position = "relative";
    parent.appendChild(venueParent);

    let className = this.styleData.fontData.venue + " ";
    let venueNode = this.specialGraphicsUtils.createTextElement(venueParent, this.sgData[0].venue, "sgVenueNode", "venueText " + className + this.selectionLayerClass, "venue");
    this.setCommonSelector(venueNode);
    venueNode.contentEditable = "true";
    venueNode.setAttribute("data-prompt-text", this.styleData.venuePrompt);

    this.applyTextBaseProps(venueNode, 0, "venue");
    this.setTextFocus(venueNode);

    return venueNode;
};

SGBaseClass.prototype.contactBase = function (assetParent) {
    let oldContactParent = assetParent.querySelector("[id='contactParent']");
    if (oldContactParent) oldContactParent.parentElement.removeChild(oldContactParent);

    let contactParent = document.createElement("div");
    contactParent.id = "contactParent";
    this.setTextType(contactParent);
    contactParent.className = "contactParent";
    assetParent.appendChild(contactParent);
    let addressParent = this.createContactData(contactParent, "venue", "mailingAddress", "Address");

    let contactLine1 = document.createElement("div");
    contactLine1.id = "contactLine1";
    contactLine1.setAttribute("data-animation", "connector");
    contactLine1.className = "contactLine contactLine1 " + this.moodanimation;
    addressParent.appendChild(contactLine1);

    let emailParent = this.createContactData(contactParent, "creatoremail", "emailAddress", "Mail");

    let contactLine2 = document.createElement("div");
    contactLine2.id = "contactLine2";
    contactLine2.setAttribute("data-animation", "connector");
    contactLine2.className = "contactLine contactLine2" + this.moodanimation;
    emailParent.appendChild(contactLine2);

    let phoneParent = this.createContactData(contactParent, "phone", "phoneNumber", "Phone");

    let contactLine3 = document.createElement("div");
    contactLine3.id = "contactLine3";
    contactLine3.setAttribute("data-animation", "connector");
    contactLine3.className = "contactLine contactLine3" + this.moodanimation;
    phoneParent.appendChild(contactLine3);

    this.createContactData(contactParent, "website", "website", "Website");
};

//Create contact style asset's data here
SGBaseClass.prototype.createContactData = function (parent, key, id, prompt) {
    let elmentParent = document.createElement("div");
    elmentParent.id = "sg" + id + "Parent";
    elmentParent.className = id + "Parent ctafullnode";
    this.setTextType(elmentParent);
    parent.appendChild(elmentParent);

    let iconNodeParent = document.createElement("div");
    iconNodeParent.id = id + "IconParent";
    iconNodeParent.className = this.moodanimation + " " + id + "IconParent ctaiconnode";
    this.setTextType(iconNodeParent);
    iconNodeParent.style.position = "relative";
    iconNodeParent.setAttribute("data-nodetype", "contentContainer");
    elmentParent.appendChild(iconNodeParent);

    let contentBackground = document.createElement("div");
    contentBackground.id = "contentBackground";
    contentBackground.className = "contentBackground";
    contentBackground.style.position = "absolute";
    contentBackground.style.pointerEvents = "none";
    contentBackground.style.width = "100%";
    contentBackground.style.height = "100%";
    this.setTextType(contentBackground);
    contentBackground.setAttribute("data-nodetype", "contentBackground");
    iconNodeParent.appendChild(contentBackground);

    let contactIconNode = document.createElement("div");
    contactIconNode.id = id + "IconNode";
    contactIconNode.className = id + "IconNode";
    contactIconNode.setAttribute("data-nodetype", "iconHolder");
    iconNodeParent.appendChild(contactIconNode);

    let iconBackground = document.createElement("div");
    iconBackground.id = "iconBackground";
    iconBackground.className = "iconBackground";
    iconBackground.style.pointerEvents = "none";
    this.setTextType(iconBackground);
    iconBackground.setAttribute("data-nodetype", "iconBackground");
    contactIconNode.appendChild(iconBackground);

    let iconOverlay = document.createElement("div");
    iconOverlay.id = "iconOverlay";
    iconOverlay.className = "iconOverlay " + this.moodanimation;
    iconOverlay.style.pointerEvents = "none";
    this.setTextType(iconOverlay);
    iconOverlay.setAttribute("data-nodetype", "iconOverlay");
    contactIconNode.appendChild(iconOverlay);

    let textParent = document.createElement("div");
    textParent.id = id + "textParent";
    textParent.className = id + "TextParent";
    this.setTextType(textParent);
    elmentParent.appendChild(textParent);

    let className = " " + this.styleData.fontData.socialicontitle + " ";
    let textContent = this.sgData[0][key + "prompt"] ? this.sgData[0][key + "prompt"] : prompt;
    let promptText = this.specialGraphicsUtils.createTextElement(textParent, textContent, key + "promptText", " promptText ctaheadernode " + className + this.selectionLayerClass + this.moodanimation, key + "prompt");
    this.setCommonSelector(promptText);
    promptText.contentEditable = "true";
    promptText.setAttribute("data-prompt-text", prompt);
    this.setTextFocus(promptText);

    // if (this.contactNodesHeightFit) {
    //     promptText.contactnodesheightfit = this.contactNodesHeightFit;
    //     promptText.setAttribute("contactnodesheightfit", "true");
    // }

    let ctextCassName = " ctacontentnode " + this.styleData.fontData.socialiconcontent + " ";
    let elementNode = this.specialGraphicsUtils.createTextElement(textParent, this.sgData[0][key], "sg" + id, id + ctextCassName + this.selectionLayerClass + this.moodanimation, key);
    this.setCommonSelector(elementNode);
    elementNode.contentEditable = "true";
    elementNode.setAttribute("data-prompt-text", this.styleData[id + "Prompt"]);
    if (key == "website") this.updateAgendaLink(null, this.sgData[0][key], elementNode.id);

    // if (this.contactNodesHeightFit) {
    //     elementNode.contactnodesheightfit = this.contactNodesHeightFit;
    //     elementNode.setAttribute("contactnodesheightfit", "true");
    // }

    this.setTextFocus(elementNode);
    return elmentParent;
};

// For CTA REFERENCE
SGBaseClass.prototype.createReferenceBase = function (parent) {
    let oldReferenceParent = parent.querySelector("[id='referenceParent']");
    if (oldReferenceParent) oldReferenceParent.parentElement.removeChild(oldReferenceParent);

    let referenceParent = document.createElement("div");
    referenceParent.id = "referenceParent";
    referenceParent.className = "referenceParent";
    this.setTextType(referenceParent);
    parent.appendChild(referenceParent);

    let parent1 = this.createReferenceData(referenceParent, "reference1", "referenceLink1", "sgreferenceLinkHead1");

    let referenceLine1 = document.createElement("div");
    referenceLine1.id = "referenceLine1";
    referenceLine1.setAttribute("data-animation", "connector");
    referenceLine1.className = "referenceLine referenceLine1 " + this.moodanimation;
    parent1.appendChild(referenceLine1);

    let parent2 = this.createReferenceData(referenceParent, "reference2", "referenceLink2", "sgreferenceLinkHead2");

    let referenceLine2 = document.createElement("div");
    referenceLine2.id = "referenceLine2";
    referenceLine2.setAttribute("data-animation", "connector");
    referenceLine2.className = "referenceLine referenceLine2 " + this.moodanimation;
    parent2.appendChild(referenceLine2);

    let parent3 = this.createReferenceData(referenceParent, "reference3", "referenceLink3", "sgreferenceLinkHead3");

    let referenceLine3 = document.createElement("div");
    referenceLine3.id = "referenceLine3";
    referenceLine3.setAttribute("data-animation", "connector");
    referenceLine3.className = "referenceLine referenceLine3 " + this.moodanimation;
    parent3.appendChild(referenceLine3);

    this.createReferenceData(referenceParent, "reference4", "referenceLink4", "sgreferenceLinkHead4");
};

// Create SOCIAL style asset's data here
SGBaseClass.prototype.createSocialData = function (assetParent) {
    let oldCustomLinkParent = assetParent.querySelector("[id='customLinkIconParent']");
    if (oldCustomLinkParent) oldCustomLinkParent.parentElement.removeChild(oldCustomLinkParent);

    let customLinkIconParent = document.createElement("div");
    customLinkIconParent.id = "customLinkIconParent";
    customLinkIconParent.className = "customLinkIconParentCTA";
    this.setTextType(customLinkIconParent);
    assetParent.appendChild(customLinkIconParent);

    let customLinkIconInnerParent = document.createElement("div");
    customLinkIconInnerParent.id = "customLinkIconInnerParent";
    customLinkIconInnerParent.className = "customLinkIconInnerParent";
    this.setTextType(customLinkIconInnerParent);
    customLinkIconParent.appendChild(customLinkIconInnerParent);

    for (let i = 1; i < 6; i++) {
        let socialHead = i == 1 ? "LinkedIn" : i == 2 ? "Twitter" : i == 3 ? "Facebook" : i == 4 ? "Instagram" : "Skype";
        let customSocialLink = document.createElement("div");
        customSocialLink.id = "sgCustomSocialLink" + i;
        customSocialLink.className = "ctafullnode customSocialLink";
        this.setTextType(customSocialLink);
        customLinkIconInnerParent.appendChild(customSocialLink);

        let iconNodeParent = document.createElement("div");
        iconNodeParent.id = "iconParent" + i;
        iconNodeParent.className = "ctaiconnode customSocialLinkIconParent";
        this.setTextType(iconNodeParent);
        iconNodeParent.style.position = "relative";
        iconNodeParent.setAttribute("data-nodetype", "contentContainer");
        customSocialLink.appendChild(iconNodeParent);

        let contentBackground = document.createElement("div");
        contentBackground.id = "contentBackground";
        contentBackground.className = "contentBackground";
        contentBackground.style.position = "absolute";
        contentBackground.style.pointerEvents = "none";
        contentBackground.style.width = "100%";
        contentBackground.style.height = "100%";
        this.setTextType(contentBackground);
        contentBackground.setAttribute("data-nodetype", "contentBackground");
        iconNodeParent.appendChild(contentBackground);

        let iconHolder = document.createElement("div");
        iconHolder.id = "customSocialLinkIcon" + i;
        // iconHolder.setAttribute("data-animation", "socialicon");
        iconHolder.className = "customSocialLinkIcon" + this.moodanimation;
        iconHolder.setAttribute("data-nodetype", "iconHolder");
        iconNodeParent.appendChild(iconHolder);

        let iconBackground = document.createElement("div");
        iconBackground.id = "iconBackground";
        iconBackground.className = "iconBackground " + this.moodanimation;
        iconBackground.style.pointerEvents = "none";
        this.setTextType(iconBackground);
        iconBackground.setAttribute("data-nodetype", "iconBackground");
        iconHolder.appendChild(iconBackground);

        let iconOverlay = document.createElement("div");
        iconOverlay.id = "iconOverlay";
        iconOverlay.className = "iconOverlay " + this.moodanimation;
        iconOverlay.style.pointerEvents = "none";
        this.setTextType(iconOverlay);
        iconOverlay.setAttribute("data-nodetype", "iconOverlay");
        iconHolder.appendChild(iconOverlay);

        this.specialGraphicsUtils.socialIconsPropertyApplyFromMood(this.socialiconsData, iconHolder, assetParent);

        let socialIconTextParent = document.createElement("div");
        socialIconTextParent.id = "socialIconTextParent";
        socialIconTextParent.className = "socialIconTextParent ctatextparent";
        this.setTextType(socialIconTextParent);
        customSocialLink.appendChild(socialIconTextParent);

        let socialIconTextTitle = this.specialGraphicsUtils.createTextElement(socialIconTextParent, socialHead, "socialIconTextTitle" + i, "socialIconTextTitle ctaheadernode " + this.styleData.fontData.address + " secondary-color " + this.moodanimation, "customsociallink" + i);
        socialIconTextTitle.contentEditable = "false";
        socialIconTextTitle.style.pointerEvents = "all";
        // this.setTextFocus(socialIconTextTitle);
        // socialIconTextTitle.setAttribute("data-animation", "socialicontitle");

        let textContent = this.sgData[0]["customsociallinksub" + i];
        let socialIconTextSubTitle = this.specialGraphicsUtils.createTextElement(
            socialIconTextParent,
            this.sgData[0]["customsociallinksub" + i],
            "socialIconTextSubTitle" + i,
            "socialIconTextSubTitle ctacontentnode " + this.styleData.fontData.addressprompt + " " + this.selectionLayerClass + this.moodanimation,
            "customsociallinksub" + i
        );
        // socialIconTextSubTitle.setAttribute("data-animation", "socialiconcontent");
        this.setCommonSelector(socialIconTextSubTitle);
        socialIconTextSubTitle.contentEditable = "true";
        socialIconTextSubTitle.setAttribute("data-prompt-text", "Enter Social link text");
        socialIconTextSubTitle.style.pointerEvents = "all";
        this.setTextFocus(socialIconTextSubTitle);
        if (textContent && !textContent.includes("http")) textContent = "https://" + textContent;
        this.updateAgendaLink(null, textContent, customSocialLink.id);

        if (textContent && textContent.includes(".") && !textContent.includes(" ")) customSocialLink.classList.add("clsSocialLink");
        else customSocialLink.classList.remove("clsSocialLink");

        // if (this.contactNodesHeightFit) {
        //     socialIconTextSubTitle.contactnodesheightfit = this.contactNodesHeightFit;
        //     socialIconTextSubTitle.setAttribute("contactnodesheightfit", "true");
        // }

        if (i < 5) {
            let socialLine = document.createElement("div");
            socialLine.id = "socialLine" + i;
            socialLine.setAttribute("data-animation", "connector");
            socialLine.className = "socialLine socialLine" + i + " " + this.moodanimation;
            customSocialLink.appendChild(socialLine);
        }
    }
};
SGBaseClass.prototype.createReferenceData = function (parent, key, id, referenceID = null) {
    let elmentParent = document.createElement("div");
    elmentParent.id = "sg" + id + "Parent";
    elmentParent.className = id + "Parent ctafullnode";
    elmentParent.style.position = "relative";
    this.setTextType(elmentParent);
    parent.appendChild(elmentParent);

    let className = this.styleData.fontData.referencetitle + " ";

    let promptText = this.specialGraphicsUtils.createTextElement(elmentParent, this.sgData[0][key], referenceID, "promptText ctaheadernode " + className + this.selectionLayerClass + this.moodanimation, key);
    this.setCommonSelector(promptText);
    promptText.setAttribute("data-prompt-text", this.styleData["referenceHeadPrompt"]);
    promptText.contentEditable = "true";
    promptText.setAttribute("data-animation", "referencetitle");
    this.applyTextBaseProps(promptText, 0, key);
    this.setTextFocus(promptText);

    let ctextCassName = this.styleData.fontData.referencecontent + " ";
    let textContent = this.sgData[0]["referencesub" + key.replace("reference", "")];
    let elementNode = this.specialGraphicsUtils.createTextElement(elmentParent, textContent, "sg" + id, id + " ctacontentnode " + ctextCassName + this.selectionLayerClass + this.moodanimation, "referencesub" + key.replace("reference", ""));
    this.setCommonSelector(elementNode);
    elementNode.contentEditable = "true";
    elementNode.setAttribute("data-animation", "referencecontent");
    elementNode.setAttribute("data-prompt-text", this.styleData["referencePrompt"]);
    if (textContent && !textContent.includes("http")) textContent = "https://" + textContent;
    this.updateAgendaLink(null, textContent, elmentParent.id);
    this.applyTextBaseProps(elementNode, 0, "referencesub" + key.replace("reference", ""));

    if (textContent && textContent.includes(".") && !textContent.includes(" ")) elmentParent.classList.add("clsReference");
    else elmentParent.classList.remove("clsReference");

    this.setTextFocus(elementNode);
    return elmentParent;
};
//Create quote icon for quote assets
SGBaseClass.prototype.createQuoteIcon = function (parentNode, index = "") {
    let quoteParent = document.createElement("div");
    quoteParent.id = "quoteParent" + index;
    quoteParent.className = "quoteParent" + index + " " + this.moodanimation;
    quoteParent.style.pointerEvents = "none";
    quoteParent.setAttribute("data-animation", "quoteicon" + (index == "" ? "" : index));
    quoteParent.setAttribute("data-nodetype", "contentContainer");
    parentNode.appendChild(quoteParent);

    let contentBackground = document.createElement("div");
    contentBackground.id = "contentBackground";
    contentBackground.className = "contentBackground";
    contentBackground.style.position = "absolute";
    contentBackground.style.pointerEvents = "none";
    contentBackground.style.width = "100%";
    contentBackground.style.height = "100%";
    this.setTextType(contentBackground);
    contentBackground.setAttribute("data-nodetype", "contentBackground");
    quoteParent.appendChild(contentBackground);

    let quoteIcon = document.createElement("div");
    quoteIcon.id = "quoteIcon" + index;
    quoteIcon.className = "quoteIcon";
    quoteIcon.style.pointerEvents = "none";
    quoteIcon.setAttribute("data-nodetype", "iconHolder");
    this.setTextType(quoteIcon);
    quoteParent.appendChild(quoteIcon);

    let iconBackground = document.createElement("div");
    iconBackground.id = "iconBackground";
    iconBackground.className = "iconBackground";
    iconBackground.style.pointerEvents = "none";
    this.setTextType(iconBackground);
    iconBackground.setAttribute("data-nodetype", "iconBackground");
    quoteIcon.appendChild(iconBackground);

    let iconOverlay = document.createElement("div");
    iconOverlay.id = "iconOverlay";
    iconOverlay.className = "iconOverlay " + this.moodanimation;
    iconOverlay.style.pointerEvents = "none";
    this.setTextType(iconOverlay);
    iconOverlay.setAttribute("data-nodetype", "iconOverlay");
    quoteIcon.appendChild(iconOverlay);
};
SGBaseClass.prototype.createAuthorTextBase = function (parentNode, flexvalue = "", index = 0) {
    let authorParent = document.createElement("div");
    authorParent.id = "authorParent";
    authorParent.className = "authorParent";
    this.setTextType(authorParent);
    parentNode.appendChild(authorParent);
    if (flexvalue != "") authorParent.style.flex = flexvalue;

    let authorInnerParent = document.createElement("div");
    authorInnerParent.id = "authorInnerParent";
    authorInnerParent.className = "authorInnerParent authorfullnode ";
    this.setTextType(authorInnerParent);
    authorParent.appendChild(authorInnerParent);

    this.createAuthorName(authorInnerParent, index);
    this.createAuthorDesignation(authorInnerParent, index);
};
//Craete author name node
SGBaseClass.prototype.createAuthorName = function (textParent, index = 0) {
    let className = this.styleData.fontData.authorname + " ";
    let authorNameNode = this.specialGraphicsUtils.createTextElement(textParent, this.sgData[index].authorname, "sgAuthorNameNode", "authorName namenode " + className + this.selectionLayerClass + this.moodanimation, "authorname");
    this.setCommonSelector(authorNameNode);
    authorNameNode.contentEditable = "true";
    authorNameNode.setAttribute("data-animation", "authorname");
    authorNameNode.setAttribute("data-prompt-text", this.styleData.authorNamePrompt);
    this.applyTextBaseProps(authorNameNode, 0, "authorname");
    this.setTextFocus(authorNameNode);
    return authorNameNode;
};
//Craete author desigination node
SGBaseClass.prototype.createAuthorDesignation = function (textParent, index = 0) {
    let className = this.styleData.fontData.authordesigination + " ";
    let authorDesignationNode = this.specialGraphicsUtils.createTextElement(textParent, this.sgData[index].authordesignation, "sgAuthorDesignationNode", "authorDesignation designationnode " + className + this.selectionLayerClass + this.moodanimation, "authordesignation");
    this.setCommonSelector(authorDesignationNode);
    authorDesignationNode.setAttribute("data-animation", "authordesigination");
    authorDesignationNode.contentEditable = "true";
    authorDesignationNode.setAttribute("data-prompt-text", this.styleData.authorDesignationPrompt);
    this.applyTextBaseProps(authorDesignationNode, 0, "authordesignation");
    this.setTextFocus(authorDesignationNode);
    return authorDesignationNode;
};
//Create Author image with parent node
SGBaseClass.prototype.createAuthorImageNode = function (parentNode, index = 0) {
    let oldImageParent = parentNode.querySelector("[id='authorContentParent']");
    if (oldImageParent) oldImageParent.parentElement.removeChild(oldImageParent);

    //Creating author image main parent
    let authorContentParent = document.createElement("div");
    authorContentParent.id = "authorContentParent";
    authorContentParent.className = "authorContentParent " + this.moodanimation;
    authorContentParent.setAttribute("data-type", "IMAGE");
    authorContentParent.setAttribute("data-animation", "authorimage");
    authorContentParent.setAttribute("data-nodetype", "contentContainer");
    parentNode.appendChild(authorContentParent);

    //Creating author image content background
    let contentBackground = document.createElement("div");
    contentBackground.id = "contentBackground";
    contentBackground.className = "contentBackground";
    contentBackground.style.position = "absolute";
    contentBackground.style.pointerEvents = "none";
    contentBackground.style.width = "100%";
    contentBackground.style.height = "100%";
    contentBackground.setAttribute("data-nodetype", "contentBackground");
    authorContentParent.appendChild(contentBackground);

    let authorImageParent = document.createElement("div");
    authorImageParent.id = "authorImageParent";
    authorImageParent.className = "authorImageParent" + this.selectionLayerClass;
    this.setCommonSelector(authorImageParent);
    authorImageParent.setAttribute("data-nodetype", "imageHolder");
    authorContentParent.appendChild(authorImageParent);

    //Creating author image background
    let authorImageBackground = document.createElement("div");
    authorImageBackground.id = "authorImageBackground";
    authorImageBackground.className = "authorImageBackground";
    authorImageBackground.style.pointerEvents = "none";
    authorImageBackground.style.position = "absolute";
    authorImageBackground.setAttribute("data-nodetype", "imageBackground");
    authorImageParent.appendChild(authorImageBackground);

    let src = this.sgData[index].authorimage;
    if (src == "undefined" || src == undefined || src == null || src == "") src = "genericassets/placeholderimages/authorimage.jpg";
    src = this.specialGraphicsUtils.checkAppStaticURLSG(src, this.appStaticURL);
    let authorImage = this.specialGraphicsUtils.createImageElement(authorImageParent, "authorImage", "", src, 0, 0, 0, 0, "authorimage", this.sgData, "sgAuthorImageNode");
    authorImage.setAttribute("data-nodetype", "imageNode");

    authorImage.setAttribute("data-x", authorImageParent.offsetLeft);
    authorImage.setAttribute("data-y", authorImageParent.offsetTop);

    let nameDesigination = this.sgData[0]?.["authorname"] + "$$" + this.sgData[0]?.["authordesignation"];
    let assetText = this.sgData[0]?.["authorimageprompt"] || this.sgData[0]?.["authorimageimageprompt"] || nameDesigination || "";
    if (assetText && this.imageLoadUsingPrompt && this.sgData[0]["authorimageneedassetupdate"] == "true") this.imageLoadUsingPrompt(authorImage, assetText, 0, "person");
    else if (assetText) authorImage.parentElement.setAttribute("data-node-graphic-text", assetText);

    this.eventManager.addEvent(authorImage, "dblclick", this.imageDoubleClickEvent);
    authorImage.setAttribute("clicklistener", "true");

    //Creating overlay div
    let overlayDiv = document.createElement("div");
    overlayDiv.id = "authorOverlayDiv";
    overlayDiv.className = "authorOverlayDiv" + this.moodanimation;
    overlayDiv.setAttribute("data-nodetype", "imageOverlay");
    overlayDiv.setAttribute("data-cssslide", "slide0authorimage");
    authorImageParent.appendChild(overlayDiv);
};
//Create Preset image
SGBaseClass.prototype.createPresetImageNode = function (parentNode) {
    this.createCommonImageStructure(parentNode, 0, "presetImage", "presetimage");

    return parentNode.querySelector("[id='presetImageParent']");

    // let oldImageParent = parentNode.querySelector("[id='presetImageParent']");
    // if (oldImageParent) oldImageParent.parentElement.removeChild(oldImageParent);

    // let presetImageparent = document.createElement("div");
    // presetImageparent.id = "presetImageparent" + index;
    // presetImageparent.className = "presetImageparent " + this.moodanimation;
    // parent.appendChild(presetImageparent);

    // let presetImagebackground = document.createElement("div");
    // presetImagebackground.id = "presetImagebackground";
    // presetImagebackground.className = "presetImagebackground " + this.moodanimation;
    // presetImagebackground.style.pointerEvents = "none";
    // presetImagebackground.style.position = "absolute";
    // presetImagebackground.setAttribute("data-nodetype", "imageBackground");
    // presetImageparent.appendChild(presetImagebackground);

    // let presetImageparentHolder = document.createElement("div");
    // presetImageparentHolder.id = "presetImageparentHolder" + index;
    // presetImageparentHolder.className = "presetImageparentHolder " + this.moodanimation;
    // presetImageparent.appendChild(presetImageparentHolder);

    // let imgNode = document.createElement("img");
    // imgNode.id = "presetImageNode" + index;
    // imgNode.className = "presetImageNode";
    // presetImageparentHolder.appendChild(imgNode);
    // imgNode.setAttribute("data-target-id", "presetimage");
    // imgNode.setAttribute("data-oldcontrast", "true");
    // if (src != "") imgNode.src = this.specialGraphicsUtils.checkAppStaticURLSG(src, this.appStaticURL);
    // imgNode.setAttribute("data-nodetype", "imageNode");

    // this.eventManager.addEvent(imgNode, "dblclick", this.imageDoubleClickEvent);
    // imgNode.setAttribute("clicklistener", "true");

    // let coverImageOverlay = document.createElement("div");
    // coverImageOverlay.id = "coverImageOverlay";
    // coverImageOverlay.className = "presetImageOverlay";
    // coverImageOverlay.style.pointerEvents = "none";
    // coverImageOverlay.setAttribute("data-type", "overlay");
    // presetImageparentHolder.appendChild(coverImageOverlay);
    // coverImageOverlay.setAttribute("data-nodetype", "imageOverlay");

    // let presetImageParent = document.createElement("div");
    // presetImageParent.id = "presetImageParent";
    // presetImageParent.className = "presetImageParent" + this.selectionLayerClass + this.moodanimation;
    // this.setCommonSelector(presetImageParent);
    // parentNode.appendChild(presetImageParent);

    // let imgNode = document.createElement("img");
    // imgNode.id = "presetImageNode";
    // imgNode.className = "presetImageNode";
    // imgNode.setAttribute("data-target-id", "presetimage");
    // imgNode.setAttribute("data-oldcontrast", "true");
    // presetImageParent.appendChild(imgNode);

    // this.eventManager.addEvent(imgNode, "dblclick", this.imageDoubleClickEvent);
    // imgNode.setAttribute("clicklistener", "true");

    return presetImageparent;
};

SGBaseClass.prototype.createCommonImageStructure = function (parentNode, index, prefix, assetType) {
    let oldImageParent = parentNode.querySelector("[id='" + prefix + "ContentParent']");
    if (oldImageParent) oldImageParent.parentElement.removeChild(oldImageParent);

    //Creating presenter image main parent
    let phImageContentParent = document.createElement("div");
    phImageContentParent.id = prefix + "ContentParent";
    phImageContentParent.className = prefix + "ContentParent " + this.moodanimation;
    phImageContentParent.style.position = "relative";
    phImageContentParent.setAttribute("data-animation", "number");
    phImageContentParent.setAttribute("data-animation", "coverimage");
    phImageContentParent.setAttribute("data-type", "IMAGE");
    phImageContentParent.setAttribute("data-nodetype", "contentContainer");
    parentNode.appendChild(phImageContentParent);

    //Creating presenter image content background
    let contentBackground = document.createElement("div");
    contentBackground.id = prefix + "contentBackground";
    contentBackground.className = prefix + "contentBackground";
    contentBackground.style.position = "absolute";
    contentBackground.style.pointerEvents = "none";
    contentBackground.style.width = "100%";
    contentBackground.style.height = "100%";
    contentBackground.setAttribute("data-nodetype", "contentBackground");
    phImageContentParent.appendChild(contentBackground);

    let phImageParent = document.createElement("div");
    phImageParent.id = prefix + "Parent";
    phImageParent.className = prefix + "Parent image " + this.selectionLayerClass;
    this.setCommonSelector(phImageParent);
    phImageParent.setAttribute("data-nodetype", "imageHolder");
    phImageContentParent.appendChild(phImageParent);

    //Creating presenter image background
    let phImageBackground = document.createElement("div");
    phImageBackground.id = prefix + "Background";
    phImageBackground.className = prefix + "Background";
    phImageBackground.style.pointerEvents = "none";
    phImageBackground.style.position = "absolute";
    phImageBackground.setAttribute("data-nodetype", "imageBackground");
    phImageParent.appendChild(phImageBackground);

    let sgData = this.sgData[index];
    let src = sgData[assetType] && !sgData[assetType].includes(".svg") ? sgData[assetType] : this.appStaticURL + "genericassets/placeholderimages/coverimage.jpg";
    src = this.specialGraphicsUtils.checkAppStaticURLSG(src, this.appStaticURL);
    let phImage = this.specialGraphicsUtils.createImageElement(phImageParent, assetType, "", src, 0, 0, 0, 0, assetType, sgData, "sg" + prefix + "Node");

    let offsetVal = this.getOffsetRectByParent(this.sgParent, phImageParent);
    phImage.setAttribute("data-x", offsetVal.left);
    phImage.setAttribute("data-y", offsetVal.top);
    phImage.setAttribute("data-nodetype", "imageNode");

    this.eventManager.addEvent(phImage, "dblclick", this.imageDoubleClickEvent);
    phImage.setAttribute("clicklistener", "true");

    //Creating overlay div
    let overlayDiv = document.createElement("div");
    overlayDiv.id = prefix + "OverlayDiv";
    overlayDiv.className = prefix + "OverlayDiv" + this.moodanimation;
    overlayDiv.setAttribute("data-nodetype", "imageOverlay");
    phImageParent.appendChild(overlayDiv);
    this.specialGraphicsUtils.setOpacityAttribute(phImage);
};

SGBaseClass.prototype.createQuotePlaceHolder = function (parentNode) {
    let quotePlaceHolderParent = document.createElement("div");
    quotePlaceHolderParent.id = "quotePlaceHolderParent";
    quotePlaceHolderParent.className = "quotePlaceHolderParent " + this.moodanimation;
    quotePlaceHolderParent.setAttribute("data-animation", "quotetitle");
    parentNode.appendChild(quotePlaceHolderParent);

    let className = this.styleData.fontData.quotetitle + " ";
    let quotePlaceHolder = this.specialGraphicsUtils.createTextElement(quotePlaceHolderParent, this.sgData[0].quotetitle, "sgQuoteTextNode", "quoteText " + className + this.selectionLayerClass, "quotetitle");
    this.setCommonSelector(quotePlaceHolder);
    quotePlaceHolder.contentEditable = "true";
    quotePlaceHolder.setAttribute("data-prompt-text", this.styleData.quoteTitlePrompt);
    if (this.commonHeightFit) {
        quotePlaceHolder.commonheightfit = this.commonHeightFit;
        quotePlaceHolder.setAttribute("commonheightfit", "true");
    }
    this.applyTextBaseProps(quotePlaceHolder, 0, "quotetitle");
    this.setTextFocus(quotePlaceHolder);
};
SGBaseClass.prototype.createQuoteTakeaway = function (parentNode) {
    let quotePlaceHolderParent = document.createElement("div");
    quotePlaceHolderParent.id = "quotePlaceHolderParent";
    quotePlaceHolderParent.className = "quotePlaceHolderParent moodanimation";
    quotePlaceHolderParent.setAttribute("data-animation", "quotetakeaway");
    parentNode.appendChild(quotePlaceHolderParent);

    let className = this.styleData.fontData.quotetakeaway + " ";
    let quotePlaceHolder = this.specialGraphicsUtils.createTextElement(quotePlaceHolderParent, this.sgData[0].quotetakeaway, "sgQuoteTextAwayNode", "quoteText " + className + this.selectionLayerClass, "quotetakeaway");
    this.setCommonSelector(quotePlaceHolder);
    quotePlaceHolder.contentEditable = "true";
    quotePlaceHolder.setAttribute("data-prompt-text", this.styleData.quoteTitlePrompt);
    if (this.commonHeightFit) {
        quotePlaceHolder.commonheightfit = this.commonHeightFit;
        quotePlaceHolder.setAttribute("commonheightfit", "true");
    }
    this.applyTextBaseProps(quotePlaceHolder, 0, "quotetakeaway");
    this.setTextFocus(quotePlaceHolder);
};
SGBaseClass.prototype.createFooterNode = function (parentNode) {
    let footerParent = document.createElement("div");
    footerParent.id = "sgFooterParent";
    footerParent.setAttribute("data-animation", "footer");
    footerParent.className = "sgFooterParent moodanimation";
    parentNode.appendChild(footerParent);

    let className = (this.styleData.fontData.footer ? this.styleData.fontData.footer : "p6") + " ";
    let footerPlaceHolder = this.specialGraphicsUtils.createTextElement(footerParent, this.sgData[0].sgfooter, "sgFooterNode", "sgFooterNode " + className + this.selectionLayerClass, "sgfooter");
    this.setCommonSelector(footerPlaceHolder);
    footerPlaceHolder.setAttribute("ImagestackPosition", "");
    footerPlaceHolder.contentEditable = "true";
    footerPlaceHolder.setAttribute("data-prompt-text", this.styleData.footerPrompt);
    this.setTextFocus(footerPlaceHolder);
    this.applyTextBaseProps(footerPlaceHolder, 0, "sgfooter");
};
SGBaseClass.prototype.createBgImageNode = function (parent, index = "", type = "img", src = "") {
    let bgImage = document.createElement(type);
    bgImage.id = "bgImage" + index;
    bgImage.className = "bgImage moodanimation";
    bgImage.setAttribute("data-animation", "bgimage" + (index == "" ? "" : index));
    parent.appendChild(bgImage);
    this.specialGraphicsUtils.setOpacityAttribute(bgImage);
    src = this.specialGraphicsUtils.checkAppStaticURLSG(src, this.appStaticURL);
    if (src && src != "") bgImage.src = src;

    if (type == "video") {
        // This attribute need to export ppt using poster image
        bgImage.style.objectFit = "cover";
        bgImage.style.left = "0px";
        bgImage.style.top = "0px";
        bgImage.style.width = "100%";
        bgImage.style.height = "100%";
        let posterpath = bgImage.src.replace(".mp4", ".jpg");
        bgImage.setAttribute("poster", posterpath);
        bgImage.autoplay = true;
        bgImage.disablePictureInPicture = true;
        bgImage.muted = "true";
        bgImage.loop = "true";
    }
    bgImage.setAttribute("data-fit", "false");
    if (this.objDataToSG.assetGroupingId) bgImage.setAttribute("assetGroupingId", this.objDataToSG.assetGroupingId);
    return bgImage;
};
SGBaseClass.prototype.createPointImageNode = function (parent, index, src = "") {
    let oldImageParent = parent.querySelector("[id='pointImageParent" + index + "']");
    if (oldImageParent) oldImageParent.parentElement.removeChild(oldImageParent);

    let pointImageParent = document.createElement("div");
    pointImageParent.id = "pointImageParent" + index;
    pointImageParent.setAttribute("data-animation", "pointimage");
    pointImageParent.className = "pointImageParent " + this.moodanimation;
    parent.appendChild(pointImageParent);

    let pointImageBackground = document.createElement("div");
    pointImageBackground.id = "pointImageBackground";
    pointImageBackground.className = "pointImageBackground";
    pointImageBackground.style.pointerEvents = "none";
    pointImageBackground.style.position = "absolute";
    pointImageBackground.setAttribute("data-nodetype", "imageBackground");
    pointImageParent.appendChild(pointImageBackground);

    let pointImageParentHolder = document.createElement("div");
    pointImageParentHolder.id = "pointImageParentHolder" + index;
    pointImageParentHolder.className = "pointImageParentHolder";
    pointImageParent.appendChild(pointImageParentHolder);

    let imgNode = document.createElement("img");
    imgNode.id = "pointImageNode" + index;
    imgNode.className = "pointImageNode";
    pointImageParentHolder.appendChild(imgNode);
    if (src != "") imgNode.src = this.appStaticURL + src;
    imgNode.setAttribute("data-nodetype", "imageNode");

    let coverImageOverlay = document.createElement("div");
    coverImageOverlay.id = "coverImageOverlay";
    coverImageOverlay.className = "pointImageOverlay";
    coverImageOverlay.style.pointerEvents = "none";
    coverImageOverlay.setAttribute("data-type", "overlay");
    pointImageParentHolder.appendChild(coverImageOverlay);
    coverImageOverlay.setAttribute("data-nodetype", "imageOverlay");

    return pointImageParent;
};
SGBaseClass.prototype.createCtaButtonNode = function (parent, index = 0) {
    let className = (this.styleData.fontData.ctabutton ? this.styleData.fontData.ctabutton : "p4") + " ";
    let ctabutton = this.sgData[index] && this.sgData[index].ctabutton ? this.sgData[index].ctabutton : this.sgData.ctabutton;

    let ctaButtonParent = document.createElement("div");
    ctaButtonParent.id = "ctaButtonParent";
    ctaButtonParent.setAttribute("data-animation", "ctabutton");
    ctaButtonParent.className = "ctaButtonParent clsSingleColorParent clsHorButton" + this.moodanimation;
    this.setTextType(ctaButtonParent);
    ctaButtonParent.setAttribute("data-index", index);
    parent.appendChild(ctaButtonParent);

    this.styleData.ctaButtonPrompt = this.styleData.ctaButtonPrompt ? this.styleData.ctaButtonPrompt : "Call To Action";
    let ctaButtonNode = this.specialGraphicsUtils.createTextElement(ctaButtonParent, ctabutton && ctabutton != "undefined" ? ctabutton : this.styleData.ctaButtonPrompt, "sgCtaButtonNode", "ctaButton clsHolderText " + className + this.selectionLayerClass, "ctabutton");
    this.setCommonSelector(ctaButtonNode);
    ctaButtonNode.contentEditable = "true";
    ctaButtonNode.setAttribute("data-prompt-text", this.styleData.ctaButtonPrompt);
    ctaButtonNode.setAttribute("data-fontfit", "false");
    ctaButtonNode.setAttribute("data-index", index);
    this.applyTextBaseProps(ctaButtonNode, 0, "ctabutton");
    this.setTextFocus(ctaButtonNode);
};
SGBaseClass.prototype.applyCtaButtonProps = function (props, index = 0) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + index + "']");
    let elementNode = assetParent ? assetParent.querySelector("[id='ctaButtonParent']") : null;

    let propData = props.ctabutton;

    let sgCtaButtonNode = assetParent ? assetParent.querySelector("[id='sgCtaButtonNode']") : null;
    if (propData && elementNode && sgCtaButtonNode) {
        let specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL);
        specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
        let propNameData = "ctaButton";
        if (propData.position) specialgraphicsPropertyUtils.updatePosition(elementNode, propData.position);
        elementNode.style.maxWidth = elementNode.style.width;
        elementNode.style.width = "auto";
        if (propData.halign) {
            let align = propData.halign == "right" || propData.halign == "end" ? "end" : propData.halign == "center" ? "center" : "start";
            assetParent.style.setProperty("--" + propNameData + "Align", align);
        }
        if (propData.valign) {
            let vAlign = propData.valign;
            let align = vAlign == "bottom" || vAlign == "end" ? "flex-end" : vAlign == "center" || vAlign == "middle" ? "center" : "flex-start";
            elementNode.style.alignItems = align;
        }
        if (propData.margin) specialgraphicsPropertyUtils.updateMargin(propData.margin, elementNode);
        if (propData.padding) specialgraphicsPropertyUtils.updatePadding(propData.padding, elementNode);
        if (propData.color) assetParent.style.setProperty("--" + propNameData + "Color", "rgba(var(--" + propData.color + "-color-rgb),1)");
        if (propData.bgcolor) assetParent.style.setProperty("--" + propNameData + "BgColor", "rgba(var(--" + propData.bgcolor + "-color-rgb),1)");
        if (propData.zorder) assetParent.style.setProperty("--" + propNameData + "ZIndex", propData.zorder);
        if (propData.positionvalue) elementNode.style.position = propData.positionvalue;
        if (propData.opacity) elementNode.style.opacity = propData.opacity;
        if (propData.prompt) sgCtaButtonNode.setAttribute("data-prompt-text", propData.prompt);
        if (propData.globalstyle) {
            elementNode.classList.remove("clsHorButton");
            this.specialGraphicsUtils.applyClassNamesFromString(elementNode, propData.globalstyle);
            elementNode.classList.add("clsSingleColorParent");
        }

        this.specialGraphicsUtils.applyClassNamesFromString(elementNode, propData.parentclass);
        this.specialGraphicsUtils.applyClassNamesFromString(sgCtaButtonNode, propData.class);

        this.specialGraphicsUtils.setOpacityAttribute(elementNode);
        this.applyContrastToText(elementNode, propData);
        if (this.sgData[index]["ctabuttonnavigateurl"]) this.updateAgendaLink(null, this.sgData[index]["ctabuttonnavigateurl"], sgCtaButtonNode.id, true, null, index, sgCtaButtonNode);
    }
};
SGBaseClass.prototype.createPresentedToNode = function (parent, index = 0) {
    let presentedToParent = document.createElement("div");
    presentedToParent.id = "sgPresentedToParentNode";
    presentedToParent.className = "presentedToParent";
    parent.appendChild(presentedToParent);

    let className = (this.styleData.fontData.presentedto ? this.styleData.fontData.presentedto : "h5") + " ";
    let presentedto = this.sgData[index] && this.sgData[index].presentedto ? this.sgData[index].presentedto : this.sgData.presentedto;
    let presentedToNode = this.specialGraphicsUtils.createTextElement(presentedToParent, presentedto, "sgPresentedToNode", "presentedTo " + className + this.selectionLayerClass + this.moodanimation, "presentedto");
    this.setCommonSelector(presentedToNode);
    presentedToNode.setAttribute("data-animation", "presentedto");
    if (!presentedto || presentedto == "") presentedToNode.innerText = this.styleData.presentedToPrompt;
    presentedToNode.contentEditable = "true";
    presentedToNode.setAttribute("data-prompt-text", this.styleData.presentedToPrompt);
    this.applyTextBaseProps(presentedToNode, 0, "presentedto");
    this.setTextFocus(presentedToNode);
};
SGBaseClass.prototype.createAuthorTitleNode = function (parent, index = 0) {
    let authorTitleParent = document.createElement("div");
    authorTitleParent.id = "sgAuthorTitleParentNode";
    authorTitleParent.className = "authorTitleParent";
    parent.appendChild(authorTitleParent);

    let className = (this.styleData.fontData.authortitle ? this.styleData.fontData.authortitle : "h7") + " ";
    let authortitle = this.sgData[index] && this.sgData[index].authortitle ? this.sgData[index].authortitle : this.sgData.authortitle;
    let authorTitleNode = this.specialGraphicsUtils.createTextElement(authorTitleParent, authortitle, "sgAuthorTitleNode", "authorTitle " + className + this.selectionLayerClass + this.moodanimation, "authortitle");
    this.setCommonSelector(authorTitleNode);
    authorTitleNode.contentEditable = "true";
    authorTitleNode.setAttribute("data-prompt-text", this.styleData.authorTitlePrompt);
    authorTitleNode.setAttribute("data-fontfit", "false");
    this.applyTextBaseProps(authorTitleNode, 0, "authortitle");
    this.setTextFocus(authorTitleNode);
};
SGBaseClass.prototype.createDateTitleNode = function (parent, index = 0) {
    let dateTitleParent = document.createElement("div");
    dateTitleParent.id = "sgDateTitleParentNode";
    dateTitleParent.className = "dateTitleParent";
    parent.appendChild(dateTitleParent);

    let className = (this.styleData.fontData.datetitle ? this.styleData.fontData.datetitle : "h7") + " ";
    let datetitle = this.sgData[index] && this.sgData[index].datetitle ? this.sgData[index].datetitle : this.sgData.datetitle;
    let dateTitleNode = this.specialGraphicsUtils.createTextElement(dateTitleParent, datetitle, "sgDateTitleNode", "dateTitle " + className + this.selectionLayerClass + this.moodanimation, "datetitle");
    this.setCommonSelector(dateTitleNode);
    dateTitleNode.contentEditable = "true";
    dateTitleNode.setAttribute("data-prompt-text", this.styleData.dateTitlePrompt);
    dateTitleNode.setAttribute("data-fontfit", "false");
    this.applyTextBaseProps(dateTitleNode, 0, "datetitle");
    this.setTextFocus(dateTitleNode);
};
SGBaseClass.prototype.createVenueTitleNode = function (parent, index = 0) {
    let venueTitleParent = document.createElement("div");
    venueTitleParent.id = "sgVenueTitleParentNode";
    venueTitleParent.className = "venueTitleParent";
    parent.appendChild(venueTitleParent);

    let className = (this.styleData.fontData.venuetitle ? this.styleData.fontData.venuetitle : "p3") + " ";
    let venuetitle = this.sgData[index] && this.sgData[index].venuetitle ? this.sgData[index].venuetitle : this.sgData.venuetitle;
    let venueTitleNode = this.specialGraphicsUtils.createTextElement(venueTitleParent, venuetitle, "sgVenueTitleNode", "venueTitle " + className + this.selectionLayerClass + this.moodanimation, "venuetitle");
    this.setCommonSelector(venueTitleNode);
    venueTitleNode.contentEditable = "true";
    venueTitleNode.setAttribute("data-prompt-text", this.styleData.venueTitlePrompt);
    venueTitleNode.setAttribute("data-fontfit", "false");
    this.applyTextBaseProps(venueTitleNode, 0, "venuetitle");
    this.setTextFocus(venueTitleNode);
};
SGBaseClass.prototype.createWebsiteLinkNode = function (parent, index = 0) {
    let websiteLinkParent = document.createElement("div");
    websiteLinkParent.id = "sgWebsiteLinkParentNode";
    websiteLinkParent.className = "websiteLinkParent";
    parent.appendChild(websiteLinkParent);

    let className = (this.styleData.fontData.websitelink ? this.styleData.fontData.websitelink : "p3") + " ";
    let websitelink = this.sgData[index] && this.sgData[index].websitelink ? this.sgData[index].websitelink : this.sgData.websitelink;
    let websiteLinkNode = this.specialGraphicsUtils.createTextElement(websiteLinkParent, websitelink, "sgWebsiteLinkNode", "websiteLink " + className + this.selectionLayerClass + this.moodanimation, "websitelink");
    this.setCommonSelector(websiteLinkNode);
    websiteLinkNode.contentEditable = "true";
    websiteLinkNode.setAttribute("data-prompt-text", this.styleData.websiteLinkPrompt);
    websiteLinkNode.setAttribute("data-fontfit", "false");
    this.applyTextBaseProps(websiteLinkNode, 0, "websitelink");
    this.setTextFocus(websiteLinkNode);
};
SGBaseClass.prototype.createPresentedByNode = function (parent, index = 0) {
    let presentedByparent = document.createElement("div");
    presentedByparent.id = "sgPresentedByParentNode";
    presentedByparent.className = "presentedByparent";
    parent.appendChild(presentedByparent);

    let className = (this.styleData.fontData.presentedby ? this.styleData.fontData.presentedby : "h5") + " ";
    let presentedby = this.sgData[index] && this.sgData[index].presentedby ? this.sgData[index].presentedby : this.sgData.presentedby;
    let presentedByNode = this.specialGraphicsUtils.createTextElement(presentedByparent, presentedby, "sgPresentedByNode", "presentedBy " + className + this.selectionLayerClass + this.moodanimation, "presentedby");
    this.setCommonSelector(presentedByNode);
    if (!presentedby || presentedby == "") presentedByNode.innerText = this.styleData.presentedByPrompt;
    presentedByNode.contentEditable = "true";
    presentedByNode.setAttribute("data-animation", "presentedby");
    presentedByNode.setAttribute("data-prompt-text", this.styleData.presentedByPrompt);
    presentedByNode.setAttribute("data-fontfit", "false");
    this.applyTextBaseProps(presentedByNode, 0, "presentedby");
    this.setTextFocus(presentedByNode);
};
SGBaseClass.prototype.createPresenterCompanyNameNode = function (parent, index = 0) {
    let presenterCompanyParent = document.createElement("div");
    presenterCompanyParent.id = "sgPresenterCompanyParentNode";
    presenterCompanyParent.className = "presenterCompanyParent";
    parent.appendChild(presenterCompanyParent);

    let className = (this.styleData.fontData.presentercompany ? this.styleData.fontData.presentercompany : "h7") + " ";
    let presentercompany = this.sgData[index] && this.sgData[index].presentercompany ? this.sgData[index].presentercompany : this.sgData.presentercompany;
    let presenterCompanyNode = this.specialGraphicsUtils.createTextElement(presenterCompanyParent, presentercompany, "sgPresenterCompanyNode", "presenterCompany " + className + this.selectionLayerClass + this.moodanimation, "presentercompany");
    this.setCommonSelector(presenterCompanyNode);
    presenterCompanyNode.contentEditable = "true";
    presenterCompanyNode.setAttribute("data-animation", "presentercompany");
    presenterCompanyNode.setAttribute("data-prompt-text", this.styleData.presenterCompanyPrompt);
    presenterCompanyNode.setAttribute("data-fontfit", "false");
    this.applyTextBaseProps(presenterCompanyNode, 0, "presentercompany");
    this.setTextFocus(presenterCompanyNode);
};
SGBaseClass.prototype.createCustomerCompanyNameNode = function (parent, index = 0) {
    let customerCompanyParent = document.createElement("div");
    customerCompanyParent.id = "sgCustomerCompanyParentNode";
    customerCompanyParent.className = "customerCompanyParent";
    parent.appendChild(customerCompanyParent);

    let className = (this.styleData.fontData.customercompany ? this.styleData.fontData.customercompany : "h7") + " ";
    let customercompany = this.sgData[index] && this.sgData[index].customercompany ? this.sgData[index].customercompany : this.sgData.customercompany;
    let customerCompanyNode = this.specialGraphicsUtils.createTextElement(customerCompanyParent, customercompany, "sgCustomerCompanyNode", "customerCompany " + className + this.selectionLayerClass + this.moodanimation, "customercompany");
    this.setCommonSelector(customerCompanyNode);
    customerCompanyNode.contentEditable = "true";
    customerCompanyNode.setAttribute("data-animation", "creatorname");
    customerCompanyNode.setAttribute("data-prompt-text", this.styleData.customerCompanyPrompt);
    customerCompanyNode.setAttribute("data-fontfit", "false");
    this.applyTextBaseProps(customerCompanyNode, 0, "customercompany");
    this.setTextFocus(customerCompanyNode);
};
SGBaseClass.prototype.createSpeakerNodes = function (parent, oldParent, oldData) {
    let speakerParent;
    let startIndex = 1;
    let endIndex = 5;
    if (oldParent) {
        speakerParent = oldParent;
        startIndex = oldData?.index || speakerParent.querySelectorAll("[id*='speakerNodeGroup']").length + 1;
        endIndex = startIndex + 1;
    } else {
        speakerParent = document.createElement("div");
        speakerParent.id = "speakerParent";
        speakerParent.className = "speakerParent";
        this.setTextType(speakerParent);
        parent.appendChild(speakerParent);
    }
    for (let a = startIndex; a < endIndex; a++) {
        let speakerNodeGroup = document.createElement("div");
        speakerNodeGroup.id = "speakerNodeGroup" + a;
        speakerNodeGroup.className = "speakerNodeGroup " + this.selectionLayerClass;
        this.setCommonSelector(speakerNodeGroup);
        speakerNodeGroup.setAttribute("speakername", "speakernode" + a);
        this.setTextType(speakerNodeGroup);
        if (oldData?.index && oldData?.index != 1 && speakerParent.children?.[oldData?.index - 2]) {
            let oldNode = speakerParent.children?.[oldData?.index - 2];
            speakerParent.insertBefore(speakerNodeGroup, oldNode.nextSibling);
        } else if (oldData?.index == 1) speakerParent.insertBefore(speakerNodeGroup, speakerParent.firstChild);
        else speakerParent.appendChild(speakerNodeGroup);

        //Speaker text group
        let speakerTextGroup = document.createElement("div");
        speakerTextGroup.id = "speakerTextGroup" + a;
        speakerTextGroup.className = "speakerTextGroup";
        this.setTextType(speakerTextGroup);
        speakerNodeGroup.appendChild(speakerTextGroup);

        //Speaker primary text
        let speakerPrimaryParent = document.createElement("div");
        speakerPrimaryParent.id = "sgSpeakerPrimaryParent" + a;
        speakerPrimaryParent.className = "speakerPrimaryParent";
        this.setTextType(speakerPrimaryParent);
        speakerTextGroup.appendChild(speakerPrimaryParent);

        let className = this.fontData && this.fontData.speakerprimary ? this.fontData.speakerprimary : "h7";
        let primaryText = oldData?.primary || this.sgData[0]["speaker" + a + "primary"] || this.sgData[0]["speakerprimary" + a];
        let speakerPrimaryNode = this.specialGraphicsUtils.createTextElement(speakerPrimaryParent, primaryText, "sgSpeakerPrimary" + a, "speakerPrimary " + this.moodanimation + className + " speaker1primary" + this.moodanimation, "speakerprimary" + a);
        speakerPrimaryNode.setAttribute("data-animation", "speakerprimary");
        this.setCommonSelector(speakerPrimaryNode);
        speakerPrimaryNode.contentEditable = "true";
        let promptText = this.styleData && this.styleData.speakerPrimaryPrompt ? this.styleData.speakerPrimaryPrompt : "Click here to edit text";
        speakerPrimaryNode.setAttribute("data-prompt-text", promptText);
        this.applyTextBaseProps(speakerPrimaryNode, 0, "speakerprimary" + a);
        this.setTextFocus(speakerPrimaryNode);

        //Speaker secondary text
        let speakerSecondaryParent = document.createElement("div");
        speakerSecondaryParent.id = "sgSpeakerSecondaryParent" + a;
        speakerSecondaryParent.className = "speakerSecondaryParent";
        this.setTextType(speakerSecondaryParent);
        speakerTextGroup.appendChild(speakerSecondaryParent);

        className = this.fontData && this.fontData.speakersecondary ? this.fontData.speakersecondary : "p5";
        let secondaryText = oldData?.secondary || this.sgData[0]["speaker" + a + "secondary"] || this.sgData[0]["speakersecondary" + a];
        let speakerSecondaryNode = this.specialGraphicsUtils.createTextElement(speakerSecondaryParent, secondaryText, "sgSpeakerSecondary" + a, "speakerSecondary " + this.moodanimation + className + " speaker1secondary" + this.moodanimation, "speakersecondary" + a);
        speakerSecondaryNode.setAttribute("data-animation", "speakersecondary");
        this.setCommonSelector(speakerSecondaryNode);
        speakerSecondaryNode.contentEditable = "true";
        promptText = this.styleData && this.styleData.speakerSecondaryPrompt ? this.styleData.speakerSecondaryPrompt : "Click here to edit text";
        speakerSecondaryNode.setAttribute("data-prompt-text", promptText);
        this.applyTextBaseProps(speakerSecondaryNode, 0, "speakersecondary" + a);
        this.setTextFocus(speakerSecondaryNode);

        let speakerContentParent = document.createElement("div");
        speakerContentParent.id = "speakerContentParent" + a;
        speakerContentParent.className = "speakerContentParent" + this.selectionLayerClass + this.moodanimation;
        this.setCommonSelector(speakerContentParent);
        speakerContentParent.setAttribute("data-animation", "speakerimage");
        speakerContentParent.setAttribute("data-type", "IMAGE");
        speakerContentParent.setAttribute("data-nodetype", "contentContainer");
        speakerNodeGroup.appendChild(speakerContentParent);

        let contentBackground = document.createElement("div");
        contentBackground.id = "contentBackground" + a;
        contentBackground.className = "contentBackground";
        contentBackground.style.position = "absolute";
        contentBackground.style.pointerEvents = "none";
        contentBackground.style.width = "100%";
        contentBackground.style.height = "100%";
        contentBackground.setAttribute("data-nodetype", "contentBackground");
        speakerContentParent.appendChild(contentBackground);

        let speakerImageParent = document.createElement("div");
        speakerImageParent.id = "speakerImageParent" + a;
        speakerImageParent.className = "speakerImageParent" + this.selectionLayerClass;
        this.setCommonSelector(speakerImageParent);
        speakerContentParent.appendChild(speakerImageParent);
        speakerImageParent.setAttribute("data-nodetype", "imageHolder");

        let speakerImageBackground = document.createElement("div");
        speakerImageBackground.id = "speakerImageBackground";
        speakerImageBackground.className = "speakerImageBackground ";
        speakerImageBackground.style.pointerEvents = "none";
        speakerImageBackground.style.position = "absolute";
        speakerImageBackground.setAttribute("data-nodetype", "imageBackground");
        speakerImageParent.appendChild(speakerImageBackground);

        let src = oldData?.src ? oldData.src : this.sgData[0]["speakerimage" + a] ? this.sgData[0]["speakerimage" + a] : this.appStaticURL + "genericassets/placeholderimages/authorimage.jpg";
        src = this.specialGraphicsUtils.checkAppStaticURLSG(src, this.appStaticURL);
        let speakerImage = this.specialGraphicsUtils.createImageElement(speakerImageParent, "speakerImageNode", "", src, 0, 0, 0, 0, "speakerimage" + a, this.sgData[0], "sgSpeakerImageNode" + a);

        let offsetVal = this.getOffsetRectByParent(this.sgParent, speakerImageParent);
        speakerImage.setAttribute("data-x", offsetVal.left);
        speakerImage.setAttribute("data-y", offsetVal.top);
        speakerImage.setAttribute("data-nodetype", "imageNode");

        this.eventManager.addEvent(speakerImage, "dblclick", this.imageDoubleClickEvent);

        let nameDesigination = primaryText + "$$" + secondaryText;
        let assetText = this.sgData[0]?.["speakerimage" + a + "prompt"] || nameDesigination || "";
        if (assetText && this.imageLoadUsingPrompt && this.sgData[0]["speakerimage" + a + "needassetupdate"] == "true") this.imageLoadUsingPrompt(speakerImage, assetText, 0, "person");
        else if (assetText) speakerImage.parentElement.setAttribute("data-node-graphic-text", assetText);

        speakerImage.setAttribute("clicklistener", "true");

        //Creating overlay div
        let overlayDiv = document.createElement("div");
        overlayDiv.id = "speakerOverlayDiv" + a;
        overlayDiv.setAttribute("data-index", a);
        overlayDiv.className = "speakerOverlayDiv" + this.moodanimation;
        overlayDiv.setAttribute("data-nodetype", "imageOverlay");
        overlayDiv.setAttribute("data-cssslide", "slide0speakerimage" + a);
        overlayDiv.style.display = "none";
        speakerImageParent.appendChild(overlayDiv);
    }
};
SGBaseClass.prototype.createShapesInsidePage = function (parent, id, property, index = 0) {
    let oldChild = parent.querySelector("[id='" + id + "']");
    if (oldChild) oldChild.parentElement.removeChild(oldChild);

    let covershape = document.createElement("div");
    covershape.id = id;
    covershape.setAttribute("data-animation", "covershape" + index);
    covershape.className = id + " " + this.moodanimation + " ";
    covershape.style.pointerEvents = "none";
    covershape.setAttribute("data-type", "TEXT");
    parent.appendChild(covershape);
    this.specialGraphicsUtils.setOpacityAttribute(covershape);

    if (property && property.nested) {
        let covershapeInner = document.createElement("div");
        covershapeInner.id = "covershapeInner" + id.replace("shape", "");
        covershapeInner.className = "covershapeInner";
        covershapeInner.style.pointerEvents = "none";
        covershapeInner.setAttribute("data-type", "TEXT");
        covershape.appendChild(covershapeInner);
        if (this.moodName == "bubblecss") covershapeInner.classList.add("bubbleAnimationSG");
    }
    if (property) {
        let assetParent = this.sgParent.querySelector("[id='assetParent" + index + "']");
        let specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL);
        specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
        specialgraphicsPropertyUtils.commonShapeProperties(property, covershape, assetParent, index);
        if (property.positionvalue) covershape.style.position = property.positionvalue;
    }
};
SGBaseClass.prototype.createShapes = function (parent, id, property, index = 0) {
    let covershape = document.createElement("div");
    covershape.id = id;
    covershape.setAttribute("data-animation", "covershape" + id.replace("shape", ""));
    covershape.className = id + " " + this.moodanimation + " ";
    covershape.style.pointerEvents = "none";
    covershape.setAttribute("data-type", "TEXT");
    parent.appendChild(covershape);
    this.specialGraphicsUtils.setOpacityAttribute(covershape);

    if (property && property.nested) {
        let covershapeInner = document.createElement("div");
        covershapeInner.id = "covershapeInner" + id.replace("shape", "");
        covershapeInner.className = "covershapeInner";
        covershapeInner.style.pointerEvents = "none";
        covershapeInner.setAttribute("data-type", "TEXT");
        covershape.appendChild(covershapeInner);
        if (this.moodName == "bubblecss") covershapeInner.classList.add("bubbleAnimationSG");
    }
    if (property) {
        let assetParent = this.sgParent.querySelector("[id='assetParent" + index + "']");
        let specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL);
        specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
        specialgraphicsPropertyUtils.applyMoodShapeProperties(property, assetParent ? assetParent : parent, 0, true, true, id.replace("shape", ""));
        if (property.positionvalue) covershape.style.position = property.positionvalue;
        if (property.depends) {
            covershape.setAttribute("depends", "content");
            this.sgParent.setAttribute("depends", "content");
        }
    }
};
SGBaseClass.prototype.createPlaceHolderImage = function (parent, index) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + index + "']");
    let placeHolderParent = assetParent ? assetParent.querySelector("[id='placeHolderParent']") : null;
    if (!placeHolderParent) {
        placeHolderParent = document.createElement("div");
        placeHolderParent.id = "placeHolderParent" + index;
        placeHolderParent.setAttribute("data-type", "IMAGE");
        placeHolderParent.setAttribute("data-nodetype", "contentContainer");
        placeHolderParent.className = "placeHolderParent";
        parent.appendChild(placeHolderParent);

        this.createLogoImageNode(placeHolderParent, this.sgParent, index, this.sgData[index].placeholderimage, false);
        this.createPlaceHolderImageNode(placeHolderParent, index);
        this.createPlaceHolderIconNode(placeHolderParent, index);
        this.createPlaceHolderTextNode(placeHolderParent, index);
        let logoImageParent = placeHolderParent.querySelector("[id*='logoImageParent']");
        if (logoImageParent) {
            logoImageParent.classList.add("logo");
            if (this.sgSlideType != "imagestack" && this.sgSlideType != "textstack") logoImageParent.id = "logoImageParent" + index;
            logoImageParent.setAttribute("placeholder", "true");
        }
        let sgLogoImageNode = placeHolderParent.querySelector("[id*='sgLogoImageNode']");
        if (sgLogoImageNode) {
            sgLogoImageNode.setAttribute("placeholder", "true");
            if (this.sgSlideType != "imagestack" && this.sgSlideType != "textstack") sgLogoImageNode.id = "sgLogoImageNode" + index;
        }
    }
};
SGBaseClass.prototype.createPlaceHolderIconNode = function (parentNode, index) {
    let phIconContentParent = document.createElement("div");
    phIconContentParent.id = "phIconContentParent" + index;
    phIconContentParent.className = "phIconContentParent " + this.moodanimation;
    phIconContentParent.style.pointerEvents = "none";
    phIconContentParent.setAttribute("data-nodetype", "contentContainer");
    parentNode.appendChild(phIconContentParent);
    phIconContentParent.setAttribute("data-animation", "number");
    phIconContentParent.setAttribute("placeholder", "true");

    let contentBackground = document.createElement("div");
    contentBackground.id = "contentBackground";
    contentBackground.className = "contentBackground";
    contentBackground.style.position = "absolute";
    contentBackground.style.pointerEvents = "none";
    contentBackground.style.width = "100%";
    contentBackground.style.height = "100%";
    this.setTextType(contentBackground);
    contentBackground.setAttribute("data-nodetype", "contentBackground");
    phIconContentParent.appendChild(contentBackground);

    let phIcon = document.createElement("div");
    phIcon.id = "phIconNode" + index;
    phIcon.className = "phIcon icon clsSingleColorParent " + this.selectionLayerClass;
    this.setCommonSelector(phIcon);
    phIcon.setAttribute("data-nodetype", "iconHolder");
    this.setTextType(phIcon);
    phIconContentParent.appendChild(phIcon);
    phIcon.setAttribute("placeholder", "true");

    let iconBackground = document.createElement("div");
    iconBackground.id = "iconBackground";
    iconBackground.className = "iconBackground";
    iconBackground.style.pointerEvents = "none";
    this.setTextType(iconBackground);
    iconBackground.setAttribute("data-nodetype", "iconBackground");
    phIcon.appendChild(iconBackground);

    let phIconSvgNode = document.createElement("div");
    phIconSvgNode.id = "phIconSvgNode" + index;
    phIconSvgNode.className = "phIconSvgNode " + this.selectionLayerClass;
    this.setCommonSelector(phIconSvgNode);
    phIconSvgNode.setAttribute("data-nodetype", "iconHolder");
    this.setTextType(phIconSvgNode);
    phIcon.appendChild(phIconSvgNode);
    phIconSvgNode.setAttribute("placeholder", "true");

    let iconOverlay = document.createElement("div");
    iconOverlay.id = "iconOverlay";
    iconOverlay.className = "iconOverlay " + this.moodanimation;
    iconOverlay.style.pointerEvents = "none";
    this.setTextType(iconOverlay);
    iconOverlay.setAttribute("data-animation", "iconoverlay");
    iconOverlay.setAttribute("data-nodetype", "iconOverlay");
    phIcon.appendChild(iconOverlay);
};
SGBaseClass.prototype.createPlaceHolderTextNode = function (parentNode, index) {
    let phTextParent = document.createElement("div");
    phTextParent.id = "phTextParent";
    this.setTextType(phTextParent);
    phTextParent.className = "phTextParent " + this.selectionLayerClass + this.moodanimation;
    this.setCommonSelector(phTextParent);
    phTextParent.setAttribute("data-animation", "number");
    phTextParent.style.position = "relative";
    parentNode.appendChild(phTextParent);

    let className = this.styleData.fontData.placeholder ? this.styleData.fontData.placeholder : "";
    let phTextNode = this.specialGraphicsUtils.createTextElement(phTextParent, this.sgData[index].placeholderimage, "phTextNode", "phTextNode text " + className, "placeholderimage");
    phTextNode.contentEditable = "true";
    phTextNode.setAttribute("data-prompt-text", this.styleData.venuePrompt);
    this.setTextFocus(phTextNode);
    this.setCommonSelector(phTextNode);
    this.applyTextBaseProps(phTextNode, index, "placeholderimage");

    let promptText = this.styleData && this.styleData.placeholderPrompt ? this.styleData.placeholderPrompt : "Placeholder Text";
    phTextNode.setAttribute("data-prompt-text", promptText);
    phTextNode.setAttribute("data-index", index);
    phTextNode.setAttribute("data-font", this.fontData && this.fontData.placeholdertext ? this.fontData.placeholdertext : "h6");
    phTextNode.setAttribute("placeholder", "true");
    phTextParent.setAttribute("placeholder", "true");
    phTextNode.onTextChangeNode = this.onTextChangeUpdatePlaceholderNode;
};
SGBaseClass.prototype.createPlaceHolderImageNode = function (parentNode, index) {
    let oldImageParent = parentNode.querySelector("[id='phImageContentParent']");
    if (oldImageParent) oldImageParent.parentElement.removeChild(oldImageParent);

    //Creating presenter image main parent
    let phImageContentParent = document.createElement("div");
    phImageContentParent.id = "phImageContentParent";
    phImageContentParent.className = "phImageContentParent " + this.moodanimation;
    phImageContentParent.style.position = "relative";
    phImageContentParent.setAttribute("data-type", "IMAGE");
    phImageContentParent.setAttribute("data-animation", "number");
    phImageContentParent.setAttribute("data-nodetype", "contentContainer");
    parentNode.appendChild(phImageContentParent);

    //Creating presenter image content background
    let contentBackground = document.createElement("div");
    contentBackground.id = "contentBackground";
    contentBackground.className = "contentBackground";
    contentBackground.style.position = "absolute";
    contentBackground.style.pointerEvents = "none";
    contentBackground.style.width = "100%";
    contentBackground.style.height = "100%";
    contentBackground.setAttribute("data-nodetype", "contentBackground");
    phImageContentParent.appendChild(contentBackground);

    let phImageParent = document.createElement("div");
    phImageParent.id = "phImageParent";
    phImageParent.className = "phImageParent image " + this.selectionLayerClass;
    this.setCommonSelector(phImageParent);
    phImageParent.setAttribute("data-nodetype", "imageHolder");
    phImageContentParent.appendChild(phImageParent);

    //Creating presenter image background
    let phImageBackground = document.createElement("div");
    phImageBackground.id = "phImageBackground";
    phImageBackground.className = "phImageBackground";
    phImageBackground.style.pointerEvents = "none";
    phImageBackground.style.position = "absolute";
    phImageBackground.setAttribute("data-nodetype", "imageBackground");
    phImageParent.appendChild(phImageBackground);

    let sgData = this.sgData[index];
    let src = sgData.placeholderimage && !sgData.placeholderimage.includes(".svg") ? sgData.placeholderimage : this.appStaticURL + "genericassets/placeholderimages/coverimage.jpg";
    src = this.specialGraphicsUtils.checkAppStaticURLSG(src, this.appStaticURL);
    let phImage = this.specialGraphicsUtils.createImageElement(phImageParent, "placeholderImage", "", src, 0, 0, 0, 0, "placeholderimage", sgData, "sgPlaceHolderImageNode");

    let offsetVal = this.getOffsetRectByParent(this.sgParent, phImageParent);
    phImage.setAttribute("data-x", offsetVal.left);
    phImage.setAttribute("data-y", offsetVal.top);
    phImage.setAttribute("data-nodetype", "imageNode");
    phImage.setAttribute("placeholder", "true");

    this.eventManager.addEvent(phImage, "dblclick", this.imageDoubleClickEvent);
    phImage.setAttribute("clicklistener", "true");

    //Creating overlay div
    let overlayDiv = document.createElement("div");
    overlayDiv.id = "phOverlayDiv";
    overlayDiv.className = "phOverlayDiv" + this.moodanimation;
    overlayDiv.setAttribute("data-nodetype", "imageOverlay");
    phImageParent.appendChild(overlayDiv);
    this.specialGraphicsUtils.setOpacityAttribute(phImage);
};
SGBaseClass.prototype.createQuoteTestimonial = function (parentNode) {
    let oldQuoteTestimonialParent = parentNode.querySelector("[id='quoteTestimonialParent']");
    if (oldQuoteTestimonialParent) oldQuoteTestimonialParent.parentElement.removeChild(oldQuoteTestimonialParent);

    //Creating presenter image main parent
    let quoteTestimonialParent = document.createElement("div");
    quoteTestimonialParent.id = "quoteTestimonialParent";
    quoteTestimonialParent.className = "quoteTestimonialParent clsMultiColorParent " + this.moodanimation;
    parentNode.appendChild(quoteTestimonialParent);
    quoteTestimonialParent.setAttribute("data-animation", "quoteicon1");
    this.setTextType(quoteTestimonialParent);

    let contentParentNode = document.createElement("div");
    contentParentNode.className = "clsmicroChartHoldersg";
    this.specialGraphicsUtils.assignAttributes(contentParentNode, {
        name: "microChartHolder",
        "data-node-content-type": "microchart",
        "data-content-type": "microchart",
        "data-type": "contentmicrochartparent",
        "data-id": "contentmicrochartparent",
        id: "microChartHolder0",
    });
    quoteTestimonialParent.appendChild(contentParentNode);
    this.setTextType(contentParentNode);
    this.parseRatingValue(this.sgData[0].rating, contentParentNode);

    let microParentNode = document.createElement("div");
    microParentNode.id = "microParentNode";
    microParentNode.className = "clsMicroChartContentsg clsRatingMicrosg clsTertiaryStroke";
    microParentNode.setAttribute("name", "microchartContent");
    contentParentNode.appendChild(microParentNode);
    this.setTextType(microParentNode);

    let innerHTML = "";
    let uuid = this.specialGraphicsUtils.generateRandomStringCSS(5);
    innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 429 71" width="100%">';
    innerHTML += '<defs><clipPath id="' + uuid + '"><rect class="clsMicroRect" id="clsMicroRect" height="100%"/></clipPath></defs>';
    innerHTML +=
        '<path class="clsCircleBG clsTertiaryFill clsTertiaryStroke" id="clsCircleBG" d="M15.7,59.3a3,3,0,0,1-4.6-3.4L17.1,38c.1-.4.1-.7-.3-.9L1.3,26.1a3,3,0,0,1,1.7-5.4H22.8L28.8,2.2a3,3,0,0,1,5.7,0L40.5,20a.7.7,0,0,0,.8.6H60.3a3,3,0,0,1,1.7,5.4L46.8,37a.9.9,0,0,0-.4,1.1l5.9,17.8a3,3,0,0,1-4.6,3.4L32.3,48.2a.8.8,0,0,0-1.1,0ZM121.6,48.2a.8.8,0,0,1,1.1,0l15.4,11a3,3,0,0,0,4.6-3.4l-5.9-17.8a.9.9,0,0,1,.4-1.1l15.3-11a3,3,0,0,0-1.7-5.4h-19a.7.7,0,0,1-.8-.6h0c-1.3-4.2-3.9-11.9-5.9-17.9a3,3,0,0,0-5.7,0l-6.1,18.5H93.5a3,3,0,0,0-1.7,5.4l15.4,11.1c.4.2.4.5.3.9-1.3,3.9-3.9,11.6-5.9,17.9a3,3,0,0,0,4.6,3.4Zm88.4,0a.8.8,0,0,1,1.1,0l15.4,11.1a3,3,0,0,0,4.6-3.4l-5.8-17.8a.8.8,0,0,1,.3-1.1h0l15.3-11a3,3,0,0,0-1.7-5.4h-19a.7.7,0,0,1-.8-.6h0c-1.3-4.2-3.9-11.9-5.9-17.9a3,3,0,0,0-5.7,0l-6.1,18.5H181.9a3,3,0,0,0-1.7,5.4l15.4,11.1c.4.2.4.5.3.9L190,55.9a3,3,0,0,0,4.6,3.4Zm89.4,0a.8.8,0,0,1,1.1,0l15.4,11.1a3,3,0,0,0,4.6-3.4l-5.8-17.8a.8.8,0,0,1,.3-1.1h.1l15.2-11a3,3,0,0,0-1.8-5.4H309.5c-.4,0-.6-.2-.8-.6-1.3-4.2-3.9-11.9-5.9-17.9a3,3,0,0,0-5.7,0L291,20.6H271.3a3,3,0,0,0-1.7,5.4L285,37.1c.4.2.4.5.3.9l-5.8,17.8a3,3,0,0,0,4.6,3.4Zm85.4,0a.8.8,0,0,1,1.1,0l15.4,11.1a3,3,0,0,0,4.6-3.4l-5.8-17.8a.8.8,0,0,1,.3-1.1h0l15.3-11a3,3,0,0,0-1.7-5.4h-19c-.5,0-.6-.2-.8-.6-1.3-4.2-3.9-11.8-5.9-17.8a3,3,0,0,0-5.7,0l-6.1,18.4H356.7a3,3,0,0,0-1.7,5.4l15.4,11.1c.4.2.4.5.3.9l-5.8,17.8a3,3,0,0,0,4.6,3.4Z" fill="green" />';
    innerHTML +=
        '<g clip-path="url(#' +
        uuid +
        ')"><path  class="clsMainCircle clsAccentStroke"  id="clsMainCircle" d="M15.7,59.3a3,3,0,0,1-4.6-3.4L17.1,38c.1-.4.1-.7-.3-.9L1.3,26.1a3,3,0,0,1,1.7-5.4H22.8L28.8,2.2a3,3,0,0,1,5.7,0L40.5,20a.7.7,0,0,0,.8.6H60.3a3,3,0,0,1,1.7,5.4L46.8,37a.9.9,0,0,0-.4,1.1l5.9,17.8a3,3,0,0,1-4.6,3.4L32.3,48.2a.8.8,0,0,0-1.1,0ZM121.6,48.2a.8.8,0,0,1,1.1,0l15.4,11a3,3,0,0,0,4.6-3.4l-5.9-17.8a.9.9,0,0,1,.4-1.1l15.3-11a3,3,0,0,0-1.7-5.4h-19a.7.7,0,0,1-.8-.6h0c-1.3-4.2-3.9-11.9-5.9-17.9a3,3,0,0,0-5.7,0l-6.1,18.5H93.5a3,3,0,0,0-1.7,5.4l15.4,11.1c.4.2.4.5.3.9-1.3,3.9-3.9,11.6-5.9,17.9a3,3,0,0,0,4.6,3.4Zm88.4,0a.8.8,0,0,1,1.1,0l15.4,11.1a3,3,0,0,0,4.6-3.4l-5.8-17.8a.8.8,0,0,1,.3-1.1h0l15.3-11a3,3,0,0,0-1.7-5.4h-19a.7.7,0,0,1-.8-.6h0c-1.3-4.2-3.9-11.9-5.9-17.9a3,3,0,0,0-5.7,0l-6.1,18.5H181.9a3,3,0,0,0-1.7,5.4l15.4,11.1c.4.2.4.5.3.9L190,55.9a3,3,0,0,0,4.6,3.4Zm89.4,0a.8.8,0,0,1,1.1,0l15.4,11.1a3,3,0,0,0,4.6-3.4l-5.8-17.8a.8.8,0,0,1,.3-1.1h.1l15.2-11a3,3,0,0,0-1.8-5.4H309.5c-.4,0-.6-.2-.8-.6-1.3-4.2-3.9-11.9-5.9-17.9a3,3,0,0,0-5.7,0L291,20.6H271.3a3,3,0,0,0-1.7,5.4L285,37.1c.4.2.4.5.3.9l-5.8,17.8a3,3,0,0,0,4.6,3.4Zm85.4,0a.8.8,0,0,1,1.1,0l15.4,11.1a3,3,0,0,0,4.6-3.4l-5.8-17.8a.8.8,0,0,1,.3-1.1h0l15.3-11a3,3,0,0,0-1.7-5.4h-19c-.5,0-.6-.2-.8-.6-1.3-4.2-3.9-11.8-5.9-17.8a3,3,0,0,0-5.7,0l-6.1,18.4H356.7a3,3,0,0,0-1.7,5.4l15.4,11.1c.4.2.4.5.3.9l-5.8,17.8a3,3,0,0,0,4.6,3.4Z" fill="red" /></g>';
    innerHTML += "</svg>";
    microParentNode.innerHTML = innerHTML;

    // For Microchart Node
    let microchartNodeCircle = parentNode.querySelectorAll("[id='clsCircleBG']");
    if (microchartNodeCircle && microchartNodeCircle.length > 0) {
        microchartNodeCircle.forEach((element) => {
            this.setTextType(element);
            this.eventManager.addEvent(element, "click", this.ratingStarClickEvent);
        });
    }
};
SGBaseClass.prototype.ratingStarClickEvent = function (event) {
    let percent = (event.offsetX / event.target.parentElement.parentElement.offsetWidth) * 100;
    let nodeItem = this.sgParent.querySelector('[data-id="contentmicrochartparent"]');
    // nodeItem.style.setProperty("--percentageValue", parseFloat(percent) + "%");
    this.eventManager.dispatch("sgPropertyChangeCallback", percent, nodeItem, "rating");
    this.eventManager.dispatch("focusout", event.target);
};
SGBaseClass.prototype.parseRatingValue = function (data, parentNode) {
    let mainCircle = parentNode.querySelector(".clsMainCircle");
    let defaultValue = 80;
    data = data ? data.toString().replace(/[^0-9.]/g, "") : defaultValue;
    let value = Math.round(data) != NaN ? Math.round(data) : data;
    value = value > 100 ? 100 : value == "" || isNaN(value) ? defaultValue : value;
    parentNode.style.setProperty("--percentageValue", value + "%");
    if (mainCircle) mainCircle.setAttribute("data-percentageValue", value);
};
//CTA social and contact
SGBaseClass.prototype.createCtaSocial = function (assetParent) {
    let oldCustomLinkParent = assetParent.querySelector("[id='ctaSocialParent']");
    if (oldCustomLinkParent) oldCustomLinkParent.parentElement.removeChild(oldCustomLinkParent);

    let menuJson = this.objDataToSG && this.objDataToSG.menufromjson ? this.objDataToSG.menufromjson : null;
    let isEvent = menuJson?.haseventicons ? true : false;
    let ctaSocialParent = document.createElement("div");
    ctaSocialParent.id = "ctaSocialParent";
    ctaSocialParent.className = "ctaSocialParent";
    if (isEvent) ctaSocialParent.setAttribute("isevent", "true");
    this.setTextType(ctaSocialParent);
    assetParent.appendChild(ctaSocialParent);

    let ctaSocialInnerParent = document.createElement("div");
    ctaSocialInnerParent.id = "ctaSocialInnerParent";
    ctaSocialInnerParent.className = "ctaSocialInnerParent";
    this.setTextType(ctaSocialInnerParent);
    ctaSocialParent.appendChild(ctaSocialInnerParent);

    let nodes = this.sgData[0];
    let objIndex = -1;

    let slideParent = this.slideContent ? this.slideContent : this.sgParent.parentElement.parentElement;
    let sgDomDataNodes = slideParent ? slideParent.querySelector("[id='AESpecialGraphics']").children : null;

    if (isEvent) {
        try {
            let arrNewData = [];
            for (let a = 0; a < 12; a++) {
                let sType = nodes["socialicon" + (a + 1) + "socialtype"];
                if (sType == "address" || sType == "time" || sType == "date") {
                    let primaryData = nodes["socialicon" + (a + 1) + "primary"] || "";
                    let secondaryData = nodes["socialicon" + (a + 1) + "secondary"] || "";
                    let socialtypeData = nodes["socialicon" + (a + 1) + "socialtype"] || "";
                    arrNewData.push({ primary: primaryData, secondary: secondaryData, socialtype: socialtypeData });
                }
                delete nodes["socialicon" + (a + 1)];
                delete nodes["socialicon" + (a + 1) + "primary"];
                delete nodes["socialicon" + (a + 1) + "secondary"];
                delete nodes["socialicon" + (a + 1) + "socialtype"];
            }
            // console.table(arrNewData);
            // console.table(nodes);
            for (let a = 0; a < arrNewData.length; a++) {
                nodes["socialicon" + (a + 1)] = "";
                nodes["socialicon" + (a + 1) + "primary"] = arrNewData[a].primary;
                nodes["socialicon" + (a + 1) + "secondary"] = arrNewData[a].secondary;
                nodes["socialicon" + (a + 1) + "socialtype"] = arrNewData[a].socialtype;
            }
            delete nodes["website"];
            // console.table(nodes);
        } catch (error) {
            console.log("Error on checking events data");
        }
    }

    let emptyCount = 0;
    for (let a = 0; a < 12; a++) {
        let socialIconNode = nodes["socialicon" + (a + 1)];
        if (socialIconNode == "") emptyCount++;
    }
    if (emptyCount == 12) {
        delete nodes["socialicon5"];
        delete nodes["socialicon6"];
        delete nodes["socialicon7"];
        delete nodes["socialicon8"];
        delete nodes["socialicon9"];
        delete nodes["socialicon10"];
        delete nodes["socialicon11"];
        delete nodes["socialicon12"];
    }

    let isAdded = "";
    for (let a = 0; a < 12; a++) {
        if ((isAdded == "" || isAdded == "1") && nodes["socialicon" + (a + 1) + "socialtype"]) {
            isAdded = "1";
            objIndex++;
            this.addSocialNodeItem(nodes["socialicon" + (a + 1) + "socialtype"], objIndex + "", false);
        } else if ((isAdded == "" || isAdded == "2") && nodes["customsociallinksub" + (a + 1)]) {
            isAdded = "2";
            objIndex++;
            let strName = objIndex == 0 ? "linkedin" : objIndex == 1 ? "twitter" : objIndex == 2 ? "facebook" : objIndex == 3 ? "instagram" : "skype";
            nodes["socialicon" + (a + 1) + "primary"] = strName;
            nodes["socialicon" + (a + 1) + "secondary"] = nodes["customsociallinksub" + (a + 1)];
            if (sgDomDataNodes && sgDomDataNodes.length > 0 && sgDomDataNodes[0].children.length > 0) {
                let socialIconNode = sgDomDataNodes[0].getElementsByTagName("socialicon" + (a + 1));
                if (!socialIconNode) {
                    let newSocialIconNode = document.createElement("socialicon" + (a + 1));
                    sgDomDataNodes[0].appendChild(newSocialIconNode);
                    socialIconNode = sgDomDataNodes[0].getElementsByTagName("socialicon" + (a + 1));
                }
                if (socialIconNode && socialIconNode.length > 0) {
                    socialIconNode[0].setAttribute("socialicon" + (a + 1) + "primary", strName);
                    socialIconNode[0].setAttribute("socialicon" + (a + 1) + "secondary", nodes["customsociallinksub" + (a + 1)]);
                    socialIconNode[0].setAttribute("socialicon" + (a + 1) + "socialtype", strName);
                }
            }
            this.addSocialNodeItem(strName, objIndex + "", false);
        } else if ((isAdded == "" || isAdded == "3") && nodes["website"] != undefined && (nodes["website"] != null && nodes["websiteprompt"]) != undefined && nodes["websiteprompt"] != null) {
            isAdded = "3";
            objIndex++;
            let strName = objIndex == 0 ? "address" : objIndex == 1 ? "email" : objIndex == 2 ? "phone" : objIndex == 3 ? "website" : null;
            let strValueName = objIndex == 0 ? "venue" : objIndex == 1 ? "creatoremail" : objIndex == 2 ? "phone" : objIndex == 3 ? "website" : null;
            if (nodes[strValueName] != null && nodes[strValueName] != undefined) {
                if (sgDomDataNodes && sgDomDataNodes.length > 0 && sgDomDataNodes[0].children.length > 0) {
                    let socialIconNode = sgDomDataNodes[0].getElementsByTagName("socialicon" + (a + 1));
                    if (!socialIconNode) {
                        let newSocialIconNode = document.createElement("socialicon" + (a + 1));
                        sgDomDataNodes[0].appendChild(newSocialIconNode);
                        socialIconNode = sgDomDataNodes[0].getElementsByTagName("socialicon" + (a + 1));
                    }
                    if (socialIconNode && socialIconNode.length > 0) {
                        socialIconNode[0].setAttribute("socialicon" + (a + 1) + "primary", nodes[strValueName + "prompt"]);
                        socialIconNode[0].setAttribute("socialicon" + (a + 1) + "secondary", nodes[strValueName]);
                        socialIconNode[0].setAttribute("socialicon" + (a + 1) + "socialtype", strName);
                    }
                }
                nodes["socialicon" + (a + 1) + "primary"] = nodes[strValueName + "prompt"];
                nodes["socialicon" + (a + 1) + "secondary"] = nodes[strValueName];
                this.addSocialNodeItem(strName, objIndex + "", false);
            }
        }
    }
    if (objIndex == -1 && !isEvent) {
        this.addSocialNodeItem("address", "0", false);
        this.addSocialNodeItem("phone", "1", false);
        this.addSocialNodeItem("twitter", "2", false);
        this.addSocialNodeItem("instagram", "3", false); //testbala
    } else if (objIndex == -1 && isEvent) {
        this.addSocialNodeItem("date", "0", false);
        this.addSocialNodeItem("time", "1", false);
        this.addSocialNodeItem("address", "2", false);
    }
};
SGBaseClass.prototype.createSocialIconNodeBase = function (parent, objIndex, type = "", primaryData, secondaryData) {
    let i = parseInt(objIndex);
    let ctaSocialNodeParent = document.createElement("div");
    ctaSocialNodeParent.id = "ctaSocialNodeParent" + i;
    ctaSocialNodeParent.className = "ctaSocialNodeParent" + this.selectionLayerClass;
    this.setCommonSelector(ctaSocialNodeParent);
    ctaSocialNodeParent.setAttribute("data-type", "TEXT");
    parent.appendChild(ctaSocialNodeParent);

    this.createCommonIcon(ctaSocialNodeParent, i);

    let ctaSocialNodeTextParent = document.createElement("div");
    ctaSocialNodeTextParent.id = "ctaSocialNodeTextParent" + i;
    ctaSocialNodeTextParent.className = "ctaSocialNodeTextParent";
    this.setTextType(ctaSocialNodeTextParent);
    ctaSocialNodeParent.appendChild(ctaSocialNodeTextParent);

    let primaryFontClass = this.styleData.fontData.socialicontitle ? this.styleData.fontData.socialicontitle : "p4";
    let commonClass = " " + this.selectionLayerClass + this.moodanimation;

    let headingText = primaryData ? primaryData : this.sgData[0]["socialicon" + (i + 1) + "primary"];
    let ctaSocialNodeHeadingText = this.specialGraphicsUtils.createTextElement(
        ctaSocialNodeTextParent,
        headingText ? headingText : !!type ? type.charAt(0).toUpperCase() + type.slice(1) : "Enter text..",
        "ctaSocialNodeHeadingText" + i,
        "ctaSocialNodeHeadingText" + commonClass + primaryFontClass,
        "socialicon" + (i + 1)
    );
    this.setCommonSelector(ctaSocialNodeHeadingText);
    ctaSocialNodeHeadingText.contentEditable = "true";
    ctaSocialNodeHeadingText.style.pointerEvents = "all";
    ctaSocialNodeHeadingText.setAttribute("data-prompt-text", "Enter primary text...");
    ctaSocialNodeHeadingText.style.minHeight = window.getComputedStyle(ctaSocialNodeHeadingText).lineHeight;
    ctaSocialNodeHeadingText.setAttribute("data-fontfit", "false");

    this.applyTextBaseProps(ctaSocialNodeHeadingText, 0, "socialicon" + (i + 1) + "primary");
    this.setTextFocus(ctaSocialNodeHeadingText);

    let secondaryFontClass = this.styleData.fontData.socialiconcontent ? this.styleData.fontData.socialiconcontent : "p5";
    let contentText = "";
    if (type == this.sgData[0]["socialicon" + (i + 1) + "socialtype"] || !this.sgData[0]["socialicon" + (i + 1) + "socialtype"]) contentText = this.sgData[0]["socialicon" + (i + 1) + "secondary"];
    let ctaSocialNodeContentText = this.specialGraphicsUtils.createTextElement(ctaSocialNodeTextParent, secondaryData ? secondaryData : contentText ? contentText : "", "ctaSocialNodeContentText" + i, "ctaSocialNodeContentText" + commonClass + secondaryFontClass, "socialicon" + (i + 1));
    this.setCommonSelector(ctaSocialNodeContentText);
    ctaSocialNodeContentText.contentEditable = "true";
    ctaSocialNodeContentText.setAttribute("data-prompt-text", "Enter " + (!!type ? type + " text" : "text"));
    if (type == "time") ctaSocialNodeContentText.setAttribute("data-prompt-text", "hh:mm:ss");
    else if (type == "date") ctaSocialNodeContentText.setAttribute("data-prompt-text", "MM/DD/YYYY");
    ctaSocialNodeContentText.style.pointerEvents = "all";
    ctaSocialNodeContentText.style.minHeight = window.getComputedStyle(ctaSocialNodeContentText).lineHeight;
    ctaSocialNodeContentText.setAttribute("data-fontfit", "false");
    if (contentText && !contentText.includes("http")) contentText = "https://" + contentText;
    this.updateAgendaLink(null, contentText, ctaSocialNodeParent.id);

    // if (this.socialHeightFit && type == "address") {
    if (this.socialHeightFit) {
        ctaSocialNodeContentText.socialheightfit = this.socialHeightFit;
        ctaSocialNodeContentText.setAttribute("socialheightfit", "true");
    }
    this.applyTextBaseProps(ctaSocialNodeContentText, 0, "socialicon" + (i + 1) + "secondary");
    this.setTextFocus(ctaSocialNodeContentText);

    if (this.sgParent.parentElement.parentElement.hasAttribute("data-variation-name")) {
        let variationName = this.sgParent.parentElement.parentElement.getAttribute("data-variation-name").split(",");
        if (variationName.includes("socialiconprompt")) parent.parentElement.classList.add("sgHidePrompt");
        if (variationName.includes("socialicon")) parent.parentElement.classList.add("sgHideIcons");
    }
    if (this.sgParent.parentElement.parentElement.hasAttribute("data-variation-type")) {
        let variationType = this.sgParent.parentElement.parentElement.getAttribute("data-variation-type").split(",");
        if (variationType.includes("socialiconprompt")) parent.parentElement.classList.add("sgHidePrompt");
        if (variationType.includes("socialicon")) parent.parentElement.classList.add("sgHideIcons");
    }
    let socialLine = document.createElement("div");
    socialLine.id = "socialLine" + i;
    socialLine.setAttribute("data-animation", "connector");
    socialLine.className = "socialLine socialLine" + i + " " + this.moodanimation;
    ctaSocialNodeParent.appendChild(socialLine);
    return ctaSocialNodeParent;
};
//Create icon Common
SGBaseClass.prototype.createCommonIcon = function (parent, i) {
    let iconNodeParent = document.createElement("div");
    iconNodeParent.id = "sgIconParent" + i;
    iconNodeParent.className = "sgIconParent" + this.moodanimation;
    this.setTextType(iconNodeParent);
    iconNodeParent.setAttribute("data-nodetype", "contentContainer");
    parent.appendChild(iconNodeParent);

    let contentBackground = document.createElement("div");
    contentBackground.id = "contentBackground";
    contentBackground.className = "contentBackground";
    contentBackground.style.position = "absolute";
    contentBackground.style.pointerEvents = "none";
    contentBackground.style.width = "100%";
    contentBackground.style.height = "100%";
    this.setTextType(contentBackground);
    contentBackground.setAttribute("data-nodetype", "contentBackground");
    iconNodeParent.appendChild(contentBackground);

    let iconHolder = document.createElement("div");
    iconHolder.id = "sgIconHolder" + i;
    iconHolder.className = "sgIconHolder";
    iconHolder.setAttribute("data-nodetype", "iconHolder");
    iconNodeParent.appendChild(iconHolder);

    let iconBackground = document.createElement("div");
    iconBackground.id = "sgIconBackground";
    iconBackground.className = "sgIconBackground " + this.moodanimation;
    iconBackground.style.pointerEvents = "none";
    this.setTextType(iconBackground);
    iconBackground.setAttribute("data-nodetype", "iconBackground");
    iconHolder.appendChild(iconBackground);

    let iconOverlay = document.createElement("div");
    iconOverlay.id = "sgIconOverlay";
    iconOverlay.className = "sgIconOverlay " + this.moodanimation;
    iconOverlay.style.pointerEvents = "none";
    this.setTextType(iconOverlay);
    iconOverlay.setAttribute("data-nodetype", "iconOverlay");
    iconHolder.appendChild(iconOverlay);
};
SGBaseClass.prototype.createDeviceSvgNode = function (parent, index = "") {
    let deviceImageParentNode = document.createElement("div");
    deviceImageParentNode.id = "deviceContainerNode" + index;
    deviceImageParentNode.setAttribute("data-animation", "coverimage");
    deviceImageParentNode.className = "deviceImageParentNode" + this.moodanimation;
    deviceImageParentNode.style.pointerEvents = "none";
    deviceImageParentNode.style.position = "absolute";
    deviceImageParentNode.setAttribute("device", "true");
    parent.appendChild(deviceImageParentNode);

    let deviceImageNode = document.createElement("div");
    deviceImageNode.id = "deviceHolderNode";
    deviceImageNode.className = "deviceImageNode";
    deviceImageNode.setAttribute("data-nodetype", "deviceHolder");
    deviceImageParentNode.appendChild(deviceImageNode);
    return deviceImageNode;
};
//Create Event base with nodes
SGBaseClass.prototype.createEventElements = function (parent, type) {
    let commonClass = this.selectionLayerClass + this.moodanimation;
    if (type == "date") {
        //Date field
        let textContent = this.sgData[0]["eventdate"] ? this.sgData[0]["eventdate"] : "";
        let eventDateField = this.specialGraphicsUtils.createTextElement(parent, textContent, "sgEventDateNode", "eventDate " + commonClass, "eventdate");
        this.setCommonSelector(eventDateField);
        eventDateField.setAttribute("data-fontfit", "false");
        eventDateField.setAttribute("data-eventtype", "date");
        eventDateField.contentEditable = "true";
        eventDateField.setAttribute("data-prompt-text", this.styleData.presenterNamePrompt);
        this.applyTextBaseProps(eventDateField, 0, "eventdate");
        this.setTextFocus(eventDateField);
    } else if (type == "year") {
        //Year field
        let textContent = this.sgData[0]["eventyear"] ? this.sgData[0]["eventyear"] : "";
        let eventYearField = this.specialGraphicsUtils.createTextElement(parent, textContent, "sgEventYearNode", "eventYear " + commonClass, "eventyear");
        this.setCommonSelector(eventYearField);
        eventYearField.setAttribute("data-fontfit", "false");
        eventYearField.setAttribute("data-eventtype", "year");
        eventYearField.contentEditable = "true";
        eventYearField.setAttribute("data-prompt-text", this.styleData.presenterNamePrompt);
        this.applyTextBaseProps(eventYearField, 0, "eventyear");
        this.setTextFocus(eventYearField);
    } else if (type == "month") {
        //Month field
        let textContent = this.sgData[0]["eventmonth"] ? this.sgData[0]["eventmonth"] : "";
        let eventMonthField = this.specialGraphicsUtils.createTextElement(parent, textContent, "sgEventMonthNode", "eventMonth " + commonClass, "eventmonth");
        this.setCommonSelector(eventMonthField);
        eventMonthField.setAttribute("data-fontfit", "false");
        eventMonthField.setAttribute("data-eventtype", "month");
        eventMonthField.contentEditable = "true";
        eventMonthField.setAttribute("data-prompt-text", this.styleData.presenterNamePrompt);
        this.applyTextBaseProps(eventMonthField, 0, "eventmonth");
        this.setTextFocus(eventMonthField);
    } else if (type == "time") {
        //Time field
        let textContent = this.sgData[0]["eventtime"] ? this.sgData[0]["eventtime"] : "";
        let eventTimeField = this.specialGraphicsUtils.createTextElement(parent, textContent, "sgEventTimeNode", "eventTime " + commonClass, "eventtime");
        this.setCommonSelector(eventTimeField);
        eventTimeField.setAttribute("data-fontfit", "false");
        eventTimeField.setAttribute("data-eventtype", "time");
        eventTimeField.contentEditable = "true";
        eventTimeField.setAttribute("data-prompt-text", this.styleData.presenterNamePrompt);
        this.applyTextBaseProps(eventTimeField, 0, "eventtime");
        this.setTextFocus(eventTimeField);
    }
};
SGBaseClass.prototype.createEventIconNode = function (parentNode) {
    let eventIconParent = document.createElement("div");
    eventIconParent.id = "eventIconParent";
    eventIconParent.className = "eventIconParent" + this.moodanimation;
    eventIconParent.style.pointerEvents = "none";
    eventIconParent.setAttribute("data-nodetype", "contentContainer");
    parentNode.appendChild(eventIconParent);

    let contentBackground = document.createElement("div");
    contentBackground.id = "contentBackground";
    contentBackground.className = "contentBackground";
    contentBackground.style.position = "absolute";
    contentBackground.style.pointerEvents = "none";
    contentBackground.style.width = "100%";
    contentBackground.style.height = "100%";
    this.setTextType(contentBackground);
    contentBackground.setAttribute("data-nodetype", "contentBackground");
    eventIconParent.appendChild(contentBackground);

    let eventIconNode = document.createElement("div");
    eventIconNode.id = "eventIconNode";
    eventIconNode.className = "eventIconNode";
    eventIconNode.style.pointerEvents = "none";
    eventIconNode.setAttribute("data-nodetype", "iconHolder");
    this.setTextType(eventIconNode);
    eventIconParent.appendChild(eventIconNode);

    let iconBackground = document.createElement("div");
    iconBackground.id = "iconBackground";
    iconBackground.className = "iconBackground";
    iconBackground.style.pointerEvents = "none";
    this.setTextType(iconBackground);
    iconBackground.setAttribute("data-nodetype", "iconBackground");
    eventIconNode.appendChild(iconBackground);

    let iconOverlay = document.createElement("div");
    iconOverlay.id = "iconOverlay";
    iconOverlay.className = "iconOverlay " + this.moodanimation;
    iconOverlay.style.pointerEvents = "none";
    this.setTextType(iconOverlay);
    iconOverlay.setAttribute("data-nodetype", "iconOverlay");
    eventIconNode.appendChild(iconOverlay);
};
//Common bg image with image,solid,video,lottie support
SGBaseClass.prototype.createCommonBgImageNode = function (parentNode, props, isIntro = false) {
    let commonBgImageParent = document.createElement("div");
    commonBgImageParent.id = "commonBgImageParent" + (isIntro ? "Intro" : "");
    commonBgImageParent.className = "commonBgImageParent" + this.selectionLayerClass + this.moodanimation;
    commonBgImageParent.setAttribute("data-animation", "coverimage" + (isIntro ? "intro" : ""));
    this.setCommonSelector(commonBgImageParent);
    parentNode.appendChild(commonBgImageParent);

    let propURL = props?.commonbg?.url ? props.commonbg.url : null;
    let videoURL = "genericassets/video/preset/videotext.mp4";
    let imageURL = "genericassets/placeholderimages/coverimage.jpg";
    let solidURL = "#CCCCCC";
    let assetType = this.sgData[0].commonbgtype || props?.commonbg?.type ? props.commonbg.type : "image";
    if (assetType == "illustration") {
        this.sgParent.setAttribute("data-svgsupport", "true");
        assetType = "image";
    }
    let src = this.sgData[0].commonbg ? this.sgData[0].commonbg : propURL ? propURL : assetType == "video" ? videoURL : assetType == "solid" ? solidURL : imageURL;
    if (assetType == "image" && (src.includes(".mp4") || src.includes(".json"))) src = imageURL;
    if (assetType == "video" && !src.includes(".mp4")) src = videoURL;
    if (assetType == "lottie" && !src.includes(".json")) {
        src = imageURL;
        assetType = "image";
    }
    if (this.getIllustrationPath) src = this.getIllustrationPath(src);
    src = this.specialGraphicsUtils.checkAppStaticURLSG(src, this.appStaticURL);

    var slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
    if (slideDomContentGroup && slideDomContentGroup.getElementsByTagName("node-0").length > 0) {
        let nodeData = slideDomContentGroup.getElementsByTagName("node-0")[0];
        if (nodeData?.getElementsByTagName("commonbg").length > 0) {
            let nodeDataList = nodeData.getElementsByTagName("commonbg")[0];
            if (nodeDataList) nodeDataList.setAttribute("data-src", src);
        }
    }

    let assetGroupingId = this.objDataToSG?.assetGroupingId ? this.objDataToSG.assetGroupingId : null;

    //Video support
    let commonBgVideo = document.createElement("video");
    commonBgVideo.id = "commonBgVideo";
    commonBgVideo.className = "commonBgVideoNodeSG";
    commonBgImageParent.appendChild(commonBgVideo);
    this.setTextType(commonBgVideo);
    commonBgVideo.style.objectFit = "cover";
    commonBgVideo.style.left = "0px";
    commonBgVideo.style.top = "0px";
    commonBgVideo.style.width = "100%";
    commonBgVideo.style.height = "100%";
    commonBgVideo.autoplay = true;
    commonBgVideo.disablePictureInPicture = true;
    commonBgVideo.playsinline = true;
    commonBgVideo.WebKitPlaysInline = true;
    commonBgVideo.muted = "true";
    commonBgVideo.loop = props?.commonbg?.loop == "false" || props?.commonbg?.loop == false ? false : true;
    commonBgVideo.setAttribute("data-isvideo", "true");
    commonBgVideo.setAttribute("data-fit", "false");
    commonBgVideo.setAttribute("playsinline", "");
    commonBgVideo.setAttribute("webkit-playsinline", "");
    if (assetGroupingId) commonBgVideo.setAttribute("assetGroupingId", assetGroupingId);

    //Image support
    let commonBgImage = this.createCommonBgImageType(commonBgImageParent, isIntro, src);
    if (assetGroupingId) commonBgImage.setAttribute("assetGroupingId", assetGroupingId);

    //Lottie support
    let commonBgLottie = document.createElement("div");
    commonBgLottie.id = "commonBgLottie";
    commonBgLottie.className = "commonBgLottie";
    commonBgImageParent.appendChild(commonBgLottie);

    commonBgVideo.style.display = assetType == "video" ? "flex" : "none";
    commonBgImage.style.display = assetType == "image" ? "flex" : "none";
    commonBgLottie.style.display = assetType == "lottie" ? "flex" : "none";

    if (src.includes(".mp4") && assetType == "video") {
        commonBgVideo.src = src;
        // This attribute need to export ppt using poster image
        let posterpath = src.replace(".mp4", ".jpg");
        commonBgVideo.setAttribute("poster", posterpath);
    } else if (assetType == "image") {
        commonBgImage.getElementsByTagName("img")[0].src = src;
    } else if (assetType == "solid") commonBgImage.style.background = src;
    else if (assetType == "lottie" && src.includes(".json")) {
        commonBgLottie.setAttribute("data-lottie", src);
        let arrAssets = [{ type: "json", url: src, id: "commonbglottie", parent: commonBgLottie }];
        // this.loadAssets(arrAssets, this.lottieLoadCallback, this.assetError);
        this.arrCommonAssets.push({ array: arrAssets, callback: this.lottieLoadCallback });
    }
};
//Create presenter image node
SGBaseClass.prototype.createCommonBgImageType = function (parentNode, isIntro, imgPath) {
    //Creating presenter image main parent
    let commonBgImage = document.createElement("div");
    commonBgImage.id = "commonBgImage";
    commonBgImage.className = "commonBgImage";
    commonBgImage.style.position = "relative";
    commonBgImage.setAttribute("data-target-id", "presetimage");
    commonBgImage.setAttribute("data-fit", "false");
    commonBgImage.setAttribute("data-type", "IMAGE");
    commonBgImage.setAttribute("data-nodetype", "contentContainer");
    parentNode.appendChild(commonBgImage);

    //Creating image content background
    let contentBackground = document.createElement("div");
    contentBackground.id = "contentBackground";
    contentBackground.className = "contentBackground";
    contentBackground.style.position = "absolute";
    contentBackground.style.pointerEvents = "none";
    contentBackground.style.width = "100%";
    contentBackground.style.height = "100%";
    contentBackground.setAttribute("data-nodetype", "contentBackground");
    commonBgImage.appendChild(contentBackground);

    //Creating image holder
    let commonBgImageParent = document.createElement("div");
    commonBgImageParent.id = "commonBgImageParentNode";
    commonBgImageParent.setAttribute("data-nodetype", "imageHolder");
    commonBgImageParent.className = "commonBgImageParent" + this.selectionLayerClass;
    this.setCommonSelector(commonBgImageParent);
    commonBgImage.appendChild(commonBgImageParent);

    //Creating image background
    let commonBgImageBackground = document.createElement("div");
    commonBgImageBackground.id = "commonBgImageBackground";
    commonBgImageBackground.className = "commonBgImageBackground";
    commonBgImageBackground.style.pointerEvents = "none";
    commonBgImageBackground.style.position = "absolute";
    commonBgImageBackground.setAttribute("data-nodetype", "imageBackground");
    commonBgImageParent.appendChild(commonBgImageBackground);

    var svgElementDiv = document.createElement("div");

    // This is for change image / icon from inline floater change
    this.sgParent.setAttribute("data-svgsupport", "true");
    //Creating svg node
    svgElementDiv.id = "svgElementDiv";
    svgElementDiv.className = "svgElementDiv accent1-fill";
    svgElementDiv.style.pointerEvents = "none";
    commonBgImageParent.appendChild(svgElementDiv);
    if (svgElementDiv.children.length > 0) {
        svgElementDiv.children[0].style.width = "100%";
        svgElementDiv.children[0].style.height = "100%";
    }
    svgElementDiv.style.display = "none";

    //Creating image node
    let index = isIntro ? 0 : 1;
    let commonBgSrc = this.sgData[index] && this.sgData[index].commonbg ? this.sgData[index].commonbg : this.sgData.commonbg;
    if (!commonBgSrc && imgPath) commonBgSrc = imgPath;
    if (!commonBgSrc) commonBgSrc = "genericassets/placeholderimages/coverimage.jpg";
    commonBgSrc = this.specialGraphicsUtils.checkAppStaticURLSG(commonBgSrc, this.appStaticURL);
    let commonBgImageNode = this.specialGraphicsUtils.createImageElement(commonBgImageParent, "commonBgImage", "", commonBgSrc, 0, 0, 0, 0, "commonbg", this.sgData[index], "sgCommonBgImageNode");
    commonBgImageNode.setAttribute("data-nodetype", "imageNode");

    this.eventManager.addEvent(commonBgImageNode, "dblclick", this.imageDoubleClickEvent);
    commonBgImageNode.setAttribute("clicklistener", "true");

    commonBgImageNode.style.pointerEvents = "none";
    if (commonBgSrc.includes(".svg") && this.sgParent.getAttribute("data-svgsupport") == "true") {
        let arrAssets = [];
        arrAssets.push({ url: commonBgSrc, id: "iconload", type: "SVG" });
        this.arrCommonAssets.push({ array: arrAssets, callback: this.assetsLoadComplete, parent: svgElementDiv.parentElement });

        svgElementDiv.style.display = "flex";
        commonBgImageNode.style.display = "none";
    }

    //Creating overlay div
    let colorDiv = document.createElement("div");
    colorDiv.id = "commonBgColorDiv";
    colorDiv.className = "commonBgColorDiv" + this.moodanimation;
    colorDiv.setAttribute("data-nodetype", "imageOverlay");
    commonBgImageParent.appendChild(colorDiv);

    return commonBgImage;
};
SGBaseClass.prototype.lottieLoadCallback = function (response) {
    try {
        if (response && response.filter((obj) => obj.id == "commonbglottie").length > 0) {
            let lottieData = response.filter((obj) => obj.id == "commonbglottie");
            let lottieAnimDiv = lottieData[0].parent;
            const jsonData = lottieData[0].data;
            let lottieTime = [jsonData.sf, jsonData.ef];
            lottieAnimDiv.innerHTML = "";
            let params = {
                container: lottieAnimDiv,
                renderer: "svg",
                loop: true,
                autoplay: false,
                progressiveLoad: false,
                animationData: JSON.parse(jsonData),
            };

            this.sglottie = bodymovin.loadAnimation(params);
            this.sglottie.playSegments([lottieTime[0], lottieTime[1]], true);
        }
        // console.log("Lottie loaded");
    } catch (error) {
        console.log("Error on lottie load " + error);
    }
};

//After highlight we have to do font fit
SGBaseClass.prototype.highlightCompleteCallback = function (assetParent, i) {
    if (assetParent) {
        let sgTitleNode = assetParent.querySelector("[id*='sgTitleNode']");
        let sgSubTitleNode = assetParent.querySelector("[id*='sgSubTitleNode']");
        let sgTitleLabelNode = assetParent.querySelector("[id*='sgTitleLabelNode']");
        if (sgSubTitleNode) this.onTextChange(sgSubTitleNode);
        if (sgTitleNode) this.onTextChange(sgTitleNode);
        // if (sgTitleLabelNode) this.onTextChange(sgTitleLabelNode);

        if (assetParent && sgTitleNode && sgTitleLabelNode && sgTitleLabelNode) {
            let textParentElement = assetParent ? assetParent.querySelector("[id='textInnerParentNode']") : null;
            let parentNode = assetParent ? assetParent : textParentElement ? textParentElement.parentElement : null;
            let element = sgTitleNode && sgTitleNode.hasAttribute("data-parentid") ? sgTitleNode : sgSubTitleNode && sgSubTitleNode.hasAttribute("data-parentid") ? sgSubTitleNode : sgTitleLabelNode;
            if (element.hasAttribute("data-parentid")) {
                let parentID = element.getAttribute("data-parentid");
                if (assetParent && assetParent.querySelector("[id='" + parentID + "']")) {
                    parentNode = assetParent.querySelector("[id='" + parentID + "']");
                    textParentElement = parentNode;
                }
            }
            this.textElementPositioning(parentNode, textParentElement, i);
        }
    }
};
SGBaseClass.prototype.doFontFitFromTextSizeChange = function (element, doTextFitCall = true) {
    let isChangingText = !element.hasAttribute("data-changetext") || (element.hasAttribute("data-changetext") && element.getAttribute("data-changetext") != "true") ? false : true;

    let event = {};
    event.target = element;
    event.type = "focusin";
    this.focusCallBack(event);
    if (this.fontSizeChangeOnTextChange && doTextFitCall) this.fontSizeChangeOnTextChange(element);

    element.style.removeProperty("min-height");
    this.specialGraphicsUtils.doCheckMaxHeight(element, this.sgParent);

    if (this.onTextChange && (element.id == "sgTitleNode" || element.id == "sgSubTitleNode") && isChangingText == false) {
        this.onTextChange(element);
        if (this.doCheckTextLineHeightDiff) this.doCheckTextLineHeightDiff(element);
    } else if (element.herotextcallback) element.herotextcallback(element, false);
    else if (element.commonheightfit) element.commonheightfit(element);
    // else if (element.contactnodesheightfit) element.contactnodesheightfit(element);
    else if (element.socialheightfit) element.socialheightfit(element);
    else this.specialGraphicsUtils.doFontFitForCss(element, this.sgParent, null, this.textElementPositioning, this);
    //For agenda primary and secondary
    if (element.onTextChangeNode) element.onTextChangeNode(element, false);

    let assetParent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    if (!assetParent && this.sgParent.querySelector("[id='agendaTitleParent']") && element && (element.id == "sgTitleNode" || element.id == "sgSubTitleNode" || element.id == "sgTitleLabelNode")) assetParent = this.sgParent.querySelector("[id='agendaTitleParent']");
    if (assetParent) {
        let textParentElement = assetParent ? assetParent.querySelector("[id='textInnerParentNode']") : null;
        let parentNode = assetParent ? assetParent : textParentElement ? textParentElement.parentElement : null;
        if (element.hasAttribute("data-parentid")) {
            let parentID = element.getAttribute("data-parentid");
            if (assetParent && assetParent.querySelector("[id='" + parentID + "']")) {
                parentNode = assetParent.querySelector("[id='" + parentID + "']");
                textParentElement = parentNode;
            }
        }
        this.textElementPositioning(parentNode, textParentElement, this.currentNodeIndex - 1);
    }
    if (isChangingText == false) element.removeAttribute("data-changetext");
    if (element.hasAttribute("user-font-size")) {
        let userFont = element.getAttribute("user-font-size");
        let dummyDiv = document.createElement("div");
        dummyDiv.className = userFont;
        dummyDiv.style.position = "absolute";
        element.parentElement.appendChild(dummyDiv);
        let fontSize = window.getComputedStyle(dummyDiv).fontSize;
        if (parseFloat(fontSize) > 0) element.style.setProperty("--fontsizefinal", fontSize);
        element.parentElement.removeChild(dummyDiv);
    } else {
        element.style.removeProperty("--fontsizefinal");
        if (element.hasAttribute("data-customclass")) {
            this.specialGraphicsUtils.removeAllFontClass(element);
            if (!element.classList.contains(element.getAttribute("data-customclass"))) element.classList.add(element.getAttribute("data-customclass"));
        }
    }
    event.type = "focusout";
    this.focusCallBack(event);
    let hasUl = element.getElementsByTagName("ul").length > 0;
    if (hasUl && element?.id?.includes("sgSubTitleNode")) {
        let ul = element.getElementsByTagName("ul")[0];
        let li = ul.getElementsByTagName("li")?.[0];
        if (li) {
            let lineheight = window.getComputedStyle(li)["line-height"];
            ul.style.setProperty("--subTitleHolderMH", lineheight);
        }
    }
};
SGBaseClass.prototype.onTextChangeUpdatePlaceholderNode = function (textNode) {
    if (textNode && textNode.id.includes("phTextNode")) {
        let placeholderParent = textNode.parentElement;
        if (textNode && placeholderParent) {
            let lineHeight = parseFloat(window.getComputedStyle(textNode)["line-height"]);
            textNode.style.minHeight = Math.ceil(lineHeight) + 2 + "px";

            let placeholderParentHeight = parseFloat(placeholderParent.style.height);
            if (placeholderParent.style.height == "auto") placeholderParentHeight = parseFloat(placeholderParent.style.maxHeight);
            if (placeholderParent.hasAttribute("parentFullHeight")) placeholderParentHeight = parseFloat(placeholderParent.getAttribute("parentFullHeight"));

            let parentStyle = window.getComputedStyle(placeholderParent);
            let parentMargin = parentStyle ? parseFloat(parentStyle.marginTop) + parseFloat(parentStyle.marginBottom) : 0;
            let parenPadding = parentStyle ? parseFloat(parentStyle.paddingTop) + parseFloat(parentStyle.paddingBottom) : 0;

            placeholderParentHeight = placeholderParentHeight - parentMargin - parenPadding;

            textNode.style.removeProperty("max-height");
            textNode.style.maxHeight = "";

            let primaryHeight = textNode.style.maxHeight != "" && textNode.style.display != "none" ? parseFloat(textNode.style.maxHeight) : parseFloat(window.getComputedStyle(textNode).height);
            if (primaryHeight > placeholderParentHeight) {
                let targetNodeHeight = parseFloat(primaryHeight == "auto" ? 0 : primaryHeight);
                let remainingHeight = placeholderParentHeight;

                let linesFinal = parseInt(remainingHeight / lineHeight);
                let heightFinal = linesFinal * lineHeight;
                heightFinal = heightFinal == 0 ? lineHeight : heightFinal;

                textNode.style.maxHeight = heightFinal + "px";

                let minH = parseFloat(textNode.style.minHeight);
                if (!isNaN(minH) && minH > heightFinal) textNode.style.maxHeight = heightFinal + "px";
            } else {
                let numberOflines = primaryHeight / lineHeight;
                let diff = numberOflines - parseInt(numberOflines);
                if (diff > 0.9) numberOflines = parseInt(numberOflines) + 1;
                let maxHeightValue = parseInt(numberOflines) * lineHeight;
                textNode.style.maxHeight = maxHeightValue + "px";
            }
        }
    }
};
//Search logo/icon from server using prompt
SGBaseClass.prototype.searchLogoFromPrompt = function (updatedText, targetNode, targetIndex = 0, type, searchImageCallback, newType) {
    this.specialGraphicsUtils.searchImage(this.sgParent, this.appBaseURL, updatedText, targetIndex, this, type, targetNode, searchImageCallback, newType, this.appStaticURL);
};
SGBaseClass.prototype.applyAuthImagePropertyCommon = function (authimageProperty, assetParent, specialgraphicsPropertyUtils, index) {
    if (authimageProperty && assetParent && assetParent.querySelector("[id='authorImageParent']")) {
        let authorImageParent = assetParent.querySelector("[id='authorImageParent']");
        let authorContentParent = assetParent.querySelector("[id='authorContentParent']");
        let sgAuthorImageNode = assetParent.querySelector("[id='sgAuthorImageNode']");
        let colorDiv = authorContentParent?.querySelector("[id='authorOverlayDiv']");
        if (authimageProperty.positionvalue) authorImageParent.style.position = authimageProperty.positionvalue;
        if (authimageProperty.padding) specialgraphicsPropertyUtils.updatePadding(authimageProperty.padding, authorContentParent);
        if (authimageProperty.margin) specialgraphicsPropertyUtils.updateMargin(authimageProperty.margin, authorContentParent);
        if (authimageProperty.opacity) assetParent.style.setProperty("--authImageOpacity", authimageProperty.opacity);
        specialgraphicsPropertyUtils.applyImageProperties(authimageProperty, assetParent, index, authimageProperty, authorImageParent);
        if (authimageProperty.globalstyle && authorContentParent) {
            this.specialGraphicsUtils.applyClassNamesFromString(authorContentParent, authimageProperty.globalstyle);
            authorContentParent.classList.add("clsSingleColorParent");

            let percentValue = window.getComputedStyle(authorContentParent).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
            percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
            let sourceNode = authorContentParent.querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
            if (sourceNode) authorContentParent.style.setProperty("--customNodeBorderImageWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
        }
        if (authorContentParent) authorContentParent.style.display = "flex";
        if (this.applyChildStyleToParent) this.applyChildStyleToParent(authorContentParent, authorImageParent);

        authorImageParent.style.setProperty("margin", "unset");
        authorImageParent.style.setProperty("padding", "unset");
        if (sgAuthorImageNode && authimageProperty.contrast && authimageProperty.contrast == "fullbg") {
            sgAuthorImageNode.setAttribute("contrast", "fullbg");
            this.eventManager.dispatch("applyImageContrast", sgAuthorImageNode, assetParent);
        } else if (sgAuthorImageNode && authimageProperty.contrast && authimageProperty.contrast == "halfbg") {
            sgAuthorImageNode.setAttribute("contrast", "halfbg");
            this.eventManager.dispatch("applyImageContrast", sgAuthorImageNode, assetParent, true);
        }
        if (authimageProperty.contentBG) {
            let arrAssets = [];
            arrAssets.push({ parent: authorContentParent, type: "svg", url: authimageProperty.contentBG.value, id: authimageProperty.contentBG.id, color: authimageProperty.contentBG.color });
            // this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
            return arrAssets;
        }

        // Setting overlay enable/disable
        let tagWord = "author";
        if (this.sgData[index] && colorDiv && this.sgData[index][tagWord + "imageoverlayshow"]) {
            colorDiv.style.display = this.sgData[index][tagWord + "imageoverlayshow"] == "true" ? "block" : "none";
            if (authorContentParent && this.sgData[index][tagWord + "imageoverlayshow"] == "true") authorContentParent.setAttribute("data-isoverlay", "true");
        } else if (colorDiv) colorDiv.style.display = "none";

        // Setting overlay opacity
        if (this.sgData[index] && this.sgData[index][tagWord + "imageopacity"] && colorDiv) colorDiv.style.opacity = this.sgData[index][tagWord + "imageopacity"];
    }
    return null;
};
SGBaseClass.prototype.applyAuthTextPropertyCommon = function (authtextProperty, assetParent, specialgraphicsPropertyUtils) {
    if (authtextProperty && assetParent && assetParent.querySelector("[id='authorParent']")) {
        let authorParent = assetParent.querySelector("[id='authorParent']");
        let sgAuthorNameNode = assetParent.querySelector("[id='sgAuthorNameNode']");
        let sgAuthorDesignationNode = assetParent.querySelector("[id='sgAuthorDesignationNode']");
        if (authtextProperty.position) specialgraphicsPropertyUtils.updatePosition(authorParent, authtextProperty.position);
        if (authtextProperty.positionvalue) authorParent.style.position = authtextProperty.positionvalue;
        if (authtextProperty.padding) specialgraphicsPropertyUtils.updatePadding(authtextProperty.padding, authorParent);
        if (authtextProperty.margin) specialgraphicsPropertyUtils.updateMargin(authtextProperty.margin, authorParent);
        if (authtextProperty.primaryclass) this.specialGraphicsUtils.applyClassNamesFromString(sgAuthorNameNode, authtextProperty.primaryclass);
        if (authtextProperty.secondaryclass) this.specialGraphicsUtils.applyClassNamesFromString(sgAuthorDesignationNode, authtextProperty.secondaryclass);

        let authNameColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "name", authtextProperty.authnamecolor);
        let authDesiginationColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "designation", authtextProperty.authdesiginationcolor);
        // if (!authNameColor && authtextProperty.authnamecolor) authNameColor = "rgba(var(--" + authtextProperty.authnamecolor + "-color-rgb),1)";
        // if (!authDesiginationColor && authtextProperty.authdesiginationcolor) authDesiginationColor = "rgba(var(--" + authtextProperty.authdesiginationcolor + "-color-rgb),1)";

        if (authNameColor) {
            assetParent.style.setProperty("--authNameColor", authNameColor);
            if (sgAuthorNameNode) sgAuthorNameNode.setAttribute("data-color", authNameColor);
        }
        if (authDesiginationColor) {
            assetParent.style.setProperty("--authDesiginationColor", authDesiginationColor);
            if (sgAuthorDesignationNode) sgAuthorDesignationNode.setAttribute("data-color", authDesiginationColor);
        }
        if (authtextProperty.authnamebgcolor) assetParent.style.setProperty("--authNameBgColor", "rgba(var(--" + authtextProperty.authnamebgcolor + "-color-rgb),1)");
        if (authtextProperty.authdesiginationbgcolor) assetParent.style.setProperty("--authDesiginationBgColor", "rgba(var(--" + authtextProperty.authdesiginationbgcolor + "-color-rgb),1)");
        if (authtextProperty.authnameopacity) assetParent.style.setProperty("--authNameOpacity", authtextProperty.authnameopacity);
        if (authtextProperty.authdesiginationopacity) assetParent.style.setProperty("--authDesiginationOpacity", authtextProperty.authdesiginationopacity);
        if (authtextProperty.authnamepadding) specialgraphicsPropertyUtils.updatePadding(authtextProperty.authnamepadding, sgAuthorNameNode);
        if (authtextProperty.authdesiginationpadding) specialgraphicsPropertyUtils.updatePadding(authtextProperty.authdesiginationpadding, sgAuthorDesignationNode);
        if (authtextProperty.bgstyle) authorParent.classList.add(authtextProperty.bgstyle);
        if (authtextProperty.maxheight) authorParent.style.maxHeight = authtextProperty.maxheight + (authtextProperty.maxheight.includes("%") || authtextProperty.maxheight.includes("px") ? "" : "px");
        if (authtextProperty.valign) {
            let alignData = authtextProperty.valign;
            let vAlign = alignData == "bottom" || alignData == "end" ? "flex-end" : alignData == "center" || alignData == "middle" ? "center" : "flex-start";
            authorParent.style.alignItems = vAlign;
        }
        if (authtextProperty.halign) {
            let hAlign = authtextProperty.halign == "end" || authtextProperty.halign == "right" ? "flex-end" : authtextProperty.halign == "center" ? "center" : "flex-start";
            authorParent.style.justifyContent = hAlign;
            let textAlign = hAlign.includes("end") ? "end" : hAlign.includes("center") ? "center" : "start";
            assetParent.style.setProperty("--authTextAlign", textAlign);
        }
        if (this.applyContrastToText) {
            this.applyContrastToText(sgAuthorNameNode, authtextProperty);
            this.applyContrastToText(sgAuthorDesignationNode, authtextProperty);
        }
    }
};
SGBaseClass.prototype.updateAgendaLink = function (strSlideID, linkSlide, elementID, value = true, dummyDIv, newIndex = -1, newElement) {
    let linkedElement = this.sgParent.querySelector("[id='" + elementID + "']");
    let nodeIndex = 0;
    if (this.getTargetElement) linkedElement = this.getTargetElement(elementID);
    if (newElement) linkedElement = newElement;
    if (this.getCurrentIndex) nodeIndex = this.getCurrentIndex() - 1;
    if (newIndex != -1) nodeIndex = newIndex;
    if (linkedElement && linkedElement.id.includes("coverParent")) linkedElement = linkedElement.parentElement;
    if (linkedElement && linkedElement.id.includes("imageHolder")) linkedElement = this.sgParent.querySelector("[id*='coverImageParent']");
    if (linkedElement && linkSlide != null && linkSlide != undefined) {
        linkSlide = !linkSlide.includes("http") && linkSlide.includes(".") ? "https://" + linkSlide : linkSlide;
        // linkSlide = linkSlide.includes("http") ? linkSlide : "https://" + linkSlide;
        if (value != true) linkedElement.removeAttribute("data-navigate-to-slide-on-click");
        else linkedElement.setAttribute("data-navigate-to-slide-on-click", linkSlide);

        if (dummyDIv && dummyDIv.getElementsByTagName("node-" + nodeIndex).length > 0) {
            let node = dummyDIv.getElementsByTagName("node-" + nodeIndex);
            let id = linkedElement.id.toLocaleLowerCase();
            let tagName = id.includes("coverimageparent1") ? "coverimage1" : id.includes("coverimage") ? "coverimage" : "ctabutton";
            let linkedNode = node[0].getElementsByTagName(tagName);
            if (linkedNode.length > 0) linkedNode[0].setAttribute("data-navigateurl", value != true ? "" : linkSlide);
        }
    }
};
// SGBaseClass.prototype.applyContrastOnMapTypeChange = function (imageNode) {
//     if (!imageNode || (imageNode && !imageNode.hasAttribute("contrast"))) return null;
//     if (imageNode.getAttribute("contrast") == "fullbg") this.eventManager.dispatch("applyImageContrast", imageNode, this.assetParent);
//     else if (imageNode.getAttribute("contrast") == "halfbg") this.eventManager.dispatch("applyImageContrast", sgMapNode, this.assetParent, true);
// };
// SGBaseClass.prototype.getMapLink = function (imageNode, width = 300, height = 300, strText = "", type = "", mapZoom = "12") {
//     if (!imageNode) return;
//     let mapPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.mapproperties ? this.objDataToSG.sgMoodsData.mapproperties : null;
//     if (type == "") type = mapPropFromMood && mapPropFromMood.mapstyle ? mapPropFromMood.mapstyle : "roadmap";

//     let newW = parseInt(width);
//     let newH = parseInt(height);
//     let scaleValue = 1;
//     if (newW > 640 || newH > 640) {
//         newW = parseInt(newW / 2);
//         newH = parseInt(newH / 2);
//         scaleValue = 2;
//     }
//     if (!strText || strText == "") strText = "Bangalore";
//     mapZoom = parseInt(mapZoom) <= 10 ? 10 : parseInt(mapZoom) >= 22 ? 22 : mapZoom;
//     let base = "https://maps.googleapis.com/maps/api/staticmap?";
//     // let key = "&key=AIzaSyB41DRUbKWJHPxaFjMAwdrzWzbVKartNGg";
//     // let key = "&key=AIzaSyAiZSxdEWqO-nwFN2I_dH8KWjZoB4ZFPK0";
//     let key = "&key=AIzaSyC--w8mnd796xvGswWeG0RbHYwg8iQi538";
//     let place = "center=" + encodeURIComponent(strText);
//     let size = "&size=" + newW + "x" + newH;
//     let scale = "&scale=" + scaleValue;
//     let zoom = "&zoom=" + mapZoom;
//     let maptype = "&maptype=" + type; //roadmap, satellite, terrain, hybrid
//     let language = "&language=en";
//     let marker = "&markers=size:small%7Ccolor:red|" + encodeURIComponent(strText);
//     let iconMarker = "&markers=icon:" + "https://goo.gl/5y3S82%7CCanberra+ACT";
//     let lightTheme =
//         "&style=element:geometry|color:0xf5f5f5&style=element:labels.icon|visibility:off&style=element:labels.text.fill|color:0x616161&style=element:labels.text.stroke|color:0xf5f5f5&style=feature:administrative.land_parcel|element:labels.text.fill|color:0xbdbdbd&style=feature:poi|element:geometry|color:0xeeeeee&style=feature:poi|element:labels.text.fill|color:0x757575&style=feature:poi.park|element:geometry|color:0xe5e5e5&style=feature:poi.park|element:labels.text.fill|color:0x9e9e9e&style=feature:road|element:geometry|color:0xffffff&style=feature:road.arterial|element:labels.text.fill|color:0x757575&style=feature:road.highway|element:geometry|color:0xdadada&style=feature:road.highway|element:labels.text.fill|color:0x616161&style=feature:road.local|element:labels.text.fill|color:0x9e9e9e&style=feature:transit.line|element:geometry|color:0xe5e5e5&style=feature:transit.station|element:geometry|color:0xeeeeee&style=feature:water|element:geometry|color:0xc9c9c9&style=feature:water|element:labels.text.fill|color:0x9e9e9e";
//     let darkTheme =
//         "&style=element:geometry|color:0x212121&style=element:labels.icon|visibility:off&style=element:labels.text.fill|color:0x757575&style=element:labels.text.stroke|color:0x212121&style=feature:administrative|element:geometry|color:0x757575&style=feature:administrative.country|element:labels.text.fill|color:0x9e9e9e&style=feature:administrative.land_parcel|visibility:off&style=feature:administrative.locality|element:labels.text.fill|color:0xbdbdbd&style=feature:poi|element:labels.text.fill|color:0x757575&style=feature:poi.park|element:geometry|color:0x181818&style=feature:poi.park|element:labels.text.fill|color:0x616161&style=feature:poi.park|element:labels.text.stroke|color:0x1b1b1b&style=feature:road|element:geometry.fill|color:0x2c2c2c&style=feature:road|element:labels.text.fill|color:0x8a8a8a&style=feature:road.arterial|element:geometry|color:0x373737&style=feature:road.highway|element:geometry|color:0x3c3c3c&style=feature:road.highway.controlled_access|element:geometry|color:0x4e4e4e&style=feature:road.local|element:labels.text.fill|color:0x616161&style=feature:transit|element:labels.text.fill|color:0x757575&style=feature:water|element:geometry|color:0x000000&style=feature:water|element:labels.text.fill|color:0x3d3d3d";
//     let retroTheme =
//         "&style=element:geometry|color:0xebe3cd&style=element:labels.text.fill|color:0x523735&style=element:labels.text.stroke|color:0xf5f1e6&style=feature:administrative|element:geometry.stroke|color:0xc9b2a6&style=feature:administrative.land_parcel|element:geometry.stroke|color:0xdcd2be&style=feature:administrative.land_parcel|element:labels.text.fill|color:0xae9e90&style=feature:landscape.natural|element:geometry|color:0xdfd2ae&style=feature:poi|element:geometry|color:0xdfd2ae&style=feature:poi|element:labels.text.fill|color:0x93817c&style=feature:poi.park|element:geometry.fill|color:0xa5b076&style=feature:poi.park|element:labels.text.fill|color:0x447530&style=feature:road|element:geometry|color:0xf5f1e6&style=feature:road.arterial|element:geometry|color:0xfdfcf8&style=feature:road.highway|element:geometry|color:0xf8c967&style=feature:road.highway|element:geometry.stroke|color:0xe9bc62&style=feature:road.highway.controlled_access|element:geometry|color:0xe98d58&style=feature:road.highway.controlled_access|element:geometry.stroke|color:0xdb8555&style=feature:road.local|element:labels.text.fill|color:0x806b63&style=feature:transit.line|element:geometry|color:0xdfd2ae&style=feature:transit.line|element:labels.text.fill|color:0x8f7d77&style=feature:transit.line|element:labels.text.stroke|color:0xebe3cd&style=feature:transit.station|element:geometry|color:0xdfd2ae&style=feature:water|element:geometry.fill|color:0xb9d3c2&style=feature:water|element:labels.text.fill|color:0x92998d";

//     let finalMapType = type == "light" ? lightTheme : type == "dark" ? darkTheme : type == "retro" ? retroTheme : maptype;
//     let finalURL = base + place + key + size + scale + zoom + language + marker + finalMapType;
//     console.log("SG - finalURL - " + finalURL);
//     imageNode.src = finalURL;

//     this.specialGraphicsUtils.updateImageReSize(width, height, imageNode);

//     let slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
//     if (slideDomContentGroup && slideDomContentGroup.getElementsByTagName("node-0").length > 0) {
//         let node = slideDomContentGroup.getElementsByTagName("node-0");
//         let mapNode = node[0].getElementsByTagName("map");
//         if (mapNode.length > 0) mapNode[0].setAttribute("data-mapurl", finalURL);
//     }
// };

//Adding a cta social icon node from operation
SGBaseClass.prototype.addSocialNodeItem = function (type = "", newIndex, showAlertMesage = true, primaryData, secondaryData) {
    let ctaSocialParent = this.sgParent.querySelector("[id='ctaSocialParent']");
    if (ctaSocialParent) {
        let ctaSocialInnerParent = this.sgParent.querySelector("[id='ctaSocialInnerParent']");
        let finalHeight = parseInt(ctaSocialParent.getAttribute("finalHeight"));
        let finalWidth = parseInt(ctaSocialParent.getAttribute("finalWidth"));

        // if (type == "address" && ctaSocialInnerParent.querySelectorAll("[data-socialtype='address']").length > 0) {
        //     if (this.showAlert && showAlertMesage) this.showAlert("", "Already address added! Only one address will support.");
        //     return;
        // }
        let props = this.getPropertyData();

        let index = newIndex ? newIndex : parseInt(ctaSocialInnerParent.lastChild.id.replace("ctaSocialNodeParent", "")) + 1;
        let addedItem = this.createSocialIconNodeBase(ctaSocialInnerParent, index, type, primaryData, secondaryData);
        if (ctaSocialInnerParent.getAttribute("data-gridcount") == "1") {
            let propsCount = props.socialicons.gridcount ? props.socialicons.gridcount : 1;
            ctaSocialInnerParent.setAttribute("data-gridcount", propsCount);
            ctaSocialInnerParent.style.setProperty("--gridCount", propsCount);
        }

        if (ctaSocialInnerParent.children.length > 12) {
            if (this.showAlert && showAlertMesage) this.showAlert("", "Maximum number reached.");
            addedItem.parentElement.removeChild(addedItem);
        }
        if (props && props.socialicons && showAlertMesage == false) {
            if (!props.socialicons.class) props.socialicons.class = "ctasocial_type1";
            if (props.socialicons.class) {
                addedItem.classList.remove(props.socialicons.class);
                addedItem.classList.add(props.socialicons.class);
            }
            // }
            // if (props && props.socialicons) {
            let socialProp = props.socialicons;
            if (socialProp.globalstyle) {
                addedItem.classList.remove("clsSingleColorParent");
                addedItem.classList.add("clsSingleColorParent");
                this.specialGraphicsUtils.applyClassNamesFromString(addedItem, socialProp.globalstyle);

                let percentValue = window.getComputedStyle(addedItem).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
                percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
                let sourceNode = addedItem.querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
                if (sourceNode) addedItem.style.setProperty("--customNodeBorderWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
            }
            if (!socialProp.aligntype) socialProp.aligntype = "vertical";
            if (socialProp.aligntype && ctaSocialInnerParent) ctaSocialInnerParent.classList.add("ctasocial" + socialProp.aligntype);
            let specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL, this);
            specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
            if (socialProp.position) specialgraphicsPropertyUtils.updatePosition(ctaSocialParent, socialProp.position);
            if (socialProp.maxheight) ctaSocialParent.style.maxHeight = socialProp.maxheight + (socialProp.maxheight.includes("px") || socialProp.maxheight.includes("%") ? "" : "px");
            if (socialProp.iconnodesize) {
                let arrValues = this.specialGraphicsUtils.isJson(socialProp.iconnodesize) ? socialProp.iconnodesize : JSON.stringify(socialProp.iconnodesize);
                if (arrValues) {
                    ctaSocialParent.setAttribute("iconnodesizearray", arrValues);
                    this.setSocialIconsSize();
                }
            }
            let primaryNode = addedItem.querySelector("[id*='ctaSocialNodeHeadingText']");
            let secondaryNode = addedItem.querySelector("[id*='ctaSocialNodeContentText']");
            if (primaryNode && secondaryNode) {
                this.applyContrastToText(primaryNode, socialProp);
                this.applyContrastToText(secondaryNode, socialProp);
                if (socialProp.primaryclass) this.specialGraphicsUtils.applyClassNamesFromString(primaryNode, socialProp.primaryclass);
                if (socialProp.secondaryclass) this.specialGraphicsUtils.applyClassNamesFromString(secondaryNode, socialProp.secondaryclass);
            }
            this.setSocialIconsNodeGap();
            this.setSocialIconsMaxWidth();
            this.setSocialIconsMinWidth();
        }
        if (!newIndex && ctaSocialInnerParent.children[0]) {
            let oldChildNode = ctaSocialInnerParent.children[0];
            addedItem.className = oldChildNode.className;
            addedItem.style.setProperty("--customNodeBorderWidth", oldChildNode.style.getPropertyValue("--customNodeBorderWidth").trim());
            addedItem.style.setProperty("--ctaSocialNodeGap", oldChildNode.style.getPropertyValue("--ctaSocialNodeGap").trim());
            let oldCtaSocialNodeContentText = oldChildNode.querySelector("[id*='ctaSocialNodeContentText']");
            let newCtaSocialNodeContentText = addedItem.querySelector("[id*='ctaSocialNodeContentText']");
            let newCtaSocialNodeHeadingText = addedItem.querySelector("[id*='ctaSocialNodeHeadingText']");
            if (oldCtaSocialNodeContentText && newCtaSocialNodeHeadingText && newCtaSocialNodeContentText) {
                newCtaSocialNodeContentText.setAttribute("data-supportcontrast", oldCtaSocialNodeContentText.getAttribute("data-supportcontrast") || "false");
                newCtaSocialNodeHeadingText.setAttribute("data-supportcontrast", oldCtaSocialNodeContentText.getAttribute("data-supportcontrast") || "false");
            }
        }
        let childHeight = ctaSocialInnerParent.scrollHeight;
        let childWidth = ctaSocialInnerParent.scrollWidth;
        finalHeight = ctaSocialInnerParent.offsetHeight;
        finalWidth = ctaSocialInnerParent.offsetWidth;

        let parentNode = ctaSocialParent.parentElement;
        let totalH = 0;
        for (let d = 0; d < parentNode.children.length; d++) {
            if (parentNode.children[d].style.position != "absolute" && window.getComputedStyle(parentNode.children[d]).position != "absolute") totalH = totalH + parentNode.children[d].offsetHeight;
        }
        if (totalH > parentNode.offsetHeight && totalH - 1 != parentNode.offsetHeight) childHeight = 10000;

        // console.log("finalHeight - " + finalHeight + "   -  finalWidth - " + finalWidth);
        // console.log("childHeight - " + childHeight + "   -  childWidth - " + childWidth);
        if (childHeight > finalHeight || childWidth > finalWidth) {
            addedItem.parentElement.removeChild(addedItem);

            let slideParent = this.slideContent ? this.slideContent : this.sgParent.parentElement.parentElement;
            let sgDomDataNodes = slideParent ? slideParent.querySelector("[id='AESpecialGraphics']").children : null;
            if (sgDomDataNodes && sgDomDataNodes.length > 0 && sgDomDataNodes[0].children.length > 0) {
                let socialIconNode = sgDomDataNodes[0].getElementsByTagName("socialicon" + (parseInt(index) + 1));
                let socialIconNodeSec = sgDomDataNodes[0].getElementsByTagName("socialicon" + (parseInt(index) + 1) + "secondary");
                if (socialIconNode && socialIconNode[0]) {
                    socialIconNode[0].removeAttribute("data-text");
                    socialIconNode[0].removeAttribute("data-primary");
                    socialIconNode[0].removeAttribute("data-secondary");
                }
                if (socialIconNodeSec && socialIconNodeSec[0]) socialIconNodeSec[0].parentElement.removeChild(socialIconNodeSec[0]);
            }

            if (this.showAlert && showAlertMesage) this.showAlert("Unable to add Node!", "There is not enough space to add more nodes.");
        } else if (type) {
            if (props.socialicons && (!props.socialicons.hideicon || (props.socialicons.hideicon != undefined && props.socialicons.hideicon != "true" && props.socialicons.hideicon != true))) {
                let arrAssets = [];
                arrAssets.push({ type: "svg", url: this.appStaticURL + "genericassets/socialicons/" + type + ".svg", id: "sgIconHolder" + index });
                if (!newIndex) this.loadAssets(arrAssets, this.assetsLoadComplete, this.assetError);
                this.arrCommonAssets.push({ array: arrAssets, callback: this.assetsLoadComplete });
            }
            let primaryNode = addedItem.querySelector("[id*='ctaSocialNodeHeadingText']");
            let secondaryNode = addedItem.querySelector("[id*='ctaSocialNodeContentText']");
            if (primaryNode && secondaryNode) {
                if (props.socialicons.primaryclass) this.specialGraphicsUtils.applyClassNamesFromString(primaryNode, props.socialicons.primaryclass);
                if (props.socialicons.secondaryclass) this.specialGraphicsUtils.applyClassNamesFromString(secondaryNode, props.socialicons.secondaryclass);
            }
            addedItem.setAttribute("data-socialtype", type);
            let slideParent = this.slideContent ? this.slideContent : this.sgParent.parentElement.parentElement;
            let sgDomDataNodes = slideParent ? slideParent.querySelector("[id='AESpecialGraphics']").children : null;
            if (sgDomDataNodes && sgDomDataNodes.length > 0 && sgDomDataNodes[0].children.length > 0) {
                let socialIconNode = sgDomDataNodes[0].getElementsByTagName("socialicon" + (parseInt(index) + 1));
                if (socialIconNode && socialIconNode[0]) socialIconNode[0].setAttribute("data-socialtype", type);
            }
            let lastNode = addedItem?.parentElement?.firstChild;
            if (lastNode?.querySelector("[id*='sgIconParent']") && addedItem.querySelector("[id*='sgIconParent']")) {
                let iconNode = lastNode.querySelector("[id*='sgIconParent']");
                let addedIconNode = addedItem.querySelector("[id*='sgIconParent']");
                addedIconNode.style.setProperty("display", iconNode.style.display);
                addedIconNode.style.setProperty("display", iconNode.style.display);
            }
            this.setSocialIconsSize();
            this.setSocialIconsNodeGap();
            this.setSocialIconsMaxWidth();
            this.setSocialIconsMinWidth();
        }
    }
};
//Deleting a cta social icon node from operation
SGBaseClass.prototype.deleteSocialNodeItem = function (elementId) {
    let ctaSocialParent = this.sgParent.querySelector("[id='ctaSocialParent']");
    let element = ctaSocialParent.querySelector("[id='" + elementId + "']");
    if (!element) element = ctaSocialParent.querySelector("[data-socialtype='" + elementId + "']");
    if (ctaSocialParent && element) {
        element.parentElement.removeChild(element);
        this.setSocialIconsSize();
        this.setSocialIconsNodeGap();
        this.setSocialIconsMaxWidth();
        this.setSocialIconsMinWidth();
        this.reArrangeSocialNodeItem();
    }
};
SGBaseClass.prototype.reArrangeSocialNodeItem = function () {
    let ctaSocialParent = this.sgParent.querySelector("[id='ctaSocialParent']");
    if (ctaSocialParent) {
        let arrNodes = ctaSocialParent.querySelectorAll("[id*='ctaSocialNodeParent']");
        let slideParent = this.slideContent ? this.slideContent : this.sgParent.parentElement.parentElement;
        let sgDomDataNodes = slideParent ? slideParent.querySelector("[id='AESpecialGraphics']").children : null;
        let hasAESpecialgraphicsNode = sgDomDataNodes && sgDomDataNodes.length > 0 && sgDomDataNodes[0].children.length > 0;
        for (let c = 0; c < 12; c++) {
            let primaryText = "";
            let secondaryText = "";
            let socialType = "";
            let hasNode = false;
            if (arrNodes[c]) {
                hasNode = true;
                let sgIconParent = arrNodes[c].querySelector("[id*='sgIconParent']");
                let sgIconHolder = arrNodes[c].querySelector("[id*='sgIconHolder']");
                let socialLine = arrNodes[c].querySelector("[id*='socialLine']");
                let primaryNode = arrNodes[c].querySelector("[id*='ctaSocialNodeHeadingText']");
                let secondaryNode = arrNodes[c].querySelector("[id*='ctaSocialNodeContentText']");
                arrNodes[c].id = "ctaSocialNodeParent" + c;
                sgIconParent.id = "sgIconParent" + c;
                sgIconHolder.id = "sgIconHolder" + c;
                socialLine.id = "socialLine" + c;
                primaryNode.id = "ctaSocialNodeHeadingText" + c;
                secondaryNode.id = "ctaSocialNodeContentText" + c;
                primaryText = primaryNode.innerText;
                secondaryText = secondaryNode.innerText;
                socialType = arrNodes[c].getAttribute("data-socialtype");
                primaryNode.setAttribute("data-cssslide", "slide0socialicon" + c);
                secondaryNode.setAttribute("data-cssslide", "slide0socialicon" + c);
            }
            if (hasAESpecialgraphicsNode) {
                let socialIconNode = sgDomDataNodes[0].getElementsByTagName("socialicon" + (c + 1));
                let socialIconSecondary = sgDomDataNodes[0].getElementsByTagName("socialicon" + (c + 1) + "secondary");
                let socialIconType = sgDomDataNodes[0].getElementsByTagName("socialicon" + (c + 1) + "socialtype");
                if (socialIconNode && socialIconNode[0]) {
                    socialIconNode[0].removeAttribute("data-text");
                    if (primaryText) socialIconNode[0].setAttribute("data-primary", primaryText);
                    else socialIconNode[0].removeAttribute("data-primary");
                    if (secondaryText) {
                        socialIconNode[0].setAttribute("data-secondary", secondaryText);
                        if (socialIconSecondary.length > 0) {
                            socialIconSecondary[0].setAttribute("data-text", secondaryText);
                            socialIconSecondary[0].setAttribute("data-secondary", secondaryText);
                        }
                    } else {
                        socialIconNode[0].removeAttribute("data-secondary");
                        if (socialIconSecondary.length > 0) socialIconSecondary[0].parentElement.removeChild(socialIconSecondary[0]);
                    }
                    if (socialType) {
                        socialIconNode[0].setAttribute("data-socialtype", socialType);
                        if (socialIconType.length > 0) {
                            socialIconType[0].setAttribute("data-text", socialType);
                            socialIconType[0].setAttribute("data-socialtype", socialType);
                        }
                    } else {
                        socialIconNode[0].removeAttribute("data-socialtype");
                        if (socialIconType.length > 0) socialIconType[0].parentElement.removeChild(socialIconType[0]);
                    }
                    if (this.sgData[0]["socialicon" + (c + 1)] != null && this.sgData[0]["socialicon" + (c + 1)] != undefined) {
                        if (primaryText) this.sgData[0]["socialicon" + (c + 1) + "primary"] = primaryText;
                        else delete this.sgData[0]["socialicon" + (c + 1) + "primary"];
                        if (secondaryText) this.sgData[0]["socialicon" + (c + 1) + "secondary"] = secondaryText;
                        else delete this.sgData[0]["socialicon" + (c + 1) + "secondary"];
                        if (socialType) this.sgData[0]["socialicon" + (c + 1) + "socialtype"] = socialType;
                        else delete this.sgData[0]["socialicon" + (c + 1) + "socialtype"];
                    }
                }
            }
        }
    }
};
SGBaseClass.prototype.applySingleNodesProperties = function (propData, idData, propNameData, assetParent) {
    let specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL);
    specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
    let elementNode = this.sgParent.querySelector("[id='sg" + idData + "Node']");
    let elementparentNode = this.sgParent.querySelector("[id='sg" + idData + "ParentNode']");
    if (propData && elementNode && elementparentNode) {
        if (propData.position) specialgraphicsPropertyUtils.updatePosition(elementparentNode, propData.position);
        elementparentNode.style.maxWidth = elementparentNode.style.width;
        elementparentNode.style.width = "auto";
        if (propData.parentclass) this.specialGraphicsUtils.applyClassNamesFromString(elementparentNode, propData.parentclass);
        if (propData.class) this.specialGraphicsUtils.applyClassNamesFromString(elementNode, propData.class);
        else elementNode.style.color = "rgba(var(--secondary-color-rgb), 1)";
        if (propData.halign) {
            let align = propData.halign == "right" || propData.halign == "end" ? "end" : propData.halign == "center" ? "center" : "start";
            assetParent.style.setProperty("--" + propNameData + "Align", align);
            let halign = align == "end" ? "flex-end" : align == "center" ? "center" : "flex-start";
            assetParent.style.setProperty("--" + propNameData + "HAlign", halign);
        }
        if (propData.valign) {
            let vAlign = propData.valign;
            let align = vAlign == "bottom" || vAlign == "end" ? "flex-end" : vAlign == "center" || vAlign == "middle" ? "center" : "flex-start";
            elementNode.style.alignItems = align;
            elementparentNode.style.alignItems = align;
        }
        if (propData.margin) specialgraphicsPropertyUtils.updateMargin(propData.margin, elementparentNode);
        if (propData.padding) specialgraphicsPropertyUtils.updatePadding(propData.padding, elementparentNode);

        let colorPref = idData == "PresentedBy" || idData == "PresentedTo" ? "designation" : "heading";
        let colorValue = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, colorPref, propData.color);
        if (colorValue) {
            // assetParent.style.setProperty("--" + propNameData + "Color", colorValue);
            elementNode.style.color = colorValue;
            elementNode.setAttribute("data-color", colorValue);
        }

        if (propData.bgcolor) assetParent.style.setProperty("--" + propNameData + "BgColor", "rgba(var(--" + propData.bgcolor + "-color-rgb),1)");
        if (propData.zorder) assetParent.style.setProperty("--" + propNameData + "ZIndex", propData.zorder);
        if (propData.positionvalue) elementparentNode.style.position = propData.positionvalue;
        if (propData.opacity) elementNode.style.opacity = propData.opacity;
        if (propData.prompt) elementNode.setAttribute("data-prompt-text", propData.prompt);
        if (propData.globalstyle) {
            elementparentNode.classList.remove("clsHorButton");
            this.specialGraphicsUtils.applyClassNamesFromString(elementparentNode, propData.globalstyle);
            elementparentNode.classList.add("clsSingleColorParent");
        }
        this.specialGraphicsUtils.setOpacityAttribute(elementNode);
        this.applyContrastToText(elementNode, propData);
    }
};

//Deleting a cta social icon node from operation
SGBaseClass.prototype.deleteSpeakerItem = function (elementId, isUndo = false) {
    let speakerParent = this.sgParent.querySelector("[id='speakerParent']");
    let element = speakerParent.querySelector("[id='" + elementId + "']");
    if (speakerParent && element) {
        element.parentElement.removeChild(element);
        if (!isUndo) {
            this.reArrangeSpeakerNodeItem();
            this.speakerImageSizeUpdate();
            this.arrNodeGapForSpeaker();
            this.speakerTextMinWidthCalculations();
            this.doSpeakerFontFit();
        }
    }
};
SGBaseClass.prototype.reArrangeSpeakerNodeItem = function () {
    let ctaSocialParent = this.sgParent.querySelector("[id='speakerParent']");
    if (ctaSocialParent) {
        let arrNodes = ctaSocialParent.querySelectorAll("[id*='speakerNodeGroup']");
        let slideParent = this.slideContent ? this.slideContent : this.sgParent.parentElement.parentElement;
        let sgDomDataNodes = slideParent ? slideParent.querySelector("[id='AESpecialGraphics']").children : null;
        let hasAESpecialgraphicsNode = sgDomDataNodes && sgDomDataNodes.length > 0 && sgDomDataNodes[0].children.length > 0;
        for (let c = 0; c < 6; c++) {
            let primaryText = "";
            let secondaryText = "";
            let src = "";
            let ind = c + 1;
            if (arrNodes[c]) {
                arrNodes[c].id = "speakerNodeGroup" + ind;
                arrNodes[c].setAttribute("speakername", "speakernode" + ind);

                let speakerTextGroup = arrNodes[c].querySelector("[id*='speakerTextGroup']");
                let primaryparetNode = arrNodes[c].querySelector("[id*='sgSpeakerPrimaryParent']");
                let primaryNode = primaryparetNode.querySelector("[id*='sgSpeakerPrimary']");
                let secondaryParentNode = arrNodes[c].querySelector("[id*='sgSpeakerSecondaryParent']");
                let secondaryNode = secondaryParentNode.querySelector("[id*='sgSpeakerSecondary']");
                let sgSpeakerImageNode = arrNodes[c].querySelector("[id*='sgSpeakerImageNode']");
                let speakerImageParent = arrNodes[c].querySelector("[id*='speakerImageParent']");
                let speakerContentParent = arrNodes[c].querySelector("[id*='speakerContentParent']");
                speakerTextGroup.id = "speakerTextGroup" + ind;
                primaryparetNode.id = "sgSpeakerPrimaryParent" + ind;
                primaryNode.id = "sgSpeakerPrimary" + ind;
                secondaryParentNode.id = "sgSpeakerSecondaryParent" + ind;
                secondaryNode.id = "sgSpeakerSecondary" + ind;
                sgSpeakerImageNode.id = "sgSpeakerImageNode" + ind;
                speakerImageParent.id = "speakerImageParent" + ind;
                speakerContentParent.id = "speakerContentParent" + ind;

                primaryText = primaryNode.innerText;
                secondaryText = secondaryNode.innerText;
                src = sgSpeakerImageNode.src;
            }
            if (hasAESpecialgraphicsNode) {
                let speakerPrimary = sgDomDataNodes[0].getElementsByTagName("speakerprimary" + ind);
                let speakerSecondary = sgDomDataNodes[0].getElementsByTagName("speakersecondary" + ind);
                let speakerImage = sgDomDataNodes[0].getElementsByTagName("speakerimage" + ind);
                if (speakerPrimary.length > 0 && speakerSecondary.length > 0 && speakerImage.length > 0) {
                    speakerPrimary[0].setAttribute("data-text", primaryText);
                    speakerSecondary[0].setAttribute("data-text", secondaryText);
                    speakerImage[0].setAttribute("data-src", src);

                    this.sgData[0]["speakerprimary" + ind] = primaryText;
                    this.sgData[0]["speakersecondary" + ind] = secondaryText;
                    this.sgData[0]["speakerimage" + ind] = src;
                }
            }
        }
    }
};
SGBaseClass.prototype.addSpeakerItem = function (count, oldData) {
    let ctaSocialParent = this.sgParent.querySelector("[id='speakerParent']");
    if (ctaSocialParent) {
        let arrNodes = ctaSocialParent.querySelectorAll("[id*='speakerNodeGroup']");
        if (arrNodes.length != 4) {
            for (let a = 0; a < count; a++) {
                this.createSpeakerNodes(null, ctaSocialParent, oldData);
            }
            if (oldData) this.reArrangeSpeakerNodeItem();
            this.applySpeakerProps();
        }
    }
};
SGBaseClass.prototype.applySpeakerProps = function () {
    let props = this.metaData[this.designChange == true ? "properties2" : "properties"];
    if (props?.speaker && this.sgParent.querySelector("[id='speakerParent']")) {
        let speakerProps = props.speaker;
        let specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL);
        specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
        let speakerParent = this.sgParent.querySelector("[id='speakerParent']");
        if (speakerProps.position && speakerProps.position.split(",").length == 4) specialgraphicsPropertyUtils.updatePosition(speakerParent, speakerProps.position);
        if (speakerProps.positionvalue) speakerParent.style.position = speakerProps.positionvalue;
        if (speakerProps.zorder) speakerParent.style.zIndex = speakerProps.zorder;
        if (speakerProps.padding) specialgraphicsPropertyUtils.updatePadding(speakerProps.padding, speakerParent, true);
        if (speakerProps.margin) specialgraphicsPropertyUtils.updateMargin(speakerProps.margin, speakerParent);
        if (speakerProps.textgap) this.assetParent.style.setProperty("--speakerGap", speakerProps.textgap + (speakerProps.textgap.includes("px") ? "" : "px"));
        if (speakerProps.inbetweentextgap) this.assetParent.style.setProperty("--speakerTextGap", speakerProps.inbetweentextgap + (speakerProps.inbetweentextgap.includes("px") ? "" : "px"));
        if (speakerParent.style.height != "auto") speakerParent.setAttribute("parentFullHeight", window.getComputedStyle(speakerParent).height);

        if (speakerProps.aligntype) speakerParent.classList.add("speaker" + speakerProps.aligntype);
        if (!speakerProps.class) speakerProps.class = "speakertype1";
        if (speakerProps.class) {
            if (speakerProps.class.includes("textreverse")) speakerParent.classList.add(speakerProps.class.replace("textreverse", ""));
            speakerParent.classList.add(speakerProps.class);
        }
        if (speakerProps.halign) {
            let hAlign = speakerProps.halign == "right" || speakerProps.halign == "end" ? "flex-end" : speakerProps.halign == "center" || speakerProps.halign == "middle" ? "center" : "flex-start";
            this.assetParent.style.setProperty("--speakerHAlign", hAlign);
        }
        if (speakerProps.valign) {
            let vAlign = speakerProps.valign == "bottom" || speakerProps.valign == "end" ? "flex-end" : speakerProps.valign == "center" || speakerProps.valign == "middle" ? "center" : "flex-start";
            this.assetParent.style.setProperty("--speakerVAlign", vAlign);
        }
        if (speakerProps.contenthalign) {
            let contenthalign = speakerProps.contenthalign;
            let hAlign = contenthalign == "right" || contenthalign == "end" ? "flex-end" : contenthalign == "center" || contenthalign == "middle" ? "center" : "flex-start";
            let hAlignText = contenthalign == "right" || contenthalign == "end" ? "end" : contenthalign == "center" || contenthalign == "middle" ? "center" : "start";
            this.assetParent.style.setProperty("--speakerContentHAlign", hAlign);
            this.assetParent.style.setProperty("--speakerTextAlign", hAlignText);
        }
        if (speakerProps.contentvalign) {
            let contentvalign = speakerProps.contentvalign;
            let vAlign = contentvalign == "bottom" || contentvalign == "end" ? "flex-end" : contentvalign == "center" || contentvalign == "middle" ? "center" : "flex-start";
            this.assetParent.style.setProperty("--speakerContentVAlign", vAlign);
        }
        if (speakerProps.image) {
            if (speakerProps.image.globalstyle) {
                this.specialGraphicsUtils.applyClassNamesFromString(speakerParent, speakerProps.image.globalstyle);
                speakerParent.classList.add("clsSingleColorParent");
            }
            let arrSpeakerImageParent = speakerParent.querySelectorAll("[id*='speakerContentParent']");
            for (let a = 0; a < arrSpeakerImageParent.length; a++) {
                specialgraphicsPropertyUtils.applyImageBaseProps(speakerProps.image, this.assetParent, arrSpeakerImageParent[a], "--speaker");
                if (a == 0 && arrSpeakerImageParent.length > 0) {
                    this.assetParent.style.setProperty("--speakerHeight", arrSpeakerImageParent[0].style.height);
                    this.assetParent.style.setProperty("--speakerWidth", arrSpeakerImageParent[0].style.width);
                }
                arrSpeakerImageParent[a].style.removeProperty("width");
                arrSpeakerImageParent[a].style.removeProperty("height");
                if (speakerProps.image.contentBG) {
                    let arrAssets = [];
                    arrAssets.push({
                        parent: arrSpeakerImageParent[a],
                        type: "svg",
                        url: speakerProps.image.contentBG.value,
                        id: speakerProps.image.contentBG.id,
                        color: speakerProps.image.contentBG.color,
                    });
                    this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
                }
                if (speakerProps.image.globalstyle) {
                    let percentValue = window.getComputedStyle(arrSpeakerImageParent[a]).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
                    percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
                    let sourceNode = arrSpeakerImageParent[a].querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
                    if (sourceNode) arrSpeakerImageParent[a].style.setProperty("--customNodeBorderImageWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
                }
            }
            if (speakerProps.image.imagenodesize) {
                if (speakerProps.image.imagenodesize.length == 4) speakerParent.setAttribute("imagesize", JSON.stringify(speakerProps.image.imagenodesize));
                else if (JSON.parse(speakerProps.image.imagenodesize).length == 4) speakerParent.setAttribute("imagesize", speakerProps.image.imagenodesize);
            }
        }
        if (speakerProps.text) {
            let speakerTextProp = speakerProps.text;
            for (let b = 1; b < 5; b++) {
                let primaryNode = speakerParent.querySelector("[id='sgSpeakerPrimary" + b + "']");
                let secondaryNode = speakerParent.querySelector("[id='sgSpeakerSecondary" + b + "']");
                if (primaryNode) {
                    if (speakerTextProp.primaryopacity) primaryNode.style.opacity = speakerTextProp.primaryopacity;
                    if (speakerTextProp.primaryclass) this.specialGraphicsUtils.applyClassNamesFromString(primaryNode, speakerTextProp.primaryclass);
                    if (speakerTextProp.contrast) this.applyContrastToText(primaryNode, speakerTextProp);

                    let colorValue = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "name", speakerTextProp.primarycolor);
                    if (colorValue) {
                        primaryNode.style.color = colorValue;
                        primaryNode.setAttribute("data-color", colorValue);
                    }

                    this.specialGraphicsUtils.setOpacityAttribute(primaryNode);
                }
                if (secondaryNode) {
                    if (speakerTextProp.secondaryopacity) secondaryNode.style.opacity = speakerTextProp.secondaryopacity;
                    if (speakerTextProp.secondaryclass) this.specialGraphicsUtils.applyClassNamesFromString(secondaryNode, speakerTextProp.secondaryclass);
                    if (speakerTextProp.contrast) this.applyContrastToText(secondaryNode, speakerTextProp);

                    let colorValue = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "designation", speakerTextProp.secondarycolor);
                    if (colorValue) {
                        secondaryNode.style.color = colorValue;
                        secondaryNode.setAttribute("data-color", colorValue);
                    }

                    this.specialGraphicsUtils.setOpacityAttribute(secondaryNode);
                }
            }
        }
        for (let c = 1; c < 5; c++) {
            let primaryNode = speakerParent.querySelector("[id='sgSpeakerPrimary" + c + "']");
            let secondaryNode = speakerParent.querySelector("[id='sgSpeakerSecondary" + c + "']");

            let speakerContentParent = speakerParent.querySelector("[id='speakerContentParent" + c + "']");

            let colorDiv = speakerContentParent?.querySelector("[id='speakerOverlayDiv" + c + "']");
            if (primaryNode) primaryNode.onTextChangeNode = this.onTextChangeUpdateSpeakerNode;
            if (secondaryNode) secondaryNode.onTextChangeNode = this.onTextChangeUpdateSpeakerNode;
            let speakerNodeGroup = speakerParent.querySelector("[id='speakerNodeGroup" + c + "']");
            let animationDIV = this.slideContent ? this.slideContent.querySelector("[id='animationDIV']") : this.sgParent.parentElement.parentElement;
            let variationName = animationDIV && animationDIV.hasAttribute("data-variation-name") ? animationDIV.getAttribute("data-variation-name") : "";
            if (variationName.includes("speakernode" + c)) speakerNodeGroup.style.display = "none";

            let tagWord = "speakerimage" + c;
            // Setting overlay enable/disable
            if (this.sgData[0] && colorDiv && this.sgData[0][tagWord + "overlayshow"]) {
                colorDiv.style.display = this.sgData[0][tagWord + "overlayshow"] == "true" ? "block" : "none";
                if (speakerContentParent && this.sgData[0][tagWord + "overlayshow"] == "true") speakerContentParent.setAttribute("data-isoverlay", "true");
            } else if (colorDiv) colorDiv.style.display = "none";

            // Setting overlay opacity
            if (this.sgData[0] && this.sgData[0][tagWord + "opacity"] && colorDiv) colorDiv.style.opacity = this.sgData[0][tagWord + "opacity"];
        }
        let arrNodes = this.sgParent.querySelector("[id*='speakerNodeGroup']");
        for (let a = 0; a < arrNodes.length; a++) {
            arrNodes[a].setAttribute("data-count", arrNodes.length);
        }

        this.speakerImageSizeUpdate();
        this.arrNodeGapForSpeaker();
        this.speakerTextMinWidthCalculations();
        this.doSpeakerFontFit();
    }
};

SGBaseClass.prototype.applyCommonBgProps = function (presetImageParent, commonImageNode, commonVideoNode, props, index = 0, assetParent) {
    let imageProps = props?.commonbg;
    if (imageProps && presetImageParent) {
        let specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL, this);
        specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
        if (imageProps.positionvalue) presetImageParent.style.position = imageProps.positionvalue;
        if (imageProps.globalstyle) {
            this.specialGraphicsUtils.applyClassNamesFromString(presetImageParent.parentElement, imageProps.globalstyle);
            presetImageParent.parentElement.classList.add("clsSingleColorParent");
        }
        if (imageProps.contrast && imageProps.contrast == "fullbg") {
            if (commonImageNode) {
                commonImageNode.setAttribute("contrast", "fullbg");
                this.eventManager.dispatch("applyImageContrast", commonImageNode, assetParent);
            }
        } else if (imageProps.contrast && imageProps.contrast == "halfbg") {
            if (commonImageNode) {
                commonImageNode.setAttribute("contrast", "halfbg");
                this.eventManager.dispatch("applyImageContrast", commonImageNode, assetParent, true);
            }
        } else if (this.slideContent) {
            this.slideContent.classList.remove("fixedlightText");
            this.slideContent.classList.remove("fixeddarkText");
        }
        if (imageProps.borderoption) presetImageParent.setAttribute("borderoption", imageProps.borderoption == "enable" ? "true" : "false");

        let videoContrast = this.sgData[index]?.commonbgcontrast ? this.sgData[index].commonbgcontrast : null;
        let contrast = videoContrast ? videoContrast : imageProps.fixedcontrast;
        if (contrast) {
            assetParent.classList.remove("darkText");
            assetParent.classList.remove("lightText");
            assetParent.classList.remove("fixedlightText");
            assetParent.classList.remove("fixeddarkText");
            assetParent.classList.add(contrast);
        }

        specialgraphicsPropertyUtils.applyImageBaseProps(imageProps, assetParent, presetImageParent, "--commonBg");
        presetImageParent.style.setProperty("--commonBgWidth", presetImageParent.style.width);
        presetImageParent.style.setProperty("--commonBgHeight", presetImageParent.style.height);

        if (commonImageNode) {
            commonImageNode.setAttribute("data-width", parseFloat(window.getComputedStyle(presetImageParent).width));
            commonImageNode.setAttribute("data-height", parseFloat(window.getComputedStyle(presetImageParent).height));
            commonImageNode.setAttribute("data-x", parseFloat(window.getComputedStyle(presetImageParent).left));
            commonImageNode.setAttribute("data-y", parseFloat(window.getComputedStyle(presetImageParent).top));
        }
        if (commonVideoNode) {
            commonVideoNode.setAttribute("data-width", parseFloat(window.getComputedStyle(presetImageParent).width));
            commonVideoNode.setAttribute("data-height", parseFloat(window.getComputedStyle(presetImageParent).height));
            commonVideoNode.setAttribute("data-x", parseFloat(window.getComputedStyle(presetImageParent).left));
            commonVideoNode.setAttribute("data-y", parseFloat(window.getComputedStyle(presetImageParent).top));
        }
        let menuJson = this.objDataToSG && this.objDataToSG.menufromjson ? this.objDataToSG.menufromjson : null;
        if (menuJson && menuJson.floateroptions && menuJson.floateroptions.includes("commonbgimagebleed") && presetImageParent) {
            presetImageParent.setAttribute("imagebleedoption", "true");
            if (!this.sgData[0]["commonbgimagebleed"] && menuJson.floateroptionsenable && menuJson.floateroptionsenable.includes("commonbgimagebleed")) {
                var slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
                if (slideDomContentGroup && slideDomContentGroup.getElementsByTagName(index == 0 ? "introdata" : "node-0").length > 0) {
                    let nodeData = slideDomContentGroup.getElementsByTagName(index == 0 ? "introdata" : "node-0")[0];
                    let nodeDataList = nodeData.getElementsByTagName("commonbg")[0];
                    if (nodeDataList) nodeDataList.setAttribute("imagebleed", "true");
                }
            }
        }
    }
};

"use strict";

function GenericCoverpage(sgParent, sgData = null, moodName = "simplecss", metadata, styleName = "", isPlayAnimation = true, textElementData = null, socialiconsData = null, fontData = null, objDataToSG) {
    this.specialGraphicsUtils = new window["SpecialGraphicsUtils"]();
    this.specialGraphicsAnimationUtils = new window["SpecialGraphicsAnimationUtils"]();
    this.assetsLoading = false;
    let styleData = {};

    let baseSet = {
        title: "h3",
        subtitle: "p2",
        label: "p2",
        creatorname: "h5",
        customername: "h5",
        desigination: "p4",
        customerdesignation: "p4",
        socialiconcontent: "p4",
        socialicontitle: "p4",
        referencetitle: "p4",
        referencecontent: "p4",
        number: "n1",
        address: "p3",
        addressprompt: "p2",
        authorname: "h5",
        authordesigination: "p4",
        venue: "p3",
        presentedto: "p3",
        venuetitle: "p3",
        websitelink: "p3",
        authortitle: "p3",
        datetitle: "p3",
        quotetitle: "h4",
        ctabutton: "p4",
        quotetakeaway: "p2",
        speakerprimary: "h5",
        speakersecondary: "p4",
    };
    baseSet = fontData ? fontData : baseSet;
    this.specialGraphicsUtils.getFontClass(baseSet, metadata, "cover");
    styleData.fontData = baseSet;
    this.fontData = JSON.parse(JSON.stringify(baseSet));

    this.sgParent = sgParent;
    this.sgSlideType = this.sgParent.dataset.slidetype;
    this.deviceStyle = objDataToSG && objDataToSG.deviceStyle ? objDataToSG.deviceStyle : "photographic";

    //Setting all coverpage nodes prompt text here
    styleData.titlePrompt = this.sgSlideType == "cta" ? "Type a Call to action" : this.sgSlideType == "sectionbreak" ? "Awesome Section Break" : this.sgSlideType == "quote" ? "Type an inspiring quote to start the presentation" : "Awesome Presentation Title";
    styleData.subTitlePrompt = "A small sentence which explains all about this presentation";
    styleData.titleLabelPrompt = "Title label here";
    styleData.venuePrompt = "Type something to add more info";
    styleData.presenterNamePrompt = "Presenter Name";
    styleData.presenterDesignationPrompt = "Presenter Designation";
    styleData.mailingAddressPrompt = "Enter Your Address";
    styleData.emailAddressPrompt = "Enter Your Email";
    styleData.websitePrompt = "Enter Your website";
    styleData.phoneNumberPrompt = "Enter Your Phone Number";
    styleData.referenceHeadPrompt = "Enter Reference Head";
    styleData.referencePrompt = "Enter Refrence URL";
    styleData.authorNamePrompt = "Author Name";
    styleData.authorDesignationPrompt = "Author Desigination";
    styleData.quoteTitlePrompt = "Click here to edit text";
    styleData.presentedToPrompt = "Presented To";
    styleData.presentedByPrompt = "Presented By";
    styleData.venueTitlePrompt = "Venue";
    styleData.websiteLinkPrompt = "Website";
    styleData.dateTitlePrompt = "Date";
    styleData.ctaButtonPrompt = "Call-to-action";
    styleData.authorTitlePrompt = "Author";
    styleData.presenterCompanyPrompt = "Presenter Company Name";
    styleData.customerCompanyPrompt = "Customer Company Name";
    styleData.footerPrompt = "Click here to edit footer";
    styleData.speakerPrimaryPrompt = "Name";
    styleData.speakerSecondaryPrompt = "Desigination";
    styleData.imagecaptionPrompt = "This is image caption text";

    if (objDataToSG && objDataToSG.category && objDataToSG.category == "title" && this.sgSlideType == "cta") styleData.titlePrompt = "Thank You";
    if (objDataToSG && objDataToSG.category && objDataToSG.category == "contact" && this.sgSlideType == "cta") styleData.titlePrompt = "Contact Us";
    if (objDataToSG && objDataToSG.category && objDataToSG.category == "socialicons" && this.sgSlideType == "cta") styleData.titlePrompt = "Call-To-Action";
    if (objDataToSG && objDataToSG.category && objDataToSG.category == "reference" && this.sgSlideType == "cta") styleData.titlePrompt = "Reference";

    styleData.styleName = styleName;

    this.socialiconsData = socialiconsData;
    // if (metadata && metadata.properties && metadata.properties.image && metadata.properties.image.supportsvg) styleData.isSVGAsset = metadata.properties.image.supportsvg;

    this.rotatationValue = "";
    if (sgParent && sgParent.dataset.moodrotate) this.rotatationValue = sgParent.dataset.moodrotate;

    sgParent.className = "genericcoverpage";
    this.isPlayAnimation = isPlayAnimation;
    this.slideContent = objDataToSG && objDataToSG.slide ? objDataToSG.slide : null;
    this.oldContent = objDataToSG && objDataToSG.isLoadedSlide ? objDataToSG.isLoadedSlide : null;
    if (this.slideContent) {
        this.slideContent.classList.remove("darkText");
        this.slideContent.classList.remove("lightText");
        this.slideContent.classList.remove("fixedlightText");
        this.slideContent.classList.remove("fixeddarkText");
    }
    this.assetsLoadComplete = this.assetsLoadComplete.bind(this);
    this.assetError = this.assetError.bind(this);
    this.onTextChange = this.onTextChange.bind(this);
    this.commonHeightFit = this.commonHeightFit.bind(this);
    this.logoCompleteCallback = this.logoCompleteCallback.bind(this);
    this.instanceCreateCallback = this.instanceCreateCallback.bind(this);
    this.logoGridUpdateLayout = this.logoGridUpdateLayout.bind(this);
    this.changeVariation = this.changeVariation.bind(this);
    this.svgLoadCallback = this.svgLoadCallback.bind(this);
    this.socialHeightFit = this.socialHeightFit.bind(this);
    this.logoLoadCallback = this.logoLoadCallback.bind(this);
    this.ctaIconSizeUpdate = this.ctaIconSizeUpdate.bind(this);
    this.deleteNodeCallback = this.deleteNodeCallback.bind(this);
    this.updateHeightForText = this.updateHeightForText.bind(this);
    this.textFitOnImageResize = this.textFitOnImageResize.bind(this);
    this.contactNodesHeightFit = this.contactNodesHeightFit.bind(this);
    this.deviceClippathCheck = this.deviceClippathCheck.bind(this);
    this.speakerImageSizeUpdate = this.speakerImageSizeUpdate.bind(this);
    this.placeholderLoadCallback = this.placeholderLoadCallback.bind(this);
    this.rePositionTextAndElement = this.rePositionTextAndElement.bind(this);
    this.commonAssetsLoadComplete = this.commonAssetsLoadComplete.bind(this);
    this.updateImageResizeOnTypeChange = this.updateImageResizeOnTypeChange.bind(this);
    this.onTextChangeUpdateSpeakerNode = this.onTextChangeUpdateSpeakerNode.bind(this);
    this.applyContrastOnAutoImageChange = this.applyContrastOnAutoImageChange.bind(this);
    this.specialGraphicsCreationComplete = this.specialGraphicsCreationComplete.bind(this);
    // this.logoGridCallback = this.logoGridCallback.bind(this);
    this.designChange = false;
    this.assetLoadingCount = 0;
    this.arrCommonAssets = [];
    this.logoGridImagesLoadComplete = false;
    SGBaseClass.call(this, sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, this.fontData, "coverpage", styleData, objDataToSG);
}

GenericCoverpage.prototype = Object.create(SGBaseClass.prototype);

GenericCoverpage.prototype.initSpecialGraphicsCreation = function (completeCallBack = true) {
    this.checkDesignChangeElements();

    this.assetParent = this.createAssetParent(0, this.sgParent);
    let specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL, this);
    specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });

    if (!this.oldContent) {
        if (this.isWidget == false || (this.objDataToSG && this.objDataToSG.menuChange)) {
            if (this.metaData && this.metaData[this.designChange == true ? "supportedNodes2" : "supportedNodes"]) {
                let nodeObj = this.metaData[this.designChange == true ? "supportedNodes2" : "supportedNodes"];
                let nodeParent = this.createNodes(nodeObj, this.assetParent);
                let moodShapeProperty = null;
                if (nodeObj && nodeObj.name && nodeObj.name == "contentMainParent") {
                    if (this.metaData && this.metaData && this.metaData[this.designChange == true ? "properties2" : "properties"]) {
                        let props = this.metaData[this.designChange == true ? "properties2" : "properties"];
                        moodShapeProperty = props.moodshape;
                        if (moodShapeProperty) {
                            let parent = this.assetParent.querySelector("[id='contentMainParent']");
                            parent = parent ? parent : this.assetParent;
                            this.createMoodShapes(parent, Object.keys(moodShapeProperty).length, moodShapeProperty);
                            specialgraphicsPropertyUtils.applyMoodShapeProperties(moodShapeProperty, this.assetParent, 0, true);
                        }
                    }
                }
                if (nodeObj.subNodes && nodeParent) this.createNestedNodes(nodeObj.subNodes, nodeParent);
            }
            if (this.metaData && this.metaData && this.metaData[this.designChange == true ? "properties2" : "properties"]) {
                let props = this.metaData[this.designChange == true ? "properties2" : "properties"];
                if (props && !props.bgshape) props.bgshape = "emptylayoutshape";
                if (this.objDataToSG?.layoutshapeoutline && props) props.bgshape = this.objDataToSG.layoutshapeoutline;

                //Creating bgshape
                if (props?.bgshape && this.slideContent && this.createLayoutShape) this.createLayoutShape("add", props.bgshape, this.slideContent);
                else if (this.slideContent && this.createLayoutShape) this.createLayoutShape("remove", "", this.slideContent);

                if (this.layoutShapeAddCallback) {
                    let slideID = this.slideContent && this.slideContent.id ? this.slideContent.id : null;
                    this.layoutShapeAddCallback(slideID);
                }
                if (props && props.textelementstyle && this.slideContent) {
                    this.sgParent.parentElement.parentElement.setAttribute("data-textelementstyle", props.textelementstyle);
                } else if (this.sgParent.parentElement && this.sgParent.parentElement.parentElement) this.sgParent.parentElement.parentElement.removeAttribute("data-textelementstyle");
                if (props.number) {
                    let covernumber = this.assetParent.querySelector("[id='covernumber']");
                    covernumber = !covernumber ? this.assetParent.querySelector("[id*='sgNumberTextNode']") : covernumber;
                    let covernumbercontent = this.assetParent.querySelector("[id='covernumbercontent']");
                    let sgNumberTextParent = this.assetParent.querySelector("[id='sgNumberTextParent']");
                    let numberParentNode = sgNumberTextParent ? sgNumberTextParent : covernumber;
                    let node = covernumbercontent ? covernumbercontent : covernumber;
                    if (props.number.positionvalue && covernumber) {
                        covernumber.style.position = props.number.positionvalue;
                        if (sgNumberTextParent) sgNumberTextParent.style.position = props.number.positionvalue;
                    }
                    if (covernumbercontent) covernumbercontent.classList.remove("covernumberRotation");
                    if (props.number.line && (props.number.line == "true") | (props.number.line == true) && covernumber) covernumber.parentElement.classList.add("numberline");
                    if (props.number.parentclass && numberParentNode) this.specialGraphicsUtils.applyClassNamesFromString(numberParentNode, props.number.parentclass);
                    if (props.number.class && node) this.specialGraphicsUtils.applyClassNamesFromString(node, props.number.class);
                    let textAlign = null;
                    let hAlign = null;
                    let vAlign = null;
                    if (props.number.halign && (covernumber || sgNumberTextParent)) {
                        hAlign = props.number.halign == "right" || props.number.halign == "end" ? "flex-end" : props.number.halign == "center" || props.number.valign == "middle" ? "center" : "flex-start";
                        covernumber.style.justifyContent = hAlign;
                        if (sgNumberTextParent) sgNumberTextParent.style.justifyContent = hAlign;
                        if (covernumbercontent) covernumbercontent.style.textAlign = hAlign == "flex-end" ? "end" : hAlign == "center" ? "center" : "start";
                        if (covernumber) covernumber.style.textAlign = hAlign == "flex-end" ? "end" : hAlign == "center" ? "center" : "start";
                        textAlign = hAlign == "flex-end" ? "end" : hAlign == "center" ? "center" : "start";
                    }
                    if (props.number.valign && (covernumber || sgNumberTextParent)) {
                        vAlign = props.number.valign == "bottom" || props.number.valign == "end" ? "flex-end" : props.number.valign == "center" || props.number.valign == "middle" ? "center" : "flex-start";
                        if (sgNumberTextParent) sgNumberTextParent.style.alignItems = vAlign;
                        else covernumber.style.alignItems = vAlign;
                    }
                    specialgraphicsPropertyUtils.applyNumberProperties(props, covernumber, this.assetParent, 0, true);

                    if (props.number.linecount && node) {
                        node.setAttribute("data-linecount", props.number.linecount);
                        this.specialGraphicsUtils.doFontFitForCss(node, this.sgParent);
                    }
                    if (props.number.rotate && (covernumbercontent || sgNumberTextParent)) {
                        let applyingNode = sgNumberTextParent ? covernumber : covernumbercontent;
                        let lineHeight = parseFloat(window.getComputedStyle(applyingNode)["line-height"]);
                        lineHeight = isNaN(lineHeight) ? "40" : lineHeight;
                        applyingNode.style.minWidth = lineHeight + "px";
                        applyingNode.classList.add("covernumberRotation");
                        applyingNode.setAttribute("rotatednode", "true");
                        if (props.number.rotate.includes("-90")) {
                            applyingNode.style.setProperty("--rotateTextRotation", "180deg");
                            covernumber.style.justifyContent = vAlign;
                        } else covernumber.style.justifyContent = vAlign == "flex-start" ? "flex-end" : vAlign == "flex-end" ? "flex-start" : "center";
                        if (applyingNode && textAlign) applyingNode.style.setProperty("--rotateTextAlign", textAlign);
                        this.specialGraphicsUtils.doFontFitForCss(applyingNode, this.sgParent, null, null, null, true);
                    }
                    if (props.number.linecolor) this.assetParent.style.setProperty("--numberLineColor", "rgba(var(--" + props.number.linecolor + "-color-rgb),1)");
                    if (props.number.lineopacity) this.assetParent.style.setProperty("--numberLineOpacity", props.number.lineopacity);

                    let defaultNum = this.objDataToSG && this.objDataToSG.numberFormat ? this.specialGraphicsUtils.getSeqMoodStyle(this.objDataToSG.numberFormat, "1") : "1";

                    if (node && node.id.includes("sgNumberTextNode")) {
                        if (props.number.prefix && node) {
                            node.setAttribute("prefix", props.number.prefix);
                            let pfxValue = node.getAttribute("prefix");
                            if (this.sgData[0].numbertext == "") {
                                node.innerHTML.replace(pfxValue, "");
                                let hasSpace = false;
                                if (pfxValue.substr(pfxValue.length - 1) == " ") {
                                    hasSpace = true;
                                    pfxValue = pfxValue.slice(0, -1);
                                }
                                node.innerHTML = pfxValue + (hasSpace ? "&nbsp;" : "") + defaultNum;
                            } else {
                                pfxValue = this.sgData[0].numbertext;
                                let hasSpace = false;
                                if (pfxValue.substr(pfxValue.length - 1) == " ") {
                                    hasSpace = true;
                                    pfxValue = pfxValue.slice(0, -1);
                                }
                                node.innerHTML = pfxValue + (hasSpace ? "&nbsp;" : "") + defaultNum;
                            }

                            node.style.pointerEvents = "auto";
                            node.contentEditable = "true";
                            this.setCommonSelector(node);
                            this.setTextFocus(node);
                            node.setAttribute("data-fontfit", "false");
                        } else if (node) node.innerText = defaultNum;
                    } else {
                        if (props.number.prefix && node) {
                            node.setAttribute("prefix", props.number.prefix);
                            node.innerText.replace(props.number.prefix, "");
                            node.innerText = props.number.prefix + " " + node.innerText;
                        }
                        if (props.number.suffix && node) {
                            node.setAttribute("suffix", props.number.suffix);
                            node.innerText.replace(props.number.suffix, "");
                            node.innerText = node.innerText + " " + props.number.suffix;
                        }
                    }
                    if (props.number.fontsize) {
                        if (node && node.hasAttribute("user-font-size")) {
                            let userFont = node.getAttribute("user-font-size");
                            let dummyDiv = document.createElement("div");
                            dummyDiv.className = userFont;
                            dummyDiv.style.position = "absolute";
                            node.parentElement.appendChild(dummyDiv);
                            let fontSize = window.getComputedStyle(dummyDiv).fontSize;
                            if (parseFloat(fontSize) > 0) node.style.setProperty("--fontsizefinal", fontSize);
                            else node.style.removeProperty("--fontsizefinal");
                            node.parentElement.removeChild(dummyDiv);
                            node.setAttribute("defaultsize", parseFloat(fontSize));
                        } else if (node) {
                            node.style.removeProperty("--fontsizefinal");
                            this.specialGraphicsUtils.removeAllFontClass(node);
                            node.classList.add("n1");
                            let fs = props.number.fontsize + (props.number.fontsize.includes("px") || props.number.fontsize.includes("%") ? "" : "px");
                            node.style.fontSize = fs;
                            node.setAttribute("defaultsize", parseFloat(fs));
                            node.setAttribute("data-fontfit", "false");
                        }
                        if (node) node.setAttribute("data-defaultclass", "n1");
                    } else if (node && node.id.includes("sgNumberTextNode")) {
                        node.style.removeProperty("font-size");
                        let fontSize = window.getComputedStyle(node).fontSize;
                        node.setAttribute("defaultsize", parseFloat(fontSize));
                    }
                    if (node && node.hasAttribute("contenteditable") && node.getAttribute("contenteditable") == "false") node.removeAttribute("listener");
                    this.applyContrastToText(node, props.number);
                }
                let imageNodeHided = false;
                let floateroptionshide = this.sgParent.parentElement.parentElement.getAttribute("floateroptionshide");
                if (floateroptionshide && floateroptionshide.split(",").length > 0) {
                    if (floateroptionshide.split(",").includes("img")) imageNodeHided = true;
                }
                specialgraphicsPropertyUtils.applyImageProperties(props.image, this.assetParent, 0, props.image);
                specialgraphicsPropertyUtils.applyImageProperties(props.image1, this.assetParent, 0, props.image1, null, false, this.sgParent.querySelector("[id='coverImageParent1']"));
                if (imageNodeHided && this.sgParent.querySelector("[id='coverImageParent']")) {
                    let coverImageParent = this.sgParent.querySelector("[id='coverImageParent']");
                    coverImageParent.style.display = "none";
                    coverImageParent.style.opacity = 0;
                }
                if (props.image) {
                    let coverImageParent = this.sgParent.querySelector("[id='coverImageParent']");
                    if (props.image.positionvalue && coverImageParent) coverImageParent.style.position = props.image.positionvalue;
                    let imagePosition = props.imageposition ? props.imageposition : "left";
                    if (props.image.contentBG) {
                        let arrAssets = [];
                        arrAssets.push({ parent: coverImageParent, type: "svg", url: props.image.contentBG.value, id: props.image.contentBG.id, color: props.image.contentBG.color });
                        this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
                    }
                    let resizeSupport = false;
                    if (props.image.resize && props.image.resize == "enable" && coverImageParent && coverImageParent.querySelector("[data-target-id='coverimage']")) {
                        resizeSupport = true;
                        // let imgNode = coverImageParent.querySelector("[data-target-id='coverimage']");
                        // imgNode.setAttribute("imageresize", "enable");
                        coverImageParent.setAttribute("imageresize", "enable");
                        this.sgParent.setAttribute("imageresizenode", "enable");
                        let imagesizeFromProp = props.image.imagesize ? props.image.imagesize : "large";
                        let coverimageSize = this.sgData[0] && this.sgData[0].coverimagesize ? this.sgData[0].coverimagesize : imagesizeFromProp;
                        if (coverimageSize && coverImageParent) {
                            //Implement image size change from floter
                            // let multipleValue = coverimageSize == "small" ? 0.4 : coverimageSize == "medium" ? 0.7 : coverimageSize == "large" ? 1 : parseFloat(coverimageSize);
                            let multipleValue = this.specialGraphicsUtils.getImageSizeSML(coverimageSize);
                            let largeW = parseFloat(coverImageParent.getAttribute("data-largewidth"));
                            let largeH = parseFloat(coverImageParent.getAttribute("data-largeheight"));
                            if (isNaN(largeW)) largeW = parseFloat(window.getComputedStyle(coverImageParent).width);
                            if (isNaN(largeW)) largeW = parseFloat(coverImageParent.style.width);
                            if (isNaN(largeH)) largeH = parseFloat(window.getComputedStyle(coverImageParent).height);
                            if (isNaN(largeH)) largeH = parseFloat(coverImageParent.style.height);

                            let mainProps = this.getPropertyData();
                            let imagePosition = mainProps && mainProps.imageposition ? mainProps.imageposition : "left";

                            let newW = largeW * (imagePosition == "left" || imagePosition == "right" ? multipleValue : 1);
                            let newH = largeH * (imagePosition == "top" || imagePosition == "bottom" ? multipleValue : 1);
                            if (newW > 0) coverImageParent.style.width = newW + "px";
                            if (newH > 0) coverImageParent.style.height = newH + "px";

                            let direction = "leftRight";
                            if (imagePosition == "top" || imagePosition == "bottom") {
                                coverImageParent.removeAttribute("data-oriwidth");
                                let largeH = parseFloat(coverImageParent.getAttribute("data-largeheight"));
                                if (isNaN(largeH)) {
                                    let oldMinH = coverImageParent.style.minHeight;
                                    coverImageParent.style.minHeight = coverImageParent.style.height;
                                    largeH = parseFloat(window.getComputedStyle(coverImageParent).height);
                                    coverImageParent.style.minHeight = oldMinH;
                                }
                                if (isNaN(largeH)) largeH = parseFloat(coverImageParent.style.height);
                                direction = "topBottom";
                                coverImageParent.setAttribute("imageresize_min", largeH * 0.35);
                                coverImageParent.setAttribute("imageresize_max", largeH);
                            } else {
                                coverImageParent.setAttribute("imageresize_min", largeW * 0.35);
                                coverImageParent.setAttribute("imageresize_max", largeW);
                            }
                            coverImageParent.setAttribute("imageresize_direction", direction);
                            coverImageParent.setAttribute("imageresize_position", imagePosition);
                            let mainP = this.sgParent.querySelector("[id='contentMainParent']");
                            if (mainP) mainP.setAttribute("data-imageposition", imagePosition);
                        }
                    }
                    if (props.image.gridsupport && coverImageParent) coverImageParent.setAttribute("isgridsupport", props.image.gridsupport == "true" ? "true" : "false");

                    if (resizeSupport && this.sgData[0] && this.sgData[0]["coverimagedragvalue"] && coverImageParent) {
                        if (imagePosition == "left" || imagePosition == "right") coverImageParent.style.width = this.sgData[0]["coverimagedragvalue"] + "px";
                        if (imagePosition == "bottom" || imagePosition == "top") coverImageParent.style.height = this.sgData[0]["coverimagedragvalue"] + "px";
                    }

                    // if (this.sgData[0] && coverImageParent && this.sgData[0]["coverimageoverlayshow"]) {
                    //     let overlayNode = coverImageParent.querySelector("[data-nodetype='imageOverlay']");
                    //     if (overlayNode && this.sgData[0]["coverimageoverlayshow"] == "false") {
                    //         overlayNode.style.display = "none";
                    //     }
                    // }

                    //Image overlay check
                    let imageHolder = coverImageParent?.querySelector("[data-nodetype='imageHolder']");
                    let overlayNode = coverImageParent?.querySelector("[data-nodetype='imageOverlay']");
                    if (imageHolder) imageHolder.removeAttribute("data-isoverlay");
                    // if (overlayNode) overlayNode.style.display = "none";
                    //Setting old overlay to new style
                    if (this.sgData[0] && overlayNode && this.sgData[0]["coverimageoverlayshow"]) {
                        overlayNode.style.display = this.sgData[0]["coverimageoverlayshow"] == "true" ? "block" : "none";
                        if (imageHolder && this.sgData[0]["coverimageoverlayshow"] == "true") imageHolder.setAttribute("data-isoverlay", "true");
                    }

                    if (this.objDataToSG?.imageOverlayProps && overlayNode) {
                        let moodImageProps = this.objDataToSG.imageOverlayProps;
                        if (moodImageProps.support == "false" || moodImageProps.support == false) overlayNode.setAttribute("overlaysupport", false);
                    }

                    //If overlay not support by style we have disable by setting display none
                    // if (overlayNode?.hasAttribute("overlaysupport") && overlayNode?.getAttribute("overlaysupport") == "false") overlayNode.style.display = "none";

                    this.specialGraphicsUtils.setImageCaptionPosition(coverImageParent, 0, this.sgData, props.image);
                    let menuJson = this.objDataToSG && this.objDataToSG.menufromjson ? this.objDataToSG.menufromjson : null;
                    if (menuJson && menuJson.floateroptions && menuJson.floateroptions.includes("imagebleed") && coverImageParent) {
                        let coverParent = coverImageParent.querySelector("[id*='coverParent']");
                        if (coverParent) {
                            coverParent.setAttribute("imagebleedoption", "true");
                            if (!this.sgData[0]["coverimageimagebleed"] && menuJson.floateroptionsenable && menuJson.floateroptionsenable.includes("imagebleed")) {
                                var slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
                                if (slideDomContentGroup && slideDomContentGroup.getElementsByTagName("node-0").length > 0) {
                                    let nodeData = slideDomContentGroup.getElementsByTagName("node-0")[0];
                                    let nodeDataList = nodeData.getElementsByTagName("coverimage")[0];
                                    if (nodeDataList) nodeDataList.setAttribute("imagebleed", "true");
                                }
                            }
                        }
                    }
                }
                if (props.image1 && this.sgParent.querySelector("[id='coverImageParent1']")) {
                    let imgProp = props.image1;
                    let coverImageParent = this.sgParent.querySelector("[id='coverImageParent1']");
                    if (imgProp.positionvalue && coverImageParent) coverImageParent.style.position = imgProp.positionvalue;
                    if (imgProp.contentBG) {
                        let arrAssets = [];
                        arrAssets.push({ parent: coverImageParent, type: "svg", url: imgProp.contentBG.value, id: imgProp.contentBG.id, color: imgProp.contentBG.color });
                        this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
                    }
                    // TO-DO
                    this.specialGraphicsUtils.setImageCaptionPosition(coverImageParent, 0, this.sgData, imgProp, "coverimage1");
                    let menuJson = this.objDataToSG && this.objDataToSG.menufromjson ? this.objDataToSG.menufromjson : null;
                    if (menuJson && menuJson.floateroptions && menuJson.floateroptions.includes("imagebleed") && coverImageParent) {
                        let coverParent = coverImageParent.querySelector("[id*='coverParent']");
                        if (coverParent) {
                            coverParent.setAttribute("imagebleedoption", "true");
                            if (!this.sgData[0]["coverimage1imagebleed"] && menuJson.floateroptionsenable?.includes("imagebleed")) {
                                var slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
                                if (slideDomContentGroup && slideDomContentGroup.getElementsByTagName("node-0").length > 0) {
                                    let nodeData = slideDomContentGroup.getElementsByTagName("node-0")[0];
                                    let nodeDataList = nodeData.getElementsByTagName("coverimage1")[0];
                                    if (nodeDataList) nodeDataList.setAttribute("imagebleed", "true");
                                }
                            }
                        }
                    }
                }

                specialgraphicsPropertyUtils.applyTextProperties(this.metaData[this.designChange == true ? "properties2" : "properties"], this.assetParent, 0, true);
                let moodPaddingValue = specialgraphicsPropertyUtils.getMoodPadding(this.assetParent);

                if (this.objDataToSG && this.objDataToSG.theme && this.objDataToSG.theme) {
                    let title = this.assetParent.querySelector("[id*='sgTitleNode']");
                    let subTitle = this.assetParent.querySelector("[id*='sgSubTitleNode']");
                    let label = this.assetParent.querySelector("[id*='sgTitleLabelNode']");
                    let titleColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "title");
                    let subtitleColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "subtitle");
                    let labelColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "label");
                    // if (titleColor && title && !title.hasAttribute("data-supportcontrast")) title.style.setProperty("color", titleColor, "important");
                    if (titleColor && title && !title.hasAttribute("data-supportcontrast")) {
                        title.style.setProperty("color", titleColor);
                        title.setAttribute("data-color", titleColor);
                    }
                    if (titleColor && title && title.hasAttribute("data-supportcontrast")) {
                        title.style.setProperty("color", titleColor);
                        title.setAttribute("data-color", titleColor);
                    }
                    if (subtitleColor && subTitle && !subTitle.hasAttribute("data-supportcontrast")) {
                        subTitle.style.setProperty("color", subtitleColor);
                        subTitle.setAttribute("data-color", subtitleColor);
                    }
                    // if (subtitleColor && subTitle && !subTitle.hasAttribute("data-supportcontrast")) subTitle.style.setProperty("color", subtitleColor, "important");
                    if (subtitleColor && subTitle && subTitle.hasAttribute("data-supportcontrast")) {
                        subTitle.style.setProperty("color", subtitleColor);
                        subTitle.setAttribute("data-color", subtitleColor);
                    }
                    if (labelColor && label && !label.hasAttribute("data-supportcontrast")) {
                        label.style.setProperty("color", labelColor);
                        label.setAttribute("data-color", labelColor);
                    }
                    // if (labelColor && label && !label.hasAttribute("data-supportcontrast")) label.style.setProperty("color", labelColor, "important");
                    if (labelColor && label && label.hasAttribute("data-supportcontrast")) {
                        label.style.setProperty("color", labelColor);
                        label.setAttribute("data-color", labelColor);
                    }
                }
                //Applying text position
                let property = props && props.text ? props.text : null;
                let isSupportTextPosition = property?.positionchange == "true" || property?.positionchange == true ? true : false;
                if (!property && (props?.title?.positionchange == "true" || props?.title?.positionchange == true)) {
                    isSupportTextPosition = true;
                    property = props.title;
                }
                let textPosition;
                if (isSupportTextPosition) {
                    textPosition = this.sgData[0]["titletextposition"] ? this.sgData[0]["titletextposition"] : property && property.defaulttextposition ? property.defaulttextposition : "sgMM";
                    let textBaseParent = this.assetParent.querySelector("[id*='textBaseParentNode']");
                    let titleTextParent = this.assetParent.querySelector("[id*='titleTextParent']");
                    let positionChangeParent = textBaseParent ? textBaseParent : titleTextParent;
                    if (textPosition && textPosition != "" && positionChangeParent) {
                        this.specialGraphicsUtils.removeTextPositionClass(positionChangeParent.parentElement);
                        positionChangeParent.parentElement.classList.add("sg" + textPosition.replace("sg", ""));
                        // this.textPositionChangeOperation(textBaseParent.parentElement, textPosition);
                    }
                }

                for (let a = 0; a < 3; a++) {
                    let textProp = a == 0 ? props.label : a == 1 ? props.subtitle : props.title;
                    let textParentId = a == 0 ? "titleLabelTextParent" : a == 1 ? "subTitleTextParent" : "titleTextParent";
                    let textNodeId = a == 0 ? "sgTitleLabelNode" : a == 1 ? "sgSubTitleNode" : "sgTitleNode";
                    // let textNodeProp = a == 0 ? "titlelabel" : a == 1 ? "subtitle" : "title";
                    if (textProp && this.sgParent.querySelector("[id='" + textParentId + "']")) {
                        let sgTextNodeParent = this.sgParent.querySelector("[id='" + textParentId + "']");
                        let sgTextNode = this.sgParent.querySelector("[id='" + textNodeId + "']");
                        sgTextNodeParent.style.pointerEvents = "auto";
                        sgTextNodeParent.style.order = "unset";
                        if (props?.title?.positionchange == "true" || props?.title?.positionchange == true) sgTextNode.setAttribute("data-positionchange", "true");
                        if (textProp.position) specialgraphicsPropertyUtils.updateMaxPosition(sgTextNodeParent, textProp.position);
                        if (textProp.maxwidth) sgTextNodeParent.style.maxWidth = textProp.maxwidth + (textProp.maxwidth.includes("px") || textProp.maxwidth.includes("%") ? "" : "px");
                        if (textProp.maxheight) {
                            let mh = textProp.maxheight + (textProp.maxheight.includes("px") || textProp.maxheight.includes("%") ? "" : "px");
                            sgTextNodeParent.style.maxHeight = mh;
                            sgTextNode.setAttribute("data-maxheight", mh);
                        }
                        if (textProp.positionvalue) sgTextNodeParent.style.position = textProp.positionvalue;
                        else sgTextNodeParent.style.position = "relative";
                        if (textProp.padding) specialgraphicsPropertyUtils.updatePadding(textProp.padding, sgTextNodeParent, true);
                        if (textProp.margin) specialgraphicsPropertyUtils.updateMargin(textProp.margin, sgTextNodeParent);
                        if (textProp.zorder) sgTextNodeParent.style.zIndex = textProp.zorder;
                        sgTextNode.classList.remove("titleColorBg");
                        sgTextNode.classList.remove("subtitleColorBg");
                        sgTextNode.classList.remove("transparentBg");
                        if (textProp.support && textProp.support == "parent") {
                            sgTextNode.setAttribute("data-support", "parent");
                            this.createTextElement(sgTextNodeParent.parentElement);
                            sgTextNode.setAttribute("data-parentid", sgTextNodeParent.parentElement.id);
                        } else sgTextNode.removeAttribute("data-support");
                        if (textProp.color) sgTextNode.classList.add(textProp.color);
                        else sgTextNode.classList.add("transparentBg");

                        if (textProp.titlecustomcolor) sgTextNode.style.setProperty("color", "rgba(var(--" + textProp.titlecustomcolor + "-color-rgb),1)", "important");
                        if (textProp.bgcolor) sgTextNodeParent.style.backgroundColor = "rgba(var(--" + textProp.bgcolor + "-color-rgb),1)";
                        if (textProp.bgshadow) sgTextNodeParent.style.boxShadow = textProp.bgshadow;
                        if (textProp.contrast) this.applyContrastToText(sgTextNode, textProp);
                        if (textProp.halign) {
                            let alignValue = textProp.halign == "end" || textProp.halign == "right" ? "flex-end" : textProp.halign == "center" || textProp.halign == "middle" ? "center" : "flex-start";
                            let align = textProp.halign == "end" || textProp.halign == "right" ? "end" : textProp.halign == "center" || textProp.halign == "middle" ? "center" : "start";
                            this.sgParent.style.setProperty("--textAlign", align);
                            this.sgParent.style.setProperty("--textJustifyContent", alignValue);
                        }
                        if (textProp.valign) {
                            let alignValue = textProp.valign == "bottom" || textProp.valign == "end" ? "flex-end" : textProp.valign == "center" || textProp.valign == "middle" ? "center" : "flex-start";
                            sgTextNodeParent.style.alignItems = alignValue;
                        }
                        if (textProp.opacity) {
                            sgTextNodeParent.style.opacity = textProp.opacity;
                            this.specialGraphicsUtils.setOpacityAttribute(sgTextNodeParent);
                        }
                        if (textProp.class) {
                            this.specialGraphicsUtils.applyClassNamesFromString(sgTextNode, textProp.class);
                        }
                        if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(sgTextNode);
                        // if (this.sgData?.[0]?.[textNodeProp + "opacity"]) {
                        //     sgTextNode.style.opacity = this.sgData[0][textNodeProp + "opacity"];
                        //     this.specialGraphicsUtils.setOpacityAttribute(sgTextNode);
                        // }
                        // if (this.sgData?.[0]?.[textNodeProp + "textsize"]) {
                        //     sgTextNode.style.fontSize = this.sgData[0][textNodeProp + "textsize"];
                        //     sgTextNode.setAttribute("user-text-size", sgTextNode.style.fontSize);
                        // }
                        // if (this.sgData?.[0]?.[textNodeProp + "texttransform"]) sgTextNode.style.textTransform = this.sgData[0][textNodeProp + "texttransform"];
                    }
                }

                // if (props.number && props.number.depends && props.number.depends == "text") {
                //     //If number depends text then we have to do this
                //     let covernumber = this.assetParent.querySelector("[id='covernumber']");
                //     covernumber = !covernumber ? this.assetParent.querySelector("[id*='sgNumberTextNode']") : covernumber;
                //     let covernumbercontent = this.assetParent.querySelector("[id='covernumbercontent']");
                //     let node = covernumbercontent ? covernumbercontent : covernumber;
                //     let sgTitleNode = this.assetParent.querySelector("[id='sgTitleNode']");
                //     let textAlign = sgTitleNode ? window.getComputedStyle(sgTitleNode)["text-align"] : "";
                //     if (sgTitleNode && node) {
                //         node.parentElement.style.alignSelf = textAlign == "right" || textAlign == "end" ? "flex-end" : textAlign == "center" ? "center" : "flex-start";
                //         node.parentElement.style.justifyContent = textAlign == "right" || textAlign == "end" ? "flex-end" : textAlign == "center" ? "center" : "flex-start";
                //     }
                // }
                for (let a = 0; a < 2; a++) {
                    let presenterProperty = a == 0 ? (props.customertext ? props.customertext : props.customer) : props.presentertext ? props.presentertext : props.presenter;
                    let isSeparateProp = props.customertext || props.presentertext;
                    let imageNewProp = a == 0 ? (props.customerimage ? props.customerimage : null) : props.presenterimage ? props.presenterimage : null;
                    let preWord = a == 0 ? "customer" : "presenter";
                    let tagWord = a == 0 ? "customer" : "creator";
                    if (this.sgParent.querySelector("[id='" + preWord + "Parent']") || imageNewProp) {
                        let presenterNode = this.sgParent.querySelector("[id='" + preWord + "Parent']");
                        if (presenterNode) {
                            let sgPresentorNameNode = this.sgParent.querySelector("[id='sg" + (a == 0 ? "Customer" : "Presentor") + "NameNode']");
                            let sgPresentorDesiginationNode = this.sgParent.querySelector("[id='sg" + (a == 0 ? "Customer" : "Presentor") + "DesiginationNode']");
                            let presenterContentParent = this.sgParent.querySelector("[id='" + preWord + "ContentParent']");
                            let presenterImageParent = presenterContentParent ? presenterContentParent.querySelector("[id='" + preWord + "ImageParent']") : null;
                            if (!presenterImageParent) presenterImageParent = this.assetParent.querySelector("[id='" + preWord + "ImageParent']");
                            let colorDiv = presenterContentParent?.querySelector("[id='presentorColorDiv']");
                            if (!colorDiv) colorDiv = presenterContentParent?.querySelector("[id='customerColorDiv']");
                            let presenterTextParent = presenterNode ? presenterNode.querySelector("[id='" + preWord + "TextParent']") : null;
                            if (presenterProperty?.primaryclass) this.specialGraphicsUtils.applyClassNamesFromString(sgPresentorNameNode, presenterProperty?.primaryclass);
                            if (presenterProperty?.secondaryclass) this.specialGraphicsUtils.applyClassNamesFromString(sgPresentorDesiginationNode, presenterProperty?.secondaryclass);
                            if (presenterProperty?.primaryparentclass) this.specialGraphicsUtils.applyClassNamesFromString(sgPresentorNameNode.parentElement, presenterProperty?.primaryparentclass);
                            if (presenterProperty?.secondaryparentclass) this.specialGraphicsUtils.applyClassNamesFromString(sgPresentorDesiginationNode.parentElement, presenterProperty.secondaryparentclass);
                            if (presenterProperty && !presenterProperty.class) presenterProperty.class = "pre_type1";
                            if (presenterProperty?.class && presenterNode) presenterNode.classList = "presenterParent " + presenterProperty.class;
                            if (presenterProperty?.position) specialgraphicsPropertyUtils.updatePosition(presenterNode, presenterProperty.position);
                            if (presenterNode && presenterTextParent) presenterTextParent.style.height = presenterNode.style.height;
                            if (presenterProperty?.zorder) presenterNode.style.zIndex = presenterProperty.zorder;
                            if (presenterProperty?.image && presenterContentParent) {
                                let imageProp = presenterProperty.image;
                                if (imageProp.zorder) {
                                    presenterImageParent.style.zIndex = imageProp.zorder;
                                    presenterContentParent.style.zIndex = imageProp.zorder;
                                }
                                if (imageProp.position) {
                                    if (presenterTextParent) presenterTextParent.style.margin = "unset";
                                    presenterImageParent.style.position = "absolute";
                                    presenterContentParent.style.margin = "unset";
                                    if (presenterTextParent && !imageProp.isseparate) {
                                        let widthOfImage = imageProp.position.split(",")[2];
                                        widthOfImage = widthOfImage.includes("px") ? parseFloat(widthOfImage) : widthOfImage.includes("%") ? parseFloat(widthOfImage) * 12.8 : widthOfImage;
                                        widthOfImage = parseFloat(widthOfImage) + parseFloat(moodPaddingValue.left) + "px";
                                        presenterTextParent.style.width = "calc(100% - " + widthOfImage + ")";
                                    }
                                } else if (presenterTextParent) {
                                    if (presenterProperty?.class == "pre_type4" || presenterProperty?.class == "pre_type4right") {
                                        let w = presenterTextParent.style.width;
                                        presenterTextParent.style.width = presenterTextParent.style.maxWidth == "" ? window.getComputedStyle(presenterTextParent).maxWidth : presenterTextParent.style.maxWidth;
                                        let textparentMaxWidth = parseFloat(window.getComputedStyle(presenterTextParent).width) / 2;
                                        let imgWidth = presenterImageParent ? parseFloat(window.getComputedStyle(presenterImageParent).width) / 2 : 0;
                                        let imgMarginRight = presenterImageParent ? parseFloat(window.getComputedStyle(presenterImageParent).marginRight) / 2 : 0;
                                        let imgMarginLeft = presenterImageParent ? parseFloat(window.getComputedStyle(presenterImageParent).marginLeft) / 2 : 0;
                                        let mw = textparentMaxWidth + imgWidth - (imgMarginLeft + imgMarginRight) / 2 + "px";
                                        sgPresentorDesiginationNode.parentElement.style.width = "calc(" + mw + " - ((var(--presenterLineMarginRight) / 2) + (var(--presenterLineMarginLeft) / 2)))";
                                        sgPresentorDesiginationNode.parentElement.style.minWidth = "calc(" + mw + " - ((var(--presenterLineMarginRight) / 2) + (var(--presenterLineMarginLeft) / 2)))";
                                        presenterTextParent.style.width = w;
                                    }
                                    if (presenterProperty?.class && presenterProperty?.class.includes("pre_type2")) {
                                        let oldParentW = null;
                                        if (presenterNode.parentElement && presenterNode.parentElement.hasAttribute("fullwidth") && presenterNode.style.width.includes("%")) {
                                            oldParentW = presenterNode.style.width;
                                            presenterNode.style.width = (parseFloat(presenterNode.parentElement.getAttribute("fullwidth")) / 100) * parseFloat(oldParentW) + "px";
                                        }
                                        let w = presenterTextParent.style.width;
                                        presenterTextParent.style.width = presenterTextParent.style.maxWidth == "" ? window.getComputedStyle(presenterTextParent).maxWidth : presenterTextParent.style.maxWidth;
                                        presenterTextParent.style.maxWidth = window.getComputedStyle(presenterTextParent).width;
                                        presenterNode.parentElement.style.setProperty("--presenterTextHalfWidth", parseFloat(presenterTextParent.style.maxWidth) / 2 + "px");
                                        presenterNode.style.setProperty("--presenterTextHalfWidth", parseFloat(presenterTextParent.style.maxWidth) / 2 + "px");
                                        presenterTextParent.style.width = w;
                                        if (oldParentW != null) presenterNode.style.width = oldParentW;
                                    }
                                }
                                if (presenterImageParent) specialgraphicsPropertyUtils.applyImageProperties(imageProp, this.assetParent, 0, imageProp, presenterImageParent);
                                let isseparate = false;
                                if (imageProp.isseparate && (imageProp.isseparate == "true" || imageProp.isseparate == true)) {
                                    let contentMainParent = this.sgParent.querySelector("[id='contentMainParent']");
                                    presenterContentParent.parentElement.removeChild(presenterContentParent);
                                    contentMainParent.appendChild(presenterContentParent);
                                    if (presenterTextParent) presenterTextParent.style.maxWidth = "unset";
                                    isseparate = true;
                                    this.assetParent.style.setProperty("--presenterImageParentWidth", "100%");
                                    this.assetParent.style.setProperty("--presenterImageParentHeight", "100%");
                                }
                                this.applyChildStyleToParent(presenterContentParent, presenterImageParent);
                                if (isseparate && presenterImageParent) {
                                    if (presenterImageParent.style.margin == "unset") {
                                        presenterImageParent.style.removeProperty("margin");
                                        presenterImageParent.style.margin = "unset";
                                    }
                                    if (presenterImageParent.style.padding == "unset") {
                                        presenterImageParent.style.removeProperty("padding");
                                        presenterImageParent.style.padding = "unset";
                                    }
                                }
                                if (imageProp.width && imageProp.height) {
                                    presenterContentParent.style.width = imageProp.width + (imageProp.width.includes("px") || imageProp.width.includes("%") ? "" : "px");
                                    presenterContentParent.style.height = imageProp.height + (imageProp.height.includes("px") || imageProp.height.includes("%") ? "" : "px");
                                    this.assetParent.style.setProperty("--presenterImageParentWidth", presenterContentParent.style.width);
                                    this.assetParent.style.setProperty("--presenterImageParentHeight", presenterContentParent.style.height);
                                }
                                // if (isseparate == false && presenterProperty?.class && presenterProperty?.class != "pre_type4" && presenterProperty?.class != "pre_type4right")
                                //     presenterTextParent.style.maxWidth = "calc(100% - (" + parseFloat(window.getComputedStyle(presenterImageParent).width) + "px + var(--presentGap)))";
                                if (imageProp.globalstyle && presenterContentParent) {
                                    presenterContentParent.classList.remove(imageProp.globalstyle);
                                    presenterContentParent.classList.add(imageProp.globalstyle);
                                    presenterContentParent.classList.add("clsSingleColorParent");

                                    let percentValue = window.getComputedStyle(presenterContentParent).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
                                    percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
                                    let sourceNode = presenterContentParent.querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
                                    if (sourceNode) presenterContentParent.style.setProperty("--customNodeBorderImageWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
                                }
                                if (imageProp?.class) this.specialGraphicsUtils.applyClassNamesFromString(presenterContentParent, imageProp?.class);
                                if (imageProp.contentBG) {
                                    let arrAssets = [];
                                    arrAssets.push({
                                        parent: presenterContentParent,
                                        type: "svg",
                                        url: imageProp.contentBG.value,
                                        id: imageProp.contentBG.id,
                                        color: imageProp.contentBG.color,
                                    });
                                    this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
                                }
                            } else if (presenterTextParent && presenterImageParent && presenterProperty?.class && presenterProperty?.class != "pre_type4" && presenterProperty?.class != "pre_type4right") {
                                presenterTextParent.style.maxWidth = "calc(100% - (" + parseFloat(window.getComputedStyle(presenterImageParent).width) + "px + var(--presentGap)))";
                                if (isSeparateProp) presenterTextParent.style.maxWidth = "100%";
                            }
                            if (imageNewProp && presenterContentParent) {
                                let imageProp = imageNewProp;

                                specialgraphicsPropertyUtils.applyImageProperties(imageProp, this.assetParent, 0, imageProp, presenterImageParent);
                                presenterImageParent.parentElement.style.margin = presenterImageParent.style.margin;
                                presenterImageParent.style.margin = "unset";

                                this.applyChildStyleToParent(presenterContentParent, presenterImageParent);
                                if (imageProp.positionvalue) presenterContentParent.style.position = imageProp.positionvalue;
                                if (imageProp.globalstyle) {
                                    presenterContentParent.classList.remove(imageProp.globalstyle);
                                    presenterContentParent.classList.add(imageProp.globalstyle);
                                    presenterContentParent.classList.add("clsSingleColorParent");

                                    let percentValue = window.getComputedStyle(presenterContentParent).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
                                    percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
                                    let sourceNode = presenterContentParent.querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
                                    if (sourceNode) presenterContentParent.style.setProperty("--customNodeBorderImageWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
                                }
                                if (imageProp?.class) this.specialGraphicsUtils.applyClassNamesFromString(presenterContentParent, imageProp?.class);
                                if (imageProp.contentBG) {
                                    let arrAssets = [];
                                    arrAssets.push({
                                        parent: presenterContentParent,
                                        type: "svg",
                                        url: imageProp.contentBG.value,
                                        id: imageProp.contentBG.id,
                                        color: imageProp.contentBG.color,
                                    });
                                    this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
                                }
                            }
                            if (presenterProperty?.textgap) this.assetParent.style.setProperty("--presentGap", presenterProperty?.textgap + (presenterProperty?.textgap.includes("px") ? "" : "px"));
                            if (presenterProperty?.textalign) this.assetParent.style.setProperty("--presenterTextAlign", presenterProperty?.textalign);

                            let presenterNameColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "name", presenterProperty?.namecolor);
                            let presenterDesiginationColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "designation", presenterProperty?.desiginationcolor);

                            if (presenterNameColor) {
                                this.assetParent.style.setProperty("--presenterNameColor", presenterNameColor);
                                if (sgPresentorNameNode) sgPresentorNameNode.setAttribute("data-color", presenterNameColor);
                            }
                            if (presenterDesiginationColor) {
                                this.assetParent.style.setProperty("--presenterDesiginationColor", presenterDesiginationColor);
                                if (sgPresentorDesiginationNode) sgPresentorDesiginationNode.setAttribute("data-color", presenterDesiginationColor);
                            }

                            if (presenterProperty?.desiginationtop && sgPresentorDesiginationNode) sgPresentorDesiginationNode.parentElement.style.marginTop = presenterProperty?.desiginationtop + (presenterProperty?.desiginationtop.includes("px") ? "" : "px");
                            if (presenterProperty?.maxheight && presenterNode) presenterNode.style.maxHeight = presenterProperty?.maxheight + (presenterProperty?.maxheight.includes("px") || presenterProperty?.maxheight.includes("%") ? "" : "px");
                            if (presenterProperty?.halign && presenterNode) {
                                let hAlign = presenterProperty?.halign == "end" || presenterProperty?.halign == "right" ? "flex-end" : presenterProperty?.halign == "center" ? "center" : "flex-start";
                                presenterNode.style.justifyContent = hAlign;
                            }
                            if (presenterProperty?.valign && presenterNode) {
                                let alignData = presenterProperty?.valign;
                                let vAlign = alignData == "bottom" || alignData == "end" ? "flex-end" : alignData == "center" || alignData == "middle" ? "center" : "flex-start";
                                presenterNode.style.alignItems = vAlign;
                                if (presenterProperty?.class && presenterProperty?.class.includes("type3")) {
                                    presenterNode.style.justifyContent = vAlign;
                                    presenterNode.style.removeProperty("align-items");
                                }
                            }
                            if (presenterProperty?.margin) specialgraphicsPropertyUtils.updateMargin(presenterProperty?.margin, presenterNode);
                            if (presenterProperty?.padding) specialgraphicsPropertyUtils.updatePadding(presenterProperty?.padding, presenterNode);
                            if (presenterProperty?.line && presenterTextParent && presenterTextParent.querySelector("[id='" + preWord + "Line']")) {
                                let lineProp = presenterProperty?.line;
                                if (lineProp.width) presenterNode.style.setProperty("--presenterLineWidth", lineProp.width + (lineProp.width.includes("px") || lineProp.width.includes("%") ? "" : "px"));
                                if (lineProp.height) presenterNode.style.setProperty("--presenterLineHeight", lineProp.height + (lineProp.height.includes("px") || lineProp.height.includes("%") ? "" : "px"));
                                if (lineProp.color) presenterNode.style.setProperty("--presenterLineColor", "rgba(var(--" + lineProp.color + "-color-rgb),1)");
                                if (lineProp.opacity) {
                                    presenterNode.style.setProperty("--presenterLineOpacity", lineProp.opacity);
                                    this.specialGraphicsUtils.setOpacityAttribute(presenterTextParent.querySelector("[id='" + preWord + "Line']"));
                                }
                                this.specialGraphicsUtils.setOpacityAttribute(presenterNode);
                                if (lineProp["margin-right"]) presenterNode.style.setProperty("--presenterLineMarginRight", lineProp["margin-right"] + (lineProp["margin-right"].includes("px") || lineProp["margin-right"].includes("%") ? "" : "px"));
                                if (lineProp["margin-left"]) presenterNode.style.setProperty("--presenterLineMarginLeft", lineProp["margin-left"] + (lineProp["margin-left"].includes("px") || lineProp["margin-left"].includes("%") ? "" : "px"));
                            }

                            // Setting overlay enable/disable
                            if (this.sgData[0] && colorDiv && this.sgData[0][tagWord + "imageoverlayshow"]) {
                                colorDiv.style.display = this.sgData[0][tagWord + "imageoverlayshow"] == "true" ? "block" : "none";
                                if (presenterContentParent && this.sgData[0][tagWord + "imageoverlayshow"] == "true") presenterContentParent.setAttribute("data-isoverlay", "true");
                            } else if (colorDiv && (imageNewProp?.overlayenable == "true" || imageNewProp?.overlayenable == true)) colorDiv.style.display = "block";
                            else if (colorDiv) colorDiv.style.display = "none";

                            // Setting overlay opacity
                            if (this.sgData[0] && this.sgData[0][tagWord + "imageopacity"] && colorDiv) colorDiv.style.opacity = this.sgData[0][tagWord + "imageopacity"];

                            this.applyContrastToText(sgPresentorNameNode, presenterProperty);
                            this.applyContrastToText(sgPresentorDesiginationNode, presenterProperty);
                            let line = presenterNode?.querySelector("[id*='Line']");
                            this.specialGraphicsUtils.applyContrastToShape(line, presenterProperty);
                            if (colorDiv) this.specialGraphicsUtils.setOpacityAttribute(colorDiv);
                        }
                    }
                }
                if (props.social && this.sgParent.querySelector("[id='customLinkIconParent']")) {
                    let customLinkIconParent = this.sgParent.querySelector("[id='customLinkIconParent']");
                    let presenterNode = this.sgParent.querySelector("[id='presenterParent']");
                    let presenterTextParent = presenterNode ? presenterNode.querySelector("[id='presenterTextParent']") : null;
                    if (presenterTextParent) {
                        presenterTextParent.style.height = "auto";
                        presenterTextParent.style.margin = "unset";
                    }
                    if (!!props.social.depends && (props.social.depends == "true" || props.social.depends == true)) {
                        customLinkIconParent.parentElement.removeChild(customLinkIconParent);
                        presenterNode.appendChild(customLinkIconParent);
                        presenterNode.style.flexDirection = "column";
                        let presenterProperty = props.presenter;
                        if (presenterProperty && presenterProperty.halign) {
                            let hAlign = presenterProperty.halign == "end" || presenterProperty.halign == "right" ? "flex-end" : presenterProperty.halign == "center" ? "center" : "flex-start";
                            presenterNode.style.alignItems = hAlign;
                        }
                        if (presenterProperty && presenterProperty.valign) {
                            let alignData = presenterProperty.valign;
                            let vAlign = alignData == "bottom" || alignData == "end" ? "flex-end" : alignData == "center" || alignData == "middle" ? "center" : "flex-start";
                            presenterNode.style.justifyContent = vAlign;
                        }
                        if ((presenterProperty && !presenterProperty.valign && !presenterProperty.halign) || !presenterProperty) {
                            presenterNode.style.alignItems = "flex-start";
                            presenterNode.style.justifyContent = "center";
                        }
                    }
                    if (props.social.class) {
                        let sgCustomSocialLink = this.sgParent.querySelectorAll("[id*='sgCustomSocialLink']");
                        for (let i = 0; i < sgCustomSocialLink.length; i++) {
                            sgCustomSocialLink[i].classList = "sgCustomSocialLink" + i + " " + props.social.class;
                        }
                    }
                    if (props.social.textgap) this.assetParent.style.setProperty("--socialGap", props.social.textgap + (props.social.textgap.includes("px") ? "" : "px"));
                    if (props.social.nodegap) this.assetParent.style.setProperty("--socialNodeGap", props.social.nodegap + (props.social.nodegap.includes("px") ? "" : "px"));
                    if (props.social.position) specialgraphicsPropertyUtils.updatePosition(customLinkIconParent, props.social.position);
                    if (props.social.positionvalue) customLinkIconParent.style.position = props.social.positionvalue;
                    if (props.social.padding) specialgraphicsPropertyUtils.updatePadding(props.social.padding, customLinkIconParent);
                    if (props.social.margin) specialgraphicsPropertyUtils.updateMargin(props.social.margin, customLinkIconParent);
                    if (props.social.iconcolor) this.assetParent.style.setProperty("--socialIconColor", "rgba(var(--" + props.social.iconcolor + "-color-rgb),1)");
                    if (props.social.align) {
                        customLinkIconParent.style.order = props.social.align == "bottom" ? 1 : 0;
                        if (presenterTextParent) presenterTextParent.style.order = props.social.align == "bottom" ? 0 : 1;
                    }
                    customLinkIconParent.style.left = "unset";
                    customLinkIconParent.style.top = "unset";
                    customLinkIconParent.style.width = "100%";
                    if (presenterTextParent) customLinkIconParent.style.maxWidth = presenterTextParent.style.width;

                    if (props.social.hideicon && (props.social.hideicon == "true" || props.social.hideicon == true)) {
                        let customSocialLinkIcon = this.sgParent.querySelectorAll("[id*='customSocialLinkIcon']");
                        for (let i = 0; i < customSocialLinkIcon.length; i++) {
                            customSocialLinkIcon[i].style.display = "none";
                            let socialIconTextParent = customSocialLinkIcon[i].parentElement.querySelector("[id='socialIconTextParent']");
                            if (socialIconTextParent) {
                                socialIconTextParent.style.maxWidth = "100%";
                                socialIconTextParent.style.margin = "unset";
                            }
                        }
                    } else {
                        let arrAssets = [];
                        arrAssets.push({ type: "svg", url: "genericassets/socialicons/linkedin.svg", id: "linkedin" });
                        arrAssets.push({ type: "svg", url: "genericassets/socialicons/twitter.svg", id: "twitter" });

                        this.arrCommonAssets.push({ array: arrAssets, callback: this.assetsLoadComplete });

                        // this.assetsLoading = true;
                        // this.loadAssets(arrAssets, this.assetsLoadComplete, this.assetError);
                    }
                    let arrIconParent = this.sgParent.querySelectorAll("[id*='iconParent']");
                    for (let i = 0; i < arrIconParent.length; i++) {
                        if (props.social.globalstyle) {
                            arrIconParent[i].classList.add("clsSingleColorParent");
                            arrIconParent[i].classList.add(props.social.globalstyle);

                            let percentValue = window.getComputedStyle(arrIconParent[i]).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
                            percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
                            let sourceNode = arrIconParent[i].querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
                            if (sourceNode) arrIconParent[i].style.setProperty("--customNodeBorderWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
                        } else arrIconParent[i].className = "";
                        if (props.social.contentBG) {
                            let arrAssets = [];
                            arrAssets.push({ parent: arrIconParent[i], type: "svg", url: props.social.contentBG.value, id: props.social.contentBG.id, color: props.social.contentBG.color });
                            this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
                        }
                    }
                    if (props.social.contrast) {
                        let socialNodes = this.sgParent.querySelectorAll("[id*='socialIconTextTitle']");
                        for (let a = 0; a < socialNodes.length; a++) {
                            this.applyContrastToText(socialNodes[a], props.social);
                        }
                        let socialSubNodes = this.sgParent.querySelectorAll("[id*='socialIconTextSubTitle']");
                        for (let a = 0; a < socialSubNodes.length; a++) {
                            this.applyContrastToText(socialSubNodes[a], props.social);
                        }
                    }
                }
                if (props.ctasocial && this.sgParent.querySelector("[id='customLinkIconParent']")) {
                    this.hideTextNodes(true);
                    let customLinkIconParent = this.sgParent.querySelector("[id='customLinkIconParent']");
                    if (props.ctasocial.position) specialgraphicsPropertyUtils.updatePosition(customLinkIconParent, props.ctasocial.position);
                    if (props.ctasocial.positionvalue) customLinkIconParent.style.position = props.ctasocial.positionvalue;
                    if (props.ctasocial.primarycolor) this.assetParent.style.setProperty("--socialPrimaryColor", "rgba(var(--" + props.ctasocial.primarycolor + "-color-rgb),1)");
                    if (props.ctasocial.textgap) this.assetParent.style.setProperty("--socialGap", props.ctasocial.textgap + (props.ctasocial.textgap.includes("px") ? "" : "px"));
                    if (props.ctasocial.inbetweentextgap) this.assetParent.style.setProperty("--ctaSocialTextGap", props.ctasocial.inbetweentextgap);
                    if (props.ctasocial.iconcolor) this.assetParent.style.setProperty("--socialIconColor", "rgba(var(--" + props.ctasocial.iconcolor + "-color-rgb),1)");
                    if (props.ctasocial.secondarycolor) this.assetParent.style.setProperty("--socialSecondaryColor", "rgba(var(--" + props.ctasocial.secondarycolor + "-color-rgb),1)");
                    if (props.ctasocial.padding) specialgraphicsPropertyUtils.updatePadding(props.ctasocial.padding, customLinkIconParent);
                    if (props.ctasocial.margin) specialgraphicsPropertyUtils.updateMargin(props.ctasocial.margin, customLinkIconParent);
                    if (props.ctasocial.bgstyle) customLinkIconParent.classList.add(props.ctasocial.bgstyle);
                    if (props.ctasocial.maxheight) customLinkIconParent.style.maxHeight = props.ctasocial.maxheight + (props.ctasocial.maxheight.includes("px") || props.ctasocial.maxheight.includes("%") ? "" : "px");
                    if (props.ctasocial.iconopacity) this.assetParent.style.setProperty("--contactIconOpacity", props.ctasocial.iconopacity);
                    let customLinkIconInnerParent = this.sgParent.querySelector("[id='customLinkIconInnerParent']");
                    if (!props.ctasocial.aligntype) props.ctasocial.aligntype = "vertical";
                    if (props.ctasocial.aligntype && customLinkIconInnerParent) {
                        customLinkIconInnerParent.classList.add("ctasocial" + props.ctasocial.aligntype);
                        if (props.ctasocial.aligntype == "grid") {
                            let contactLine1 = customLinkIconInnerParent.querySelector("[id='contactLine1']");
                            let contactLine2 = customLinkIconInnerParent.querySelector("[id='contactLine2']");
                            let contactLine3 = customLinkIconInnerParent.querySelector("[id='contactLine3']");
                            let contactLine4 = customLinkIconInnerParent.querySelector("[id='contactLine4']");
                            if (contactLine1) contactLine1.style.display = "none";
                            if (contactLine2) contactLine2.style.display = "none";
                            if (contactLine3) contactLine2.style.display = "none";
                            if (contactLine4) contactLine2.style.display = "none";
                        }
                    }
                    if (props.ctasocial.nodegap) this.assetParent.style.setProperty("--ctaSocialNodeGap", props.ctasocial.nodegap);
                    if (props.ctasocial.gridcount) {
                        customLinkIconInnerParent.style.setProperty("--gridCount", props.ctasocial.gridcount);
                        customLinkIconInnerParent.setAttribute("data-gridcount", props.ctasocial.gridcount);
                    }
                    if (!props.ctasocial.class) props.ctasocial.class = "ctasocial_type1";
                    if (props.ctasocial.class) {
                        let sgCustomSocialLink = this.sgParent.querySelectorAll("[id*='sgCustomSocialLink']");
                        if (customLinkIconInnerParent && props.ctasocial.class == "social_type2") customLinkIconInnerParent.style.alignItems = "flex-end";
                        for (let i = 0; i < sgCustomSocialLink.length; i++) {
                            if (sgCustomSocialLink[i].classList.contains("clsSocialLink")) sgCustomSocialLink[i].classList = "ctafullnode customSocialLink clsSocialLink " + props.ctasocial.class;
                            else sgCustomSocialLink[i].classList = "ctafullnode customSocialLink " + props.ctasocial.class;
                            let socialIconTextParent = sgCustomSocialLink[i].querySelector("[id*='socialIconTextParent']");
                            let socialLine = sgCustomSocialLink[i].querySelector("[id*='socialLine']");
                            if (props.ctasocial.class == "ctasocial_type4" && socialIconTextParent && socialLine) socialIconTextParent.appendChild(socialLine);
                        }
                    }
                    if (props.ctasocial.hideicon && (props.ctasocial.hideicon == "true" || props.ctasocial.hideicon == true)) {
                        let customSocialLinkIcon = this.sgParent.querySelectorAll("[id*='customSocialLinkIcon']");
                        for (let i = 0; i < customSocialLinkIcon.length; i++) {
                            customSocialLinkIcon[i].style.display = "none";
                            let socialIconTextParent = customSocialLinkIcon[i].parentElement.querySelector("[id='socialIconTextParent']");
                            if (socialIconTextParent) {
                                socialIconTextParent.style.maxWidth = "100%";
                                socialIconTextParent.style.margin = "unset";
                            }
                        }
                    } else {
                        let customSocialLinkIcon = this.sgParent.querySelectorAll("[id*='customSocialLinkIcon']");
                        for (let i = 0; i < customSocialLinkIcon.length; i++) {
                            this.specialGraphicsUtils.setOpacityAttribute(customSocialLinkIcon[i]);
                        }
                    }
                    if (props.ctasocial.halign) {
                        let alignValue = props.ctasocial.halign;
                        let hAlign = alignValue == "right" || alignValue == "end" ? "flex-end" : alignValue == "center" || alignValue == "middle" ? "center" : "flex-start";
                        this.assetParent.style.setProperty("--ctaSocialHAlign", hAlign);
                    }
                    if (props.ctasocial.valign) {
                        let alignValue = props.ctasocial.valign;
                        let vAlign = alignValue == "bottom" || alignValue == "end" ? "flex-end" : alignValue == "center" || alignValue == "middle" ? "center" : "flex-start";
                        this.assetParent.style.setProperty("--ctaSocialVAlign", vAlign);
                    }
                    if (props.ctasocial.hideicon && (props.ctasocial.hideicon == "true" || props.ctasocial.hideicon == true)) {
                        this.assetParent.style.setProperty("--contactIconSize", 0);
                    } else {
                        let arrAssets = [];
                        arrAssets.push({ type: "svg", url: "genericassets/socialicons/linkedin.svg", id: "linkedin" });
                        arrAssets.push({ type: "svg", url: "genericassets/socialicons/twitter.svg", id: "twitter" });
                        arrAssets.push({ type: "svg", url: "genericassets/socialicons/facebook.svg", id: "facebook", type: "SVG" });
                        arrAssets.push({ type: "svg", url: "genericassets/socialicons/instagram.svg", id: "instagram", type: "SVG" });
                        arrAssets.push({ type: "svg", url: "genericassets/socialicons/skype.svg", id: "skype", type: "SVG" });
                        this.arrCommonAssets.push({ array: arrAssets, callback: this.assetsLoadComplete });
                    }
                    this.applyTextFormats(props.ctasocial, ["socialIconTextTitle1", "socialIconTextTitle2", "socialIconTextTitle3", "socialIconTextTitle4", "socialIconTextTitle5"], ["socialIconTextSubTitle1", "socialIconTextSubTitle2", "socialIconTextSubTitle3", "socialIconTextSubTitle4", "socialIconTextSubTitle5"]);
                    let arrIconParent = this.sgParent.querySelectorAll("[id*='iconParent']");
                    for (let i = 0; i < arrIconParent.length; i++) {
                        if (props.ctasocial.globalstyle) {
                            arrIconParent[i].classList.add("clsSingleColorParent");
                            arrIconParent[i].classList.add(props.ctasocial.globalstyle);

                            let percentValue = window.getComputedStyle(arrIconParent[i]).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
                            percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
                            let sourceNode = arrIconParent[i].querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
                            if (sourceNode) arrIconParent[i].style.setProperty("--customNodeBorderWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
                        } else arrIconParent[i].className = "";

                        if (props.ctasocial.contentBG) {
                            let arrAssets = [];
                            arrAssets.push({ parent: arrIconParent[i], type: "svg", url: props.ctasocial.contentBG.value, id: props.ctasocial.contentBG.id, color: props.ctasocial.contentBG.color });
                            this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
                        }
                        // let customSocialLinkIcon = arrIconParent[i].querySelector("[id*='customSocialLinkIcon']");
                        // this.applyChildStyleToParent(arrIconParent[i], customSocialLinkIcon);
                    }
                    if (props.ctasocial.contrast) {
                        let socialNodes = this.sgParent.querySelectorAll("[id*='socialIconTextTitle']");
                        for (let a = 0; a < socialNodes.length; a++) {
                            this.applyContrastToText(socialNodes[a], props.ctasocial);
                        }
                        let socialSubNodes = this.sgParent.querySelectorAll("[id*='socialIconTextSubTitle']");
                        for (let a = 0; a < socialSubNodes.length; a++) {
                            this.applyContrastToText(socialSubNodes[a], props.ctasocial);
                        }
                    }
                    if (props.ctasocial.line) {
                        let lineProperty = props.ctasocial.line;
                        if (lineProperty.width) this.assetParent.style.setProperty("--ctaSocialLineWidth", lineProperty.width + (lineProperty.width.includes("%") || lineProperty.width.includes("px") ? "" : "px"));
                        if (lineProperty.height) this.assetParent.style.setProperty("--ctaSocialLineHeight", lineProperty.height + (lineProperty.height.includes("%") || lineProperty.height.includes("px") ? "" : "px"));
                        if (lineProperty.color) this.assetParent.style.setProperty("--ctaSocialLineColor", "rgba(var(--" + lineProperty.color + "-color-rgb),1)");
                        if (lineProperty.opacity) this.assetParent.style.setProperty("--ctaSocialLineOpacity", lineProperty.opacity);
                        if (lineProperty.radius) this.assetParent.style.setProperty("--ctaSocialLineRadius", lineProperty.radius + (lineProperty.radius.includes("%") || lineProperty.radius.includes("px") ? "" : "px"));
                        if (lineProperty.type && lineProperty.type == "dashed") {
                            for (let a = 1; a < 5; a++) {
                                let socialLine = customLinkIconParent.querySelector("[id='socialLine" + a + "']");
                                let bgDirection = (props.ctasocial.aligntype && props.ctasocial.aligntype.includes("vertical")) || !props.ctasocial.aligntype ? "right" : "bottom";
                                socialLine.style.backgroundImage = "linear-gradient(to " + bgDirection + ", rgba(var(--" + lineProperty.color + "-color-rgb),1) 40%, rgba(255, 255, 255, 0) 20%)";
                                socialLine.style.backgroundSize = bgDirection == "bottom" ? "2px 20px" : "10px 20px";
                                this.assetParent.style.setProperty("--ctaSocialLineColor", "unset");
                            }
                        }
                        if (lineProperty.filltype && lineProperty.filltype == "content") {
                            for (let a = 1; a < 6; a++) {
                                let socialLink = customLinkIconParent.querySelector("[id='sgCustomSocialLink" + a + "']");
                                socialLink.classList.add("socialgrow");
                            }
                        }
                        for (let a = 1; a < 6; a++) {
                            let socialLine = customLinkIconParent.querySelector("[id='socialLine" + a + "']");
                            if (socialLine) this.specialGraphicsUtils.setOpacityAttribute(socialLine);
                            if (lineProperty.margin && socialLine) specialgraphicsPropertyUtils.updateMargin(lineProperty.margin, socialLine);
                        }
                    }
                    if (props.ctasocial.iconnodesize) {
                        if (props.ctasocial.iconnodesize.length == 5) customLinkIconParent.setAttribute("iconsize", JSON.stringify(props.ctasocial.iconnodesize));
                        else if (JSON.parse(props.ctasocial.iconnodesize).length == 5) customLinkIconParent.setAttribute("iconsize", props.ctasocial.iconnodesize);
                    }
                    this.arrNodeGapForCTA();
                }
                if (props.venue && this.sgParent.querySelector("[id='sgVenueNode']")) {
                    let sgVenueParent = this.sgParent.querySelector("[id='sgVenueParent']");
                    let sgVenueNode = this.sgParent.querySelector("[id='sgVenueNode']");
                    if (props.venue.position) specialgraphicsPropertyUtils.updatePosition(sgVenueParent, props.venue.position);
                    if (props.venue.maxheight) sgVenueParent.style.maxHeight = props.venue.maxheight + (props.venue.maxheight.includes("px") || props.venue.maxheight.includes("%") ? "" : "px");
                    let vAlign = null;
                    let textAlign = null;
                    let hAlign = null;
                    if (props.venue.halign) {
                        let align = props.venue.halign == "right" || props.venue.halign == "end" ? "end" : props.venue.halign == "center" ? "center" : "start";
                        this.assetParent.style.setProperty("--venueAlign", align);
                        textAlign = align;
                        hAlign = props.venue.halign == "right" || props.venue.halign == "end" ? "flex-end" : props.venue.halign == "center" ? "center" : "flex-start";
                        this.assetParent.style.setProperty("--venueAlignItems", hAlign);
                    }
                    if (props.venue.valign) {
                        vAlign = props.venue.valign == "bottom" || props.venue.valign == "end" ? "flex-end" : props.venue.valign == "center" || props.venue.valign == "middle" ? "center" : "flex-start";
                        this.assetParent.style.setProperty("--venueAlignVItems", vAlign);
                    }
                    if (props.venue.parentclass) this.specialGraphicsUtils.applyClassNamesFromString(sgVenueParent, props.venue.parentclass);
                    if (props.venue.class) this.specialGraphicsUtils.applyClassNamesFromString(sgVenueNode, props.venue.class);
                    if (props.venue.margin) specialgraphicsPropertyUtils.updateMargin(props.venue.margin, sgVenueParent);
                    if (props.venue.padding) specialgraphicsPropertyUtils.updatePadding(props.venue.padding, sgVenueParent, true);

                    let colorValue = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "heading", props.venue.color);
                    // if (!colorValue && props.venue.color) colorValue = "rgba(var(--" + props.venue.color + "-color-rgb),1)";

                    if (colorValue) {
                        this.assetParent.style.setProperty("--venueColor", colorValue);
                        if (sgVenueNode) sgVenueNode.setAttribute("data-color", colorValue);
                    }
                    if (props.venue.bgcolor) this.assetParent.style.setProperty("--venueBgColor", "rgba(var(--" + props.venue.bgcolor + "-color-rgb),1)");
                    if (props.venue.zorder) this.assetParent.style.setProperty("--venueZIndex", props.venue.zorder);
                    if (props.venue.positionvalue) sgVenueParent.style.position = props.venue.positionvalue;
                    if (props.venue.radius) {
                        if (props.venue.radius.includes(",") && props.venue.radius.split(",").length == 4) {
                            let radiusValue = props.venue.radius.split(",");
                            this.assetParent.style.setProperty("--venueRadius", radiusValue[0] + "px " + radiusValue[1] + "px " + radiusValue[2] + "px " + radiusValue[3] + "px");
                        } else this.assetParent.style.setProperty("--venueRadius", props.venue.radius + (props.venue.radius.includes("%") || props.venue.radius.includes("px") ? "" : "px"));
                    }
                    this.applyContrastToText(sgVenueNode, props.venue);
                    if (props.venue.rotate) {
                        let lineHeight = parseFloat(window.getComputedStyle(sgVenueNode)["line-height"]);
                        lineHeight = isNaN(lineHeight) ? "40" : lineHeight;
                        sgVenueNode.style.minWidth = lineHeight + "px";
                        sgVenueNode.classList.add("venueRotation");
                        sgVenueNode.setAttribute("rotatednode", "true");
                        if (props.venue.rotate.includes("-90")) {
                            sgVenueNode.style.setProperty("--rotateTextRotation", "180deg");
                            this.assetParent.style.setProperty("--venueAlignItems", vAlign);
                            this.assetParent.style.setProperty("--venueAlignVItems", hAlign);
                        } else {
                            this.assetParent.style.setProperty("--venueAlignItems", vAlign == "flex-end" ? "flex-start" : vAlign == "flex-start" ? "flex-end" : "center");
                            this.assetParent.style.setProperty("--venueAlignVItems", hAlign);
                        }
                        if (sgVenueNode && textAlign) sgVenueNode.style.setProperty("--rotateTextAlign", textAlign);
                        this.specialGraphicsUtils.doFontFitForCss(sgVenueNode, this.sgParent, null, null, null, true);
                    }
                    if (props.venue.position) {
                        sgVenueParent.style.maxHeight = sgVenueParent.style.height;
                        sgVenueParent.style.height = "auto";
                    }
                }
                if (props.logo && this.sgParent.querySelector("[id='logoImageParent']")) {
                    let logoImageParent = this.sgParent.querySelector("[id='logoImageParent']");
                    let logoContentParent = this.sgParent.querySelector("[id='logoContentParent']");
                    let logoImageNode = this.sgParent.querySelector("[id='sgLogoImageNode']");
                    if (props.logo.logosizestyle) {
                        logoImageParent.setAttribute("data-logosizestyle", props.logo.logosizestyle);
                        if (!logoContentParent.classList.contains("logoSizeStyle")) logoContentParent.classList.add("logoSizeStyle");
                        if (!logoImageParent.classList.contains(props.logo.logosizestyle)) logoImageParent.classList.add(props.logo.logosizestyle);
                    }
                    specialgraphicsPropertyUtils.applyImageBaseProps(props.logo, this.assetParent, logoImageParent, "logo");
                    if (props.logo.positionvalue) this.assetParent.style.setProperty("--logoPosition", props.logo.positionvalue);
                    if (props.logo.zorder) this.assetParent.style.setProperty("--logoImageZorder", props.logo.zorder);

                    if (this.sgData[0] && this.sgData[0].logoimagesize && logoImageNode) logoImageNode.parentElement.setAttribute("data-logoimagesize", this.sgData[0].logoimagesize);
                    this.setLogoSizes();

                    if (this.sgData[0] && this.sgData[0].logoimagesize) {
                        //Implement logo size change from floter
                        // let sizeV = this.sgData[0].logoimagesize;
                        // let multipleValue = sizeV == "small" ? 0.4 : sizeV == "medium" ? 0.7 : sizeV == "large" ? 1 : parseFloat(sizeV);
                        let multipleValue = this.specialGraphicsUtils.getImageSizeSML(this.sgData[0].logoimagesize);
                        let largeW = parseFloat(logoImageParent.getAttribute("data-largewidth"));
                        let largeH = parseFloat(logoImageParent.getAttribute("data-largeheight"));
                        let newW = largeW * multipleValue;
                        let newH = largeH * multipleValue;
                        let cropHeight = logoImageNode && logoImageNode.hasAttribute("logosizecropheight") ? logoImageNode.getAttribute("logosizecropheight") : "";
                        if (newW > 0 && newH > 0) {
                            logoImageParent.style.width = newW + "px";
                            if (cropHeight == "") logoImageParent.style.height = newH + "px";
                        }
                        if (logoImageNode) logoImageNode.removeAttribute("logosizecropheight");
                    }
                    this.applyChildStyleToParent(logoContentParent, logoImageParent);

                    logoContentParent.classList.remove("shapeHolder");
                    if (props.logo.color) {
                        logoContentParent.classList.remove(props.logo.color);
                        logoContentParent.classList.add(props.logo.color);
                        logoContentParent.classList.add("shapeHolder");
                    }
                    if (props.logo.globalstyle && logoContentParent) {
                        logoContentParent.classList.remove(props.logo.globalstyle);
                        logoContentParent.classList.add(props.logo.globalstyle);
                        logoContentParent.classList.add("clsSingleColorParent");

                        let percentValue = window.getComputedStyle(logoContentParent).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
                        percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
                        let sourceNode = logoContentParent.querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
                        if (sourceNode) logoContentParent.style.setProperty("--customNodeBorderImageWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
                    }
                    if (props.logo.contentBG) {
                        let arrAssets = [];
                        arrAssets.push({ parent: logoContentParent, type: "svg", url: props.logo.contentBG.value, id: props.logo.contentBG.id, color: props.logo.contentBG.color });
                        this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
                    }
                    if (logoImageNode) {
                        if (this.sgData[0].logoimagecontrast) {
                            logoImageNode.classList.remove("logoBrightnessSGUnset");
                            if (this.sgData[0].logoimagecontrast == "false") logoImageNode.classList.add("logoBrightnessSGUnset");
                        }
                        this.applyContrastToText(logoImageNode, props.logo);
                    }
                    if (this.sgData && this.sgData[0] && this.sgData[0].logoimageprompt) logoImageParent.setAttribute("data-node-graphic-text", this.sgData[0].logoimageprompt);
                }
                if (props.logo && this.sgParent.querySelector("[id='logoGridParent']")) {
                    let logoImageParent = this.sgParent.querySelector("[id='logoGridParent']");
                    // let logoContentParent = this.sgParent.querySelector("[id='logoGridParent']");
                    // let logoImageNode = this.sgParent.querySelector("[id='sgLogoImageNode']");
                    if (props.logo.logosizestyle) {
                        logoImageParent.setAttribute("data-logosizestyle", props.logo.logosizestyle);
                        if (!logoImageParent.parentElement.classList.contains("logoSizeStyle")) logoImageParent.parentElement.classList.add("logoSizeStyle");
                        if (!logoImageParent.classList.contains(props.logo.logosizestyle)) logoImageParent.classList.add(props.logo.logosizestyle);
                    }
                    specialgraphicsPropertyUtils.applyImageBaseProps(props.logo, this.assetParent, logoImageParent, "logo");
                    // this.applyLogoGridSize(props);
                    if (props.logo.positionvalue) this.assetParent.style.setProperty("--logoPosition", props.logo.positionvalue);
                    if (props.logo.zorder) this.assetParent.style.setProperty("--logoImageZorder", props.logo.zorder);
                    if (props.logo.hposition) this.assetParent.style.setProperty("--logoImageAlignHorizontal", props.logo.hposition == "left" || props.logo.hposition == "start" ? "flex-start" : props.logo.hposition == "right" || props.logo.hposition == "end" ? "flex-end" : "center");

                    if (this.sgData?.[0]?.logoimagesize) logoImageParent.setAttribute("data-logoimagesize", this.sgData[0].logoimagesize);
                    else if (props.logo.logoimagesize) logoImageParent.setAttribute("data-logoimagesize", props.logo.logoimagesize);

                    // this.setLogoSizes();

                    // if (this.sgData[0] && this.sgData[0].logoimagesize) {
                    //     //Implement logo size change from floter
                    //     // let sizeV = this.sgData[0].logoimagesize;
                    //     // let multipleValue = sizeV == "small" ? 0.4 : sizeV == "medium" ? 0.7 : sizeV == "large" ? 1 : parseFloat(sizeV);
                    //     let multipleValue = this.specialGraphicsUtils.getImageSizeSML(this.sgData[0].logoimagesize);
                    //     let largeW = parseFloat(logoImageParent.getAttribute("data-largewidth"));
                    //     let largeH = parseFloat(logoImageParent.getAttribute("data-largeheight"));
                    //     let newW = largeW * multipleValue;
                    //     let newH = largeH * multipleValue;
                    //     let cropHeight = logoImageNode && logoImageNode.hasAttribute("logosizecropheight") ? logoImageNode.getAttribute("logosizecropheight") : "";
                    //     if (newW > 0 && newH > 0) {
                    //         logoImageParent.style.width = newW + "px";
                    //         if (cropHeight == "") logoImageParent.style.height = newH + "px";
                    //     }
                    //     if (logoImageNode) logoImageNode.removeAttribute("logosizecropheight");
                    // }
                    // this.applyChildStyleToParent(logoContentParent, logoImageParent);

                    logoImageParent.classList.remove("shapeHolder");
                    if (props.logo.color) {
                        logoImageParent.classList.remove(props.logo.color);
                        logoImageParent.classList.add(props.logo.color);
                        logoImageParent.classList.add("shapeHolder");
                    }
                    if (props.logo.globalstyle && logoImageParent) {
                        logoImageParent.classList.remove(props.logo.globalstyle);
                        logoImageParent.classList.add(props.logo.globalstyle);
                        logoImageParent.classList.add("clsSingleColorParent");

                        let percentValue = window.getComputedStyle(logoImageParent).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
                        percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
                        let sourceNode = logoImageParent.querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
                        if (sourceNode) logoImageParent.style.setProperty("--customNodeBorderImageWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
                    }
                    if (props.logo.contentBG) {
                        let arrAssets = [];
                        arrAssets.push({ parent: logoImageParent, type: "svg", url: props.logo.contentBG.value, id: props.logo.contentBG.id, color: props.logo.contentBG.color });
                        this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
                    }
                    // if (logoImageNode) {
                    //     if (this.sgData[0].logoimagecontrast) {
                    //         logoImageNode.classList.remove("logoBrightnessSGUnset");
                    //         if (this.sgData[0].logoimagecontrast == "false") logoImageNode.classList.add("logoBrightnessSGUnset");
                    //     }
                    //     this.applyContrastToText(logoImageNode, props.logo);
                    // }
                    if (this.sgData && this.sgData[0] && this.sgData[0].logoimageprompt) logoImageParent.setAttribute("data-node-graphic-text", this.sgData[0].logoimageprompt);

                    // this.applyLogoGridSize(props);
                    // let logogrid = this.objDataToSG && this.objDataToSG.logogrid ? this.objDataToSG.logogrid : null;
                    // let slideId = this.slideContent ? this.slideContent.id : null;
                    // this.createLogoGrid(logoImageParent, logogrid, slideId);
                }
                // if (props.logo1 && this.sgParent.querySelector("[id='logoGridParent1']")) {
                //     let logoImageParent = this.sgParent.querySelector("[id='logoGridParent1']");
                //     if (props.logo1.logosizestyle) {
                //         logoImageParent.setAttribute("data-logosizestyle", props.logo1.logosizestyle);
                //         if (!logoImageParent.parentElement.classList.contains("logoSizeStyle")) logoImageParent.parentElement.classList.add("logoSizeStyle");
                //         if (!logoImageParent.classList.contains(props.logo1.logosizestyle)) logoImageParent.classList.add(props.logo1.logosizestyle);
                //     }
                //     specialgraphicsPropertyUtils.applyImageBaseProps(props.logo1, this.assetParent, logoImageParent, "logo");
                //     // this.applyLogoGridSize(props);
                //     if (props.logo1.positionvalue) this.assetParent.style.setProperty("--logoPosition", props.logo1.positionvalue);
                //     if (props.logo1.zorder) this.assetParent.style.setProperty("--logoImageZorder", props.logo1.zorder);
                //     if (props.logo1.hposition)
                //         this.assetParent.style.setProperty(
                //             "--logoImageAlignHorizontal",
                //             props.logo1.hposition == "left" || props.logo1.hposition == "start" ? "flex-start" : props.logo1.hposition == "right" || props.logo1.hposition == "end" ? "flex-end" : "center"
                //         );

                //     if (this.sgData?.[0]?.logoimagesize) logoImageParent.setAttribute("data-logoimagesize", this.sgData[0].logoimagesize);
                //     else if (props.logo1.logoimagesize) logoImageParent.setAttribute("data-logoimagesize", props.logo1.logoimagesize);

                //     logoImageParent.classList.remove("shapeHolder");
                //     if (props.logo1.color) {
                //         logoImageParent.classList.remove(props.logo1.color);
                //         logoImageParent.classList.add(props.logo1.color);
                //         logoImageParent.classList.add("shapeHolder");
                //     }
                //     if (props.logo1.globalstyle && logoImageParent) {
                //         logoImageParent.classList.remove(props.logo1.globalstyle);
                //         logoImageParent.classList.add(props.logo1.globalstyle);
                //         logoImageParent.classList.add("clsSingleColorParent");

                //         let percentValue = window.getComputedStyle(logoImageParent).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
                //         percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
                //         let sourceNode = logoImageParent.querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
                //         if (sourceNode) logoImageParent.style.setProperty("--customNodeBorderWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
                //     }
                //     if (props.logo1.contentBG) {
                //         let arrAssets = [];
                //         arrAssets.push({ parent: logoImageParent, type: "svg", url: props.logo1.contentBG.value, id: props.logo1.contentBG.id, color: props.logo1.contentBG.color });
                //         this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
                //     }

                //     if (this.sgData && this.sgData[0] && this.sgData[0].logoimageprompt) logoImageParent.setAttribute("data-node-graphic-text", this.sgData[0].logoimageprompt);
                // }
                for (let a = 0; a < 2; a++) {
                    let typeOfImage = a == 0 ? "customer" : "presenter";
                    let logoProp = a == 0 ? props.customerlogo : props.presenterlogo;
                    if (logoProp && this.sgParent.querySelector("[id='" + typeOfImage + "LogoImageParent']")) {
                        let logoImageParent = this.sgParent.querySelector("[id='" + typeOfImage + "LogoImageParent']");
                        let logoContentParent = this.sgParent.querySelector("[id='" + typeOfImage + "LogoContentParent']");
                        let logoImageNode = this.sgParent.querySelector("[id='sg" + (typeOfImage == "customer" ? "Customer" : "Presenter") + "LogoImageNode']");
                        if (logoProp.logosizestyle) {
                            logoImageParent.setAttribute("data-logosizestyle", props[typeOfImage + "logo"].logosizestyle);
                            if (!logoContentParent.classList.contains("logoSizeStyle")) logoContentParent.classList.add("logoSizeStyle");
                            if (!logoImageParent.classList.contains(logoProp.logosizestyle)) logoImageParent.classList.add(logoProp.logosizestyle);
                        }
                        specialgraphicsPropertyUtils.applyImageBaseProps(logoProp, this.assetParent, logoImageParent, typeOfImage + "Logo");
                        if (logoProp.positionvalue) this.assetParent.style.setProperty("--" + typeOfImage + "LogoPosition", logoProp.positionvalue);
                        if (logoProp.zorder) this.assetParent.style.setProperty("--" + typeOfImage + "LogoImageZorder", logoProp.zorder);

                        if (this.sgData[0] && this.sgData[0][typeOfImage + "logoimagesize"] && logoImageNode) logoImageNode.parentElement.setAttribute("data-logoimagesize", this.sgData[0][typeOfImage + "logoimagesize"]);
                        this.setCustomerLogoSizes(a + 1);

                        if (this.sgData[0] && this.sgData[0][typeOfImage + "logoimagesize"]) {
                            //Implement logo size change from floter
                            let multipleValue = this.specialGraphicsUtils.getImageSizeSML(this.sgData[0][typeOfImage + "logoimagesize"]);
                            let largeW = parseFloat(logoImageParent.getAttribute("data-largewidth"));
                            let largeH = parseFloat(logoImageParent.getAttribute("data-largeheight"));
                            let newW = largeW * multipleValue;
                            let newH = largeH * multipleValue;
                            let cropHeight = logoImageNode && logoImageNode.hasAttribute("logosizecropheight") ? logoImageNode.getAttribute("logosizecropheight") : "";
                            if (newW > 0 && newH > 0) {
                                logoImageParent.style.width = newW + "px";
                                if (cropHeight == "") logoImageParent.style.height = newH + "px";
                            }
                            if (logoImageNode) logoImageNode.removeAttribute("logosizecropheight");
                        }
                        this.applyChildStyleToParent(logoContentParent, logoImageParent);
                        logoContentParent.style.margin = logoImageParent.style.margin;
                        logoImageParent.style.margin = "unset";
                        logoContentParent.classList.remove("shapeHolder");
                        if (logoProp.color) {
                            logoContentParent.classList.remove(logoProp.color);
                            logoContentParent.classList.add(logoProp.color);
                            logoContentParent.classList.add("shapeHolder");
                        }
                        if (logoProp.globalstyle && logoContentParent) {
                            logoContentParent.classList.remove(logoProp.globalstyle);
                            logoContentParent.classList.add(logoProp.globalstyle);
                            logoContentParent.classList.add("clsSingleColorParent");

                            let percentValue = window.getComputedStyle(logoContentParent).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
                            percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
                            let sourceNode = logoContentParent.querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
                            if (sourceNode) logoContentParent.style.setProperty("--customNodeBorderImageWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
                        }
                        if (logoProp.contentBG) {
                            let arrAssets = [];
                            arrAssets.push({
                                parent: logoContentParent,
                                type: "svg",
                                url: logoProp.contentBG.value,
                                id: logoProp.contentBG.id,
                                color: logoProp.contentBG.color,
                            });
                            this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
                        }
                        if (logoImageNode) {
                            if (this.sgData[0][typeOfImage + "logoimagecontrast"]) {
                                logoImageNode.classList.remove("logoBrightnessSGUnset");
                                if (this.sgData[0][typeOfImage + "logoimagecontrast"] == "false") logoImageNode.classList.add("logoBrightnessSGUnset");
                            }
                            this.applyContrastToText(logoImageNode, logoProp);
                        }
                        if (this.sgData?.[0]?.[typeOfImage + "logoimageprompt"]) logoImageParent.setAttribute("data-node-graphic-text", this.sgData[0][typeOfImage + "logoimageprompt"]);
                    }
                }
                if (props.image) {
                    let coverImageParent = this.sgParent.querySelector("[id='coverImageParent']");
                    let coverParent = coverImageParent?.querySelector("[id*='coverParent']");
                    let imageNode = coverImageParent ? coverImageParent.querySelector("[data-target-id='coverimage']") : null;
                    if (props.image.positionvalue && coverImageParent) coverImageParent.style.position = props.image.positionvalue;
                    if (props.image.padding && props.image.padding.split(",").length == 4 && coverImageParent) specialgraphicsPropertyUtils.updatePadding(props.image.padding, coverImageParent);

                    if (this.sgData?.[0]?.coverimageprompt && coverParent) coverParent.setAttribute("data-node-graphic-text", this.sgData[0].coverimageprompt);

                    let fixedContrastValue = this.sgData[0] && this.sgData[0].coverimagecontrast ? this.sgData[0].coverimagecontrast : null;
                    if (fixedContrastValue && props.image.contrast) props.image.fixedcontrast = fixedContrastValue == "fixeddarkText" ? "darkText" : fixedContrastValue == "fixedlightText" ? "lightText" : "";
                    let finalHideData = this.sgParent.parentElement.parentElement.getAttribute("data-ogdata-finalhide")?.split(",") || [];
                    let hasVisibleImage = true;
                    if (finalHideData.includes("coverimage")) hasVisibleImage = false;
                    if (!props.image.fixedcontrast && props.image.contrast && props.image.contrast == "fullbg") {
                        if (imageNode) {
                            imageNode.setAttribute("autoimagechange", "true");
                            imageNode.setAttribute("contrast", "fullbg");
                            imageNode.autoImageChange = this.applyContrastOnAutoImageChange;
                            if (hasVisibleImage) this.eventManager.dispatch("applyImageContrast", imageNode, this.assetParent);
                        }
                    } else if (!props.image.fixedcontrast && props.image.contrast && props.image.contrast == "halfbg") {
                        if (imageNode) {
                            imageNode.setAttribute("autoimagechange", "true");
                            imageNode.setAttribute("contrast", "halfbg");
                            imageNode.autoImageChange = this.applyContrastOnAutoImageChange;
                            if (hasVisibleImage) this.eventManager.dispatch("applyImageContrast", imageNode, this.assetParent, true);
                        }
                    } else if (this.slideContent) {
                        if (imageNode) {
                            imageNode.removeAttribute("autoimagechange");
                            imageNode.autoImageChange = null;
                        }
                        this.slideContent.classList.remove("fixedlightText");
                        this.slideContent.classList.remove("fixeddarkText");
                    }
                    if (props.image.fixedcontrast) {
                        this.assetParent.classList.remove("darkText");
                        this.assetParent.classList.remove("lightText");
                        this.assetParent.classList.remove("fixedlightText");
                        this.assetParent.classList.remove("fixeddarkText");
                        this.assetParent.classList.add(props.image.fixedcontrast);
                    }
                    if (props.image.overlayindex && this.applyOverlayToImageSG) if (imageNode && !imageNode.hasAttribute("data-csstext")) this.applyOverlayToImageSG(imageNode, props.image.overlayindex);
                    if (props.image.overlayname && this.applyOverlayToImageSG) if (imageNode && !imageNode.hasAttribute("data-csstext")) this.applyOverlayToImageSG(imageNode, null, props.image.overlayname);
                    if (props.image.globalstyle && coverImageParent) {
                        coverImageParent.classList.remove(props.image.globalstyle);
                        coverImageParent.classList.add(props.image.globalstyle);
                        coverImageParent.classList.add("clsSingleColorParent");

                        let percentValue = window.getComputedStyle(coverImageParent).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
                        percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
                        let sourceNode = coverImageParent.querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
                        if (sourceNode) coverImageParent.style.setProperty("--customNodeBorderImageWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
                    }
                    if (props.image.vposition && coverImageParent) {
                        let align = props.image.vposition == "top" || props.image.vposition == "start" ? "Top" : props.image.vposition == "center" || props.image.vposition == "middle" ? "Center" : "Bottom";
                        coverImageParent.classList.add("coverAlign" + align);
                    }
                } else if (this.slideContent) {
                    this.slideContent.classList.remove("fixedlightText");
                    this.slideContent.classList.remove("fixeddarkText");
                }
                if (props.contact && this.sgParent.querySelector("[id='contactParent']")) {
                    this.hideTextNodes(true);
                    let contactParent = this.sgParent.querySelector("[id='contactParent']");
                    if (props.contact.bgstyle) contactParent.classList.add(props.contact.bgstyle);
                    if (props.contact.position) specialgraphicsPropertyUtils.updatePosition(contactParent, props.contact.position);
                    if (props.contact.textgap) this.assetParent.style.setProperty("--contactGap", props.contact.textgap + (props.contact.textgap.includes("px") ? "" : "px"));
                    if (!props.contact.aligntype) props.contact.aligntype = "vertical";
                    if (props.contact.aligntype) {
                        contactParent.classList.add("contact" + props.contact.aligntype);
                        if (props.contact.aligntype == "grid") {
                            let contactLine1 = contactParent.querySelector("[id='contactLine1']");
                            let contactLine2 = contactParent.querySelector("[id='contactLine2']");
                            if (contactLine1) contactLine1.style.display = "none";
                            if (contactLine2) contactLine2.style.display = "none";
                        }
                    }
                    this.applyTextFormats(props.contact, ["venuepromptText", "creatoremailpromptText", "phonepromptText", "websitepromptText"], ["sgmailingAddress", "sgemailAddress", "sgphoneNumber", "sgwebsite"]);
                    let vAlign = null;
                    if (props.contact.valign) {
                        let alignData = props.contact.valign;
                        vAlign = alignData == "bottom" || alignData == "end" ? "flex-end" : alignData == "center" || alignData == "middle" ? "center" : "flex-start";
                        this.assetParent.style.setProperty("--contactVAlign", vAlign);
                    }
                    if (props.contact.halign) {
                        let hAlign = props.contact.halign == "end" || props.contact.halign == "right" ? "flex-end" : props.contact.halign == "center" || props.contact.halign == "middle" ? "center" : "flex-start";
                        this.assetParent.style.setProperty("--contactHAlign", hAlign);
                    }

                    let contactHeadingColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "heading", props.contact.primarycolor);
                    let contactSecondaryColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "secondary", props.contact.secondarycolor);
                    // if (!contactHeadingColor && props.contact.primarycolor) contactHeadingColor = "rgba(var(--" + props.contact.primarycolor + "-color-rgb),1)";
                    // if (!contactSecondaryColor && props.contact.secondarycolor) contactSecondaryColor = "rgba(var(--" + props.contact.secondarycolor + "-color-rgb),1)";
                    if (contactHeadingColor) {
                        this.assetParent.style.setProperty("--contactPrimaryColor", contactHeadingColor);
                        // sgVenueNode.setAttribute("data-color", contactHeadingColor);
                    }
                    if (contactSecondaryColor) {
                        this.assetParent.style.setProperty("--contactSecondaryColor", contactSecondaryColor);
                        // sgVenueNode.setAttribute("data-color", contactSecondaryColor);
                    }

                    if (props.contact.nodegap) this.assetParent.style.setProperty("--contactNodeGap", props.contact.nodegap);
                    if (props.contact.inbetweentextgap) this.assetParent.style.setProperty("--contactTextGap", props.contact.inbetweentextgap);
                    if (props.contact.maxheight) contactParent.style.maxHeight = props.contact.maxheight + (props.contact.maxheight.includes("px") || props.contact.maxheight.includes("%") ? "" : "px");
                    if (props.contact.padding) specialgraphicsPropertyUtils.updatePadding(props.contact.padding, contactParent, true);
                    if (props.contact.margin) specialgraphicsPropertyUtils.updateMargin(props.contact.margin, contactParent);
                    if (props.contact.iconsize) {
                        let size = props.contact.iconsize == "big" ? "70px" : props.contact.iconsize == "small" ? "40px" : "55px";
                        this.assetParent.style.setProperty("--contactIconSize", size);
                    }
                    if (props.contact.icon && (props.contact.icon == "true" || props.contact.icon == true)) {
                        if (props.contact.iconnodesize) {
                            if (props.contact.iconnodesize.length == 4) contactParent.setAttribute("iconsize", JSON.stringify(props.contact.iconnodesize));
                            else if (this.specialGraphicsUtils.isJson(props.contact.iconnodesize) && JSON.parse(props.contact.iconnodesize).length == 4) contactParent.setAttribute("iconsize", props.contact.iconnodesize);
                        }
                        this.arrNodeGapForContact();

                        this.assetParent.style.setProperty("--contactIconDisplay", "flex");
                        let arrAssets = [];
                        arrAssets.push({ type: "svg", url: "genericassets/socialicons/mail.svg", id: "mail", type: "SVG" });
                        arrAssets.push({ type: "svg", url: "genericassets/socialicons/home.svg", id: "home", type: "SVG" });
                        arrAssets.push({ type: "svg", url: "genericassets/socialicons/phone.svg", id: "phone", type: "SVG" });
                        arrAssets.push({ type: "svg", url: "genericassets/socialicons/web.svg", id: "website", type: "SVG" });
                        this.arrCommonAssets.push({ array: arrAssets, callback: this.assetsLoadComplete });
                    } else {
                        contactParent.setAttribute("data-icon", "disable");
                        this.assetParent.style.setProperty("--contactIconDisplay", "none");
                        let mailingAddresstextParent = this.sgParent.querySelector("[id='mailingAddresstextParent']");
                        if (mailingAddresstextParent) {
                            mailingAddresstextParent.style.maxWidth = "100%";
                            mailingAddresstextParent.style.width = "100%";
                        }
                        let emailAddresstextParent = this.sgParent.querySelector("[id='emailAddresstextParent']");
                        if (emailAddresstextParent) {
                            emailAddresstextParent.style.maxWidth = "100%";
                            emailAddresstextParent.style.width = "100%";
                        }
                        let phoneNumbertextParent = this.sgParent.querySelector("[id='phoneNumbertextParent']");
                        if (phoneNumbertextParent) {
                            phoneNumbertextParent.style.maxWidth = "100%";
                            phoneNumbertextParent.style.width = "100%";
                        }
                        let websitetextParent = this.sgParent.querySelector("[id='websitetextParent']");
                        if (websitetextParent) {
                            websitetextParent.style.maxWidth = "100%";
                            websitetextParent.style.width = "100%";
                        }
                    }
                    if (props.contact.globalstyle) {
                        contactParent.classList.add(props.contact.globalstyle);
                        contactParent.classList.add("clsSingleColorParent");
                    }
                    if (!props.contact.class) props.contact.class = "contact_type1";
                    let sgemailAddressParent = this.sgParent.querySelector("[id='sgemailAddressParent']");
                    let sgphoneNumberParent = this.sgParent.querySelector("[id='sgphoneNumberParent']");
                    let sgmailingAddressParent = this.sgParent.querySelector("[id='sgmailingAddressParent']");

                    if (props.contact.class) {
                        if (sgemailAddressParent) sgemailAddressParent.className = "ctafullnode emailAddressParent " + props.contact.class;
                        if (sgphoneNumberParent) sgphoneNumberParent.className = "ctafullnode phoneNumberParent " + props.contact.class;
                        if (sgmailingAddressParent) sgmailingAddressParent.className = "ctafullnode mailingAddressParent " + props.contact.class;
                        let sgwebsiteParent = this.sgParent.querySelector("[id='sgwebsiteParent']");
                        if (sgwebsiteParent) sgwebsiteParent.className = "ctafullnode websiteParent " + props.contact.class;
                    }
                    if (props.contact.contrast) {
                        let sgphoneNumber = this.sgParent.querySelector("[id='sgphoneNumber']");
                        if (sgphoneNumber) this.applyContrastToText(sgphoneNumber, props.contact);
                        let sgemailAddress = this.sgParent.querySelector("[id='sgemailAddress']");
                        if (sgemailAddress) this.applyContrastToText(sgemailAddress, props.contact);
                        let sgmailingAddress = this.sgParent.querySelector("[id='sgmailingAddress']");
                        if (sgmailingAddress) this.applyContrastToText(sgmailingAddress, props.contact);
                        let sgwebsite = this.sgParent.querySelector("[id='sgwebsite']");
                        if (sgwebsite) this.applyContrastToText(sgwebsite, props.contact);
                        let venuepromptText = this.sgParent.querySelector("[id='venuepromptText']");
                        if (venuepromptText) this.applyContrastToText(venuepromptText, props.contact);
                        let creatoremailpromptText = this.sgParent.querySelector("[id='creatoremailpromptText']");
                        if (creatoremailpromptText) this.applyContrastToText(creatoremailpromptText, props.contact);
                        let phonepromptText = this.sgParent.querySelector("[id='phonepromptText']");
                        if (phonepromptText) this.applyContrastToText(phonepromptText, props.contact);
                        let websitepromptText = this.sgParent.querySelector("[id='websitepromptText']");
                        if (websitepromptText) this.applyContrastToText(websitepromptText, props.contact);
                    }
                    if (props.contact.line) {
                        let lineProperty = props.contact.line;
                        let contactLine1 = contactParent.querySelector("[id='contactLine1']");
                        let contactLine2 = contactParent.querySelector("[id='contactLine2']");
                        if (lineProperty.width) this.assetParent.style.setProperty("--contactLineWidth", lineProperty.width + (lineProperty.width.includes("%") || lineProperty.width.includes("px") ? "" : "px"));
                        if (lineProperty.color) this.assetParent.style.setProperty("--contactLineColor", "rgba(var(--" + lineProperty.color + "-color-rgb),1)");
                        if (lineProperty.opacity) this.assetParent.style.setProperty("--contactLineOpacity", lineProperty.opacity);
                        if (lineProperty.filltype && lineProperty.filltype == "content") {
                            if (sgemailAddressParent) sgemailAddressParent.classList.add("contactgrow");
                            if (sgphoneNumberParent) sgphoneNumberParent.classList.add("contactgrow");
                            if (sgmailingAddressParent) sgmailingAddressParent.classList.add("contactgrow");
                            let sgwebsiteParent = this.sgParent.querySelector("[id='sgwebsiteParent']");
                            if (sgwebsiteParent) sgwebsiteParent.classList.add("contactgrow");
                        }
                        if (lineProperty.radius) this.assetParent.style.setProperty("--contactLineRadius", lineProperty.radius + (lineProperty.radius.includes("%") || lineProperty.radius.includes("px") ? "" : "px"));
                        if (lineProperty.type && lineProperty.type == "dashed" && contactLine1 && contactLine2) {
                            let bgDirection = props.contact.aligntype && props.contact.aligntype.includes("vertical") ? "right" : "bottom";
                            contactLine1.style.backgroundImage = "linear-gradient(to " + bgDirection + ", rgba(var(--" + lineProperty.color + "-color-rgb),1) 40%, rgba(255, 255, 255, 0) 20%)";
                            contactLine1.style.backgroundSize = bgDirection == "bottom" ? "2px 20px" : "10px 20px";
                            contactLine2.style.backgroundImage = "linear-gradient(to " + bgDirection + ", rgba(var(--" + lineProperty.color + "-color-rgb),1) 40%, rgba(255, 255, 255, 0) 20%)";
                            contactLine2.style.backgroundSize = bgDirection == "bottom" ? "2px 20px" : "10px 20px";
                            this.assetParent.style.setProperty("--contactLineColor", "unset");
                        }
                        this.specialGraphicsUtils.setOpacityAttribute(contactLine1);
                        this.specialGraphicsUtils.setOpacityAttribute(contactLine2);
                    }
                    if (props.contact.globalstyle) {
                        contactParent.classList.remove(props.contact.globalstyle);
                        contactParent.classList.add(props.contact.globalstyle);
                        contactParent.classList.add("clsSingleColorParent");
                    }
                    if (props.contact.contentBG) {
                        let arrAssets = [];
                        let phoneNumberIconParent = contactParent.querySelector("[id='phoneNumberIconParent']");
                        if (phoneNumberIconParent) arrAssets.push({ parent: phoneNumberIconParent, type: "svg", url: props.contact.contentBG.value, id: props.contact.contentBG.id, color: props.contact.contentBG.color });
                        let websiteIconParent = contactParent.querySelector("[id='websiteIconParent']");
                        if (websiteIconParent) arrAssets.push({ parent: websiteIconParent, type: "svg", url: props.contact.contentBG.value, id: props.contact.contentBG.id, color: props.contact.contentBG.color });
                        let emailAddressIconParent = contactParent.querySelector("[id='emailAddressIconParent']");
                        if (emailAddressIconParent) arrAssets.push({ parent: emailAddressIconParent, type: "svg", url: props.contact.contentBG.value, id: props.contact.contentBG.id, color: props.contact.contentBG.color });
                        let mailingAddressIconParent = contactParent.querySelector("[id='mailingAddressIconParent']");
                        if (mailingAddressIconParent) arrAssets.push({ parent: mailingAddressIconParent, type: "svg", url: props.contact.contentBG.value, id: props.contact.contentBG.id, color: props.contact.contentBG.color });
                        if (arrAssets.length > 0) this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
                    }
                    if (sgemailAddressParent.contactnodesheightfit) sgemailAddressParent.contactnodesheightfit(sgemailAddressParent);
                    if (sgphoneNumberParent.contactnodesheightfit) sgphoneNumberParent.contactnodesheightfit(sgphoneNumberParent);
                    if (sgmailingAddressParent.contactnodesheightfit) sgmailingAddressParent.contactnodesheightfit(sgmailingAddressParent);
                }
                if (props.reference && this.sgParent.querySelector("[id='referenceParent']")) {
                    this.hideTextNodes(true);
                    let referenceParent = this.sgParent.querySelector("[id='referenceParent']");
                    if (!props.reference.aligntype) props.reference.aligntype = "vertical";
                    if (props.reference.bgstyle) referenceParent.classList.add(props.reference.bgstyle);
                    if (props.reference.aligntype) referenceParent.classList.add("reference" + props.reference.aligntype);
                    if (props.reference.position) specialgraphicsPropertyUtils.updatePosition(referenceParent, props.reference.position);
                    if (props.reference.positionvalue) referenceParent.style.position = props.reference.positionvalue;

                    let referenceHeadingColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "heading", props.reference.primarycolor);
                    let referenceSecondaryColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "secondary", props.reference.secondarycolor);
                    // if (!referenceHeadingColor && props.reference.primarycolor) referenceHeadingColor = "rgba(var(--" + props.reference.primarycolor + "-color-rgb),1)";
                    // if (!referenceSecondaryColor && props.reference.secondarycolor) referenceSecondaryColor = "rgba(var(--" + props.reference.secondarycolor + "-color-rgb),1)";
                    if (referenceHeadingColor) this.assetParent.style.setProperty("--referencePrimaryColor", referenceHeadingColor);
                    if (referenceSecondaryColor) this.assetParent.style.setProperty("--referenceSecondayrColor", referenceSecondaryColor);
                    if (props.reference.inbetweentextgap) this.assetParent.style.setProperty("--referenceTextGap", props.reference.inbetweentextgap);

                    if (props.reference.gridcount) {
                        this.assetParent.style.setProperty("--gridCount", props.reference.gridcount);
                        referenceParent.setAttribute("data-gridcount", props.reference.gridcount);
                    }
                    this.applyTextFormats(props.reference, ["sgreferenceLinkHead1", "sgreferenceLinkHead2", "sgreferenceLinkHead3", "sgreferenceLinkHead4", "sgreferenceLinkHead5"], ["sgreferenceLink1", "sgreferenceLink2", "sgreferenceLink3", "sgreferenceLink4", "sgreferenceLink5"]);
                    if (props.reference.nodegap) this.assetParent.style.setProperty("--referenceNodeGap", props.reference.nodegap);
                    if (props.reference.padding) specialgraphicsPropertyUtils.updatePadding(props.reference.padding, referenceParent, true);
                    if (props.reference.margin) specialgraphicsPropertyUtils.updateMargin(props.reference.margin, referenceParent);
                    if (referenceParent && referenceParent.parentElement && referenceParent.parentElement.style.height == "auto") {
                        let refMainParent = referenceParent.parentElement;
                        let oldHeight = refMainParent.style.height;
                        refMainParent.style.height = refMainParent.style.maxHeight;
                        let refH = parseFloat(refMainParent.offsetHeight);
                        refMainParent.style.height = oldHeight;
                        if (!isNaN(refH) && refH > 0) referenceParent.setAttribute("parentHeight", refH);
                    } else referenceParent.removeAttribute("parentHeight");
                    if (props.reference.maxheight) {
                        let oldparentH = referenceParent.parentElement ? referenceParent.parentElement.style.height : null;
                        if (referenceParent.hasAttribute("parentHeight")) referenceParent.parentElement.style.height = referenceParent.getAttribute("parentHeight") + "px";
                        referenceParent.style.maxHeight = props.reference.maxheight + (props.reference.maxheight.includes("px") || props.reference.maxheight.includes("%") ? "" : "px");
                        let oldHeight = referenceParent.style.height;
                        referenceParent.style.height = props.reference.maxheight + (props.reference.maxheight.includes("px") || props.reference.maxheight.includes("%") ? "" : "px");
                        let refH = parseFloat(referenceParent.offsetHeight);
                        referenceParent.style.height = oldHeight;
                        if (!isNaN(refH) && refH > 0) this.assetParent.style.setProperty("--referenceNodeFullHeight", refH + "px");
                        if (referenceParent.hasAttribute("parentHeight") && oldparentH != null) referenceParent.parentElement.style.height = oldparentH;
                    } else if (referenceParent.hasAttribute("parentHeight")) {
                        let refMainParent = referenceParent.parentElement;
                        let oldHeight = refMainParent.style.height;
                        refMainParent.style.height = referenceParent.getAttribute("parentHeight") + "px";
                        let refH = parseFloat(referenceParent.offsetHeight);
                        refMainParent.style.height = oldHeight;
                        if (!isNaN(refH) && refH > 0) this.assetParent.style.setProperty("--referenceNodeFullHeight", refH + "px");
                    }

                    if (props.reference.valign) {
                        let alignData = props.reference.valign;
                        let vAlign = alignData == "bottom" || alignData == "end" ? "flex-end" : alignData == "center" || alignData == "middle" ? "center" : "flex-start";
                        this.assetParent.style.setProperty("--referenceVAlign", vAlign);
                    } else this.assetParent.style.setProperty("--referenceVAlign", "flex-start");
                    if (props.reference.halign) {
                        let hAlign = props.reference.halign == "end" || props.reference.halign == "right" ? "flex-end" : props.reference.halign == "center" ? "center" : "flex-start";
                        this.assetParent.style.setProperty("--referenceHAlign", hAlign);
                        this.assetParent.style.setProperty("--referenceTextAlign", hAlign.includes("end") ? "end" : hAlign.includes("center") ? "center" : "start");
                    }
                    for (let a = 1; a < 5; a++) {
                        let referenceNodes = this.sgParent.querySelector("[id='sgreferenceLinkHead" + a + "']");
                        let referenceNodesSub = this.sgParent.querySelector("[id='sgreferenceLink" + a + "']");
                        if (props.reference.contrast) {
                            this.applyContrastToText(referenceNodes, props.reference);
                            this.applyContrastToText(referenceNodesSub, props.reference);
                        }

                        if (referenceHeadingColor && referenceNodes) referenceNodes.setAttribute("data-color", referenceHeadingColor);
                        if (referenceSecondaryColor && referenceNodesSub) referenceNodesSub.setAttribute("data-color", referenceSecondaryColor);

                        if (props.reference.primaryclass) this.specialGraphicsUtils.applyClassNamesFromString(referenceNodes, props.reference.primaryclass);
                        if (props.reference.secondaryclass) this.specialGraphicsUtils.applyClassNamesFromString(referenceNodesSub, props.reference.secondaryclass);
                        if (referenceNodesSub) {
                            let lh = parseFloat(window.getComputedStyle(referenceNodesSub)["line-height"]);
                            referenceParent.style.setProperty("--minH", lh + "px");
                        }
                    }
                    if (props.reference.line) {
                        let lineProperty = props.reference.line;
                        if (lineProperty.width) this.assetParent.style.setProperty("--referenceLineWidth", lineProperty.width + (lineProperty.width.includes("%") || lineProperty.width.includes("px") ? "" : "px"));
                        if (lineProperty.color) this.assetParent.style.setProperty("--referenceLineColor", "rgba(var(--" + lineProperty.color + "-color-rgb),1)");
                        if (lineProperty.opacity) this.assetParent.style.setProperty("--referenceLineOpacity", lineProperty.opacity);
                        if (lineProperty.radius) this.assetParent.style.setProperty("--referenceLineRadius", lineProperty.radius + (lineProperty.radius.includes("%") || lineProperty.radius.includes("px") ? "" : "px"));
                        if (lineProperty.type && lineProperty.type == "dashed") {
                            for (let a = 1; a < 4; a++) {
                                let referenceLine = referenceParent.querySelector("[id='referenceLine" + a + "']");
                                if (referenceLine) {
                                    let bgDirection = (props.reference.aligntype && props.reference.aligntype.includes("vertical")) || !props.reference.aligntype ? "right" : "bottom";
                                    referenceLine.style.backgroundImage = "linear-gradient(to " + bgDirection + ", rgba(var(--" + lineProperty.color + "-color-rgb),1) 40%, rgba(255, 255, 255, 0) 20%)";
                                    referenceLine.style.backgroundSize = bgDirection == "bottom" ? "2px 20px" : "10px 20px";
                                }
                            }
                            this.assetParent.style.setProperty("--referenceLineColor", "unset");
                        }
                        if (lineProperty.filltype && lineProperty.filltype == "content") {
                            for (let a = 1; a < 5; a++) {
                                let socialLink = referenceParent.querySelector("[id='sgreferenceLink" + a + "Parent']");
                                socialLink.classList.add("referencegrow");
                            }
                        }
                        for (let a = 1; a < 5; a++) {
                            let referenceLine = referenceParent.querySelector("[id='referenceLine" + a + "']");
                            if (referenceLine) this.specialGraphicsUtils.setOpacityAttribute(referenceLine);
                        }
                    }
                    if (props.reference.arrnodegap) {
                        let arrGapData = null;
                        if (props.reference.arrnodegap.length == 4) arrGapData = props.reference.arrnodegap;
                        else if (JSON.parse(props.reference.arrnodegap).length == 4) arrGapData = JSON.parse(props.reference.arrnodegap);
                        if (arrGapData && arrGapData.length == 4) {
                            let arrRefLink = this.sgParent.querySelectorAll("[id*='sgreferenceLink']");
                            let nodesCount = 4;
                            for (let a = 0; a < arrRefLink.length; a++) {
                                if (arrRefLink[a].style.display == "none" && arrRefLink[a].id.includes("sgreferenceLink") && arrRefLink[a].id.includes("Parent")) nodesCount = nodesCount - 1;
                            }
                            if (nodesCount) nodesCount = nodesCount - 1;
                            if (arrGapData[nodesCount])
                                for (let a = 0; a < arrRefLink.length; a++) {
                                    if (arrRefLink[a].id.includes("sgreferenceLink") && arrRefLink[a].id.includes("Parent")) arrRefLink[a].style.setProperty("--referenceNodeGap", arrGapData[nodesCount] + "px");
                                }
                        }
                    }
                    if (props.reference.maxheight) {
                        let oldparentH = referenceParent.parentElement.style.height;
                        if (referenceParent.parentElement.style.height == "auto") referenceParent.parentElement.style.height = referenceParent.parentElement.style.maxHeight;

                        referenceParent.style.maxHeight = props.reference.maxheight + (props.reference.maxheight.includes("px") || props.reference.maxheight.includes("%") ? "" : "px");
                        let oldHeight = referenceParent.style.height;
                        referenceParent.style.height = referenceParent.style.maxHeight;
                        let nodeHeight = parseFloat(window.getComputedStyle(referenceParent).height) / 4;
                        this.assetParent.style.setProperty("--referenceNodeHeight", nodeHeight + "px");
                        referenceParent.style.height = oldHeight;

                        if (referenceParent.parentElement.style.height == "auto") referenceParent.parentElement.style.height = oldparentH;
                    }
                    if (referenceParent.parentElement.style.height == "auto") {
                        let fullHeight = window.getComputedStyle(referenceParent.parentElement).height;
                        if (!isNaN(parseFloat(fullHeight)) && parseFloat(fullHeight) > 0) {
                            let singleNodeHeight = parseFloat(fullHeight) / 4;
                            this.assetParent.style.setProperty("--referenceNodeHeight", singleNodeHeight + "px");
                        }
                    }
                }
                if (props.image) {
                    let hasSVG = this.sgData[0].coverimage.includes(".svg");
                    if (props.image.supportsvg && props.image.supportsvg == "false" && hasSVG) {
                        this.sgData[0].coverimage = this.appStaticURL + "genericassets/placeholderimages/coverimage.jpg";
                        this.sgParent.removeAttribute("data-svgsupport");
                        hasSVG = false;
                        if (this.sgParent.parentElement.parentElement) {
                            let slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
                            if (slideDomContentGroup.getElementsByTagName("coverimage").length > 0) slideDomContentGroup.getElementsByTagName("coverimage")[0].setAttribute("data-src", this.sgData[0].coverimage);
                        }
                    }

                    // if (props.image && props.image.supportsvg) {
                    let arrAssets = [];
                    // if (this.sgData[0].coverimageillustration) this.sgData[0].coverimage = this.sgData[0].coverimageillustration;
                    // let hasSVG = props.image.supportsvg == "true" || props.image.supportsvg == true ? true : false;
                    // let path = this.sgData[0].coverimage.includes(".svg") ? this.sgData[0].coverimage : "genericassets/illustrations/industry_agnostic/breaker_slide/breaker_slide_2.svg";
                    // if (!this.sgData[0].coverimage.includes(".svg") && this.sgData[0].coverimage.includes(".svg") && this.sgParent.parentElement.parentElement) {
                    //     let slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
                    //     if (slideDomContentGroup.getElementsByTagName("coverimage").length > 0) {
                    //         slideDomContentGroup.getElementsByTagName("coverimage")[0].setAttribute("data-src", this.sgData[0].coverimage);
                    //     }
                    // }
                    if (hasSVG == true) {
                        arrAssets.push({ url: this.sgData[0].coverimage, id: "svgdata", type: "SVG" });
                        this.arrCommonAssets.push({ array: arrAssets, callback: this.assetsLoadComplete });
                    }

                    let svgElementDiv = this.sgParent.querySelector("[id='svgElementDiv']");
                    let coverimage = this.sgParent.querySelector("[data-target-id='coverimage']");
                    if (svgElementDiv && coverimage) {
                        svgElementDiv.style.display = hasSVG ? "flex" : "none";
                        coverimage.style.display = hasSVG ? "none" : "flex";
                    }
                    // } else if (this.sgData[0] && this.sgData[0].coverimage && this.sgData[0].coverimage.includes(".svg")) {
                    //     this.sgData[0].coverimageillustration = this.sgData[0].coverimage;
                    //     this.sgData[0].coverimage = this.appStaticURL + "genericassets/placeholderimages/coverimage.jpg";
                    //     if (this.sgSlideType && this.sgSlideType == "sectionbreak") this.sgData[0].coverimage = this.appStaticURL + "genericassets/images/app/sectionbreak.jpg";
                    //     let svgElementDiv = this.sgParent.querySelector("[id='svgElementDiv']");
                    //     let coverimage = this.sgParent.querySelector("[data-target-id='coverimage']");
                    //     if (svgElementDiv) svgElementDiv.style.display = "none";
                    //     if (coverimage) {
                    //         coverimage.style.display = "block";
                    //         coverimage.src = this.sgData[0].coverimage;
                    //     }
                    //     if (this.sgParent.parentElement.parentElement) {
                    //         let slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
                    //         if (slideDomContentGroup.getElementsByTagName("coverimage").length > 0) {
                    //             slideDomContentGroup.getElementsByTagName("coverimage")[0].setAttribute("data-src", this.sgData[0].coverimage);
                    //         }
                    //     }
                    // }
                }
                if (props.authtext && this.sgParent.querySelector("[id='authorParent']")) {
                    this.hideTextNodes();
                    this.applyAuthTextPropertyCommon(props.authtext, this.assetParent, specialgraphicsPropertyUtils);
                }
                if (props.authimg && this.sgParent.querySelector("[id='authorImageParent']")) {
                    this.hideTextNodes();
                    this.applyAuthImagePropertyCommon(props.authimg, this.assetParent, specialgraphicsPropertyUtils, 0);
                }
                for (let i = 1; i < 4; i++) {
                    let iconProperty = props["quoteicon" + i];
                    iconProperty = !iconProperty ? props["quoteicon"] : iconProperty;
                    if (iconProperty) {
                        this.hideTextNodes();
                        if (iconProperty && this.sgParent.querySelector("[id='quoteParent" + i + "']")) {
                            let quoteParent = this.sgParent.querySelector("[id='quoteParent" + i + "']");
                            let quoteIcon = quoteParent.querySelector("[id*='quoteIcon']");
                            if (iconProperty.position) specialgraphicsPropertyUtils.updatePosition(quoteParent, iconProperty.position);
                            quoteParent.style.minHeight = quoteParent.style.height;
                            if (iconProperty.positionvalue) quoteParent.style.position = iconProperty.positionvalue;
                            let propIndex = i == 1 ? "" : i;
                            if (iconProperty.color) this.assetParent.style.setProperty("--quoteIcon" + propIndex + "Color", "rgba(var(--" + iconProperty.color + "-color-rgb),1)");
                            else this.assetParent.style.setProperty("--quoteIcon" + propIndex + "Color", "rgba(var(--icon-color-rgb),1)");
                            if (iconProperty.opacity) this.assetParent.style.setProperty("--quoteIcon" + propIndex + "Opacity", iconProperty.opacity);
                            if (iconProperty.iconwidth) this.assetParent.style.setProperty("--quoteIcon" + propIndex + "Width", iconProperty.iconwidth + (iconProperty.iconwidth.includes("%") || iconProperty.iconwidth.includes("px") ? "" : "px"));
                            if (iconProperty.iconheight) this.assetParent.style.setProperty("--quoteIcon" + propIndex + "Height", iconProperty.iconheight + (iconProperty.iconheight.includes("%") || iconProperty.iconheight.includes("px") ? "" : "px"));
                            if (iconProperty.bgcolor) {
                                if (iconProperty.bgcolor.includes("gradient")) {
                                    quoteParent.style.backgroundColor = "unset";
                                    quoteParent.style.background = iconProperty.bgcolor;
                                } else quoteParent.style.backgroundColor = "rgba(var(--" + iconProperty.bgcolor + "-color-rgb),1)";
                            }
                            if (iconProperty.padding && quoteIcon) specialgraphicsPropertyUtils.updatePadding(iconProperty.padding, quoteParent);
                            if (iconProperty.margin && quoteIcon) specialgraphicsPropertyUtils.updateMargin(iconProperty.margin, quoteParent);
                            if (iconProperty.radius) quoteParent.style.borderRadius = iconProperty.radius;
                            if (iconProperty.border) quoteParent.style.borderRadius = iconProperty.border;
                            if (iconProperty.zorder) quoteParent.style.zIndex = iconProperty.zorder;
                            if (iconProperty.rotate) quoteIcon.style.transform = iconProperty.rotate;
                            if (iconProperty.outline && (iconProperty.outline == "true" || iconProperty.outline == true)) quoteParent.classList.add("quoteoutline");
                            else quoteParent.classList.remove("quoteoutline");
                            if (iconProperty.imageborder) {
                                quoteParent.style.border = "double " + iconProperty.imageborder.replace("gradient", "") + "transparent";
                                quoteParent.style.backgroundImage = "linear-gradient(rgba(var(--bg-color-rgb),1), rgba(var(--bg-color-rgb),1)), radial-gradient(circle at bottom right, rgba(var(--item6-color-rgb),1), rgba(var(--item1-color-rgb),1))";
                                quoteParent.style.backgroundOrigin = "border-box";
                                quoteParent.style.backgroundClip = "content-box, border-box";
                            }
                            if (iconProperty.globalstyle) {
                                quoteParent.classList.add(iconProperty.globalstyle);
                                quoteParent.classList.add("clsSingleColorParent");
                            }
                            let quotePath = iconProperty.path ? iconProperty.path : "moods/" + this.moodName + "/" + this.moodName + "quote.svg";
                            quotePath = "moods/" + this.moodName + "/" + this.moodName + "quote.svg";
                            let arrAssets = [];
                            arrAssets.push({ url: quotePath, id: "quoteIcon", type: "SVG", parentId: "quoteIcon" + i });
                            this.arrCommonAssets.push({ array: arrAssets, callback: this.assetsLoadComplete });

                            if (iconProperty.contentBG) {
                                arrAssets = [];
                                arrAssets.push({ parent: quoteParent, type: "svg", url: iconProperty.contentBG.value, id: iconProperty.contentBG.id, color: iconProperty.contentBG.color });
                                this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
                            }
                            this.applyContrastToText(quoteParent, iconProperty);
                        }
                    }
                }
                let quotePlaceHolderProp = props.quotetakeaway ? props.quotetakeaway : props.quotetitle ? props.quotetitle : null;
                if (quotePlaceHolderProp && this.sgParent.querySelector("[id='quotePlaceHolderParent']")) {
                    let takeawayParent = this.sgParent.querySelector("[id='quotePlaceHolderParent']");
                    let sgQuoteTextNode = this.sgParent.querySelector("[id='sgQuoteTextNode']");
                    sgQuoteTextNode = sgQuoteTextNode ? sgQuoteTextNode : this.sgParent.querySelector("[id='sgQuoteTextAwayNode']");
                    if (quotePlaceHolderProp.position) specialgraphicsPropertyUtils.updatePosition(takeawayParent, quotePlaceHolderProp.position);
                    if (quotePlaceHolderProp.maxheight) takeawayParent.style.maxHeight = quotePlaceHolderProp.maxheight + (quotePlaceHolderProp.maxheight.includes("px") || quotePlaceHolderProp.maxheight.includes("%") ? "" : "px");
                    if (quotePlaceHolderProp.positionvalue) takeawayParent.style.position = quotePlaceHolderProp.positionvalue;

                    let colorValue = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "heading", quotePlaceHolderProp.color);
                    // if (!colorValue && quotePlaceHolderProp.color) colorValue = "rgba(var(--" + quotePlaceHolderProp.color + "-color-rgb),1)";

                    if (colorValue) {
                        this.assetParent.style.setProperty("--quotePlaceholderColor", colorValue);
                        if (sgQuoteTextNode) sgQuoteTextNode.setAttribute("data-color", colorValue);
                    }
                    if (quotePlaceHolderProp.class) this.specialGraphicsUtils.applyClassNamesFromString(sgQuoteTextNode, quotePlaceHolderProp.class);
                    if (quotePlaceHolderProp.parentclass) this.specialGraphicsUtils.applyClassNamesFromString(takeawayParent, quotePlaceHolderProp.parentclass);
                    if (quotePlaceHolderProp.bgcolor) {
                        if (quotePlaceHolderProp.bgcoloropacity) {
                            takeawayParent.style.backgroundColor = "rgba(rgba(var(--" + quotePlaceHolderProp.bgcolor + "-color-rgb)," + quotePlaceHolderProp.bgcoloropacity + ")";
                        } else {
                            if (quotePlaceHolderProp.bgcolor.includes("gradient")) takeawayParent.style.background = quotePlaceHolderProp.bgcolor;
                            else takeawayParent.style.backgroundColor = "rgba(var(--" + quotePlaceHolderProp.bgcolor + "-color-rgb),1)";
                        }
                    }
                    if (quotePlaceHolderProp.padding) specialgraphicsPropertyUtils.updatePadding(quotePlaceHolderProp.padding, takeawayParent);
                    if (quotePlaceHolderProp.margin) specialgraphicsPropertyUtils.updateMargin(quotePlaceHolderProp.margin, takeawayParent);
                    let textAlign = null;
                    let hAlign = null;
                    let vAlign = null;
                    if (quotePlaceHolderProp.halign) {
                        hAlign = quotePlaceHolderProp.halign == "end" || quotePlaceHolderProp.halign == "right" ? "flex-end" : quotePlaceHolderProp.halign == "center" ? "center" : "flex-start";
                        this.assetParent.style.setProperty("--quotePlaceholderHAlign", hAlign);
                        textAlign = hAlign.includes("end") ? "end" : hAlign.includes("center") ? "center" : "start";
                        this.assetParent.style.setProperty("--quotePlaceholderAlign", textAlign);
                    }
                    if (quotePlaceHolderProp.valign) {
                        vAlign = quotePlaceHolderProp.valign == "end" || quotePlaceHolderProp.valign == "bottom" ? "flex-end" : quotePlaceHolderProp.valign == "center" || quotePlaceHolderProp.valign == "middle" ? "center" : "flex-start";
                        this.assetParent.style.setProperty("--quotePlaceholderVAlign", vAlign);
                    }
                    if (quotePlaceHolderProp.border) this.assetParent.style.setProperty("--quotePlaceholderBorder", quotePlaceHolderProp.border);
                    if (quotePlaceHolderProp.zorder) takeawayParent.style.zIndex = quotePlaceHolderProp.zorder;
                    // if (quotePlaceHolderProp.linecount && sgQuoteTextNode) {
                    //     sgQuoteTextNode.setAttribute("data-linecount", quotePlaceHolderProp.linecount);
                    //     this.specialGraphicsUtils.doFontFitForCss(sgQuoteTextNode, this.sgParent);
                    // }

                    if (quotePlaceHolderProp.rotate && sgQuoteTextNode) {
                        let lineHeight = parseFloat(window.getComputedStyle(sgQuoteTextNode)["line-height"]);
                        lineHeight = isNaN(lineHeight) ? "40" : lineHeight;
                        takeawayParent.style.minWidth = lineHeight + "px";
                        takeawayParent.classList.add("quoteTitleRotation");
                        sgQuoteTextNode.setAttribute("rotatednode", "true");
                        if (quotePlaceHolderProp.rotate.includes("-90")) {
                            takeawayParent.style.setProperty("--rotateTextRotation", "180deg");
                            this.assetParent.style.setProperty("--quotePlaceholderHAlign", vAlign == "flex-end" ? "flex-start" : vAlign == "flex-start" ? "flex-end" : "center");
                            this.assetParent.style.setProperty("--quotePlaceholderVAlign", hAlign);
                        } else {
                            this.assetParent.style.setProperty("--quotePlaceholderHAlign", vAlign);
                            this.assetParent.style.setProperty("--quotePlaceholderVAlign", hAlign);
                        }
                        if (takeawayParent && textAlign) takeawayParent.style.setProperty("--rotateTextAlign", textAlign);
                        this.specialGraphicsUtils.doFontFitForCss(sgQuoteTextNode, this.sgParent, null, null, null, true);
                    }
                    if (sgQuoteTextNode.commonheightfit) sgQuoteTextNode.commonheightfit(sgQuoteTextNode);
                    this.applyContrastToText(sgQuoteTextNode, quotePlaceHolderProp);
                }

                //Presented By, Presented To, Presenter company, Customer company
                this.applySingleNodesProperties(props.presentedby, "PresentedBy", "presentedBy", this.assetParent);
                this.applySingleNodesProperties(props.presentedto, "PresentedTo", "presentedTo", this.assetParent);
                this.applySingleNodesProperties(props.presentercompany, "PresenterCompany", "presenterCompany", this.assetParent);
                this.applySingleNodesProperties(props.venuetitle, "VenueTitle", "venueTitle", this.assetParent);
                this.applySingleNodesProperties(props.datetitle, "DateTitle", "dateTitle", this.assetParent);
                this.applySingleNodesProperties(props.authortitle, "AuthorTitle", "authorTitle", this.assetParent);
                this.applySingleNodesProperties(props.websitelink, "WebsiteLink", "websiteLink", this.assetParent);
                this.applySingleNodesProperties(props.customercompany, "CustomerCompany", "customerCompany", this.assetParent);

                let bgImageProp = props.bgimage ? props.bgimage : props.bgimage1;
                if (bgImageProp && this.sgParent.querySelector("[id='bgImage']")) {
                    let bgImage = this.sgParent.querySelector("[id='bgImage']");
                    if ((bgImageProp.loop == "false" || bgImageProp.loop == false) && bgImage) bgImage.loop = "false";
                    if (bgImageProp.positionvalue && bgImage) bgImage.style.position = bgImageProp.positionvalue;
                    if (bgImageProp.imageurl && bgImage) bgImage.src = this.appStaticURL + bgImageProp.imageurl;
                    specialgraphicsPropertyUtils.applyImageBaseProps(bgImageProp, this.assetParent, bgImage, "bg");
                    if (bgImageProp.contrast && bgImageProp.contrast == "fullbg") {
                        if (bgImage) {
                            bgImage.setAttribute("contrast", "fullbg");
                            this.eventManager.dispatch("applyImageContrast", bgImage, this.assetParent);
                        }
                    } else if (bgImageProp.contrast && bgImageProp.contrast == "halfbg") {
                        if (bgImage) {
                            bgImage.setAttribute("contrast", "halfbg");
                            this.eventManager.dispatch("applyImageContrast", bgImage, this.assetParent, true);
                        }
                    } else if (this.slideContent) {
                        this.slideContent.classList.remove("fixedlightText");
                        this.slideContent.classList.remove("fixeddarkText");
                    }
                    if (bgImageProp.fixedcontrast) {
                        this.assetParent.classList.remove("darkText");
                        this.assetParent.classList.remove("lightText");
                        this.assetParent.classList.remove("fixedlightText");
                        this.assetParent.classList.remove("fixeddarkText");
                        this.assetParent.classList.add(bgImageProp.fixedcontrast);
                        // this.assetParent.setAttribute("highlight", "false");
                    }
                }
                if (props.presetimage && this.sgParent.querySelector("[id='presetImageContentParent']")) {
                    let presetImageContentParent = this.sgParent.querySelector("[id='presetImageContentParent']");
                    let presetImageNode = this.sgParent.querySelector("[id='sgpresetImageNode']");
                    if (props.presetimage.positionvalue && presetImageContentParent) presetImageContentParent.style.position = props.presetimage.positionvalue;
                    if (props.presetimage.imageurl && presetImageNode) {
                        let coverImageURL = this.sgData[0].presetimage;
                        if (coverImageURL != "") presetImageNode.src = coverImageURL;
                        else presetImageNode.src = this.appStaticURL + props.presetimage.imageurl;
                    }
                    if (this.objDataToSG.assetGroupingId) presetImageNode.setAttribute("assetGroupingId", this.objDataToSG.assetGroupingId);
                    specialgraphicsPropertyUtils.applyImageBaseProps(props.presetimage, this.assetParent, presetImageContentParent, "preset");
                    if (props.presetimage.contrast && props.presetimage.contrast == "fullbg") {
                        if (presetImageNode) {
                            presetImageNode.setAttribute("contrast", "fullbg");
                            this.eventManager.dispatch("applyImageContrast", presetImageNode, this.assetParent);
                        }
                    } else if (props.presetimage.contrast && props.presetimage.contrast == "halfbg") {
                        if (presetImageNode) {
                            presetImageNode.setAttribute("contrast", "halfbg");
                            this.eventManager.dispatch("applyImageContrast", presetImageNode, this.assetParent, true);
                        }
                    } else if (this.slideContent) {
                        this.slideContent.classList.remove("fixedlightText");
                        this.slideContent.classList.remove("fixeddarkText");
                    }
                    if (props.presetimage.borderoption) presetImageContentParent.setAttribute("borderoption", props.presetimage.borderoption == "enable" ? "true" : "false");

                    if (props.presetimage.fixedcontrast) {
                        this.assetParent.classList.remove("darkText");
                        this.assetParent.classList.remove("lightText");
                        this.assetParent.classList.remove("fixedlightText");
                        this.assetParent.classList.remove("fixeddarkText");
                        this.assetParent.classList.add(props.presetimage.fixedcontrast);
                        // this.assetParent.setAttribute("highlight", "false");
                    }
                    presetImageContentParent.style.setProperty("--presetImageWidth", presetImageContentParent.style.width);
                    presetImageContentParent.style.setProperty("--presetImageHeight", presetImageContentParent.style.height);

                    if (presetImageNode) {
                        presetImageNode.setAttribute("data-width", parseFloat(window.getComputedStyle(presetImageContentParent).width));
                        presetImageNode.setAttribute("data-height", parseFloat(window.getComputedStyle(presetImageContentParent).height));
                        presetImageNode.setAttribute("data-x", parseFloat(window.getComputedStyle(presetImageContentParent).left));
                        presetImageNode.setAttribute("data-y", parseFloat(window.getComputedStyle(presetImageContentParent).top));
                    }
                    let menuJson = this.objDataToSG && this.objDataToSG.menufromjson ? this.objDataToSG.menufromjson : null;
                    if (menuJson && menuJson.floateroptions && menuJson.floateroptions.includes("imagebleed") && presetImageContentParent) {
                        presetImageContentParent.setAttribute("imagebleedoption", "true");
                        if (!this.sgData[0]["presetimageimagebleed"] && menuJson.floateroptionsenable && menuJson.floateroptionsenable.includes("imagebleed")) {
                            var slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
                            if (slideDomContentGroup && slideDomContentGroup.getElementsByTagName("node-0").length > 0) {
                                let nodeData = slideDomContentGroup.getElementsByTagName("node-0")[0];
                                let nodeDataList = nodeData.getElementsByTagName("presetimage")[0];
                                if (nodeDataList) nodeDataList.setAttribute("imagebleed", "true");
                            }
                        }
                    }
                }
                if (props.footer && this.sgParent.querySelector("[id='sgFooterParent']")) {
                    let sgFooterParent = this.sgParent.querySelector("[id='sgFooterParent']");
                    let sgFooterNode = this.sgParent.querySelector("[id='sgFooterNode']");
                    if (props.footer.position) specialgraphicsPropertyUtils.updatePosition(sgFooterParent, props.footer.position);
                    if (props.footer.positionvalue) sgFooterParent.style.position = props.footer.positionvalue;
                    if (props.footer.zorder) sgFooterParent.style.zIndex = props.footer.zorder;

                    let colorValue = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "source", props.footer.color);
                    // if (!colorValue && props.footer.color) colorValue = "rgba(var(--" + props.footer.color + "-color-rgb),1)";
                    if (colorValue) {
                        this.assetParent.style.setProperty("--sgFooterColor", colorValue);
                        if (sgFooterNode) sgFooterNode.setAttribute("data-color", colorValue);
                    }
                    if (props.footer.class) this.specialGraphicsUtils.applyClassNamesFromString(sgFooterNode, props.footer.class);
                    if (props.footer.parentclass) this.specialGraphicsUtils.applyClassNamesFromString(sgFooterParent, props.footer.parentclass);

                    if (props.footer.globalstyle) {
                        sgFooterParent.classList.remove(props.footer.globalstyle);
                        sgFooterParent.classList.add(props.footer.globalstyle);
                        sgFooterParent.classList.add("clsSingleColorParent");
                    }
                    if (props.footer.opacity) {
                        sgFooterParent.style.opacity = props.footer.opacity;
                        this.specialGraphicsUtils.setOpacityAttribute(sgFooterParent);
                    }
                    if (props.footer.bgcolor) {
                        if (props.footer.bgcoloropacity) {
                            sgFooterParent.style.backgroundColor = "rgba(var(--" + props.footer.bgcolor + "-color-rgb)," + props.footer.bgcoloropacity + ")";
                        } else sgFooterParent.style.backgroundColor = "rgba(var(--" + props.footer.bgcolor + "-color-rgb),1)";
                    }
                    if (props.footer.padding) specialgraphicsPropertyUtils.updatePadding(props.footer.padding, sgFooterParent, true);
                    if (props.footer.margin) specialgraphicsPropertyUtils.updateMargin(props.footer.margin, sgFooterParent);
                    let textAlign = null;
                    let hAlign = null;
                    if (props.footer.halign) {
                        hAlign = props.footer.halign == "end" || props.footer.halign == "right" ? "flex-end" : props.footer.halign == "center" ? "center" : "flex-start";
                        this.assetParent.style.setProperty("--sgFooterHAlign", hAlign);
                        textAlign = hAlign.includes("end") ? "end" : hAlign.includes("center") ? "center" : "start";
                        this.assetParent.style.setProperty("--sgFooterAlign", textAlign);
                    }
                    let vAlign = null;
                    if (props.footer.valign) {
                        vAlign = props.footer.valign == "end" || props.footer.valign == "bottom" ? "flex-end" : props.footer.valign == "center" || props.footer.valign == "middle" ? "center" : "flex-start";
                        this.assetParent.style.setProperty("--sgFooterVAlign", vAlign);
                    }
                    if (props.footer.rotate && sgFooterNode) {
                        let lineHeight = parseFloat(window.getComputedStyle(sgFooterNode)["line-height"]);
                        lineHeight = isNaN(lineHeight) ? "40" : lineHeight;
                        sgFooterNode.style.minWidth = lineHeight + "px";
                        sgFooterNode.classList.add("footerRotation");
                        sgFooterNode.setAttribute("rotatednode", "true");
                        if (props.footer.rotate.includes("-90")) {
                            sgFooterNode.style.setProperty("--rotateFooterTextRotation", "180deg");
                            this.assetParent.style.setProperty("--sgFooterHAlign", vAlign);
                            this.assetParent.style.setProperty("--sgFooterVAlign", hAlign);
                        } else {
                            this.assetParent.style.setProperty("--sgFooterHAlign", vAlign == "flex-end" ? "flex-start" : vAlign == "flex-start" ? "flex-end" : "center");
                            this.assetParent.style.setProperty("--sgFooterVAlign", hAlign);
                        }
                        if (sgFooterNode && textAlign) sgFooterNode.style.setProperty("--rotateFooterTextAlign", textAlign);
                        this.specialGraphicsUtils.doFontFitForCss(sgFooterNode, this.sgParent, null, null, null, true);
                    } else sgFooterNode.classList.remove("footerRotation");
                    this.applyContrastToText(sgFooterNode, props.footer);
                }
                if (props.duplicateimage) {
                    specialgraphicsPropertyUtils.applyDuplicateImageProperties(props, this.assetParent, 0, true);
                }
                this.applySpeakerProps();
                if (props.quotetestimonial && this.sgParent.querySelector("[id='quoteTestimonialParent']")) {
                    let quoteTestimonialParent = this.sgParent.querySelector("[id='quoteTestimonialParent']");
                    if (props.quotetestimonial.position && props.quotetestimonial.position.split(",").length == 4) specialgraphicsPropertyUtils.updatePosition(quoteTestimonialParent, props.quotetestimonial.position);
                    if (props.quotetestimonial.positionvalue) quoteTestimonialParent.style.position = props.quotetestimonial.positionvalue;
                    if (props.quotetestimonial.zorder) quoteTestimonialParent.style.zIndex = props.quotetestimonial.zorder;
                    if (props.quotetestimonial.padding) specialgraphicsPropertyUtils.updatePadding(props.quotetestimonial.padding, quoteTestimonialParent, true);
                    if (props.quotetestimonial.margin) specialgraphicsPropertyUtils.updateMargin(props.quotetestimonial.margin, quoteTestimonialParent);
                    if (props.quotetestimonial.bgcolor) {
                        let opacity = props.quotetestimonial.bgcoloropacity ? props.quotetestimonial.bgcoloropacity : 1;
                        quoteTestimonialParent.style.backgroundColor = "rgba(var(--" + props.quotetestimonial.bgcolor + "-color-rgb)," + opacity + ")";
                    }
                    if (props.quotetestimonial.bgshadow) quoteTestimonialParent.style.boxShadow = props.quotetestimonial.bgshadow;
                    if (props.quotetestimonial.contrast) this.applyContrastToText(quoteTestimonialParent, props.quotetestimonial);
                    if (props.quotetestimonial.zorder) quoteTestimonialParent.style.zIndex = props.quotetestimonial.zorder;
                    if (props.quotetestimonial.class) {
                        let microParentNode = quoteTestimonialParent.querySelector("[id='microParentNode']");
                        let finalNode = microParentNode ? microParentNode : quoteTestimonialParent;
                        this.specialGraphicsUtils.applyClassNamesFromString(finalNode, props.quotetestimonial.class);
                    }
                    if (props.quotetestimonial.radius) {
                        if (props.quotetestimonial.radius.includes(",") && props.quotetestimonial.radius.split(",").length == 4) {
                            let radiusValue = props.quotetestimonial.radius.split(",");
                            quoteTestimonialParent.style.borderRadius = radiusValue[0] + "px " + radiusValue[1] + "px " + radiusValue[2] + "px " + radiusValue[3] + "px";
                        } else quoteTestimonialParent.style.borderRadius = props.quotetestimonial.radius + (props.quotetestimonial.radius.includes("%") || props.quotetestimonial.radius.includes("px") ? "" : "px");
                    }
                    // if(props.class){}
                }
                // if (props.map && this.sgParent.querySelector("[id='sgMapHolderNode']")) {
                //     let sgMapParentNode = this.sgParent.querySelector("[id='sgMapParentNode']");
                //     let sgMapHolderNode = this.sgParent.querySelector("[id='sgMapHolderNode']");
                //     let sgMapNode = this.sgParent.querySelector("[id='sgMapNode']");
                //     if (props.map.logosizestyle) {
                //         sgMapHolderNode.setAttribute("data-logosizestyle", props.map.logosizestyle);
                //         if (!sgMapParentNode.classList.contains("logoSizeStyle")) sgMapParentNode.classList.add("logoSizeStyle");
                //         if (!sgMapHolderNode.classList.contains(props.map.logosizestyle)) sgMapHolderNode.classList.add(props.map.logosizestyle);
                //     }
                //     specialgraphicsPropertyUtils.applyImageBaseProps(props.map, this.assetParent, sgMapParentNode, "--map");
                //     if (props.map.positionvalue) {
                //         this.assetParent.style.setProperty("--mapPosition", props.map.positionvalue);
                //         sgMapParentNode.style.removeProperty("position");
                //     }
                //     if (props.map.zorder) this.assetParent.style.setProperty("--mapImageZorder", props.map.zorder);

                //     // this.applyChildStyleToParent(sgMapParentNode, sgMapHolderNode);

                //     if (props.map.globalstyle && sgMapParentNode) {
                //         sgMapParentNode.classList.remove(props.map.globalstyle);
                //         sgMapParentNode.classList.add(props.map.globalstyle);
                //         sgMapParentNode.classList.add("clsSingleColorParent");

                //         let percentValue = window.getComputedStyle(sgMapParentNode).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
                //         percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
                //         let sourceNode = sgMapParentNode.querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
                //         if (sourceNode) sgMapParentNode.style.setProperty("--customNodeBorderImageWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
                //     }
                //     if (props.map.contentBG) {
                //         let arrAssets = [];
                //         arrAssets.push({
                //             parent: sgMapParentNode,
                //             type: "svg",
                //             url: props.map.contentBG.value,
                //             id: props.map.contentBG.id,
                //             color: props.map.contentBG.color,
                //         });
                //         this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
                //     }
                //     sgMapNode.setAttribute("data-width", sgMapParentNode.offsetWidth);
                //     sgMapNode.setAttribute("data-height", sgMapParentNode.offsetHeight);
                //     let sgmailingAddress = this.sgParent.querySelector("[id='sgmailingAddress']");
                //     let placeValue = sgmailingAddress ? sgmailingAddress.innerText : "Bangalore";
                //     // if (this.sgData[0].mapurl) {
                //     //     let mapData = this.specialGraphicsUtils.splitMapDetails(this.sgData[0].mapurl);
                //     //     this.getMapLink(sgMapNode, sgMapParentNode.offsetWidth, sgMapParentNode.offsetHeight, placeValue, mapData && mapData.maptype ? mapData.maptype : "");
                //     // } else
                //     this.getMapLink(sgMapNode, sgMapParentNode.offsetWidth, sgMapParentNode.offsetHeight, placeValue);

                //     if (props.map.contrast && props.map.contrast == "fullbg") {
                //         sgMapNode.setAttribute("contrast", "fullbg");
                //         this.eventManager.dispatch("applyImageContrast", sgMapNode, this.assetParent);
                //     } else if (props.map.contrast && props.map.contrast == "halfbg") {
                //         sgMapNode.setAttribute("contrast", "halfbg");
                //         this.eventManager.dispatch("applyImageContrast", sgMapNode, this.assetParent, true);
                //     } else if (this.slideContent) {
                //         sgMapNode.removeAttribute("autoimagechange");
                //         this.slideContent.classList.remove("fixedlightText");
                //         this.slideContent.classList.remove("fixeddarkText");
                //     }
                // }
                if (props.logo && this.sgParent.querySelector("[id='logoGridParent']")) {
                    this.applyLogoGridSize(props);
                    let logogrid = this.objDataToSG && this.objDataToSG.logogrid ? this.objDataToSG.logogrid : null;
                    let slideId = this.slideContent ? this.slideContent.id : null;
                    let supportContrast = props.logo.contrast && (props.logo.contrast == "true" || props.logo.contrast == true) ? true : false;
                    this.createLogoGrid(this.sgParent.querySelector("[id='logoGridParent']"), logogrid, slideId, supportContrast);
                    // this.isLogoGridLoading = true;
                }
                // if (props.logo1 && this.sgParent.querySelector("[id='logoGridParent1']")) {
                //     this.applyLogoGridSize(props, 1);
                //     let logogrid = this.objDataToSG && this.objDataToSG.logogrid1 ? this.objDataToSG.logogrid1 : null;
                //     let slideId = this.slideContent ? this.slideContent.id : null;
                //     let supportContrast = props.logo1.contrast && (props.logo1.contrast == "true" || props.logo1.contrast == true) ? true : false;
                //     this.createLogoGrid(this.sgParent.querySelector("[id='logoGridParent1']"), logogrid, slideId, supportContrast);
                // }
                this.applyCtaButtonProps(this.getPropertyData());
                let titleTextParent = this.assetParent.querySelector("[id='titleTextParent']");
                if (textPosition && this.assetParent.querySelector("[id*='textBaseParentNode']")) {
                    let textBaseParent = this.assetParent.querySelector("[id*='textBaseParentNode']");
                    this.textPositionChangeOperation(textBaseParent.parentElement, textPosition);
                } else if (textPosition && titleTextParent) this.textPositionChangeOperation(titleTextParent.parentElement, textPosition);

                this.updateHeightForText();
            }
            // Check and apply Flip & bleed options
            this.applyImageBleedCommon();
            // this.applyImageBleedCommon(null, "commonbg");

            this.doFinalFontfit();
        }

        if (this.sgSlideType && this.sgSlideType == "cta") this.hideTextNodes(true);
        if (this.sgSlideType && this.sgSlideType == "quote") this.hideTextNodes();
    } else {
        this.clearListener(false);
        let elements = this.assetParent ? this.assetParent.querySelectorAll("[listener='true']") : [];
        let clickElements = this.assetParent ? this.assetParent.querySelectorAll("[clicklistener='true']") : [];
        for (let a = 0; a < clickElements.length; a++) {
            if (this.imageDoubleClickEvent) this.eventManager.addEvent(clickElements[a], "dblclick", this.imageDoubleClickEvent);
        }
        for (let a = 0; a < elements.length; a++) {
            this.setTextFocus(elements[a], false, this.assetParent, true);
            if (elements[a].hasAttribute("commonheightfit")) {
                elements[a].commonheightfit = this.commonHeightFit;
                this.commonHeightFit(elements[a]);
            }
            if (elements[a].hasAttribute("contactnodesheightfit")) {
                elements[a].contactnodesheightfit = this.contactNodesHeightFit;
                this.contactNodesHeightFit(elements[a]);
            }
            if (elements[a].hasAttribute("socialheightfit")) {
                elements[a].socialheightfit = this.socialHeightFit;
                this.socialHeightFit(elements[a]);
            }
        }

        let presenterLogoContentParent = this.sgParent.querySelector("[id='presenterLogoContentParent']");
        let customerLogoContentParent = this.sgParent.querySelector("[id='customerLogoContentParent']");
        let defaultLogo = this.objDataToSG && this.objDataToSG.logoDefaultData ? this.objDataToSG.logoDefaultData : [];
        if (presenterLogoContentParent) {
            // Recreate presenter logo grid instance
            let presenterLogoImageParent = presenterLogoContentParent.querySelector("[id='presenterLogoImageParent']");
            let scaledLogoSize = presenterLogoImageParent?.hasAttribute("data-scaledheight") ? presenterLogoImageParent?.getAttribute("data-scaledheight") : 32;
            let divParent = presenterLogoImageParent.querySelector("[id='presenterdiagramparent']");

            let supportContrast = presenterLogoImageParent?.getAttribute("data-supportcontrast") || "false";
            let contrastVal = { supportcontrast: supportContrast, disablelogocontrast: false };

            this.presenterLogoInstance = new window["SimpleImageGrid"](divParent, { logoHeight: scaledLogoSize }, this.appStaticURL, defaultLogo, contrastVal, 2, this.instanceCreateCallback);
            if (divParent) this.presenterLogoInstance.gridimages = this.presenterLogoInstance.getLogoListData(divParent);
            else {
                let arrImage = [];
                arrImage.push({
                    type: "image",
                    value: this.objDataToSG?.companylogo || this.appStaticURL + "genericassets/placeholderimages/logoplaceholder_landscape.png",
                    contenttype: "logo",
                });
                this.presenterLogoInstance.gridimages = arrImage;
            }
        }
        if (customerLogoContentParent) {
            // Recreate presenter logo grid instance
            let customerLogoImageParent = customerLogoContentParent.querySelector("[id='customerLogoImageParent']");
            let scaledLogoSize = customerLogoImageParent?.hasAttribute("data-scaledheight") ? customerLogoImageParent?.getAttribute("data-scaledheight") : 32;
            let divParent = customerLogoImageParent.querySelector("[id='customerdiagramparent']");

            let supportContrast = customerLogoImageParent?.getAttribute("data-supportcontrast") || "false";
            let contrastVal = { supportcontrast: supportContrast, disablelogocontrast: false };

            this.customerLogoInstance = new window["SimpleImageGrid"](divParent, { logoHeight: scaledLogoSize }, this.appStaticURL, defaultLogo, contrastVal, 1, this.instanceCreateCallback);
            if (divParent) this.customerLogoInstance.gridimages = this.customerLogoInstance.getLogoListData(divParent);
            else {
                let arrImage = [];
                arrImage.push({
                    type: "image",
                    value: this.objDataToSG?.companylogo || this.appStaticURL + "genericassets/placeholderimages/logoplaceholder_landscape.png",
                    contenttype: "logo",
                });
                this.customerLogoInstance.gridimages = arrImage;
            }
        }

        let coverImageParent = this.sgParent.querySelector("[id='coverImageParent']");
        let imageNode = coverImageParent ? coverImageParent.querySelector("[data-target-id='coverimage']") : null;
        if (imageNode && imageNode.hasAttribute("autoimagechange")) imageNode.autoImageChange = this.applyContrastOnAutoImageChange;
        this.setSocialIconsMaxWidth();
        this.setSocialIconsMinWidth();

        let quoteTestimonialParent = this.sgParent.querySelector("[id='quoteTestimonialParent']");
        if (quoteTestimonialParent && quoteTestimonialParent.querySelectorAll("[id='clsCircleBG']").length > 0) {
            quoteTestimonialParent.querySelectorAll("[id='clsCircleBG']").forEach((element) => {
                let eleParent = element.parentElement;
                let clipPath = eleParent.getElementsByTagName("clipPath");
                if (clipPath && clipPath.length > 0) {
                    let clipNode = eleParent.querySelector("[clip-path='url(#" + clipPath[0].id + ")']");
                    clipPath[0].id = clipPath[0].id + this.specialGraphicsUtils.generateRandomStringCSS();
                    if (clipNode) clipNode.style.setProperty("clip-path", "url(#" + clipPath[0].id + ")");
                }
                this.eventManager.addEvent(element, "click", this.ratingStarClickEvent);
            });
        }

        let lottieParent = this.sgParent.querySelector("[data-lottie*='/']");
        if (lottieParent) {
            lottieParent.innerHTML = "";
            let arrAssets = [{ type: "json", url: lottieParent.getAttribute("data-lottie"), id: "commonbglottie", parent: lottieParent }];
            this.arrCommonAssets.push({ array: arrAssets, callback: this.lottieLoadCallback });
        }
    }

    this.initComplete = true;
    this.logoGridUpdateLayout();

    //Re-applying image contrast
    this.reApplyContrast();
    this.reApplyDevicePath();
    if (completeCallBack) SGBaseClass.prototype.initSpecialGraphicsCreation.call(this);
    this.specialGraphicsCreationComplete();
    this.updateMaxWidthForCtaSocial();
    this.updateTextSizeForCtaSocial();
    this.speakerTextMinWidthCalculations();
    if (this.isWidget) this.specialGraphicsUtils.updateImagePositions(this.sgParent);
};

GenericCoverpage.prototype.instanceCreateCallback = function () {
    let slideId = this.slideContent ? this.slideContent.id : this.sgParent.parentElement.parentElement.parentElement.id;
    if (this.updateThumbnail) this.updateThumbnail(slideId);
};
GenericCoverpage.prototype.reApplyDevicePath = function () {
    if (this.sgParent.querySelector("[id='deviceContainerNode']")) {
        let deviceContainerNode = this.sgParent.querySelector("[id='deviceContainerNode']");
        let menuData = this.metaData ? this.metaData[this.designChange == true ? "properties2" : "properties"] : null;
        let deviceProp = menuData && menuData.devicesvg ? menuData.devicesvg : null;
        if (deviceContainerNode.getElementsByTagName("svg").length > 0 && deviceProp && deviceProp.devicename) {
            var svgPath = this.appStaticURL + "genericassets/device/" + this.deviceStyle + "/" + deviceProp.devicename + ".svg";
            deviceContainerNode.getElementsByTagName("svg")[0].setAttribute("path", svgPath);
        }
    }
    if (this.sgParent.querySelector("[id='deviceContainerNode1']")) {
        let deviceContainerNode = this.sgParent.querySelector("[id='deviceContainerNode1']");
        let menuData = this.metaData ? this.metaData[this.designChange == true ? "properties2" : "properties"] : null;
        let deviceProp = menuData && menuData.devicesvg1 ? menuData.devicesvg1 : null;
        if (deviceContainerNode.getElementsByTagName("svg").length > 0 && deviceProp && deviceProp.devicename) {
            var svgPath = this.appStaticURL + "genericassets/device/" + this.deviceStyle + "/" + deviceProp.devicename + ".svg";
            deviceContainerNode.getElementsByTagName("svg")[0].setAttribute("path", svgPath);
        }
    }
};

GenericCoverpage.prototype.setLogoSizes = function () {
    let imgNode = this.assetParent.querySelector("[id='sgLogoImageNode']");

    if (imgNode.complete) this.setLogoSizesOP(imgNode);
    else imgNode.addEventListener("load", this.logoLoadCallback);
};

GenericCoverpage.prototype.setCustomerLogoSizes = function (position = -1) {
    let imgNode = this.assetParent.querySelector("[id='sgCustomerLogoImageNode']");
    if (imgNode && (position == -1 || position == 1)) {
        if (imgNode.complete) this.setLogoSizesOP(imgNode);
        else imgNode.addEventListener("load", this.logoLoadCallback);
    }

    let preImgNode = this.assetParent.querySelector("[id='sgPresenterLogoImageNode']");
    if (preImgNode && (position == -1 || position == 2)) {
        if (preImgNode.complete) this.setLogoSizesOP(preImgNode);
        else preImgNode.addEventListener("load", this.logoLoadCallback);
    }
};

GenericCoverpage.prototype.logoLoadCallback = function (event) {
    event.target.removeEventListener("load", this.logoLoadCallback);
    this.setLogoSizesOP(event.target);
};

GenericCoverpage.prototype.applyLogoGridSize = function (propsData, index) {
    let imgNode = this.sgParent.querySelector("[id='logoGridParent" + (index ? index : "") + "']");
    let logoRatio = "common";
    if (logoRatio) {
        let dummyDom = document.createElement("div");
        dummyDom.classList.add(logoRatio);
        dummyDom.style.position = "absolute";
        dummyDom.style.width = "var(--logoSizeWidth)";
        dummyDom.style.height = "var(--logoSizeHeight)";
        imgNode.appendChild(dummyDom);
        let w = window.getComputedStyle(dummyDom).width;
        let h = window.getComputedStyle(dummyDom).height;
        if (w != "" && h != "" && w != "0px" && h != "0px") {
            if (window.getComputedStyle(dummyDom).getPropertyValue("--logoSizeWidth").trim() == "100%") {
                imgNode.style.width = "100%";
                w = window.getComputedStyle(imgNode).width;
            }
            imgNode.parentElement.style.setProperty("--logoSizeWidth", w);
            imgNode.parentElement.style.setProperty("--logoSizeHeight", h);
            imgNode.style.setProperty("--logoSizeWidth", w);
            imgNode.style.setProperty("--logoSizeHeight", h);
            imgNode.parentElement.setAttribute("data-largewidth", parseFloat(w));
            imgNode.parentElement.setAttribute("data-largeheight", parseFloat(h));

            let logoimagesize = "medium";
            if (imgNode.parentElement.hasAttribute("data-logoimagesize")) logoimagesize = imgNode.parentElement.getAttribute("data-logoimagesize");
            else {
                let props = propsData ? propsData : this.getPropertyData();
                let property = props && props["logo"] ? props["logo"] : null;
                logoimagesize = property && property.logoimagesize ? property.logoimagesize : logoimagesize;
                if (!imgNode.parentElement.hasAttribute("data-logoimagesize")) imgNode.parentElement.setAttribute("data-logoimagesize", logoimagesize);
            }
            let logoImageSizeValue = this.specialGraphicsUtils.getImageSizeSML(logoimagesize);

            logoImageSizeValue = 1;
            w = parseFloat(w) * parseFloat(logoImageSizeValue);
            h = parseFloat(h) * parseFloat(logoImageSizeValue);

            imgNode.style.width = w + "px";
            imgNode.style.height = "auto";
            imgNode.style.maxHeight = h + "px";
        }
        imgNode.removeChild(dummyDom);
    }
};
GenericCoverpage.prototype.applyCustomLogoGridSize = function (propsData, imgNode) {
    let logoRatio = "common";
    let dummyDom = document.createElement("div");
    dummyDom.classList.add(logoRatio);
    dummyDom.style.position = "absolute";
    dummyDom.style.width = "var(--logoSizeWidth)";
    dummyDom.style.height = "var(--logoSizeHeight)";
    imgNode.appendChild(dummyDom);
    let w = window.getComputedStyle(dummyDom).width;
    let h = window.getComputedStyle(dummyDom).height;
    if (w != "" && h != "" && w != "0px" && h != "0px") {
        if (window.getComputedStyle(dummyDom).getPropertyValue("--logoSizeWidth").trim() == "100%") {
            imgNode.style.width = "100%";
            w = window.getComputedStyle(imgNode).width;
        }
        imgNode.parentElement.style.setProperty("--logoSizeWidth", w);
        imgNode.parentElement.style.setProperty("--logoSizeHeight", h);
        imgNode.style.setProperty("--logoSizeWidth", w);
        imgNode.style.setProperty("--logoSizeHeight", h);
        imgNode.parentElement.setAttribute("data-largewidth", parseFloat(w));
        imgNode.parentElement.setAttribute("data-largeheight", parseFloat(h));

        let logoimagesize = "medium";
        if (imgNode.parentElement.hasAttribute("data-logoimagesize")) logoimagesize = imgNode.parentElement.getAttribute("data-logoimagesize");
        else {
            let property = propsData;
            logoimagesize = property && property.logoimagesize ? property.logoimagesize : logoimagesize;
            if (!imgNode.parentElement.hasAttribute("data-logoimagesize")) imgNode.parentElement.setAttribute("data-logoimagesize", logoimagesize);
        }
        let logoImageSizeValue = this.specialGraphicsUtils.getImageSizeSML(logoimagesize);

        logoImageSizeValue = 1;
        w = parseFloat(w) * parseFloat(logoImageSizeValue);
        h = parseFloat(h) * parseFloat(logoImageSizeValue);

        imgNode.parentElement.style.height = "auto";
        imgNode.parentElement.style.maxHeight = h + "px";

        imgNode.parentElement.parentElement.style.width = w + "px";
        imgNode.parentElement.parentElement.style.height = "auto";
        imgNode.parentElement.parentElement.style.maxHeight = h + "px";
    }
    imgNode.removeChild(dummyDom);
};
GenericCoverpage.prototype.setLogoSizesOP = function (imgNode, newRatio) {
    let logoRatio = this.specialGraphicsUtils.getLogoRatio(imgNode);
    if (newRatio) logoRatio = newRatio;
    // console.log("LOGO - ratio - " + logoRatio);
    if (logoRatio) {
        let dummyDom = document.createElement("div");
        dummyDom.classList.add(logoRatio);
        dummyDom.style.position = "absolute";
        dummyDom.style.width = "var(--logoSizeWidth)";
        dummyDom.style.height = "var(--logoSizeHeight)";
        imgNode.parentElement.appendChild(dummyDom);
        let w = window.getComputedStyle(dummyDom).width;
        let h = window.getComputedStyle(dummyDom).height;
        if (w != "" && h != "" && w != "0px" && h != "0px") {
            if (window.getComputedStyle(dummyDom).getPropertyValue("--logoSizeWidth").trim() == "100%") {
                imgNode.style.width = "100%";
                w = window.getComputedStyle(imgNode).width;
            }
            imgNode.parentElement.style.setProperty("--logoSizeWidth", w);
            imgNode.parentElement.style.setProperty("--logoSizeHeight", h);
            imgNode.parentElement.setAttribute("data-largewidth", parseFloat(w));
            imgNode.parentElement.setAttribute("data-largeheight", parseFloat(h));

            let logoimagesize = "medium";
            if (imgNode.parentElement.hasAttribute("data-logoimagesize")) logoimagesize = imgNode.parentElement.getAttribute("data-logoimagesize");
            else {
                let props = this.getPropertyData();
                let newParent = imgNode.parentElement?.parentElement?.parentElement?.parentElement?.parentElement;
                let imageData = imgNode.id.includes("Customer") ? "customerlogo" : imgNode.id.includes("Presenter") ? "presenterlogo" : "logo";
                if (newParent?.id?.toLocaleLowerCase()?.includes("customerlogo")) imageData = "customerlogo";
                else if (newParent?.id?.toLocaleLowerCase()?.includes("presenterlogo")) imageData = "presenterlogo";

                let property = props && props[imageData] ? props[imageData] : null;
                logoimagesize = property && property.logoimagesize ? property.logoimagesize : logoimagesize;
                if (!imgNode.parentElement.hasAttribute("data-logoimagesize")) imgNode.parentElement.setAttribute("data-logoimagesize", logoimagesize);
            }
            // let logoImageSizeValue = logoimagesize == "small" ? 0.4 : logoimagesize == "medium" ? 0.7 : logoimagesize == "large" ? 1 : parseFloat(logoimagesize);
            let logoImageSizeValue = this.specialGraphicsUtils.getImageSizeSML(logoimagesize);
            w = parseFloat(w) * parseFloat(logoImageSizeValue);
            h = parseFloat(h) * parseFloat(logoImageSizeValue);

            imgNode.parentElement.removeChild(dummyDom);
            imgNode.parentElement.parentElement.style.width = w + "px";
            imgNode.parentElement.parentElement.style.height = h + "px";
            imgNode.parentElement.style.width = w + "px";
            imgNode.parentElement.style.height = h + "px";
            imgNode.setAttribute("data-width", w);
            imgNode.setAttribute("data-height", h);
            if (imgNode && imgNode.hasAttribute("data-csstext") && imgNode.getAttribute("data-csstext") != "") {
                var imageDimensionRatio = imgNode.width / imgNode.height;
                var canvasDimensionRatio = w / h;
                if (imageDimensionRatio > canvasDimensionRatio) {
                    imgNode.parentElement.style.height = imgNode.height + "px";
                    imgNode.parentElement.parentElement.style.height = imgNode.height + "px";
                    imgNode.style.setProperty("bottom", 0);
                    imgNode.setAttribute("logosizecropheight", imgNode.height);
                }
            } else this.specialGraphicsUtils.updateImageReSize(w, h, imgNode);
            if (imgNode.callback) imgNode.callback();
            imgNode.callback = null;
        }
    }
};
//DONE_B
GenericCoverpage.prototype.arrNodeGapForSpeaker = function () {
    if (this.metaData && this.metaData && this.metaData[this.designChange == true ? "properties2" : "properties"]) {
        let props = this.metaData[this.designChange == true ? "properties2" : "properties"];
        if (props.speaker && props.speaker.arrnodegap) {
            let arrGapData = null;
            if (props.speaker.arrnodegap.length == 4) arrGapData = props.speaker.arrnodegap;
            else if (JSON.parse(props.speaker.arrnodegap).length == 4) arrGapData = JSON.parse(props.speaker.arrnodegap);
            if (arrGapData?.length == 4) {
                let arrSpeakerNodes = this.sgParent.querySelectorAll("[id*='speakerNodeGroup']");
                let nodesCount = 4;
                for (let a = 0; a < arrSpeakerNodes.length; a++) {
                    if (arrSpeakerNodes[a].style.display == "none") nodesCount = nodesCount - 1;
                }
                if (nodesCount) nodesCount = nodesCount - 1;
                if (arrGapData[nodesCount] != null && arrGapData[nodesCount] != undefined)
                    for (let a = 0; a < arrSpeakerNodes.length; a++) {
                        arrSpeakerNodes[a].style.setProperty("--speakerNodeGap", arrGapData[nodesCount] + "px");
                        arrSpeakerNodes[a].parentElement.style.setProperty("--speakerNodeGap", arrGapData[nodesCount] + "px");
                    }
            }
        }
    }
    let arrSpeakerNodeGroup = this.sgParent.querySelectorAll("[id*='speakerNodeGroup']");
    let columnCount = 0;
    let leftValue = -1;
    if (arrSpeakerNodeGroup.length > 0) {
        this.assetParent.style.setProperty("--ctaSpeakerColumnCount", 1);
        for (let a = 0; a < arrSpeakerNodeGroup.length; a++) {
            if (arrSpeakerNodeGroup[a].offsetLeft > leftValue && arrSpeakerNodeGroup[a].style.display != "none") {
                leftValue = arrSpeakerNodeGroup[a].offsetLeft;
                columnCount = columnCount + 1;
            }
        }
        if (columnCount > 0) this.assetParent.style.setProperty("--ctaSpeakerColumnCount", columnCount);
    }
};

GenericCoverpage.prototype.arrNodeGapForCTA = function () {
    if (this.metaData && this.metaData && this.metaData[this.designChange == true ? "properties2" : "properties"]) {
        let props = this.metaData[this.designChange == true ? "properties2" : "properties"];
        if (props.ctasocial && props.ctasocial.arrnodegap) {
            let arrGapData = null;
            if (props.ctasocial.arrnodegap.length == 5) arrGapData = props.ctasocial.arrnodegap;
            else if (JSON.parse(props.ctasocial.arrnodegap).length == 5) arrGapData = JSON.parse(props.ctasocial.arrnodegap);
            if (arrGapData && arrGapData.length == 5) {
                let arrSocailLink = this.sgParent.querySelectorAll("[id*='sgCustomSocialLink']");
                let nodesCount = 5;
                if (arrSocailLink.length == 0) {
                    arrSocailLink = this.sgParent.querySelectorAll("[id*='ctaSocialNodeParent']");
                    nodesCount = arrSocailLink.length;
                }
                for (let a = 0; a < arrSocailLink.length; a++) {
                    if (arrSocailLink[a].style.display == "none") nodesCount = nodesCount - 1;
                }
                if (nodesCount) nodesCount = nodesCount - 1;
                if (arrGapData[nodesCount])
                    for (let a = 0; a < arrSocailLink.length; a++) {
                        arrSocailLink[a].style.setProperty("--ctaSocialNodeGap", arrGapData[nodesCount] + "px");
                    }
            }
        }
    }
};
//New - v2
GenericCoverpage.prototype.setSocialIconsNodeGap = function () {
    try {
        if (this.metaData && this.metaData && this.metaData[this.designChange == true ? "properties2" : "properties"]) {
            let props = this.metaData[this.designChange == true ? "properties2" : "properties"];
            if (props.socialicons && props.socialicons.arrnodegap) {
                let arrGapData = this.specialGraphicsUtils.isJson(props.socialicons.arrnodegap) ? props.socialicons.arrnodegap : JSON.stringify(props.socialicons.arrnodegap);
                arrGapData = arrGapData ? JSON.parse(arrGapData) : [];
                if (arrGapData.length > 0) {
                    let arrSocailLink = this.sgParent.querySelectorAll("[id*='ctaSocialNodeParent']");
                    let nodesCount = arrSocailLink.length;
                    for (let a = 0; a < arrSocailLink.length; a++) {
                        if (arrSocailLink[a].style.display == "none") nodesCount = nodesCount - 1;
                    }
                    if (nodesCount) nodesCount = nodesCount - 1;
                    let paddingVal = arrGapData[nodesCount] != null && arrGapData[nodesCount] != undefined ? arrGapData[nodesCount] : arrGapData[arrGapData.length - 1] ? arrGapData[arrGapData.length - 1] : null;
                    if (paddingVal != null && paddingVal != undefined)
                        for (let a = 0; a < arrSocailLink.length; a++) {
                            arrSocailLink[a].style.setProperty("--ctaSocialNodeGap", paddingVal + "px");
                        }
                }
            }
        }
    } catch (error) {
        console.log("SG - Error on setSocialIconsNodeGap - " + error);
    }
};
//New - v2
GenericCoverpage.prototype.setSocialIconsSize = function () {
    let ctaSocialParent = this.sgParent.querySelector("[id='ctaSocialParent']");
    if (ctaSocialParent && ctaSocialParent.hasAttribute("iconnodesizearray")) {
        let arrNodes = ctaSocialParent.querySelectorAll("[id*='ctaSocialNodeParent']");
        let arrValues = JSON.parse(ctaSocialParent.getAttribute("iconnodesizearray"));
        let iconSizeW = -1;
        let iconSizeH = -1;
        if (arrNodes.length < 4 && arrValues[0]) {
            iconSizeW = arrValues[0][0];
            iconSizeH = arrValues[0][1];
        }
        if (arrNodes.length >= 4 && arrValues[1]) {
            iconSizeW = arrValues[1][0];
            iconSizeH = arrValues[1][1];
        }
        if (arrNodes.length >= 6 && arrValues[2]) {
            iconSizeW = arrValues[2][0];
            iconSizeH = arrValues[2][1];
        }
        if (arrNodes.length >= 8 && arrValues[3]) {
            iconSizeW = arrValues[3][0];
            iconSizeH = arrValues[3][1];
        }
        if (arrNodes.length >= 10 && arrValues[4]) {
            iconSizeW = arrValues[4][0];
            iconSizeH = arrValues[4][1];
        }
        if (iconSizeW == -1 && iconSizeH == -1 && arrValues[0]) {
            iconSizeW = arrValues[0][0];
            iconSizeH = arrValues[0][1];
        }
        this.assetParent.style.setProperty("--ctaIconWidth", iconSizeW + "px");
        this.assetParent.style.setProperty("--ctaIconHeight", iconSizeH + "px");
    }
};
GenericCoverpage.prototype.arrNodeGapForContact = function () {
    if (this.metaData && this.metaData && this.metaData[this.designChange == true ? "properties2" : "properties"]) {
        let props = this.metaData[this.designChange == true ? "properties2" : "properties"];
        // if (props.contact && props.contact.icon && (props.contact.icon == "true" || props.contact.icon == true)) {
        if (props && props.contact && props.contact.arrnodegap) {
            let sgemailAddressParent = this.sgParent.querySelector("[id='sgemailAddressParent']");
            let sgphoneNumberParent = this.sgParent.querySelector("[id='sgphoneNumberParent']");
            let sgmailingAddressParent = this.sgParent.querySelector("[id='sgmailingAddressParent']");
            let sgwebsiteParent = this.sgParent.querySelector("[id='sgwebsiteParent']");

            let arrGapData = null;
            if (props.contact.arrnodegap.length == 4) arrGapData = props.contact.arrnodegap;
            else if (this.specialGraphicsUtils.isJson(props.contact.arrnodegap) && JSON.parse(props.contact.arrnodegap).length == 4) arrGapData = JSON.parse(props.contact.arrnodegap);
            if (arrGapData && arrGapData.length == 4) {
                let nodesCount = 4;
                if (sgemailAddressParent && sgemailAddressParent.style.display == "none") nodesCount = nodesCount - 1;
                if (sgphoneNumberParent && sgphoneNumberParent.style.display == "none") nodesCount = nodesCount - 1;
                if (sgmailingAddressParent && sgmailingAddressParent.style.display == "none") nodesCount = nodesCount - 1;
                if (sgwebsiteParent && sgwebsiteParent.style.display == "none") nodesCount = nodesCount - 1;
                if (nodesCount) nodesCount = nodesCount - 1;
                if (arrGapData[nodesCount]) {
                    sgemailAddressParent.style.setProperty("--contactNodeGap", arrGapData[nodesCount] + "px");
                    sgphoneNumberParent.style.setProperty("--contactNodeGap", arrGapData[nodesCount] + "px");
                    sgmailingAddressParent.style.setProperty("--contactNodeGap", arrGapData[nodesCount] + "px");
                    sgwebsiteParent.style.setProperty("--contactNodeGap", arrGapData[nodesCount] + "px");
                }
            }
        }
        // }
    }
};
GenericCoverpage.prototype.applyContrastToText = function (element, property) {
    if (property?.contrast && (property.contrast == "true" || property.contrast == true) && element) element.setAttribute("data-supportcontrast", "true");
    else if (element) element.removeAttribute("data-supportcontrast");
};
GenericCoverpage.prototype.applyChildStyleToParent = function (parent, child) {
    if (parent && child) {
        let childStyle = window.getComputedStyle(child);
        let ww = child.style.width.includes("%") ? child.style.width : child.style.width.includes("px") ? child.style.width : childStyle.width;
        let hh = child.style.height.includes("%") ? child.style.height : child.style.height.includes("px") ? child.style.height : childStyle.height;
        if (ww != 0 && ww != "0px") parent.style.width = ww;
        if (hh != 0 && hh != "0px") parent.style.height = hh;

        parent.style.left = childStyle.left;
        parent.style.top = childStyle.top;
        parent.style.position = childStyle.position;
        // let margin = childStyle.margin == "" || childStyle.margin == "0px" ? child.style.margin : childStyle.margin;
        // let padding = childStyle.padding == "" || childStyle.padding == "0px" ? child.style.padding : childStyle.padding;
        // parent.style.margin = margin;
        // parent.style.padding = padding;
        child.style.width = "100%";
        child.style.height = "100%";
        child.style.removeProperty("left");
        child.style.removeProperty("top");
        // child.style.setProperty("margin", "unset", "important");
        // child.style.setProperty("padding", "unset", "important");
    }
};
GenericCoverpage.prototype.onTextChangeForAllNodes = function (sgParent = null, doOnlyTitle = false, doOnlySubTitle = false) {
    if (sgParent) this.assetParent = sgParent.querySelector("[id='assetParent0']");
    if (!this.assetParent) this.assetParent = this.sgParent.querySelector("[id='assetParent0']");
    let textBaseParentNode = this.assetParent.querySelector("[id*='textBaseParentNode']");
    if (!textBaseParentNode) textBaseParentNode = this.assetParent;
    if (textBaseParentNode) {
        textBaseParentNode.style.overflow = "hidden";
        // textBaseParentNode.style.removeProperty("max-height");
        let titleNode = textBaseParentNode.querySelector("[id='sgTitleNode']");
        let subTitleNode = textBaseParentNode.querySelector("[id='sgSubTitleNode']");
        let sgTitleLabelNode = textBaseParentNode.querySelector("[id='sgTitleLabelNode']");

        if (sgTitleLabelNode) {
            if (this.removeHighlightFocus) this.removeHighlightFocus(this.assetParent, sgTitleLabelNode);
            let elementPadding = this.specialGraphicsUtils.getPadding(sgTitleLabelNode);
            let labelStyle = window.getComputedStyle(sgTitleLabelNode);
            sgTitleLabelNode.style.maxHeight = parseFloat(labelStyle.lineHeight) + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
            sgTitleLabelNode.style.minHeight = sgTitleLabelNode.style.maxHeight;
            sgTitleLabelNode.parentElement.style.maxHeight = sgTitleLabelNode.style.maxHeight;
            sgTitleLabelNode.parentElement.style.minHeight = sgTitleLabelNode.style.maxHeight;
        }
        if (subTitleNode && !doOnlyTitle) {
            if (this.removeHighlightFocus) this.removeHighlightFocus(this.assetParent, subTitleNode);
            subTitleNode.style.removeProperty("max-height");
            subTitleNode.style.removeProperty("height");
            if (textBaseParentNode.id.includes("textBaseParentNode")) subTitleNode.parentElement.style.removeProperty("max-height");
            if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(subTitleNode);
            this.onTextChangeUpdate(subTitleNode, true);
            this.doCheckTextLineHeightDiff(subTitleNode);
        }
        if (titleNode && !doOnlySubTitle) {
            if (this.removeHighlightFocus) this.removeHighlightFocus(this.assetParent, titleNode);
            titleNode.style.removeProperty("max-height");
            titleNode.style.removeProperty("height");
            if (textBaseParentNode.id.includes("textBaseParentNode")) titleNode.parentElement.style.removeProperty("max-height");
            if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(titleNode);
            this.onTextChangeUpdate(titleNode, true);
            if (this.fontSizeChangeOnTextChange && this.sgSlideType == "quote") this.fontSizeChangeOnTextChange(titleNode);
            this.doCheckTextLineHeightDiff(titleNode);
        }

        this.doSpeakerFontFit();
        textBaseParentNode.style.removeProperty("overflow");
    }
};

GenericCoverpage.prototype.doSpeakerFontFit = function (doFontFit = false) {
    let agendaNodeParent = this.sgParent.querySelector("[id='speakerParent']");
    if (agendaNodeParent) {
        let primaryNodes = agendaNodeParent.querySelectorAll("[data-cssslide*='primary']");
        let secondaryNodes = agendaNodeParent.querySelectorAll("[data-cssslide*='secondary']");
        for (let a = 0; a < primaryNodes.length; a++) {
            if (primaryNodes[a]) {
                if (doFontFit) this.specialGraphicsUtils.doFontFitForCss(primaryNodes[a], this.sgParent, null, null, null, true);
                this.onTextChangeUpdateSpeakerNode(primaryNodes[a]);
            }
            if (secondaryNodes[a]) {
                if (doFontFit) this.specialGraphicsUtils.doFontFitForCss(secondaryNodes[a], this.sgParent, null, null, null, true);
                this.onTextChangeUpdateSpeakerNode(secondaryNodes[a]);
            }
        }
    }
};

GenericCoverpage.prototype.onTextChange = function (element) {
    let textNode = element;
    this.onTextChangeUpdate(textNode);
};

GenericCoverpage.prototype.onTextChangeUpdate = function (textNode, isStart = false) {
    let textBaseParentNode = this.assetParent.querySelector("[id*='textBaseParentNode']");
    let supportParent = textNode.hasAttribute("data-support") ? true : false;
    let singleNodeHeight = -1;
    let isSingleNode = false;
    if (supportParent == true && !textBaseParentNode && this.assetParent.querySelector("[id='sgTitleNode']")) {
        let titleNode = this.assetParent.querySelector("[id='sgTitleNode']");
        textBaseParentNode = titleNode.parentElement;
        let oldOverflowValue = textBaseParentNode.style.overflow;
        textBaseParentNode.style.overflow = "hidden";
        singleNodeHeight = parseFloat(window.getComputedStyle(textBaseParentNode).height);
        if (textBaseParentNode.style.height == "auto") {
            textBaseParentNode.style.height = textBaseParentNode.style.maxHeight;
            singleNodeHeight = parseFloat(window.getComputedStyle(textBaseParentNode).height);
            textBaseParentNode.style.height = "auto";
        }
        if (textNode.hasAttribute("data-maxheight")) {
            let textNodeMaxHeight = textNode.getAttribute("data-maxheight");
            if (textNodeMaxHeight.includes("%")) {
                let ph = textNode.parentElement.parentElement.offsetHeight;
                let mhFinal = ph * (parseFloat(textNodeMaxHeight) / 100);
                singleNodeHeight = mhFinal;
            } else {
                singleNodeHeight = parseFloat(textNodeMaxHeight);
            }
            textNode.parentElement.style.maxHeight = textNodeMaxHeight;
        }
        textBaseParentNode.style.overflow = oldOverflowValue;
        isSingleNode = true;
    }
    if (!textBaseParentNode) {
        textBaseParentNode = textNode.parentElement.parentElement;
        isSingleNode = true;
    }
    if (textBaseParentNode) {
        if (isSingleNode != true && textNode.id.includes("sgTitleLabelNode")) {
            let labelStyle = window.getComputedStyle(textNode);
            let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
            textNode.style.maxHeight = parseFloat(labelStyle.lineHeight) + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
            textNode.parentElement.style.maxHeight = textNode.style.maxHeight;
        } else {
            textNode.style.removeProperty("max-height");
            textNode.style.removeProperty("min-height");
            textNode.style.removeProperty("height");
            if (isSingleNode != true) textNode.parentElement.style.removeProperty("max-height");

            let titleNode = textBaseParentNode.querySelector("[id='sgTitleNode']");
            let subTitleNode = textBaseParentNode.querySelector("[id='sgSubTitleNode']");
            let sgTitleLabelNode = textBaseParentNode.querySelector("[id='sgTitleLabelNode']");
            let textInnerParentNode = textBaseParentNode.querySelector("[id='textInnerParentNode']");
            let sgNumberTextNode = textBaseParentNode.querySelector("[id*='sgNumberTextParent']");

            let numberStyle = sgNumberTextNode ? window.getComputedStyle(sgNumberTextNode) : null;
            let numberMargin = numberStyle ? parseFloat(numberStyle.height == "auto" ? 0 : numberStyle.height) + parseFloat(numberStyle.marginTop) + parseFloat(numberStyle.marginBottom) : 0;
            numberMargin = isNaN(numberMargin) ? 0 : numberMargin;

            let textParentStyle = textInnerParentNode ? window.getComputedStyle(textInnerParentNode.parentElement) : null;
            let textParentMargin = textParentStyle ? parseFloat(textParentStyle.marginTop) + parseFloat(textParentStyle.marginBottom) : 0;

            let innerParentStyle = textInnerParentNode ? window.getComputedStyle(textInnerParentNode) : null;
            let innerParentMargin = innerParentStyle ? parseFloat(innerParentStyle.marginTop) + parseFloat(innerParentStyle.marginBottom) : 0;

            let labelParentStyle = sgTitleLabelNode ? window.getComputedStyle(sgTitleLabelNode.parentElement) : null;
            let labelStyle = sgTitleLabelNode ? window.getComputedStyle(sgTitleLabelNode) : null;
            let hasLabel = (sgTitleLabelNode && sgTitleLabelNode.style.display == "none") || !sgTitleLabelNode ? false : true;
            let labelMargin = labelParentStyle ? parseFloat(labelParentStyle.marginTop) + parseFloat(labelParentStyle.marginBottom) : 0;
            labelMargin = (labelStyle ? parseFloat(labelStyle.marginTop) + parseFloat(labelStyle.marginBottom) : 0) + labelMargin;
            if ((sgTitleLabelNode && sgTitleLabelNode.parentElement && sgTitleLabelNode.parentElement.style.display == "none") || hasLabel == false) labelMargin = 0;

            let subTitileParentStyle = subTitleNode ? window.getComputedStyle(subTitleNode.parentElement) : null;
            let subTitileStyle = subTitleNode ? window.getComputedStyle(subTitleNode) : null;
            let hasSubtitle = (subTitleNode && subTitleNode.style.display == "none") || !subTitleNode ? false : true;
            let subTitileMargin = subTitileParentStyle ? parseFloat(subTitileParentStyle.marginTop) + parseFloat(subTitileParentStyle.marginBottom) : 0;
            subTitileMargin = (subTitileStyle ? parseFloat(subTitileStyle.marginTop) + parseFloat(subTitileStyle.marginBottom) : 0) + subTitileMargin;
            if ((subTitleNode && subTitleNode.parentElement && subTitleNode.parentElement.style.display == "none") || hasSubtitle == false) subTitileMargin = 0;

            let titileParentStyle = titleNode ? window.getComputedStyle(titleNode.parentElement) : null;
            let titileMargin = titileParentStyle ? parseFloat(titileParentStyle.marginTop) + parseFloat(titileParentStyle.marginBottom) : 0;

            let textBaseHeight = parseFloat(singleNodeHeight) > 0 ? parseFloat(singleNodeHeight) : parseFloat(window.getComputedStyle(textBaseParentNode).height);
            if (textBaseParentNode && textBaseParentNode.hasAttribute("fullheight")) textBaseHeight = parseFloat(textBaseParentNode.getAttribute("fullheight"));
            if (window.getComputedStyle(textBaseParentNode).height == "" && textBaseParentNode.style.maxHeight != "" && textBaseParentNode.style.maxHeight.includes("px")) textBaseHeight = parseFloat(textBaseParentNode.style.maxHeight);
            let maxHeight = window.getComputedStyle(textBaseParentNode).maxHeight;
            if ((maxHeight != "" && maxHeight != "0px") || maxHeight.includes("calc")) {
                if (maxHeight.includes("px") && !isNaN(parseFloat(maxHeight))) textBaseHeight = parseFloat(maxHeight);
                else if (maxHeight.includes("%")) {
                    let oldParentHeight = null;
                    if (textBaseParentNode.parentElement && textBaseParentNode.parentElement.style.height == "auto" && textBaseParentNode.parentElement.hasAttribute("fullheight")) {
                        oldParentHeight = textBaseParentNode.parentElement.style.height;
                        textBaseParentNode.parentElement.style.height = textBaseParentNode.parentElement.getAttribute("fullheight");
                    }
                    let oldParentH = textBaseParentNode.style.height;
                    textBaseParentNode.style.height = textBaseParentNode.style.maxHeight;
                    let hh = textBaseParentNode.offsetHeight;
                    if (hh > 0 && !isNaN(hh)) textBaseHeight = hh;
                    textBaseParentNode.style.height = oldParentH;
                    if (oldParentHeight) textBaseParentNode.parentElement.style.height = oldParentHeight;
                }
            }

            //removing margin/padding things on total base height
            let textParentHeight =
                textBaseHeight - (isNaN(labelMargin) ? 0 : labelMargin) - (isNaN(subTitileMargin) ? 0 : subTitileMargin) - (isNaN(titileMargin) ? 0 : titileMargin) - (isNaN(innerParentMargin) ? 0 : innerParentMargin) - (isNaN(textParentMargin) ? 0 : textParentMargin) - (isNaN(numberMargin) ? 0 : numberMargin);
            let titleHeight = titleNode?.scrollHeight > 0 ? titleNode.scrollHeight : !titleNode || titleNode?.offsetHeight == 0 ? 0 : titleNode.style.maxHeight != "" && titleNode.style.display != "none" ? parseFloat(titleNode.style.maxHeight) : window.getComputedStyle(titleNode).height;
            let subTitleHeight = subTitleNode?.scrollHeight > 0 ? subTitleNode.scrollHeight : !subTitleNode || subTitleNode?.offsetHeight == 0 ? 0 : subTitleNode.style.maxHeight != "" && subTitleNode.style.display != "none" ? parseFloat(subTitleNode.style.maxHeight) : window.getComputedStyle(subTitleNode).height;
            let lableHeight = !sgTitleLabelNode || sgTitleLabelNode?.offsetHeight == 0 ? 0 : sgTitleLabelNode.style.maxHeight != "" && sgTitleLabelNode.style.display != "none" ? parseFloat(sgTitleLabelNode.style.maxHeight) : window.getComputedStyle(sgTitleLabelNode).height;
            //calculating total current text height
            let totalTextHeight = parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight);

            let lineHeight = window.getComputedStyle(textNode).lineHeight;
            let fontsize = window.getComputedStyle(textNode).fontSize;
            lineHeight = isNaN(parseFloat(lineHeight)) ? parseFloat(fontsize) * 1.2 : parseFloat(lineHeight);
            let fullHeight = isSingleNode ? (textNode.parentElement.parentElement.hasAttribute("fullheight") ? parseFloat(textNode.parentElement.parentElement.hasAttribute("fullheight")) : null) : null;
            let noLines = Math.max((fullHeight ? fullHeight : textNode.parentElement.offsetHeight) / lineHeight, 1);
            let offDifference = noLines - parseInt(noLines);
            let lines = offDifference > 0.9 ? parseInt(noLines) + 1 : parseInt(noLines);

            //If text height increase total height we have doing fit logic
            if (typeof totalTextHeight == "string") totalTextHeight = parseFloat(totalTextHeight);
            if (typeof textParentHeight == "string") textParentHeight = parseFloat(textParentHeight);
            totalTextHeight = totalTextHeight.toFixed(1);
            textParentHeight = textParentHeight.toFixed(1);
            if (typeof totalTextHeight == "string") totalTextHeight = parseFloat(totalTextHeight);
            if (typeof textParentHeight == "string") textParentHeight = parseFloat(textParentHeight);
            let commonRemainingHeight = 0;
            let isSameW = Math.round(textParentHeight) == Math.round(totalTextHeight);
            if (totalTextHeight > textParentHeight && !isSameW) {
                let targetNodeHeight =
                    textNode.id == "sgTitleNode"
                        ? parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                        : textNode.id == "sgSubTitleNode"
                        ? parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                        : parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight);
                let remainingHeight = textParentHeight - targetNodeHeight;
                if (isSingleNode) remainingHeight = textParentHeight;
                if (lines == 1) remainingHeight = lineHeight;

                commonRemainingHeight = remainingHeight;

                let linesFinal = remainingHeight / lineHeight;
                let offDiff = linesFinal - parseInt(linesFinal);
                linesFinal = offDiff > 0.9 ? parseInt(linesFinal) + 1 : parseInt(linesFinal);

                let heightFinal = linesFinal * lineHeight;
                heightFinal = heightFinal == 0 ? lineHeight : heightFinal;

                textNode.style.maxHeight = heightFinal + "px";
            } else {
                let targetNodeHeight =
                    textNode.id == "sgTitleNode"
                        ? parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                        : textNode.id == "sgSubTitleNode"
                        ? parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                        : parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight);
                let remainingHeight = textParentHeight - targetNodeHeight;
                if (isSingleNode) remainingHeight = textParentHeight;
                commonRemainingHeight = remainingHeight;
            }

            DiagramResizeUtils.commonFontResize(totalTextHeight, textParentHeight, commonRemainingHeight, textNode, textNode.parentElement, this.objDataToSG.fontClassLists, true);

            if (isSingleNode == true) textNode.parentElement.style.removeProperty("height");

            this.onTextUpdate(textNode, isSingleNode);
        }
    }
};

GenericCoverpage.prototype.loop = function (lines, lineHeight, textNode, textParentHeight, titleNode, subTitleNode, sgTitleLabelNode) {
    //Loop and fitting the text inside max avaiable height
    lines = lines - 1;
    if (lines == 0) return;
    let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
    let newHeight = lines * lineHeight + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom);
    textNode.style.maxHeight = newHeight + "px";

    let titleHeight = !titleNode ? 0 : titleNode.style.maxHeight != "" && titleNode.style.display != "none" ? parseFloat(titleNode.style.maxHeight) : window.getComputedStyle(titleNode).height;
    let subTitleHeight = !subTitleNode ? 0 : subTitleNode.style.maxHeight != "" && subTitleNode.style.display != "none" ? parseFloat(subTitleNode.style.maxHeight) : window.getComputedStyle(subTitleNode).height;
    let lableHeight = !sgTitleLabelNode ? 0 : sgTitleLabelNode.style.maxHeight != "" && sgTitleLabelNode.style.display != "none" ? parseFloat(sgTitleLabelNode.style.maxHeight) : window.getComputedStyle(sgTitleLabelNode).height;
    let totalTextHeight = parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight);
    if (textParentHeight < totalTextHeight) this.loop(lines, lineHeight, textNode, textParentHeight, titleNode, subTitleNode, sgTitleLabelNode);
};

GenericCoverpage.prototype.onTextUpdate = function (textNode, isSingleNode = false) {
    if (textNode.parentElement.offsetHeight <= textNode.offsetHeight) {
        let lineHeight = window.getComputedStyle(textNode).lineHeight;
        let fontsize = window.getComputedStyle(textNode).fontSize;
        lineHeight = isNaN(parseFloat(lineHeight)) ? parseFloat(fontsize) * 1.2 : parseFloat(lineHeight);
        let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
        let noLines = Math.max(textNode.parentElement.offsetHeight / lineHeight, 1);
        let offDifference = noLines - parseInt(noLines);
        let lines = offDifference > 0.9 ? parseInt(noLines) + 1 : parseInt(noLines);
        textNode.style.maxHeight = lines * lineHeight + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
        textNode.style.overflow = "hidden";
        if (!isSingleNode) textNode.parentElement.style.removeProperty("max-height");
    }
};

GenericCoverpage.prototype.doCheckTextLineHeightDiff = function (textNode) {
    // return
    if (textNode.id.includes("sgTitleLabelNode")) return;

    // let textBaseParentNode = this.assetParent.querySelector("[id*='textBaseParentNode']");
    // let supportParent = textNode.hasAttribute("data-support") ? true : false;
    // let isSingleNode = supportParent == true && !textBaseParentNode;

    let lineHeight = window.getComputedStyle(textNode).lineHeight;
    let fontsize = window.getComputedStyle(textNode).fontSize;
    lineHeight = isNaN(parseFloat(lineHeight)) ? parseFloat(fontsize) * 1.2 : parseFloat(lineHeight);

    let offsetHeight = textNode.parentElement.offsetHeight;
    // if (isSingleNode) {
    //     let pMh = textNode.parentElement.parentElement.style.maxHeight;
    //     let oldPh = textNode.parentElement.parentElement.style.height;
    //     if (pMh?.includes("%") || pMh?.includes("calc") || pMh?.includes("px")) textNode.parentElement.parentElement.style.height = pMh;

    //     let textParentMh = textNode.parentElement.style.maxHeight;
    //     let textParentOldPh = textNode.parentElement.style.height;
    //     if (textParentMh?.includes("%") || textParentMh?.includes("calc") || textParentMh?.includes("px")) textNode.parentElement.style.height = textParentMh;

    //     offsetHeight = textNode.parentElement.offsetHeight;
    //     textNode.parentElement.parentElement.style.height = oldPh;
    //     textNode.parentElement.style.height = textParentOldPh;
    // }

    let noLines = Math.max(offsetHeight / lineHeight, 1);
    let offDifference = noLines - parseInt(noLines);
    let lines = offDifference > 0.9 ? parseInt(noLines) + 1 : parseInt(noLines);

    let dummyNode = textNode.cloneNode(true);
    dummyNode.style.lineHeight = "normal";
    dummyNode.style.opacity = "0";
    dummyNode.innerHTML = "sd";
    this.sgParent.appendChild(dummyNode);

    dummyNode.style.minHeight = "unset";
    dummyNode.style.height = "unset";
    dummyNode.style.maxHeight = "unset";
    dummyNode.style.position = "absolute";
    let fullLh1 = dummyNode.clientHeight;
    this.sgParent.removeChild(dummyNode);
    if (fullLh1 <= 0) return;

    let diff = fullLh1 - lineHeight;
    if (diff <= 0) {
        textNode.style.maxHeight = lines * lineHeight + "px";
        // if (isSingleNode) textNode.style.height = textNode.style.maxHeight;
        return;
    }

    // let totalLines = Math.max(textNode.scrollHeight / lineHeight, 1);
    textNode.style.maxHeight = lines * lineHeight + diff / (lines == 1 ? 2 : lines) + "px";
    textNode.style.height = lines * lineHeight + diff / (lines == 1 ? 2 : lines) + "px";
    // textNode.style.maxHeight = lines * lineHeight + diff / totalLines + "px";
    // console.log("SGG - Full - ", lines * lineHeight + diff / totalLines + "px");
    // console.log("SGG - number of lines - ", lines * lineHeight + diff / lines + "px");
    // textNode.style.maxHeight = textNode.offsetHeight * lh + diff / lines + "px";

    // textNode.style.maxHeight = lines * lineHeight + diff / lines + "px";
    // // console.log("SGG - Lineheight diff - ", diff + " - " + textNode.style.maxHeight);
    // // console.log(textNode);

    textNode.style.minHeight = textNode.style.maxHeight;
    let textH = textNode.clientHeight;
    let textparentH = textNode.parentElement.parentElement.parentElement.clientHeight;
    textNode.style.removeProperty("min-height");
    if (textH > textparentH) {
        // console.log("Sg - Exceed height while adding difference line height");
        lines = lines - 1;
        // if (lines == 1) textNode.style.maxHeight = lines * lineHeight + "px";
        // else
        textNode.style.maxHeight = lines * lineHeight + diff / 3 + "px";
    }
    // }
};

GenericCoverpage.prototype.updateHeightForText = function () {
    if (this.isWidget == false && this.metaData && this.metaData && this.metaData[this.designChange == true ? "properties2" : "properties"]) {
        let props = this.metaData[this.designChange == true ? "properties2" : "properties"];
        let property = props.text;
        if (property && property.maxheight) {
            let textBaseParentNode = this.sgParent.querySelector("[id*='textBaseParentNode']");
            let remainingHeight;
            if (textBaseParentNode) {
                let textParent = textBaseParentNode.parentElement;
                let textParentOriginalHeight = textParent.style.height;
                let parentHeight = parseFloat(window.getComputedStyle(textParent).height);
                if (textParent.hasAttribute("fullheight")) parentHeight = parseFloat(textParent.getAttribute("fullheight"));
                if (!isNaN(parentHeight) && parentHeight > 0) return;
                textBaseParentNode.style.display = "none";
                textParent.style.height = "auto";

                let mainParentDisplay = textParent.parentElement.style.display;
                textParent.parentElement.style.removeProperty("display");
                let currentHeight = parseFloat(window.getComputedStyle(textParent).height);
                textParent.parentElement.style.display = mainParentDisplay;

                remainingHeight = parentHeight - currentHeight;
                textParent.style.height = textParentOriginalHeight;
            }
            let titleLabelTextParent = this.sgParent.querySelector("[id='titleLabelTextParent']");
            let sgTitleLabelNode = this.sgParent.querySelector("[id='sgTitleLabelNode']");

            let titleTextParent = this.sgParent.querySelector("[id='titleTextParent']");
            let sgTitleNode = this.sgParent.querySelector("[id='sgTitleNode']");

            let subTitleTextParent = this.sgParent.querySelector("[id='subTitleTextParent']");
            let sgSubTitleNode = this.sgParent.querySelector("[id='sgSubTitleNode']");

            if (titleLabelTextParent) titleLabelTextParent.style.removeProperty("max-height");
            if (sgTitleLabelNode) sgTitleLabelNode.style.removeProperty("max-height");
            if (titleTextParent) titleTextParent.style.removeProperty("max-height");
            if (sgTitleNode) sgTitleNode.style.removeProperty("max-height");
            if (subTitleTextParent) subTitleTextParent.style.removeProperty("max-height");
            if (sgSubTitleNode) sgSubTitleNode.style.removeProperty("max-height");
            if (textBaseParentNode && remainingHeight) {
                textBaseParentNode.style.maxHeight = remainingHeight + "px";
                textBaseParentNode.style.removeProperty("display");
            }
        }
    }
};

//Set slide type
GenericCoverpage.prototype.setSlideType = function (type) {
    if (type) this.sgSlideType = type;
    // if (this.sgSlideType && this.sgSlideType == "cta") this.hideTextNodes(true);
    if (this.sgSlideType && this.sgSlideType == "quote") this.hideTextNodes();
};

//Hide nodes depends on asset type.
GenericCoverpage.prototype.hideTextNodes = function (showSubtitle = false) {
    let titleLabelTextParent = this.sgParent.querySelector("[id='titleLabelTextParent']");
    let subTitleTextParent = this.sgParent.querySelector("[id='subTitleTextParent']");
    if (subTitleTextParent && showSubtitle == false) {
        subTitleTextParent.style.display = "none";
        subTitleTextParent.style.height = "0px";
    }
    if (titleLabelTextParent && showSubtitle == false) {
        titleLabelTextParent.style.display = "none";
        titleLabelTextParent.style.height = "0px";
    }
    // if (titleLabelTextParent) titleLabelTextParent.style.display = "none";
};
GenericCoverpage.prototype.commonAssetsLoadComplete = function (responseData, objData) {
    if (objData && objData.callback) objData.callback(responseData, objData);
    this.assetLoadingCount = this.assetLoadingCount - 1;
    if (this.assetLoadingCount == 0) {
        // console.log("SG - all assets load complete");
        this.assetsLoading = false;
        this.arrCommonAssets = [];
        let doComplete = objData && objData.docall ? false : true;
        // if (objData && objData.updatingDesign != null && objData.updatingDesign != undefined) this.updatingDesign = objData.updatingDesign;
        if (doComplete) this.specialGraphicsCreationComplete();
    }
};
// GenericCoverpage.prototype.logoGridCallback = function () {
//     this.isLogoGridLoading = false;
//     this.specialGraphicsCreationComplete();
// };
GenericCoverpage.prototype.specialGraphicsCreationComplete = function () {
    // if (!this.isLogoGridLoading) {
    this.assetParent = this.sgParent.querySelector("[id='assetParent0']");
    if (this.arrCommonAssets.length > 0 && this.isPresent != true) {
        this.assetsLoading = true;
        this.assetLoadingCount = this.arrCommonAssets.length;
        for (let a = 0; a < this.arrCommonAssets.length; a++) {
            let obj = this.arrCommonAssets[a];
            obj.updatingDesign = this.updatingDesign;
            this.loadAssets(obj.array, this.commonAssetsLoadComplete, this.assetError, obj);
        }
        this.arrCommonAssets = [];
    }
    if (this.assetsLoading == false) {
        let isNewDesign = this.updatingDesign != null && this.updatingDesign != undefined && this.updatingDesign == true ? true : false;
        let slideId = this.slideContent ? this.slideContent.id : this.sgParent.parentElement.parentElement.parentElement.id;
        if (this.isPresent != true) {
            //Check and update font class depends on number of lines
            // let arrTitleNodes = this.sgParent.querySelectorAll("[id*='sgTitleNode']");
            // for (let a = 0; a < arrTitleNodes.length; a++) {
            //     if (this.fontSizeChangeOnTextChange && arrTitleNodes[a].innerHTML != "") this.fontSizeChangeOnTextChange(arrTitleNodes[a]);
            // }
            let bggrid = this.objDataToSG && this.objDataToSG.bggrid ? this.objDataToSG.bggrid : null;
            if (this.createGridImage && bggrid) {
                let coverImageParent = this.sgParent.querySelector("[id='coverImageParent']");
                if (coverImageParent && this.objDataToSG?.extraData?.properties?.gridlayout) coverImageParent.setAttribute("floater_additem", "false");
                this.createGridImage(slideId, bggrid);
            }

            if (isNewDesign) this.deviceClippathCheck();
            this.checkShapeDependency();
        }
        // let slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
        // if (slideDomContentGroup && this.isPresent != true && !isNewDesign) {
        // if ((this.updatingDesign != null && this.updatingDesign != undefined && this.updatingDesign != true) || !this.updatingDesign) {
        // } else this.changeVariation(slideDomContentGroup, false, true, true);
        // setTimeout(() => {
        // this.changeVariation(slideDomContentGroup, false, true, true);
        // }, 0);
        // } else if (slideDomContentGroup && this.isPresent != true && isNewDesign) {
        // }
        if (this.isPresent != true)
            setTimeout(() => {
                this.onTextChangeForAllNodes();
            }, 0);

        //Updating image positions for all images
        if (this.isPresent != true) this.specialGraphicsUtils.updateImagePositions(this.sgParent);

        //If inserting asset is sectionbreak
        if (this.reBuildSectiontitleCallback && this.sgSlideType == "sectionbreak") this.reBuildSectiontitleCallback();

        //Text Element positioning after all text's props change
        this.doCommonTextElementPosition();
        if ((this.updatingDesign != null && this.updatingDesign != undefined && this.updatingDesign != true) || !this.updatingDesign) SGBaseClass.prototype.specialGraphicsCreationComplete.call(this);
        if (this.updatingDesign && this.updateThumbnail) this.updateThumbnail(slideId);

        if (this.updatingDesign) this.updatingDesign = false;
    }
    // }
};
GenericCoverpage.prototype.doCommonTextElementPosition = function () {
    //Text Element positioning after all text's props change
    if (this.isPresent != true) {
        let textInnerParentNode = this.sgParent.querySelector("[id='textInnerParentNode']");
        if (this.sgParent.hasAttribute("singlenode") && this.sgParent.getAttribute("singlenode") == "true" && this.textElement && this.textElement.elementData && this.textElement.elementData.textelementproperties) {
            let textElementStyle = this.assetParent.getAttribute("data-textelementstyle");
            let props = this.textElement.elementData.textelementproperties;
            let textElementSelected = props[textElementStyle] ? props[textElementStyle] : Object.keys(props).length > 0 ? props[Object.keys(props)[0]] : null;
            let target = textElementSelected && textElementSelected.target ? textElementSelected.target : null;
            if (target && target == "title" && this.assetParent.querySelector("[id*='titleTextParent")) textInnerParentNode = this.assetParent.querySelector("[id*='titleTextParent']").parentElement;
            if (target && target == "label" && this.assetParent.querySelector("[id*='titleLabelTextParent")) textInnerParentNode = this.assetParent.querySelector("[id*='titleLabelTextParent']").parentElement;
            if (target && target == "subtitle" && this.assetParent.querySelector("[id*='subTitleTextParent")) textInnerParentNode = this.assetParent.querySelector("[id*='subTitleTextParent']").parentElement;
        }
        this.textElementPositioning(this.assetParent, textInnerParentNode);
    }
};

//Doing font fit after all properties updated.
GenericCoverpage.prototype.doFinalFontfit = function () {
    let sgVenueNode = this.sgParent.querySelector("[id='sgVenueNode']");
    let sgmailingAddress = this.sgParent.querySelector("[id='sgmailingAddress']");
    let sgemailAddress = this.sgParent.querySelector("[id='sgemailAddress']");
    let sgphoneNumber = this.sgParent.querySelector("[id='sgphoneNumber']");
    let sgmailingAddressPrompt = this.sgParent.querySelector("[id='venuepromptText']");
    let sgemailAddressPrompt = this.sgParent.querySelector("[id='creatoremailpromptText']");
    let sgphoneNumberPrompt = this.sgParent.querySelector("[id='phonepromptText']");
    let referenceParent = this.sgParent.querySelector("[id='referenceParent']");
    let sgAuthorNameNode = this.sgParent.querySelector("[id='sgAuthorNameNode']");
    let sgAuthorDesignationNode = this.sgParent.querySelector("[id='sgAuthorDesignationNode']");
    if (referenceParent) {
        for (let a = 1; a < 5; a++) {
            let refLink = this.sgParent.querySelector("[id='sgreferenceLink" + a + "']");
            let refLinkHead = this.sgParent.querySelector("[id='sgreferenceLinkHead" + a + "']");
            if (refLink) this.specialGraphicsUtils.doFontFitForCss(refLink, this.sgParent, null, null, null, true);
            if (refLinkHead) this.specialGraphicsUtils.doFontFitForCss(refLinkHead, this.sgParent, null, null, null, true);
        }
    }
    if (sgmailingAddress) this.specialGraphicsUtils.doFontFitForCss(sgmailingAddress, this.sgParent, null, null, null, true);
    if (sgemailAddress) this.specialGraphicsUtils.doFontFitForCss(sgemailAddress, this.sgParent, null, null, null, true);
    if (sgphoneNumber) this.specialGraphicsUtils.doFontFitForCss(sgphoneNumber, this.sgParent, null, null, null, true);
    if (sgmailingAddressPrompt) this.specialGraphicsUtils.doFontFitForCss(sgmailingAddressPrompt, this.sgParent, null, null, null, true);
    if (sgemailAddressPrompt) this.specialGraphicsUtils.doFontFitForCss(sgemailAddressPrompt, this.sgParent, null, null, null, true);
    if (sgphoneNumberPrompt) this.specialGraphicsUtils.doFontFitForCss(sgphoneNumberPrompt, this.sgParent, null, null, null, true);
    if (sgAuthorNameNode) this.specialGraphicsUtils.doFontFitForCss(sgAuthorNameNode, this.sgParent, null, null, null, true);
    if (sgAuthorDesignationNode) this.specialGraphicsUtils.doFontFitForCss(sgAuthorDesignationNode, this.sgParent, null, null, null, true);
    if (sgVenueNode) this.specialGraphicsUtils.doFontFitForCss(sgVenueNode, this.sgParent, null, null, null, true);
    this.doSpeakerFontFit(true);
};
//Assets load error
GenericCoverpage.prototype.assetError = function () {
    this.assetLoadingCount = this.assetLoadingCount - 1;
    if (this.assetLoadingCount == 0) {
        // console.log("SG - all assets load complete");
        this.assetsLoading = false;
        this.arrCommonAssets = [];
        this.specialGraphicsCreationComplete();
    }
};
//Assets load complete
GenericCoverpage.prototype.assetsLoadComplete = function (responseData, objData) {
    for (let i = 0; i < responseData.length; i++) {
        let name = "";
        if (responseData[i].id.includes("skype")) name = "Skype";
        if (responseData[i].id.includes("twitter")) name = "Twitter";
        if (responseData[i].id.includes("facebook")) name = "Facebook";
        if (responseData[i].id.includes("instagram")) name = "Instagram";
        if (responseData[i].id.includes("linkedin")) name = "Linkedin";
        if (responseData[i].id.includes("mail")) name = "Email";
        if (responseData[i].id.includes("phone")) name = "Phone";
        if (responseData[i].id.includes("home")) name = "Home";
        if (responseData[i].id.includes("website")) name = "Website";
        if (responseData[i].id.includes("svgdata")) name = "Illustration";
        var parser = new DOMParser();
        let currentIndex = name == "Linkedin" ? 1 : name == "Twitter" ? 2 : name == "Facebook" ? 3 : name == "Instagram" ? 4 : name == "Skype" ? 5 : -1;
        if (currentIndex != -1) {
            //Cta social icon - svg
            if (this.sgParent.querySelector("[id='customSocialLinkIcon" + currentIndex + "']")) {
                let parent = this.sgParent.querySelector("[id='customSocialLinkIcon" + currentIndex + "']");
                if (parent.getElementsByTagName("svg").length > 0) parent.getElementsByTagName("svg")[0].parentElement.removeChild(parent.getElementsByTagName("svg")[0]);
                var doc = parser.parseFromString(responseData[i].data, "image/svg+xml");
                doc.lastChild.setAttribute("data-nodetype", "iconNode");
                parent.appendChild(doc.lastChild);
                this.applySVGData(parent);
            }
        }
        if (name == "Email" || name == "Phone" || name == "Home" || name == "Website") {
            //Cta contact icon - svg
            let parentId = name == "Email" ? "emailAddressIconNode" : name == "Phone" ? "phoneNumberIconNode" : name == "Website" ? "websiteIconNode" : "mailingAddressIconNode";
            let parent = this.sgParent.querySelector("[id='" + parentId + "']");
            if (parent) {
                if (parent.getElementsByTagName("svg").length > 0) parent.getElementsByTagName("svg")[0].parentElement.removeChild(parent.getElementsByTagName("svg")[0]);
                var doc = parser.parseFromString(responseData[i].data, "image/svg+xml");
                doc.lastChild.setAttribute("data-nodetype", "iconNode");
                parent.appendChild(doc.lastChild);
                this.applySVGData(parent);
            }
        }
        if (name == "Illustration" && this.sgParent.querySelector("[id='svgElementDiv']")) {
            this.sgParent.querySelector("[id='svgElementDiv']").innerHTML = responseData[i].data;
            this.applySVGData(this.sgParent.querySelector("[id='svgElementDiv']"));
        }
        if (responseData[i].parentId && responseData[i].id.includes("quoteIcon") && this.sgParent.querySelector("[id='" + responseData[i].parentId + "']")) {
            //Quote icon - svg
            let parent = this.sgParent.querySelector("[id='" + responseData[i].parentId + "']");

            if (parent.getElementsByTagName("svg").length > 0) parent.getElementsByTagName("svg")[0].parentElement.removeChild(parent.getElementsByTagName("svg")[0]);
            var doc = parser.parseFromString(responseData[i].data, "image/svg+xml");
            doc.lastChild.setAttribute("data-nodetype", "iconNode");
            doc.lastChild.style.overflow = "unset";
            doc.lastChild.style.setProperty("--quoteIconColor", this.assetParent.style.getPropertyValue("--quoteIconColor").trim());
            parent.appendChild(doc.lastChild);
            this.applySVGData(parent);
        }
        if (responseData[i].id.includes("sgIconHolder") && this.sgParent.querySelector("[id='" + responseData[i].id + "']")) {
            let iconNode = this.sgParent.querySelector("[id='" + responseData[i].id + "']");
            var doc = parser.parseFromString(responseData[i].data, "image/svg+xml");
            doc.lastChild.setAttribute("data-nodetype", "iconNode");
            let oldIconNode = iconNode.querySelector("[data-nodetype='iconNode']");
            if (oldIconNode) oldIconNode.parentElement.removeChild(oldIconNode);
            iconNode.appendChild(doc.lastChild);
            this.applySVGData(iconNode);
        }
        let parentNodeForSVG = objData?.parent || responseData[i]?.parent;
        if (responseData[i].id.includes("iconload") && parentNodeForSVG?.querySelector("[id='svgElementDiv']")) {
            let iconNode = parentNodeForSVG.querySelector("[id='svgElementDiv']");
            var doc = parser.parseFromString(responseData[i].data, "image/svg+xml");
            doc.lastChild.setAttribute("data-nodetype", "iconNode");
            iconNode.appendChild(doc.lastChild);
            this.applySVGData(iconNode);
        }
        if (i == responseData.length - 1) {
            let checkSize = true;
            let customLinkIconParent = this.sgParent.querySelector("[id='customLinkIconParent']");
            if (customLinkIconParent && customLinkIconParent.hasAttribute("iconsize")) checkSize = false;
            if (checkSize == true && customLinkIconParent) {
                //icon size calculation based on height
                let arrIcons = this.sgParent.querySelectorAll("[id*='customSocialLinkIcon']");
                let arrIconsParent = this.sgParent.querySelectorAll("[id*='sgCustomSocialLink']");
                let style = arrIcons && arrIcons[0] ? window.getComputedStyle(arrIcons[0]) : null;
                if (arrIconsParent && arrIconsParent[0] && arrIconsParent[0].parentElement.parentElement.style.display != "none") style = window.getComputedStyle(arrIconsParent[0]);
                else if (arrIconsParent && arrIconsParent[1] && arrIconsParent[1].parentElement.parentElement.style.display != "none") style = window.getComputedStyle(arrIconsParent[1]);
                else if (arrIconsParent && arrIconsParent[2] && arrIconsParent[2].parentElement.parentElement.style.display != "none") style = window.getComputedStyle(arrIconsParent[2]);
                else if (arrIconsParent && arrIconsParent[3] && arrIconsParent[3].parentElement.parentElement.style.display != "none") style = window.getComputedStyle(arrIconsParent[3]);
                else if (arrIconsParent && arrIconsParent[4] && arrIconsParent[4].parentElement.parentElement.style.display != "none") style = window.getComputedStyle(arrIconsParent[4]);
                if (style) {
                    let h = parseFloat(style.height) * 0.8 + "px";
                    for (let a = 0; a < arrIcons.length; a++) {
                        arrIcons[a].style.width = h;
                        arrIcons[a].style.height = h;
                        let socialIconTextParent = arrIcons[a].parentElement.parentElement.querySelector("[id='socialIconTextParent']");
                        if (socialIconTextParent) socialIconTextParent.style.maxWidth = "calc(100% - " + (parseFloat(h) + 14) + "px)";
                    }
                }
            } else if (customLinkIconParent) this.ctaIconSizeUpdate();

            let contactParent = this.sgParent.querySelector("[id='contactParent']");
            if (contactParent) this.ctaIconSizeUpdate();
        }
    }
};
GenericCoverpage.prototype.speakerTextMinWidthCalculations = function () {
    try {
        //Speaker text area calculations
        let minWidth = 0;
        let minHeight = 0;
        for (let a = 1; a < 5; a++) {
            let node = this.sgParent.querySelector("[id='speakerTextGroup" + a + "']");
            if (node && node.style.display != "none") {
                let pNode = node.parentElement;
                let oldW;
                if (pNode.style.maxWidth || window.getComputedStyle(pNode).maxWidth) {
                    oldW = "auto";
                    pNode.style.width = pNode.style.maxWidth ? pNode.style.maxWidth : window.getComputedStyle(pNode).maxWidth;
                }

                let min = node.style.minWidth;
                node.style.minWidth = "unset";

                let oldFlex = window.getComputedStyle(node).flex;
                node.style.flex = "unset";
                let w = parseFloat(window.getComputedStyle(node).width);
                if (!isNaN(w) && minWidth < w) minWidth = w;
                node.style.flex = oldFlex;
                node.style.minWidth = min;
                let minH = node.style.minHeight;
                node.style.minHeight = "unset";
                let h = parseFloat(window.getComputedStyle(node).height);
                if (!isNaN(h) && minHeight < h) minHeight = h;
                node.style.minHeight = minH;

                if (oldW) pNode.style.width = oldW;
            }
        }
        if (minWidth != 0) this.assetParent.style.setProperty("--speakerMinWidth", minWidth + "px");
        if (minHeight != 0) this.assetParent.style.setProperty("--speakerMinHeight", minHeight + "px");
    } catch (error) {
        console.log("SG - Error on speakerImageSizeUpdate - " + error);
    }
};
GenericCoverpage.prototype.speakerImageSizeUpdate = function () {
    try {
        //Speaker image size calculations
        let speakerParent = this.sgParent.querySelector("[id='speakerParent']");
        if (speakerParent && speakerParent.hasAttribute("imagesize")) {
            let sizeArray = JSON.parse(speakerParent.getAttribute("imagesize"));
            let totalSize = 0;
            for (let a = 1; a < 5; a++) {
                let speakerNodeGroup = this.sgParent.querySelector("[id='speakerNodeGroup" + a + "']");
                if (speakerNodeGroup && speakerNodeGroup.style.display != "none") totalSize = totalSize + 1;
            }
            let currentSize = sizeArray ? sizeArray[totalSize - 1] : [];
            if (currentSize && currentSize.length > 1) {
                this.assetParent.style.setProperty("--speakerWidth", currentSize[0] + "px");
                this.assetParent.style.setProperty("--speakerHeight", currentSize[1] + "px");
            }
            let sgSpeakerImageNode = speakerParent.querySelectorAll("[id*='sgSpeakerImageNode']");
            if (sgSpeakerImageNode.length > 0) {
                let parentStyle = window.getComputedStyle(sgSpeakerImageNode[0].parentElement.parentElement);
                let w = parseFloat(parentStyle.width);
                let h = parseFloat(parentStyle.height);
                for (let a = 0; a < sgSpeakerImageNode.length; a++) {
                    if (!isNaN(w) && w > 0) sgSpeakerImageNode[a].setAttribute("data-width", w);
                    if (!isNaN(h) && h > 0) sgSpeakerImageNode[a].setAttribute("data-height", h);
                    this.specialGraphicsUtils.updateImageReSize(w, h, sgSpeakerImageNode[a]);
                }
            }
        }
        let arrSpeakerNodeGroup = this.sgParent.querySelectorAll("[id*='speakerNodeGroup']");
        for (let c = 0; c < arrSpeakerNodeGroup.length; c++) {
            arrSpeakerNodeGroup[c].setAttribute("data-count", arrSpeakerNodeGroup.length);
            arrSpeakerNodeGroup[c].parentElement.setAttribute("data-count", arrSpeakerNodeGroup.length);
        }

        let props = this.metaData ? this.metaData[this.designChange == true ? "properties2" : "properties"] : null;
        props = props ? props.speaker : null;
        if (props && props.class && props.class.includes("speakertype3")) {
            let minWidth = 0;
            for (let a = 1; a < 5; a++) {
                let node = this.sgParent.querySelector("[id='speakerTextGroup" + a + "']");
                if (node && node.style.display != "none") {
                    let min = node.style.minWidth;
                    node.style.minWidth = "unset";
                    let oldFlex = window.getComputedStyle(node).flex;
                    node.style.flex = "unset";
                    let w = parseFloat(window.getComputedStyle(node).width);
                    node.style.flex = oldFlex;
                    if (!isNaN(w) && minWidth < w) minWidth = w;
                    node.style.minWidth = min;
                }
            }
            if (minWidth != 0) this.assetParent.style.setProperty("--speakerMinWidth", minWidth + "px");
        }
    } catch (error) {
        console.log("SG - Error on speakerImageSizeUpdate - " + error);
    }
};
GenericCoverpage.prototype.ctaIconSizeUpdate = function () {
    try {
        //icon size calculation based on property given in menu
        //CTA social icons
        let customLinkIconParent = this.sgParent.querySelector("[id='customLinkIconParent']");
        if (customLinkIconParent && customLinkIconParent.hasAttribute("iconsize")) {
            let sizeArray = JSON.parse(customLinkIconParent.getAttribute("iconsize"));
            let arrIcons = this.sgParent.querySelectorAll("[id*='customSocialLinkIcon']");
            let totalSize = 0;
            for (let a = 1; a < 6; a++) {
                let iconParent = this.sgParent.querySelector("[id='sgCustomSocialLink" + a + "']");
                if (iconParent && iconParent.style.display != "none") totalSize = totalSize + 1;
            }
            let currentSize = sizeArray[totalSize - 1];
            if (currentSize && currentSize.length > 1)
                for (let b = 0; b < arrIcons.length; b++) {
                    this.assetParent.style.setProperty("--ctaIconWidth", currentSize[0] + "px");
                    this.assetParent.style.setProperty("--ctaIconHeight", currentSize[1] + "px");
                }
        }
        //CTA contact
        let contactParent = this.sgParent.querySelector("[id='contactParent']");
        if (contactParent && contactParent.hasAttribute("iconsize")) {
            let sgmailingAddressParent = this.sgParent.querySelector("[id='sgmailingAddressParent']");
            let sgemailAddressParent = this.sgParent.querySelector("[id='sgemailAddressParent']");
            let sgphoneNumberParent = this.sgParent.querySelector("[id='sgphoneNumberParent']");
            let sgwebsiteParent = this.sgParent.querySelector("[id='sgwebsiteParent']");
            let sizeArray = JSON.parse(contactParent.getAttribute("iconsize"));
            let totalSize = 0;
            if (sgphoneNumberParent && sgphoneNumberParent.style.display != "none") totalSize = totalSize + 1;
            if (sgemailAddressParent && sgemailAddressParent.style.display != "none") totalSize = totalSize + 1;
            if (sgmailingAddressParent && sgmailingAddressParent.style.display != "none") totalSize = totalSize + 1;
            if (sgwebsiteParent && sgwebsiteParent.style.display != "none") totalSize = totalSize + 1;
            let currentSize = sizeArray[totalSize - 1] ? sizeArray[totalSize - 1] : null;
            if (currentSize) this.assetParent.style.setProperty("--contactIconSize", currentSize[0] + "px");
        }
    } catch (error) {
        console.log("SG - Error on ctaIconSizeUpdate - " + error);
    }
};
GenericCoverpage.prototype.applySVGData = function (svgChild) {
    if (svgChild.getElementsByTagName("svg").length > 0) {
        let svgDOM = svgChild.getElementsByTagName("svg")[0];
        svgDOM.style.width = "100%";
        svgDOM.style.height = "100%";
    }
    if (this.socialiconsData && svgChild && svgChild.id.includes("customSocialLinkIcon")) {
        this.specialGraphicsUtils.socialIconsPropertyApplyFromMood(this.socialiconsData, svgChild, this.assetParent);
    }
};
GenericCoverpage.prototype.createNestedNodes = function (subNodes, nodeParentToInsert) {
    for (let j = 0; j < subNodes.length; j++) {
        let nodeObj = subNodes[j];
        let nodeParent = this.createNodes(nodeObj, nodeParentToInsert);
        if (nodeObj.subNodes && nodeParent) {
            this.createNestedNodes(nodeObj.subNodes, nodeParent);
        }
    }
};
GenericCoverpage.prototype.createNodes = function (nodeObj, nodeParent) {
    let name = nodeObj.name;
    switch (name) {
        case "contentMainParent":
        case "contentNode":
        case "contentNode1":
        case "contentNode2":
        case "contentNode3":
        case "contentNode4":
        case "contentNode5":
        case "contentNode6":
        case "secContentNode":
        case "secContentNode1":
        case "secContentNode2":
        case "secContentNode3":
        case "secContentNode4":
        case "secContentNode5":
        case "secContentNode6":
            return this.createContentNode(nodeParent, nodeObj, name);
        case "img":
            this.createImageNode(nodeParent, nodeObj.flexvalue);
            break;
        case "tit":
        case "text":
            this.createTitleNode(nodeParent, nodeObj.flexvalue);
            break;
        case "title":
            this.createSingleTitleNode(nodeParent, nodeObj.flexvalue);
            break;
        case "subtitle":
            this.createSingleSubTitleNode(nodeParent, nodeObj.flexvalue);
            break;
        case "label":
            this.createSingleLabelNode(nodeParent, nodeObj.flexvalue);
            break;
        case "logo":
            this.createLogoNode(nodeParent);
            break;
        // case "logo1":
        //     this.createLogoNode(nodeParent, 1);
        //     break;
        case "pre":
            this.createPresenterNode(nodeParent, nodeObj.flexvalue, name);
            break;
        case "presentertext":
            this.createPresenterTextNode(nodeParent, nodeObj.flexvalue);
            break;
        case "presenterimage":
            this.createPresenterImageNode(nodeParent, nodeObj.flexvalue);
            break;
        case "cus":
            this.createCustomerNode(nodeParent, nodeObj.flexvalue, name);
            break;
        case "customertext":
            this.createCustomerTextNode(nodeParent, nodeObj.flexvalue);
            break;
        case "customerimage":
            this.createCustomerImageNodeAlone(nodeParent, nodeObj.flexvalue);
            break;
        case "num":
            this.createNumberNode(nodeParent, "num", nodeObj.flexvalue);
            break;
        case "yr":
            this.createNumberNode(nodeParent, "yr", nodeObj.flexvalue);
            break;
        case "venue":
            this.createVenueNode(nodeParent);
            break;
        case "social":
            this.createSocialIconNode(nodeParent);
            break;
        case "contact":
            this.contactBase(nodeParent);
            break;
        case "reference":
            this.createReferenceBase(nodeParent);
            break;
        case "ctasocial":
            this.createSocialData(nodeParent);
            break;
        case "sectionnum":
            this.createNumberTextNode(nodeParent, 0, null, true);
            break;
        case "authtext":
            this.createAuthorTextBase(nodeParent, nodeObj.flexvalue);
            break;
        case "authimg":
            this.createAuthorImageNode(nodeParent);
            break;
        case "quoteicon":
        case "quoteicon1":
            this.createQuoteIcon(nodeParent, 1);
            break;
        case "quoteicon2":
            this.createQuoteIcon(nodeParent, 2);
            break;
        case "quoteicon3":
            this.createQuoteIcon(nodeParent, 3);
            break;
        case "presentedto":
            this.createPresentedToNode(nodeParent);
            break;
        case "presentedby":
            this.createPresentedByNode(nodeParent);
            break;
        case "bgimage":
        case "bgimage1":
            this.createBgImageNode(nodeParent);
            break;
        case "presetimage":
            this.createPresetImageNode(nodeParent);
            break;
        case "quotetitle":
            this.createQuotePlaceHolder(nodeParent);
            break;
        case "quotetakeaway":
            this.createQuoteTakeaway(nodeParent);
            break;
        case "footer":
            this.createFooterNode(nodeParent);
            break;
        case "speaker":
            this.createSpeakerNodes(nodeParent);
            break;
        case "shape1":
        case "shape2":
        case "shape3":
        case "shape4":
        case "shape5":
            let propertyValue = null;
            let propType = this.designChange == true ? "properties2" : "properties";
            if (this.metaData && this.metaData[propType] && this.metaData[propType][name]) propertyValue = this.metaData[propType][name];
            this.createShapes(nodeParent, name, propertyValue, name.replace("shape", ""));
            break;
        case "placeholderimage":
            this.createPlaceHolder(nodeParent, 0);
            break;
        case "presentercompany":
            this.createPresenterCompanyNameNode(nodeParent);
            break;
        case "customercompany":
            this.createCustomerCompanyNameNode(nodeParent);
            break;
        case "customerlogo":
        case "presenterlogo":
            this.createPresenterCustomerLogoNode(nodeParent, name == "customerlogo");
            break;
        case "venuetitle":
            this.createVenueTitleNode(nodeParent);
            break;
        case "authortitle":
            this.createAuthorTitleNode(nodeParent);
            break;
        case "datetitle":
            this.createDateTitleNode(nodeParent);
            break;
        case "ctabutton":
            this.createCtaButtonNode(nodeParent);
            break;
        case "quotetestimonial":
            this.createQuoteTestimonial(nodeParent);
            break;
        // case "map":
        //     this.createMap(nodeParent);
        //     break;
        case "socialicons":
            this.createSocialIcons(nodeParent, nodeObj.flexvalue);
            break;
        case "devicesvg":
            this.createDeviceSvg(nodeParent);
            break;
        case "websitelink":
            this.createWebsiteLinkNode(nodeParent);
            break;
        // case "eventdate":
        //     this.createEventDate(nodeParent);
        //     break;
        // case "eventyear":
        //     this.createEventYear(nodeParent);
        //     break;
        // case "eventmonth":
        //     this.createEventMonth(nodeParent);
        //     break;
        // case "eventtime":
        //     this.createEventTime(nodeParent);
        //     break;
        // case "eventicon":
        //     this.createEventIcon(nodeParent);
        //     break;
        case "commonbg":
            this.createCommonBgImage(nodeParent);
            break;
        case "img1":
            this.createImageNode(nodeParent, nodeObj.flexvalue, 1);
            break;
        case "devicesvg1":
            this.createDeviceSvg(nodeParent, 1);
            break;
        default:
            break;
    }
};
GenericCoverpage.prototype.createContentNode = function (parent, props, id) {
    if (id == "contentMainParent" && parent.querySelector("[id='contentMainParent']")) parent.querySelector("[id='contentMainParent']").parentElement.removeChild(parent.querySelector("[id='contentMainParent']"));
    let nodeParent = document.createElement("div");
    nodeParent.className = id;
    nodeParent.style.pointerEvents = "none";
    nodeParent.setAttribute("id", id);
    parent.appendChild(nodeParent);
    nodeParent.style.display = "flex";
    this.setTextType(nodeParent);
    let specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL, this);
    specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });

    if (props && props.class) {
        nodeParent.className = id + "  " + props.class;
        if (nodeParent.classList.contains("valign_s") || nodeParent.classList.contains("valign_c") || nodeParent.classList.contains("valign_e")) {
            let direction = window.getComputedStyle(nodeParent).flexDirection;
            if (direction == "row") nodeParent.style.alignItems = nodeParent.classList.contains("valign_c") ? "center" : nodeParent.classList.contains("valign_e") ? "flex-end" : "flex-start";
            else nodeParent.style.justifyContent = nodeParent.classList.contains("valign_c") ? "center" : nodeParent.classList.contains("valign_e") ? "flex-end" : "flex-start";
        }
        if (nodeParent.classList.contains("halign_s") || nodeParent.classList.contains("halign_c") || nodeParent.classList.contains("halign_e")) {
            let direction = window.getComputedStyle(nodeParent).flexDirection;
            if (direction == "row") nodeParent.style.justifyContent = nodeParent.classList.contains("halign_c") ? "center" : nodeParent.classList.contains("halign_e") ? "flex-end" : "flex-start";
            else nodeParent.style.alignItems = nodeParent.classList.contains("halign_c") ? "center" : nodeParent.classList.contains("halign_e") ? "flex-end" : "flex-start";
        }
    } else nodeParent.style.display = "block";
    if (props.positionvalue) nodeParent.style.position = props.positionvalue;
    if (props.zorder) nodeParent.style.zIndex = props.zorder;
    if (props.order) nodeParent.style.order = props.order;
    if (props.flexvalue) nodeParent.style.flex = props.flexvalue;
    if (props.position && props.position.split(",").length == 4) specialgraphicsPropertyUtils.updatePosition(nodeParent, props.position);

    if (props.padding) specialgraphicsPropertyUtils.updatePadding(props.padding, nodeParent, true);
    if (props.margin) specialgraphicsPropertyUtils.updateMargin(props.margin, nodeParent);
    if (props.maxwidth) {
        let w = nodeParent.style.width;
        nodeParent.style.width = props.maxwidth + (props.maxwidth.includes("px") || props.maxwidth.includes("%") ? "" : "px");
        nodeParent.style.maxWidth = props.maxwidth + (props.maxwidth.includes("px") || props.maxwidth.includes("%") ? "" : "px");
        nodeParent.setAttribute("fullwidth", window.getComputedStyle(nodeParent).width);
        nodeParent.style.width = w;
    }
    if (props.maxheight) {
        let oldH = null;
        if (nodeParent.parentElement.hasAttribute("fullheight")) {
            oldH = nodeParent.parentElement.style.height;
            nodeParent.parentElement.style.height = nodeParent.parentElement.getAttribute("fullheight");
        }

        let oldHeight = nodeParent.style.height;
        nodeParent.style.height = props.maxheight + (props.maxheight.includes("px") || props.maxheight.includes("%") ? "" : "px");
        nodeParent.style.maxHeight = props.maxheight + (props.maxheight.includes("px") || props.maxheight.includes("%") ? "" : "px");
        let h = window.getComputedStyle(nodeParent).height;
        nodeParent.style.height = oldHeight;
        nodeParent.setAttribute("fullheight", h);

        if (oldH && nodeParent.parentElement.hasAttribute("fullheight")) nodeParent.parentElement.style.height = oldH;
    }
    this.specialGraphicsUtils.updatePaddingMarginInlineStyle(nodeParent);
    // let styleData = window.getComputedStyle(nodeParent);
    // nodeParent.style.setProperty("--paddingLeft", styleData.paddingLeft);
    // nodeParent.style.setProperty("--paddingRight", styleData.paddingRight);
    // nodeParent.style.setProperty("--paddingTop", styleData.paddingTop);
    // nodeParent.style.setProperty("--paddingBottom", styleData.paddingBottom);
    // nodeParent.style.setProperty("--marginLeft", styleData.marginLeft);
    // nodeParent.style.setProperty("--marginRight", styleData.marginRight);
    // nodeParent.style.setProperty("--marginTop", styleData.marginTop);
    // nodeParent.style.setProperty("--marginBottom", styleData.marginBottom);

    return nodeParent;
};
GenericCoverpage.prototype.createSocialIconNode = function (parent) {
    //Cpverpage Social icon Nodes - "social"
    this.createSocialIconCover(parent);
};
GenericCoverpage.prototype.createVenueNode = function (parent) {
    //Venue - "venue"
    this.createVenue(parent);
};
GenericCoverpage.prototype.createNumberNode = function (parent, type = "yr", flexValue = null) {
    //Annual Year / things todo number  - "yr"/"num"
    let propertyValue = null;
    if (this.metaData && this.metaData && this.metaData[this.designChange == true ? "properties2" : "properties"] && this.metaData[this.designChange == true ? "properties2" : "properties"]["number"])
        propertyValue = this.metaData[this.designChange == true ? "properties2" : "properties"]["number"].prompt ? this.metaData[this.designChange == true ? "properties2" : "properties"]["number"].prompt : null;
    this.createCoverNumber(parent, type, propertyValue, flexValue);
};
GenericCoverpage.prototype.createLogoNode = function (parent, index) {
    if (this.createLogoGrid) {
        let logoGridParent = document.createElement("div");
        logoGridParent.id = "logoGridParent" + (index ? index : "");
        logoGridParent.className = "logoGridParent moodanimation";
        logoGridParent.style.height = "auto";
        logoGridParent.setAttribute("data-animation", "logo");
        logoGridParent.setAttribute("data-type", "IMAGE");
        parent.appendChild(logoGridParent);

        let props = this.getPropertyData();
        let specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL, this);
        specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
        let logoProp = index ? props?.logo1?.position : props?.logo?.position;
        if (logoProp) {
            let pos = props[index ? "logo1" : "logo"].position.split(",");
            props[index ? "logo1" : "logo"].position = pos[0] + "," + pos[1] + ",100%,auto";
            specialgraphicsPropertyUtils.updatePosition(logoGridParent, props[index ? "logo1" : "logo"].position);
        }
        // // this.applyLogoGridSize(props);
        // let logogrid = this.objDataToSG && this.objDataToSG.logogrid ? this.objDataToSG.logogrid : null;
        // let slideId = this.slideContent ? this.slideContent.id : null;
        // this.createLogoGrid(logoGridParent, logogrid, slideId);
    } else {
        //Logo image - "logo"
        this.createLogoImageNode(parent, this.sgParent);
        let logoImageParent = this.sgParent.querySelector("[id*='logoImageParent']");
        if (logoImageParent) {
            let logoContentParent = this.sgParent.querySelector("[id*='logoContentParent']");
            let zOrderValue = 0;
            let logoZIndex = parseFloat(window.getComputedStyle(logoImageParent).zIndex);
            let parentZIndex = parseFloat(window.getComputedStyle(parent).zIndex);
            if (!isNaN(parentZIndex) && parentZIndex > 0) zOrderValue = parentZIndex;
            if (!isNaN(logoZIndex) && logoZIndex > 0) zOrderValue = zOrderValue + logoZIndex;
            logoImageParent.style.zIndex = zOrderValue;
            if (logoContentParent) logoContentParent.style.zIndex = zOrderValue;
        }
    }
};
GenericCoverpage.prototype.createPresenterCustomerLogoNode = function (parent, isCustomer) {
    //Customer Logo image - "customerlogo"
    let oldNode = this.sgParent.querySelector("[id*='" + (isCustomer ? "customer" : "presenter") + "LogoContentParent']");
    if (oldNode) oldNode.parentElement.removeChild(oldNode);

    this.createPresenterCustomerLogoImageNode(parent, this.sgParent, 0, null, isCustomer);
    let logoImageParent = this.sgParent.querySelector("[id*='" + (isCustomer ? "customer" : "presenter") + "LogoImageParent']");
    if (logoImageParent) {
        let logoContentParent = this.sgParent.querySelector("[id*='" + (isCustomer ? "customer" : "presenter") + "LogoContentParent']");
        logoContentParent.style.width = "100%";
        logoImageParent.style.width = "100%";
        let zOrderValue = 0;
        let logoZIndex = parseFloat(window.getComputedStyle(logoImageParent).zIndex);
        let parentZIndex = parseFloat(window.getComputedStyle(parent).zIndex);
        if (!isNaN(parentZIndex) && parentZIndex > 0) zOrderValue = parentZIndex;
        if (!isNaN(logoZIndex) && logoZIndex > 0) zOrderValue = zOrderValue + logoZIndex;

        logoImageParent.style.zIndex = zOrderValue;
        if (logoContentParent) logoContentParent.style.zIndex = zOrderValue;

        let logoInstance;

        let divParent = document.createElement("div");
        divParent.id = (isCustomer ? "customer" : "presenter") + "diagramparent";
        let oldDiagramParent = parent.querySelector("[id='diagramparent']");
        if (oldDiagramParent) oldDiagramParent.parentElement.removeChild(oldDiagramParent);
        logoImageParent.appendChild(divParent);
        divParent.className = "clsLinearImageGrid";
        divParent.classList.add("clsLinerDiagram");
        divParent.classList.add("clsLinearImageGridNode");
        divParent.style.height = "auto";
        divParent.style.alignItems = "flex-start";
        divParent.style.maxHeight = "inherit";

        let props = this.getPropertyData();
        let logoProp = isCustomer ? props.customerlogo : props.presenterlogo;
        this.applyCustomLogoProps(isCustomer, divParent);
        this.applyCustomLogoGridSize(logoProp, divParent);

        let logoimagesize = "medium";
        if (logoImageParent.hasAttribute("data-logoimagesize")) logoimagesize = logoImageParent.getAttribute("data-logoimagesize");
        else logoimagesize = logoProp.logoimagesize ? logoProp.logoimagesize : logoimagesize;
        let logoImageSizeValue = this.specialGraphicsUtils.getImageSizeSML(logoimagesize);
        let largeHeight = divParent.style.getPropertyValue("--logoSizeHeight");

        let scaledLogoSize = parseFloat(largeHeight) * logoImageSizeValue;

        let supportContrast = logoProp.contrast && (logoProp.contrast == "true" || logoProp.contrast == true) ? true : false;
        let contrastVal = { supportcontrast: supportContrast, disablelogocontrast: false };

        logoImageParent.setAttribute("data-supportcontrast", supportContrast);
        let defaultLogo = this.objDataToSG && this.objDataToSG.logoDefaultData ? this.objDataToSG.logoDefaultData : [];
        logoInstance = new window["SimpleImageGrid"](divParent, { logoHeight: scaledLogoSize }, this.appStaticURL, defaultLogo, contrastVal, isCustomer ? 1 : 2, this.logoCompleteCallback);

        let arrImage = [];
        let imgPath = isCustomer ? this.sgData[0]["customerlogoimage"] : this.sgData[0]["presenterlogoimage"];
        arrImage.push({
            type: "image",
            value: imgPath ? imgPath : this.objDataToSG?.companylogo || this.appStaticURL + "genericassets/placeholderimages/logoplaceholder_landscape.png",
            contenttype: "logo",
            logocontrast: true,
        });

        let oldData = isCustomer ? this.objDataToSG.customerlogogrid : this.objDataToSG.presenterlogogrid;
        logoInstance.gridimages = oldData?.length > 0 ? oldData : arrImage;

        let slideID = this.slideContent && this.slideContent.id ? this.slideContent.id : null;

        logoInstance.updateCallBack = {
            func: this.updateSlidePropsCallBack,
            params: { slideID: slideID },
        };
        logoInstance.initDiagramCreationNode(isCustomer ? 1 : 2, {}, divParent);

        if (isCustomer) this.customerLogoInstance = logoInstance;
        else this.presenterLogoInstance = logoInstance;
    }
};
GenericCoverpage.prototype.applyCustomLogoProps = function (isCustomer, divParent) {
    let a = isCustomer ? 0 : 1;
    let props = this.getPropertyData();
    let specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL, this);
    specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
    let typeOfImage = a == 0 ? "customer" : "presenter";
    let logoProp = a == 0 ? props.customerlogo : props.presenterlogo;
    if (logoProp && this.sgParent.querySelector("[id='" + typeOfImage + "LogoImageParent']")) {
        let logoImageParent = this.sgParent.querySelector("[id='" + typeOfImage + "LogoImageParent']");
        let logoContentParent = this.sgParent.querySelector("[id='" + typeOfImage + "LogoContentParent']");
        let logoImageNode = this.sgParent.querySelector("[id='sg" + (typeOfImage == "customer" ? "Customer" : "Presenter") + "LogoImageNode']");
        if (logoProp.logosizestyle) {
            logoContentParent.setAttribute("data-logosizestyle", props[typeOfImage + "logo"].logosizestyle);
            if (!logoContentParent.classList.contains("logoSizeStyle")) logoContentParent.classList.add("logoSizeStyle");
            if (!logoImageParent.classList.contains(logoProp.logosizestyle)) logoImageParent.classList.add(logoProp.logosizestyle);
        }
        specialgraphicsPropertyUtils.applyImageBaseProps(logoProp, this.assetParent, logoContentParent, typeOfImage + "Logo");
        if (logoProp.positionvalue) this.assetParent.style.setProperty("--" + typeOfImage + "LogoPosition", logoProp.positionvalue);
        if (logoProp.zorder) this.assetParent.style.setProperty("--" + typeOfImage + "LogoImageZorder", logoProp.zorder);

        if (this.sgData[0] && this.sgData[0][typeOfImage + "logoimagesize"] && logoImageParent) logoImageParent.setAttribute("data-logoimagesize", this.sgData[0][typeOfImage + "logoimagesize"]);
        this.setCustomerLogoSizes(a + 1);

        if (this.sgData[0] && this.sgData[0][typeOfImage + "logoimagesize"]) {
            //Implement logo size change from floter
            let multipleValue = this.specialGraphicsUtils.getImageSizeSML(this.sgData[0][typeOfImage + "logoimagesize"]);
            let largeW = parseFloat(logoImageParent.getAttribute("data-largewidth"));
            let largeH = parseFloat(logoImageParent.getAttribute("data-largeheight"));
            let newW = largeW * multipleValue;
            let newH = largeH * multipleValue;
            let cropHeight = logoImageNode && logoImageNode.hasAttribute("logosizecropheight") ? logoImageNode.getAttribute("logosizecropheight") : "";
            if (newW > 0 && newH > 0) {
                logoImageParent.style.width = newW + "px";
                if (cropHeight == "") logoImageParent.style.height = newH + "px";
            }
            if (logoImageNode) logoImageNode.removeAttribute("logosizecropheight");
        }
        this.applyChildStyleToParent(logoContentParent, logoImageParent);
        logoContentParent.style.margin = logoImageParent.style.margin;
        logoImageParent.style.margin = "unset";
        logoContentParent.classList.remove("shapeHolder");
        if (logoProp.hposition && divParent) {
            let hAlignProp = isCustomer ? "--customerLogoImageAlignHorizontal" : "--presenterLogoImageAlignHorizontal";
            let hAlignVal = logoProp.hposition == "left" || logoProp.hposition == "start" ? "flex-start" : logoProp.hposition == "right" || logoProp.hposition == "end" ? "flex-end" : "center";
            this.assetParent.style.setProperty(hAlignProp, hAlignVal);
            divParent.style.justifyContent = hAlignVal;
        }
        if (logoProp.color) {
            logoContentParent.classList.remove(logoProp.color);
            logoContentParent.classList.add(logoProp.color);
            logoContentParent.classList.add("shapeHolder");
        }
        if (logoProp.globalstyle && logoContentParent) {
            logoContentParent.classList.remove(logoProp.globalstyle);
            logoContentParent.classList.add(logoProp.globalstyle);
            logoContentParent.classList.add("clsSingleColorParent");

            let percentValue = window.getComputedStyle(logoContentParent).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
            percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
            let sourceNode = logoContentParent.querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
            if (sourceNode) logoContentParent.style.setProperty("--customNodeBorderImageWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
        }
        if (logoProp.contentBG) {
            let arrAssets = [];
            arrAssets.push({
                parent: logoContentParent,
                type: "svg",
                url: logoProp.contentBG.value,
                id: logoProp.contentBG.id,
                color: logoProp.contentBG.color,
            });
            this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
        }
        if (logoImageNode) {
            if (this.sgData[0][typeOfImage + "logoimagecontrast"]) {
                logoImageNode.classList.remove("logoBrightnessSGUnset");
                if (this.sgData[0][typeOfImage + "logoimagecontrast"] == "false") logoImageNode.classList.add("logoBrightnessSGUnset");
            }
            this.applyContrastToText(logoImageNode, logoProp);
        }
        if (this.sgData?.[0]?.[typeOfImage + "logoimageprompt"]) logoImageParent.setAttribute("data-node-graphic-text", this.sgData[0][typeOfImage + "logoimageprompt"]);
    }
};
GenericCoverpage.prototype.logoCompleteCallback = function (parent) {
    // console.log("Got custom logo grid complete callback");
    this.logoGridImagesLoadComplete = true;
    this.logoGridUpdateLayout();
    this.checkShapeDependency();
};

GenericCoverpage.prototype.logoGridUpdateLayout = function () {
    if (this.initComplete && this.logoGridImagesLoadComplete) {
        let props = this.getPropertyData();
        let customerLogoImageParent = this.sgParent.querySelector("[id*='customerLogoImageParent']");
        let presenterLogoImageParent = this.sgParent.querySelector("[id*='presenterLogoImageParent']");
        if (this.customerLogoInstance?.imageLayoutManager?.updateLayout && customerLogoImageParent && props?.customerlogo) {
            customerLogoImageParent.parentElement.style.width = "100%";
            let divParent = customerLogoImageParent.querySelector("[id='customerdiagramparent']");
            let logoProp = props.customerlogo;
            this.applyCustomLogoGridSize(logoProp, divParent);

            let logoimagesize = "medium";
            if (customerLogoImageParent.hasAttribute("data-logoimagesize")) logoimagesize = customerLogoImageParent.getAttribute("data-logoimagesize");
            else logoimagesize = logoProp.logoimagesize ? logoProp.logoimagesize : logoimagesize;
            let logoImageSizeValue = this.specialGraphicsUtils.getImageSizeSML(logoimagesize);
            let largeHeight = divParent.style.getPropertyValue("--logoSizeHeight");
            let scaledLogoSize = parseFloat(largeHeight) * logoImageSizeValue;

            customerLogoImageParent.dataset.scaledheight = scaledLogoSize;
            this.customerLogoInstance?.imageLayoutManager?.updateLayout(customerLogoImageParent);
        }
        if (this.presenterLogoInstance?.imageLayoutManager?.updateLayout && presenterLogoImageParent && props?.presenterlogo) {
            presenterLogoImageParent.parentElement.style.width = "100%";
            let divParent = presenterLogoImageParent.querySelector("[id='presenterdiagramparent']");
            let logoProp = props.presenterlogo;
            this.applyCustomLogoGridSize(logoProp, divParent);

            let logoimagesize = "medium";
            if (presenterLogoImageParent.hasAttribute("data-logoimagesize")) logoimagesize = presenterLogoImageParent.getAttribute("data-logoimagesize");
            else logoimagesize = logoProp.logoimagesize ? logoProp.logoimagesize : logoimagesize;
            let logoImageSizeValue = this.specialGraphicsUtils.getImageSizeSML(logoimagesize);
            let largeHeight = divParent.style.getPropertyValue("--logoSizeHeight");
            let scaledLogoSize = parseFloat(largeHeight) * logoImageSizeValue;

            presenterLogoImageParent.dataset.scaledheight = scaledLogoSize;

            this.presenterLogoInstance?.imageLayoutManager?.updateLayout(presenterLogoImageParent);
        }
    }
};
GenericCoverpage.prototype.updateSlidePropsCallBack = function () {};
GenericCoverpage.prototype.createPresenterNode = function (parent, flexValue = "", type) {
    let propertyValue = null;
    if (this.metaData?.[this.designChange == true ? "properties2" : "properties"]?.["presenter"]) propertyValue = this.metaData[this.designChange == true ? "properties2" : "properties"]["presenter"];
    //Presenter Data - "pre"
    let presenterParent = this.createPresenterBaseWithData(parent, type, propertyValue);
    if (flexValue && flexValue != "" && presenterParent) presenterParent.style.flex = flexValue;
};
GenericCoverpage.prototype.createPresenterTextNode = function (parent, flexValue = "") {
    //Presenter Data - "presentertext"
    let propertyValue = null;
    if (this.metaData?.[this.designChange == true ? "properties2" : "properties"]?.["presentertext"]) propertyValue = this.metaData[this.designChange == true ? "properties2" : "properties"]["presentertext"];
    let presenterTextAloneParent = this.createPresenterTextWithData(parent, propertyValue);
    if (flexValue && flexValue != "" && presenterTextAloneParent) presenterTextAloneParent.style.flex = flexValue;
};
GenericCoverpage.prototype.createPresenterImageNode = function (parent, flexValue = "") {
    //Presenter Data - "presenterimage"
    let presenterImageAloneParent = this.createPresenterImageWithData(parent);
    if (flexValue && flexValue != "" && presenterImageAloneParent) presenterImageAloneParent.style.flex = flexValue;
};
GenericCoverpage.prototype.createCustomerTextNode = function (parent, flexValue = "") {
    //Presenter Data - "customertext"
    let propertyValue = null;
    if (this.metaData?.[this.designChange == true ? "properties2" : "properties"]?.["customertext"]) propertyValue = this.metaData[this.designChange == true ? "properties2" : "properties"]["customertext"];
    let customerTextAloneParent = this.createCustomerTextWithData(parent, propertyValue);
    if (flexValue && flexValue != "" && customerTextAloneParent) customerTextAloneParent.style.flex = flexValue;
};
GenericCoverpage.prototype.createCustomerImageNodeAlone = function (parent, flexValue = "") {
    //Presenter Data - "customerimage"
    let presenterImageAloneParent = this.createCustomerImageWithData(parent);
    if (flexValue && flexValue != "" && presenterImageAloneParent) presenterImageAloneParent.style.flex = flexValue;
};
GenericCoverpage.prototype.createCustomerNode = function (parent, flexValue = "", type) {
    let propertyValue = null;
    let propName = this.designChange == true ? "properties2" : "properties";
    if (this.metaData && this.metaData && this.metaData[propName] && this.metaData[propName]["customer"]) propertyValue = this.metaData[propName]["customer"];
    //Presenter Data - "pre"
    let customerParent = this.createCustomerBaseWithData(parent, propertyValue);
    if (flexValue && flexValue != "" && customerParent) customerParent.style.flex = flexValue;
};
GenericCoverpage.prototype.createTitleNode = function (parent, flexValue = "") {
    //Text Nodes - "tit"
    let textInnerParent = this.createTextBase(parent, 0);
    let textBaseParent = this.sgParent.querySelector("[id*='textBaseParentNode']");
    if (textBaseParent) {
        let zOrderValue = 0;
        let textZIndex = parseFloat(window.getComputedStyle(textBaseParent).zIndex);
        let parentZIndex = parseFloat(window.getComputedStyle(parent).zIndex);
        if (!isNaN(parentZIndex) && parentZIndex > 0) zOrderValue = parentZIndex;
        if (!isNaN(textZIndex) && textZIndex > 0) zOrderValue = zOrderValue + textZIndex;

        textBaseParent.style.zIndex = zOrderValue;
    }
    if (flexValue && flexValue != "") textBaseParent.style.flex = flexValue;
    this.createTitleSet(textInnerParent, 0, parent);
};
GenericCoverpage.prototype.createSingleTitleNode = function (parent, flexValue = "") {
    this.sgParent.setAttribute("singlenode", "true");
    //Text Nodes - title only
    let textParent = this.createSingleTitle(parent);
    if (flexValue && flexValue != "") textParent.style.flex = flexValue;
    // this.createTextElement(parent);
};
GenericCoverpage.prototype.createSingleSubTitleNode = function (parent, flexValue = "") {
    this.sgParent.setAttribute("singlenode", "true");
    //Text Nodes - title only
    let textParent = this.createSingleSubTitle(parent);
    if (flexValue && flexValue != "") textParent.style.flex = flexValue;
    // this.createTextElement(parent);
};
GenericCoverpage.prototype.createSingleLabelNode = function (parent, flexValue = "") {
    this.sgParent.setAttribute("singlenode", "true");
    //Text Nodes - title only
    let textParent = this.createSingleLabel(parent);
    if (flexValue && flexValue != "") textParent.style.flex = flexValue;
    // this.createTextElement(parent);
};
GenericCoverpage.prototype.createImageNode = function (parent, flexValue = "", index = 0) {
    //Coverimage - "img"
    let props = this.getPropertyData();
    let imageProp;
    if (props && props["image" + (index == 0 ? "" : index)]) imageProp = props["image" + (index == 0 ? "" : index)];
    let svgSupport = imageProp?.supportsvg && imageProp.supportsvg == "false" ? false : true;
    let coverParent = this.createCoverImageParent(parent, 0, true, imageProp, index == 0 ? "" : index);
    if (flexValue && flexValue != "") coverParent.style.flex = flexValue;
    this.createCoverImageNode(coverParent, 0, "generic", svgSupport, index == 0 ? "coverimage" : "coverimage" + index);

    let coverImageParent = this.sgParent.querySelector("[id*='coverImageParent" + (index == 0 ? "" : index) + "']");
    if (coverImageParent && index == 0) {
        let zOrderValue = 0;
        let imageZIndex = parseFloat(window.getComputedStyle(coverImageParent).zIndex);
        let parentZIndex = parseFloat(window.getComputedStyle(parent).zIndex);
        if (!isNaN(parentZIndex) && parentZIndex > 0) zOrderValue = parentZIndex;
        if (!isNaN(imageZIndex) && imageZIndex > 0) zOrderValue = zOrderValue + imageZIndex;

        coverImageParent.style.zIndex = zOrderValue;
    }
};
GenericCoverpage.prototype.createDeviceSvg = function (parent, index = "") {
    let deviceHolderNode = this.createDeviceSvgNode(parent, index);
    let props = this.getPropertyData();

    if (props[index == 0 ? "devicesvg" : "devicesvg" + index]) {
        let deviceProp = props[index == 0 ? "devicesvg" : "devicesvg" + index];
        let specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL, this);
        specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
        if (deviceProp.position) specialgraphicsPropertyUtils.updatePosition(deviceHolderNode.parentElement, deviceProp.position);
        if (deviceProp.positionvalue) deviceHolderNode.parentElement.style.position = deviceProp.positionvalue;
        if (deviceProp.zorder) deviceHolderNode.parentElement.style.zIndex = deviceProp.zorder;
        if (deviceProp.globalstyle) {
            deviceHolderNode.parentElement.classList.remove(deviceProp.globalstyle);
            deviceHolderNode.parentElement.classList.add(deviceProp.globalstyle);
            deviceHolderNode.parentElement.classList.add("clsSingleColorParent");
        }
        if (deviceProp.deviceglobalstyle) {
            deviceHolderNode.parentElement.classList.remove("clsSingleColorParent");
            deviceHolderNode.parentElement.classList.remove(deviceProp.deviceglobalstyle);
            deviceHolderNode.parentElement.classList.add(deviceProp.deviceglobalstyle);
            deviceHolderNode.parentElement.classList.add("clsSingleColorParent");
        }
        if (deviceProp.devicename) {
            var svgPath = this.appStaticURL + "genericassets/device/" + this.deviceStyle + "/" + deviceProp.devicename + ".svg";
            var imagePath = this.appStaticURL + "genericassets/device/" + this.deviceStyle + "/" + deviceProp.devicename + ".png";

            let arrAssets = [];
            arrAssets.push({ parent: deviceHolderNode, type: "svg", url: svgPath, device: true, imagePath: imagePath, assetname: deviceProp.devicename });
            this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
        }
    }
};
// GenericCoverpage.prototype.createEventDate = function (parent) {
//     this.createEventElements(parent, "date");
//     let eventDateField = this.sgParent.querySelector("[id='sgEventDateNode']");
// };
// GenericCoverpage.prototype.createEventYear = function (parent) {
//     this.createEventElements(parent, "year");
//     let eventYearField = this.sgParent.querySelector("[id='sgEventYearNode']");
// };
// GenericCoverpage.prototype.createEventMonth = function (parent) {
//     this.createEventElements(parent, "month");
//     let eventMonthField = this.sgParent.querySelector("[id='sgEventMonthNode']");
// };
// GenericCoverpage.prototype.createEventTime = function (parent) {
//     this.createEventElements(parent, "time");
//     let eventTimeField = this.sgParent.querySelector("[id='sgEventTimeNode']");
// };
// GenericCoverpage.prototype.createEventIcon = function (parent) {
//     this.createEventIconNode(parent);
//     let eventIconParent = this.sgParent.querySelector("[id='eventIconParent']");
// };
GenericCoverpage.prototype.createCommonBgImage = function (parent) {
    let props = this.getPropertyData();
    this.createCommonBgImageNode(parent, props);
    let presetImageParent = parent.querySelector("[id='commonBgImageParent']");
    let commonImageNode = parent.querySelector("[id='commonBgImage']");
    let commonVideoNode = parent.querySelector("[id='commonBgImage']");
    if (props.commonbg) {
        this.applyCommonBgProps(presetImageParent, commonImageNode, commonVideoNode, props, 0, this.assetParent);
    }
};
// GenericCoverpage.prototype.applyCommonBgProps = function (presetImageParent, commonImageNode, commonVideoNode, props) {
//     let imageProps = props?.commonbg;
//     if (imageProps && presetImageParent) {
//         let specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL, this);
//         if (imageProps.positionvalue && presetImageParent) presetImageParent.style.position = imageProps.positionvalue;
//         if (imageProps.contrast && imageProps.contrast == "fullbg") {
//             if (commonImageNode) {
//                 commonImageNode.setAttribute("contrast", "fullbg");
//                 this.eventManager.dispatch("applyImageContrast", commonImageNode, this.assetParent);
//             }
//         } else if (imageProps.contrast && imageProps.contrast == "halfbg") {
//             if (commonImageNode) {
//                 commonImageNode.setAttribute("contrast", "halfbg");
//                 this.eventManager.dispatch("applyImageContrast", commonImageNode, this.assetParent, true);
//             }
//         } else if (this.slideContent) {
//             this.slideContent.classList.remove("fixedlightText");
//             this.slideContent.classList.remove("fixeddarkText");
//         }
//         if (imageProps.borderoption) presetImageParent.setAttribute("borderoption", imageProps.borderoption == "enable" ? "true" : "false");

//         let videoContrast = this.sgData[0]?.commonbgcontrast ? this.sgData[0].commonbgcontrast : null;
//         let contrast = videoContrast ? videoContrast : imageProps.fixedcontrast;
//         if (contrast) {
//             this.assetParent.classList.remove("darkText");
//             this.assetParent.classList.remove("lightText");
//             this.assetParent.classList.remove("fixedlightText");
//             this.assetParent.classList.remove("fixeddarkText");
//             this.assetParent.classList.add(contrast);
//         }

//         specialgraphicsPropertyUtils.applyImageBaseProps(imageProps, this.assetParent, presetImageParent, "--commonBg");
//         presetImageParent.style.setProperty("--commonBgWidth", presetImageParent.style.width);
//         presetImageParent.style.setProperty("--commonBgHeight", presetImageParent.style.height);

//         if (commonImageNode) {
//             commonImageNode.setAttribute("data-width", parseFloat(window.getComputedStyle(presetImageParent).width));
//             commonImageNode.setAttribute("data-height", parseFloat(window.getComputedStyle(presetImageParent).height));
//             commonImageNode.setAttribute("data-x", parseFloat(window.getComputedStyle(presetImageParent).left));
//             commonImageNode.setAttribute("data-y", parseFloat(window.getComputedStyle(presetImageParent).top));
//         }
//         if (commonVideoNode) {
//             commonVideoNode.setAttribute("data-width", parseFloat(window.getComputedStyle(presetImageParent).width));
//             commonVideoNode.setAttribute("data-height", parseFloat(window.getComputedStyle(presetImageParent).height));
//             commonVideoNode.setAttribute("data-x", parseFloat(window.getComputedStyle(presetImageParent).left));
//             commonVideoNode.setAttribute("data-y", parseFloat(window.getComputedStyle(presetImageParent).top));
//         }
//         let menuJson = this.objDataToSG && this.objDataToSG.menufromjson ? this.objDataToSG.menufromjson : null;
//         if (menuJson && menuJson.floateroptions && menuJson.floateroptions.includes("commonbgimagebleed") && presetImageParent) {
//             presetImageParent.setAttribute("imagebleedoption", "true");
//             if (!this.sgData[0]["commonbgimagebleed"] && menuJson.floateroptionsenable && menuJson.floateroptionsenable.includes("commonbgimagebleed")) {
//                 var slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
//                 if (slideDomContentGroup && slideDomContentGroup.getElementsByTagName("node-0").length > 0) {
//                     let nodeData = slideDomContentGroup.getElementsByTagName("node-0")[0];
//                     let nodeDataList = nodeData.getElementsByTagName("commonbg")[0];
//                     if (nodeDataList) nodeDataList.setAttribute("imagebleed", "true");
//                 }
//             }
//         }
//         // let mainP = this.sgParent.querySelector("[id='contentMainParent']");
//         // if (mainP && props.imageposition) mainP.setAttribute("data-imageposition", props.imageposition);
//     }
// };
GenericCoverpage.prototype.createSocialIcons = function (parent, flexValue = "") {
    let props = this.getPropertyData();
    this.createCtaSocial(parent);
    let ctaSocialParent = this.sgParent.querySelector("[id='ctaSocialParent']");

    if (flexValue && flexValue != "") ctaSocialParent.style.flex = flexValue;

    if (props.socialicons) {
        let socialProp = props.socialicons;
        let specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL, this);
        specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
        if (socialProp.position) specialgraphicsPropertyUtils.updatePosition(ctaSocialParent, socialProp.position);
        if (socialProp.positionvalue) ctaSocialParent.style.position = socialProp.positionvalue;
        if (socialProp.maxheight) ctaSocialParent.style.maxHeight = socialProp.maxheight + (socialProp.maxheight.includes("px") || socialProp.maxheight.includes("%") ? "" : "px");

        let arrNodes = ctaSocialParent.querySelectorAll("[id*='ctaSocialNodeParent']");
        for (let a = 0; a < arrNodes.length; a++) {
            let iconParent = arrNodes[a].querySelector("[id*='sgIconParent']");
            if (socialProp.hideicon && (socialProp.hideicon == "true" || socialProp.hideicon == true)) {
                iconParent.style.setProperty("display", "none", "important");
                iconParent.style.setProperty("opacity", "0", "important");
                this.assetParent.style.setProperty("--ctaIconWidth", "0px");
                this.assetParent.style.setProperty("--ctaIconHeight", "0px");
                this.assetParent.style.setProperty("--socialGap", "0px");
            } else this.specialGraphicsUtils.setOpacityAttribute(iconParent);
            if (socialProp.globalstyle) {
                arrNodes[a].classList.remove("clsSingleColorParent");
                arrNodes[a].classList.add("clsSingleColorParent");
                arrNodes[a].classList.add(socialProp.globalstyle);

                let percentValue = window.getComputedStyle(arrNodes[a]).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
                percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
                let sourceNode = arrNodes[a].querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
                if (sourceNode) arrNodes[a].style.setProperty("--customNodeBorderWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
            }
            if (socialProp.contentBG) {
                let arrAssets = [];
                arrAssets.push({ parent: iconParent, type: "svg", url: socialProp.contentBG.value, id: socialProp.contentBG.id, color: socialProp.contentBG.color });
                this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
            }
            if (socialProp.contrast) {
                let headingNodes = arrNodes[a].querySelector("[id*='ctaSocialNodeHeadingText']");
                this.applyContrastToText(headingNodes, socialProp);
                let contentNodes = arrNodes[a].querySelector("[id*='ctaSocialNodeContentText']");
                this.applyContrastToText(contentNodes, socialProp);
            }
            if (socialProp.line) {
                let lineProperty = socialProp.line;
                let socialLine = arrNodes[a].querySelector("[id*='socialLine']");
                if (socialLine) this.specialGraphicsUtils.setOpacityAttribute(socialLine);
                if (lineProperty.type && lineProperty.type == "dashed") {
                    let bgDirection = (socialProp.aligntype && socialProp.aligntype.includes("vertical")) || !socialProp.aligntype ? "right" : "bottom";
                    socialLine.style.backgroundImage = "linear-gradient(to " + bgDirection + ", rgba(var(--" + lineProperty.color + "-color-rgb),1) 40%, rgba(255, 255, 255, 0) 20%)";
                    socialLine.style.backgroundSize = bgDirection == "bottom" ? "2px 20px" : "10px 20px";
                    this.assetParent.style.setProperty("--ctaSocialLineColor", "unset");
                }
                if (lineProperty.filltype && lineProperty.filltype == "content") arrNodes[a].classList.add("socialgrow");
                if (lineProperty.margin && socialLine) specialgraphicsPropertyUtils.updateMargin(lineProperty.margin, socialLine);
            }
            if (!socialProp.class) socialProp.class = "ctasocial_type1";
            if (socialProp.class) {
                arrNodes[a].classList.remove(socialProp.class);
                arrNodes[a].classList.add(socialProp.class);
            }

            let primaryNode = arrNodes[a].querySelector("[id*='ctaSocialNodeHeadingText']");
            let secondaryNode = arrNodes[a].querySelector("[id*='ctaSocialNodeContentText']");
            if (primaryNode && secondaryNode) {
                if (socialProp.primaryclass) this.specialGraphicsUtils.applyClassNamesFromString(primaryNode, socialProp.primaryclass);
                if (socialProp.secondaryclass) this.specialGraphicsUtils.applyClassNamesFromString(secondaryNode, socialProp.secondaryclass);
                this.specialGraphicsUtils.setOpacityAttribute(primaryNode);
                this.specialGraphicsUtils.setOpacityAttribute(secondaryNode);
            }
        }

        this.applyTextFormats(socialProp, ctaSocialParent.querySelectorAll("[id*='ctaSocialNodeHeadingText']"), ctaSocialParent.querySelectorAll("[id*='ctaSocialNodeContentText']"), true);

        if (socialProp.textgap) this.assetParent.style.setProperty("--socialGap", socialProp.textgap + (socialProp.textgap.includes("px") ? "" : "px"));
        if (socialProp.inbetweentextgap) this.assetParent.style.setProperty("--ctaSocialTextGap", socialProp.inbetweentextgap);

        if (socialProp.iconcolor) this.assetParent.style.setProperty("--socialIconColor", "rgba(var(--" + socialProp.iconcolor + "-color-rgb),1)");

        if (!socialProp.primarycolor) socialProp.primarycolor = "secondary";
        if (!socialProp.secondarycolor) socialProp.secondarycolor = "secondary";
        let socialHeadingColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "heading", socialProp.primarycolor);
        let socialSecondaryColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "secondary", socialProp.secondarycolor);
        // if (!socialHeadingColor && socialProp.primarycolor) socialHeadingColor = "rgba(var(--" + socialProp.primarycolor + "-color-rgb),1)";
        // if (!socialSecondaryColor && socialProp.secondarycolor) socialSecondaryColor = "rgba(var(--" + socialProp.secondarycolor + "-color-rgb),1)";

        for (let a = 0; a < arrNodes.length; a++) {
            let headingNodes = arrNodes[a].querySelector("[id*='ctaSocialNodeHeadingText']");
            let contentNodes = arrNodes[a].querySelector("[id*='ctaSocialNodeContentText']");
            if (socialHeadingColor && headingNodes) headingNodes.setAttribute("data-color", socialHeadingColor);
            if (socialSecondaryColor && contentNodes) contentNodes.setAttribute("data-color", socialSecondaryColor);
        }

        if (socialHeadingColor) this.assetParent.style.setProperty("--socialPrimaryColor", socialHeadingColor);
        if (socialSecondaryColor) this.assetParent.style.setProperty("--socialSecondaryColor", socialSecondaryColor);

        if (socialProp.padding) specialgraphicsPropertyUtils.updatePadding(socialProp.padding, ctaSocialParent);
        if (socialProp.margin) specialgraphicsPropertyUtils.updateMargin(socialProp.margin, ctaSocialParent);
        if (socialProp.nodegap) this.assetParent.style.setProperty("--ctaSocialNodeGap", socialProp.nodegap);

        if (socialProp.bgstyle) ctaSocialParent.classList.add(socialProp.bgstyle);

        if (socialProp.iconopacity) this.assetParent.style.setProperty("--contactIconOpacity", socialProp.iconopacity);

        let ctaSocialInnerParent = this.sgParent.querySelector("[id='ctaSocialInnerParent']");
        if (!socialProp.aligntype) socialProp.aligntype = "vertical";
        if (socialProp.aligntype && ctaSocialInnerParent) ctaSocialInnerParent.classList.add("ctasocial" + socialProp.aligntype);
        if (socialProp.gridcount) {
            if (parseInt(socialProp.gridcount) > 4) socialProp.gridcount = 4;
            ctaSocialInnerParent.style.setProperty("--gridCount", socialProp.gridcount);
            ctaSocialInnerParent.setAttribute("data-gridcount", socialProp.gridcount);
        }
        if (socialProp.halign) {
            let alignValue = socialProp.halign;
            let hAlign = alignValue == "right" || alignValue == "end" ? "flex-end" : alignValue == "center" || alignValue == "middle" ? "center" : "flex-start";
            this.assetParent.style.setProperty("--ctaSocialHAlign", hAlign);
        }
        if (socialProp.valign) {
            let alignValue = socialProp.valign;
            let vAlign = alignValue == "bottom" || alignValue == "end" ? "flex-end" : alignValue == "center" || alignValue == "middle" ? "center" : "flex-start";
            this.assetParent.style.setProperty("--ctaSocialVAlign", vAlign);
        }

        if (socialProp.line) {
            let lineProperty = socialProp.line;
            if (lineProperty.width) this.assetParent.style.setProperty("--ctaSocialLineWidth", lineProperty.width + (lineProperty.width.includes("%") || lineProperty.width.includes("px") ? "" : "px"));
            if (lineProperty.height) this.assetParent.style.setProperty("--ctaSocialLineHeight", lineProperty.height + (lineProperty.height.includes("%") || lineProperty.height.includes("px") ? "" : "px"));
            if (lineProperty.color) this.assetParent.style.setProperty("--ctaSocialLineColor", "rgba(var(--" + lineProperty.color + "-color-rgb),1)");
            if (lineProperty.opacity) this.assetParent.style.setProperty("--ctaSocialLineOpacity", lineProperty.opacity);
            if (lineProperty.radius) this.assetParent.style.setProperty("--ctaSocialLineRadius", lineProperty.radius + (lineProperty.radius.includes("%") || lineProperty.radius.includes("px") ? "" : "px"));
        }
        if (socialProp.iconnodesize) {
            let arrValues = this.specialGraphicsUtils.isJson(socialProp.iconnodesize) ? socialProp.iconnodesize : JSON.stringify(socialProp.iconnodesize);
            if (arrValues) {
                ctaSocialParent.setAttribute("iconnodesizearray", arrValues);
                this.setSocialIconsSize();
            }
        }
        this.setSocialIconsNodeGap();
    }

    if (!ctaSocialParent.hasAttribute("finalHeight")) {
        let h = ctaSocialParent.style.height;
        let height = 0;
        let isAuto = h.includes("auto");
        if (h.includes("auto") || h == "") {
            ctaSocialParent.style.height = ctaSocialParent.style.maxHeight;
            h = ctaSocialParent.style.height;
        }
        ctaSocialParent.style.minHeight = ctaSocialParent.style.height;
        if (h.includes("px")) height = parseFloat(ctaSocialParent.style.height);
        if (h.includes("%")) {
            let parentH = ctaSocialParent.parentElement.style.height;
            if (parentH == "auto") parentH = ctaSocialParent.parentElement.style.maxHeight;
            if (parentH) {
                ctaSocialParent.parentElement.style.minHeight = parentH;
                parentH = window.getComputedStyle(ctaSocialParent.parentElement).height;
                height = parseFloat(parentH) * (parseFloat(h) / 100);
                ctaSocialParent.parentElement.style.removeProperty("min-height");
            }
        }

        ctaSocialParent.style.removeProperty("min-height");
        if (isAuto) ctaSocialParent.style.height = "auto";

        let elementPadding = this.specialGraphicsUtils.getPadding(ctaSocialParent);
        ctaSocialParent.setAttribute("finalHeight", parseInt(height) - (parseInt(elementPadding.paddingTop) + parseInt(elementPadding.paddingBottom)));
    }
    if (!ctaSocialParent.hasAttribute("finalWidth")) {
        let h = ctaSocialParent.style.width;
        let width = 0;
        let isAuto = h.includes("auto");
        if (h.includes("auto") || h == "") {
            ctaSocialParent.style.width = ctaSocialParent.style.maxWidth;
            h = ctaSocialParent.style.width;
        }
        ctaSocialParent.style.minWidth = ctaSocialParent.style.width;
        if (h.includes("px")) width = parseFloat(ctaSocialParent.style.width);
        if (h.includes("%")) {
            let parentW = ctaSocialParent.parentElement.style.width;
            if (parentW == "auto") parentW = ctaSocialParent.parentElement.style.maxWidth;
            if (parentW) {
                ctaSocialParent.parentElement.style.minWidth = parentW;
                parentW = window.getComputedStyle(ctaSocialParent.parentElement).width;
                width = parseFloat(parentW) * (parseFloat(h) / 100);
                ctaSocialParent.parentElement.style.removeProperty("min-width");
            }
        }

        ctaSocialParent.style.removeProperty("min-width");
        if (isAuto) ctaSocialParent.style.width = "auto";

        let elementPadding = this.specialGraphicsUtils.getPadding(ctaSocialParent);
        ctaSocialParent.setAttribute("finalWidth", parseInt(width) - (parseInt(elementPadding.paddingLeft) + parseInt(elementPadding.paddingRight)));
    }

    let arrNodeParent = ctaSocialParent.querySelectorAll("[id*='ctaSocialNodeParent']");
    for (let a = 0; a < arrNodeParent.length; a++) {
        let primaryNode = arrNodeParent[a].querySelector("[id*='ctaSocialNodeHeadingText']");
        let secondaryNode = arrNodeParent[a].querySelector("[id*='ctaSocialNodeContentText']");
        if (primaryNode && primaryNode.socialheightfit) this.socialHeightFit(primaryNode);
        if (secondaryNode && secondaryNode.socialheightfit) this.socialHeightFit(secondaryNode);
    }
};
GenericCoverpage.prototype.setSocialIconsMaxWidth = function () {
    if (this.metaData && this.metaData[this.designChange == true ? "properties2" : "properties"] && this.metaData[this.designChange == true ? "properties2" : "properties"].socialicons) {
        let nodeItem = this.sgParent.querySelectorAll("[id*='ctaSocialNodeParent']");
        let ctaSocialInnerParent = this.sgParent.querySelector("[id*='ctaSocialInnerParent']");
        if (!ctaSocialInnerParent) return null;
        let props = this.metaData[this.designChange == true ? "properties2" : "properties"].socialicons;
        if (props.aligntype == "grid") {
            let visibleNodes = 0;
            for (let a = 0; a < nodeItem.length; a++) {
                if (nodeItem[a] && nodeItem[a].style.display != "none") visibleNodes = visibleNodes + 1;
            }
            if (visibleNodes == 1) {
                ctaSocialInnerParent.style.setProperty("--gridCount", 1);
                ctaSocialInnerParent.setAttribute("data-gridcount", 1);
            } else if (props.gridcount) {
                let gCount = parseInt(props.gridcount) > 4 ? 4 : props.gridcount;
                if (nodeItem.length < gCount) gCount = nodeItem.length;
                ctaSocialInnerParent.style.setProperty("--gridCount", gCount);
                ctaSocialInnerParent.setAttribute("data-gridcount", gCount);
            } else {
                ctaSocialInnerParent.style.setProperty("--gridCount", 2);
                ctaSocialInnerParent.setAttribute("data-gridcount", 2);
            }
        }
        if (props.aligntype == "verticalgrid") {
            let visibleNodes = 0;
            let leftVal = -1;
            for (let a = 0; a < nodeItem.length; a++) {
                if (leftVal < nodeItem[a].offsetLeft) {
                    visibleNodes = visibleNodes + 1;
                    leftVal = nodeItem[a].offsetLeft;
                }
            }
            if (visibleNodes == 1) {
                ctaSocialInnerParent.style.setProperty("--gridCount", 1);
                ctaSocialInnerParent.setAttribute("data-gridcount", 1);
            } else if (props.gridcount) {
                let gCount = parseInt(props.gridcount) > 4 ? 4 : props.gridcount;
                if (nodeItem.length < gCount) gCount = nodeItem.length;
                ctaSocialInnerParent.style.setProperty("--gridCount", gCount);
                ctaSocialInnerParent.setAttribute("data-gridcount", gCount);
            } else {
                ctaSocialInnerParent.style.setProperty("--gridCount", 2);
                ctaSocialInnerParent.setAttribute("data-gridcount", 2);
            }
        }
        if (props.class && props.class.includes("social_type") && props.aligntype && props.aligntype == "horizontal") {
            let maxWidthCount = nodeItem.length;
            for (let a = 0; a < nodeItem.length; a++) {
                if (nodeItem[a] && nodeItem[a].style.display == "none") maxWidthCount = maxWidthCount - 1;
            }
            this.assetParent.style.setProperty("--ctaSocialMaxWidth", 100 / maxWidthCount + "%");
        }
    }
};
GenericCoverpage.prototype.updateMaxWidthForCtaSocial = function () {
    if (this.metaData && this.metaData[this.designChange == true ? "properties2" : "properties"] && this.metaData[this.designChange == true ? "properties2" : "properties"].ctasocial) {
        let props = this.metaData[this.designChange == true ? "properties2" : "properties"].ctasocial;
        if (props.aligntype == "grid") {
            let visibleNodes = 0;
            for (let a = 1; a <= 5; a++) {
                let node = this.sgParent.querySelector("[id='sgCustomSocialLink" + a + "']");
                if (node && node.style.display != "none") visibleNodes = visibleNodes + 1;
            }
            if (visibleNodes == 1) this.assetParent.style.setProperty("--gridCount", 1);
            else if (props.gridcount) this.assetParent.style.setProperty("--gridCount", props.gridcount);
            else this.assetParent.style.setProperty("--gridCount", 2);
        }
        if (props.class && props.class.includes("social_type") && props.aligntype && props.aligntype == "horizontal") {
            let maxWidthCount = 5;
            for (let a = 1; a <= maxWidthCount; a++) {
                let node = this.sgParent.querySelector("[id='sgCustomSocialLink" + a + "']");
                if (node && node.style.display == "none") maxWidthCount = maxWidthCount - 1;
            }
            this.assetParent.style.setProperty("--ctaSocialMaxWidth", 100 / maxWidthCount + "%");
        }
    }
    if (this.metaData && this.metaData && this.metaData[this.designChange == true ? "properties2" : "properties"] && this.metaData[this.designChange == true ? "properties2" : "properties"].reference) {
        let props = this.metaData[this.designChange == true ? "properties2" : "properties"].reference;
        let minWidth = 0;
        for (let a = 1; a < 5; a++) {
            let id = "sgreferenceLink" + a + "Parent";
            let node = this.sgParent.querySelector("[id='" + id + "']");
            if (node && node.style.display != "none") {
                let min = node.style.minWidth;
                node.style.minWidth = "unset";
                let w = parseFloat(window.getComputedStyle(node).width);
                if (!isNaN(w) && minWidth < w) minWidth = w;
                node.style.minWidth = min;
            }
        }
        if (minWidth != 0) this.assetParent.style.setProperty("--referenceMinWidth", minWidth + "px");
    }
    if (this.metaData && this.metaData && this.metaData[this.designChange == true ? "properties2" : "properties"] && this.metaData[this.designChange == true ? "properties2" : "properties"].contact) {
        let props = this.metaData[this.designChange == true ? "properties2" : "properties"].contact;
        if ((props.class && props.class.includes("contact_type")) || !props.class) {
            let minWidth = 0;
            let maxW = 0;
            let count = 0;
            let oldParentW = null;
            let contactParent = this.sgParent.querySelector("[id='contactParent']");
            if (contactParent && contactParent.parentElement && contactParent.parentElement.hasAttribute("fullwidth")) {
                oldParentW = contactParent.parentElement.style.width;
                contactParent.parentElement.style.width = contactParent.parentElement.hasAttribute("fullwidth");
            }
            let arrNodes = [];
            for (let a = 0; a < 4; a++) {
                let id = a == 0 ? "sgmailingAddressParent" : a == 1 ? "sgemailAddressParent" : a == 2 ? "sgphoneNumberParent" : "sgwebsiteParent";
                let node = this.sgParent.querySelector("[id='" + id + "']");
                if (node && node.style.display != "none") {
                    arrNodes.push(node);
                    if (maxW == 0) {
                        let oldWidth = node.style.width;
                        node.style.width = window.getComputedStyle(node).maxWidth;
                        maxW = parseFloat(window.getComputedStyle(node).width);
                        node.style.width = oldWidth;
                    }
                    let min = node.style.minWidth;
                    node.style.minWidth = "unset";
                    let w = parseFloat(window.getComputedStyle(node).width);
                    if (!isNaN(w) && minWidth < w) minWidth = w;
                    node.style.minWidth = min;
                    count = count + 1;
                }
            }
            if (contactParent) this.assetParent.style.setProperty("--contactMaxWidth", count == 1 ? "100%" : count == 2 ? "50%" : count == 3 ? "33%" : "25%");
            if (minWidth != 0) {
                if (maxW < minWidth) minWidth = maxW;
                this.assetParent.style.setProperty("--contactMinWidth", minWidth + "px");
                for (let b = 0; b < arrNodes.length; b++) {
                    let primaryNode = arrNodes[b].querySelector("[id*='promptText']");
                    let secondaryNode = arrNodes[b].querySelector("[id*='sgmailingAddress']");
                    if (!secondaryNode) secondaryNode = arrNodes[b].querySelector("[id*='sgemailAddress']");
                    if (!secondaryNode) secondaryNode = arrNodes[b].querySelector("[id*='sgphoneNumber']");
                    if (!secondaryNode) secondaryNode = arrNodes[b].querySelector("[id*='sgwebsite']");
                    if (primaryNode && primaryNode.contactnodesheightfit) primaryNode.contactnodesheightfit(primaryNode);
                    if (secondaryNode && secondaryNode.contactnodesheightfit) secondaryNode.contactnodesheightfit(secondaryNode);
                }
            }
            if (oldParentW && contactParent && contactParent.parentElement) contactParent.parentElement.style.width = oldParentW;
        }
        if (props.aligntype && props.aligntype == "horizontal") {
            let maxWidthCount = 4;
            for (let a = 1; a <= 4; a++) {
                let name = a == 1 ? "sgmailingAddressParent" : a == 2 ? "sgemailAddressParent" : a == 3 ? "sgphoneNumberParent" : "sgwebsiteParent";
                let node = this.sgParent.querySelector("[id='" + name + "']");
                if (node && node.style.display == "none") maxWidthCount = maxWidthCount - 1;
            }
            this.assetParent.style.setProperty("--contactMaxWidth", 100 / maxWidthCount + "%");
        }
    }
};

GenericCoverpage.prototype.updateTextSizeForCtaSocial = function () {
    if (this.metaData && this.metaData[this.designChange == true ? "properties2" : "properties"] && this.metaData[this.designChange == true ? "properties2" : "properties"].ctasocial) {
        let props = this.metaData[this.designChange == true ? "properties2" : "properties"].ctasocial;
        if (!props.class) props.class = "ctasocial_type1";
        if (props.class && ((props.class.includes("ctasocial_type") && (props?.aligntype == "vertical" || props?.aligntype == "horizontal" || !props.aligntype)) || (props.class.includes("ctasocial_type1") && props.aligntype && props.aligntype == "grid"))) {
            let minWidth = 0;
            for (let a = 1; a <= 5; a++) {
                let node = this.sgParent.querySelector("[id='sgCustomSocialLink" + a + "']");
                if (node && node.style.display != "none") {
                    let innerNode = node.querySelector("[id='socialIconTextParent']");
                    if (innerNode?.style.display != "none" && (props.aligntype == "grid" || (props.class.includes("ctasocial_type1") && (!props.aligntype || props.aligntype == "vertical" || props.aligntype == "horizontal")))) node = innerNode;
                    let min = node.style.minWidth;
                    node.style.minWidth = "unset";
                    let w = parseFloat(window.getComputedStyle(node).width);
                    if (!isNaN(w) && minWidth < w) minWidth = w;
                    node.style.minWidth = min;
                }
            }
            if (minWidth != 0) this.assetParent.style.setProperty("--ctaSocialMinWidth", minWidth + "px");
        }
    }
};
GenericCoverpage.prototype.setSocialIconsMinWidth = function () {
    if (this.metaData && this.metaData[this.designChange == true ? "properties2" : "properties"] && this.metaData[this.designChange == true ? "properties2" : "properties"].socialicons) {
        let props = this.metaData[this.designChange == true ? "properties2" : "properties"].socialicons;
        if (!props.class) props.class = "ctasocial_type1";

        this.assetParent.style.setProperty("--ctaSocialMinWidth", "unset");

        let minWidth = 0;
        let end = this.sgParent.querySelectorAll("[id*='ctaSocialNodeParent']").length;
        for (let a = 0; a <= end; a++) {
            let node = this.sgParent.querySelector("[id='ctaSocialNodeParent" + a + "']");
            if (node && node.style.display != "none") {
                let innerNode = node.querySelector("[id*='ctaSocialNodeTextParent']");
                if (innerNode && innerNode.style.display != "none") node = innerNode;
                let min = node.style.minWidth;
                node.style.minWidth = "unset";
                let w = parseFloat(window.getComputedStyle(node).width);
                if (!isNaN(w) && minWidth < w) minWidth = w;
                node.style.minWidth = min;
            }
        }
        if (minWidth != 0) this.assetParent.style.setProperty("--ctaSocialMinWidth", minWidth + "px");
    }
};
GenericCoverpage.prototype.changeVariation = function (slideDomContentGroup, updateOnlyVariation = false, checkUpdateDesign = false, updateDeviceClip = false) {
    let subTitleNode = this.sgParent.querySelector("[id='sgSubTitleNode']");
    let coverImageParent = this.sgParent.querySelector("[id='coverImageParent']");
    let oldImageDisplay = coverImageParent ? window.getComputedStyle(coverImageParent)["display"] : "";
    let oldDisplay = subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "";

    let nodeType = this.sgSlideType == "quote" ? "authorname" : "creatorname";
    let creatorName = this.sgParent.querySelector("[id='" + (this.sgSlideType == "quote" ? "sgAuthorNameNode" : "sgPresentorNameNode") + "']");
    let creatorDesigination = this.sgParent.querySelector("[id='" + (this.sgSlideType == "quote" ? "sgAuthorDesignationNode" : "sgPresentorDesiginationNode") + "']");
    let oldDesiginationDisplay = creatorDesigination ? window.getComputedStyle(creatorDesigination)["display"] : "";

    // let oldDisplayForDesignChange = checkUpdateDesign == true ? this.getDisplayForUpdatedDesign() : "none";
    this.specialGraphicsUtils.changeVariation(this.sgParent, slideDomContentGroup);

    this.checkSocialIconsDisplay();
    this.checkSocialIconsOpacity();

    // let animationDIV = this.sgParent?.parentElement?.parentElement;
    // if (animationDIV?.hasAttribute("dohideelements")) checkUpdateDesign = false;

    if (checkUpdateDesign == true && this.isPresent != true) {
        //Check for design change on property while enable/disable nodes
        this.checkForUpdatedDesign(slideDomContentGroup);
    }

    //Big title check - only title/ title with logo only will support big title
    subTitleNode = this.sgParent.querySelector("[id='sgSubTitleNode']");
    if (this.sgParent.querySelector("[id='sgTitleNode']") && subTitleNode) {
        let isOnlyTitle = this.specialGraphicsUtils.isOnlyTitle(this.sgParent);
        let oldFontMapping = "baseset";
        let supportBigTitle = "true";
        if (this.metaData && this.metaData && this.metaData.fontmapping) oldFontMapping = this.metaData.fontmapping;
        if (this.metaData && this.metaData && this.metaData[this.designChange == true ? "properties2" : "properties"] && this.metaData[this.designChange == true ? "properties2" : "properties"].supportbigtitle)
            supportBigTitle = this.metaData[this.designChange == true ? "properties2" : "properties"].supportbigtitle == true || this.metaData[this.designChange == true ? "properties2" : "properties"].supportbigtitle == "true" ? "true" : "false";
        if (supportBigTitle == "true") {
            let fontList = this.getFontListForAgenda(isOnlyTitle ? "bigtitle" : oldFontMapping, this.sgSlideType);
            if (fontList) {
                this.fontData = fontList;
                let newDisplay = subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "";
                if (newDisplay == "none") oldDisplay = "block";
                else if (newDisplay != "none") oldDisplay = "none";
            }
        }
    }

    // this.setSpeakerPadding();
    this.arrNodeGapForSpeaker();
    this.speakerImageSizeUpdate();
    this.speakerTextMinWidthCalculations();

    //Updating image positions for all images
    this.specialGraphicsUtils.updateImagePositions(this.sgParent);
    this.ctaIconSizeUpdate();

    if (updateOnlyVariation == false) {
        let titleNode = this.sgParent.querySelector("[id='sgTitleNode']");
        let newDisplay = subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "";
        if (titleNode && subTitleNode && newDisplay != oldDisplay && this.fontData.title.length <= 2) {
            let isSubtitleEnabled = window.getComputedStyle(subTitleNode)["display"] == "none" ? false : true;
            titleNode.classList.remove(this.fontData.title);
            titleNode.classList.remove(this.fontData.titleNoSubtitle);
            this.specialGraphicsUtils.removeAllFontClass(titleNode);
            let fontClass = isSubtitleEnabled == false && this.fontData.titleNoSubtitle ? this.fontData.titleNoSubtitle : this.fontData.title;
            titleNode.classList.add(fontClass);
            titleNode.setAttribute("data-font", fontClass);
            titleNode.style.removeProperty("min-height");
            titleNode.style.removeProperty("max-height");
            titleNode.parentElement.style.removeProperty("min-height");
            titleNode.parentElement.style.removeProperty("max-height");
            titleNode.style.removeProperty("font-size");

            titleNode.setAttribute("defaultsize", parseFloat(window.getComputedStyle(titleNode)["font-size"]));
            // if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(titleNode);
            if (titleNode.hasAttribute("user-font-size")) {
                this.specialGraphicsUtils.removeAllFontClass(titleNode);
                titleNode.classList.add(titleNode.getAttribute("user-font-size"));
            }
            if (titleNode.hasAttribute("user-text-size")) titleNode.style.fontSize = titleNode.getAttribute("user-text-size");
            this.specialGraphicsUtils.doCheckMaxHeight(titleNode, this.sgParent);
            this.specialGraphicsUtils.doFontFitForCss(titleNode, this.sgParent);
        }

        let newDesiginationDisplay = creatorDesigination ? window.getComputedStyle(creatorDesigination)["display"] : "";
        if (creatorDesigination && creatorName && oldDesiginationDisplay != newDesiginationDisplay && this.fontData[nodeType] && this.fontData[nodeType].length <= 2) {
            let isSubtitleEnabled = window.getComputedStyle(creatorDesigination)["display"] == "none" ? false : true;
            creatorName.classList.remove(this.fontData[nodeType]);
            creatorName.classList.remove(this.fontData[nodeType + "NoDesignation"]);

            let fontClass = isSubtitleEnabled == false && this.fontData[nodeType + "NoDesignation"] ? this.fontData[nodeType + "NoDesignation"] : this.fontData[nodeType];
            creatorName.classList.add(fontClass);
            creatorName.setAttribute("data-font", fontClass);
            creatorName.style.removeProperty("min-height");
            creatorName.style.removeProperty("max-height");
            creatorName.style.removeProperty("font-size");

            creatorName.setAttribute("defaultsize", parseFloat(window.getComputedStyle(creatorName)["font-size"]));
            if (creatorName.hasAttribute("user-font-size")) {
                this.specialGraphicsUtils.removeAllFontClass(creatorName);
                creatorName.classList.add(creatorName.getAttribute("user-font-size"));
            }
            if (creatorName.hasAttribute("user-text-size")) creatorName.style.fontSize = creatorName.getAttribute("user-text-size");

            this.specialGraphicsUtils.doCheckMaxHeight(creatorName, this.sgParent);
            this.specialGraphicsUtils.doFontFitForCss(creatorName, this.sgParent);
        }
        this.updateHeightForText();
        this.onTextChangeForAllNodes(this.sgParent);
    }
    // Check and apply Flip & bleed options
    this.applyImageBleedCommon(null, "commonbg");
    this.applyImageBleedCommon();
    this.textElementPositioning(this.assetParent);

    this.checkMoodLevelSocialIconProp();
    this.arrNodeGapForCTA();
    this.setSocialIconsNodeGap();
    this.arrNodeGapForContact();
    this.updateMaxWidthForCtaSocial();
    this.updateTextSizeForCtaSocial();
    this.setSocialIconsMaxWidth();
    this.setSocialIconsMinWidth();
    this.checkContrastOnImageDisplayChange(oldImageDisplay);
    this.setContactPadding();
    let oldSlide = this.sgParent.parentElement?.parentElement?.parentElement?.parentElement;
    if (this.updateResizer) this.updateResizer(-1, oldSlide);
    if (updateDeviceClip) this.deviceClippathCheck();
    this.fitSocialIcons();
    if (this.sgSlideType && this.sgSlideType == "quote") this.hideTextNodes();
    this.checkShapeDependency();
};

GenericCoverpage.prototype.fitSocialIcons = function () {
    if (!this.sgParent.querySelector("[id='ctaSocialParent']")) return;
    let ctaSocialParent = this.sgParent.querySelector("[id='ctaSocialParent']");
    let arrNodes = ctaSocialParent.querySelectorAll("[id*='ctaSocialNodeParent']");
    let parentW = ctaSocialParent.offsetWidth;
    let parentH = ctaSocialParent.offsetHeight;
    for (let a = 0; a < arrNodes.length; a++) {
        let node = arrNodes[a];
        if (node.offsetLeft + node.offsetWidth > parentW || node.offsetTop + node.offsetHeight > parentH) {
            node.parentElement.removeChild(node);
            a--;
        }
    }
};
GenericCoverpage.prototype.checkSocialIconsDisplay = function () {
    if (!this.sgParent.querySelector("[id='ctaSocialParent']")) return;
    let ctaSocialParent = this.sgParent.querySelector("[id='ctaSocialParent']");
    let sgIconParent = ctaSocialParent.querySelector("[id*='sgIconParent']");
    if (sgIconParent && (sgIconParent.style.display == "none" || window.getComputedStyle(sgIconParent).display == "none")) {
        this.assetParent.style.setProperty("--ctaIconWidth", "0px");
        this.assetParent.style.setProperty("--ctaIconHeight", "0px");
        this.assetParent.style.setProperty("--socialGap", "0px");
    } else {
        this.setSocialIconsSize();
        let props = this.getPropertyData();
        if (props && props.socialicons && props.socialicons.textgap) this.assetParent.style.setProperty("--socialGap", props.socialicons.textgap + (props.socialicons.textgap.includes("px") ? "" : "px"));
    }
};
GenericCoverpage.prototype.checkSocialIconsOpacity = function () {
    if (!this.sgParent.querySelector("[id='ctaSocialParent']")) return;
    let ctaSocialParent = this.sgParent.querySelector("[id='ctaSocialParent']");
    let primaryNode = ctaSocialParent.querySelectorAll("[id*='ctaSocialNodeHeadingText']");
    let secondaryNode = ctaSocialParent.querySelectorAll("[id*='ctaSocialNodeContentText']");
    for (let a = 0; a < primaryNode.length; a++) {
        if (primaryNode[a]) this.specialGraphicsUtils.setOpacityAttribute(primaryNode[a]);
        if (secondaryNode[a]) this.specialGraphicsUtils.setOpacityAttribute(secondaryNode[a]);
    }
};
GenericCoverpage.prototype.checkMoodLevelSocialIconProp = function () {
    if (!this.sgParent.querySelector("[id='ctaSocialParent']")) return;
    let ctaSocialParent = this.sgParent.querySelector("[id='ctaSocialParent']");
    let ctaSocialInnerParent = this.sgParent.querySelector("[id='ctaSocialInnerParent']");
    let socialIconsPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.socialiconsproperty ? this.objDataToSG.sgMoodsData.socialiconsproperty : null;
    if (socialIconsPropFromMood && socialIconsPropFromMood.hideprompt && (socialIconsPropFromMood.hideprompt == "true" || socialIconsPropFromMood.hideprompt == true)) {
        ctaSocialParent.classList.add("sgHidePrompt");
    }
    if (socialIconsPropFromMood && socialIconsPropFromMood.hideicon && (socialIconsPropFromMood.hideicon == "true" || socialIconsPropFromMood.hideicon == true)) {
        ctaSocialParent.classList.add("sgHideIcons");
        ctaSocialInnerParent.style.setProperty("--ctaIconWidth", "0px");
        ctaSocialInnerParent.style.setProperty("--ctaIconHeight", "0px");
        this.assetParent.style.setProperty("--socialGap", "0px");
    }
};
// GenericCoverpage.prototype.getDisplayForUpdatedDesign = function () {
//     this.designChange = false;
//     if (this.metaData && this.metaData && this.metaData.designchange && this.metaData.supportedNodes2 && this.metaData.properties2) {
//         let designChange = this.metaData.designchange.split("-");
//         let designChangeElement = designChange[0];
//         let designChangeUsing = designChange[1];
//         if (designChangeElement && designChangeUsing) {
//             let parent = this.getParentByProperty(designChangeElement);
//             let displayValue = parent ? parent.style.display : "none";
//             return displayValue;
//         }
//     }
//     return "none";
// };
GenericCoverpage.prototype.checkForUpdatedDesign = function (slideDomContentGroup) {
    // this.designChange = false;
    this.checkDesignChangeElements();
    if (this.metaData && this.metaData && this.metaData.designchange && this.metaData.supportedNodes2 && this.metaData.properties2) {
        let designChange = this.metaData.designchange.split("-");
        let designChangeElement = designChange[0];
        let designChangeUsing = designChange[1];
        let isFromOp = this.sgParent.parentElement.parentElement.hasAttribute("fromop");
        if (isFromOp) this.oldContent = null;
        if (designChangeElement && designChangeUsing && !this.oldContent) {
            let parent = this.getParentByProperty(designChangeElement);
            let displayValue = parent ? parent.style.display : "notavailable";

            let finalHideData = this.sgParent.parentElement.parentElement.getAttribute("data-ogdata-finalhide")?.split(",") || [];

            let isDC = false;
            let isCurrentlyDisable = finalHideData.includes(designChangeElement);

            if (designChangeElement == "presenterimage") isCurrentlyDisable = finalHideData.includes("creatorimage");
            if (designChangeElement == "presentertext") isCurrentlyDisable = finalHideData.includes("creatorname") && finalHideData.includes("creatordesignation");
            if (designChangeElement == "customertext") isCurrentlyDisable = finalHideData.includes("customername") && finalHideData.includes("customerdesignation");
            if (designChangeElement == "pre") isCurrentlyDisable = finalHideData.includes("creatorname") && finalHideData.includes("creatordesignation") && finalHideData.includes("creatorimage");
            if (designChangeElement == "cus") isCurrentlyDisable = finalHideData.includes("customername") && finalHideData.includes("customerdesignation") && finalHideData.includes("customerimage");
            if (designChangeElement == "logo") isCurrentlyDisable = finalHideData.includes("logoimage");
            if (designChangeElement == "yr") isCurrentlyDisable = finalHideData.includes("covernumber");
            if (designChangeElement == "num" || designChangeElement == "sectionnum") isCurrentlyDisable = finalHideData.includes("numbertext");
            if (designChangeElement == "img") isCurrentlyDisable = finalHideData.includes("coverimage");
            if (designChangeElement == "tit") isCurrentlyDisable = finalHideData.includes("title") && finalHideData.includes("subtitle") && finalHideData.includes("titlelabel");
            if (designChangeElement == "reference") isCurrentlyDisable = finalHideData.includes("reference1") && finalHideData.includes("reference2") && finalHideData.includes("reference3") && finalHideData.includes("reference4");
            if (designChangeElement == "contact") isCurrentlyDisable = finalHideData.includes("venue") && finalHideData.includes("phone") && finalHideData.includes("creatoremail");
            if (designChangeElement == "authimg") isCurrentlyDisable = finalHideData.includes("authorimage");
            if (designChangeElement == "authtxt") isCurrentlyDisable = finalHideData.includes("authorname") && finalHideData.includes("authordesignation");
            if (designChangeElement == "footer") isCurrentlyDisable = finalHideData.includes("sgfooter");
            if (designChangeElement == "social" || designChangeElement == "ctasocial") isCurrentlyDisable = finalHideData.includes("customsociallink1") && finalHideData.includes("customsociallink2") && finalHideData.includes("customsociallink3") && finalHideData.includes("customsociallink4");

            // if (designChangeElement == "customerimage") isCurrentlyDisable = finalHideData.includes("customerimage");
            // if (designChangeElement == "presentertext") {
            //     isCurrentlyDisable = finalHideData.includes("creatorname") && finalHideData.includes("creatordesignation") && !variationType.split(",").includes("pre");
            // }
            // if (designChangeElement == "customertext") {
            //     isCurrentlyDisable = finalHideData.includes("customername") && finalHideData.includes("customerdesignation") && !variationType.split(",").includes("cus");
            // }

            if (designChangeUsing == "enable" && ((displayValue == "notavailable" && !isCurrentlyDisable) || (displayValue == "none" && isCurrentlyDisable))) isDC = true;
            // // if (designChangeUsing == "disable" && displayValue != "notavailable" && displayValue != "none") {
            if (designChangeUsing == "disable" && ((displayValue == "notavailable" && !isCurrentlyDisable) || (displayValue == "none" && isCurrentlyDisable))) isDC = true;

            // if (designChangeElement == "img" && floateroptionshide?.includes(designChangeElement)) isDC = false;

            // if (displayValue != oldDisplayForDesignChange) {
            if (isDC) {
                // console.log("SG - Design change here - " + designChange);
                if (!parent && this.sgParent.parentElement.parentElement.hasAttribute("data-variation-name")) {
                    let variationName = this.sgParent.parentElement.parentElement.getAttribute("data-variation-name");
                    let arrVarition = variationName.split(",");
                    if (designChangeElement == "pre" && variationName.includes("creatorname") && variationName.includes("creatordesignation") && variationName.includes("creatorimage")) displayValue = "none";
                    if (designChangeElement == "cus" && variationName.includes("customername") && variationName.includes("customerdesignation") && variationName.includes("customerimage")) displayValue = "none";
                    if (designChangeElement == "tit" && arrVarition.includes("title")) displayValue = "none";
                    if (designChangeElement == "logo" && variationName.includes("logoimage")) displayValue = "none";
                    if (designChangeElement == "customerlogoimage" && variationName.includes("customerlogoimage")) displayValue = "none";
                    if (designChangeElement == "presenterlogoimage" && variationName.includes("presenterlogoimage")) displayValue = "none";
                    if (designChangeElement == "venue" && variationName.includes("venue")) displayValue = "none";
                    if (designChangeElement == "yr" && variationName.includes("covernumber")) displayValue = "none";
                    if (designChangeElement == "sectionnum" && variationName.includes("numbertext")) displayValue = "none";
                    if (designChangeElement == "img" && variationName.includes("coverimage")) displayValue = "none";
                    if (designChangeElement == "reference" && variationName.includes("reference1") && variationName.includes("reference2") && variationName.includes("reference3") && variationName.includes("reference4")) displayValue = "none";
                    if (designChangeElement == "contact" && variationName.includes("venue") && variationName.includes("phone") && variationName.includes("creatoremail")) displayValue = "none";
                    if (
                        (designChangeElement == "social" || designChangeElement == "ctasocial") &&
                        variationName.includes("customsociallink1") &&
                        variationName.includes("customsociallink2") &&
                        variationName.includes("customsociallink3") &&
                        variationName.includes("customsociallink4") &&
                        variationName.includes("customsociallink5")
                    )
                        displayValue = "none";
                }
                if ((designChangeUsing == "enable" && displayValue != "none") || (designChangeUsing == "disable" && displayValue == "none")) this.designChange = true;
                else this.designChange = false;
                this.sgParent.innerHTML = "";
                // let oldSVG = null;
                // if (this.sgData?.[0]?.coverimageillustration) oldSVG = this.sgData[0].coverimageillustration;
                this.sgData = this.specialGraphicsUtils.buildDomContentArray(this.sgParent.parentElement.parentElement);
                // if (oldSVG) this.sgData[0].coverimageillustration = oldSVG;
                if (this.slideContent) {
                    this.slideContent.classList.remove("darkText");
                    this.slideContent.classList.remove("lightText");
                    this.slideContent.classList.remove("fixedlightText");
                    this.slideContent.classList.remove("fixeddarkText");
                }
                this.updatingDesign = true;
                this.prop2 = this.designChange;
                if (this.getPropsFromSlide) {
                    let propsFromSlide = this.getPropsFromSlide(this.slideContent ? this.slideContent.id : null);
                    if (propsFromSlide?.logogrid) this.objDataToSG.logogrid = propsFromSlide.logogrid;
                    if (propsFromSlide?.bggrid) this.objDataToSG.bggrid = propsFromSlide.bggrid;
                }
                this.initSpecialGraphicsCreation(false);
                if (this.arrCommonAssets.length > 0 && this.isPresent != true) {
                    this.assetsLoading = true;
                    this.assetLoadingCount = this.arrCommonAssets.length;
                    for (let a = 0; a < this.arrCommonAssets.length; a++) {
                        let obj = this.arrCommonAssets[a];
                        obj.docall = true;
                        this.loadAssets(obj.array, this.commonAssetsLoadComplete, this.assetError, obj);
                    }
                    this.arrCommonAssets = [];
                }
                this.specialGraphicsUtils.changeVariation(this.sgParent, slideDomContentGroup);
                let logoImageNode = this.assetParent.querySelector("[id='sgLogoImageNode']");
                if (logoImageNode) {
                    logoImageNode.callback = this.rePositionTextAndElement;
                    this.setLogoSizes();
                }
                let customerLogoImageNode = this.assetParent.querySelector("[id='sgCustomerLogoImageNode']");
                if (customerLogoImageNode) {
                    customerLogoImageNode.callback = this.rePositionTextAndElement;
                    this.setCustomerLogoSizes(1);
                }
                let presenterLogoImageNode = this.assetParent.querySelector("[id='sgPresenterLogoImageNode']");
                if (presenterLogoImageNode) {
                    presenterLogoImageNode.callback = this.rePositionTextAndElement;
                    this.setCustomerLogoSizes(2);
                }
            }
        }
    }
};

GenericCoverpage.prototype.getParentByProperty = function (propName) {
    if (propName == "pre" || propName == "presentertext") return this.sgParent.querySelector("[id='presenterParent']");
    if (propName == "presenterimage") return this.sgParent.querySelector("[id='presenterContentParent']");
    if (propName == "customerimage") return this.sgParent.querySelector("[id='customerContentParent']");
    if (propName == "cus" || propName == "customertext") return this.sgParent.querySelector("[id='customerParent']");
    if (propName == "logo" && this.sgParent.querySelector("[id='logoGridParent']")) return this.sgParent.querySelector("[id='logoGridParent']");
    if (propName == "logo") return this.sgParent.querySelector("[id='logoContentParent']");
    if (propName == "customerlogoimage") return this.sgParent.querySelector("[id='customerLogoContentParent']");
    if (propName == "presenterlogoimage") return this.sgParent.querySelector("[id='presenterLogoContentParent']");
    if (propName == "venue") return this.sgParent.querySelector("[id='sgVenueParent']");
    if (propName == "yr" || propName == "num") return this.sgParent.querySelector("[id='covernumber']");
    if (propName == "sectionnum") return this.sgParent.querySelector("[id='sgNumberTextParent']");
    if (propName == "img") return this.sgParent.querySelector("[id='coverImageParent']");
    if (propName == "tit") return this.sgParent.querySelector("[id='sgTitleNode']");
    if (propName == "reference") return this.sgParent.querySelector("[id='referenceParent']");
    if (propName == "contact") return this.sgParent.querySelector("[id='contactParent']");
    // if (propName == "map") return this.sgParent.querySelector("[id='sgMapParentNode']");
    if (propName == "social" || propName == "ctasocial") return this.sgParent.querySelector("[id='customLinkIconParent']");
    if (propName == "quoteicon" || propName == "quoteicon1") return this.sgParent.querySelector("[id='quoteParent1']");
    if (propName == "quoteicon2") return this.sgParent.querySelector("[id='quoteParent2']");
    if (propName == "quoteicon3") return this.sgParent.querySelector("[id='quoteParent3']");
    if (propName == "authimg") return this.sgParent.querySelector("[id='authorContentParent']");
    if (propName == "authtext") return this.sgParent.querySelector("[id='authorParent']");
    if (propName == "footer") return this.sgParent.querySelector("[id='sgFooterParent']");
    return null;
};
GenericCoverpage.prototype.checkContrastOnImageDisplayChange = function (oldImageDisplay = "") {
    let coverImageParent = this.assetParent.querySelector("[id='coverImageParent']");
    let coverImage = coverImageParent ? coverImageParent.querySelector("[data-target-id='coverimage']") : null;
    let newDisplay = coverImageParent ? window.getComputedStyle(coverImageParent)["display"] : "";
    if ((oldImageDisplay == "block" && newDisplay == "block") || (oldImageDisplay == "none" && newDisplay == "none") || (oldImageDisplay == "flex" && newDisplay == "flex")) {
    } else {
        // this.assetParent.removeAttribute("applycontrastonload");
        if (coverImageParent && coverImageParent.style.display == "none" && coverImage && coverImage.autoImageChange) {
            this.assetParent.classList.remove("fixeddarkText");
            this.assetParent.classList.remove("fixedlightText");
            this.assetParent.classList.remove("darkText");
            this.assetParent.classList.remove("lightText");
            // this.assetParent.setAttribute("applycontrastonload", "false");
            try {
                let slideParent = this.sgParent.parentElement.parentElement.parentElement.parentElement;
                slideParent.classList.remove("fixeddarkText");
                slideParent.classList.remove("fixedlightText");
                slideParent.classList.remove("darkText");
                slideParent.classList.remove("lightText");
            } catch (error) {}
        } else if (coverImageParent && coverImageParent.style.display != "none" && coverImage && coverImage.autoImageChange) this.applyContrastOnAutoImageChange(coverImage);
    }
};
//Before going to start presentation to particular slide this call will call
GenericCoverpage.prototype.initPresentSG = function (slideContent) {
    if (slideContent && slideContent.querySelectorAll("[svgid*='-path']").length > 0) {
        let arrClipNodes = slideContent.querySelectorAll("[svgid*='-path']");
        let arrCoverParent = slideContent.querySelectorAll("[id*='coverParent']");
        for (let a = 0; a < arrClipNodes.length; a++) {
            if (arrClipNodes[a].hasAttribute("maskid")) {
                let clipPathName = arrClipNodes[a].getAttribute("maskid");
                let clipPathNode = slideContent.querySelector("clipPath[id='" + clipPathName + "']");
                if (clipPathNode) {
                    clipPathNode.id = clipPathName + "-present";
                    if (arrCoverParent[a] && arrCoverParent[a].style.clipPath.includes("url(")) arrCoverParent[a].style.clipPath = 'url("#' + clipPathName + '-present")';
                }
            }
        }
    }
    if (slideContent && slideContent.querySelector("[data-lottie*='/']")) {
        let lottieParent = slideContent.querySelector("[data-lottie*='/']");
        lottieParent.innerHTML = "";
        let arrAssets = [{ type: "json", url: lottieParent.getAttribute("data-lottie"), id: "commonbglottie", parent: lottieParent }];
        // this.arrCommonAssets.push({ array: arrAssets, callback: this.lottieLoadCallback });
        this.loadAssets(arrAssets, this.lottieLoadCallback, this.assetError);
    }
};
//Present mode 1st call to start slide animation
GenericCoverpage.prototype.gotoAndStopFirstNode = function (completeCallback) {
    //Re-applying image contrast
    if (this.sgParent.clientHeight != 0 && this.sgParent.clientWidth != 0) this.reApplyContrast();

    let delayForLottieAnim = this.sgParent.dataset.introdelay ? this.sgParent.dataset.introdelay : 0;
    if (delayForLottieAnim > 0)
        setTimeout(() => {
            //Intro animation
            this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager);
        }, delayForLottieAnim);
    else this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager);
};
//Present mode hide slide animation
GenericCoverpage.prototype.hideAnimation = function (completeCallback) {
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", completeCallback, this.isPlayAnimation, this.eventManager);
};
GenericCoverpage.prototype.updateImage = function (elementId, src, index1, resizeImage = false) {
    let imageNode = this.sgParent.querySelector("[id='" + elementId + "']");
    if (imageNode && src) {
        imageNode = imageNode?.getElementsByTagName("img").length > 0 ? imageNode.getElementsByTagName("img")[0] : imageNode;
        imageNode.src = src;
        if (resizeImage) this.specialGraphicsUtils.updateImageReSize(imageNode.getAttribute("data-width"), imageNode.getAttribute("data-height"), imageNode);
        if (this.sgData[0].coverimage != src) this.sgData[0].coverimage = src;
        if (!elementId.toLocaleLowerCase().includes("presentor") && !elementId.toLocaleLowerCase().includes("logo")) {
            let imageId = imageNode.id ? imageNode.id.toLocaleLowerCase() : elementId;
            let imagePropname = imageId == "commonbgimage" ? "commonbg" : imageId.includes("presetimage") ? "presetimage" : imageId.includes("sgauthorimagenode") ? "authimg" : imageId.includes("coverimage") ? "image" : null;
            let props = this.getPropertyData();
            if (imagePropname && props && props[imagePropname]) {
                if (props[imagePropname].contrast && props[imagePropname].contrast == "fullbg") this.eventManager.dispatch("applyImageContrast", imageNode, this.assetParent);
                if (props[imagePropname].contrast && props[imagePropname].contrast == "halfbg") this.eventManager.dispatch("applyImageContrast", imageNode, this.assetParent, true);
            }
        }
        let duplicatedImages = this.assetParent ? this.assetParent.querySelectorAll("[data-target-id='coverimageduplicate']") : null;
        if (duplicatedImages?.length > 0 && elementId.includes("coverimage")) {
            for (let a = 0; a < duplicatedImages.length; a++) {
                let duplicatedImage = duplicatedImages[a];
                duplicatedImage.src = src;
            }
        }
        if (elementId.toLocaleLowerCase().includes("logo") || elementId.includes("sgPlaceHolderImageNode")) {
            imageNode.callback = this.rePositionTextAndElement;
            if (elementId.includes("sgPlaceHolderImageNode") || (imageNode.parentElement.parentElement.parentElement && imageNode.parentElement.parentElement.parentElement.id.includes("placeHolderParent"))) {
                let type = elementId.includes("sgPlaceHolderImageNode") ? "image" : "logo";
                this.setPlaceholderSizes(this.assetParent, type);
            } else if (elementId.toLocaleLowerCase().includes("customer") || elementId.toLocaleLowerCase().includes("presenter")) {
                this.setCustomerLogoSizes();
            } else this.setLogoSizes();
        }
    }
};
GenericCoverpage.prototype.updateImageResizeOnTypeChange = function (type) {
    this.setPlaceholderSizes(this.assetParent, type);
    this.textFitOnImageResize();
    this.checkShapeDependency();
};
GenericCoverpage.prototype.updateImageResizeOnly = function (imageNode) {
    if (imageNode) {
        if (imageNode.getElementsByTagName("img").length > 0) imageNode = imageNode.getElementsByTagName("img")[0];
        this.specialGraphicsUtils.updateImageReSize(imageNode.getAttribute("data-width"), imageNode.getAttribute("data-height"), imageNode);
    }
};
GenericCoverpage.prototype.applyContrastOnAutoImageChange = function (imageNode) {
    if (this.metaData && this.metaData && this.metaData[this.designChange == true ? "properties2" : "properties"] && this.metaData[this.designChange == true ? "properties2" : "properties"].image) {
        let props = this.metaData[this.designChange == true ? "properties2" : "properties"].image;
        if (imageNode && imageNode.hasAttribute("contrast") && imageNode.getAttribute("contrast") == "fullbg") this.eventManager.dispatch("applyImageContrast", imageNode, this.assetParent);
        else if (imageNode && imageNode.hasAttribute("contrast") && imageNode.getAttribute("contrast") == "halfbg") this.eventManager.dispatch("applyImageContrast", imageNode, this.assetParent, true);
        else if (props.contrast && props.contrast == "fullbg" && imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, this.assetParent);
        else if (props.contrast && props.contrast == "halfbg" && imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, this.assetParent, true);
    }
};

GenericCoverpage.prototype.changeText = function (updatedText, elementId, targetIndex, textType, updateMap = true) {
    let textNode = this.sgParent.querySelector("[id='" + elementId + "']");
    textNode = !textNode ? this.sgParent.querySelector("[id*='" + elementId + "']") : textNode;
    if (!textNode) textNode = this.sgParent.querySelector("[id='covernumbercontent']");
    if (!textNode) textNode = this.sgParent.querySelector("[id='covernumber']");

    if (textNode.id?.includes("sgNumberTextNode") && updatedText?.includes("<br>")) updatedText = updatedText.replaceAll("<br>", "");
    if (textNode && textNode.innerHTML != updatedText) {
        textNode.setAttribute("data-heading", updatedText);
        textNode.setAttribute("data-oldtext", updatedText);
        textNode.setAttribute("data-changetext", "true");
        textNode.innerHTML = updatedText;

        this.specialGraphicsUtils.doFontFitForCss(textNode, this.sgParent, null, null, null, true);

        if (elementId && elementId == "sgTitleNode" && updatedText.trim().length != 0 && this.sgData[0].coverimage.includes("placeholderimages/coverimage")) this.specialGraphicsUtils.searchImage(this.sgParent, this.appBaseURL, updatedText, null, this);
        this.specialGraphicsUtils.updateImagePositions(this.sgParent);
    }
    if (elementId && (elementId.includes("socialIconTextSubTitle") || elementId.includes("sgreferenceLink"))) {
        if (updatedText && !updatedText.includes("http")) updatedText = "https://" + updatedText;
        if (textNode && textNode.parentElement.parentElement && elementId.includes("socialIconTextSubTitle")) this.updateAgendaLink(null, updatedText, textNode.parentElement.parentElement.id);
        else if (textNode && textNode.parentElement && elementId.includes("sgreferenceLink")) this.updateAgendaLink(null, updatedText, textNode.parentElement.id);
        else this.updateAgendaLink(null, updatedText, elementId);

        let customSocialLink = textNode && textNode.parentElement.parentElement ? textNode.parentElement.parentElement : null;
        if (elementId.includes("sgreferenceLink") && textNode) customSocialLink = textNode && textNode.parentElement ? textNode.parentElement : null;
        let clsName = elementId.includes("socialIconTextSubTitle") ? "clsSocialLink" : "clsReference";
        if (updatedText && updatedText.includes(".") && !updatedText.includes(" ") && customSocialLink) customSocialLink.classList.add(clsName);
        else if (customSocialLink) customSocialLink.classList.remove(clsName);
    }
    if (textNode && textNode.hasAttribute("rotatednode") && textNode.getAttribute("rotatednode") == "true") textNode.style.minWidth = window.getComputedStyle(textNode).lineHeight;

    let textBaseParentNode = this.assetParent.querySelector("[id*='textBaseParentNode']");
    if (!textBaseParentNode && textNode && (textNode.id.includes("sgTitleNode") || textNode.id.includes("sgTitleLabelNode") || textNode.id.includes("sgSubTitleNode"))) {
        this.onTextChangeForAllNodes(null, textNode.id.includes("sgTitleNode"), textNode.id.includes("sgSubTitleNode"));
        this.rePositionTextAndElement();
    }

    this.updateTextSizeForCtaSocial();
    if (elementId.includes("ctaSocialNodeHeadingText") || elementId.includes("ctaSocialNodeContentText")) {
        this.setSocialIconsMaxWidth();
        this.setSocialIconsMinWidth();
    }
    this.updateMaxWidthForCtaSocial();
    this.arrNodeGapForSpeaker();
    this.speakerTextMinWidthCalculations();
    this.checkShapeDependency();
};

GenericCoverpage.prototype.rePositionTextAndElement = function () {
    this.onTextChangeForAllNodes();
    this.textElementPositioning();
    this.applyLogoGridSize();
};

GenericCoverpage.prototype.deleteNodeCallback = function () {
    // this.setSpeakerPadding();
    this.arrNodeGapForSpeaker();
    this.speakerTextMinWidthCalculations();
    this.speakerImageSizeUpdate();
    this.doSpeakerFontFit();
};

GenericCoverpage.prototype.onTextChangeUpdateSpeakerNode = function (textNode) {
    if (textNode) {
        let speakerParent = this.sgParent.querySelector("[id='speakerParent']");
        let primaryNode = textNode.parentElement.parentElement.querySelector("[data-cssslide*='primary']");
        let secondaryNode = textNode.parentElement.parentElement.querySelector("[data-cssslide*='secondary']");
        if (primaryNode && secondaryNode && speakerParent) {
            let primaryLineHeight = parseFloat(window.getComputedStyle(primaryNode)["line-height"]);
            primaryNode.style.minHeight = Math.ceil(primaryLineHeight) + 2 + "px";

            let secondaryLineHeight = parseFloat(window.getComputedStyle(secondaryNode)["line-height"]);
            secondaryNode.style.minHeight = Math.ceil(secondaryLineHeight) + 2 + "px";

            let lineHeight = textNode.id.includes("Primary") ? primaryLineHeight : secondaryLineHeight;

            let speakerParentHeight = parseFloat(speakerParent.style.height);
            if (speakerParentHeight == "auto") speakerParentHeight = parseFloat(speakerParent.style.maxHeight);
            if (speakerParent.hasAttribute("parentFullHeight")) speakerParentHeight = parseFloat(speakerParent.getAttribute("parentFullHeight"));

            let secondaryStyle = secondaryNode ? window.getComputedStyle(secondaryNode) : null;
            let secondaryMargin = secondaryStyle ? parseFloat(secondaryStyle.marginTop) + parseFloat(secondaryStyle.marginBottom) : 0;

            let parentStyle = secondaryNode ? window.getComputedStyle(textNode.parentElement.parentElement.parentElement) : null;
            let parentMargin = parentStyle ? parseFloat(parentStyle.marginTop) + parseFloat(parentStyle.marginBottom) : 0;
            let parenPadding = parentStyle ? parseFloat(parentStyle.paddingTop) + parseFloat(parentStyle.paddingBottom) : 0;

            let imageNodeFinalHeight = 0;
            if (speakerParent.classList.contains("speakertype1") || speakerParent.classList.contains("speakertype2")) {
                let firstNode = speakerParent.children[0];
                if (firstNode.style.display == "none" && speakerParent.children[1]) firstNode = speakerParent.children[1];
                if (firstNode.style.display == "none" && speakerParent.children[2]) firstNode = speakerParent.children[2];
                if (firstNode.style.display == "none" && speakerParent.children[3]) firstNode = speakerParent.children[3];
                let imgNode = firstNode.querySelector("[id*='speakerContentParent']");
                if (imgNode && imgNode.style.display != "none") {
                    let imgNodeStyle = window.getComputedStyle(imgNode);
                    let imgH = imgNode.offsetHeight + (parseFloat(imgNodeStyle.marginBottom) + parseFloat(imgNodeStyle.marginTop));
                    if (imgH > 0 && !isNaN(imgH)) imageNodeFinalHeight = imgH;
                }
            }

            speakerParentHeight = speakerParentHeight - secondaryMargin - parentMargin - parenPadding;
            if (speakerParentHeight > 0 && speakerParent.children.length > 0 && speakerParent.classList.contains("speakervertical")) {
                let firstNode = speakerParent.children[0];
                let elementPadding = this.specialGraphicsUtils.getPadding(firstNode);
                let visibileCount = firstNode && firstNode.hasAttribute("data-count") ? firstNode.getAttribute("data-count") : 4;
                speakerParentHeight = speakerParentHeight / parseInt(visibileCount) - (parseFloat(elementPadding.paddingBottom) + parseFloat(elementPadding.paddingTop) + imageNodeFinalHeight);
            } else if (speakerParentHeight > 0 && speakerParent.classList.contains("speakerhorizontal")) {
                speakerParentHeight = speakerParentHeight - imageNodeFinalHeight;
            } else if (speakerParentHeight > 0 && speakerParent.classList.contains("speakergrid")) {
                let firstNode = speakerParent.children[0];
                let visibileCount = firstNode && firstNode.hasAttribute("data-count") ? firstNode.getAttribute("data-count") : 4;
                let elementPadding = this.specialGraphicsUtils.getPadding(firstNode);
                visibileCount = parseInt(visibileCount) > 2 ? 2 : 1;
                speakerParentHeight = speakerParentHeight / visibileCount - (parseFloat(elementPadding.paddingBottom) + parseFloat(elementPadding.paddingTop) + imageNodeFinalHeight);
            }
            textNode.style.removeProperty("max-height");
            textNode.style.maxHeight = "";

            let primaryHeight = primaryNode.style.maxHeight != "" && primaryNode.style.display != "none" ? parseFloat(primaryNode.style.maxHeight) : parseFloat(window.getComputedStyle(primaryNode).height);
            let secondaryHeight = secondaryNode.style.maxHeight != "" && secondaryNode.style.display != "none" ? parseFloat(secondaryNode.style.maxHeight) : parseFloat(window.getComputedStyle(secondaryNode).height);

            let totalTextHeight = primaryHeight + secondaryHeight;

            if (totalTextHeight > speakerParentHeight) {
                let targetNodeHeight = textNode.id.includes("Primary") ? parseFloat(secondaryHeight == "auto" ? 0 : secondaryHeight) : parseFloat(primaryHeight == "auto" ? 0 : primaryHeight);
                let remainingHeight = speakerParentHeight - targetNodeHeight;

                let linesFinal = parseInt(remainingHeight / lineHeight);
                let heightFinal = linesFinal * lineHeight;
                heightFinal = heightFinal == 0 ? lineHeight : heightFinal;

                textNode.style.maxHeight = heightFinal + "px";

                let minH = parseFloat(textNode.style.minHeight);
                if (!isNaN(minH) && minH > heightFinal) textNode.style.maxHeight = heightFinal + "px";
            } else {
                let numberOflines = (textNode.id.includes("Primary") ? primaryHeight : secondaryHeight) / lineHeight;
                let diff = numberOflines - parseInt(numberOflines);
                if (diff > 0.9) numberOflines = parseInt(numberOflines) + 1;
                let maxHeightValue = parseInt(numberOflines) * lineHeight;
                textNode.style.maxHeight = maxHeightValue + "px";
            }
        }
    }
};
GenericCoverpage.prototype.getPropertyData = function () {
    let designValue = this.designChange;
    if (this.prop2 != null && this.prop2 != undefined) designValue = this.prop2;
    if (this.metaData && this.metaData && this.metaData[designValue == true ? "properties2" : "properties"]) {
        let props = this.metaData[designValue == true ? "properties2" : "properties"];
        return props;
    }
    return null;
};

GenericCoverpage.prototype.setSpeakerPadding = function () {
    // let speakerParent = this.sgParent.querySelector("[id='speakerParent']");
    // if (speakerParent) {
    //     let arrNodes = this.sgParent.querySelectorAll("[id*='speakerNodeGroup']");
    //     let startIndex = 0;
    //     let lastNode;
    //     for (let c = 0; c < arrNodes.length; c++) {
    //         let node = arrNodes[c];
    //         node.classList.remove("firstNode");
    //         node.classList.remove("lastNode");
    //         if (node.style.display != "none") {
    //             startIndex = startIndex + 1;
    //             lastNode = node;
    //         }
    //         if (startIndex == 1) node.classList.add("firstNode");
    //     }
    //     if (lastNode) lastNode.classList.add("lastNode");
    // }
};

GenericCoverpage.prototype.setContactPadding = function () {
    let contactParent = this.sgParent.querySelector("[id='contactParent']");
    if (contactParent) {
        let sgmailingAddressParent = contactParent.querySelector("[id='sgmailingAddressParent']");
        let sgemailAddressParent = contactParent.querySelector("[id='sgemailAddressParent']");
        let sgphoneNumberParent = contactParent.querySelector("[id='sgphoneNumberParent']");
        let sgwebsiteParent = contactParent.querySelector("[id='sgwebsiteParent']");

        let startIndex = 0;
        let lastNode;

        for (let a = 0; a < 4; a++) {
            let element = a == 0 ? sgmailingAddressParent : a == 1 ? sgemailAddressParent : a == 2 ? sgphoneNumberParent : sgwebsiteParent;
            if (element && element.style.display != "none") {
                startIndex = startIndex + 1;
                lastNode = element;
                element.classList.remove("firstNode");
                element.classList.remove("lastNode");
                if (startIndex == 1) element.classList.add("firstNode");
            }
        }
        if (lastNode) lastNode.classList.add("lastNode");
    }
};

GenericCoverpage.prototype.deviceClippathCheck = function () {
    for (let a = 0; a < 2; a++) {
        let deviceContainerNode = this.sgParent.querySelector("[id='deviceContainerNode" + (a == 0 ? "" : a) + "']");
        if (deviceContainerNode) {
            deviceContainerNode.style.position = "absolute";
            let svgParent = deviceContainerNode.querySelector("[id*='deviceHolderNode']");
            let assetname = svgParent.getAttribute("assetname");
            if (!assetname) return;
            // console.log("SGG - updating clippath");
            let clipID = assetname + "-clip-path";
            let oldClipID = assetname + "-clip-path";
            let clipPathGroupNode = svgParent.querySelector("g[clip-path*='url(#" + clipID + ")']");
            if (svgParent.hasAttribute("maskid")) clipID = svgParent.getAttribute("maskid");
            else clipID = assetname + "-clip-path" + this.specialGraphicsUtils.generateRandomStringCSS();
            svgParent.setAttribute("maskid", clipID);
            svgParent.setAttribute("svgid", clipID);
            let bbox = clipPathGroupNode ? clipPathGroupNode.getBBox() : { width: 0, height: 0, x: 0, y: 0 };
            let scaleValue = 1;
            let svgDOM;
            let coverParent = this.sgParent.querySelector("[id*='coverParent" + (a == 0 ? "" : "1") + "']");
            if (coverParent) {
                coverParent.parentElement.classList.remove("slideGraphicElementTransformHoverState");
                coverParent.classList.add("slideGraphicElementTransformHoverState");
                if (deviceContainerNode.parentElement.hasAttribute("data-originalwidth")) {
                    deviceContainerNode.parentElement.style.width = deviceContainerNode.parentElement.getAttribute("data-originalwidth");
                    deviceContainerNode.parentElement.style.height = deviceContainerNode.parentElement.getAttribute("data-originalheight");
                } else {
                    let parentStyle = window.getComputedStyle(deviceContainerNode.parentElement);
                    deviceContainerNode.parentElement.setAttribute("data-originalwidth", parentStyle.width);
                    deviceContainerNode.parentElement.setAttribute("data-originalheight", parentStyle.height);
                }
                let isW;
                let scaleX = 1;
                let scaleY = 1;
                if (svgParent.getElementsByTagName("svg").length > 0 && clipID) {
                    svgDOM = svgParent.getElementsByTagName("svg")[0];
                    let imageParentStyle = window.getComputedStyle(deviceContainerNode);
                    if (svgDOM && imageParentStyle && imageParentStyle.width != 0 && imageParentStyle.height != 0) {
                        svgDOM.style.position = "absolute";
                        svgDOM.style.width = "100%";
                        svgDOM.style.height = "100%";
                        svgDOM.style.left = "0px";
                        svgDOM.style.top = "0px";
                        let elementPadding = this.specialGraphicsUtils.getPadding(deviceContainerNode);
                        let widthValue = parseFloat(deviceContainerNode.parentElement.getAttribute("data-originalwidth")) - (parseFloat(elementPadding.paddingLeft) + parseFloat(elementPadding.paddingRight));
                        let svgViewBoxW = parseFloat(svgDOM.getAttribute("viewBox").split(" ")[2]);
                        scaleX = widthValue / svgViewBoxW;

                        scaleY = (parseFloat(deviceContainerNode.parentElement.getAttribute("data-originalheight")) - (parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom))) / parseFloat(svgDOM.getAttribute("viewBox").split(" ")[3]);
                        scaleValue = Math.min(scaleX, scaleY);
                        isW = scaleValue === scaleX;
                        if (scaleValue == 0) scaleValue = 1;
                        let clipPathNode = svgDOM.querySelector("clipPath[id='" + oldClipID + "']");
                        if (clipPathNode) {
                            clipPathNode.setAttribute("id", clipID);
                            if (bbox && bbox.width) clipPathNode.style.transform = "scale(" + scaleValue + ") translate(" + parseFloat(bbox.x) * -1 + "px," + parseFloat(bbox.y) * -1 + "px)";
                        }
                    }
                }
                if (bbox && bbox.width && isW != null && isW != undefined) {
                    coverParent.style.width = bbox.width * scaleValue + "px";
                    coverParent.style.height = bbox.height * scaleValue + "px";
                    coverParent.style.left = bbox.x * scaleValue + "px";
                    coverParent.style.top = bbox.y * scaleValue + "px";
                    coverParent.style.position = "absolute";

                    let svgBBox = svgDOM ? svgDOM.getBBox() : { width: 0, height: 0, x: 0, y: 0 };

                    if (!isW) deviceContainerNode.parentElement.style.width = svgBBox.width * scaleValue + "px";
                    else deviceContainerNode.parentElement.style.height = svgBBox.height * scaleValue + "px";

                    deviceContainerNode.style.width = "100%";
                    deviceContainerNode.style.height = "100%";
                    deviceContainerNode.style.left = "0px";
                    deviceContainerNode.style.top = "0px";
                    deviceContainerNode.style.position = "absolute";
                    coverParent.parentElement.style.width = "100%";
                    coverParent.parentElement.style.height = "100%";
                    coverParent.parentElement.style.left = "0px";
                    coverParent.parentElement.style.top = "0px";
                    coverParent.parentElement.style.position = "absolute";

                    let imageNode = coverParent.getElementsByTagName("img").length > 0 ? coverParent.getElementsByTagName("img")[0] : null;
                    if (imageNode) {
                        imageNode.setAttribute("data-width", parseFloat(coverParent.style.width));
                        imageNode.setAttribute("data-height", parseFloat(coverParent.style.height));
                        this.specialGraphicsUtils.updateImageReSize(imageNode.getAttribute("data-width"), imageNode.getAttribute("data-height"), imageNode);
                    }
                }
                coverParent.style.setProperty("clip-path", "url(#" + clipID + ")");
                coverParent.style.setProperty("-webkit-clip-path", "url(#" + clipID + ")");
            }
        }
    }
};
GenericCoverpage.prototype.svgLoadCallback = function (responseData) {
    for (let a = 0; a < responseData.length; a++) {
        let parentNode = responseData[a].parent;
        let isDevice = responseData[a].device;
        let colorClass = responseData[a] && responseData[a].color ? responseData[a].color : "clsAccentfill";
        var parser = new DOMParser();
        var doc = parser.parseFromString(responseData[a].data, "image/svg+xml");
        if (isDevice) {
            let imagePath = responseData[a].imagePath;
            let assetname = responseData[a].assetname;
            if (assetname && imagePath) {
                let svgParent = parentNode;
                parentNode.appendChild(doc.lastChild);
                if (parentNode.getElementsByTagName("svg").length > 0) parentNode.getElementsByTagName("svg")[0].setAttribute("path", imagePath.replace(".png", ".svg"));
                parentNode.setAttribute("assetname", assetname);
                if (svgParent.querySelector("[id*='" + assetname + "-image']") && imagePath) {
                    let imageNode = svgParent.querySelector("[id*='" + assetname + "-image']").getElementsByTagName("image");
                    if (imageNode && imageNode.length > 0) imageNode[0].setAttribute("xlink:href", imagePath);
                }
                this.deviceClippathCheck();
            }
        } else if (parentNode && parentNode.querySelector("[id*='contentBackground']")) {
            //Loading svg from menu for icon/image background svg global style - only for "contentBackground"
            let bgNode = parentNode.querySelector("[id*='contentBackground']");
            bgNode.classList.remove(colorClass);
            bgNode.classList.add(colorClass);
            bgNode.innerHTML = "";
            bgNode.appendChild(doc.lastChild);
        }
    }
};

GenericCoverpage.prototype.textPositionChangeOperation = function (targetParent, pos) {
    if (targetParent) {
        for (let a = 0; a < targetParent.children.length; a++) {
            if (targetParent.children[a].style.position != "absolute") {
                if (a == 0) {
                    let arrEditableNodes = targetParent.querySelectorAll("[contenteditable='true']");
                    for (let b = 0; b < arrEditableNodes.length; b++) {
                        arrEditableNodes[b].style.removeProperty("text-align");
                        if (arrEditableNodes[b].getElementsByTagName("ul").length > 0) arrEditableNodes[b].style.removeProperty("justify-content");
                    }
                    if (targetParent.querySelector("[id*='sgSubTitleNode']")) {
                        targetParent.querySelector("[id*='sgSubTitleNode']").style.removeProperty("text-align");
                        if (targetParent.querySelector("[id*='sgSubTitleNode']").getElementsByTagName("ul").length > 0) targetParent.querySelector("[id*='sgSubTitleNode']").style.removeProperty("justify-content");
                    }
                }
                let element = targetParent.children[a];
                let elementId = element.id;
                // console.log("SGG - Childs - " + elementId);
                pos = pos.replace("sg", "");
                let textAlign = pos == "TL" || pos == "ML" || pos == "BL" ? "start" : pos == "TR" || pos == "MR" || pos == "BR" ? "end" : pos == "TM" || pos == "MM" || pos == "BM" ? "center" : "";
                if (elementId && elementId.includes("placeHolderParent")) {
                    element = element.querySelector("[id*='logoContentParent']");
                    elementId = element.id;
                }
                if (elementId == "logoContentParent") {
                    if (element.getElementsByTagName("img").length > 0) {
                        let imageNode = element.getElementsByTagName("img")[0];
                        if (!imageNode.hasAttribute("data-oldimagecropalignment")) imageNode.setAttribute("data-oldimagecropalignment", imageNode.getAttribute("data-imagecropalignment"));
                        imageNode.setAttribute(
                            "data-imagecropalignment",
                            pos == "TL" || pos == "ML" || pos == "BL" ? "left" : pos == "TR" || pos == "MR" || pos == "BR" ? "right" : pos == "TM" || pos == "MM" || pos == "BM" ? "center" : imageNode.hasAttribute("data-oldimagecropalignment") ? imageNode.getAttribute("data-oldimagecropalignment") : "center"
                        );
                        imageNode.removeAttribute("data-style");
                        imageNode.removeAttribute("data-csstext");
                        // console.log("SGG - Logo align - " + imageNode.getAttribute("data-imagecropalignment"));
                        this.specialGraphicsUtils.updateImageReSize(imageNode.getAttribute("data-width"), imageNode.getAttribute("data-height"), imageNode);
                    }
                } else if (elementId == "logoGridParent") {
                    this.assetParent.style.setProperty("--logoImageAlignHorizontal", textAlign == "start" ? "flex-start" : textAlign == "end" ? "flex-end" : "center");
                    let diagramparent = element.querySelector("[id='diagramparent']");
                    if (diagramparent) diagramparent.style.justifyContent = textAlign == "start" ? "flex-start" : textAlign == "end" ? "flex-end" : "center";
                } else if (elementId == "customerLogoContentParent") {
                    this.assetParent.style.setProperty("--customerLogoImageAlignHorizontal", textAlign == "start" ? "flex-start" : textAlign == "end" ? "flex-end" : "center");
                    let diagramparent = element.querySelector("[id='customerdiagramparent']");
                    if (diagramparent) diagramparent.style.justifyContent = textAlign == "start" ? "flex-start" : textAlign == "end" ? "flex-end" : "center";
                } else if (elementId == "presenterLogoContentParent") {
                    this.assetParent.style.setProperty("--presenterLogoImageAlignHorizontal", textAlign == "start" ? "flex-start" : textAlign == "end" ? "flex-end" : "center");
                    let diagramparent = element.querySelector("[id='presenterdiagramparent']");
                    if (diagramparent) diagramparent.style.justifyContent = textAlign == "start" ? "flex-start" : textAlign == "end" ? "flex-end" : "center";
                } else if (elementId == "sgVenueParent") element.style.setProperty("--venueAlign", textAlign);
                else if (elementId == "sgPresentedToNode") element.style.setProperty("--presentedToAlign", textAlign);
                else if (elementId == "sgPresentedByNode") element.style.setProperty("--presentedByAlign", textAlign);
                else if (elementId == "sgPresenterCompanyNode") element.style.setProperty("--presenterCompanyAlign", textAlign);
                else if (elementId == "sgCustomerCompanyNode") element.style.setProperty("--customerCompanyAlign", textAlign);
                else if (elementId == "sgAuthorTitleNode") element.style.setProperty("--authorTitleAlign", textAlign);
                else if (elementId == "sgVenueTitleNode") element.style.setProperty("--venueTitleAlign", textAlign);
                else if (elementId == "sgDateTitleNode") element.style.setProperty("--dateTitleAlign", textAlign);
                else if (elementId == "sgWebsiteLinkNode") element.style.setProperty("--websiteLinkAlign", textAlign);
                else if (elementId == "covernumber") {
                    element.style.justifyContent = textAlign == "start" ? "flex-start" : textAlign == "end" ? "flex-end" : "center";
                    let covernumbercontent = element.querySelector("[id='covernumbercontent']");
                    if (covernumbercontent) covernumbercontent.style.textAlign = textAlign;
                } else if (elementId == "sgNumberTextParent") {
                    element.style.justifyContent = textAlign == "start" ? "flex-start" : textAlign == "end" ? "flex-end" : "center";
                } else if (elementId == "quotePlaceHolderParent") {
                    element.style.setProperty("--quotePlaceholderHAlign", textAlign == "start" ? "flex-start" : textAlign == "end" ? "flex-end" : "center");
                    element.style.setProperty("--quotePlaceholderAlign", textAlign);
                } else if (elementId == "sgFooterParent") {
                    element.style.setProperty("--sgFooterHAlign", textAlign == "start" ? "flex-start" : textAlign == "end" ? "flex-end" : "center");
                    element.style.setProperty("--sgFooterAlign", textAlign);
                } else if (elementId == "presenterParent") {
                    let isAlignNode = element.classList.contains("pre_type3") || element.classList.contains("pre_type3right") || element.classList.contains("pre_type3center");
                    if (isAlignNode) {
                        element.classList.remove("pre_type3");
                        element.classList.remove("pre_type3right");
                        element.classList.remove("pre_type3center");
                        let newClass = textAlign == "center" ? "pre_type3center" : textAlign == "end" ? "pre_type3right" : "pre_type3";
                        element.classList.add(newClass);
                    }
                } else if (elementId == "authorParent") {
                    element.style.justifyContent = textAlign == "start" ? "flex-start" : textAlign == "end" ? "flex-end" : "center";
                    this.assetParent.style.setProperty("--authTextAlign", textAlign);
                }
            }
        }
        //Text Element positioning after all text's props change
        this.doCommonTextElementPosition();
        this.checkShapeDependency();
    }
};

GenericCoverpage.prototype.createPlaceHolder = function (parentNode, currentIndex) {
    let props = this.getPropertyData();
    // let src = "";
    let placeholderProperty = null;
    if (props && props["placeholderimage"]) placeholderProperty = props["placeholderimage"];
    // if (placeholderProperty && placeholderProperty.imageurl) src = placeholderProperty.imageurl;

    this.createPlaceHolderImage(parentNode, currentIndex);
    let parentElement = parentNode.querySelector("[id*='placeHolderParent']");
    let logoParent = parentElement.querySelector("[id*='logoContentParent']");
    let imageParent = parentElement.querySelector("[id*='phImageContentParent']");
    let iconParent = parentElement.querySelector("[id*='phIconContentParent']");
    let textParent = parentElement.querySelector("[id*='phTextParent']");
    let phTextNode = parentElement.querySelector("[id*='phTextNode']");
    let logoImageNode = logoParent ? logoParent.querySelector("[id*='sgLogoImageNode']") : null;

    let placeHolderType = this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagetype ? this.sgData[currentIndex].placeholderimagetype : placeholderProperty.placeholderimagetype ? placeholderProperty.placeholderimagetype : "logo";
    if (placeHolderType && logoParent && imageParent && iconParent && textParent) {
        logoParent.classList.remove("placeholderactive");
        imageParent.classList.remove("placeholderactive");
        iconParent.classList.remove("placeholderactive");
        textParent.classList.remove("placeholderactive");
        if (placeHolderType == "logo") logoParent.classList.add("placeholderactive");
        if (placeHolderType == "image") imageParent.classList.add("placeholderactive");
        if (placeHolderType == "icon") iconParent.classList.add("placeholderactive");
        if (placeHolderType == "text") textParent.classList.add("placeholderactive");
        if (placeholderProperty.placeholdersizestyle) {
            let sizeStyle = placeholderProperty.placeholdersizestyle;
            if (!parentElement.classList.contains("placeholderSizeStyle")) parentElement.classList.add("placeholderSizeStyle");
            parentElement.setAttribute("data-placeholdersizestyle", sizeStyle);
            logoParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            imageParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            iconParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            textParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            if (!logoParent.classList.contains(sizeStyle)) logoParent.classList.add(sizeStyle);
            if (!imageParent.classList.contains(sizeStyle)) imageParent.classList.add(sizeStyle);
            if (!iconParent.classList.contains(sizeStyle)) iconParent.classList.add(sizeStyle);
            if (!textParent.classList.contains(sizeStyle)) textParent.classList.add(sizeStyle);
        }
    }
    let specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL, this);
    specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
    specialgraphicsPropertyUtils.applyImageBaseProps(placeholderProperty, this.assetParent, parentElement, "--placeholderImage", false);

    let colorValue = placeholderProperty ? this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "secondary", placeholderProperty.textcolor) : null;
    // if (!colorValue && placeholderProperty.textcolor) colorValue = "rgba(var(--" + placeholderProperty.textcolor + "-color-rgb),1)";
    if (phTextNode && colorValue) {
        phTextNode.style.color = colorValue;
        phTextNode.setAttribute("data-color", colorValue);
    }

    if (this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagesize && parentElement) parentElement.setAttribute("data-placeholderimagesize", this.sgData[currentIndex].placeholderimagesize);
    if (placeHolderType == "image" || placeHolderType == "logo" || placeHolderType == "icon" || placeHolderType == "text") this.setPlaceholderSizes(this.assetParent, placeHolderType);

    if (this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagealign) {
        let alignData = this.sgData[currentIndex].placeholderimagealign;
        if (alignData == "bottom" || alignData == "right") parentElement.classList.add("phPosition");
        else parentElement.classList.remove("phPosition");
    }
    if (placeholderProperty.placeholderalign) parentElement.setAttribute("phalign", placeholderProperty.placeholderalign);
    if (this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagesize) {
        //Implement placeholder size change from floter
        // let sizeV = this.sgData[currentIndex].placeholderimagesize;
        // let multipleValue = sizeV == "small" ? 0.4 : sizeV == "medium" ? 0.7 : sizeV == "large" ? 1 : parseFloat(sizeV);
        let multipleValue = this.specialGraphicsUtils.getImageSizeSML(this.sgData[currentIndex].placeholderimagesize);
        let largeW = parseFloat(parentElement.getAttribute("data-largewidth"));
        let largeH = parseFloat(parentElement.getAttribute("data-largeheight"));
        let newW = largeW * multipleValue;
        let newH = largeH * multipleValue;
        let cropHeight = logoImageNode && logoImageNode.hasAttribute("logosizecropheight") ? logoImageNode.getAttribute("logosizecropheight") : "";
        if (newW > 0 && newH > 0) {
            parentElement.style.width = newW + "px";
            if (cropHeight == "") parentElement.style.height = newH + "px";
        }
        if (logoImageNode) logoImageNode.removeAttribute("logosizecropheight");
    }
    let hasPlaceholderData = this.sgData[currentIndex].placeholderimage != null && this.sgData[currentIndex].placeholderimage != undefined;
    if (placeHolderType == "icon" && iconParent && hasPlaceholderData) {
        let iconPath = this.sgData[currentIndex].placeholderimage.includes(".svg") ? this.sgData[currentIndex].placeholderimage : this.appStaticURL + "genericassets/icons/fill/default/best.svg";
        let iconNodeParent = iconParent.querySelector("[id*='phIconSvgNode']");
        let arrAssets = [];
        if (iconNodeParent) iconNodeParent.setAttribute("data-src", iconPath);
        arrAssets.push({ url: iconPath, id: "svgdata", parent: iconNodeParent, type: "SVG" });
        this.arrCommonAssets.push({ array: arrAssets, callback: this.placeholderSvgLoadCallback });
    }
    if (placeholderProperty && placeholderProperty.halign) {
        let halignProp = placeholderProperty.halign;
        let hAlign = halignProp == "right" || halignProp == "end" ? "flex-end" : halignProp == "center" || halignProp == "middle" ? "center" : "flex-start";
        let pos = halignProp == "right" || halignProp == "end" ? "right" : halignProp == "center" || halignProp == "middle" ? "center" : "left";
        if (logoImageNode) logoImageNode.setAttribute("data-imagecropalignment", pos);
        let phTextNode = textParent.querySelector("[id*='phTextNode']");
        if (phTextNode) phTextNode.style.textAlign = hAlign;
    }
    this.applyContrastToText(logoImageNode, placeholderProperty);
    this.applyContrastToText(phTextNode, placeholderProperty);
};

GenericCoverpage.prototype.setPlaceholderSizes = function (assetParent, placeHolderType = "") {
    let phParent = this.assetParent.querySelector("[id*='placeHolderParent']");
    let assetParentNode = phParent ? phParent : this.assetParent;
    let imgNode = assetParentNode ? assetParentNode.querySelector("[id*='sgLogoImageNode']") : null;
    if (placeHolderType == "icon") {
        imgNode = assetParentNode ? assetParentNode.querySelector("[id*='phIconSvgNode']") : null;
        this.setPlaceholderSizesOP(imgNode);
    } else if (placeHolderType == "text") {
        imgNode = assetParentNode ? assetParentNode.querySelector("[id*='phTextNode']") : null;
        this.setPlaceholderSizesOP(imgNode);
        this.onTextChangeUpdatePlaceholderNode(imgNode);
    } else {
        if (placeHolderType == "image") imgNode = assetParentNode ? assetParentNode.querySelector("[id='sgPlaceHolderImageNode']") : null;

        if (imgNode && imgNode.complete) this.setPlaceholderSizesOP(imgNode);
        else if (imgNode) imgNode.addEventListener("load", this.placeholderLoadCallback);
    }
};
GenericCoverpage.prototype.placeholderLoadCallback = function (event) {
    event.target.removeEventListener("load", this.placeholderLoadCallback);
    this.setPlaceholderSizesOP(event.target);
};
GenericCoverpage.prototype.setPlaceholderSizesOP = function (imgNode) {
    let logoRatio = this.specialGraphicsUtils.getLogoRatio(imgNode);
    // console.log("PLCEHOLDER - ratio - " + logoRatio);
    if (!logoRatio) logoRatio = "square";
    if (logoRatio && imgNode) {
        let dummyDom = document.createElement("div");
        dummyDom.classList.add(logoRatio);
        dummyDom.style.position = "absolute";
        dummyDom.style.width = "var(--logoSizeWidth)";
        dummyDom.style.height = "var(--logoSizeHeight)";
        if (imgNode.id.includes("phTextNode")) imgNode.appendChild(dummyDom);
        else imgNode.parentElement.appendChild(dummyDom);
        let w = window.getComputedStyle(dummyDom).width;
        let h = window.getComputedStyle(dummyDom).height;

        if (w != "" && h != "" && w != "0px" && h != "0px") {
            imgNode.parentElement.style.setProperty("--logoSizeWidth", w);
            imgNode.parentElement.style.setProperty("--logoSizeHeight", h);
            imgNode.parentElement.setAttribute("data-largewidth", parseFloat(w));
            imgNode.parentElement.setAttribute("data-largeheight", parseFloat(h));
            let mainParent = imgNode.parentElement.parentElement.parentElement;
            if (imgNode.id.includes("phTextNode")) mainParent = imgNode.parentElement.parentElement;
            let lgWidth = window.getComputedStyle(dummyDom).getPropertyValue("--logoSizeWidth");
            if (lgWidth?.trim() == "100%") {
                mainParent.style.width = "100%";
                w = window.getComputedStyle(mainParent).width;
            }
            mainParent.setAttribute("data-largewidth", parseFloat(w));
            mainParent.setAttribute("data-largeheight", parseFloat(h));

            let placeholderimagesize = "medium";
            if (imgNode.parentElement.hasAttribute("data-placeholderimagesize")) placeholderimagesize = imgNode.parentElement.getAttribute("data-placeholderimagesize");
            else if (mainParent.hasAttribute("data-placeholderimagesize")) placeholderimagesize = mainParent.getAttribute("data-placeholderimagesize");
            else {
                let props = this.getPropertyData();
                let property = props && props.placeholderimage ? props.placeholderimage : null;
                placeholderimagesize = property && property.placeholderimagesize ? property.placeholderimagesize : placeholderimagesize;
            }
            // let logoImageSizeValue = placeholderimagesize == "small" ? 0.4 : placeholderimagesize == "medium" ? 0.7 : placeholderimagesize == "large" ? 1 : parseFloat(placeholderimagesize);
            let logoImageSizeValue = this.specialGraphicsUtils.getImageSizeSML(placeholderimagesize);
            w = parseFloat(w) * parseFloat(logoImageSizeValue);
            h = parseFloat(h) * parseFloat(logoImageSizeValue);

            if (imgNode.id.includes("phTextNode")) imgNode.removeChild(dummyDom);
            else imgNode.parentElement.removeChild(dummyDom);

            imgNode.parentElement.parentElement.style.width = w + "px";
            imgNode.parentElement.parentElement.style.height = h + "px";
            mainParent.style.width = w + "px";
            mainParent.style.height = h + "px";
            if (mainParent.id.includes("placeHolderParent")) mainParent.style.minHeight = h + "px";
            imgNode.parentElement.style.width = w + "px";
            imgNode.parentElement.style.height = h + "px";
            imgNode.setAttribute("data-width", w);
            imgNode.setAttribute("data-height", h);
            if (imgNode && imgNode.hasAttribute("data-csstext") && imgNode.getAttribute("data-csstext") != "") {
                var imageDimensionRatio = imgNode.width / imgNode.height;
                var canvasDimensionRatio = w / h;
                if (imageDimensionRatio > canvasDimensionRatio) {
                    imgNode.parentElement.style.height = imgNode.height + "px";
                    imgNode.parentElement.parentElement.style.height = imgNode.height + "px";
                    imgNode.style.setProperty("bottom", 0);
                    imgNode.setAttribute("logosizecropheight", imgNode.height);
                }
            } else if (!imgNode.id.includes("phTextNode")) this.specialGraphicsUtils.updateImageReSize(w, h, imgNode);
            if (imgNode.callback) imgNode.callback();
            imgNode.callback = null;
        }
    }
};
GenericCoverpage.prototype.applyTextFormats = function (props, arrHeaders, arrContents, isDirectNode = false) {
    for (let c = 0; c < 2; c++) {
        //Bold,italic,underline,and caps properties
        if (c == 0 && props.headingformat) {
            let format = props.headingformat;
            for (let d = 0; d < arrHeaders.length; d++) {
                let headersId = isDirectNode ? arrHeaders[d].id : arrHeaders[d];
                let headersNode = isDirectNode ? arrHeaders[d] : this.sgParent.querySelector("[id='" + headersId + "']");
                if (format && format.bold && format.bold == "true" && headersNode) headersNode.style.fontWeight = "bold";
                if (format && format.italic && format.italic == "true" && headersNode) headersNode.style.fontStyle = "italic";
                if (format && format.underline && format.underline == "true" && headersNode) headersNode.style.textDecoration = "underline";
                if (format && format.case && format.case != "" && headersNode) {
                    let val = format.case == "capseachword" ? "capitalize" : format.case;
                    if (val == "setencecase") {
                        let newString = "";
                        for (let e = 0; e < headersNode.innerHTML.length; e++) {
                            try {
                                if (e == 0) newString = newString + headersNode.innerHTML[e].toUpperCase();
                                else newString = newString + headersNode.innerHTML[e].toLowerCase();
                            } catch (error) {
                                console.log("Sg - Error on text format case change - " + error);
                            }
                        }
                        headersNode.innerHTML = newString;
                    } else if (val == "togglecase") {
                        let newString = "";
                        for (let e = 0; e < headersNode.innerHTML.length; e++) {
                            try {
                                if (e == 0) newString = newString + headersNode.innerHTML[e].toLowerCase();
                                else newString = newString + headersNode.innerHTML[e].toUpperCase();
                            } catch (error) {
                                console.log("Sg - Error on text format case change - " + error);
                            }
                        }
                        headersNode.innerHTML = newString;
                    } else headersNode.style.textTransform = val;
                }
            }
        }
        if (c == 1 && props.contentformat) {
            let format = props.contentformat;
            for (let d = 0; d < arrContents.length; d++) {
                let contentId = isDirectNode ? arrContents[d].id : arrContents[d];
                let contentNode = isDirectNode ? arrContents[d] : this.sgParent.querySelector("[id='" + contentId + "']");
                if (format && format.bold && format.bold == "true" && contentNode) contentNode.style.fontWeight = "bold";
                if (format && format.italic && format.italic == "true" && contentNode) contentNode.style.fontStyle = "italic";
                if (format && format.underline && format.underline == "true" && contentNode) contentNode.style.textDecoration = "underline";
                if (format && format.case && format.case != "" && contentNode) {
                    let val = format.case == "capseachword" ? "capitalize" : format.case;
                    if (val == "setencecase") {
                        let newString = "";
                        for (let e = 0; e < contentNode.innerHTML.length; e++) {
                            try {
                                if (e == 0) newString = newString + contentNode.innerHTML[e].toUpperCase();
                                else newString = newString + contentNode.innerHTML[e].toLowerCase();
                            } catch (error) {
                                console.log("Sg - Error on text format case change - " + error);
                            }
                        }
                        contentNode.innerHTML = newString;
                    } else if (val == "togglecase") {
                        let newString = "";
                        for (let e = 0; e < contentNode.innerHTML.length; e++) {
                            try {
                                if (e == 0) newString = newString + contentNode.innerHTML[e].toLowerCase();
                                else newString = newString + contentNode.innerHTML[e].toUpperCase();
                            } catch (error) {
                                console.log("Sg - Error on text format case change - " + error);
                            }
                        }
                        contentNode.innerHTML = newString;
                    } else contentNode.style.textTransform = val;
                }
            }
        }
    }
};
GenericCoverpage.prototype.placeholderSvgLoadCallback = function (responseData) {
    //Loading svg from menu for icon/image background svg global style - only for "contentBackground"
    for (let a = 0; a < responseData.length; a++) {
        let localSvgParent = responseData[a].parent;
        let colorClass = responseData[a] && responseData[a].color ? responseData[a].color : "clsAccentfill";
        if (localSvgParent) {
            localSvgParent.classList.remove(colorClass);
            localSvgParent.classList.add(colorClass);
            var parser = new DOMParser();
            var doc = parser.parseFromString(responseData[a].data, "image/svg+xml");
            localSvgParent.innerHTML = "";
            localSvgParent.appendChild(doc.lastChild);
        }
    }
};
GenericCoverpage.prototype.textFitOnImageResize = function () {
    this.rePositionTextAndElement();
    this.checkShapeDependency();
};

GenericCoverpage.prototype.reApplyContrast = function () {
    if (!this.assetParent) this.assetParent = this.createAssetParent(0, this.sgParent);
    if ((this.oldContent || this.isWidget == true || this.isPresent == true) && this.assetParent) {
        //Re-applying image contrast
        let fullContrastElements = this.assetParent ? this.assetParent.querySelectorAll("[contrast='fullbg']") : [];
        for (let a = 0; a < fullContrastElements.length; a++) {
            let id = fullContrastElements[a].id;
            let parentNode = id.includes("coverimage") ? fullContrastElements[a].parentElement.parentElement : fullContrastElements[a];
            parentNode = id.includes("sgpresetImageNode") || id.includes("pointImageNode") ? fullContrastElements[a].parentElement : parentNode;
            let isVisible = parentNode.style.display != "none";
            if (isVisible) {
                fullContrastElements[a].setAttribute("data-overlaychange", "false");
                this.eventManager.dispatch("applyImageContrast", fullContrastElements[a], this.assetParent);
            }
        }
        let halfContrastElements = this.assetParent ? this.assetParent.querySelectorAll("[contrast='halfbg']") : [];
        for (let b = 0; b < halfContrastElements.length; b++) {
            let id = halfContrastElements[b].id;
            let parentNode = id.includes("coverimage") ? halfContrastElements[b].parentElement.parentElement : halfContrastElements[b];
            parentNode = id.includes("sgpresetImageNode") || id.includes("pointImageNode") ? halfContrastElements[b].parentElement : parentNode;
            let isVisible = parentNode.style.display != "none";
            if (isVisible) {
                halfContrastElements[b].setAttribute("data-overlaychange", "false");
                this.eventManager.dispatch("applyImageContrast", halfContrastElements[b], this.assetParent, true);
            }
        }
    }
};

GenericCoverpage.prototype.commonHeightFit = function (textNode) {
    if (textNode) {
        let parentNode = textNode.parentElement;
        let primaryLineHeight = parseFloat(window.getComputedStyle(textNode)["line-height"]);
        textNode.style.minHeight = Math.ceil(primaryLineHeight) + 2 + "px";

        let lineHeight = primaryLineHeight;

        let parentNodeHeight = parseFloat(parentNode.style.height);
        if (parentNode.style.height == "auto") parentNodeHeight = parseFloat(parentNode.style.maxHeight);

        if (parentNode.style.maxHeight.includes("%")) {
            let parentH = parentNode.parentElement.style.height;
            if (parentH == "auto") parentH = parentNode.parentElement.style.maxHeight;
            if (parentH) {
                let parentStyle = window.getComputedStyle(parentNode.parentElement);
                parentH = parentStyle.height;
                parentNodeHeight = parseFloat(parentH) * (parseFloat(parentNodeHeight) / 100);
            }
        }

        if (parentNode.hasAttribute("parentFullHeight")) parentNodeHeight = parseFloat(parentNode.getAttribute("parentFullHeight"));

        let parentStyle = textNode ? window.getComputedStyle(parentNode.parentElement) : null;
        let parentMargin = parentStyle ? parseFloat(parentStyle.marginTop) + parseFloat(parentStyle.marginBottom) : 0;
        let parenPadding = parentStyle ? parseFloat(parentStyle.paddingTop) + parseFloat(parentStyle.paddingBottom) : 0;

        parentNodeHeight = parentNodeHeight - parentMargin - parenPadding;

        textNode.style.removeProperty("max-height");

        let primaryHeight = textNode.style.maxHeight != "" && textNode.style.display != "none" ? parseFloat(textNode.style.maxHeight) : parseFloat(window.getComputedStyle(textNode).height);

        let totalTextHeight = primaryHeight;

        if (totalTextHeight > parentNodeHeight) {
            let remainingHeight = parentNodeHeight - totalTextHeight;

            let linesFinal = parseInt(remainingHeight / lineHeight);
            if (remainingHeight < 0 && linesFinal == 0) linesFinal = parseInt(totalTextHeight / lineHeight);
            if (linesFinal < 0) {
                let totalLines = parseInt(totalTextHeight / lineHeight);
                linesFinal = totalLines + linesFinal;
            }
            let heightFinal = linesFinal * lineHeight;
            heightFinal = heightFinal == 0 ? lineHeight : heightFinal;

            textNode.style.maxHeight = heightFinal + "px";

            let minH = parseFloat(textNode.style.minHeight);
            if (!isNaN(minH) && minH > heightFinal) textNode.style.maxHeight = heightFinal + "px";
        } else textNode.style.maxHeight = window.getComputedStyle(textNode).height;
    }
};
GenericCoverpage.prototype.contactNodesHeightFit = function (textNode) {
    if (textNode) {
        let parentNode = this.sgParent.querySelector("[id='contactParent']");
        parentNode = textNode.parentElement.parentElement;
        let primaryNode = textNode.parentElement.querySelector("[id*='promptText']");
        if (!primaryNode) primaryNode = textNode.parentElement.querySelector("[id*='socialIconTextTitle']");
        let iconNode = textNode.parentElement.parentElement.querySelector("[id*='IconParent']");
        if (!iconNode) iconNode = textNode.parentElement.parentElement.querySelector("[id*='iconParent']");
        let secondaryNode = textNode.parentElement.querySelector("[id*='sgmailingAddress']");
        if (!secondaryNode) secondaryNode = textNode.parentElement.querySelector("[id*='sgemailAddress']");
        if (!secondaryNode) secondaryNode = textNode.parentElement.querySelector("[id*='sgphoneNumber']");
        if (!secondaryNode) secondaryNode = textNode.parentElement.querySelector("[id*='sgwebsite']");
        if (!secondaryNode) secondaryNode = textNode.parentElement.querySelector("[id*='socialIconTextSubTitle']");

        if (primaryNode && secondaryNode && parentNode) {
            textNode.style.removeProperty("max-height");

            let primaryLineHeight = parseFloat(window.getComputedStyle(primaryNode)["line-height"]);
            primaryNode.style.minHeight = Math.ceil(primaryLineHeight) + "px";

            let secondaryLineHeight = parseFloat(window.getComputedStyle(secondaryNode)["line-height"]);
            secondaryNode.style.minHeight = Math.ceil(secondaryLineHeight) + "px";

            let parentNodeHeight = parseFloat(parentNode.style.height);
            parentNodeHeight = parentNode.offsetHeight;
            // if (parentNode.style.height == "auto") parentNodeHeight = parseFloat(parentNode.style.maxHeight);
            // let hh = parentNode.style.height;
            // if (parentNode.style.maxHeight.includes("%") || window.getComputedStyle(parentNode).maxHeight.includes("%")) {
            //     parentNode.style.height = parentNode.style.maxHeight.includes("%") ? parentNode.style.maxHeight : window.getComputedStyle(parentNode).maxHeight;
            //     let parentH = parentNode.parentElement.style.height;
            //     if (parentH == "auto") parentH = parentNode.parentElement.style.maxHeight;
            //     if (parentH) {
            //         let parentStyle = window.getComputedStyle(parentNode.parentElement);
            //         parentH = parentStyle.height;
            //         parentNodeHeight = parseFloat(parentH) * (parseFloat(parentNodeHeight) / 100);
            //     }
            // }
            // if (parentNode.style.height.includes("%") || window.getComputedStyle(parentNode).height.includes("%")) {
            //     let parentH = parentNode.style.height.includes("%") ? parentNode.parentElement.style.height : window.getComputedStyle(parentNode).height;
            //     if (parentH == "auto") parentH = parentNode.parentElement.style.maxHeight;
            //     if (parentH) {
            //         let parentStyle = window.getComputedStyle(parentNode.parentElement);
            //         parentH = parentStyle.height;
            //         parentNodeHeight = parseFloat(parentH) * (parseFloat(parentNodeHeight) / 100);
            //     }
            // }
            // if (parentNode.style.height == "" && parentNode.style.maxHeight == "") parentNodeHeight = parseFloat(window.getComputedStyle(parentNode).height);
            // if (parentNode.hasAttribute("parentFullHeight")) parentNodeHeight = parseFloat(parentNode.getAttribute("parentFullHeight"));

            let seconadryStyle = secondaryNode ? window.getComputedStyle(secondaryNode) : null;
            let secondaryMargin = seconadryStyle ? parseFloat(seconadryStyle.marginTop) + parseFloat(seconadryStyle.marginBottom) : 0;

            let iconStyle = iconNode ? window.getComputedStyle(iconNode) : null;
            let iconMargin = iconStyle ? parseFloat(iconStyle.marginTop) + parseFloat(iconStyle.marginBottom) : 0;
            let iconHeight = iconNode.style.maxHeight != "" && iconNode.style.display != "none" ? parseFloat(iconNode.style.maxHeight) : parseFloat(window.getComputedStyle(iconNode).height);
            let parentClassList = textNode.parentElement.parentElement.classList;
            if (
                (!parentClassList.contains("contact_type2") && !parentClassList.contains("contact_type2right") && !parentClassList.contains("contact_type2center")) ||
                (!parentClassList.contains("ctasocial_type2") && !parentClassList.contains("ctasocial_type2right") && !parentClassList.contains("ctasocial_type2center"))
            ) {
                iconMargin = 0;
                iconHeight = 0;
            }

            let parentStyle = secondaryNode ? window.getComputedStyle(parentNode) : null;
            let parentMargin = parentStyle ? parseFloat(parentStyle.marginTop) + parseFloat(parentStyle.marginBottom) : 0;
            let parenPadding = parentStyle ? parseFloat(parentStyle.paddingTop) + parseFloat(parentStyle.paddingBottom) : 0;

            parentNodeHeight = parentNodeHeight - secondaryMargin - parentMargin - parenPadding;

            // textNode.style.maxHeight = "95%";

            let oldParentH = textNode.parentElement.style.height;
            if (oldParentH == "") {
                let parentMaxH = window.getComputedStyle(textNode.parentElement).maxHeight;
                textNode.parentElement.style.height = parentMaxH;
            }
            let primaryHeight = !primaryNode ? 0 : primaryNode.style.maxHeight != "" && primaryNode.style.display != "none" ? parseFloat(primaryNode.style.maxHeight) : parseFloat(window.getComputedStyle(primaryNode).height);
            let secondaryHeight = secondaryNode.style.maxHeight != "" && secondaryNode.style.display != "none" ? parseFloat(secondaryNode.style.maxHeight) : parseFloat(window.getComputedStyle(secondaryNode).height);

            textNode.parentElement.style.height = oldParentH;
            // parentNode.style.height = hh;

            let totalTextHeight = primaryHeight + secondaryHeight + iconHeight + iconMargin;

            if (totalTextHeight >= parentNodeHeight || Math.round(totalTextHeight) >= Math.round(parentNodeHeight) || Math.round(totalTextHeight) + 5 >= Math.round(parentNodeHeight)) {
                let targetNodeHeight = textNode.id.includes("promptText") ? parseFloat(secondaryHeight == "auto" ? 0 : secondaryHeight) : parseFloat(primaryHeight == "auto" ? 0 : primaryHeight);
                let remainingHeight = parentNodeHeight - (targetNodeHeight + iconHeight + iconMargin);

                let lineHeight = parseFloat(window.getComputedStyle(textNode)["line-height"]);
                let linesFinal = parseInt(remainingHeight / lineHeight);
                if (remainingHeight < 0 && linesFinal == 0) linesFinal = parseInt(targetNodeHeight / lineHeight);
                if (linesFinal < 0) {
                    let totalLines = parseInt(targetNodeHeight / lineHeight);
                    linesFinal = totalLines + linesFinal;
                }
                let heightFinal = linesFinal * lineHeight;
                heightFinal = heightFinal == 0 ? lineHeight : heightFinal;

                textNode.style.maxHeight = heightFinal + "px";

                let minH = parseFloat(textNode.style.minHeight);
                if (!isNaN(minH) && minH > heightFinal) textNode.style.maxHeight = heightFinal + "px";
            } else textNode.style.maxHeight = window.getComputedStyle(textNode).height;
        }
    }
};
GenericCoverpage.prototype.socialHeightFit = function (textNode) {
    if (textNode) {
        setTimeout(() => {
            let ctaSocialParent = this.sgParent.querySelector("[id='ctaSocialParent']");
            let parentNode = textNode.parentElement.parentElement;
            let primaryNode = textNode.parentElement.querySelector("[id*='ctaSocialNodeHeadingText']");
            let iconNode = parentNode.querySelector("[id*='sgIconParent']");
            let secondaryNode = textNode.parentElement.querySelector("[id*='ctaSocialNodeContentText']");

            if (primaryNode && secondaryNode && parentNode && ctaSocialParent) {
                textNode.style.removeProperty("max-height");

                let primaryLineHeight = parseFloat(window.getComputedStyle(primaryNode)["line-height"]);
                primaryNode.style.minHeight = Math.ceil(primaryLineHeight) + "px";

                let secondaryLineHeight = parseFloat(window.getComputedStyle(secondaryNode)["line-height"]);
                secondaryNode.style.minHeight = Math.ceil(secondaryLineHeight) + "px";

                let oldPH = ctaSocialParent.style.height;
                if (oldPH == "" || oldPH == "auto") ctaSocialParent.style.height = ctaSocialParent.style.maxHeight;

                let oldH = parentNode.style.minHeight;
                parentNode.style.minHeight = window.getComputedStyle(parentNode).maxHeight;
                let parentNodeHeight = parentNode.offsetHeight;
                parentNode.style.minHeight = oldH;

                ctaSocialParent.style.height = oldPH;

                let seconadryStyle = secondaryNode ? window.getComputedStyle(secondaryNode) : null;
                let secondaryMargin = seconadryStyle ? parseFloat(seconadryStyle.marginTop) + parseFloat(seconadryStyle.marginBottom) : 0;

                let iconStyle = iconNode ? window.getComputedStyle(iconNode) : null;
                let iconMargin = iconStyle ? parseFloat(iconStyle.marginTop) + parseFloat(iconStyle.marginBottom) : 0;
                let iconHeight = iconNode.style.maxHeight != "" && iconNode.style.display != "none" ? parseFloat(iconNode.style.maxHeight) : parseFloat(window.getComputedStyle(iconNode).height);
                let parentClassList = textNode.parentElement.parentElement.classList;
                if (iconStyle.display == "none" || iconNode.style.display == "none" || (!parentClassList.contains("ctasocial_type2") && !parentClassList.contains("ctasocial_type2right") && !parentClassList.contains("ctasocial_type2center"))) {
                    iconMargin = 0;
                    iconHeight = 0;
                }

                let parentStyle = secondaryNode ? window.getComputedStyle(parentNode) : null;
                let parentMargin = parentStyle ? parseFloat(parentStyle.marginTop) + parseFloat(parentStyle.marginBottom) : 0;
                let parenPadding = parentStyle ? parseFloat(parentStyle.paddingTop) + parseFloat(parentStyle.paddingBottom) : 0;

                parentNodeHeight = parentNodeHeight - secondaryMargin - parentMargin - parenPadding;

                let oldParentH = textNode.parentElement.style.height;
                if (oldParentH == "") {
                    let parentMaxH = window.getComputedStyle(textNode.parentElement).maxHeight;
                    textNode.parentElement.style.height = parentMaxH;
                }
                let primaryStyle = window.getComputedStyle(primaryNode);
                let secondaryStyle = window.getComputedStyle(secondaryNode);
                let primaryHeight = !primaryNode ? 0 : primaryNode.style.maxHeight != "" && primaryNode.style.display != "none" ? parseFloat(primaryNode.style.maxHeight) : parseFloat(primaryStyle.height);
                let secondaryHeight = secondaryNode.style.maxHeight != "" && secondaryNode.style.display != "none" ? parseFloat(secondaryNode.style.maxHeight) : parseFloat(secondaryStyle.height);

                if (primaryNode.style.display == "none" || primaryStyle.display == "none") primaryHeight = 0;
                if (secondaryNode.style.display == "none" || secondaryStyle.display == "none") secondaryHeight = 0;

                textNode.parentElement.style.height = oldParentH;
                // parentNode.style.height = hh;

                let totalTextHeight = primaryHeight + secondaryHeight + iconHeight + iconMargin;

                if (totalTextHeight >= parentNodeHeight || Math.round(totalTextHeight) >= Math.round(parentNodeHeight) || Math.round(totalTextHeight) + 5 >= Math.round(parentNodeHeight)) {
                    let targetNodeHeight = textNode.id.includes("promptText") ? parseFloat(secondaryHeight == "auto" ? 0 : secondaryHeight) : parseFloat(primaryHeight == "auto" ? 0 : primaryHeight);
                    let remainingHeight = parentNodeHeight - (targetNodeHeight + iconHeight + iconMargin);

                    let lineHeight = parseFloat(window.getComputedStyle(textNode)["line-height"]);
                    let linesFinal = parseInt(remainingHeight / lineHeight);
                    if (remainingHeight < 0 && linesFinal == 0) linesFinal = parseInt(targetNodeHeight / lineHeight);
                    if (linesFinal < 0) {
                        let totalLines = parseInt(targetNodeHeight / lineHeight);
                        linesFinal = totalLines + linesFinal;
                    }
                    let heightFinal = linesFinal * lineHeight;
                    heightFinal = heightFinal == 0 ? lineHeight : heightFinal;

                    textNode.style.maxHeight = heightFinal + "px";

                    let minH = parseFloat(textNode.style.minHeight);
                    if (!isNaN(minH) && minH > heightFinal) textNode.style.maxHeight = heightFinal + "px";
                } else textNode.style.maxHeight = window.getComputedStyle(textNode).height;
            }
        }, 0);
    }
};
GenericCoverpage.prototype.applyImageBleedCommon = function (prnt, tagName = null) {
    // Check and apply Flip & bleed options
    this.specialGraphicsUtils.checkAndApplyFlipBleed(this.assetParent, this.sgParent, this.metaData, this.getPropertyData(), tagName);
};

GenericCoverpage.prototype.updateImageContrastOnChange = function (imageNode) {
    let imageId = imageNode.id ? imageNode.id.toLocaleLowerCase() : elementId;
    let imagePropname = imageId.includes("presetimage") ? "presetimage" : imageId.includes("sgauthorimagenode") ? "authimg" : imageId.includes("coverimage") ? "image" : null;
    let props = this.getPropertyData();
    if (imagePropname && props?.[imagePropname]) {
        if (props[imagePropname].contrast && props[imagePropname].contrast == "fullbg") this.eventManager.dispatch("applyImageContrast", imageNode, this.assetParent);
        if (props[imagePropname].contrast && props[imagePropname].contrast == "halfbg") this.eventManager.dispatch("applyImageContrast", imageNode, this.assetParent, true);
    }
};

GenericCoverpage.prototype.checkShapeDependency = function () {
    if (this.sgParent.hasAttribute("depends") && this.sgParent.getAttribute("depends") == "content") {
        let assetParent = this.sgParent.querySelector("[id='assetParent0']");
        if (assetParent && assetParent.querySelector("[id='shape1']") && assetParent.querySelector("[id='shape1']").hasAttribute("depends")) {
            let shape = assetParent.querySelector("[id='shape1']");
            let parent = shape.parentElement;
            shape.style.height = "auto";
            shape.style.width = "auto";
            let oldH = parent.style.height;
            parent.style.height = "auto";
            parent.style.maxHeight = "100%";
            let maxWidth = 0;
            for (let b = 0; b < parent.children.length; b++) {
                if (parent.children[b].offsetWidth > maxWidth) maxWidth = parent.children[b].offsetWidth;
            }
            let elementPadding = this.specialGraphicsUtils.getPadding(parent);
            shape.style.height = parent.offsetHeight + "px";
            shape.style.width = maxWidth + parseFloat(elementPadding.paddingLeft) + parseFloat(elementPadding.paddingRight) + "px";
            parent.style.height = oldH;

            let tp = this.specialGraphicsUtils.getOldPositionClass(parent);
            if (tp) {
                shape.style.top = tp == "TL" || tp == "TR" || tp == "TM" ? "0px" : "unset";
                shape.style.bottom = tp == "BL" || tp == "BM" || tp == "BR" ? "0px" : "unset";
                shape.style.left = tp == "BL" || tp == "TL" || tp == "ML" ? "0px" : "unset";
                shape.style.right = tp == "BR" || tp == "TR" || tp == "MR" ? "0px" : "unset";
            } else {
                shape.style.top = "0px";
                shape.style.bottom = "unset";
                shape.style.left = "0px";
                shape.style.right = "unset";
            }
        }
    }
};

GenericCoverpage.prototype.checkDesignChangeElements = function () {
    if (!this.oldContent && this.metaData && this.metaData && this.metaData.designchange && this.metaData.supportedNodes2 && this.metaData.properties2 && !this.updatingDesign) {
        let designChange = this.metaData.designchange.split("-");
        let designChangeElement = designChange[0];
        let designChangeUsing = designChange[1];
        if (designChangeElement && designChangeUsing) {
            let finalHideData = this.sgParent.parentElement.parentElement.getAttribute("data-ogdata-finalhide")?.split(",") || [];

            let isDC = false;
            let isCurrentlyDisable = finalHideData.includes(designChangeElement);

            if (designChangeElement == "presenterimage") isCurrentlyDisable = finalHideData.includes("creatorimage");
            if (designChangeElement == "presentertext") isCurrentlyDisable = finalHideData.includes("creatorname") && finalHideData.includes("creatordesignation");
            if (designChangeElement == "customertext") isCurrentlyDisable = finalHideData.includes("customername") && finalHideData.includes("customerdesignation");
            if (designChangeElement == "pre") isCurrentlyDisable = finalHideData.includes("creatorname") && finalHideData.includes("creatordesignation") && finalHideData.includes("creatorimage");
            if (designChangeElement == "cus") isCurrentlyDisable = finalHideData.includes("customername") && finalHideData.includes("customerdesignation") && finalHideData.includes("customerimage");
            if (designChangeElement == "logo") isCurrentlyDisable = finalHideData.includes("logoimage");
            if (designChangeElement == "yr") isCurrentlyDisable = finalHideData.includes("covernumber");
            if (designChangeElement == "num" || designChangeElement == "sectionnum") isCurrentlyDisable = finalHideData.includes("numbertext");
            if (designChangeElement == "img") isCurrentlyDisable = finalHideData.includes("coverimage");
            if (designChangeElement == "tit") isCurrentlyDisable = finalHideData.includes("title") && finalHideData.includes("subtitle") && finalHideData.includes("titlelabel");
            if (designChangeElement == "reference") isCurrentlyDisable = finalHideData.includes("reference1") && finalHideData.includes("reference2") && finalHideData.includes("reference3") && finalHideData.includes("reference4");
            if (designChangeElement == "contact") isCurrentlyDisable = finalHideData.includes("venue") && finalHideData.includes("phone") && finalHideData.includes("creatoremail");
            if (designChangeElement == "authimg") isCurrentlyDisable = finalHideData.includes("authorimage");
            if (designChangeElement == "authtxt") isCurrentlyDisable = finalHideData.includes("authorname") && finalHideData.includes("authordesignation");
            if (designChangeElement == "footer") isCurrentlyDisable = finalHideData.includes("sgfooter");
            if (designChangeElement == "social" || designChangeElement == "ctasocial") isCurrentlyDisable = finalHideData.includes("customsociallink1") && finalHideData.includes("customsociallink2") && finalHideData.includes("customsociallink3") && finalHideData.includes("customsociallink4");

            if (designChangeUsing == "enable" && !isCurrentlyDisable) isDC = true;
            if (designChangeUsing == "disable" && isCurrentlyDisable) isDC = true;
            if (isDC) {
                // console.log("Design Change Element Found");
                this.designChange = true;
            }
        }
    }
};

"use strict";

function GenericSpecialgraphics(sgParent, sgData, moodName, metadata, styleName = "", isPlayAnimation = true, textElementData, socialiconsData, fontData, objDataToSG) {
    this.specialGraphicsUtils = new window["SpecialGraphicsUtils"]();
    this.specialGraphicsAnimationUtils = new window["SpecialGraphicsAnimationUtils"]();

    let styleData = {};

    let baseSet = {
        title: "h4",
        titleNoSubtitle: "h3",
        subtitle: "p4",
        label: "p3",
        number: "n1",
        introtitle: "h2",
        introtitleNoSubtitle: "h1",
        introsubtitle: "p3",
        introlabel: "p2",
        authorname: "h5",
        authordesigination: "p4",
    };
    baseSet = fontData ? fontData : baseSet;
    styleData.fontData = baseSet;
    this.fontData = JSON.parse(JSON.stringify(baseSet));

    baseSet.titleClass = baseSet.title;
    baseSet.subtitleClass = baseSet.subtitle;
    baseSet.labelClass = baseSet.label;
    baseSet.title = " " + baseSet.title + " ";
    baseSet.subtitle = " " + baseSet.subtitle + " ";
    baseSet.label = " " + baseSet.label + " ";
    baseSet.number = " " + baseSet.number + " ";

    this.sgParent = sgParent;
    this.sgSlideType = this.sgParent.dataset.slidetype;

    //Setting all nodes prompt text here
    styleData.titlePrompt = this.sgSlideType == "textstack" ? "Type a Headline" : "Type an image caption";
    styleData.subTitlePrompt = this.sgSlideType == "textstack" ? "A brief explanation about the headline" : "A brief explanation about the image you have used";
    styleData.titleLabelPrompt = "Title label here";
    styleData.authorNamePrompt = "Author Name";
    styleData.authorDesignationPrompt = "Author Desigination";
    styleData.imagecaptionPrompt = "This is image caption text";

    styleData.styleName = styleName;

    this.socialiconsData = socialiconsData;

    this.sgParent.className = "genericspecialgraphics";

    this.isPlayAnimation = isPlayAnimation;
    this.slideContent = objDataToSG && objDataToSG.slide ? objDataToSG.slide : null;
    this.oldContent = objDataToSG && objDataToSG.isLoadedSlide ? objDataToSG.isLoadedSlide : null;

    this.onTextChange = this.onTextChange.bind(this);
    this.changeText = this.changeText.bind(this);
    this.assetError = this.assetError.bind(this);
    this.changeVariation = this.changeVariation.bind(this);
    this.logoLoadCallback = this.logoLoadCallback.bind(this);
    this.assetsLoadComplete = this.assetsLoadComplete.bind(this);
    this.updateHeightForText = this.updateHeightForText.bind(this);
    this.textFitOnImageResize = this.textFitOnImageResize.bind(this);
    this.rePositionTextAndElement = this.rePositionTextAndElement.bind(this);
    this.commonAssetsLoadComplete = this.commonAssetsLoadComplete.bind(this);
    this.updateImageResizeOnTypeChange = this.updateImageResizeOnTypeChange.bind(this);
    this.updateImageContrastOnChange = this.updateImageContrastOnChange.bind(this);

    this.sgSlideType = "imagestack";

    this.isFromLastSlide = metadata ? metadata.isFromLastSlide : false;
    this.currentNodeIndex = this.isFromLastSlide == true ? sgData.length : 1;

    this.setTargetIndex(0, sgParent);
    this.specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL, this);
    this.specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });

    if (this.slideContent) {
        this.slideContent.classList.remove("darkText");
        this.slideContent.classList.remove("lightText");
        this.slideContent.classList.remove("fixedlightText");
        this.slideContent.classList.remove("fixeddarkText");
    }
    let variSelected = sgParent.parentElement.parentElement.hasAttribute("data-variation-selected") ? sgParent.parentElement.parentElement.getAttribute("data-variation-selected") : false;
    let isIntroEnabled = variSelected && variSelected.includes("intro") ? true : false;
    if (sgData.length > 2 || isIntroEnabled) sgParent.parentElement.parentElement.setAttribute("fulloptions", "true");
    else sgParent.parentElement.parentElement.setAttribute("fulloptions", "false");
    this.deviceModel = "";

    this.assetLoadingCount = 0;
    this.arrCommonAssets = [];
    this.assetsLoading = false;

    SGBaseClass.call(this, sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, this.fontData, "imagestack", styleData, objDataToSG);
}

GenericSpecialgraphics.prototype = Object.create(SGBaseClass.prototype);

GenericSpecialgraphics.prototype.setTargetIndex = function (index = 0, sgParent = null) {
    let localParent = sgParent ? sgParent : this.sgParent;
    let animationDIV = localParent && localParent.parentElement && localParent.parentElement.parentElement ? localParent.parentElement.parentElement : null;
    if (animationDIV && animationDIV.id == "animationDIV") animationDIV.setAttribute("data-target-index", index);
};

GenericSpecialgraphics.prototype.initSpecialGraphicsCreation = function (doMainFunctions = true, doCompleteCallback = true) {
    this.sgParent.style.opacity = 0;
    // console.log("SGG - doing initSpecialGraphicsCreation");
    this.specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL, this);
    this.specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
    if (this.isWidget == false || (this.objDataToSG && this.objDataToSG.menuChange)) {
        this.deviceModel = "";
        if (this.decodeMetaData) {
            let decodedMetaData = this.decodeMetaData(this.sgParent);
            let sgalignment = decodedMetaData.sgalignment;
            let sgorientation = decodedMetaData.sgorientation;
            let sgdevicemodel = decodedMetaData.sgdevicemodel;
            if (sgalignment && sgorientation && sgdevicemodel && sgalignment == "top" && sgdevicemodel.includes("phone") && sgorientation == "portrait") sgalignment = "left";
            if (sgalignment && sgorientation && sgdevicemodel) this.deviceModel = sgdevicemodel + sgorientation + sgalignment;
        }
        if (!this.oldContent || !doMainFunctions) {
            for (let c = 0; c < this.sgData.length; c++) {
                let assetParent = this.createAssetParent(c, this.sgParent);
                let imagestackIntro = (this.sgSlideType == "imagestack" || this.sgSlideType == "textstack") && c == 0 && this.sgData.length != 1 ? "introSlide" : "";
                if (imagestackIntro != "") assetParent.classList.add(imagestackIntro);

                //Creating nodes from menu
                let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData ? this.metaData : null;
                if (metaDataBase && metaDataBase[this.deviceModel] && (metaDataBase[this.deviceModel].supportedNodes || metaDataBase[this.deviceModel].introNodes)) metaDataBase = metaDataBase[this.deviceModel];
                if (metaDataBase && (metaDataBase.supportedNodes || metaDataBase.introNodes)) {
                    let supportNode = imagestackIntro != "" && metaDataBase.introNodes ? metaDataBase.introNodes : metaDataBase.supportedNodes;
                    let nodeObj = supportNode;
                    if (nodeObj) {
                        let nodeParent = this.createNodes(nodeObj, assetParent, c);
                        if (nodeObj.subNodes && nodeParent) this.createNestedNodes(nodeObj.subNodes, nodeParent, c);
                    }
                }

                this.applyImageBleedCommon(assetParent);

                let property = metaDataBase && metaDataBase.properties;
                if (this.deviceModel != "" && metaDataBase[this.deviceModel] && metaDataBase[this.deviceModel].properties) property = metaDataBase[this.deviceModel].properties;
                if (metaDataBase && metaDataBase.introproperties && c == 0) property = metaDataBase.introproperties;

                if (property) {
                    let props = property;
                    if (props && !props.bgshape) props.bgshape = "emptylayoutshape";
                    //Applying bgshape property for slide
                    if (this.objDataToSG?.layoutshapeoutline && props) props.bgshape = this.objDataToSG.layoutshapeoutline;

                    //Creating bgshape
                    if (props?.bgshape && this.slideContent && this.createLayoutShape) this.createLayoutShape("add", props.bgshape, this.slideContent);
                    else if (this.slideContent && this.createLayoutShape) this.createLayoutShape("remove", "", this.slideContent);

                    if (this.layoutShapeAddCallback) {
                        let slideID = this.slideContent && this.slideContent.id ? this.slideContent.id : null;
                        this.layoutShapeAddCallback(slideID);
                    }
                    //Applying textelement style property for slide
                    if (props && props.textelementstyle && this.slideContent) {
                        this.sgParent.parentElement.parentElement.setAttribute("data-textelementstyle", props.textelementstyle);
                        assetParent.setAttribute("data-textelementstyle", props.textelementstyle);
                    } else if (this.sgParent.parentElement && this.sgParent.parentElement.parentElement) {
                        this.sgParent.parentElement.parentElement.removeAttribute("data-textelementstyle");
                        assetParent.removeAttribute("data-textelementstyle");
                    }
                    if (assetParent.hasAttribute("textPosition") && assetParent.querySelector("[id*='textBaseParentNode']")) {
                        let textBaseParent = assetParent.querySelector("[id*='textBaseParentNode']");
                        this.textPositionChangeOperation(textBaseParent.parentElement, assetParent.getAttribute("textPosition"));
                    }
                    this.updateHeightForText(assetParent);
                }

                let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
                let deviceBGColorParent = this.sgParent.querySelector("[id='deviceBGColorParent']");
                let deviceBGColorParentInside = deviceImageParentNode ? deviceImageParentNode.querySelector("[id='deviceBGColorParent']") : null;
                if (!deviceBGColorParentInside && deviceBGColorParent) {
                    deviceBGColorParent.parentElement.removeChild(deviceBGColorParent);
                    deviceImageParentNode.appendChild(deviceBGColorParent);
                }
                if (doMainFunctions) SGBaseClass.prototype.initSpecialGraphicsCreation.call(this);
                this.onTextChangeForAllNodes(this.sgParent, c);
                if (this.specialGraphicsSlideCreationComplete) this.specialGraphicsSlideCreationComplete(c);
            }
        } else {
            this.clearListener(false);
            for (let c = 0; c < this.sgData.length; c++) {
                let assetParent = this.createAssetParent(c, this.sgParent);
                let elements = assetParent ? assetParent.querySelectorAll("[listener='true']") : [];
                for (let a = 0; a < elements.length; a++) {
                    this.setTextFocus(elements[a], false, assetParent, true);
                }
                let clickElements = assetParent ? assetParent.querySelectorAll("[clicklistener='true']") : [];
                for (let a = 0; a < clickElements.length; a++) {
                    if (this.imageDoubleClickEvent) this.eventManager.addEvent(clickElements[a], "dblclick", this.imageDoubleClickEvent);
                }
            }
            let introParent = this.sgParent.querySelector("[id='introParent']");
            if (introParent) {
                let elements = introParent.querySelectorAll("[listener='true']");
                for (let a = 0; a < elements.length; a++) {
                    this.setTextFocus(elements[a], false, introParent, true);
                }
            }
            let textParent = this.sgParent.querySelectorAll("[id*='lytAssetTextParent']");
            if (textParent) {
                for (let b = 0; b < textParent.length; b++) {
                    let elements = textParent[b].querySelectorAll("[listener='true']");
                    for (let a = 0; a < elements.length; a++) {
                        this.setTextFocus(elements[a], false, textParent[b], true);
                    }
                }
            }
            let lottieParent = this.sgParent.querySelectorAll("[data-lottie*='/']");
            for (let a = 0; a < lottieParent.length; a++) {
                let arrAssets = [{ type: "json", url: lottieParent[a].getAttribute("data-lottie"), id: "commonbglottie", parent: lottieParent[a] }];
                this.arrCommonAssets.push({ array: arrAssets, callback: this.lottieLoadCallback });
            }
        }
    } else SGBaseClass.prototype.initSpecialGraphicsCreation.call(this);

    //Re-applying image contrast
    this.reApplyContrast();
    if (this.isWidget) this.specialGraphicsUtils.updateImagePositions(this.sgParent);
    if (doCompleteCallback) this.specialGraphicsCreationComplete(true, doMainFunctions);
    // else this.sgParent.style.opacity = 1;
};

GenericSpecialgraphics.prototype.reApplyContrast = function () {
    if (this.oldContent || this.isWidget == true || this.isPresent == true) {
        //Re-applying image contrast
        let allAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
        for (let c = 0; c < allAssetParent.length; c++) {
            let fullContrastElements = allAssetParent[c].querySelectorAll("[contrast='fullbg']");
            for (let a = 0; a < fullContrastElements.length; a++) {
                allAssetParent[c].setAttribute("docontrastapply", "true");
                fullContrastElements[a].setAttribute("data-overlaychange", "false");
                this.eventManager.dispatch("applyImageContrast", fullContrastElements[a], allAssetParent[c]);
            }
            let halfContrastElements = allAssetParent[c].querySelectorAll("[contrast='halfbg']");
            for (let b = 0; b < halfContrastElements.length; b++) {
                allAssetParent[c].setAttribute("docontrastapply", "true");
                halfContrastElements[b].setAttribute("data-overlaychange", "false");
                this.eventManager.dispatch("applyImageContrast", halfContrastElements[b], allAssetParent[c], true);
            }
        }
    }
};

GenericSpecialgraphics.prototype.specialGraphicsSlideCreationComplete = function (index) {
    // SGBaseClass.prototype.specialGraphicsSlideCreationComplete.call(this, index);
};
GenericSpecialgraphics.prototype.applyContrastToText = function (element, property) {
    if (property && property.contrast && (property.contrast == "true" || property.contrast == true) && element) element.setAttribute("data-supportcontrast", "true");
    else if (element) element.removeAttribute("data-supportcontrast");
};
GenericSpecialgraphics.prototype.applyChildStyleToParent = function (parent, child) {
    if (parent && child) {
        let childStyle = window.getComputedStyle(child);
        parent.style.width = child.style.width.includes("%") ? child.style.width : childStyle.width;
        parent.style.height = child.style.height.includes("%") ? child.style.height : childStyle.height;
        parent.style.left = childStyle.left;
        parent.style.top = childStyle.top;
        parent.style.position = childStyle.position;
        let margin = childStyle.margin == "" || childStyle.margin == "0px" ? child.style.margin : childStyle.margin;
        let padding = childStyle.padding == "" || childStyle.padding == "0px" ? child.style.padding : childStyle.padding;
        parent.style.margin = margin;
        parent.style.padding = padding;
        child.style.width = "100%";
        child.style.height = "100%";
        child.style.removeProperty("left");
        child.style.removeProperty("top");
        child.style.setProperty("margin", "unset", "important");
        child.style.setProperty("padding", "unset", "important");
    }
};
GenericSpecialgraphics.prototype.onTextChangeForAllNodes = function (sgParent = null, index = -1) {
    let assetParent = null;
    let indexValue = index != -1 ? index : this.currentNodeIndex - 1;
    if (sgParent) assetParent = sgParent.querySelector("[id='assetParent" + indexValue + "']");
    if (!assetParent) assetParent = this.sgParent.querySelector("[id='assetParent" + indexValue + "']");
    if (sgParent && sgParent.id == "introParent") assetParent = sgParent;

    let textBaseParentNode = assetParent.querySelector("[id*='textBaseParentNode']");
    if (!textBaseParentNode && this.sgParent.querySelector("[id='lytAssetTextParent" + indexValue + "']")) {
        assetParent = this.sgParent.querySelector("[id='lytAssetTextParent" + indexValue + "']");
        textBaseParentNode = assetParent ? assetParent.querySelector("[id*='textBaseParentNode']") : null;
    }
    if (this.sgParent.querySelector("[id='textFallNode" + indexValue + "']")) {
        assetParent = this.sgParent.querySelector("[id='textFallNode" + indexValue + "']");
        textBaseParentNode = assetParent ? assetParent.querySelector("[id*='textBaseParentNode']") : null;
    }

    let oldDisplay = assetParent?.style?.display == "none" ? "none" : "";
    if (oldDisplay == "none") assetParent.style.display = "flex";

    if (!textBaseParentNode) textBaseParentNode = assetParent;
    if (textBaseParentNode) {
        textBaseParentNode.style.overflow = "hidden";
        let titleNode = textBaseParentNode.querySelector("[id*='sgTitleNode']");
        let subTitleNode = textBaseParentNode.querySelector("[id*='sgSubTitleNode']");
        let sgTitleLabelNode = textBaseParentNode.querySelector("[id*='sgTitleLabelNode']");

        if (sgTitleLabelNode) {
            if (this.removeHighlightFocus) this.removeHighlightFocus(assetParent, sgTitleLabelNode);
            let elementPadding = this.specialGraphicsUtils.getPadding(sgTitleLabelNode);
            let labelStyle = window.getComputedStyle(sgTitleLabelNode);
            sgTitleLabelNode.style.maxHeight = parseFloat(labelStyle.lineHeight) + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
            sgTitleLabelNode.style.minHeight = sgTitleLabelNode.style.maxHeight;
            sgTitleLabelNode.parentElement.style.maxHeight = sgTitleLabelNode.style.maxHeight;
            sgTitleLabelNode.parentElement.style.minHeight = sgTitleLabelNode.style.maxHeight;
        }
        if (subTitleNode) {
            if (this.removeHighlightFocus) this.removeHighlightFocus(assetParent, subTitleNode);
            let supportParent = subTitleNode.hasAttribute("data-support") ? true : false;
            subTitleNode.style.removeProperty("max-height");
            subTitleNode.style.removeProperty("height");
            subTitleNode.style.setProperty("max-height", "unset", "important");
            if (supportParent != true) subTitleNode.parentElement.style.removeProperty("max-height");
            if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(subTitleNode);
            this.onTextChangeUpdate(subTitleNode, true, assetParent, indexValue);
            this.doCheckTextLineHeightDiff(subTitleNode);
        }
        if (titleNode) {
            if (this.removeHighlightFocus) this.removeHighlightFocus(assetParent, titleNode);
            titleNode.style.removeProperty("max-height");
            titleNode.style.removeProperty("height");
            titleNode.parentElement.style.removeProperty("max-height");
            if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(titleNode);
            this.onTextChangeUpdate(titleNode, true, assetParent, indexValue);
            this.doCheckTextLineHeightDiff(titleNode);
        }
        textBaseParentNode.style.removeProperty("overflow");
    }
    if (oldDisplay) assetParent.style.display = oldDisplay;
};

GenericSpecialgraphics.prototype.onTextChange = function (element) {
    let textNode = element;
    this.onTextChangeUpdate(textNode);
};

GenericSpecialgraphics.prototype.onTextChangeUpdate = function (textNode, isStart = false, assetParentNode = null, currentNodeInd = 1) {
    let indexValue = textNode.id.includes("0") ? this.currentNodeIndex - 2 : this.currentNodeIndex - 1;
    let assetParent = assetParentNode ? assetParentNode : this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    if (this.carouselType == "type9" && (indexValue == "0" || indexValue == 0) && this.sgParent.querySelector("[id='introParent']")) assetParent = this.sgParent.querySelector("[id='introParent']");
    if (!assetParent) return;

    if (this.carouselType == "type9") {
        assetParent.style.height = window.getComputedStyle(assetParent).maxHeight;
        let cmp = assetParent.querySelector("[id='contentMainParent']");
        if (cmp) cmp.style.setProperty("height", "100%", "important");
    }

    let textBaseParentNode = assetParent.querySelector("[id*='textBaseParentNode']");
    if (!textBaseParentNode && this.sgParent.querySelector("[id='lytAssetTextParent" + indexValue + "']")) {
        assetParent = this.sgParent.querySelector("[id='lytAssetTextParent" + indexValue + "']");
        textBaseParentNode = assetParent ? assetParent.querySelector("[id*='textBaseParentNode']") : null;
    }
    if (assetParentNode && assetParentNode.id.includes("textFallNode")) {
        assetParent = assetParentNode;
        textBaseParentNode = assetParent ? assetParent.querySelector("[id*='textBaseParentNode']") : null;
    } else if (this.currentNodeIndex - 1 != 0 && this.sgParent.querySelector("[id='textFallNode" + indexValue + "']")) {
        assetParent = this.sgParent.querySelector("[id='textFallNode" + indexValue + "']");
        textBaseParentNode = assetParent ? assetParent.querySelector("[id*='textBaseParentNode']") : null;
    }

    let supportParent = textNode.hasAttribute("data-support") ? true : false;
    let singleNodeHeight = -1;
    let isSingleNode = false;
    if (supportParent == true && !textBaseParentNode && assetParent.querySelector("[id*='sgTitleNode']")) {
        let titleNode = assetParent.querySelector("[id*='sgTitleNode']");
        textBaseParentNode = textNode.parentElement;
        let oldOverflowValue = textBaseParentNode.style.overflow;
        textBaseParentNode.style.overflow = "hidden";
        singleNodeHeight = parseFloat(window.getComputedStyle(textBaseParentNode).height);
        if (textBaseParentNode.style.height == "auto") {
            textBaseParentNode.style.height = textBaseParentNode.style.maxHeight;
            singleNodeHeight = parseFloat(window.getComputedStyle(textBaseParentNode).height);
            textBaseParentNode.style.height = "auto";
        }
        if (textNode.hasAttribute("data-maxheight")) {
            let textNodeMaxHeight = textNode.getAttribute("data-maxheight");
            if (textNodeMaxHeight.includes("%")) {
                let ph = textNode.parentElement.parentElement.offsetHeight;
                let mhFinal = ph * (parseFloat(textNodeMaxHeight) / 100);
                singleNodeHeight = mhFinal;
            } else {
                singleNodeHeight = parseFloat(textNodeMaxHeight);
            }
            textNode.parentElement.style.maxHeight = textNodeMaxHeight;
            // textNode.parentElement.style.height = textNodeMaxHeight;
        }
        textBaseParentNode.style.overflow = oldOverflowValue;
        isSingleNode = true;
    }
    if (!textBaseParentNode) {
        textBaseParentNode = textNode.parentElement.parentElement;
        isSingleNode = true;
    }
    if (textBaseParentNode) {
        if (isSingleNode != true && textNode.id.includes("sgTitleLabelNode")) {
            let labelStyle = window.getComputedStyle(textNode);
            let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
            textNode.style.maxHeight = parseFloat(labelStyle.lineHeight) + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
            textNode.parentElement.style.maxHeight = textNode.style.maxHeight;
        } else {
            let removeMaxHeight = this.carouselType && this.carouselType == "onlytitle" ? false : true;
            if (removeMaxHeight) {
                textNode.style.removeProperty("max-height");
                textNode.style.removeProperty("height");
            }
            if (supportParent != true && isSingleNode != true) textNode.parentElement.style.removeProperty("max-height");

            let titleNode = textBaseParentNode.querySelector("[id*='sgTitleNode']");
            let subTitleNode = textBaseParentNode.querySelector("[id*='sgSubTitleNode']");
            let sgTitleLabelNode = textBaseParentNode.querySelector("[id*='sgTitleLabelNode']");
            let textInnerParentNode = textBaseParentNode.querySelector("[id*='textInnerParentNode']");
            let sgNumberTextNode = textBaseParentNode.querySelector("[id*='sgNumberTextNode']");

            let numberStyle = sgNumberTextNode ? window.getComputedStyle(sgNumberTextNode) : null;
            let numberMargin = numberStyle ? parseFloat(numberStyle.height == "auto" ? 0 : numberStyle.height) + parseFloat(numberStyle.marginTop) + parseFloat(numberStyle.marginBottom) : 0;
            numberMargin = isNaN(numberMargin) ? 0 : numberMargin;

            let textParentStyle = textInnerParentNode ? window.getComputedStyle(textInnerParentNode.parentElement) : null;
            let textParentMargin = textParentStyle ? parseFloat(textParentStyle.marginTop) + parseFloat(textParentStyle.marginBottom) : 0;

            let innerParentStyle = textInnerParentNode ? window.getComputedStyle(textInnerParentNode) : null;
            let innerParentMargin = innerParentStyle ? parseFloat(innerParentStyle.marginTop) + parseFloat(innerParentStyle.marginBottom) : 0;

            let labelParentStyle = sgTitleLabelNode ? window.getComputedStyle(sgTitleLabelNode.parentElement) : null;
            let labelStyle = sgTitleLabelNode ? window.getComputedStyle(sgTitleLabelNode) : null;
            let hasLabel = (sgTitleLabelNode && sgTitleLabelNode.style.display == "none") || !sgTitleLabelNode ? false : true;
            let labelMargin = labelParentStyle ? parseFloat(labelParentStyle.marginTop) + parseFloat(labelParentStyle.marginBottom) : 0;
            labelMargin = hasLabel ? (labelStyle ? parseFloat(labelStyle.marginTop) + parseFloat(labelStyle.marginBottom) : 0) + labelMargin : 0;

            let subTitileParentStyle = subTitleNode ? window.getComputedStyle(subTitleNode.parentElement) : null;
            let subTitileStyle = subTitleNode ? window.getComputedStyle(subTitleNode) : null;
            let hasSubtitle = (subTitleNode && subTitleNode.style.display == "none") || !subTitleNode ? false : true;
            let subTitileMargin = subTitileParentStyle ? parseFloat(subTitileParentStyle.marginTop) + parseFloat(subTitileParentStyle.marginBottom) : 0;
            subTitileMargin = hasSubtitle ? (subTitileStyle ? parseFloat(subTitileStyle.marginTop) + parseFloat(subTitileStyle.marginBottom) : 0) + subTitileMargin : 0;

            let titileParentStyle = titleNode ? window.getComputedStyle(titleNode.parentElement) : null;
            let titileMargin = titileParentStyle ? parseFloat(titileParentStyle.marginTop) + parseFloat(titileParentStyle.marginBottom) : 0;

            let textBaseHeight = parseFloat(singleNodeHeight) > 0 ? parseFloat(singleNodeHeight) : parseFloat(window.getComputedStyle(textBaseParentNode).height);
            if (textBaseParentNode && textBaseParentNode.hasAttribute("fullheight")) textBaseHeight = parseFloat(textBaseParentNode.getAttribute("fullheight"));
            if (window.getComputedStyle(textBaseParentNode).height == "" && textBaseParentNode.style.maxHeight != "" && textBaseParentNode.style.maxHeight.includes("px")) textBaseHeight = parseFloat(textBaseParentNode.style.maxHeight);
            let maxHeight = window.getComputedStyle(textBaseParentNode).maxHeight;
            if (maxHeight != "" && maxHeight != "0px" && !isNaN(parseFloat(maxHeight))) if (maxHeight.includes("px")) textBaseHeight = parseFloat(maxHeight);
            let isCarousel = assetParent && assetParent.id.includes("lytAssetTextParent") ? true : false;
            if (maxHeight != "" && maxHeight != "0px" && !isNaN(parseFloat(maxHeight)) && isCarousel == false) {
                if (maxHeight.includes("px")) textBaseHeight = parseFloat(maxHeight);
                else if (maxHeight.includes("%")) {
                    let oldParentHeight = null;
                    if (textBaseParentNode.parentElement && textBaseParentNode.parentElement.style.height == "auto" && textBaseParentNode.parentElement.hasAttribute("fullheight")) {
                        oldParentHeight = textBaseParentNode.parentElement.style.height;
                        textBaseParentNode.parentElement.style.height = textBaseParentNode.parentElement.getAttribute("fullheight");
                    }
                    let oldBkupH = null;
                    if (textBaseParentNode.parentElement.id == "introParent" && (textBaseParentNode.parentElement.style.height == "" || textBaseParentNode.parentElement.style.height == "auto")) {
                        oldBkupH = textBaseParentNode.parentElement.style.height;
                        textBaseParentNode.parentElement.style.height = window.getComputedStyle(textBaseParentNode.parentElement).maxHeight;
                    }
                    let oldParentH = textBaseParentNode.style.height;
                    textBaseParentNode.style.height = textBaseParentNode.style.maxHeight;
                    let hh = parseFloat(window.getComputedStyle(textBaseParentNode).height);
                    if (hh > 0 && !isNaN(hh)) textBaseHeight = hh;
                    textBaseParentNode.style.height = oldParentH;
                    if (oldParentHeight) textBaseParentNode.parentElement.style.height = oldParentHeight;
                    if (oldBkupH != null) textBaseParentNode.parentElement.style.height = oldBkupH;
                }
            }
            //removing margin/padding things on total base height
            let textParentHeight =
                textBaseHeight - (isNaN(labelMargin) ? 0 : labelMargin) - (isNaN(subTitileMargin) ? 0 : subTitileMargin) - (isNaN(titileMargin) ? 0 : titileMargin) - (isNaN(innerParentMargin) ? 0 : innerParentMargin) - (isNaN(textParentMargin) ? 0 : textParentMargin) - (isNaN(numberMargin) ? 0 : numberMargin);
            let titleHeight = titleNode?.scrollHeight > 0 ? titleNode.scrollHeight : !titleNode || titleNode?.offsetHeight == 0 ? 0 : titleNode.style.maxHeight != "" && titleNode.style.display != "none" ? parseFloat(titleNode.style.maxHeight) : window.getComputedStyle(titleNode).height;
            let subTitleHeight = subTitleNode?.scrollHeight > 0 ? subTitleNode.scrollHeight : !subTitleNode || subTitleNode?.offsetHeight == 0 ? 0 : subTitleNode.style.maxHeight != "" && subTitleNode.style.display != "none" ? parseFloat(subTitleNode.style.maxHeight) : window.getComputedStyle(subTitleNode).height;
            let lableHeight = !sgTitleLabelNode || sgTitleLabelNode?.offsetHeight == 0 ? 0 : sgTitleLabelNode.style.maxHeight != "" && sgTitleLabelNode.style.display != "none" ? parseFloat(sgTitleLabelNode.style.maxHeight) : window.getComputedStyle(sgTitleLabelNode).height;
            //calculating total current text height
            let totalTextHeight = parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight);

            let lineHeight = window.getComputedStyle(textNode).lineHeight;
            let fontsize = window.getComputedStyle(textNode).fontSize;
            lineHeight = isNaN(parseFloat(lineHeight)) ? parseFloat(fontsize) * 1.2 : parseFloat(lineHeight);
            let noLines = Math.max(textNode.parentElement.offsetHeight / lineHeight, 1);
            let offDifference = noLines - parseInt(noLines);
            let lines = offDifference > 0.9 ? parseInt(noLines) + 1 : parseInt(noLines);

            //If text height increase total height we have doing fit logic
            if (typeof totalTextHeight == "string") totalTextHeight = parseFloat(totalTextHeight);
            if (typeof textParentHeight == "string") textParentHeight = parseFloat(textParentHeight);
            totalTextHeight = totalTextHeight.toFixed(1);
            textParentHeight = textParentHeight.toFixed(1);
            if (typeof totalTextHeight == "string") totalTextHeight = parseFloat(totalTextHeight);
            if (typeof textParentHeight == "string") textParentHeight = parseFloat(textParentHeight);
            let commonRemainingHeight = 0;
            if (totalTextHeight > textParentHeight) {
                let targetNodeHeight = textNode.id.includes("sgTitleNode")
                    ? parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : textNode.id.includes("sgSubTitleNode")
                    ? parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight);
                let remainingHeight = textParentHeight - targetNodeHeight;
                if (isSingleNode) remainingHeight = textParentHeight;
                commonRemainingHeight = remainingHeight;
                if (lines == 1) remainingHeight = lineHeight;

                let linesFinal = remainingHeight / lineHeight;
                let offDiff = linesFinal - parseInt(linesFinal);
                linesFinal = offDiff > 0.9 ? parseInt(linesFinal) + 1 : parseInt(linesFinal);
                if (linesFinal < 0) linesFinal = 1;

                let heightFinal = linesFinal * lineHeight;
                heightFinal = heightFinal == 0 ? lineHeight : heightFinal;

                textNode.style.removeProperty("max-height");
                textNode.style.maxHeight = heightFinal + "px";
                if (this.carouselType == "type9" && textNode.id.includes("sgSubTitleNode")) commonRemainingHeight = heightFinal;
                let isTextFall = this.strAssetType == "textfall" ? true : false;
                if (!isTextFall && textNode.id.includes("sgSubTitleNode")) {
                    let mt = textNode.id.includes("sgTitleNode") ? titileMargin : textNode.id.includes("sgSubTitleNode") ? subTitileMargin : labelMargin;
                    textNode.parentElement.style.maxHeight = heightFinal + mt + "px";
                } else if (!textNode.hasAttribute("data-maxheight")) textNode.parentElement.style.removeProperty("max-height");
                // }
            } else {
                let targetNodeHeight = textNode.id.includes("sgTitleNode")
                    ? parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : textNode.id.includes("sgSubTitleNode")
                    ? parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight);
                let remainingHeight = textParentHeight - targetNodeHeight;
                if (isSingleNode) remainingHeight = textParentHeight;

                commonRemainingHeight = remainingHeight;
            }

            textNode.style.removeProperty("min-height");
            DiagramResizeUtils.commonFontResize(totalTextHeight, textParentHeight, commonRemainingHeight, textNode, textNode.parentElement, this.objDataToSG.fontClassLists, true);

            if (isSingleNode == true) textNode.parentElement.style.removeProperty("height");

            this.onTextUpdate(textNode, isSingleNode);
        }
    }
    if (this.carouselType == "type9") assetParent.style.removeProperty("height");
};

GenericSpecialgraphics.prototype.loop = function (lines, lineHeight, textNode, textParentHeight, titleNode, subTitleNode, sgTitleLabelNode) {
    //Loop and fitting the text inside max avaiable height
    lines = lines - 1;
    if (lines == 0) return;
    let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
    let newHeight = lines * lineHeight + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom);
    textNode.style.maxHeight = newHeight + "px";
    // textNode.parentElement.style.maxHeight = newHeight + "px";

    let titleHeight = !titleNode ? 0 : titleNode.style.maxHeight != "" && titleNode.style.display != "none" ? parseFloat(titleNode.style.maxHeight) : window.getComputedStyle(titleNode).height;
    let subTitleHeight = !subTitleNode ? 0 : subTitleNode.style.maxHeight != "" && subTitleNode.style.display != "none" ? parseFloat(subTitleNode.style.maxHeight) : window.getComputedStyle(subTitleNode).height;
    let lableHeight = !sgTitleLabelNode ? 0 : sgTitleLabelNode.style.maxHeight != "" && sgTitleLabelNode.style.display != "none" ? parseFloat(sgTitleLabelNode.style.maxHeight) : window.getComputedStyle(sgTitleLabelNode).height;
    let totalTextHeight = parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight);
    if (textParentHeight < totalTextHeight) this.loop(lines, lineHeight, textNode, textParentHeight, titleNode, subTitleNode, sgTitleLabelNode);
};

GenericSpecialgraphics.prototype.onTextUpdate = function (textNode, isSingleNode = false) {
    if (textNode.parentElement.offsetHeight <= textNode.offsetHeight) {
        let lineHeight = window.getComputedStyle(textNode).lineHeight;
        let fontsize = window.getComputedStyle(textNode).fontSize;
        lineHeight = isNaN(parseFloat(lineHeight)) ? parseFloat(fontsize) * 1.2 : parseFloat(lineHeight);
        let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
        let noLines = Math.max(textNode.parentElement.offsetHeight / lineHeight, 1);
        let offDifference = noLines - parseInt(noLines);
        let lines = offDifference > 0.9 ? parseInt(noLines) + 1 : parseInt(noLines);
        textNode.style.maxHeight = lines * lineHeight + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
        if (lines == 1) textNode.style.minHeight = textNode.style.maxHeight;
        textNode.style.overflow = "hidden";
        if (!isSingleNode) textNode.parentElement.style.removeProperty("max-height");
    }
};

GenericSpecialgraphics.prototype.doCheckTextLineHeightDiff = function (textNode) {
    return;
    if (textNode.id.includes("sgTitleLabelNode")) return;
    this.onTextChangeUpdate(textNode);

    let lineHeight = window.getComputedStyle(textNode).lineHeight;
    let fontsize = window.getComputedStyle(textNode).fontSize;
    lineHeight = isNaN(parseFloat(lineHeight)) ? parseFloat(fontsize) * 1.2 : parseFloat(lineHeight);
    let noLines = Math.max(textNode.parentElement.offsetHeight / lineHeight, 1);
    let offDifference = noLines - parseInt(noLines);
    let lines = offDifference > 0.9 ? parseInt(noLines) + 1 : parseInt(noLines);
    // if (lines > 1) {
    let dummyNode = textNode.cloneNode(true);
    dummyNode.style.lineHeight = "normal";
    dummyNode.style.opacity = "0";
    dummyNode.innerHTML = "sd";
    this.sgParent.appendChild(dummyNode);

    dummyNode.style.minHeight = "unset";
    dummyNode.style.height = "unset";
    dummyNode.style.maxHeight = "unset";
    dummyNode.style.position = "absolute";
    let fullLh = dummyNode.clientHeight;
    this.sgParent.removeChild(dummyNode);
    if (fullLh <= 0) return;

    let diff = fullLh - lineHeight;
    textNode.style.maxHeight = lines * lineHeight + diff / (lines == 1 ? 2 : lines) + "px";
    textNode.style.height = lines * lineHeight + diff / (lines == 1 ? 2 : lines) + "px";
    // console.log("SGG - Lineheight diff - ", diff + " - " + textNode.style.maxHeight);
    // console.log(textNode);

    textNode.style.minHeight = textNode.style.maxHeight;
    let textH = textNode.clientHeight;
    let textparentH = textNode.parentElement.parentElement.parentElement.clientHeight;
    textNode.style.removeProperty("min-height");
    if (textH > textparentH) {
        // console.log("Sg - Exceed height while adding difference line height");
        lines = lines - 1;
        // if (lines == 1) textNode.style.maxHeight = lines * lineHeight + "px";
        // else
        textNode.style.maxHeight = lines * lineHeight + diff / 3 + "px";
    }
    // }
};

GenericSpecialgraphics.prototype.updateHeightForText = function (assetParent) {
    try {
        let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData ? this.metaData : null;
        if (metaDataBase && (metaDataBase.properties || metaDataBase.introproperties)) {
            let propData = assetParent.classList.contains("introSlide") && metaDataBase.introproperties ? metaDataBase.introproperties : metaDataBase.properties;
            let property = propData.text;
            if (property && property.maxheight) {
                let textBaseParentNode = assetParent.querySelector("[id*='textBaseParentNode']");
                let titleLabelTextParent = assetParent.querySelector("[id='titleLabelTextParent']");
                let sgTitleLabelNode = assetParent.querySelector("[id='sgTitleLabelNode']");

                let textParent = textBaseParentNode ? textBaseParentNode.parentElement : null;
                let parentHeight = textParent ? parseFloat(window.getComputedStyle(textParent).height) : 0;
                if (textParent && textParent.hasAttribute("fullheight")) parentHeight = parseFloat(textParent.getAttribute("fullheight"));
                if (!isNaN(parentHeight) && parentHeight > 0) return;
                if (textBaseParentNode) textBaseParentNode.style.display = "none";
                let remainingHeight = 0;
                if (textParent) {
                    let mainParentDisplay = textParent.parentElement.style.display;
                    textParent.parentElement.style.removeProperty("display");
                    let currentHeight = parseFloat(window.getComputedStyle(textParent).height);
                    textParent.parentElement.style.display = mainParentDisplay;

                    remainingHeight = parentHeight - currentHeight;
                }
                let titleTextParent = assetParent.querySelector("[id='titleTextParent']");
                let sgTitleNode = assetParent.querySelector("[id='sgTitleNode']");

                let subTitleTextParent = assetParent.querySelector("[id='subTitleTextParent']");
                let sgSubTitleNode = assetParent.querySelector("[id='sgSubTitleNode']");

                if (titleLabelTextParent) titleLabelTextParent.style.removeProperty("max-height");
                if (sgTitleLabelNode) sgTitleLabelNode.style.removeProperty("max-height");
                if (titleTextParent) titleTextParent.style.removeProperty("max-height");
                if (sgTitleNode) sgTitleNode.style.removeProperty("max-height");
                if (subTitleTextParent) subTitleTextParent.style.removeProperty("max-height");
                if (sgSubTitleNode) sgSubTitleNode.style.removeProperty("max-height");

                if (textBaseParentNode && remainingHeight != 0) {
                    textBaseParentNode.style.maxHeight = remainingHeight + "px";
                    textBaseParentNode.style.removeProperty("display");
                }
            }
        }
    } catch (error) {
        console.log("SG - Error on updateHeightForText - " + error);
    }
};
//Set slide type
GenericSpecialgraphics.prototype.setSlideType = function (type) {
    this.sgSlideType = type;
};

GenericSpecialgraphics.prototype.commonAssetsLoadComplete = function (responseData, objData) {
    if (objData && objData.callback) objData.callback(responseData);
    this.assetLoadingCount = this.assetLoadingCount - 1;
    if (this.assetLoadingCount == 0) {
        // console.log("SG - all assets load complete");
        this.assetsLoading = false;
        this.arrCommonAssets = [];
        if (objData && objData.doMainFunctions) this.specialGraphicsCreationComplete();
    }
};

GenericSpecialgraphics.prototype.specialGraphicsCreationComplete = function (doImagePosition = true, doMainFunctions = true) {
    let isCarousel = (this.introType != undefined && this.introType != null) || this.carouselType == "onlytitle" ? true : false;
    isCarousel = false;
    if (this.arrCommonAssets.length > 0 && this.isPresent != true && isCarousel == false) {
        this.assetsLoading = true;
        this.assetLoadingCount = this.arrCommonAssets.length;
        for (let a = 0; a < this.arrCommonAssets.length; a++) {
            let obj = this.arrCommonAssets[a];
            obj.doMainFunctions = doMainFunctions;
            this.loadAssets(obj.array, this.commonAssetsLoadComplete, this.assetError, obj);
        }
        this.arrCommonAssets = [];
    }
    if (this.assetsLoading == false) {
        if (this.isPreviewMode == false || !this.isPreviewMode) {
            //Check and update font class depends on number of lines
            let arrTitleNodes = this.sgParent.querySelectorAll("[id*='sgTitleNode']");
            if (this.isPresent != true) {
                for (let a = 0; a < arrTitleNodes.length; a++) {
                    if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(arrTitleNodes[a]);
                }
                this.checkShapeDependency();
            }

            if (this.isPlayAnimation == false && this.isPresent != true) this.eventManager.dispatch("positionchangecallback", (this.isFromLastSlide == true ? this.sgData.length : 1) - 1);
            if (this.isPresent != true) {
                // let slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
                // if (slideDomContentGroup) this.changeVariation(slideDomContentGroup);
                //Updating image positions for all images
                // if (doImagePosition) this.specialGraphicsUtils.updateImagePositions(this.sgParent);

                let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
                let finalShow = this.sgParent?.parentElement?.parentElement?.getAttribute("data-ogdata-finalshow_0")?.includes("intro") ? true : false;
                let indexValue = assetParent0.classList.contains("introSlide") && finalShow ? this.currentNodeIndex : 0;
                let isCustomCarousel = this.fileclass == "GenericCarouselImagestack3";
                if (isCustomCarousel) this.currentNodeIndex = 2;

                if (!finalShow) this.currentNodeIndex = 2;

                this.floaterNavigation((this.carouselType && (this.carouselType == "type4" || this.carouselType == "type9")) || isCustomCarousel ? 0 : indexValue);
                // this.setTargetIndex();

                //Text Element positioning after all text's props change
                this.rePositioningTextElement();
            }
        }
        SGBaseClass.prototype.specialGraphicsCreationComplete.call(this);
    }
};
//Assets load error
GenericSpecialgraphics.prototype.assetError = function () {
    this.assetLoadingCount = this.assetLoadingCount - 1;
    if (this.assetLoadingCount == 0) {
        // console.log("SG - all assets load complete");
        this.assetsLoading = false;
        this.arrCommonAssets = [];
        this.specialGraphicsCreationComplete();
    }
};
//Re position text element
GenericSpecialgraphics.prototype.rePositioningTextElement = function (targetIndex = -1) {
    let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
    for (let i = 0; i < assetParents.length; i++) {
        if (targetIndex == -1 || targetIndex == i) {
            let textInnerParentNode = assetParents[i].querySelector("[id='textInnerParentNode']");
            let lytAssetTextParent = this.sgParent.querySelector("[id='lytAssetTextParent" + i + "']");
            if (!textInnerParentNode && lytAssetTextParent) textInnerParentNode = lytAssetTextParent;

            if (this.sgParent.hasAttribute("singlenode") && this.sgParent.getAttribute("singlenode") == "true" && this.textElement && this.textElement.elementData && this.textElement.elementData.textelementproperties) {
                let textElementStyle = assetParents[i].getAttribute("data-textelementstyle");
                let props = this.textElement.elementData.textelementproperties;
                let textElementSelected = props[textElementStyle] ? props[textElementStyle] : Object.keys(props).length > 0 ? props[Object.keys(props)[0]] : null;
                let target = textElementSelected && textElementSelected.target ? textElementSelected.target : null;
                if (target && target == "title" && assetParents[i].querySelector("[id*='titleTextParent")) textInnerParentNode = assetParents[i].querySelector("[id*='titleTextParent']").parentElement;
                if (target && target == "label" && assetParents[i].querySelector("[id*='titleLabelTextParent")) textInnerParentNode = assetParents[i].querySelector("[id*='titleLabelTextParent']").parentElement;
                if (target && target == "subtitle" && assetParents[i].querySelector("[id*='subTitleTextParent")) textInnerParentNode = assetParents[i].querySelector("[id*='subTitleTextParent']").parentElement;
            }
            this.textElementPositioning(assetParents[i], textInnerParentNode, i);
        }
    }
};
//Assets load complete
GenericSpecialgraphics.prototype.assetsLoadComplete = function (responseData) {
    for (let i = 0; i < responseData.length; i++) {
        if (responseData[i].parentId && responseData[i].id.includes("quoteIcon") && this.sgParent.querySelector("[id='" + responseData[i].parentId + "']")) {
            //Quote icon - svg
            let parent = responseData[i].assetParent.querySelector("[id='" + responseData[i].parentId + "']");

            if (parent.getElementsByTagName("svg").length > 0) parent.getElementsByTagName("svg")[0].parentElement.removeChild(parent.getElementsByTagName("svg")[0]);
            var parser = new DOMParser();
            var doc = parser.parseFromString(responseData[i].data, "image/svg+xml");
            doc.lastChild.setAttribute("data-nodetype", "iconNode");
            doc.lastChild.style.overflow = "unset";
            let propName = responseData[i].parentId.includes("quoteIcon2") ? "quoteIcon2Color" : responseData[i].parentId.includes("quoteIcon3") ? "quoteIcon3Color" : "quoteIconColor";
            doc.lastChild.style.setProperty(propName, responseData[i].assetParent.style.getPropertyValue(propName).trim());
            parent.appendChild(doc.lastChild);
            this.applySVGData(parent);
        } else {
            let name = "";
            let parentNode = responseData[i].parent ? responseData[i].parent : this.sgParent;
            if (responseData[i].id.includes("svgdata")) name = "Illustration";
            if (responseData[i].id.includes("iconload")) name = "Illustration";
            if (name == "Illustration" && parentNode.querySelectorAll("[id='svgElementDiv']").length > 0) {
                let arrSvgParent = parentNode.querySelectorAll("[id='svgElementDiv']");
                for (let a = 0; a < arrSvgParent.length; a++) {
                    arrSvgParent[a].innerHTML = responseData[i].data;
                    this.applySVGData(arrSvgParent[a]);
                }
            }
        }
    }
};
GenericSpecialgraphics.prototype.applySVGData = function (svgChild) {
    if (svgChild.getElementsByTagName("svg").length > 0) {
        let svgDOM = svgChild.getElementsByTagName("svg")[0];
        svgDOM.style.width = "100%";
        svgDOM.style.height = "100%";
    }
};
GenericSpecialgraphics.prototype.createNestedNodes = function (subNodes, nodeParentToInsert, currentIndex = 0) {
    for (let j = 0; j < subNodes.length; j++) {
        let nodeObj = subNodes[j];
        let nodeParent = this.createNodes(nodeObj, nodeParentToInsert, currentIndex);
        if (nodeObj.subNodes && nodeParent) {
            this.createNestedNodes(nodeObj.subNodes, nodeParent, currentIndex);
        }
    }
};
GenericSpecialgraphics.prototype.createNodes = function (nodeObj, nodeParent, currentIndex = 0) {
    let name = nodeObj.name;
    switch (name) {
        case "contentMainParent":
        case "contentNode":
        case "contentNode1":
        case "contentNode2":
        case "contentNode3":
        case "contentNode4":
        case "contentNode5":
        case "contentNode6":
        case "secContentNode":
        case "secContentNode1":
        case "secContentNode2":
        case "secContentNode3":
        case "secContentNode4":
        case "secContentNode5":
        case "secContentNode6":
            return this.createContentNode(nodeParent, nodeObj, name);
        case "img":
            this.createImageNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "tit":
        case "text":
            this.createTitleNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "title":
            this.createSingleTitleNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "subtitle":
            this.createSingleSubTitleNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "label":
            this.createSingleLabelNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "num":
            this.createNumberNode(nodeParent, currentIndex);
            break;
        case "bgimage1":
            this.createBgImage(1, currentIndex);
            break;
        case "bgimage2":
            this.createBgImage(2, currentIndex);
            break;
        case "presetimage":
            this.createPresetImage(currentIndex);
            break;
        case "pointimage":
        case "pointimage1":
        case "pointimage2":
        case "pointimage3":
        case "pointimage4":
        case "pointimage5":
        case "pointimage6":
        case "pointimage7":
        case "pointimage8":
        case "pointimage9":
        case "pointimage10":
            this.createPointImage(nodeParent, currentIndex);
            break;
        case "duplicateimage":
            this.createDuplicateImage(currentIndex);
            break;
        case "shape1":
        case "shape2":
        case "shape3":
        case "shape4":
        case "shape5":
            let propertyValue = null;
            let propName = currentIndex == 0 ? "introproperties" : "properties";
            let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData ? this.metaData : null;
            if (metaDataBase && metaDataBase[this.deviceModel]) metaDataBase = metaDataBase[this.deviceModel];
            if (metaDataBase && metaDataBase[propName] && metaDataBase[propName][name]) propertyValue = metaDataBase[propName][name];
            this.createShapes(nodeParent, name, propertyValue, currentIndex);
            break;
        case "placeholderimage":
            this.createPlaceHolder(nodeParent, currentIndex);
            break;
        case "quoteicon":
        case "quoteicon1":
            this.createQuoteIconNodes(nodeParent, currentIndex, 1);
            break;
        case "quoteicon2":
            this.createQuoteIconNodes(nodeParent, currentIndex, 2);
            break;
        case "quoteicon3":
            this.createQuoteIconNodes(nodeParent, currentIndex, 3);
            break;
        case "authtext":
            this.authTextBase(nodeParent, currentIndex, nodeObj.flexvalue);
            break;
        case "authimg":
            this.authImageBase(nodeParent, currentIndex);
            break;
        case "ctabutton":
            this.ctaButtonCreate(nodeParent, currentIndex);
            break;
        case "commonbg":
            this.createCommonBgImage(nodeParent, currentIndex);
            break;
        default:
            break;
    }
    if (name.includes("pointshape")) {
        let props = this.getProps();
        let propertyValue = props && props[name] ? props[name] : null;
        this.createShapesInsidePage(nodeParent, name, propertyValue, currentIndex);
    } else if (name.includes("point") && name.includes("shape")) {
        let props = this.getProps();
        let propertyValue = props && props[name] ? props[name] : null;
        let shapeName = name.slice(name.indexOf("shape") + 5);
        let shapeIndex = name.substr(0, name.indexOf("shape")).replace("point", "");
        if (parseInt(shapeIndex) == currentIndex) this.createShapesInsidePage(nodeParent, "pointshape" + shapeName, propertyValue, currentIndex);
    }
};
GenericSpecialgraphics.prototype.getProps = function () {
    //Get slide properties
    let props = null;
    let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData ? this.metaData : null;
    let secondaryProp = null;
    if (metaDataBase && metaDataBase.properties) secondaryProp = metaDataBase.properties;
    if (metaDataBase && metaDataBase[this.deviceModel]) metaDataBase = metaDataBase[this.deviceModel];
    if (metaDataBase && metaDataBase.properties) props = metaDataBase.properties;
    let returnVal = props ? props : secondaryProp;
    if (returnVal && ((returnVal.text && returnVal.text.textstyle) || (returnVal.number && returnVal.number.numberstyle) || (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle))) {
        let textPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.textproperties ? this.objDataToSG.sgMoodsData.textproperties : null;
        let numberPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.numberproperties ? this.objDataToSG.sgMoodsData.numberproperties : null;
        let placeholderPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.placeholderimageproperties ? this.objDataToSG.sgMoodsData.placeholderimageproperties : null;

        if (returnVal.text && returnVal.text.textstyle && textPropFromMood && textPropFromMood[returnVal.text.textstyle]) {
            let newValue = textPropFromMood[returnVal.text.textstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.text[key] = newValue[key];
            });
            delete returnVal.text.textstyle;
        }
        if (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle && placeholderPropFromMood && placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle]) {
            let newValue = placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.placeholderimage[key] = newValue[key];
            });
            delete returnVal.placeholderimage.placeholderimagestyle;
        }
        if (returnVal.number && returnVal.number.numberstyle && numberPropFromMood && numberPropFromMood[returnVal.number.numberstyle]) {
            let newValue = numberPropFromMood[returnVal.number.numberstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.number[key] = newValue[key];
            });
            delete returnVal.number.numberstyle;
        }
    }
    return returnVal;
};
GenericSpecialgraphics.prototype.getIntroProps = function () {
    //Get intro slide properties
    let props = null;
    let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData ? this.metaData : null;
    let secondaryProp = null;
    if (metaDataBase && metaDataBase.introproperties) secondaryProp = metaDataBase.introproperties;
    if (metaDataBase && metaDataBase[this.deviceModel]) metaDataBase = metaDataBase[this.deviceModel];
    if (metaDataBase && metaDataBase.introproperties) props = metaDataBase.introproperties;

    let returnVal = props ? props : secondaryProp ? secondaryProp : this.getProps();
    if (returnVal && ((returnVal.text && returnVal.text.textstyle) || (returnVal.number && returnVal.number.numberstyle) || (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle))) {
        let textPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.textproperties ? this.objDataToSG.sgMoodsData.textproperties : null;
        let numberPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.numberproperties ? this.objDataToSG.sgMoodsData.numberproperties : null;
        let placeholderPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.placeholderimageproperties ? this.objDataToSG.sgMoodsData.placeholderimageproperties : null;

        if (returnVal.text && returnVal.text.textstyle && textPropFromMood && textPropFromMood[returnVal.text.textstyle]) {
            let newValue = textPropFromMood[returnVal.text.textstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.text[key] = newValue[key];
            });
            delete returnVal.text.textstyle;
        }
        if (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle && placeholderPropFromMood && placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle]) {
            let newValue = placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.placeholderimage[key] = newValue[key];
            });
            delete returnVal.placeholderimage.placeholderimagestyle;
        }
        if (returnVal.number && returnVal.number.numberstyle && numberPropFromMood && numberPropFromMood[returnVal.number.numberstyle]) {
            let newValue = numberPropFromMood[returnVal.number.numberstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.number[key] = newValue[key];
            });
            delete returnVal.number.numberstyle;
        }
    }
    return returnVal;
};
GenericSpecialgraphics.prototype.createContentNode = function (parent, props, id) {
    if (id == "contentMainParent" && parent.querySelector("[id='contentMainParent']")) parent.querySelector("[id='contentMainParent']").parentElement.removeChild(parent.querySelector("[id='contentMainParent']"));
    let nodeParent = document.createElement("div");
    nodeParent.className = id;
    nodeParent.style.pointerEvents = "none";
    nodeParent.setAttribute("id", id);
    parent.appendChild(nodeParent);
    nodeParent.style.display = "flex";
    this.setTextType(nodeParent);

    if (props && props.class) {
        nodeParent.className = id + "  " + props.class;
        if (nodeParent.classList.contains("valign_s") || nodeParent.classList.contains("valign_c") || nodeParent.classList.contains("valign_e")) {
            let direction = window.getComputedStyle(nodeParent).flexDirection;
            if (direction == "row") nodeParent.style.alignItems = nodeParent.classList.contains("valign_c") ? "center" : nodeParent.classList.contains("valign_e") ? "flex-end" : "flex-start";
            else nodeParent.style.justifyContent = nodeParent.classList.contains("valign_c") ? "center" : nodeParent.classList.contains("valign_e") ? "flex-end" : "flex-start";
        }
        if (nodeParent.classList.contains("halign_s") || nodeParent.classList.contains("halign_c") || nodeParent.classList.contains("halign_e")) {
            let direction = window.getComputedStyle(nodeParent).flexDirection;
            if (direction == "row") nodeParent.style.justifyContent = nodeParent.classList.contains("halign_c") ? "center" : nodeParent.classList.contains("halign_e") ? "flex-end" : "flex-start";
            else nodeParent.style.alignItems = nodeParent.classList.contains("halign_c") ? "center" : nodeParent.classList.contains("halign_e") ? "flex-end" : "flex-start";
        }
    } else nodeParent.style.display = "block";
    if (props.positionvalue) nodeParent.style.position = props.positionvalue;
    if (props.zorder) nodeParent.style.zIndex = props.zorder;
    if (props.order) nodeParent.style.order = props.order;
    if (props.flexvalue) nodeParent.style.flex = props.flexvalue;
    if (props.position && props.position.split(",").length == 4) this.specialgraphicsPropertyUtils.updatePosition(nodeParent, props.position);

    if (props.padding) this.specialgraphicsPropertyUtils.updatePadding(props.padding, nodeParent, true);
    if (props.margin) this.specialgraphicsPropertyUtils.updateMargin(props.margin, nodeParent, true);
    if (props.maxwidth) {
        // nodeParent.style.maxWidth = props.maxwidth + (props.maxwidth.includes("px") || props.maxwidth.includes("%") ? "" : "px");
        nodeParent.style.width = props.maxwidth + (props.maxwidth.includes("px") || props.maxwidth.includes("%") ? "" : "px");
        nodeParent.setAttribute("fullwidth", window.getComputedStyle(nodeParent).width);
    }
    if (props.maxheight) {
        let oldH = null;
        if (nodeParent.parentElement.hasAttribute("fullheight")) {
            oldH = nodeParent.parentElement.style.height;
            nodeParent.parentElement.style.height = nodeParent.parentElement.getAttribute("fullheight");
        }

        let oldHeight = nodeParent.style.height;
        nodeParent.style.height = props.maxheight + (props.maxheight.includes("px") || props.maxheight.includes("%") ? "" : "px");
        nodeParent.style.maxHeight = props.maxheight + (props.maxheight.includes("px") || props.maxheight.includes("%") ? "" : "px");
        let h = window.getComputedStyle(nodeParent).height;
        nodeParent.style.height = oldHeight;
        nodeParent.setAttribute("fullheight", h);

        if (oldH && nodeParent.parentElement.hasAttribute("fullheight")) nodeParent.parentElement.style.height = oldH;
    }
    this.specialGraphicsUtils.updatePaddingMarginInlineStyle(nodeParent);
    // let styleData = window.getComputedStyle(nodeParent);
    // nodeParent.style.setProperty("--paddingLeft", styleData.paddingLeft);
    // nodeParent.style.setProperty("--paddingRight", styleData.paddingRight);
    // nodeParent.style.setProperty("--paddingTop", styleData.paddingTop);
    // nodeParent.style.setProperty("--paddingBottom", styleData.paddingBottom);
    // nodeParent.style.setProperty("--marginLeft", styleData.marginLeft);
    // nodeParent.style.setProperty("--marginRight", styleData.marginRight);
    // nodeParent.style.setProperty("--marginTop", styleData.marginTop);
    // nodeParent.style.setProperty("--marginBottom", styleData.marginBottom);

    return nodeParent;
};
GenericSpecialgraphics.prototype.authTextBase = function (nodeParent, currentIndex, flexValue) {
    this.createAuthorTextBase(nodeParent, flexValue, currentIndex);

    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let authtextProperty = null;
    if (props && props["authtext"]) authtextProperty = props["authtext"];
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    this.applyAuthTextPropertyCommon(authtextProperty, assetParent, this.specialgraphicsPropertyUtils);
};
GenericSpecialgraphics.prototype.ctaButtonCreate = function (nodeParent, currentIndex) {
    this.createCtaButtonNode(nodeParent, currentIndex);
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    this.applyCtaButtonProps(props, currentIndex);
};
GenericSpecialgraphics.prototype.authImageBase = function (nodeParent, currentIndex) {
    this.createAuthorImageNode(nodeParent, currentIndex);

    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let authimageProperty = null;
    if (props && props["authimg"]) authimageProperty = props["authimg"];
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let arrAssets = this.applyAuthImagePropertyCommon(authimageProperty, assetParent, this.specialgraphicsPropertyUtils, currentIndex);
    if (arrAssets) this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
};
GenericSpecialgraphics.prototype.createQuoteIconNodes = function (nodeParent, currentIndex, quoteIndex) {
    this.createQuoteIcon(nodeParent, quoteIndex);
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    this.applyQuoteIconProperty(quoteIndex, assetParent);
};
GenericSpecialgraphics.prototype.applyQuoteIconProperty = function (i, assetParent) {
    let props = this.getProps();
    // props = props && props.length > 0 ? props[0] : null;
    let iconProperty = props && props["quoteicon" + i] ? props["quoteicon" + i] : props && props["quoteicon"] ? props["quoteicon"] : null;
    if (props && iconProperty) {
        // for (let i = 1; i < 4; i++) {
        if (iconProperty) {
            if (iconProperty && assetParent.querySelector("[id='quoteParent" + i + "']")) {
                let quoteParent = assetParent.querySelector("[id='quoteParent" + i + "']");
                let quoteIcon = assetParent.querySelector("[id*='quoteIcon']");
                if (iconProperty.position) this.specialgraphicsPropertyUtils.updatePosition(quoteParent, iconProperty.position);
                quoteParent.style.minHeight = quoteParent.style.height;
                if (iconProperty.positionvalue) quoteParent.style.position = iconProperty.positionvalue;
                let propIndex = i == 1 ? "" : i;
                if (iconProperty.color) assetParent.style.setProperty("--quoteIcon" + propIndex + "Color", "rgba(var(--" + iconProperty.color + "-color-rgb),1)");
                else assetParent.style.setProperty("--quoteIcon" + propIndex + "Color", "rgba(var(--icon-color-rgb),1)");
                if (iconProperty.opacity) assetParent.style.setProperty("--quoteIcon" + propIndex + "Opacity", iconProperty.opacity);
                if (iconProperty.iconwidth) assetParent.style.setProperty("--quoteIcon" + propIndex + "Width", iconProperty.iconwidth + (iconProperty.iconwidth.includes("%") || iconProperty.iconwidth.includes("px") ? "" : "px"));
                if (iconProperty.iconheight) assetParent.style.setProperty("--quoteIcon" + propIndex + "Height", iconProperty.iconheight + (iconProperty.iconheight.includes("%") || iconProperty.iconheight.includes("px") ? "" : "px"));
                if (iconProperty.bgcolor) {
                    if (iconProperty.bgcolor.includes("gradient")) {
                        quoteParent.style.backgroundColor = "unset";
                        quoteParent.style.background = iconProperty.bgcolor;
                    } else quoteParent.style.backgroundColor = "rgba(var(--" + iconProperty.bgcolor + "-color-rgb),1)";
                }
                if (iconProperty.padding && quoteIcon) this.specialgraphicsPropertyUtils.updatePadding(iconProperty.padding, quoteParent);
                if (iconProperty.margin && quoteIcon) this.specialgraphicsPropertyUtils.updateMargin(iconProperty.margin, quoteParent);
                if (iconProperty.radius) quoteParent.style.borderRadius = iconProperty.radius;
                if (iconProperty.border) quoteParent.style.borderRadius = iconProperty.border;
                if (iconProperty.zorder) quoteParent.style.zIndex = iconProperty.zorder;
                if (iconProperty.rotate) quoteIcon.style.transform = iconProperty.rotate;
                if (iconProperty.outline && (iconProperty.outline == "true" || iconProperty.outline == true)) quoteParent.classList.add("quoteoutline");
                else quoteParent.classList.remove("quoteoutline");
                if (iconProperty.imageborder) {
                    quoteParent.style.border = "double " + iconProperty.imageborder.replace("gradient", "") + "transparent";
                    quoteParent.style.backgroundImage = "linear-gradient(rgba(var(--bg-color-rgb),1), rgba(var(--bg-color-rgb),1)), radial-gradient(circle at bottom right, rgba(var(--item6-color-rgb),1), rgba(var(--item1-color-rgb),1))";
                    quoteParent.style.backgroundOrigin = "border-box";
                    quoteParent.style.backgroundClip = "content-box, border-box";
                }
                if (iconProperty.globalstyle) {
                    quoteParent.classList.add(iconProperty.globalstyle);
                    quoteParent.classList.add("clsSingleColorParent");
                }
                let quotePath = iconProperty.path ? iconProperty.path : "moods/" + this.moodName + "/" + this.moodName + "quote.svg";
                quotePath = "moods/" + this.moodName + "/" + this.moodName + "quote.svg";
                let arrAssets = [];
                arrAssets.push({ url: quotePath, id: "quoteIcon", type: "SVG", parentId: "quoteIcon" + i, assetParent: assetParent });
                this.arrCommonAssets.push({ array: arrAssets, callback: this.assetsLoadComplete });

                if (iconProperty.contentBG) {
                    arrAssets = [];
                    arrAssets.push({ parent: quoteParent, type: "svg", url: iconProperty.contentBG.value, id: iconProperty.contentBG.id, color: iconProperty.contentBG.color });
                    this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
                }
            }
            // }
        }
    }
};
GenericSpecialgraphics.prototype.createPresetImage = function (currentIndex) {
    //Create preset image
    let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (!deviceImageParentNode) {
        deviceImageParentNode = document.createElement("div");
        deviceImageParentNode.id = "deviceImageParentNode";
        deviceImageParentNode.className = "deviceImageParentNode";
        this.sgParent.insertBefore(deviceImageParentNode, assetParent0);
    }

    this.createPresetImageNode(deviceImageParentNode);
    this.applyPresetImgeProperty(currentIndex);
};
GenericSpecialgraphics.prototype.applyPresetImgeProperty = function (currentIndex) {
    //Apply preset image properties
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props && props.presetimage && this.sgParent.querySelector("[id='presetImageParent']")) {
        let presetImageParent = this.sgParent.querySelector("[id='presetImageParent']");
        let presetImageNode = this.sgParent.querySelector("[id='presetImageNode']");
        if (props.presetimage.positionvalue && presetImageParent) presetImageParent.style.position = props.presetimage.positionvalue;
        if (props.presetimage.imageurl && presetImageNode) presetImageNode.src = this.appStaticURL + props.presetimage.imageurl;
        this.specialgraphicsPropertyUtils.applyImageBaseProps(props.presetimage, deviceImageParentNode, presetImageParent, "--presetImage");
    }
};
GenericSpecialgraphics.prototype.createPlaceHolder = function (parentNode, currentIndex) {
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    // let src = "";
    let placeholderProperty = null;
    if (props && props["placeholderimage"]) placeholderProperty = props["placeholderimage"];
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");

    this.createPlaceHolderImage(parentNode, currentIndex);
    let parentElement = parentNode.querySelector("[id*='placeHolderParent']");
    let logoParent = parentElement.querySelector("[id*='logoContentParent']");
    let imageParent = parentElement.querySelector("[id*='phImageContentParent']");
    let iconParent = parentElement.querySelector("[id*='phIconContentParent']");
    let textParent = parentElement.querySelector("[id*='phTextParent']");
    let phTextNode = parentElement.querySelector("[id*='phTextNode']");
    let logoImageNode = logoParent ? logoParent.querySelector("[id='sgLogoImageNode']") : null;

    let placeHolderType = this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagetype ? this.sgData[currentIndex].placeholderimagetype : placeholderProperty && placeholderProperty.placeholderimagetype ? placeholderProperty.placeholderimagetype : "logo";
    if (placeHolderType && logoParent && imageParent && iconParent && textParent) {
        logoParent.classList.remove("placeholderactive");
        imageParent.classList.remove("placeholderactive");
        iconParent.classList.remove("placeholderactive");
        textParent.classList.remove("placeholderactive");
        if (placeHolderType == "logo") logoParent.classList.add("placeholderactive");
        if (placeHolderType == "image") imageParent.classList.add("placeholderactive");
        if (placeHolderType == "icon") iconParent.classList.add("placeholderactive");
        if (placeHolderType == "text") textParent.classList.add("placeholderactive");
        if (placeholderProperty && placeholderProperty.placeholdersizestyle) {
            let sizeStyle = placeholderProperty.placeholdersizestyle;
            if (!parentElement.classList.contains("placeholderSizeStyle")) parentElement.classList.add("placeholderSizeStyle");
            parentElement.setAttribute("data-placeholdersizestyle", sizeStyle);
            logoParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            imageParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            iconParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            textParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            if (!logoParent.classList.contains(sizeStyle)) logoParent.classList.add(sizeStyle);
            if (!imageParent.classList.contains(sizeStyle)) imageParent.classList.add(sizeStyle);
            if (!iconParent.classList.contains(sizeStyle)) iconParent.classList.add(sizeStyle);
            if (!textParent.classList.contains(sizeStyle)) textParent.classList.add(sizeStyle);
        }
    }
    if (placeholderProperty) this.specialgraphicsPropertyUtils.applyImageBaseProps(placeholderProperty, assetParent, parentElement, "--placeholderImage", false);

    let colorValue = placeholderProperty ? this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "secondary", placeholderProperty.textcolor) : null;
    // if (!colorValue && placeholderProperty.textcolor) colorValue = "rgba(var(--" + placeholderProperty.textcolor + "-color-rgb),1)";
    if (phTextNode && colorValue) {
        phTextNode.style.color = colorValue;
        phTextNode.setAttribute("data-color", colorValue);
    }

    if (placeholderProperty.margin) {
        let parentStyle = window.getComputedStyle(parentElement);
        assetParent.style.setProperty("--placeholderImageMarginTop", parentStyle.marginTop);
        assetParent.style.setProperty("--placeholderImageMarginBottom", parentStyle.marginBottom);
        assetParent.style.setProperty("--placeholderImageMarginLeft", parentStyle.marginLeft);
        assetParent.style.setProperty("--placeholderImageMarginRight", parentStyle.marginRight);
        parentElement.style.removeProperty("margin");
    }
    if (placeholderProperty.padding) {
        let parentStyle = window.getComputedStyle(parentElement);
        assetParent.style.setProperty("--placeholderImagePaddingTop", parentStyle.paddingTop);
        assetParent.style.setProperty("--placeholderImagePaddingBottom", parentStyle.paddingBottom);
        assetParent.style.setProperty("--placeholderImagePaddingLeft", parentStyle.paddingLeft);
        assetParent.style.setProperty("--placeholderImagePaddingRight", parentStyle.paddingRight);
        parentElement.style.removeProperty("padding");
    }
    if (this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagesize && parentElement) parentElement.setAttribute("data-placeholderimagesize", this.sgData[currentIndex].placeholderimagesize);
    if (placeHolderType == "image" || placeHolderType == "logo" || placeHolderType == "icon" || placeHolderType == "text") this.setLogoSizes(assetParent, placeHolderType);

    if (this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagealign) {
        let alignData = this.sgData[currentIndex].placeholderimagealign;
        if (alignData == "bottom" || alignData == "right") parentElement.classList.add("phPosition");
        else parentElement.classList.remove("phPosition");
    }
    if (placeholderProperty && placeholderProperty.placeholderalign) parentElement.setAttribute("phalign", placeholderProperty.placeholderalign);
    if (this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagesize) {
        //Implement placeholder size change from floter
        // let sizeV = this.sgData[currentIndex].placeholderimagesize;
        // let multipleValue = sizeV == "small" ? 0.4 : sizeV == "medium" ? 0.7 : sizeV == "large" ? 1 : parseFloat(sizeV);
        let multipleValue = this.specialGraphicsUtils.getImageSizeSML(this.sgData[currentIndex].placeholderimagesize);
        let largeW = parseFloat(parentElement.getAttribute("data-largewidth"));
        let largeH = parseFloat(parentElement.getAttribute("data-largeheight"));
        let newW = largeW * multipleValue;
        let newH = largeH * multipleValue;
        let cropHeight = logoImageNode && logoImageNode.hasAttribute("logosizecropheight") ? logoImageNode.getAttribute("logosizecropheight") : "";
        if (newW > 0 && newH > 0) {
            parentElement.style.width = newW + "px";
            if (cropHeight == "") parentElement.style.height = newH + "px";
        }
        if (logoImageNode) logoImageNode.removeAttribute("logosizecropheight");
    }
    let hasPlaceholderData = this.sgData[currentIndex].placeholderimage != null && this.sgData[currentIndex].placeholderimage != undefined;
    if (placeHolderType == "icon" && iconParent && hasPlaceholderData) {
        let iconPath = this.sgData[currentIndex].placeholderimage.includes(".svg") ? this.sgData[currentIndex].placeholderimage : this.appStaticURL + "genericassets/icons/fill/default/best.svg";
        let iconNodeParent = iconParent.querySelector("[id*='phIconSvgNode']");
        let arrAssets = [];
        if (iconNodeParent) iconNodeParent.setAttribute("data-src", iconPath);
        arrAssets.push({ url: iconPath, id: "svgdata", parent: iconNodeParent, type: "SVG" });
        this.arrCommonAssets.push({ array: arrAssets, callback: this.placeholderSvgLoadCallback });
    }
    if (placeholderProperty && placeholderProperty.halign) {
        let halignProp = placeholderProperty.halign;
        let hAlign = halignProp == "right" || halignProp == "end" ? "flex-end" : halignProp == "center" || halignProp == "middle" ? "center" : "flex-start";
        let pos = halignProp == "right" || halignProp == "end" ? "right" : halignProp == "center" || halignProp == "middle" ? "center" : "left";
        if (logoImageNode) logoImageNode.setAttribute("data-imagecropalignment", pos);
        let phTextNode = textParent.querySelector("[id*='phTextNode']");
        if (phTextNode) phTextNode.style.textAlign = hAlign;
        if (iconParent && iconParent.getElementsByTagName("svg").length > 0) iconParent.getElementsByTagName("svg")[0].style.justifyContent = hAlign;
    }
    if (placeholderProperty.color) {
        parentElement.classList.remove(placeholderProperty.color);
        parentElement.classList.add(placeholderProperty.color);
        parentElement.classList.add("shapeHolder");
    }
    if (placeholderProperty.class) {
        this.specialGraphicsUtils.applyClassNamesFromString(parentElement, placeholderProperty.class);
    }
    if (placeholderProperty.textclass && phTextNode) {
        this.specialGraphicsUtils.applyClassNamesFromString(phTextNode, placeholderProperty.textclass);
    }
    if (placeholderProperty && placeholderProperty.positionvalue) {
        parentElement.style.position = placeholderProperty.positionvalue;
        if (placeholderProperty.position) {
            let positionData = placeholderProperty.position.split(",");
            parentElement.style.left = positionData[0];
            parentElement.style.top = positionData[1];
        }
    }
    if (this.sgData[currentIndex].placeholderimagecontrast && logoImageNode) {
        logoImageNode.classList.remove("logoBrightnessSGUnset");
        if (this.sgData[currentIndex].placeholderimagecontrast == "false") logoImageNode.classList.add("logoBrightnessSGUnset");
    }
    this.applyContrastToText(logoImageNode, placeholderProperty);
    this.applyContrastToText(phTextNode, placeholderProperty);
};
GenericSpecialgraphics.prototype.createBgImage = function (imageIndex = 1, currentIndex) {
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let type = "img";
    let src = "";
    let bgImageProperty = null;
    if (props && props["bgimage" + imageIndex]) bgImageProperty = props["bgimage" + imageIndex];
    if (bgImageProperty && bgImageProperty.type && bgImageProperty.type == "video") type = "video";
    if (bgImageProperty && bgImageProperty.imageurl) src = bgImageProperty.imageurl;
    let defaultURL = this.specialGraphicsUtils.getMoodBasedVideo(this.objDataToSG);
    if (defaultURL) src = defaultURL;
    if (this.sgData[1].presetimage && type == "video") src = this.sgData[1].presetimage;

    let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
    // let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let oldImage = this.sgParent.querySelector("[id*='bgImage" + (imageIndex == 1 ? "" : imageIndex) + "Node']");
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (!oldImage) {
        if (!deviceImageParentNode) {
            deviceImageParentNode = document.createElement("div");
            deviceImageParentNode.id = "deviceImageParentNode";
            deviceImageParentNode.className = "deviceImageParentNode";
            this.sgParent.insertBefore(deviceImageParentNode, assetParent0);
        }

        oldImage = this.createBgImageNode(deviceImageParentNode, (imageIndex == 1 ? "" : imageIndex) + "Node", type, src);
        if (type == "video" && (bgImageProperty.loop == "false" || bgImageProperty.loop == false)) oldImage.loop = false;
        oldImage.setAttribute("data-fit", "false");
        if (this.objDataToSG.assetGroupingId) oldImage.setAttribute("assetGroupingId", this.objDataToSG.assetGroupingId);
        oldImage.setAttribute("floater_contrast", bgImageProperty.contrastsupport == "false" || bgImageProperty.contrastsupport == false ? "false" : "true");
        if (type == "video") {
            oldImage.setAttribute("data-isvideo", "true");
            this.sgParent.setAttribute("data-isvideo", "true");
            oldImage.style.pointerEvents = "auto";
        }
    }
    this.applyBgImageProperty(imageIndex, bgImageProperty, currentIndex, type);
};
GenericSpecialgraphics.prototype.applyBgImageProperty = function (imageIndex, bgImageProperty, currentIndex, type) {
    if (!bgImageProperty) {
        let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
        if (props && props["bgimage" + imageIndex]) bgImageProperty = props["bgimage" + imageIndex];
    }
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let oldImage = this.sgParent.querySelector("[id*='bgImage" + (imageIndex == 1 ? "" : imageIndex) + "Node']");
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (bgImageProperty && oldImage) {
        let bgImage = oldImage;
        if (bgImageProperty.positionvalue && bgImage) bgImage.style.position = bgImageProperty.positionvalue;
        // if (this.sgData[1].presetimage && type == "video") bgImageProperty.imageurl = this.sgData[1].presetimage;
        // if (bgImageProperty.imageurl && bgImage) {
        //     let src = bgImageProperty.imageurl;
        //     if (src && src.includes("genericassets/") && !src.includes("assets/projectresources/")) src = this.appStaticURL + src;
        //     bgImage.src = src;
        // }
        this.specialgraphicsPropertyUtils.applyImageBaseProps(bgImageProperty, deviceImageParentNode, bgImage, "--bg", false);
        if (bgImageProperty.zorder) bgImage.style.zIndex = bgImageProperty.zorder;
        if (bgImageProperty.contrast && bgImageProperty.contrast == "fullbg") {
            if (bgImage) {
                bgImage.setAttribute("contrast", "fullbg");
                this.eventManager.dispatch("applyImageContrast", bgImage, assetParent);
            }
        } else if (bgImageProperty.contrast && bgImageProperty.contrast == "halfbg") {
            if (bgImage) {
                bgImage.setAttribute("contrast", "halfbg");
                this.eventManager.dispatch("applyImageContrast", bgImage, assetParent, true);
            }
        } else if (this.slideContent) {
            this.slideContent.classList.remove("fixedlightText");
            this.slideContent.classList.remove("fixeddarkText");
        }
        let videoContrast = this.sgData[1] && this.sgData[1].presetimagecontrast ? this.sgData[1].presetimagecontrast : null;
        let contrast = videoContrast ? videoContrast : bgImageProperty.fixedcontrast;
        if (contrast) {
            assetParent.classList.remove("darkText");
            assetParent.classList.remove("lightText");
            assetParent.classList.remove("fixedlightText");
            assetParent.classList.remove("fixeddarkText");
            assetParent.classList.add(contrast);
        }
        if (bgImageProperty.position) {
            let arrPosition = bgImageProperty.position.split(",");
            if (arrPosition.length >= 4 && deviceImageParentNode) {
                let bg = "--bg" + (imageIndex == 1 ? "" : "2");
                deviceImageParentNode.style.setProperty(bg + "Left", arrPosition[0] + (arrPosition[0].includes("px") || arrPosition[0].includes("%") || arrPosition[0].includes("auto") ? "" : "px"));
                deviceImageParentNode.style.setProperty(bg + "Top", arrPosition[1] + (arrPosition[1].includes("px") || arrPosition[1].includes("%") || arrPosition[1].includes("auto") ? "" : "px"));
                deviceImageParentNode.style.setProperty(bg + "Width", arrPosition[2] + (arrPosition[2].includes("px") || arrPosition[2].includes("%") || arrPosition[2].includes("auto") ? "" : "px"));
                deviceImageParentNode.style.setProperty(bg + "Height", arrPosition[3] + (arrPosition[3].includes("px") || arrPosition[3].includes("%") || arrPosition[3].includes("auto") ? "" : "px"));
            }
        }
    }
};
GenericSpecialgraphics.prototype.createDuplicateImage = function (currentIndex) {
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    if (props) this.specialgraphicsPropertyUtils.applyDuplicateImageProperties(props, assetParent, currentIndex, true);
};
GenericSpecialgraphics.prototype.createPointImage = function (parent, currentIndex) {
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let nodes = this.sgParent.querySelectorAll("[id*='pointImageParent']");
    if (props && currentIndex != 0 && nodes.length == 0 && this.sgData.length - 1 == currentIndex) {
        let arrAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
        for (let a = 1; a < arrAssetParent.length; a++) {
            let innerParent = arrAssetParent[a].querySelector("[id='" + parent.id + "']");
            this.createPointImageNode(innerParent, a);
        }

        for (let a = 1; a < arrAssetParent.length; a++) {
            let imageProperty = props.pointimage;
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["pointimage" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((a - 1) % loopIndex) + 1;
                imageProperty = props["pointimage" + ind];
            }
            let pointImageParentNode = arrAssetParent[a].querySelector("[id*='pointImageParent']");
            if (pointImageParentNode && imageProperty.imageurl) {
                let pointImageNode = pointImageParentNode.querySelector("[id*='pointImageNode']");
                pointImageNode.src = this.appStaticURL + imageProperty.imageurl;
                pointImageNode.setAttribute("data-fit", "false");
                this.specialgraphicsPropertyUtils.applyImageBaseProps(imageProperty, arrAssetParent[a], pointImageParentNode, "--pointImage");
                if (imageProperty.globalstyle) {
                    pointImageParentNode.parentElement.classList.remove(imageProperty.globalstyle);
                    pointImageParentNode.parentElement.classList.add(imageProperty.globalstyle);
                    pointImageParentNode.parentElement.classList.add("clsSingleColorParent");
                    pointImageParentNode.setAttribute("data-nodetype", "imageHolder");
                }
                if (imageProperty.positionvalue) arrAssetParent[a].style.setProperty("--pointImagePosition", imageProperty.positionvalue);
            }
        }
    }
};
GenericSpecialgraphics.prototype.createNumberNode = function (parent, currentIndex) {
    //number
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let numberContent = this.objDataToSG && this.objDataToSG.numberFormat ? this.specialGraphicsUtils.getSeqMoodStyle(this.objDataToSG.numberFormat, currentIndex) : null;
    if (!assetParent.classList.contains("introSlide")) this.createNumberTextNode(parent, currentIndex, numberContent);

    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props) {
        let numberProperty = props.number;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["number" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                numberProperty = props["number" + ind];
            }
        }
        let covernumber = assetParent.querySelector("[id*='sgNumberTextNode']");
        let sgNumberTextParent = assetParent.querySelector("[id='sgNumberTextParent']");

        let defaultProp = null;
        let numberPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.numberproperties ? this.objDataToSG.sgMoodsData.numberproperties : null;
        if (numberPropFromMood) {
            const keys = Object.keys(numberPropFromMood);
            keys.forEach((key) => {
                let element = numberPropFromMood[key];
                if (element && element.default && (element.default == "true" || element.default == true)) defaultProp = element;
            });
        }

        let newNumberProperty = !numberProperty ? defaultProp : numberProperty;
        if (newNumberProperty) {
            if (newNumberProperty.positionvalue && covernumber) {
                covernumber.style.position = newNumberProperty.positionvalue;
                if (sgNumberTextParent) sgNumberTextParent.style.position = newNumberProperty.positionvalue;
            }
            if (newNumberProperty.line && (newNumberProperty.line == "true") | (newNumberProperty.line == true) && covernumber) covernumber.parentElement.classList.add("numberline");
            let textAlign = null;
            if (newNumberProperty.halign && (covernumber || sgNumberTextParent)) {
                let hAlign = newNumberProperty.halign == "right" || newNumberProperty.halign == "end" ? "flex-end" : newNumberProperty.halign == "center" || newNumberProperty.valign == "middle" ? "center" : "flex-start";
                covernumber.style.justifyContent = hAlign;
                textAlign = hAlign == "flex-end" ? "end" : hAlign == "center" ? "center" : "start";
            }
            if (newNumberProperty.valign && (covernumber || sgNumberTextParent)) {
                let vAlign = newNumberProperty.valign == "bottom" || newNumberProperty.valign == "end" ? "flex-end" : newNumberProperty.valign == "center" || newNumberProperty.valign == "middle" ? "center" : "flex-start";
                if (sgNumberTextParent) sgNumberTextParent.style.alignItems = vAlign;
                else covernumber.style.alignItems = vAlign;
                this.sgParent.style.setProperty("--numberVAlign", vAlign);
            }
            this.specialgraphicsPropertyUtils.applyNumberProperties(props, covernumber, assetParent, 0, true);
            let node = covernumber;
            if (newNumberProperty.linecount && node) {
                node.setAttribute("data-linecount", newNumberProperty.linecount);
                this.specialGraphicsUtils.doFontFitForCss(node, this.sgParent);
            }
            if (newNumberProperty.rotate && sgNumberTextParent) {
                let lineHeight = parseFloat(window.getComputedStyle(covernumber)["line-height"]);
                lineHeight = isNaN(lineHeight) ? "40" : lineHeight;
                covernumber.style.minWidth = lineHeight + "px";
                covernumber.classList.add("covernumberRotation");
                covernumber.setAttribute("rotatednode", "true");
                covernumber.style.justifyContent = "flex-end";
                if (newNumberProperty.rotate.includes("-90")) covernumber.style.setProperty("--rotateTextRotation", "180deg");
                if (covernumber && textAlign) covernumber.style.setProperty("--rotateTextAlign", textAlign);
                this.specialGraphicsUtils.doFontFitForCss(covernumber, this.sgParent, null, null, null, true);
            }
            if (newNumberProperty.prefix && node) {
                node.setAttribute("prefix", newNumberProperty.prefix);
                node.innerText.replace(newNumberProperty.prefix, "");
                node.innerText = newNumberProperty.prefix + " " + node.innerText;
            }
            if (newNumberProperty.suffix && node) {
                node.setAttribute("suffix", newNumberProperty.suffix);
                node.innerText.replace(newNumberProperty.suffix, "");
                node.innerText = node.innerText + " " + newNumberProperty.suffix;
            }
            if (newNumberProperty.bottom && assetParent) {
                assetParent.style.setProperty("--numberTop", "unset");
                assetParent.style.setProperty("--numberBottom", newNumberProperty.bottom + (newNumberProperty.bottom.includes("px") || newNumberProperty.bottom.includes("%") ? "" : "px"));
            }
            this.applyContrastToText(node, newNumberProperty);
        }
    }
};
GenericSpecialgraphics.prototype.createTitleNode = function (parent, flexValue = "", currentIndex) {
    //Text Nodes - "tit"
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let textInnerParent = this.createTextBase(parent, currentIndex);
    let textBaseParent = assetParent.querySelector("[id*='textBaseParentNode']");
    if (textBaseParent) {
        let zOrderValue = 0;
        let textZIndex = parseFloat(window.getComputedStyle(textBaseParent).zIndex);
        let parentZIndex = parseFloat(window.getComputedStyle(parent).zIndex);
        if (!isNaN(parentZIndex) && parentZIndex > 0) zOrderValue = parentZIndex;
        if (!isNaN(textZIndex) && textZIndex > 0) zOrderValue = zOrderValue + textZIndex;

        textBaseParent.style.zIndex = zOrderValue;
    }
    if (flexValue && flexValue != "") textBaseParent.style.flex = flexValue;
    this.createTitleSet(textInnerParent, currentIndex, assetParent);
    this.applyTextProperty(currentIndex, textBaseParent);
    if (this.objDataToSG && this.objDataToSG.theme && this.objDataToSG.theme) {
        let title = textInnerParent.querySelector("[id*='sgTitleNode']");
        let subTitle = textInnerParent.querySelector("[id*='sgSubTitleNode']");
        let label = textInnerParent.querySelector("[id*='sgTitleLabelNode']");

        let singlecolor = title ? title.hasAttribute("singlecolor") : false;

        let titleColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "title");
        let subtitleColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "subtitle");
        let labelColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "label");
        if (!singlecolor && titleColor && title && !title.hasAttribute("data-supportcontrast")) {
            title.style.setProperty("color", titleColor);
            title.setAttribute("data-color", titleColor);
        }
        if (!singlecolor && subtitleColor && subTitle && !subTitle.hasAttribute("data-supportcontrast")) {
            subTitle.style.setProperty("color", subtitleColor);
            subTitle.setAttribute("data-color", subtitleColor);
        }
        if (!singlecolor && labelColor && label && !label.hasAttribute("data-supportcontrast")) {
            label.style.setProperty("color", labelColor);
            label.setAttribute("data-color", labelColor);
        }
    }
};
GenericSpecialgraphics.prototype.applyTextProperty = function (currentIndex, textBaseParent) {
    //Applying Text Property
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    if (props && assetParent) {
        let textProperty = props.text;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["text" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                textProperty = props["text" + ind];
            }
        }

        let defaultProp = null;
        let textPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.textproperties ? this.objDataToSG.sgMoodsData.textproperties : null;
        if (textPropFromMood) {
            const keys = Object.keys(textPropFromMood);
            keys.forEach((key) => {
                let element = textPropFromMood[key];
                if (element && element.default && (element.default == "true" || element.default == true)) defaultProp = element;
            });
        }
        let newTextProperty = !textProperty ? defaultProp : textProperty;
        if (newTextProperty) {
            this.specialgraphicsPropertyUtils.applyTextProperties(newTextProperty, assetParent, currentIndex, true, true);
            let isSupportTextPosition = newTextProperty.positionchange && (newTextProperty.positionchange == "true" || newTextProperty.positionchange == true) ? true : false;
            //Applying text position
            let textPosition = this.sgData[currentIndex] && this.sgData[currentIndex]["titletextposition"] ? this.sgData[currentIndex]["titletextposition"] : newTextProperty && newTextProperty.defaulttextposition ? newTextProperty.defaulttextposition : "sgMM";
            if (textPosition && textPosition != "" && textBaseParent && isSupportTextPosition) {
                this.specialGraphicsUtils.removeTextPositionClass(textBaseParent.parentElement);
                textBaseParent.parentElement.classList.add("sg" + textPosition.replace("sg", ""));
                assetParent.setAttribute("textPosition", textPosition);
            }
        }
    }
};
GenericSpecialgraphics.prototype.createSingleTitleNode = function (parent, flexValue = "", currentIndex) {
    //Text Nodes - title only
    let textParent = this.createSingleTitle(parent, currentIndex);
    if (flexValue && flexValue != "") textParent.style.flex = flexValue;

    this.applyTitleProperty(currentIndex);
};
GenericSpecialgraphics.prototype.applyTitleProperty = function (currentIndex) {
    //Apply single Title node property
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props) {
        let textProperty = props.title;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["title" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                textProperty = props["title" + ind];
            }
        }
        this.applySingleNodeProps(currentIndex, "titleTextParent", "sgTitleNode", textProperty);
    }
};
GenericSpecialgraphics.prototype.createSingleSubTitleNode = function (parent, flexValue = "", currentIndex) {
    //Text Nodes - title only
    let textParent = this.createSingleSubTitle(parent, currentIndex);
    if (flexValue && flexValue != "") textParent.style.flex = flexValue;

    this.applySubTitleProperty(currentIndex);
};
GenericSpecialgraphics.prototype.applySubTitleProperty = function (currentIndex) {
    //Apply single subtitle node property
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props) {
        let textProperty = props.subtitle;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["subtitle" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                textProperty = props["subtitle" + ind];
            }
        }
        this.applySingleNodeProps(currentIndex, "subTitleTextParent", "sgSubTitleNode", textProperty);
    }
};
GenericSpecialgraphics.prototype.createSingleLabelNode = function (parent, flexValue = "", currentIndex) {
    //Text Nodes - title only
    let textParent = this.createSingleLabel(parent, currentIndex);
    if (flexValue && flexValue != "") textParent.style.flex = flexValue;

    this.applyLabelProperty(currentIndex);
};
GenericSpecialgraphics.prototype.applyLabelProperty = function (currentIndex) {
    //Apply single title label proprty
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props) {
        let textProperty = props.label;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["label" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                textProperty = props["label" + ind];
            }
        }
        this.applySingleNodeProps(currentIndex, "titleLabelTextParent", "sgTitleLabelNode", textProperty);
    }
};
GenericSpecialgraphics.prototype.createImageNode = function (parent, flexValue = "", currentIndex) {
    //Coverimage - "img"
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let imageProperty = this.getImageProperty(currentIndex);
    let coverParent = this.createCoverImageParent(parent, currentIndex, true, imageProperty);
    if (flexValue && flexValue != "") coverParent.style.flex = flexValue;
    // let isSvgSupport = false;
    // if (imageProperty && imageProperty.supportsvg && (imageProperty.supportsvg == true || imageProperty.supportsvg == "true")) isSvgSupport = true;
    let isSvgSupport = imageProperty?.supportsvg && imageProperty.supportsvg == "false" ? false : true;
    this.createCoverImageNode(coverParent, currentIndex, "generic", isSvgSupport);

    let coverImageParent = assetParent.querySelector("[id*='coverImageParent']");
    let coverImageOverlay = coverImageParent ? coverImageParent.querySelector("[id*='coverImageOverlay']") : null;
    if (coverImageParent) {
        let zOrderValue = 0;
        let imageZIndex = parseFloat(window.getComputedStyle(coverImageParent).zIndex);
        let parentZIndex = parseFloat(window.getComputedStyle(parent).zIndex);
        if (!isNaN(parentZIndex) && parentZIndex > 0) zOrderValue = parentZIndex;
        if (!isNaN(imageZIndex) && imageZIndex > 0) zOrderValue = zOrderValue + imageZIndex;

        coverImageParent.style.zIndex = zOrderValue;
    }

    if (imageProperty) {
        let props = imageProperty;
        let mainProps = currentIndex == 0 ? this.getIntroProps() : this.getProps();
        let imagePosition = mainProps && mainProps.imageposition ? mainProps.imageposition : "left";

        let menuJson = this.objDataToSG && this.objDataToSG.menufromjson ? this.objDataToSG.menufromjson : null;
        let coverParent = coverImageParent?.querySelector("[id*='coverParent']");
        if (menuJson && menuJson.floateroptions && menuJson.floateroptions.includes("imagebleed") && coverImageParent) {
            if (coverParent) coverParent.setAttribute("imagebleedoption", "true");
        }
        if (coverParent && this.sgData[currentIndex].coverimageprompt) coverParent.setAttribute("data-node-graphic-text", this.sgData[currentIndex].coverimageprompt);

        this.specialgraphicsPropertyUtils.applyImageProperties(props, assetParent, currentIndex, props);
        if (props.positionvalue && coverImageParent) coverImageParent.style.position = props.positionvalue;
        if (props.padding && props.padding.split(",").length == 4 && coverImageParent) this.specialgraphicsPropertyUtils.updatePadding(props.padding, coverImageParent);
        if (props.contrast && props.contrast == "fullbg") {
            let imageNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            if (imageNode) {
                imageNode.setAttribute("contrast", "fullbg");
                this.eventManager.dispatch("applyImageContrast", imageNode, assetParent);
            }
        } else if (props.contrast && props.contrast == "halfbg") {
            let imageNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            if (imageNode) {
                imageNode.setAttribute("contrast", "halfbg");
                this.eventManager.dispatch("applyImageContrast", imageNode, assetParent, true);
            }
        } else if (this.slideContent) {
            this.slideContent.classList.remove("fixedlightText");
            this.slideContent.classList.remove("fixeddarkText");
        }
        if (props.fixedcontrast) {
            assetParent.classList.remove("darkText");
            assetParent.classList.remove("lightText");
            assetParent.classList.remove("fixedlightText");
            assetParent.classList.remove("fixeddarkText");
            assetParent.classList.add(props.fixedcontrast);
            // assetParent.setAttribute("highlight", "false");
        }
        if (props.overlayindex && this.applyOverlayToImageSG) {
            let imageNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            if (imageNode && !imageNode.hasAttribute("data-csstext")) this.applyOverlayToImageSG(imageNode, props.overlayindex);
        }
        if (props.overlayname && this.applyOverlayToImageSG) {
            let imageNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            if (imageNode && !imageNode.hasAttribute("data-csstext")) this.applyOverlayToImageSG(imageNode, null, props.overlayname);
        }
        if (props.globalstyle && coverImageParent) {
            coverImageParent.classList.remove(props.globalstyle);
            coverImageParent.classList.add(props.globalstyle);

            let percentValue = window.getComputedStyle(coverImageParent).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
            percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
            let sourceNode = coverImageParent.querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
            if (sourceNode) coverImageParent.style.setProperty("--customNodeBorderImageWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
        }
        coverImageParent.classList.add("clsMultiColorParent");
        coverImageParent.style.setProperty("--customItemColor", "var(--accent" + currentIndex + "-color-rgb)", "important");
        if (props.multicoloroverlay && (props.multicoloroverlay == "true" || props.multicoloroverlay == true) && coverImageOverlay) coverImageOverlay.style.backgroundColor = "rgba(var(--node-theme-color),1)";

        if (props.vposition && coverImageParent) {
            let align = props.vposition == "top" || props.vposition == "start" ? "Top" : props.vposition == "center" || props.vposition == "middle" ? "Center" : "Bottom";
            coverImageParent.classList.add("coverAlign" + align);
        }

        // if (props.supportsvg) {
        let arrAssets = [];
        let hasSVG = this.sgData[currentIndex].coverimage.includes(".svg");
        // let path = this.sgData[currentIndex].coverimage.includes(".svg") ? this.sgData[currentIndex].coverimage : "genericassets/illustrations/industry_agnostic/breaker_slide/breaker_slide_1.svg";
        // this.sgData[currentIndex].coverimage = path;

        if (props.supportsvg && props.supportsvg == "false" && hasSVG) {
            this.sgData[currentIndex].coverimage = this.appStaticURL + "genericassets/placeholderimages/coverimage.jpg";
            this.sgParent.removeAttribute("data-svgsupport");
            hasSVG = false;
            if (this.sgParent.parentElement.parentElement) {
                let slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
                if (slideDomContentGroup.getElementsByTagName("coverimage").length > 0) slideDomContentGroup.getElementsByTagName("coverimage")[0].setAttribute("data-src", this.sgData[currentIndex].coverimage);
            }
        }

        if (hasSVG == true) {
            arrAssets.push({ url: this.sgData[currentIndex].coverimage, id: "svgdata", type: "SVG", parent: coverImageParent });
            this.arrCommonAssets.push({ array: arrAssets, callback: this.assetsLoadComplete });
        }

        let svgElementDiv = assetParent.querySelector("[id='svgElementDiv']");
        let coverimage = assetParent.querySelector("[data-target-id='coverimage']");
        if (svgElementDiv && coverimage) {
            svgElementDiv.style.display = hasSVG ? "flex" : "none";
            coverimage.style.display = hasSVG ? "none" : "flex";
        }
        // } else if (this.sgData[currentIndex].coverimage.includes(".svg")) {
        //     this.sgData[currentIndex].coverimage = this.appStaticURL + "genericassets/placeholderimages/coverimage.jpg";
        //     let svgElementDiv = this.sgParent.querySelector("[id='svgElementDiv']");
        //     let coverimage = this.sgParent.querySelector("[data-target-id='coverimage']");
        //     if (svgElementDiv) svgElementDiv.style.display = "none";
        //     if (coverimage) {
        //         coverimage.style.display = "block";
        //         coverimage.src = this.sgData[currentIndex].coverimage;
        //     }
        // }
        if (props.imageurl && coverImageParent) {
            let coverimage = coverImageParent.querySelector("[data-target-id='coverimage']");
            coverimage.src = this.appStaticURL + props.imageurl;
            this.specialGraphicsUtils.updateImageReSize(coverimage.getAttribute("data-width"), coverimage.getAttribute("data-height"), coverimage);
        }
        if (props.contentBG) {
            let arrAssets = [];
            arrAssets.push({ parent: coverImageParent, type: "svg", url: props.contentBG.value, id: props.contentBG.id });
            this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
        }
        if (props.resize && props.resize == "enable" && coverImageParent && coverImageParent.querySelector("[data-target-id='coverimage']")) {
            let imgNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            // imgNode.setAttribute("imageresize", "enable");
            coverImageParent.setAttribute("imageresize", "enable");
            this.sgParent.setAttribute("imageresizenode", "enable");
            let imagesizeFromProp = props.imagesize ? props.imagesize : "large";
            let coverimageSize = this.sgData[currentIndex] && this.sgData[currentIndex].coverimagesize ? this.sgData[currentIndex].coverimagesize : imagesizeFromProp;
            if (coverimageSize && coverImageParent) {
                //Implement image size change from floter
                // let multipleValue = coverimageSize == "small" ? 0.4 : coverimageSize == "medium" ? 0.7 : coverimageSize == "large" ? 1 : parseFloat(coverimageSize);
                let multipleValue = this.specialGraphicsUtils.getImageSizeSML(coverimageSize);
                let largeW = parseFloat(coverImageParent.getAttribute("data-largewidth"));
                let largeH = parseFloat(coverImageParent.getAttribute("data-largeheight"));
                if (isNaN(largeW)) largeW = parseFloat(window.getComputedStyle(coverImageParent).width);
                if (isNaN(largeW)) largeW = parseFloat(coverImageParent.style.width);
                if (isNaN(largeH)) largeH = parseFloat(window.getComputedStyle(coverImageParent).height);
                if (isNaN(largeH)) largeH = parseFloat(coverImageParent.style.height);
                let newW = largeW * (imagePosition == "left" || imagePosition == "right" ? multipleValue : 1);
                let newH = largeH * (imagePosition == "top" || imagePosition == "bottom" ? multipleValue : 1);

                if (newW > 0) coverImageParent.style.width = newW + "px";
                if (newH > 0) coverImageParent.style.height = newH + "px";

                let direction = "leftRight";
                if (imagePosition == "top" || imagePosition == "bottom") {
                    let largeH = parseFloat(coverImageParent.getAttribute("data-largeheight"));
                    if (isNaN(largeH)) {
                        let oldMinH = coverImageParent.style.minHeight;
                        coverImageParent.style.minHeight = coverImageParent.style.height;
                        largeH = parseFloat(window.getComputedStyle(coverImageParent).height);
                        coverImageParent.style.minHeight = oldMinH;
                    }
                    if (isNaN(largeH)) largeH = parseFloat(coverImageParent.style.height);
                    direction = "topBottom";
                    coverImageParent.setAttribute("imageresize_min", largeH * 0.35);
                    coverImageParent.setAttribute("imageresize_max", largeH);
                } else {
                    coverImageParent.setAttribute("imageresize_min", largeW * 0.35);
                    coverImageParent.setAttribute("imageresize_max", largeW);
                }
                coverImageParent.setAttribute("imageresize_direction", direction);
                coverImageParent.setAttribute("imageresize_position", imagePosition);
            }
        }
        if (this.sgData[currentIndex] && this.sgData[currentIndex]["coverimagedragvalue"]) {
            if (imagePosition == "left" || imagePosition == "right") coverImageParent.style.width = this.sgData[currentIndex]["coverimagedragvalue"] + "px";
            if (imagePosition == "bottom" || imagePosition == "top") coverImageParent.style.height = this.sgData[currentIndex]["coverimagedragvalue"] + "px";
        }
        // if (this.sgData[currentIndex] && this.sgData[currentIndex]["coverimageoverlayshow"]) {
        //     let overlayNode = coverImageParent.querySelector("[data-nodetype='imageOverlay']");
        //     if (overlayNode && this.sgData[currentIndex]["coverimageoverlayshow"] == "false") overlayNode.style.display = "none";
        // }

        //Image overlay check
        let imageHolder = coverImageParent?.querySelector("[data-nodetype='imageHolder']");
        let overlayNode = coverImageParent?.querySelector("[data-nodetype='imageOverlay']");
        if (imageHolder) imageHolder.removeAttribute("data-isoverlay");
        // if (overlayNode) overlayNode.style.display = "none";
        //Setting old overlay to new style
        if (this.sgData[currentIndex] && overlayNode && this.sgData[currentIndex]["coverimageoverlayshow"]) {
            overlayNode.style.display = this.sgData[currentIndex]["coverimageoverlayshow"] == "true" ? "block" : "none";
            if (imageHolder && this.sgData[currentIndex]["coverimageoverlayshow"] == "true") imageHolder.setAttribute("data-isoverlay", "true");
        }

        if (this.objDataToSG?.imageOverlayProps && overlayNode) {
            let moodImageProps = this.objDataToSG.imageOverlayProps;
            if (moodImageProps.support == "false" || moodImageProps.support == false) overlayNode.setAttribute("overlaysupport", false);
        }

        //If overlay not support by style we have disable by setiing display none
        // if (overlayNode?.hasAttribute("overlaysupport") && overlayNode?.getAttribute("overlaysupport") == "false") overlayNode.style.display = "none";

        // let captionPosition = this.sgData[currentIndex].coverimagecaptionposition ? this.sgData[currentIndex].coverimagecaptionposition : props.captionposition ? props.captionposition : "bottomleft";
        // if (captionPosition && coverImageParent && coverImageParent.querySelector("[id*='imageCaption']")) {
        //     let imageCaption = coverImageParent.querySelector("[id*='imageCaption']");
        //     let cls =
        //         captionPosition == "topleft" || captionPosition == "captionTL"
        //             ? "captionTL"
        //             : captionPosition == "topright" || captionPosition == "captionTR"
        //             ? "captionTR"
        //             : captionPosition == "bottomright" || captionPosition == "captionBR"
        //             ? "captionBR"
        //             : "captionBL";
        //     imageCaption.classList.remove("captionTL");
        //     imageCaption.classList.remove("captionTR");
        //     imageCaption.classList.remove("captionBL");
        //     imageCaption.classList.remove("captionBR");
        //     imageCaption.classList.add(cls);
        // }
        this.specialGraphicsUtils.setImageCaptionPosition(coverImageParent, currentIndex, this.sgData, props);
    } else if (this.slideContent) {
        this.slideContent.classList.remove("fixedlightText");
        this.slideContent.classList.remove("fixeddarkText");
    }
};
GenericSpecialgraphics.prototype.getImageProperty = function (currentIndex) {
    let mainProps = currentIndex == 0 ? this.getIntroProps() : this.getProps();

    let imageProperty = mainProps && mainProps.image ? mainProps.image : null;
    if (mainProps) {
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (mainProps["image" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                imageProperty = mainProps["image" + ind];
            }
        }
    }
    return imageProperty;
};
GenericSpecialgraphics.prototype.createCommonBgImage = function (parent, currentIndex) {
    if (currentIndex == 0 || currentIndex == 1) {
        let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
        this.createCommonBgImageNode(this.sgParent, props, currentIndex == 0);
        let presetImageParent = this.sgParent.querySelector("[id='commonBgImageParent" + (currentIndex == 0 ? "Intro" : "") + "']");
        if (currentIndex == 1) presetImageParent.style.zIndex = -1;
        let commonImageNode = presetImageParent.querySelector("[id='commonBgImage']");
        let commonVideoNode = presetImageParent.querySelector("[id='commonBgVideo']");
        if (props.commonbg) this.applyCommonBgProps(presetImageParent, commonImageNode, commonVideoNode, props, currentIndex, this.getAssetParent(currentIndex));
    }
};

GenericSpecialgraphics.prototype.applySingleNodeProps = function (currentIndex, textParentId, textNodeId, textProp) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    this.sgParent.setAttribute("singlenode", "true");
    if (textProp && assetParent && assetParent.querySelector("[id='" + textParentId + "']")) {
        let sgTextNodeParent = assetParent.querySelector("[id='" + textParentId + "']");
        let sgTextNode = assetParent.querySelector("[id='" + textNodeId + "']");
        sgTextNodeParent.style.pointerEvents = "auto";
        sgTextNodeParent.style.order = "unset";
        if (textProp.position) this.specialgraphicsPropertyUtils.updatePosition(sgTextNodeParent, textProp.position);
        if (textProp.maxwidth) sgTextNodeParent.style.maxWidth = textProp.maxwidth + (textProp.maxwidth.includes("px") || textProp.maxwidth.includes("%") ? "" : "px");
        if (textProp.maxheight) {
            let mh = textProp.maxheight + (textProp.maxheight.includes("px") || textProp.maxheight.includes("%") ? "" : "px");
            sgTextNodeParent.style.maxHeight = mh;
            sgTextNode.setAttribute("data-maxheight", mh);
        }
        if (textProp.positionvalue) sgTextNodeParent.style.position = textProp.positionvalue;
        else sgTextNodeParent.style.position = "relative";
        if (textProp.padding) this.specialgraphicsPropertyUtils.updatePadding(textProp.padding, sgTextNodeParent, true);
        if (textProp.margin) this.specialgraphicsPropertyUtils.updateMargin(textProp.margin, sgTextNodeParent);
        if (textProp.zorder) sgTextNodeParent.style.zIndex = textProp.zorder;
        sgTextNode.classList.remove("titleColorBg");
        sgTextNode.classList.remove("subtitleColorBg");
        sgTextNode.classList.remove("transparentBg");
        if (textProp.support && textProp.support == "parent") {
            sgTextNode.setAttribute("data-support", "parent");
            this.createTextElement(sgTextNodeParent.parentElement, currentIndex);
            sgTextNode.setAttribute("data-parentid", sgTextNodeParent.parentElement.id);
        } else sgTextNode.removeAttribute("data-support");
        if (textProp.color) sgTextNode.classList.add(textProp.color);
        else sgTextNode.classList.add("transparentBg");

        if (textProp.titlecustomcolor) sgTextNode.style.setProperty("color", "rgba(var(--" + textProp.titlecustomcolor + "-color-rgb),1)", "important");
        if (textProp.bgcolor) sgTextNodeParent.style.backgroundColor = "rgba(var(--" + textProp.bgcolor + "-color-rgb),1)";
        if (textProp.bgshadow) sgTextNodeParent.style.boxShadow = textProp.bgshadow;
        if (textProp.contrast) this.applyContrastToText(sgTextNode, textProp);
        if (textProp.halign) {
            let alignValue = textProp.halign == "end" || textProp.halign == "right" ? "flex-end" : textProp.halign == "center" || textProp.halign == "middle" ? "center" : "flex-start";
            let align = textProp.halign == "end" || textProp.halign == "right" ? "end" : textProp.halign == "center" || textProp.halign == "middle" ? "center" : "start";
            assetParent.style.setProperty("--textAlign", align);
            assetParent.style.setProperty("--textJustifyContent", alignValue);
        }
        if (textProp.valign) {
            let alignValue = textProp.valign == "bottom" || textProp.valign == "end" ? "flex-end" : textProp.valign == "center" || textProp.valign == "middle" ? "center" : "flex-start";
            sgTextNodeParent.style.alignItems = alignValue;
        }
        if (textProp.opacity) {
            sgTextNodeParent.style.opacity = textProp.opacity;
            this.specialGraphicsUtils.setOpacityAttribute(sgTextNodeParent);
        }
        if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(sgTextNode);
    }
};
GenericSpecialgraphics.prototype.changeVariation = function (slideDomContentGroup, updateOnlyVariation = false, updatePosition = true) {
    if (this.isPreviewMode == false || !this.isPreviewMode) {
        let animationDIV = this.sgParent.parentElement.parentElement;
        let fromVariationChangeOP = animationDIV.hasAttribute("fromop") && animationDIV.getAttribute("fromop") == "variationchange";
        let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
        this.updateIntroVisibility();
        let arrOldDisplay = [];
        for (let i = 0; i < assetParents.length; i++) {
            let textParent = this.sgParent.querySelector("[id='lytAssetTextParent" + i + "']");
            if (!textParent) textParent = this.sgParent.querySelector("[id='textFallNode" + (i + 1) + "']");
            let assetParentFinal = textParent ? textParent : assetParents[i];
            if (i == 0 && this.sgParent.querySelector("[id='introParent']")) assetParentFinal = this.sgParent.querySelector("[id='introParent']");
            let subTitleNode = assetParentFinal.querySelector("[id*='sgSubTitleNode']");
            arrOldDisplay.push(subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "");
        }
        //Device change
        if (this.changeDeviceProperties && fromVariationChangeOP) this.changeDeviceProperties();

        for (let i = 0; i < assetParents.length; i++) {
            let textParent = this.sgParent.querySelector("[id='lytAssetTextParent" + i + "']");
            if (!textParent) textParent = this.sgParent.querySelector("[id='textFallNode" + i + "']");
            let assetParentFinal = textParent ? textParent : assetParents[i];
            if (i == 0 && this.sgParent.querySelector("[id='introParent']")) assetParentFinal = this.sgParent.querySelector("[id='introParent']");
            let subTitleNode = assetParentFinal.querySelector("[id*='sgSubTitleNode']");
            let oldDisplay = arrOldDisplay[i] != undefined && arrOldDisplay[i] != null ? arrOldDisplay[i] : subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "";

            // if (textParent?.id?.includes("textFallNode")) this.specialGraphicsUtils.changeVariation(assetParents[i], slideDomContentGroup, i);
            // else
            this.specialGraphicsUtils.changeVariation(assetParentFinal, slideDomContentGroup, i);

            //Updating image positions for all images
            if (updatePosition) this.specialGraphicsUtils.updateImagePositions(assetParentFinal);

            if (updateOnlyVariation == false) {
                let titleNode = assetParentFinal.querySelector("[id*='sgTitleNode']");
                let newDisplay = subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "";
                if (titleNode && subTitleNode && newDisplay != oldDisplay && this.fontData.title.length <= 2) {
                    let isSubtitleEnabled = window.getComputedStyle(subTitleNode)["display"] == "none" ? false : true;
                    let isIntro = assetParents[i].classList.contains("introSlide") == true ? true : false;
                    titleNode.classList.remove(this.fontData[(isIntro ? "intro" : "") + "title"]);
                    titleNode.classList.remove(this.fontData[(isIntro ? "intro" : "") + "titleNoSubtitle"]);

                    this.specialGraphicsUtils.removeAllFontClass(titleNode);

                    let fontClass = isSubtitleEnabled == false ? this.fontData[(isIntro ? "intro" : "") + "titleNoSubtitle"] : this.fontData[(isIntro ? "intro" : "") + "title"];
                    if (!fontClass) fontClass = isSubtitleEnabled == false ? this.fontData["titleNoSubtitle"] : this.fontData["title"];
                    titleNode.classList.add(fontClass);
                    titleNode.setAttribute("data-font", fontClass);
                    titleNode.style.removeProperty("min-height");
                    titleNode.style.removeProperty("max-height");
                    titleNode.style.removeProperty("font-size");

                    titleNode.setAttribute("defaultsize", parseFloat(window.getComputedStyle(titleNode)["font-size"]));
                    if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(titleNode);
                    if (titleNode.hasAttribute("user-font-size")) {
                        this.specialGraphicsUtils.removeAllFontClass(titleNode);
                        titleNode.classList.add(titleNode.getAttribute("user-font-size"));
                        // titleNode.style.setProperty("font-size", titleNode.getAttribute("user-font-size") + "px", "important");
                    }
                    this.specialGraphicsUtils.doCheckMaxHeight(titleNode, this.sgParent);
                    this.specialGraphicsUtils.doFontFitForCss(titleNode, this.sgParent);
                }
                this.updateHeightForText(assetParentFinal);
                this.onTextChangeForAllNodes(assetParentFinal, i);
                let textInnerParentNode = assetParentFinal.querySelector("[id='textInnerParentNode']");
                this.textElementPositioning(assetParentFinal, textInnerParentNode, i);
            }
            // Check and apply Flip & bleed options
            // this.specialGraphicsUtils.checkAndApplyFlipBleed(assetParentFinal, this.sgParent, this.metaData, this.getProps());
            this.applyImageBleedCommon(assetParentFinal);
        }
        this.updatenavFloater();
        this.checkShapeDependency(this.currentNodeIndex - 1);
        // if (this.updateResizer && this.sgParent.hasAttribute("imageresizenode")) this.updateResizer(this.currentNodeIndex - 1);
        if (this.updateResizer) this.updateResizer(this.currentNodeIndex - 1);
    }
};
GenericSpecialgraphics.prototype.updateIntroVisibility = function (moveToStart = false, index = 0) {
    let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
    if (this.sgParent && this.sgParent.parentElement && this.sgParent.parentElement.parentElement && assetParents.length > 0) {
        let animationDIV = this.sgParent.parentElement.parentElement;
        let showIntro = animationDIV.getAttribute("data-ogdata-finalshow_0")?.split(",")?.includes("intro") ? "true" : "false";
        if (showIntro == "false" && assetParents[0].classList.contains("introSlide")) {
            if (animationDIV.hasAttribute("inlinefloaterchange") && animationDIV.getAttribute("inlinefloaterchange") == "true") {
            } else {
                assetParents[0].style.display = "none";
                this.currentNodeIndex = 2;
                this.floaterNavigation(0);
            }
        } else {
            assetParents[0].style.removeProperty("display");
            if (moveToStart == true) {
                this.currentNodeIndex = index;
                this.floaterNavigation(0);
            }
        }
    }
};
GenericSpecialgraphics.prototype.floaterNavigation = function (index, type = "") {
    let isPreview = this.isPreviewMode && this.isPreviewMode == true ? true : false;
    this.currentNodeIndex = this.currentNodeIndex + index;
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    let commonBgImageParent = this.sgParent.querySelector("[id='commonBgImageParent']");
    let commonBgImageParentIntro = this.sgParent.querySelector("[id='commonBgImageParentIntro']");
    let carouselPhParent = this.sgParent.querySelector("[id='placeholderCommonParent']");
    let commonCarouselParent = this.sgParent.querySelector("[id='commonCarouselParent']");
    for (let i = 0; i < this.sgData.length + 1; i++) {
        let currentNode = this.sgParent.querySelector("[id='assetParent" + i + "']");
        if (currentNode && currentNode.id != "assetParent0") currentNode.style.removeProperty("display");
        if (currentNode) currentNode.classList.remove("carousel4hide");
        if (this.currentNodeIndex - 1 == i && currentNode) {
            currentNode.style.opacity = 1;
            let isVideo = this.sgParent.hasAttribute("data-isvideo");
            if (!isVideo) currentNode.style.pointerEvents = "auto";
            else currentNode.style.pointerEvents = "none";
            currentNode.style.setProperty("--textPointerEvent", "auto");
            if (isPreview == false && this.isPresent == false) this.onTextChangeForAllNodes(currentNode, i);
            if (type && type == "type4") currentNode.style.removeProperty("opacity");
            currentNode.removeAttribute("active");
        } else if (currentNode) {
            currentNode.setAttribute("active", "false");
            currentNode.style.opacity = 0;
            let isVideo = this.sgParent.hasAttribute("data-isvideo");
            if (!isVideo) currentNode.style.pointerEvents = "none";
            else currentNode.style.pointerEvents = "none";
            currentNode.style.setProperty("--textPointerEvent", "none");
            if (type && type == "type4") currentNode.style.removeProperty("opacity");
        }
        if (deviceImageParentNode) {
            deviceImageParentNode.style.opacity = this.currentNodeIndex - 1 == 0 ? 0 : 1;
            if (!deviceImageParentNode.hasAttribute("device")) {
                deviceImageParentNode.style.pointerEvents = this.currentNodeIndex - 1 == 0 ? "none" : "auto";
                if (deviceImageParentNode.getElementsByTagName("video").length > 0) deviceImageParentNode.getElementsByTagName("video")[0].style.pointerEvents = this.currentNodeIndex - 1 == 0 ? "none" : "auto";
            }
        }
        if (commonBgImageParent) commonBgImageParent.style.opacity = this.currentNodeIndex - 1 == 0 ? 0 : 1;
        if (commonBgImageParentIntro) commonBgImageParentIntro.style.opacity = this.currentNodeIndex - 1 == 0 ? 1 : 0;
        if (carouselPhParent) carouselPhParent.style.opacity = this.currentNodeIndex - 1 == 0 ? 0 : 1;
        if (commonCarouselParent && !this.isPlayAnimation) commonCarouselParent.style.opacity = this.currentNodeIndex - 1 == 0 ? 0 : 1;

        if ((type && type != "type4") || !type) {
            let lytCommonParent = this.sgParent.querySelector("[id='lytCommonParent']");
            if (lytCommonParent && this.isPlayAnimation == false) {
                lytCommonParent.style.opacity = this.currentNodeIndex - 1 == 0 ? 0 : 1;
                lytCommonParent.parentElement.style.pointerEvents = this.currentNodeIndex - 1 == 0 ? "none" : "auto";
            }
        }
    }
    if (isPreview == false) {
        this.checkShapeDependency(this.currentNodeIndex - 1);
        this.updatenavFloater();
        this.eventManager.dispatch("positionchangecallback", this.currentNodeIndex + (type == "type4" ? -1 : -1));
    }
    if (this.isPlayAnimation == false && this.updateResizer && this.sgParent.hasAttribute("imageresizenode")) this.updateResizer(this.currentNodeIndex - 1);
    if (this.isPlayAnimation == false && this.floaterNavigationCallback) this.floaterNavigationCallback();
};

GenericSpecialgraphics.prototype.updatenavFloater = function () {
    if (this.isPlayAnimation == false && this.isPresent != true) {
        let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
        if (assetParent0 && assetParent0.classList.contains("introSlide") && this.updateNavFloaterIndex) {
            let isIntroHide = this.sgParent?.parentElement?.parentElement?.getAttribute("data-ogdata-finalhide_0")?.split(",")?.includes("intro");
            let isVisible = isIntroHide ? -1 : 0;
            if (this.introType && (this.introType == "slidetop" || this.introType == "insidecontent")) isVisible = -1;
            if (assetParent0.hasAttribute("hide") && assetParent0.getAttribute("hide") == "true") isVisible = -1;
            let slideID = this.slideContent && this.slideContent.id ? this.slideContent.id : null;
            this.updateNavFloaterIndex(this.currentNodeIndex + isVisible, slideID, isVisible, this.currentNodeIndex - 1 + isVisible);
        }
    }
};

GenericSpecialgraphics.prototype.initPresentSG = function (slideContent) {
    let hasEmptyIntro = this.checkIntroAnimation();
    let specialgraphicsParent = slideContent && slideContent.querySelector("[id='specialgraphicsParent']") ? slideContent.querySelector("[id='specialgraphicsParent']") : null;
    if (specialgraphicsParent) specialgraphicsParent.setAttribute("hasemptyintro", hasEmptyIntro);
    if (slideContent && slideContent.querySelector("[id='deviceImageNode']")) {
        let deviceParent = slideContent.querySelector("[id='deviceImageNode']");
        if (deviceParent.hasAttribute("svgid") && deviceParent.querySelector("[id='" + deviceParent.getAttribute("svgid") + "']")) {
            let svgId = deviceParent.getAttribute("svgid");
            let newSvgId = deviceParent.getAttribute("svgid") + "-present";
            let cliPathNode = deviceParent.querySelector("[id='" + svgId + "']");
            let arrImages = slideContent.querySelectorAll("[id*='coverParent']");
            if (arrImages.length > 0) {
                // console.log("Applying new Clippath");
                deviceParent.setAttribute("svgid", newSvgId);
                cliPathNode.id = newSvgId;
                for (let a = 0; a < arrImages.length; a++) {
                    if (arrImages[a].style.clipPath && arrImages[a].style.clipPath.includes(svgId)) arrImages[a].style.clipPath = "url(#" + newSvgId + ")";
                }
            }
        }
    }
    let lottieParent = slideContent?.querySelectorAll("[data-lottie*='/']");
    for (let a = 0; a < lottieParent.length; a++) {
        let arrAssets = [{ type: "json", url: lottieParent[a].getAttribute("data-lottie"), id: "commonbglottie", parent: lottieParent[a] }];
        // this.arrCommonAssets.push({ array: arrAssets, callback: this.lottieLoadCallback });
        this.loadAssets(arrAssets, this.lottieLoadCallback, this.assetError);
    }
};

GenericSpecialgraphics.prototype.gotoAndStopFirstNode = function (completeCallback, type, slideContent, indexValue = -1) {
    //Re-applying image contrast
    this.reApplyContrast();

    let textBaseParentNode = this.sgParent.querySelectorAll("[id*='textBaseParentNode']");
    for (let a = 0; a < textBaseParentNode.length; a++) {
        textBaseParentNode[a].style.overflow = "unset";
    }

    let hasEmptyIntro = this.checkIntroAnimation();
    let isCarousel = this.introType != null && this.introType != undefined;
    this.currentNodeIndex = indexValue > -1 ? indexValue : this.isFromLastSlide == true && isCarousel == false ? this.sgData.length : hasEmptyIntro == true ? 2 : 1;
    this.floaterNavigation(0);
    this.eventManager.dispatch("positionchangecallback", this.currentNodeIndex - 1);

    if (hasEmptyIntro && this.getAssetParent(0)) {
        this.getAssetParent(0).style.display = "none";
        let introCommonBG = this.sgParent.querySelector("[id='commonBgImageParentIntro']");
        if (introCommonBG) introCommonBG.style.display = "none";
    }
    if (hasEmptyIntro && this.getAssetParent(1)) this.getAssetParent(1).removeAttribute("active");
    if (!hasEmptyIntro && this.getAssetParent(0)) this.getAssetParent(0).removeAttribute("active");

    this.sgParent.style.opacity = 1;
    if (hasEmptyIntro == false && this.getAssetParent(1)) this.getAssetParent(1).setAttribute("playshapeanimation", "false");
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1);
};
GenericSpecialgraphics.prototype.hideAnimation = function (completeCallback) {
    if (this.isHeroImage() != true) this.updateShowHideInfo(this.currentNodeIndex - 1, false);
    else if (this.currentNodeIndex == 1) this.currentNodeIndex = this.currentNodeIndex + 1;
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1, "moodsutil", true);
};
GenericSpecialgraphics.prototype.updateShowHideInfo = function (index, isShow = true) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + index + "']");
    assetParent.style.opacity = 1;
    assetParent.classList.remove(isShow == true ? "hidesg" : "showsg");
    assetParent.classList.add(isShow == true ? "showsg" : "hidesg");
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (this.currentNodeIndex == 1 && this.isPlayAnimation == false && deviceImageParentNode) deviceImageParentNode.style.opacity = 0;
    else if (deviceImageParentNode && this.currentNodeIndex != 1) deviceImageParentNode.style.opacity = 1;

    let lytCommonParent = this.sgParent.querySelector("[id='lytCommonParent']");
    if (this.currentNodeIndex == 1 && this.isPlayAnimation == false && lytCommonParent) lytCommonParent.style.opacity = 0;
    else if (lytCommonParent && this.currentNodeIndex != 1) lytCommonParent.style.opacity = 1;

    let placeholderCommonParent = this.sgParent.querySelector("[id='placeholderCommonParent']");
    if (this.currentNodeIndex == 1 && this.isPlayAnimation == false && placeholderCommonParent) placeholderCommonParent.style.opacity = 0;
    else if (placeholderCommonParent && this.currentNodeIndex != 1) placeholderCommonParent.style.opacity = 1;

    if (!this.isPlayAnimation && this.currentNodeIndex > 1) {
        let commonCarouselParent = this.sgParent.querySelector("[id='commonCarouselParent']");
        if (commonCarouselParent) commonCarouselParent.style.opacity = 1;
    }

    // let commonCarouselParent = this.sgParent.querySelector("[id='commonCarouselParent']");
    // if (this.currentNodeIndex == 1 && this.isPlayAnimation == false && commonCarouselParent) commonCarouselParent.style.opacity = 0;
    // else if (commonCarouselParent && this.currentNodeIndex != 1) commonCarouselParent.style.opacity = 1;
};
GenericSpecialgraphics.prototype.next = function (completeCallback) {
    let oldIndex = this.currentNodeIndex - 1 < 0 ? 0 : this.currentNodeIndex - 1;
    this.currentNodeIndex = this.currentNodeIndex + 1;
    if (this.currentNodeIndex > this.sgData.length) return;

    this.sgParent.removeAttribute("hasemptyintro");

    //HIDE ANIMATION
    this.updateShowHideInfo(oldIndex, false);
    this.sgParent.setAttribute("dotransition", "false");
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", completeCallback, this.isPlayAnimation, this.eventManager, oldIndex, "moodsutilintermediate");

    let hideAP = this.getAssetParent(oldIndex);
    if (hideAP) {
        hideAP.style.setProperty("--textPointerEvent", "none", "important");
        hideAP.style.setProperty("pointer-events", "none", "important");
    }

    if (this.currentNodeIndex > 1) this.showDevice(true);
    //SHOW ANIMATION
    this.updateShowHideInfo(this.currentNodeIndex - 1, true);
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1, "moodsutilintermediate");
    let showAP = this.getAssetParent(this.currentNodeIndex - 1);
    if (showAP) {
        showAP.removeAttribute("active");
        showAP.style.setProperty("--textPointerEvent", "auto", "important");
        showAP.style.setProperty("pointer-events", "auto", "important");
    }
    if (this.isPlayAnimation == false && this.currentNodeIndex == 2) {
        let assetParent = this.sgParent.querySelector("[id='assetParent0']");
        assetParent.style.opacity = 0;
    }
};
GenericSpecialgraphics.prototype.showDevice = function (showDevice = true) {
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (deviceImageParentNode) {
        deviceImageParentNode.style.opacity = showDevice == false ? 0 : 1;
        deviceImageParentNode.style.pointerEvents = showDevice == false ? "none" : "auto";
    }
    let commonBG = this.sgParent.querySelector("[id='commonBgImageParent']");
    if (commonBG) commonBG.style.opacity = showDevice == false ? 0 : 1;
    if (this.sgParent.querySelector("[id='deviceImageNode']") && showDevice == true) this.sgParent.querySelector("[id='deviceImageNode']").style.removeProperty("opacity");
    if (this.sgParent.querySelector("[id='deviceImageNode1']") && showDevice == true) this.sgParent.querySelector("[id='deviceImageNode1']").style.removeProperty("opacity");
    if (this.sgParent.querySelector("[id='videoElement']") && showDevice == true) this.sgParent.querySelector("[id='videoElement']").style.removeProperty("opacity");
    if (this.sgParent.querySelector("[id='secondaryAssetNode']") && showDevice == true) this.sgParent.querySelector("[id='secondaryAssetNode']").style.removeProperty("opacity");
};
GenericSpecialgraphics.prototype.previous = function (completeCallback) {
    let oldIndex = this.currentNodeIndex - 1 < 0 ? 0 : this.currentNodeIndex - 1;
    this.currentNodeIndex = this.currentNodeIndex - 1;

    this.sgParent.removeAttribute("hasemptyintro");

    let hasEmptyIntro = this.checkIntroAnimation();
    if (hasEmptyIntro == true && this.currentNodeIndex <= 1) return false;

    if (this.currentNodeIndex < 1) return;
    if (this.sgParent.querySelector("[id='assetParent0']").classList.contains("introSlide") && oldIndex == 1) {
        this.sgParent.querySelector("[id='assetParent1']").setAttribute("hashide", "true");
        if (this.sgParent.querySelector("[id='deviceImageNode']")) this.sgParent.querySelector("[id='deviceImageNode']").style.opacity = 1;
        if (this.sgParent.querySelector("[id='deviceImageNode1']")) this.sgParent.querySelector("[id='deviceImageNode1']").style.opacity = 1;
        if (this.sgParent.querySelector("[id='videoElement']")) this.sgParent.querySelector("[id='videoElement']").style.opacity = 1;
        if (this.sgParent.querySelector("[id='secondaryAssetNode']")) this.sgParent.querySelector("[id='secondaryAssetNode']").style.opacity = 1;
    }
    //HIDE ANIMATION
    this.updateShowHideInfo(oldIndex, false);
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", completeCallback, this.isPlayAnimation, this.eventManager, oldIndex, "moodsutilintermediate");

    let hideAP = this.getAssetParent(oldIndex);
    if (hideAP) {
        hideAP.style.setProperty("--textPointerEvent", "none", "important");
        hideAP.style.setProperty("pointer-events", "none", "important");
    }

    let newAssetparent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    //SHOW ANIMATION
    this.updateShowHideInfo(this.currentNodeIndex - 1, true);
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1, "moodsutilintermediate");
    if (newAssetparent) {
        newAssetparent.style.setProperty("--textPointerEvent", "auto", "important");
        newAssetparent.style.setProperty("pointer-events", "auto", "important");
    }
};
GenericSpecialgraphics.prototype.checkIntroAnimation = function () {
    if (this.isHeroImage() == true) return true;
    if (this.sgParent && this.sgParent.parentElement && this.sgParent.parentElement.parentElement) {
        let animationDIV = this.sgParent.parentElement.parentElement;
        let showIntro = animationDIV.getAttribute("data-ogdata-finalshow_0")?.split(",")?.includes("intro") ? "true" : "false";
        if (showIntro == "false") return true;
    }
    let assetParent = this.getAssetParent(0);
    if (assetParent && assetParent.classList.contains("introSlide")) {
        let title = assetParent.querySelector("[id*='sgTitleNode']");
        let subTitle = assetParent.querySelector("[id*='sgSubTitleNode']");
        let titleLabel = assetParent.querySelector("[id*='sgTitleLabelNode']");
        if (title && title.innerText.trim().length == 0 && subTitle && subTitle.innerText.trim().length == 0 && titleLabel && titleLabel.innerText.trim().length == 0) return true;
    }
    if (assetParent.style.display == "none") return true;
    return false;
};
GenericSpecialgraphics.prototype.isHeroImage = function () {
    if (this.sgParent && this.sgParent.parentElement && this.sgParent.parentElement.parentElement && this.sgData.length < 2) {
        let count = this.sgParent.parentElement.parentElement.getAttribute("data-nodecount");
        if (count == "1") return true;
    }
};

GenericSpecialgraphics.prototype.updateImage = function (elementId, src, nodeIndex = null, resizeImage = false, imgNodeFromFn) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + (nodeIndex != null ? nodeIndex : this.currentNodeIndex - 1) + "']");
    let imageNode = assetParent ? assetParent.querySelector("[id='" + elementId + "']") : this.sgParent.querySelector("[id='" + elementId + "']");
    if (this.getTargetElement) imageNode = this.getTargetElement(elementId);
    if (imageNode && imageNode.getElementsByTagName("img").length > 0) imageNode = imageNode.getElementsByTagName("img")[0];
    if (imgNodeFromFn) imageNode = imgNodeFromFn;
    if (imageNode && src) {
        imageNode.src = src;
        if (resizeImage) this.specialGraphicsUtils.updateImageReSize(imageNode.getAttribute("data-width"), imageNode.getAttribute("data-height"), imageNode);
        // let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData ? this.metaData : null;
        // let imageID = imageNode.id.includes("sgAuthorImageNode") ? "authimg" : imageNode.id.toLocaleLowerCase().includes("presetimage") ? "presetimage" : "image";
        // let isNotMainImage = imageNode.id.includes("sgPlaceHolderImageNode") || imageNode.id.includes("sgLogoImageNode") ? false : true;
        // if (isNotMainImage && metaDataBase && metaDataBase.properties && metaDataBase.properties[imageID] && assetParent) {
        //     let props = metaDataBase.properties[imageID];
        //     if (props.contrast && props.contrast == "fullbg" && imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent);
        //     if (props.contrast && props.contrast == "halfbg" && imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent, true);
        // }
        this.updateImageContrastOnChange(imageNode, this.currentNodeIndex - 1);
        let duplicatedImages = assetParent ? assetParent.querySelectorAll("[data-target-id='coverimageduplicate']") : null;
        if (duplicatedImages?.length > 0 && elementId.includes("coverimage")) {
            for (let a = 0; a < duplicatedImages.length; a++) {
                let duplicatedImage = duplicatedImages[a];
                duplicatedImage.src = src;
            }
        }
        if (elementId.toLocaleLowerCase().includes("logo") || elementId.includes("sgPlaceHolderImageNode")) {
            let placeholderCommonParent = this.sgParent.querySelector("[id='placeholderCommonParent");
            imageNode.callback = this.rePositionTextAndElement;
            let type = elementId.includes("sgPlaceHolderImageNode") ? "image" : "logo";
            this.setLogoSizes(placeholderCommonParent || assetParent, type, placeholderCommonParent ? imageNode : null);
        }
    }
};
GenericSpecialgraphics.prototype.updateImageContrastOnChange = function (imageNode, index) {
    let assetParent = this.getAssetParent(index ? index : this.currentNodeIndex - 1);
    let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData ? this.metaData : null;
    let imageID = imageNode.id.includes("sgAuthorImageNode") ? "authimg" : imageNode.id.toLocaleLowerCase().includes("presetimage") ? "presetimage" : "image";
    let isNotMainImage = imageNode.id.includes("sgPlaceHolderImageNode") || imageNode.id.includes("sgLogoImageNode") ? false : true;
    if (isNotMainImage && metaDataBase && metaDataBase.properties && metaDataBase.properties[imageID] && assetParent) {
        let props = metaDataBase.properties[imageID];
        if (props.contrast && props.contrast == "fullbg" && imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent);
        if (props.contrast && props.contrast == "halfbg" && imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent, true);
    }
};
GenericSpecialgraphics.prototype.updateImageResizeOnTypeChange = function (type) {
    let assetParent = this.getAssetParent(this.currentNodeIndex - 1);
    this.setLogoSizes(this.sgParent.querySelector("[id='placeholderCommonParent") || assetParent, type);
    this.textFitOnImageResize();
    this.checkShapeDependency(this.currentNodeIndex - 1);
};
GenericSpecialgraphics.prototype.getAssetParent = function (index) {
    return this.sgParent.querySelector("[id='assetParent" + index + "']");
};
GenericSpecialgraphics.prototype.changeText = function (updatedText, elementId, targetIndex, textType) {
    let assetParent = this.getAssetParent(targetIndex);
    let textParent = this.sgParent.querySelector("[id='lytAssetTextParent" + targetIndex + "']");
    assetParent = textParent ? textParent : assetParent;
    if (assetParent && assetParent.querySelector("[id='" + elementId + "']")) {
        let textNode = assetParent.querySelector("[id='" + elementId + "']");
        textNode = !textNode ? assetParent.querySelector("[id*='" + elementId + "']") : textNode;

        if (textNode) {
            let prefix = textNode.hasAttribute("prefix") ? textNode.getAttribute("prefix") : null;
            let suffix = textNode.hasAttribute("suffix") ? textNode.getAttribute("suffix") : null;
            if (prefix) {
                updatedText = updatedText.replace(prefix, "");
                updatedText = prefix + " " + updatedText;
            }
            if (suffix) {
                updatedText = updatedText.replace(suffix, "");
                updatedText = updatedText + " " + suffix;
            }
            textNode.setAttribute("data-heading", updatedText);
            textNode.setAttribute("data-oldtext", updatedText);
            textNode.setAttribute("data-changetext", "true");
            if (textNode.id.includes("sgSubTitleNode") && updatedText == "") textNode.innerHTML = "<br>";
            else textNode.innerHTML = updatedText;

            this.specialGraphicsUtils.doFontFitForCss(textNode, this.sgParent, null, null, null, true);
            this.specialGraphicsUtils.updateImagePositions(this.sgParent);
        }

        this.checkShapeDependency(targetIndex);
    }
};
GenericSpecialgraphics.prototype.getTargetElement = function (elementID) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    if (assetParent && assetParent.querySelector("[id='" + elementID + "']")) return assetParent.querySelector("[id='" + elementID + "']");
    let introParent = this.sgParent.querySelector("[id='placeholderCommonParent']");
    if (introParent && introParent.querySelector("[id*='phChildParent" + index + "']")) {
        let phChildParent = introParent.querySelector("[id*='phChildParent" + index + "']");
        if (phChildParent?.querySelector("[id*='" + elementID + "']")) return phChildParent.querySelector("[id*='" + elementID + "']");
    }
};

GenericSpecialgraphics.prototype.resetFontDetails = function (elementID, parent, type) {
    let element = parent.querySelector("[id='" + elementID + "']");
    if (element) {
        element.classList.remove("h3");
        element.classList.remove("h4");
        element.classList.add(this.fontData[type]);
        element.style.removeProperty("max-height");
        element.style.removeProperty("min-height");
        element.style.removeProperty("font-size");
        if (element.hasAttribute("user-font-size")) {
            this.specialGraphicsUtils.removeAllFontClass(element);
            element.classList.add(element.getAttribute("user-font-size"));
            // element.style.setProperty("font-size", element.getAttribute("user-font-size") + "px", "important");
        }
        this.specialGraphicsUtils.doFontFitForCss(element, this.sgParent);
    }
};
GenericSpecialgraphics.prototype.updateFloaterOnPreviewEnd = function (index) {
    this.updateIntroVisibility(true, index);
};
GenericSpecialgraphics.prototype.textPositionChangeOperation = function (targetParent, pos) {
    if (targetParent) {
        for (let a = 0; a < targetParent.children.length; a++) {
            if (targetParent.children[a].style.position != "absolute") {
                let element = targetParent.children[a];
                let elementId = element.id;
                pos = pos.replace("sg", "");
                let textAlign = pos == "TL" || pos == "ML" || pos == "BL" ? "start" : pos == "TR" || pos == "MR" || pos == "BR" ? "end" : pos == "TM" || pos == "MM" || pos == "BM" ? "center" : "";
                if (elementId && elementId.includes("placeHolderParent")) {
                    if (element.querySelector("[id='phTextNode']")) element.querySelector("[id='phTextNode']").style.textAlign = textAlign;
                    element = element.querySelector("[id*='logoContentParent']");
                    elementId = element.id;
                }
                if (elementId.includes("logoContentParent")) {
                    if (element.getElementsByTagName("img").length > 0) {
                        let imageNode = element.getElementsByTagName("img")[0];
                        if (!imageNode.hasAttribute("data-oldimagecropalignment")) imageNode.setAttribute("data-oldimagecropalignment", imageNode.getAttribute("data-imagecropalignment"));
                        imageNode.setAttribute(
                            "data-imagecropalignment",
                            pos == "TL" || pos == "ML" || pos == "BL" ? "left" : pos == "TR" || pos == "MR" || pos == "BR" ? "right" : pos == "TM" || pos == "MM" || pos == "BM" ? "center" : imageNode.hasAttribute("data-oldimagecropalignment") ? imageNode.getAttribute("data-oldimagecropalignment") : "center"
                        );
                        imageNode.removeAttribute("data-style");
                        imageNode.removeAttribute("data-csstext");
                        if (imageNode.offsetHeight != 0) this.specialGraphicsUtils.updateImageReSize(imageNode.getAttribute("data-width"), imageNode.getAttribute("data-height"), imageNode);
                    }
                }
            }
        }
        //Text Element positioning after all text's props change
        this.rePositioningTextElement();
        this.checkShapeDependency();
    }
};
GenericSpecialgraphics.prototype.getCurrentIndex = function () {
    return this.currentNodeIndex - 1;
};
GenericSpecialgraphics.prototype.startIndex = function (currentSlideData) {
    return this.specialGraphicsUtils.getStartIndex(currentSlideData, this.sgParent);
};
GenericSpecialgraphics.prototype.focusOutElement = function (elementID) {
    SGBaseClass.prototype.focusOutElement.call(this, elementID);
    try {
        let assetParent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
        let element = assetParent ? assetParent.querySelector("[id=" + elementID + "]") : null;
        if (element) {
            element.setAttribute("focusout", "mannual");
            element.blur();
        }
    } catch (error) {}
};
GenericSpecialgraphics.prototype.setLogoSizes = function (assetParent, placeHolderType = "", newNode) {
    let assetParentNode = assetParent ? assetParent : this.getAssetParent(this.currentNodeIndex - 1);
    if (this.sgParent.querySelector("[id='lytAssetTextParent" + (this.currentNodeIndex - 1) + "']")) assetParentNode = this.sgParent.querySelector("[id='lytAssetTextParent" + (this.currentNodeIndex - 1) + "']");
    if (assetParentNode.id == "placeholderCommonParent" && assetParentNode.querySelector("[id='phChildParent" + (this.currentNodeIndex - 1) + "']")) assetParentNode = assetParentNode.querySelector("[id='phChildParent" + (this.currentNodeIndex - 1) + "']");
    let oldDisplay = assetParentNode ? assetParentNode.style.display : "";
    if (assetParentNode) assetParentNode.style.display = "block";
    let imgNode = newNode ? newNode : assetParentNode ? assetParentNode.querySelector("[id='sgLogoImageNode']") : null;
    if (placeHolderType == "icon") {
        imgNode = assetParentNode ? assetParentNode.querySelector("[id*='phIconSvgNode']") : null;
        this.setLogoSizesOP(imgNode);
    } else if (placeHolderType == "text") {
        imgNode = assetParentNode ? assetParentNode.querySelector("[id*='phTextNode']") : null;
        this.setLogoSizesOP(imgNode);
        this.onTextChangeUpdatePlaceholderNode(imgNode);
    } else {
        if (placeHolderType == "image") imgNode = assetParentNode ? assetParentNode.querySelector("[id='sgPlaceHolderImageNode']") : null;

        if (imgNode && imgNode.complete) {
            this.setLogoSizesOP(imgNode);
        } else if (imgNode) imgNode.addEventListener("load", this.logoLoadCallback);
    }
    if (assetParentNode) assetParentNode.style.display = oldDisplay;
};

GenericSpecialgraphics.prototype.logoLoadCallback = function (event) {
    event.target.removeEventListener("load", this.logoLoadCallback);
    this.setLogoSizesOP(event.target);
};
GenericSpecialgraphics.prototype.setLogoSizesOP = function (imgNode) {
    let logoRatio = this.specialGraphicsUtils.getLogoRatio(imgNode);
    // console.log("LOGO - ratio - " + logoRatio);
    if (!logoRatio) logoRatio = "square";
    if (logoRatio && imgNode) {
        let dummyDom = document.createElement("div");
        dummyDom.classList.add(logoRatio);
        dummyDom.style.position = "absolute";
        dummyDom.style.width = "var(--logoSizeWidth)";
        dummyDom.style.height = "var(--logoSizeHeight)";
        if (imgNode.id.includes("phTextNode")) imgNode.appendChild(dummyDom);
        else imgNode.parentElement.appendChild(dummyDom);
        let w = window.getComputedStyle(dummyDom).width;
        let h = window.getComputedStyle(dummyDom).height;
        if (w != "" && h != "" && w != "0px" && h != "0px") {
            let mainParent = imgNode.parentElement.parentElement.parentElement;
            if (imgNode.id.includes("phTextNode")) mainParent = imgNode.parentElement.parentElement;
            let lgWidth = window.getComputedStyle(dummyDom).getPropertyValue("--logoSizeWidth");
            if (lgWidth?.trim() == "100%") {
                mainParent.style.width = "100%";
                w = window.getComputedStyle(mainParent).width;
            }

            // if (parseInt(w) == imgNode.parentElement.offsetWidth) {
            //     let oldW = mainParent.style.width;
            //     mainParent.style.width = "100%";
            //     w = window.getComputedStyle(mainParent).width;
            //     mainParent.style.width = oldW;
            // }
            imgNode.parentElement.style.setProperty("--logoSizeWidth", w);
            imgNode.parentElement.style.setProperty("--logoSizeHeight", h);
            imgNode.parentElement.setAttribute("data-largewidth", parseFloat(w));
            imgNode.parentElement.setAttribute("data-largeheight", parseFloat(h));

            mainParent.setAttribute("data-largewidth", parseFloat(w));
            mainParent.setAttribute("data-largeheight", parseFloat(h));

            let placeholderimagesize = "medium";
            if (imgNode.parentElement.hasAttribute("data-placeholderimagesize")) placeholderimagesize = imgNode.parentElement.getAttribute("data-placeholderimagesize");
            else if (mainParent.hasAttribute("data-placeholderimagesize")) placeholderimagesize = mainParent.getAttribute("data-placeholderimagesize");
            else {
                let props = this.getProps();
                let property = props && props.placeholderimage ? props.placeholderimage : null;
                placeholderimagesize = property && property.placeholderimagesize ? property.placeholderimagesize : placeholderimagesize;
            }
            // let logoImageSizeValue = placeholderimagesize == "small" ? 0.4 : placeholderimagesize == "medium" ? 0.7 : placeholderimagesize == "large" ? 1 : parseFloat(placeholderimagesize);
            let logoImageSizeValue = this.specialGraphicsUtils.getImageSizeSML(placeholderimagesize);
            w = parseFloat(w) * parseFloat(logoImageSizeValue);
            h = parseFloat(h) * parseFloat(logoImageSizeValue);

            // console.log("LOGO - ratio - " + w+"  -h-  "+h);

            if (imgNode.id.includes("phTextNode")) imgNode.removeChild(dummyDom);
            else imgNode.parentElement.removeChild(dummyDom);

            imgNode.parentElement.parentElement.style.width = w + "px";
            imgNode.parentElement.parentElement.style.height = h + "px";
            mainParent.style.width = w + "px";
            mainParent.style.height = h + "px";
            if (mainParent.id.includes("placeHolderParent")) mainParent.style.minHeight = h + "px";
            imgNode.parentElement.style.width = w + "px";
            imgNode.parentElement.style.height = h + "px";
            imgNode.setAttribute("data-width", w);
            imgNode.setAttribute("data-height", h);
            if (imgNode && imgNode.hasAttribute("data-csstext") && imgNode.getAttribute("data-csstext") != "") {
                var imageDimensionRatio = imgNode.width / imgNode.height;
                var canvasDimensionRatio = w / h;
                if (imageDimensionRatio > canvasDimensionRatio) {
                    imgNode.parentElement.style.height = imgNode.height + "px";
                    imgNode.parentElement.parentElement.style.height = imgNode.height + "px";
                    imgNode.style.setProperty("bottom", 0);
                    imgNode.setAttribute("logosizecropheight", imgNode.height);
                }
            } else if (!imgNode.id.includes("phTextNode")) this.specialGraphicsUtils.updateImageReSize(w, h, imgNode);
            if (imgNode.callback) imgNode.callback();
            imgNode.callback = null;
            if (imgNode.id.includes("phTextNode")) {
                mainParent.style.maxHeight = h + "px";
                mainParent.style.height = "auto";
                mainParent.style.minHeight = "unset";

                mainParent.style.maxWidth = w + "px";
                mainParent.style.width = "auto";

                imgNode.parentElement.style.maxWidth = w + "px";
                imgNode.parentElement.style.width = "auto";

                imgNode.parentElement.style.maxHeight = h + "px";
                imgNode.parentElement.style.height = "auto";
                imgNode.parentElement.style.minHeight = "unset";
            }
        }
    }
};
GenericSpecialgraphics.prototype.rePositionTextAndElement = function () {
    this.onTextChangeForAllNodes();
    this.rePositioningTextElement();
};

GenericSpecialgraphics.prototype.svgLoadCallback = function (responseData) {
    //Loading svg from menu for icon/image background svg global style - only for "contentBackground"
    for (let a = 0; a < responseData.length; a++) {
        let localSvgParent = responseData[a].parent;
        let colorClass = responseData[a] && responseData[a].color ? responseData[a].color : "clsAccentfill";
        if (localSvgParent && localSvgParent.querySelector("[id*='contentBackground']")) {
            let bgNode = localSvgParent.querySelector("[id*='contentBackground']");
            bgNode.classList.remove(colorClass);
            bgNode.classList.add(colorClass);
            var parser = new DOMParser();
            var doc = parser.parseFromString(responseData[a].data, "image/svg+xml");
            bgNode.innerHTML = "";
            bgNode.appendChild(doc.lastChild);
        }
    }
};
GenericSpecialgraphics.prototype.placeholderSvgLoadCallback = function (responseData) {
    //Loading svg from menu for icon/image background svg global style - only for "contentBackground"
    for (let a = 0; a < responseData.length; a++) {
        let localSvgParent = responseData[a].parent;
        let colorClass = responseData[a] && responseData[a].color ? responseData[a].color : "clsAccentfill";
        if (localSvgParent) {
            localSvgParent.classList.remove(colorClass);
            localSvgParent.classList.add(colorClass);
            var parser = new DOMParser();
            var doc = parser.parseFromString(responseData[a].data, "image/svg+xml");
            localSvgParent.innerHTML = "";
            localSvgParent.appendChild(doc.lastChild);
        }
    }
};
GenericSpecialgraphics.prototype.textFitOnImageResize = function (targetIndex) {
    this.onTextChangeForAllNodes(this.sgParent, targetIndex);
    this.rePositioningTextElement(targetIndex);
    this.checkShapeDependency(this.currentNodeIndex - 1);
};

GenericSpecialgraphics.prototype.checkShapeDependency = function (index = -1) {
    if (this.sgParent.hasAttribute("depends") && this.sgParent.getAttribute("depends") == "content") {
        for (let a = 0; a < (index == -1 ? this.sgData.length : 1); a++) {
            let assetParent = this.sgParent.querySelector("[id='assetParent" + (index == -1 ? a : index) + "']");
            // console.log("SG - checking shape height - " + assetParent.id);
            if (assetParent && assetParent.querySelector("[id='shape1']") && assetParent.querySelector("[id='shape1']").hasAttribute("depends")) {
                let shape = assetParent.querySelector("[id='shape1']");
                let parent = shape.parentElement;
                shape.style.height = "auto";
                shape.style.width = "auto";
                let oldH = parent.style.height;
                parent.style.height = "auto";
                let maxWidth = 0;
                for (let b = 0; b < parent.children.length; b++) {
                    if (parent.children[b].offsetWidth > maxWidth) maxWidth = parent.children[b].offsetWidth;
                }
                let elementPadding = this.specialGraphicsUtils.getPadding(parent);
                shape.style.height = parent.offsetHeight + "px";
                shape.style.width = maxWidth + parseFloat(elementPadding.paddingLeft) + parseFloat(elementPadding.paddingRight) + "px";
                parent.style.height = oldH;

                let tp = this.specialGraphicsUtils.getOldPositionClass(parent);
                if (tp) {
                    shape.style.top = tp == "TL" || tp == "TR" || tp == "TM" ? "0px" : "unset";
                    shape.style.bottom = tp == "BL" || tp == "BR" || tp == "BM" ? "0px" : "unset";
                    shape.style.left = tp == "BL" || tp == "TL" || tp == "ML" ? "0px" : "unset";
                    shape.style.right = tp == "BR" || tp == "TR" || tp == "MR" ? "0px" : "unset";
                }
            }
        }
    }
};

// Check and apply Flip & bleed options
GenericSpecialgraphics.prototype.applyImageBleedCommon = function (assetparent, tagName = null) {
    if (assetparent) {
        this.specialGraphicsUtils.checkAndApplyFlipBleed(assetparent, this.sgParent, this.metaData, this.getProps(), tagName);
    } else {
        let arrAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
        for (let a = 0; a < arrAssetParent.length; a++) {
            this.specialGraphicsUtils.checkAndApplyFlipBleed(arrAssetParent[a], this.sgParent, this.metaData, this.getProps(), tagName);
        }
    }
};

"use strict";

function GenericSpecialgraphicsCommon(sgParent, sgData, moodName, metadata, styleName = "", isPlayAnimation = true, textElementData, socialiconsData, fontData, objDataToSG) {
    this.specialGraphicsUtils = new window["SpecialGraphicsUtils"]();
    this.specialGraphicsAnimationUtils = new window["SpecialGraphicsAnimationUtils"]();

    let styleData = {};

    let baseSet = {
        title: "h4",
        titleNoSubtitle: "h3",
        subtitle: "p4",
        label: "p3",
        number: "n1",
        introtitle: "h2",
        introtitleNoSubtitle: "h1",
        introsubtitle: "p3",
        introlabel: "p2",
    };
    baseSet = fontData ? fontData : baseSet;
    styleData.fontData = baseSet;
    this.fontData = JSON.parse(JSON.stringify(baseSet));

    baseSet.titleClass = baseSet.title;
    baseSet.subtitleClass = baseSet.subtitle;
    baseSet.labelClass = baseSet.label;
    baseSet.title = " " + baseSet.title + " ";
    baseSet.subtitle = " " + baseSet.subtitle + " ";
    baseSet.label = " " + baseSet.label + " ";
    baseSet.number = " " + baseSet.number + " ";

    this.sgParent = sgParent;
    this.sgSlideType = this.sgParent.dataset.slidetype;

    //Setting all nodes prompt text here
    styleData.titlePrompt = this.sgSlideType == "textstack" ? "Type a Headline" : "Type an image caption";
    styleData.subTitlePrompt = this.sgSlideType == "textstack" ? "A brief explanation about the headline" : "A brief explanation about the image you have used";
    styleData.titleLabelPrompt = "Title label here";
    styleData.imagecaptionPrompt = "This is image caption text";

    styleData.styleName = styleName;

    this.socialiconsData = socialiconsData;

    this.sgParent.className = "genericspecialgraphics";

    this.isPlayAnimation = isPlayAnimation;
    this.slideContent = objDataToSG && objDataToSG.slide ? objDataToSG.slide : null;
    this.isPreviewMode = objDataToSG && objDataToSG.isPreviewMode ? objDataToSG.isPreviewMode : false;
    this.oldContent = objDataToSG && objDataToSG.isLoadedSlide ? objDataToSG.isLoadedSlide : null;

    this.assetsLoadComplete = this.assetsLoadComplete.bind(this);
    this.onTextChange = this.onTextChange.bind(this);
    this.changeVariation = this.changeVariation.bind(this);
    this.updateHeightForText = this.updateHeightForText.bind(this);
    this.assetError = this.assetError.bind(this);
    this.logoLoadCallback = this.logoLoadCallback.bind(this);
    this.textFitOnImageResize = this.textFitOnImageResize.bind(this);
    this.commonAssetsLoadComplete = this.commonAssetsLoadComplete.bind(this);
    this.updateImageResizeOnTypeChange = this.updateImageResizeOnTypeChange.bind(this);
    this.updateImageContrastOnChange = this.updateImageContrastOnChange.bind(this);

    this.sgSlideType = "imagestack";

    this.isFromLastSlide = metadata ? metadata.isFromLastSlide : false;
    this.currentNodeIndex = this.isFromLastSlide == true ? sgData.length : 1;

    // if (sgParent.hasAttribute("prevIndex")) {
    //     this.currentNodeIndex = parseFloat(sgParent.getAttribute("prevIndex")) + 2;
    //     this.setTargetIndex(this.currentNodeIndex, sgParent);
    // } else
    this.setTargetIndex(0, sgParent);

    this.specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL, this);
    this.specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });

    if (this.slideContent) {
        this.slideContent.classList.remove("darkText");
        this.slideContent.classList.remove("lightText");
        this.slideContent.classList.remove("fixedlightText");
        this.slideContent.classList.remove("fixeddarkText");
    }
    let variSelected = sgParent.parentElement.parentElement.hasAttribute("data-variation-selected") ? sgParent.parentElement.parentElement.getAttribute("data-variation-selected") : false;
    let isIntroEnabled = variSelected && variSelected.includes("intro") ? true : false;
    if (sgData.length > 2 || isIntroEnabled) sgParent.parentElement.parentElement.setAttribute("fulloptions", "true");
    else sgParent.parentElement.parentElement.setAttribute("fulloptions", "false");
    this.deviceModel = "";

    this.assetLoadingCount = 0;
    this.arrCommonAssets = [];
    this.assetsLoading = false;

    SGBaseClass.call(this, sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, this.fontData, "imagestack", styleData, objDataToSG);
    // if (sgParent.hasAttribute("prevIndex")) this.currentNodeIndex = parseFloat(sgParent.getAttribute("prevIndex")) + 2;
}

GenericSpecialgraphicsCommon.prototype = Object.create(SGBaseClass.prototype);

GenericSpecialgraphicsCommon.prototype.setTargetIndex = function (index = 0, sgParent = null) {
    let localParent = sgParent ? sgParent : this.sgParent;
    let animationDIV = localParent && localParent.parentElement && localParent.parentElement.parentElement ? localParent.parentElement.parentElement : null;
    if (animationDIV && animationDIV.id == "animationDIV") animationDIV.setAttribute("data-target-index", index);
};

GenericSpecialgraphicsCommon.prototype.initSpecialGraphicsCreation = function () {
    this.specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL, this);
    this.specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
    if (this.isWidget == false || (this.objDataToSG && this.objDataToSG.menuChange)) {
        this.deviceModel = "";
        if (this.decodeMetaData) {
            let decodedMetaData = this.decodeMetaData(this.sgParent);
            let sgalignment = decodedMetaData.sgalignment;
            let sgorientation = decodedMetaData.sgorientation;
            let sgdevicemodel = decodedMetaData.sgdevicemodel;
            if (sgalignment && sgorientation && sgdevicemodel && sgalignment == "top" && sgdevicemodel.includes("phone") && sgorientation == "portrait") sgalignment = "left";
            if (sgalignment && sgorientation && sgdevicemodel) this.deviceModel = sgdevicemodel + sgorientation + sgalignment;
        }
        if (!this.oldContent) {
            for (let c = 0; c < this.sgData.length; c++) {
                let assetParent = this.createAssetParent(c, this.sgParent);
                let imagestackIntro = (this.sgSlideType == "imagestack" || this.sgSlideType == "textstack") && c == 0 && this.sgData.length != 1 ? "introSlide" : "";
                if (imagestackIntro != "") assetParent.classList.add(imagestackIntro);

                //Creating nodes from menu
                let metaDataBase = this.getMetaDataCommon();
                if (metaDataBase && metaDataBase[this.deviceModel] && (metaDataBase[this.deviceModel].supportedNodes || metaDataBase[this.deviceModel].introNodes)) metaDataBase = metaDataBase[this.deviceModel];
                if (metaDataBase && (metaDataBase.supportedNodes || metaDataBase.introNodes)) {
                    let supportNode = imagestackIntro != "" && metaDataBase.introNodes ? metaDataBase.introNodes : metaDataBase.supportedNodes;
                    // let intCount = supportNode.length;
                    // for (let i = 0; i < 1; i++) {
                    let nodeObj = supportNode;
                    let nodeParent = this.createNodes(nodeObj, assetParent, c);
                    if (nodeObj.subNodes && nodeParent) this.createNestedNodes(nodeObj.subNodes, nodeParent, c);
                    // }
                }

                // Check and pply Flip & bleed options
                // this.specialGraphicsUtils.checkAndApplyFlipBleed(assetParent, this.sgParent, this.metaData, this.getProps());
                this.applyImageBleedCommon(assetParent);

                let property = metaDataBase && metaDataBase.properties;
                if (this.deviceModel != "" && metaDataBase[this.deviceModel] && metaDataBase[this.deviceModel].properties) property = metaDataBase[this.deviceModel].properties;
                if (metaDataBase && metaDataBase.introproperties && c == 0) property = metaDataBase.introproperties;

                if (property) {
                    let props = property;
                    if (props && !props.bgshape) props.bgshape = "emptylayoutshape";
                    //Applying bgshape property for slide
                    if (this.objDataToSG?.layoutshapeoutline && props) props.bgshape = this.objDataToSG.layoutshapeoutline;

                    //Creating bgshape
                    if (props?.bgshape && this.slideContent && this.createLayoutShape) this.createLayoutShape("add", props.bgshape, this.slideContent);
                    else if (this.slideContent && this.createLayoutShape) this.createLayoutShape("remove", "", this.slideContent);

                    if (this.layoutShapeAddCallback) {
                        let slideID = this.slideContent && this.slideContent.id ? this.slideContent.id : null;
                        this.layoutShapeAddCallback(slideID);
                    }
                    //Applying textelement style property for slide
                    if (props && props.textelementstyle && this.slideContent) {
                        this.sgParent.parentElement.parentElement.setAttribute("data-textelementstyle", props.textelementstyle);
                        assetParent.setAttribute("data-textelementstyle", props.textelementstyle);
                    } else if (this.sgParent.parentElement && this.sgParent.parentElement.parentElement) {
                        this.sgParent.parentElement.parentElement.removeAttribute("data-textelementstyle");
                        assetParent.removeAttribute("data-textelementstyle");
                    }
                    if (assetParent.hasAttribute("textPosition") && assetParent.querySelector("[id*='textBaseParentNode']")) {
                        let textBaseParent = assetParent.querySelector("[id*='textBaseParentNode']");
                        this.textPositionChangeOperation(textBaseParent.parentElement, assetParent.getAttribute("textPosition"));
                    }
                    this.updateHeightForText(assetParent);
                }

                let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
                let deviceBGColorParent = this.sgParent.querySelector("[id='deviceBGColorParent']");
                let deviceBGColorParentInside = deviceImageParentNode ? deviceImageParentNode.querySelector("[id='deviceBGColorParent']") : null;
                if (!deviceBGColorParentInside && deviceBGColorParent) {
                    deviceBGColorParent.parentElement.removeChild(deviceBGColorParent);
                    deviceImageParentNode.appendChild(deviceBGColorParent);
                }

                SGBaseClass.prototype.initSpecialGraphicsCreation.call(this);
                this.onTextChangeForAllNodes(this.sgParent, c);
                if (this.specialGraphicsSlideCreationComplete) this.specialGraphicsSlideCreationComplete(c);
            }
        } else {
            this.clearListener(false);
            for (let c = 0; c < this.sgData.length; c++) {
                let assetParent = this.createAssetParent(c, this.sgParent);
                let elements = assetParent ? assetParent.querySelectorAll("[listener='true']") : [];
                for (let a = 0; a < elements.length; a++) {
                    this.setTextFocus(elements[a], false, assetParent, true);
                }
                let clickElements = assetParent ? assetParent.querySelectorAll("[clicklistener='true']") : [];
                for (let a = 0; a < clickElements.length; a++) {
                    if (this.imageDoubleClickEvent) this.eventManager.addEvent(clickElements[a], "dblclick", this.imageDoubleClickEvent);
                }
            }
            let lottieParent = this.sgParent.querySelectorAll("[data-lottie*='/']");
            for (let a = 0; a < lottieParent.length; a++) {
                let arrAssets = [{ type: "json", url: lottieParent[a].getAttribute("data-lottie"), id: "commonbglottie", parent: lottieParent[a] }];
                this.arrCommonAssets.push({ array: arrAssets, callback: this.lottieLoadCallback });
            }
        }
    } else SGBaseClass.prototype.initSpecialGraphicsCreation.call(this);

    //Re-applying image contrast
    this.reApplyContrast();
    // if (this.oldContent || this.isWidget == true) {
    //     let allAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
    //     for (let c = 0; c < allAssetParent.length; c++) {
    //         let fullContrastElements = allAssetParent[c].querySelectorAll("[contrast='fullbg']");
    //         for (let a = 0; a < fullContrastElements.length; a++) {
    //             this.eventManager.dispatch("applyImageContrast", fullContrastElements[a], allAssetParent[c]);
    //         }
    //         let halfContrastElements = allAssetParent[c].querySelectorAll("[contrast='halfbg']");
    //         for (let b = 0; b < halfContrastElements.length; b++) {
    //             this.eventManager.dispatch("applyImageContrast", halfContrastElements[b], allAssetParent[c], true);
    //         }
    //     }
    // }
    if (this.isWidget) this.specialGraphicsUtils.updateImagePositions(this.sgParent);
    this.specialGraphicsCreationComplete();
};

GenericSpecialgraphicsCommon.prototype.reApplyContrast = function () {
    if (this.oldContent || this.isWidget == true || this.isPresent == true) {
        //Re-applying image contrast
        let allAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
        for (let c = 0; c < allAssetParent.length; c++) {
            let fullContrastElements = allAssetParent[c].querySelectorAll("[contrast='fullbg']");
            for (let a = 0; a < fullContrastElements.length; a++) {
                fullContrastElements[a].setAttribute("data-overlaychange", "false");
                this.eventManager.dispatch("applyImageContrast", fullContrastElements[a], allAssetParent[c]);
            }
            let halfContrastElements = allAssetParent[c].querySelectorAll("[contrast='halfbg']");
            for (let b = 0; b < halfContrastElements.length; b++) {
                halfContrastElements[b].setAttribute("data-overlaychange", "false");
                this.eventManager.dispatch("applyImageContrast", halfContrastElements[b], allAssetParent[c], true);
            }
        }
    }
};

GenericSpecialgraphicsCommon.prototype.specialGraphicsSlideCreationComplete = function (index) {
    // SGBaseClass.prototype.specialGraphicsSlideCreationComplete.call(this, index);
};
GenericSpecialgraphicsCommon.prototype.applyContrastToText = function (element, property) {
    if (property && property.contrast && (property.contrast == "true" || property.contrast == true) && element) element.setAttribute("data-supportcontrast", "true");
    else if (element) element.removeAttribute("data-supportcontrast");
};
GenericSpecialgraphicsCommon.prototype.applyChildStyleToParent = function (parent, child) {
    if (parent && child) {
        let childStyle = window.getComputedStyle(child);
        parent.style.width = child.style.width.includes("%") ? child.style.width : childStyle.width;
        parent.style.height = child.style.height.includes("%") ? child.style.height : childStyle.height;
        parent.style.left = childStyle.left;
        parent.style.top = childStyle.top;
        parent.style.position = childStyle.position;
        let margin = childStyle.margin == "" || childStyle.margin == "0px" ? child.style.margin : childStyle.margin;
        let padding = childStyle.padding == "" || childStyle.padding == "0px" ? child.style.padding : childStyle.padding;
        parent.style.margin = margin;
        parent.style.padding = padding;
        child.style.width = "100%";
        child.style.height = "100%";
        child.style.removeProperty("left");
        child.style.removeProperty("top");
        child.style.setProperty("margin", "unset", "important");
        child.style.setProperty("padding", "unset", "important");
    }
};
GenericSpecialgraphicsCommon.prototype.onTextChangeForAllNodes = function (sgParent = null, index = -1) {
    let assetParent = null;
    let indexValue = index != -1 ? index : this.currentNodeIndex - 1;
    if (sgParent) assetParent = sgParent.querySelector("[id='assetParent" + indexValue + "']");
    if (!assetParent) assetParent = this.sgParent.querySelector("[id='assetParent" + indexValue + "']");

    let oldDisplay = assetParent?.style?.display == "none" ? "none" : "";
    if (oldDisplay == "none") assetParent.style.display = "flex";

    let textBaseParentNode = assetParent.querySelector("[id*='textBaseParentNode']");
    if (!textBaseParentNode) textBaseParentNode = assetParent;
    if (textBaseParentNode) {
        textBaseParentNode.style.overflow = "hidden";
        // textBaseParentNode.style.removeProperty("max-height");
        let titleNode = textBaseParentNode.querySelector("[id='sgTitleNode']");
        let subTitleNode = textBaseParentNode.querySelector("[id='sgSubTitleNode']");
        let sgTitleLabelNode = textBaseParentNode.querySelector("[id='sgTitleLabelNode']");

        if (sgTitleLabelNode) {
            if (this.removeHighlightFocus) this.removeHighlightFocus(assetParent, sgTitleLabelNode);
            let elementPadding = this.specialGraphicsUtils.getPadding(sgTitleLabelNode);
            let labelStyle = window.getComputedStyle(sgTitleLabelNode);
            sgTitleLabelNode.style.maxHeight = parseFloat(labelStyle.lineHeight) + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
            sgTitleLabelNode.style.minHeight = sgTitleLabelNode.style.maxHeight;
            sgTitleLabelNode.parentElement.style.maxHeight = sgTitleLabelNode.style.maxHeight;
            sgTitleLabelNode.parentElement.style.minHeight = sgTitleLabelNode.style.maxHeight;
        }
        if (subTitleNode) {
            if (this.removeHighlightFocus) this.removeHighlightFocus(assetParent, subTitleNode);
            let supportParent = subTitleNode.hasAttribute("data-support") ? true : false;
            subTitleNode.style.removeProperty("max-height");
            subTitleNode.style.removeProperty("height");
            if (supportParent != true) subTitleNode.parentElement.style.removeProperty("max-height");
            if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(subTitleNode);
            this.onTextChangeUpdate(subTitleNode, true, assetParent);
            this.doCheckTextLineHeightDiff(subTitleNode);
        }
        if (titleNode) {
            if (this.removeHighlightFocus) this.removeHighlightFocus(assetParent, titleNode);
            titleNode.style.removeProperty("max-height");
            titleNode.style.removeProperty("height");
            titleNode.parentElement.style.removeProperty("max-height");
            if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(titleNode);
            this.onTextChangeUpdate(titleNode, true, assetParent);
            this.doCheckTextLineHeightDiff(titleNode);
        }

        // textBaseParentNode.style.removeProperty("overflow");
    }
    if (oldDisplay) assetParent.style.display = oldDisplay;
};

GenericSpecialgraphicsCommon.prototype.onTextChange = function (element) {
    let textNode = element;
    this.onTextChangeUpdate(textNode);
};

GenericSpecialgraphicsCommon.prototype.onTextChangeUpdate = function (textNode, isStart = false, assetParentNode = null) {
    let assetParent = assetParentNode ? assetParentNode : this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    let textBaseParentNode = assetParent.querySelector("[id*='textBaseParentNode']");
    let supportParent = textNode.hasAttribute("data-support") ? true : false;
    let singleNodeHeight = -1;
    let isSingleNode = false;
    if (supportParent == true && !textBaseParentNode && assetParent.querySelector("[id='sgTitleNode']")) {
        let titleNode = assetParent.querySelector("[id='sgTitleNode']");
        textBaseParentNode = titleNode.parentElement;
        let oldOverflowValue = textBaseParentNode.style.overflow;
        textBaseParentNode.style.overflow = "hidden";
        singleNodeHeight = parseFloat(window.getComputedStyle(textBaseParentNode).height);
        if (textBaseParentNode.style.height == "auto") {
            textBaseParentNode.style.height = textBaseParentNode.style.maxHeight;
            singleNodeHeight = parseFloat(window.getComputedStyle(textBaseParentNode).height);
            textBaseParentNode.style.height = "auto";
        }
        if (textNode.hasAttribute("data-maxheight")) {
            let textNodeMaxHeight = textNode.getAttribute("data-maxheight");
            if (textNodeMaxHeight.includes("%")) {
                let ph = textNode.parentElement.parentElement.offsetHeight;
                let mhFinal = ph * (parseFloat(textNodeMaxHeight) / 100);
                singleNodeHeight = mhFinal;
            } else {
                singleNodeHeight = parseFloat(textNodeMaxHeight);
            }
            textNode.parentElement.style.maxHeight = textNodeMaxHeight;
            // textNode.parentElement.style.height = textNodeMaxHeight;
        }
        textBaseParentNode.style.overflow = oldOverflowValue;
        isSingleNode = true;
    }
    if (!textBaseParentNode) {
        textBaseParentNode = textNode.parentElement.parentElement;
        isSingleNode = true;
    }
    if (textBaseParentNode) {
        if (isSingleNode != true && textNode.id.includes("sgTitleLabelNode")) {
            let labelStyle = window.getComputedStyle(textNode);
            let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
            textNode.style.maxHeight = parseFloat(labelStyle.lineHeight) + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
            textNode.parentElement.style.maxHeight = textNode.style.maxHeight;
        } else {
            textNode.style.removeProperty("max-height");
            textNode.style.removeProperty("height");
            if (supportParent != true && isSingleNode != true) textNode.parentElement.style.removeProperty("max-height");

            let titleNode = textBaseParentNode.querySelector("[id='sgTitleNode']");
            let subTitleNode = textBaseParentNode.querySelector("[id='sgSubTitleNode']");
            let sgTitleLabelNode = textBaseParentNode.querySelector("[id='sgTitleLabelNode']");
            let textInnerParentNode = textBaseParentNode.querySelector("[id='textInnerParentNode']");
            let sgNumberTextNode = textBaseParentNode.querySelector("[id*='sgNumberTextNode']");

            let numberStyle = sgNumberTextNode ? window.getComputedStyle(sgNumberTextNode) : null;
            let numberMargin = numberStyle ? parseFloat(numberStyle.height == "auto" ? 0 : numberStyle.height) + parseFloat(numberStyle.marginTop) + parseFloat(numberStyle.marginBottom) : 0;
            numberMargin = isNaN(numberMargin) ? 0 : numberMargin;

            let textParentStyle = textInnerParentNode ? window.getComputedStyle(textInnerParentNode.parentElement) : null;
            let textParentMargin = textParentStyle ? parseFloat(textParentStyle.marginTop) + parseFloat(textParentStyle.marginBottom) : 0;

            let innerParentStyle = textInnerParentNode ? window.getComputedStyle(textInnerParentNode) : null;
            let innerParentMargin = innerParentStyle ? parseFloat(innerParentStyle.marginTop) + parseFloat(innerParentStyle.marginBottom) : 0;

            let labelParentStyle = sgTitleLabelNode ? window.getComputedStyle(sgTitleLabelNode.parentElement) : null;
            let labelStyle = sgTitleLabelNode ? window.getComputedStyle(sgTitleLabelNode) : null;
            let hasLabel = (sgTitleLabelNode && sgTitleLabelNode.style.display == "none") || !sgTitleLabelNode ? false : true;
            let labelMargin = labelParentStyle ? parseFloat(labelParentStyle.marginTop) + parseFloat(labelParentStyle.marginBottom) : 0;
            labelMargin = hasLabel ? (labelStyle ? parseFloat(labelStyle.marginTop) + parseFloat(labelStyle.marginBottom) : 0) + labelMargin : 0;

            let subTitileParentStyle = subTitleNode ? window.getComputedStyle(subTitleNode.parentElement) : null;
            let subTitileStyle = subTitleNode ? window.getComputedStyle(subTitleNode) : null;
            let hasSubtitle = (subTitleNode && subTitleNode.style.display == "none") || !subTitleNode ? false : true;
            let subTitileMargin = subTitileParentStyle ? parseFloat(subTitileParentStyle.marginTop) + parseFloat(subTitileParentStyle.marginBottom) : 0;
            subTitileMargin = hasSubtitle ? (subTitileStyle ? parseFloat(subTitileStyle.marginTop) + parseFloat(subTitileStyle.marginBottom) : 0) + subTitileMargin : 0;

            let titileParentStyle = titleNode ? window.getComputedStyle(titleNode.parentElement) : null;
            let titileMargin = titileParentStyle ? parseFloat(titileParentStyle.marginTop) + parseFloat(titileParentStyle.marginBottom) : 0;

            let textBaseHeight = parseFloat(singleNodeHeight) > 0 ? parseFloat(singleNodeHeight) : parseFloat(window.getComputedStyle(textBaseParentNode).height);
            if (textBaseParentNode && textBaseParentNode.hasAttribute("fullheight")) textBaseHeight = parseFloat(textBaseParentNode.getAttribute("fullheight"));
            if (window.getComputedStyle(textBaseParentNode).height == "" && textBaseParentNode.style.maxHeight != "" && textBaseParentNode.style.maxHeight.includes("px")) textBaseHeight = parseFloat(textBaseParentNode.style.maxHeight);
            let maxHeight = window.getComputedStyle(textBaseParentNode).maxHeight;
            if (maxHeight != "" && maxHeight != "0px" && !isNaN(parseFloat(maxHeight))) if (maxHeight.includes("px")) textBaseHeight = parseFloat(maxHeight);
            if (maxHeight != "" && maxHeight != "0px" && !isNaN(parseFloat(maxHeight))) {
                if (maxHeight.includes("px")) textBaseHeight = parseFloat(maxHeight);
                else if (maxHeight.includes("%")) {
                    let oldParentHeight = null;
                    if (textBaseParentNode.parentElement && textBaseParentNode.parentElement.style.height == "auto" && textBaseParentNode.parentElement.hasAttribute("fullheight")) {
                        oldParentHeight = textBaseParentNode.parentElement.style.height;
                        textBaseParentNode.parentElement.style.height = textBaseParentNode.parentElement.getAttribute("fullheight");
                    }
                    let oldParentH = textBaseParentNode.style.height;
                    textBaseParentNode.style.height = textBaseParentNode.style.maxHeight;
                    let hh = parseFloat(window.getComputedStyle(textBaseParentNode).height);
                    if (hh > 0 && !isNaN(hh)) textBaseHeight = hh;
                    textBaseParentNode.style.height = oldParentH;
                    if (oldParentHeight) textBaseParentNode.parentElement.style.height = oldParentHeight;
                }
            }
            //removing margin/padding things on total base height
            let textParentHeight =
                textBaseHeight - (isNaN(labelMargin) ? 0 : labelMargin) - (isNaN(subTitileMargin) ? 0 : subTitileMargin) - (isNaN(titileMargin) ? 0 : titileMargin) - (isNaN(innerParentMargin) ? 0 : innerParentMargin) - (isNaN(textParentMargin) ? 0 : textParentMargin) - (isNaN(numberMargin) ? 0 : numberMargin);
            let titleHeight = titleNode?.scrollHeight > 0 ? titleNode.scrollHeight : !titleNode || titleNode?.offsetHeight == 0 ? 0 : titleNode.style.maxHeight != "" && titleNode.style.display != "none" ? parseFloat(titleNode.style.maxHeight) : window.getComputedStyle(titleNode).height;
            let subTitleHeight = subTitleNode?.scrollHeight > 0 ? subTitleNode.scrollHeight : !subTitleNode || subTitleNode?.offsetHeight == 0 ? 0 : subTitleNode.style.maxHeight != "" && subTitleNode.style.display != "none" ? parseFloat(subTitleNode.style.maxHeight) : window.getComputedStyle(subTitleNode).height;
            let lableHeight = !sgTitleLabelNode || sgTitleLabelNode?.offsetHeight == 0 ? 0 : sgTitleLabelNode.style.maxHeight != "" && sgTitleLabelNode.style.display != "none" ? parseFloat(sgTitleLabelNode.style.maxHeight) : window.getComputedStyle(sgTitleLabelNode).height;
            //calculating total current text height
            let totalTextHeight = parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight);

            let lineHeight = window.getComputedStyle(textNode).lineHeight;
            let fontsize = window.getComputedStyle(textNode).fontSize;
            lineHeight = isNaN(parseFloat(lineHeight)) ? parseFloat(fontsize) * 1.2 : parseFloat(lineHeight);
            let noLines = Math.max(textNode.parentElement.offsetHeight / lineHeight, 1);
            let offDifference = noLines - parseInt(noLines);
            let lines = offDifference > 0.9 ? parseInt(noLines) + 1 : parseInt(noLines);

            //If text height increase total height we have doing fit logic
            if (typeof totalTextHeight == "string") totalTextHeight = parseFloat(totalTextHeight);
            if (typeof textParentHeight == "string") textParentHeight = parseFloat(textParentHeight);
            totalTextHeight = totalTextHeight.toFixed(1);
            textParentHeight = textParentHeight.toFixed(1);
            if (typeof totalTextHeight == "string") totalTextHeight = parseFloat(totalTextHeight);
            if (typeof textParentHeight == "string") textParentHeight = parseFloat(textParentHeight);
            let commonRemainingHeight = 0;
            if (totalTextHeight > textParentHeight) {
                // if (isStart == true) {
                //     let extraValues = totalTextHeight - textParentHeight;
                //     if (extraValues >= 0) {
                //         this.loop(lines, lineHeight, textNode, textParentHeight, titleNode, subTitleNode, sgTitleLabelNode);
                //     } else {
                //         textNode.style.removeProperty("max-height");
                //         if (supportParent != true) textNode.parentElement.style.removeProperty("max-height");
                //     }
                // } else {
                let targetNodeHeight = textNode.id.includes("sgTitleNode")
                    ? parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : textNode.id.includes("sgSubTitleNode")
                    ? parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight);
                let remainingHeight = textParentHeight - targetNodeHeight;
                if (isSingleNode) remainingHeight = textParentHeight;
                commonRemainingHeight = remainingHeight;
                if (lines == 1) remainingHeight = lineHeight;

                let linesFinal = remainingHeight / lineHeight;
                let offDiff = linesFinal - parseInt(linesFinal);
                linesFinal = offDiff > 0.9 ? parseInt(linesFinal) + 1 : parseInt(linesFinal);

                let heightFinal = linesFinal * lineHeight;
                heightFinal = heightFinal == 0 ? lineHeight : heightFinal;

                textNode.style.removeProperty("max-height");
                textNode.style.maxHeight = heightFinal + "px";
                if (!textNode.hasAttribute("data-maxheight")) textNode.parentElement.style.removeProperty("max-height");
                // }
            } else {
                let targetNodeHeight = textNode.id.includes("sgTitleNode")
                    ? parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : textNode.id.includes("sgSubTitleNode")
                    ? parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight);
                let remainingHeight = textParentHeight - targetNodeHeight;
                if (isSingleNode) remainingHeight = textParentHeight;

                commonRemainingHeight = remainingHeight;
            }

            textNode.style.removeProperty("min-height");
            DiagramResizeUtils.commonFontResize(totalTextHeight, textParentHeight, commonRemainingHeight, textNode, textNode.parentElement, this.objDataToSG.fontClassLists, true);

            if (isSingleNode == true) textNode.parentElement.style.removeProperty("height");

            this.onTextUpdate(textNode, isSingleNode);
        }
    }
};

GenericSpecialgraphicsCommon.prototype.loop = function (lines, lineHeight, textNode, textParentHeight, titleNode, subTitleNode, sgTitleLabelNode) {
    //Loop and fitting the text inside max avaiable height
    lines = lines - 1;
    if (lines == 0) return;
    let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
    let newHeight = lines * lineHeight + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom);
    textNode.style.maxHeight = newHeight + "px";
    // textNode.parentElement.style.maxHeight = newHeight + "px";

    let titleHeight = !titleNode ? 0 : titleNode.style.maxHeight != "" && titleNode.style.display != "none" ? parseFloat(titleNode.style.maxHeight) : window.getComputedStyle(titleNode).height;
    let subTitleHeight = !subTitleNode ? 0 : subTitleNode.style.maxHeight != "" && subTitleNode.style.display != "none" ? parseFloat(subTitleNode.style.maxHeight) : window.getComputedStyle(subTitleNode).height;
    let lableHeight = !sgTitleLabelNode ? 0 : sgTitleLabelNode.style.maxHeight != "" && sgTitleLabelNode.style.display != "none" ? parseFloat(sgTitleLabelNode.style.maxHeight) : window.getComputedStyle(sgTitleLabelNode).height;
    let totalTextHeight = parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight);
    if (textParentHeight < totalTextHeight) this.loop(lines, lineHeight, textNode, textParentHeight, titleNode, subTitleNode, sgTitleLabelNode);
};

GenericSpecialgraphicsCommon.prototype.onTextUpdate = function (textNode, isSingleNode = false) {
    if (textNode.parentElement.offsetHeight <= textNode.offsetHeight) {
        let lineHeight = window.getComputedStyle(textNode).lineHeight;
        let fontsize = window.getComputedStyle(textNode).fontSize;
        lineHeight = isNaN(parseFloat(lineHeight)) ? parseFloat(fontsize) * 1.2 : parseFloat(lineHeight);
        let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
        let noLines = Math.max(textNode.parentElement.offsetHeight / lineHeight, 1);
        let offDifference = noLines - parseInt(noLines);
        let lines = offDifference > 0.9 ? parseInt(noLines) + 1 : parseInt(noLines);
        textNode.style.maxHeight = lines * lineHeight + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
        textNode.style.overflow = "hidden";
        if (!isSingleNode) textNode.parentElement.style.removeProperty("max-height");
    }
};

GenericSpecialgraphicsCommon.prototype.doCheckTextLineHeightDiff = function (textNode) {
    if (textNode.id.includes("sgTitleLabelNode")) return;
    this.onTextChangeUpdate(textNode);

    let lineHeight = window.getComputedStyle(textNode).lineHeight;
    let fontsize = window.getComputedStyle(textNode).fontSize;
    lineHeight = isNaN(parseFloat(lineHeight)) ? parseFloat(fontsize) * 1.2 : parseFloat(lineHeight);
    let noLines = Math.max(textNode.parentElement.offsetHeight / lineHeight, 1);
    let offDifference = noLines - parseInt(noLines);
    let lines = offDifference > 0.9 ? parseInt(noLines) + 1 : parseInt(noLines);
    // if (lines > 1) {
    let dummyNode = textNode.cloneNode(true);
    dummyNode.style.lineHeight = "normal";
    dummyNode.style.opacity = "0";
    dummyNode.innerHTML = "sd";
    this.sgParent.appendChild(dummyNode);

    dummyNode.style.minHeight = "unset";
    dummyNode.style.height = "unset";
    dummyNode.style.maxHeight = "unset";
    dummyNode.style.position = "absolute";
    let fullLh = dummyNode.clientHeight;
    this.sgParent.removeChild(dummyNode);
    if (fullLh <= 0) return;

    let diff = fullLh - lineHeight;
    textNode.style.maxHeight = lines * lineHeight + diff / (lines == 1 ? 2 : lines) + "px";
    textNode.style.height = lines * lineHeight + diff / (lines == 1 ? 2 : lines) + "px";
    // console.log("SGG - Lineheight diff - ", diff + " - " + textNode.style.maxHeight);
    // console.log(textNode);

    textNode.style.minHeight = textNode.style.maxHeight;
    let textH = textNode.clientHeight;
    let textparentH = textNode.parentElement.parentElement.parentElement.clientHeight;
    textNode.style.removeProperty("min-height");
    if (textH > textparentH) {
        // console.log("Sg - Exceed height while adding difference line height");
        lines = lines - 1;
        // if (lines == 1) textNode.style.maxHeight = lines * lineHeight + "px";
        // else
        textNode.style.maxHeight = lines * lineHeight + diff / 3 + "px";
    }
    // }
};

GenericSpecialgraphicsCommon.prototype.updateHeightForText = function (assetParent) {
    let metaDataBase = this.getMetaDataCommon();
    if (metaDataBase && (metaDataBase.properties || metaDataBase.introproperties)) {
        let propData = assetParent.classList.contains("introSlide") && metaDataBase.introproperties ? metaDataBase.introproperties : metaDataBase.properties;
        let property = propData.text;
        if (property && property.maxheight) {
            let textBaseParentNode = assetParent.querySelector("[id*='textBaseParentNode']");
            let titleLabelTextParent = assetParent.querySelector("[id='titleLabelTextParent']");
            let sgTitleLabelNode = assetParent.querySelector("[id='sgTitleLabelNode']");

            let textParent = textBaseParentNode ? textBaseParentNode.parentElement : null;
            let parentHeight = textParent ? parseFloat(window.getComputedStyle(textParent).height) : 0;
            if (textParent && textParent.hasAttribute("fullheight")) parentHeight = parseFloat(textParent.getAttribute("fullheight"));
            if (!isNaN(parentHeight) && parentHeight > 0) return;
            if (textBaseParentNode) textBaseParentNode.style.display = "none";
            let remainingHeight = 0;
            if (textParent) {
                // textParent.style.height = "auto";

                let mainParentDisplay = textParent.parentElement.style.display;
                textParent.parentElement.style.removeProperty("display");
                let currentHeight = parseFloat(window.getComputedStyle(textParent).height);
                textParent.parentElement.style.display = mainParentDisplay;

                remainingHeight = parentHeight - currentHeight;
                // textParent.style.height = parentHeight + "px";
            }
            let titleTextParent = assetParent.querySelector("[id='titleTextParent']");
            let sgTitleNode = assetParent.querySelector("[id='sgTitleNode']");

            let subTitleTextParent = assetParent.querySelector("[id='subTitleTextParent']");
            let sgSubTitleNode = assetParent.querySelector("[id='sgSubTitleNode']");

            if (titleLabelTextParent) titleLabelTextParent.style.removeProperty("max-height");
            if (sgTitleLabelNode) sgTitleLabelNode.style.removeProperty("max-height");
            if (titleTextParent) titleTextParent.style.removeProperty("max-height");
            if (sgTitleNode) sgTitleNode.style.removeProperty("max-height");
            if (subTitleTextParent) subTitleTextParent.style.removeProperty("max-height");
            if (sgSubTitleNode) sgSubTitleNode.style.removeProperty("max-height");

            if (textBaseParentNode && remainingHeight != 0) {
                textBaseParentNode.style.maxHeight = remainingHeight + "px";
                textBaseParentNode.style.removeProperty("display");
            }
        }
    }
};
//Set slide type
GenericSpecialgraphicsCommon.prototype.setSlideType = function (type) {
    this.sgSlideType = type;
};
GenericSpecialgraphicsCommon.prototype.commonAssetsLoadComplete = function (responseData, objData) {
    if (objData && objData.callback) objData.callback(responseData);
    this.assetLoadingCount = this.assetLoadingCount - 1;
    if (this.assetLoadingCount == 0) {
        // console.log("SG - all assets load complete");
        this.assetsLoading = false;
        this.arrCommonAssets = [];
        this.specialGraphicsCreationComplete();
    }
};
GenericSpecialgraphicsCommon.prototype.specialGraphicsCreationComplete = function (doImagePosition = true) {
    if (this.arrCommonAssets.length > 0 && this.isPresent != true) {
        this.assetsLoading = true;
        this.assetLoadingCount = this.arrCommonAssets.length;
        for (let a = 0; a < this.arrCommonAssets.length; a++) {
            let obj = this.arrCommonAssets[a];
            this.loadAssets(obj.array, this.commonAssetsLoadComplete, this.assetError, obj);
        }
        this.arrCommonAssets = [];
    }
    if (this.assetsLoading == false) {
        if (this.isPreviewMode == false) {
            //Check and update font class depends on number of lines
            let arrTitleNodes = this.sgParent.querySelectorAll("[id*='sgTitleNode']");
            if (this.isPresent != true) {
                for (let a = 0; a < arrTitleNodes.length; a++) {
                    if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(arrTitleNodes[a]);
                }
                this.checkShapeDependency();
            }

            if (this.isPlayAnimation == false && this.isPresent != true) this.eventManager.dispatch("positionchangecallback", (this.isFromLastSlide == true ? this.sgData.length : 1) - 1);
            if (this.isPresent != true) {
                // let slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
                // if (slideDomContentGroup) this.changeVariation(slideDomContentGroup);
                //Updating image positions for all images
                this.specialGraphicsUtils.updateImagePositions(this.sgParent);

                let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
                let finalShow = this.sgParent?.parentElement?.parentElement?.getAttribute("data-ogdata-finalshow_0")?.includes("intro") ? true : false;
                let indexValue = assetParent0.classList.contains("introSlide") && finalShow ? this.currentNodeIndex : 0;
                // if (this.sgParent.hasAttribute("prevIndex")) {
                //     indexValue = 0;
                // this.sgParent.removeAttribute("prevIndex");
                // }
                this.floaterNavigation(indexValue);
                // this.setTargetIndex();

                //Text Element positioning after all text's props change
                let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
                for (let i = 0; i < assetParents.length; i++) {
                    let textInnerParentNode = assetParents[i].querySelector("[id='textInnerParentNode']");

                    if (this.sgParent.hasAttribute("singlenode") && this.sgParent.getAttribute("singlenode") == "true" && this.textElement && this.textElement.elementData && this.textElement.elementData.textelementproperties) {
                        // this.sgParent.setAttribute("singlenode", "true");
                        let textElementStyle = assetParents[i].getAttribute("data-textelementstyle");
                        let props = this.textElement.elementData.textelementproperties;
                        let textElementSelected = props[textElementStyle] ? props[textElementStyle] : Object.keys(props).length > 0 ? props[Object.keys(props)[0]] : null;
                        let target = textElementSelected && textElementSelected.target ? textElementSelected.target : null;
                        if (target && target == "title" && assetParents[i].querySelector("[id*='titleTextParent")) textInnerParentNode = assetParents[i].querySelector("[id*='titleTextParent']").parentElement;
                        if (target && target == "label" && assetParents[i].querySelector("[id*='titleLabelTextParent")) textInnerParentNode = assetParents[i].querySelector("[id*='titleLabelTextParent']").parentElement;
                        if (target && target == "subtitle" && assetParents[i].querySelector("[id*='subTitleTextParent")) textInnerParentNode = assetParents[i].querySelector("[id*='subTitleTextParent']").parentElement;
                    }
                    // console.log("SGG - index on end - " + i);
                    this.textElementPositioning(assetParents[i], textInnerParentNode, i);
                }
            }
        }
        SGBaseClass.prototype.specialGraphicsCreationComplete.call(this);
    }
};

//Assets load error
GenericSpecialgraphicsCommon.prototype.assetError = function () {
    this.assetLoadingCount = this.assetLoadingCount - 1;
    if (this.assetLoadingCount == 0) {
        // console.log("SG - all assets load complete");
        this.assetsLoading = false;
        this.arrCommonAssets = [];
        this.specialGraphicsCreationComplete();
    }
};
//Assets load complete
GenericSpecialgraphicsCommon.prototype.assetsLoadComplete = function (responseData) {
    for (let i = 0; i < responseData.length; i++) {
        let name = "";
        let parentNode = responseData[i].parent ? responseData[i].parent : this.sgParent;
        if (responseData[i].id.includes("svgdata")) name = "Illustration";
        if (name == "Illustration" && parentNode.querySelectorAll("[id='svgElementDiv']").length > 0) {
            let arrSvgParent = parentNode.querySelectorAll("[id='svgElementDiv']");
            for (let a = 0; a < arrSvgParent.length; a++) {
                arrSvgParent[a].innerHTML = responseData[i].data;
                this.applySVGData(arrSvgParent[a]);
            }
        }
    }
};
//Re position text element
GenericSpecialgraphicsCommon.prototype.rePositioningTextElement = function (targetIndex = -1) {
    let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
    for (let i = 0; i < assetParents.length; i++) {
        if (targetIndex == -1 || targetIndex == i) {
            let textInnerParentNode = assetParents[i].querySelector("[id='textInnerParentNode']");

            if (this.sgParent.hasAttribute("singlenode") && this.sgParent.getAttribute("singlenode") == "true" && this.textElement && this.textElement.elementData && this.textElement.elementData.textelementproperties) {
                let textElementStyle = assetParents[i].getAttribute("data-textelementstyle");
                let props = this.textElement.elementData.textelementproperties;
                let textElementSelected = props[textElementStyle] ? props[textElementStyle] : Object.keys(props).length > 0 ? props[Object.keys(props)[0]] : null;
                let target = textElementSelected && textElementSelected.target ? textElementSelected.target : null;
                if (target && target == "title" && assetParents[i].querySelector("[id*='titleTextParent")) textInnerParentNode = assetParents[i].querySelector("[id*='titleTextParent']").parentElement;
                if (target && target == "label" && assetParents[i].querySelector("[id*='titleLabelTextParent")) textInnerParentNode = assetParents[i].querySelector("[id*='titleLabelTextParent']").parentElement;
                if (target && target == "subtitle" && assetParents[i].querySelector("[id*='subTitleTextParent")) textInnerParentNode = assetParents[i].querySelector("[id*='subTitleTextParent']").parentElement;
            }
            this.textElementPositioning(assetParents[i], textInnerParentNode, i);
        }
    }
};
GenericSpecialgraphicsCommon.prototype.applySVGData = function (svgChild) {
    if (svgChild.getElementsByTagName("svg").length > 0) {
        let svgDOM = svgChild.getElementsByTagName("svg")[0];
        svgDOM.style.width = "100%";
        svgDOM.style.height = "100%";
    }
};
GenericSpecialgraphicsCommon.prototype.createNestedNodes = function (subNodes, nodeParentToInsert, currentIndex = 0) {
    for (let j = 0; j < subNodes.length; j++) {
        let nodeObj = subNodes[j];
        let nodeParent = this.createNodes(nodeObj, nodeParentToInsert, currentIndex);
        if (nodeObj.subNodes && nodeParent) {
            this.createNestedNodes(nodeObj.subNodes, nodeParent, currentIndex);
        }
    }
};
GenericSpecialgraphicsCommon.prototype.createNodes = function (nodeObj, nodeParent, currentIndex = 0) {
    let name = nodeObj.name;
    switch (name) {
        case "contentMainParent":
        case "contentNode":
        case "contentNode1":
        case "contentNode2":
        case "contentNode3":
        case "contentNode4":
        case "contentNode5":
        case "contentNode6":
        case "secContentNode":
        case "secContentNode1":
        case "secContentNode2":
        case "secContentNode3":
        case "secContentNode4":
        case "secContentNode5":
        case "secContentNode6":
            return this.createContentNode(nodeParent, nodeObj, name);
        case "img":
            this.createImageNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "tit":
        case "text":
            this.createTitleNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "title":
            this.createSingleTitleNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "subtitle":
            this.createSingleSubTitleNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "label":
            this.createSingleLabelNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "num":
            this.createNumberNode(nodeParent, currentIndex);
            break;
        case "bgimage1":
            this.createBgImage(1, currentIndex);
            break;
        case "bgimage2":
            this.createBgImage(2, currentIndex);
            break;
        case "presetimage":
            this.createPresetImage(currentIndex);
            break;
        case "pointimage":
        case "pointimage1":
        case "pointimage2":
        case "pointimage3":
        case "pointimage4":
        case "pointimage5":
        case "pointimage6":
        case "pointimage7":
        case "pointimage8":
        case "pointimage9":
        case "pointimage10":
            this.createPointImage(nodeParent, currentIndex);
            break;
        case "duplicateimage":
            this.createDuplicateImage(currentIndex);
            break;
        case "shape1":
        case "shape2":
        case "shape3":
        case "shape4":
        case "shape5":
            let propertyValue = null;
            let propName = currentIndex == 0 ? "introproperties" : "properties";
            let metaDataBase = this.getMetaDataCommon();
            if (metaDataBase && metaDataBase[this.deviceModel]) metaDataBase = metaDataBase[this.deviceModel];
            if (metaDataBase && metaDataBase[propName] && metaDataBase[propName] && metaDataBase[propName][name]) propertyValue = metaDataBase[propName][name];
            this.createShapes(nodeParent, name, propertyValue, currentIndex);
            break;
        case "placeholderimage":
            this.createPlaceHolder(nodeParent, currentIndex);
            break;
        case "authtext":
            this.authTextBase(nodeParent, currentIndex, nodeObj.flexvalue);
            break;
        case "authimg":
            this.authImageBase(nodeParent, currentIndex);
            break;
        case "ctabutton":
            this.ctaButtonCreate(nodeParent, currentIndex);
            break;
        case "commonbg":
            this.createCommonBgImage(nodeParent, currentIndex);
            break;
        default:
            break;
    }
    if (name.includes("pointshape")) {
        let props = this.getProps();
        let propertyValue = props && props[name] ? props[name] : null;
        this.createShapesInsidePage(nodeParent, name, propertyValue, currentIndex);
    } else if (name.includes("point") && name.includes("shape")) {
        let props = this.getProps();
        let propertyValue = props && props[name] ? props[name] : null;
        let shapeName = name.slice(name.indexOf("shape") + 5);
        let shapeIndex = name.substr(0, name.indexOf("shape")).replace("point", "");
        if (parseInt(shapeIndex) == currentIndex) this.createShapesInsidePage(nodeParent, "pointshape" + shapeName, propertyValue, currentIndex);
    }
};

GenericSpecialgraphicsCommon.prototype.getMetaDataCommon = function () {
    let metaDataBase =
        this.metaData && this.metaData.menuData ? (this.metaData.menuData && Object.keys(this.metaData.menuData).length == 1 ? this.metaData.menuData[Object.keys(this.metaData.menuData)] : this.metaData.menuData) : this.metaData && this.metaData && Object.keys(this.metaData).length == 1 ? this.metaData : null;
    return metaDataBase;
};

GenericSpecialgraphicsCommon.prototype.getProps = function () {
    //Get slide properties
    let props = null;
    let metaDataBase = this.getMetaDataCommon();
    let secondaryProp = null;
    if (metaDataBase && metaDataBase.properties) secondaryProp = metaDataBase.properties;
    if (metaDataBase && metaDataBase[this.deviceModel]) metaDataBase = metaDataBase[this.deviceModel];
    if (metaDataBase && metaDataBase.properties) props = metaDataBase.properties;
    let returnVal = props ? props : secondaryProp;
    if (returnVal && ((returnVal.text && returnVal.text.textstyle) || (returnVal.number && returnVal.number.numberstyle) || (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle))) {
        let textPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.textproperties ? this.objDataToSG.sgMoodsData.textproperties : null;
        let numberPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.numberproperties ? this.objDataToSG.sgMoodsData.numberproperties : null;
        let placeholderPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.placeholderimageproperties ? this.objDataToSG.sgMoodsData.placeholderimageproperties : null;

        if (returnVal.text && returnVal.text.textstyle && textPropFromMood && textPropFromMood[returnVal.text.textstyle]) {
            let newValue = textPropFromMood[returnVal.text.textstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.text[key] = newValue[key];
            });
            delete returnVal.text.textstyle;
        }
        if (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle && placeholderPropFromMood && placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle]) {
            let newValue = placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.placeholderimage[key] = newValue[key];
            });
            delete returnVal.placeholderimage.placeholderimagestyle;
        }
        if (returnVal.number && returnVal.number.numberstyle && numberPropFromMood && numberPropFromMood[returnVal.number.numberstyle]) {
            let newValue = numberPropFromMood[returnVal.number.numberstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.number[key] = newValue[key];
            });
            delete returnVal.number.numberstyle;
        }
    }
    return returnVal;
};
GenericSpecialgraphicsCommon.prototype.getIntroProps = function () {
    //Get intro slide properties
    let props = null;
    let metaDataBase = this.getMetaDataCommon();
    let secondaryProp = null;
    if (metaDataBase && metaDataBase.introproperties) secondaryProp = metaDataBase.introproperties;
    if (metaDataBase && metaDataBase[this.deviceModel]) metaDataBase = metaDataBase[this.deviceModel];
    if (metaDataBase && metaDataBase.introproperties) props = metaDataBase.introproperties;

    let returnVal = props ? props : secondaryProp ? secondaryProp : this.getProps();
    if (returnVal && ((returnVal.text && returnVal.text.textstyle) || (returnVal.number && returnVal.number.numberstyle) || (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle))) {
        let textPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.textproperties ? this.objDataToSG.sgMoodsData.textproperties : null;
        let numberPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.numberproperties ? this.objDataToSG.sgMoodsData.numberproperties : null;
        let placeholderPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.placeholderimageproperties ? this.objDataToSG.sgMoodsData.placeholderimageproperties : null;

        if (returnVal.text && returnVal.text.textstyle && textPropFromMood && textPropFromMood[returnVal.text.textstyle]) {
            let newValue = textPropFromMood[returnVal.text.textstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.text[key] = newValue[key];
            });
            delete returnVal.text.textstyle;
        }
        if (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle && placeholderPropFromMood && placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle]) {
            let newValue = placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.placeholderimage[key] = newValue[key];
            });
            delete returnVal.placeholderimage.placeholderimagestyle;
        }
        if (returnVal.number && returnVal.number.numberstyle && numberPropFromMood && numberPropFromMood[returnVal.number.numberstyle]) {
            let newValue = numberPropFromMood[returnVal.number.numberstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.number[key] = newValue[key];
            });
            delete returnVal.number.numberstyle;
        }
    }
    return returnVal;
};
GenericSpecialgraphicsCommon.prototype.createContentNode = function (parent, props, id) {
    if (id == "contentMainParent" && parent.querySelector("[id='contentMainParent']")) parent.querySelector("[id='contentMainParent']").parentElement.removeChild(parent.querySelector("[id='contentMainParent']"));
    let nodeParent = document.createElement("div");
    nodeParent.className = id;
    nodeParent.style.pointerEvents = "none";
    nodeParent.setAttribute("id", id);
    parent.appendChild(nodeParent);
    nodeParent.style.display = "flex";
    this.setTextType(nodeParent);

    if (props && props.class) {
        nodeParent.className = id + "  " + props.class;
        if (nodeParent.classList.contains("valign_s") || nodeParent.classList.contains("valign_c") || nodeParent.classList.contains("valign_e")) {
            let direction = window.getComputedStyle(nodeParent).flexDirection;
            if (direction == "row") nodeParent.style.alignItems = nodeParent.classList.contains("valign_c") ? "center" : nodeParent.classList.contains("valign_e") ? "flex-end" : "flex-start";
            else nodeParent.style.justifyContent = nodeParent.classList.contains("valign_c") ? "center" : nodeParent.classList.contains("valign_e") ? "flex-end" : "flex-start";
        }
        if (nodeParent.classList.contains("halign_s") || nodeParent.classList.contains("halign_c") || nodeParent.classList.contains("halign_e")) {
            let direction = window.getComputedStyle(nodeParent).flexDirection;
            if (direction == "row") nodeParent.style.justifyContent = nodeParent.classList.contains("halign_c") ? "center" : nodeParent.classList.contains("halign_e") ? "flex-end" : "flex-start";
            else nodeParent.style.alignItems = nodeParent.classList.contains("halign_c") ? "center" : nodeParent.classList.contains("halign_e") ? "flex-end" : "flex-start";
        }
    } else nodeParent.style.display = "block";
    if (props.positionvalue) nodeParent.style.position = props.positionvalue;
    if (props.zorder) nodeParent.style.zIndex = props.zorder;
    if (props.order) nodeParent.style.order = props.order;
    if (props.flexvalue) nodeParent.style.flex = props.flexvalue;
    if (props.position && props.position.split(",").length == 4) this.specialgraphicsPropertyUtils.updatePosition(nodeParent, props.position);

    if (props.padding) this.specialgraphicsPropertyUtils.updatePadding(props.padding, nodeParent, true);
    if (props.margin) this.specialgraphicsPropertyUtils.updateMargin(props.margin, nodeParent, true);
    if (props.maxwidth) {
        // nodeParent.style.maxWidth = props.maxwidth + (props.maxwidth.includes("px") || props.maxwidth.includes("%") ? "" : "px");
        nodeParent.style.width = props.maxwidth + (props.maxwidth.includes("px") || props.maxwidth.includes("%") ? "" : "px");
        nodeParent.setAttribute("fullwidth", window.getComputedStyle(nodeParent).width);
    }
    if (props.maxheight) {
        let oldH = null;
        if (nodeParent.parentElement.hasAttribute("fullheight")) {
            oldH = nodeParent.parentElement.style.height;
            nodeParent.parentElement.style.height = nodeParent.parentElement.getAttribute("fullheight");
        }

        let oldHeight = nodeParent.style.height;
        nodeParent.style.height = props.maxheight + (props.maxheight.includes("px") || props.maxheight.includes("%") ? "" : "px");
        nodeParent.style.maxHeight = props.maxheight + (props.maxheight.includes("px") || props.maxheight.includes("%") ? "" : "px");
        let h = window.getComputedStyle(nodeParent).height;
        nodeParent.style.height = oldHeight;
        nodeParent.setAttribute("fullheight", h);

        if (oldH && nodeParent.parentElement.hasAttribute("fullheight")) nodeParent.parentElement.style.height = oldH;
    }
    this.specialGraphicsUtils.updatePaddingMarginInlineStyle(nodeParent);
    // let styleData = window.getComputedStyle(nodeParent);
    // nodeParent.style.setProperty("--paddingLeft", styleData.paddingLeft);
    // nodeParent.style.setProperty("--paddingRight", styleData.paddingRight);
    // nodeParent.style.setProperty("--paddingTop", styleData.paddingTop);
    // nodeParent.style.setProperty("--paddingBottom", styleData.paddingBottom);
    // nodeParent.style.setProperty("--marginLeft", styleData.marginLeft);
    // nodeParent.style.setProperty("--marginRight", styleData.marginRight);
    // nodeParent.style.setProperty("--marginTop", styleData.marginTop);
    // nodeParent.style.setProperty("--marginBottom", styleData.marginBottom);

    return nodeParent;
};
GenericSpecialgraphicsCommon.prototype.authTextBase = function (nodeParent, currentIndex, flexValue) {
    this.createAuthorTextBase(nodeParent, flexValue, currentIndex);

    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let authtextProperty = null;
    if (props && props["authtext"]) authtextProperty = props["authtext"];
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    this.applyAuthTextPropertyCommon(authtextProperty, assetParent, this.specialgraphicsPropertyUtils);
};
GenericSpecialgraphicsCommon.prototype.ctaButtonCreate = function (nodeParent, currentIndex) {
    this.createCtaButtonNode(nodeParent, currentIndex);
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    this.applyCtaButtonProps(props, currentIndex);
};
GenericSpecialgraphicsCommon.prototype.authImageBase = function (nodeParent, currentIndex) {
    this.createAuthorImageNode(nodeParent, currentIndex);

    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let authimageProperty = null;
    if (props && props["authimg"]) authimageProperty = props["authimg"];
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let arrAssets = this.applyAuthImagePropertyCommon(authimageProperty, assetParent, this.specialgraphicsPropertyUtils, currentIndex);
    if (arrAssets) this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
};
GenericSpecialgraphicsCommon.prototype.createPresetImage = function (currentIndex) {
    //Create preset image
    let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (!deviceImageParentNode) {
        deviceImageParentNode = document.createElement("div");
        deviceImageParentNode.id = "deviceImageParentNode";
        deviceImageParentNode.className = "deviceImageParentNode";
        this.sgParent.insertBefore(deviceImageParentNode, assetParent0);
    }

    this.createPresetImageNode(deviceImageParentNode);
    this.applyPresetImgeProperty(currentIndex);
};
GenericSpecialgraphicsCommon.prototype.applyPresetImgeProperty = function (currentIndex) {
    //Apply preset image properties
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props && props.presetimage && this.sgParent.querySelector("[id='presetImageParent']")) {
        let presetImageParent = this.sgParent.querySelector("[id='presetImageParent']");
        let presetImageNode = this.sgParent.querySelector("[id='presetImageNode']");
        if (props.presetimage.positionvalue && presetImageParent) presetImageParent.style.position = props.presetimage.positionvalue;
        if (props.presetimage.imageurl && presetImageNode) presetImageNode.src = this.appStaticURL + props.presetimage.imageurl;
        this.specialgraphicsPropertyUtils.applyImageBaseProps(props.presetimage, deviceImageParentNode, presetImageParent, "--presetImage");
    }
};
GenericSpecialgraphicsCommon.prototype.createPlaceHolder = function (parentNode, currentIndex) {
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    // let src = "";
    let placeholderProperty = null;
    if (props && props["placeholderimage"]) placeholderProperty = props["placeholderimage"];
    // if (placeholderProperty && placeholderProperty.imageurl) src = placeholderProperty.imageurl;
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");

    this.createPlaceHolderImage(parentNode, currentIndex);
    let parentElement = parentNode.querySelector("[id*='placeHolderParent']");
    let logoParent = parentElement.querySelector("[id*='logoContentParent']");
    let imageParent = parentElement.querySelector("[id*='phImageContentParent']");
    let iconParent = parentElement.querySelector("[id*='phIconContentParent']");
    let textParent = parentElement.querySelector("[id*='phTextParent']");
    let phTextNode = parentElement.querySelector("[id*='phTextNode']");
    let logoImageNode = logoParent ? logoParent.querySelector("[id='sgLogoImageNode']") : null;

    let placeHolderType = this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagetype ? this.sgData[currentIndex].placeholderimagetype : placeholderProperty && placeholderProperty.placeholderimagetype ? placeholderProperty.placeholderimagetype : "logo";
    if (placeHolderType && logoParent && imageParent && iconParent && textParent) {
        logoParent.classList.remove("placeholderactive");
        imageParent.classList.remove("placeholderactive");
        iconParent.classList.remove("placeholderactive");
        textParent.classList.remove("placeholderactive");
        if (placeHolderType == "logo") logoParent.classList.add("placeholderactive");
        if (placeHolderType == "image") imageParent.classList.add("placeholderactive");
        if (placeHolderType == "icon") iconParent.classList.add("placeholderactive");
        if (placeHolderType == "text") textParent.classList.add("placeholderactive");
        if (placeholderProperty && placeholderProperty.placeholdersizestyle) {
            let sizeStyle = placeholderProperty.placeholdersizestyle;
            if (!parentElement.classList.contains("placeholderSizeStyle")) parentElement.classList.add("placeholderSizeStyle");
            parentElement.setAttribute("data-placeholdersizestyle", sizeStyle);
            logoParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            imageParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            iconParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            textParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            if (!logoParent.classList.contains(sizeStyle)) logoParent.classList.add(sizeStyle);
            if (!imageParent.classList.contains(sizeStyle)) imageParent.classList.add(sizeStyle);
            if (!iconParent.classList.contains(sizeStyle)) iconParent.classList.add(sizeStyle);
            if (!textParent.classList.contains(sizeStyle)) textParent.classList.add(sizeStyle);
        }
    }

    if (placeholderProperty) this.specialgraphicsPropertyUtils.applyImageBaseProps(placeholderProperty, assetParent, parentElement, "--placeholderImage", false);

    let colorValue = placeholderProperty ? this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "secondary", placeholderProperty.textcolor) : null;
    // if (!colorValue && placeholderProperty.textcolor) colorValue = "rgba(var(--" + placeholderProperty.textcolor + "-color-rgb),1)";
    if (phTextNode && colorValue) {
        phTextNode.style.color = colorValue;
        phTextNode.setAttribute("data-color", colorValue);
    }

    if (placeholderProperty.margin) {
        let parentStyle = window.getComputedStyle(parentElement);
        assetParent.style.setProperty("--placeholderImageMarginTop", parentStyle.marginTop);
        assetParent.style.setProperty("--placeholderImageMarginBottom", parentStyle.marginBottom);
        assetParent.style.setProperty("--placeholderImageMarginLeft", parentStyle.marginLeft);
        assetParent.style.setProperty("--placeholderImageMarginRight", parentStyle.marginRight);
        parentElement.style.removeProperty("margin");
    }
    if (placeholderProperty.padding) {
        let parentStyle = window.getComputedStyle(parentElement);
        assetParent.style.setProperty("--placeholderImagePaddingTop", parentStyle.paddingTop);
        assetParent.style.setProperty("--placeholderImagePaddingBottom", parentStyle.paddingBottom);
        assetParent.style.setProperty("--placeholderImagePaddingLeft", parentStyle.paddingLeft);
        assetParent.style.setProperty("--placeholderImagePaddingRight", parentStyle.paddingRight);
        parentElement.style.removeProperty("padding");
    }
    if (this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagesize && parentElement) parentElement.setAttribute("data-placeholderimagesize", this.sgData[currentIndex].placeholderimagesize);
    if (placeHolderType == "image" || placeHolderType == "logo" || placeHolderType == "icon" || placeHolderType == "text") this.setLogoSizes(assetParent, placeHolderType);

    if (this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagealign) {
        let alignData = this.sgData[currentIndex].placeholderimagealign;
        if (alignData == "bottom" || alignData == "right") parentElement.classList.add("phPosition");
        else parentElement.classList.remove("phPosition");
    }
    if (placeholderProperty && placeholderProperty.placeholderalign) parentElement.setAttribute("phalign", placeholderProperty.placeholderalign);
    if (this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagesize) {
        //Implement placeholder size change from floter
        // let sizeV = this.sgData[currentIndex].placeholderimagesize;
        // let multipleValue = sizeV == "small" ? 0.4 : sizeV == "medium" ? 0.7 : sizeV == "large" ? 1 : parseFloat(sizeV);
        let multipleValue = this.specialGraphicsUtils.getImageSizeSML(this.sgData[currentIndex].placeholderimagesize);
        let largeW = parseFloat(parentElement.getAttribute("data-largewidth"));
        let largeH = parseFloat(parentElement.getAttribute("data-largeheight"));
        let newW = largeW * multipleValue;
        let newH = largeH * multipleValue;
        let cropHeight = logoImageNode && logoImageNode.hasAttribute("logosizecropheight") ? logoImageNode.getAttribute("logosizecropheight") : "";
        if (newW > 0 && newH > 0) {
            parentElement.style.width = newW + "px";
            if (cropHeight == "") parentElement.style.height = newH + "px";
        }
        if (logoImageNode) logoImageNode.removeAttribute("logosizecropheight");
    }
    let hasPlaceholderData = this.sgData[currentIndex].placeholderimage != null && this.sgData[currentIndex].placeholderimage != undefined;
    if (placeHolderType == "icon" && iconParent && hasPlaceholderData) {
        let iconPath = this.sgData[currentIndex].placeholderimage.includes(".svg") ? this.sgData[currentIndex].placeholderimage : this.appStaticURL + "genericassets/icons/fill/default/best.svg";
        let iconNodeParent = iconParent.querySelector("[id*='phIconSvgNode']");
        let arrAssets = [];
        if (iconNodeParent) iconNodeParent.setAttribute("data-src", iconPath);
        arrAssets.push({ url: iconPath, id: "svgdata", parent: iconNodeParent, type: "SVG" });
        this.arrCommonAssets.push({ array: arrAssets, callback: this.placeholderSvgLoadCallback });
    }
    if (placeholderProperty && placeholderProperty.halign) {
        let halignProp = placeholderProperty.halign;
        let hAlign = halignProp == "right" || halignProp == "end" ? "flex-end" : halignProp == "center" || halignProp == "middle" ? "center" : "flex-start";
        let pos = halignProp == "right" || halignProp == "end" ? "right" : halignProp == "center" || halignProp == "middle" ? "center" : "left";
        if (logoImageNode) logoImageNode.setAttribute("data-imagecropalignment", pos);
        let phTextNode = textParent.querySelector("[id*='phTextNode']");
        if (phTextNode) phTextNode.style.textAlign = hAlign;
    }
    if (this.sgData[currentIndex].placeholderimagecontrast && logoImageNode) {
        logoImageNode.classList.remove("logoBrightnessSGUnset");
        if (this.sgData[currentIndex].placeholderimagecontrast == "false") logoImageNode.classList.add("logoBrightnessSGUnset");
    }
    this.applyContrastToText(logoImageNode, placeholderProperty);
    this.applyContrastToText(phTextNode, placeholderProperty);
};
GenericSpecialgraphicsCommon.prototype.createBgImage = function (imageIndex = 1, currentIndex) {
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let type = "img";
    let src = "";
    let bgImageProperty = null;
    if (props && props["bgimage" + imageIndex]) bgImageProperty = props["bgimage" + imageIndex];
    if (bgImageProperty && bgImageProperty.type && bgImageProperty.type == "video") type = "video";
    if (bgImageProperty && bgImageProperty.imageurl) src = bgImageProperty.imageurl;
    let defaultURL = this.specialGraphicsUtils.getMoodBasedVideo(this.objDataToSG);
    if (defaultURL) src = defaultURL;
    if (this.sgData[1].presetimage && type == "video") src = this.sgData[1].presetimage;

    let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
    // let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let oldImage = this.sgParent.querySelector("[id*='bgImage" + (imageIndex == 1 ? "" : imageIndex) + "Node']");
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (!oldImage) {
        if (!deviceImageParentNode) {
            deviceImageParentNode = document.createElement("div");
            deviceImageParentNode.id = "deviceImageParentNode";
            deviceImageParentNode.className = "deviceImageParentNode";
            this.sgParent.insertBefore(deviceImageParentNode, assetParent0);
        }

        oldImage = this.createBgImageNode(deviceImageParentNode, (imageIndex == 1 ? "" : imageIndex) + "Node", type, src);
        if (type == "video" && (bgImageProperty.loop == "false" || bgImageProperty.loop == false)) oldImage.loop = false;
        oldImage.setAttribute("data-fit", "false");
        if (type == "video") {
            oldImage.setAttribute("data-isvideo", "true");
            this.sgParent.setAttribute("data-isvideo", "true");
            oldImage.style.pointerEvents = "auto";
        }
    }
    this.applyBgImageProperty(imageIndex, bgImageProperty, currentIndex, type);
};
GenericSpecialgraphicsCommon.prototype.applyBgImageProperty = function (imageIndex, bgImageProperty, currentIndex, type) {
    if (!bgImageProperty) {
        let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
        if (props && props["bgimage" + imageIndex]) bgImageProperty = props["bgimage" + imageIndex];
    }
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let oldImage = this.sgParent.querySelector("[id*='bgImage" + (imageIndex == 1 ? "" : imageIndex) + "Node']");
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (bgImageProperty && oldImage) {
        let bgImage = oldImage;
        if (bgImageProperty.positionvalue && bgImage) bgImage.style.position = bgImageProperty.positionvalue;
        // if (this.sgData[1].presetimage && type == "video") bgImageProperty.imageurl = this.sgData[1].presetimage;
        // if (bgImageProperty.imageurl && bgImage) {
        //     let src = bgImageProperty.imageurl;
        //     if (src && src.includes("genericassets/") && !src.includes("assets/projectresources/")) src = this.appStaticURL + src;
        //     bgImage.src = src;
        // }
        this.specialgraphicsPropertyUtils.applyImageBaseProps(bgImageProperty, deviceImageParentNode, bgImage, "--bg");
        if (bgImageProperty.zorder) bgImage.style.zIndex = bgImageProperty.zorder;
        if (bgImageProperty.contrast && bgImageProperty.contrast == "fullbg") {
            if (bgImage) {
                bgImage.setAttribute("contrast", "fullbg");
                this.eventManager.dispatch("applyImageContrast", bgImage, assetParent);
            }
        } else if (bgImageProperty.contrast && bgImageProperty.contrast == "halfbg") {
            if (bgImage) {
                bgImage.setAttribute("contrast", "halfbg");
                this.eventManager.dispatch("applyImageContrast", bgImage, assetParent, true);
            }
        } else if (this.slideContent) {
            this.slideContent.classList.remove("fixedlightText");
            this.slideContent.classList.remove("fixeddarkText");
        }
        let videoContrast = this.sgData[1] && this.sgData[1].presetimagecontrast ? this.sgData[1].presetimagecontrast : null;
        let contrast = videoContrast ? videoContrast : bgImageProperty.fixedcontrast;
        if (contrast) {
            assetParent.classList.remove("darkText");
            assetParent.classList.remove("lightText");
            assetParent.classList.remove("fixedlightText");
            assetParent.classList.remove("fixeddarkText");
            assetParent.classList.add(contrast);
        }
        if (bgImageProperty.position) {
            let arrPosition = bgImageProperty.position.split(",");
            if (arrPosition.length >= 4 && deviceImageParentNode) {
                let bg = "--bg" + (imageIndex == 1 ? "" : "2");
                deviceImageParentNode.style.setProperty(bg + "Left", arrPosition[0] + (arrPosition[0].includes("px") || arrPosition[0].includes("%") || arrPosition[0].includes("auto") ? "" : "px"));
                deviceImageParentNode.style.setProperty(bg + "Top", arrPosition[1] + (arrPosition[1].includes("px") || arrPosition[1].includes("%") || arrPosition[1].includes("auto") ? "" : "px"));
                deviceImageParentNode.style.setProperty(bg + "Width", arrPosition[2] + (arrPosition[2].includes("px") || arrPosition[2].includes("%") || arrPosition[2].includes("auto") ? "" : "px"));
                deviceImageParentNode.style.setProperty(bg + "Height", arrPosition[3] + (arrPosition[3].includes("px") || arrPosition[3].includes("%") || arrPosition[3].includes("auto") ? "" : "px"));
            }
        }
    }
};
GenericSpecialgraphicsCommon.prototype.createDuplicateImage = function (currentIndex) {
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    if (props) this.specialgraphicsPropertyUtils.applyDuplicateImageProperties(props, assetParent, currentIndex, true);
};
GenericSpecialgraphicsCommon.prototype.createPointImage = function (parent, currentIndex) {
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let nodes = this.sgParent.querySelectorAll("[id*='pointImageParent']");
    if (props && currentIndex != 0 && nodes.length == 0 && this.sgData.length - 1 == currentIndex) {
        let arrAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
        for (let a = 1; a < arrAssetParent.length; a++) {
            let innerParent = arrAssetParent[a].querySelector("[id='" + parent.id + "']");
            this.createPointImageNode(innerParent, a);
        }

        for (let a = 1; a < arrAssetParent.length; a++) {
            let imageProperty = props.pointimage;
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["pointimage" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((a - 1) % loopIndex) + 1;
                imageProperty = props["pointimage" + ind];
            }
            let pointImageParentNode = arrAssetParent[a].querySelector("[id*='pointImageParent']");
            if (pointImageParentNode && imageProperty.imageurl) {
                let pointImageNode = pointImageParentNode.querySelector("[id*='pointImageNode']");
                pointImageNode.src = this.appStaticURL + imageProperty.imageurl;
                pointImageNode.setAttribute("data-fit", "false");
                this.specialgraphicsPropertyUtils.applyImageBaseProps(imageProperty, arrAssetParent[a], pointImageParentNode, "--pointImage");
                if (imageProperty.globalstyle) {
                    pointImageParentNode.parentElement.classList.remove(imageProperty.globalstyle);
                    pointImageParentNode.parentElement.classList.add(imageProperty.globalstyle);
                    pointImageParentNode.parentElement.classList.add("clsSingleColorParent");
                    pointImageParentNode.setAttribute("data-nodetype", "imageHolder");
                }
                if (imageProperty.positionvalue) arrAssetParent[a].style.setProperty("--pointImagePosition", imageProperty.positionvalue);
            }
        }
    }
};
GenericSpecialgraphicsCommon.prototype.createNumberNode = function (parent, currentIndex) {
    //number
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let numberContent = this.objDataToSG && this.objDataToSG.numberFormat ? this.specialGraphicsUtils.getSeqMoodStyle(this.objDataToSG.numberFormat, currentIndex) : null;
    if (!assetParent.classList.contains("introSlide")) this.createNumberTextNode(parent, currentIndex, numberContent);

    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props) {
        let numberProperty = props.number;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["number" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                numberProperty = props["number" + ind];
            }
        }
        let covernumber = assetParent.querySelector("[id*='sgNumberTextNode']");
        let sgNumberTextParent = assetParent.querySelector("[id='sgNumberTextParent']");

        let defaultProp = null;
        let numberPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.numberproperties ? this.objDataToSG.sgMoodsData.numberproperties : null;
        if (numberPropFromMood) {
            const keys = Object.keys(numberPropFromMood);
            keys.forEach((key) => {
                let element = numberPropFromMood[key];
                if (element && element.default && (element.default == "true" || element.default == true)) defaultProp = element;
            });
        }

        let newNumberProperty = !numberProperty ? defaultProp : numberProperty;
        if (newNumberProperty) {
            if (newNumberProperty.positionvalue && covernumber) {
                covernumber.style.position = newNumberProperty.positionvalue;
                if (sgNumberTextParent) sgNumberTextParent.style.position = newNumberProperty.positionvalue;
            }
            if (newNumberProperty.line && (newNumberProperty.line == "true") | (newNumberProperty.line == true) && covernumber) covernumber.parentElement.classList.add("numberline");
            let textAlign = null;
            if (newNumberProperty.halign && (covernumber || sgNumberTextParent)) {
                let hAlign = newNumberProperty.halign == "right" || newNumberProperty.halign == "end" ? "flex-end" : newNumberProperty.halign == "center" || newNumberProperty.valign == "middle" ? "center" : "flex-start";
                covernumber.style.justifyContent = hAlign;
                textAlign = hAlign == "flex-end" ? "end" : hAlign == "center" ? "center" : "start";
            }
            if (newNumberProperty.valign && (covernumber || sgNumberTextParent)) {
                let vAlign = newNumberProperty.valign == "bottom" || newNumberProperty.valign == "end" ? "flex-end" : newNumberProperty.valign == "center" || newNumberProperty.valign == "middle" ? "center" : "flex-start";
                if (sgNumberTextParent) sgNumberTextParent.style.alignItems = vAlign;
                else covernumber.style.alignItems = vAlign;
                this.sgParent.style.setProperty("--numberVAlign", vAlign);
            }
            this.specialgraphicsPropertyUtils.applyNumberProperties(props, covernumber, assetParent, 0, true);
            let node = covernumber;
            if (newNumberProperty.linecount && node) {
                node.setAttribute("data-linecount", newNumberProperty.linecount);
                this.specialGraphicsUtils.doFontFitForCss(node, this.sgParent);
            }
            if (newNumberProperty.rotate && sgNumberTextParent) {
                let lineHeight = parseFloat(window.getComputedStyle(covernumber)["line-height"]);
                lineHeight = isNaN(lineHeight) ? "40" : lineHeight;
                covernumber.style.minWidth = lineHeight + "px";
                covernumber.classList.add("covernumberRotation");
                covernumber.setAttribute("rotatednode", "true");
                covernumber.style.justifyContent = "flex-end";
                if (newNumberProperty.rotate.includes("-90")) covernumber.style.setProperty("--rotateTextRotation", "180deg");
                if (covernumber && textAlign) covernumber.style.setProperty("--rotateTextAlign", textAlign);
                this.specialGraphicsUtils.doFontFitForCss(covernumber, this.sgParent, null, null, null, true);
            }
            if (newNumberProperty.prefix && node) {
                node.setAttribute("prefix", newNumberProperty.prefix);
                node.innerText.replace(newNumberProperty.prefix, "");
                node.innerText = newNumberProperty.prefix + " " + node.innerText;
            }
            if (newNumberProperty.suffix && node) {
                node.setAttribute("suffix", newNumberProperty.suffix);
                node.innerText.replace(newNumberProperty.suffix, "");
                node.innerText = node.innerText + " " + newNumberProperty.suffix;
            }
            this.applyContrastToText(node, newNumberProperty);
        }
    }
};
GenericSpecialgraphicsCommon.prototype.createTitleNode = function (parent, flexValue = "", currentIndex) {
    //Text Nodes - "tit"
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let textInnerParent = this.createTextBase(parent, currentIndex);
    let textBaseParent = assetParent.querySelector("[id*='textBaseParentNode']");
    if (textBaseParent) {
        let zOrderValue = 0;
        let textZIndex = parseFloat(window.getComputedStyle(textBaseParent).zIndex);
        let parentZIndex = parseFloat(window.getComputedStyle(parent).zIndex);
        if (!isNaN(parentZIndex) && parentZIndex > 0) zOrderValue = parentZIndex;
        if (!isNaN(textZIndex) && textZIndex > 0) zOrderValue = zOrderValue + textZIndex;

        textBaseParent.style.zIndex = zOrderValue;
    }
    if (flexValue && flexValue != "") textBaseParent.style.flex = flexValue;
    this.createTitleSet(textInnerParent, currentIndex, assetParent);
    this.applyTextProperty(currentIndex, textBaseParent);
    if (this.objDataToSG && this.objDataToSG.theme && this.objDataToSG.theme) {
        let title = textInnerParent.querySelector("[id*='sgTitleNode']");
        let subTitle = textInnerParent.querySelector("[id*='sgSubTitleNode']");
        let label = textInnerParent.querySelector("[id*='sgTitleLabelNode']");
        let titleColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "title");
        let subtitleColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "subtitle");
        let labelColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "label");
        if (titleColor && title && !title.hasAttribute("data-supportcontrast")) {
            title.style.setProperty("color", titleColor);
            title.setAttribute("data-color", titleColor);
        }
        if (subtitleColor && subTitle && !subTitle.hasAttribute("data-supportcontrast")) {
            subTitle.style.setProperty("color", subtitleColor);
            subTitle.setAttribute("data-color", subtitleColor);
        }
        if (labelColor && label && !label.hasAttribute("data-supportcontrast")) {
            label.style.setProperty("color", labelColor);
            label.setAttribute("data-color", labelColor);
        }
    }
};
GenericSpecialgraphicsCommon.prototype.applyTextProperty = function (currentIndex, textBaseParent) {
    //Applying Text Property
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    if (props && props && assetParent) {
        let textProperty = props.text;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["text" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                textProperty = props["text" + ind];
            }
        }
        for (let d = 0; d < 1; d++) {
            let secondaryProps = null;
            let defaultProp = null;
            let textPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.textproperties ? this.objDataToSG.sgMoodsData.textproperties : null;
            if (d == 1 && textProperty && textProperty.textstyle && textPropFromMood) secondaryProps = textPropFromMood[textProperty.textstyle];
            if (d == 0 && textPropFromMood) {
                const keys = Object.keys(textPropFromMood);
                keys.forEach((key) => {
                    let element = textPropFromMood[key];
                    if (element && element.default && (element.default == "true" || element.default == true)) defaultProp = element;
                });
            }

            let newTextProperty = d == 0 ? (!textProperty ? defaultProp : textProperty) : secondaryProps;
            if (newTextProperty) {
                this.specialgraphicsPropertyUtils.applyTextProperties(d == 1 ? { text: newTextProperty } : newTextProperty, assetParent, currentIndex, true, true);
                let isSupportTextPosition = newTextProperty.positionchange && (newTextProperty.positionchange == "true" || newTextProperty.positionchange == true) ? true : false;
                //Applying text position
                let textPosition = this.sgData[currentIndex] && this.sgData[currentIndex]["titletextposition"] ? this.sgData[currentIndex]["titletextposition"] : newTextProperty && newTextProperty.defaulttextposition ? newTextProperty.defaulttextposition : "sgMM";
                if (textPosition && textPosition != "" && textBaseParent && isSupportTextPosition) {
                    this.specialGraphicsUtils.removeTextPositionClass(textBaseParent.parentElement);
                    textBaseParent.parentElement.classList.add("sg" + textPosition.replace("sg", ""));
                    assetParent.setAttribute("textPosition", textPosition);
                }
            }
        }
    }
};
GenericSpecialgraphicsCommon.prototype.createSingleTitleNode = function (parent, flexValue = "", currentIndex) {
    //Text Nodes - title only
    let textParent = this.createSingleTitle(parent, currentIndex);
    if (flexValue && flexValue != "") textParent.style.flex = flexValue;

    this.applyTitleProperty(currentIndex);
};
GenericSpecialgraphicsCommon.prototype.applyTitleProperty = function (currentIndex) {
    //Apply single Title node property
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props && props) {
        let textProperty = props.title;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["title" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                textProperty = props["title" + ind];
            }
        }
        this.applySingleNodeProps(currentIndex, "titleTextParent", "sgTitleNode", textProperty);
    }
};
GenericSpecialgraphicsCommon.prototype.createSingleSubTitleNode = function (parent, flexValue = "", currentIndex) {
    //Text Nodes - title only
    let textParent = this.createSingleSubTitle(parent, currentIndex);
    if (flexValue && flexValue != "") textParent.style.flex = flexValue;

    this.applySubTitleProperty(currentIndex);
};
GenericSpecialgraphicsCommon.prototype.applySubTitleProperty = function (currentIndex) {
    //Apply single subtitle node property
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props && props) {
        let textProperty = props.subtitle;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["subtitle" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                textProperty = props["subtitle" + ind];
            }
        }
        this.applySingleNodeProps(currentIndex, "subTitleTextParent", "sgSubTitleNode", textProperty);
    }
};
GenericSpecialgraphicsCommon.prototype.createSingleLabelNode = function (parent, flexValue = "", currentIndex) {
    //Text Nodes - title only
    let textParent = this.createSingleLabel(parent, currentIndex);
    if (flexValue && flexValue != "") textParent.style.flex = flexValue;

    this.applyLabelProperty(currentIndex);
};
GenericSpecialgraphicsCommon.prototype.applyLabelProperty = function (currentIndex) {
    //Apply single title label proprty
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props && props) {
        let textProperty = props.label;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["label" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                textProperty = props["label" + ind];
            }
        }
        this.applySingleNodeProps(currentIndex, "titleLabelTextParent", "sgTitleLabelNode", textProperty);
    }
};
GenericSpecialgraphicsCommon.prototype.createImageNode = function (parent, flexValue = "", currentIndex) {
    //Coverimage - "img"
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let imageProperty = this.getImageProperty(currentIndex);
    let coverParent = this.createCoverImageParent(parent, currentIndex, true, imageProperty);
    if (flexValue && flexValue != "") coverParent.style.flex = flexValue;
    // let isSvgSupport = false;
    // if (imageProperty && imageProperty.supportsvg && (imageProperty.supportsvg == true || imageProperty.supportsvg == "true")) isSvgSupport = true;
    let isSvgSupport = imageProperty?.supportsvg && imageProperty.supportsvg == "false" ? false : true;
    this.createCoverImageNode(coverParent, currentIndex, "generic", isSvgSupport);

    let coverImageParent = assetParent.querySelector("[id*='coverImageParent']");
    let coverImageOverlay = coverImageParent ? coverImageParent.querySelector("[id*='coverImageOverlay']") : null;
    if (coverImageParent) {
        let zOrderValue = 0;
        let imageZIndex = parseFloat(window.getComputedStyle(coverImageParent).zIndex);
        let parentZIndex = parseFloat(window.getComputedStyle(parent).zIndex);
        if (!isNaN(parentZIndex) && parentZIndex > 0) zOrderValue = parentZIndex;
        if (!isNaN(imageZIndex) && imageZIndex > 0) zOrderValue = zOrderValue + imageZIndex;

        coverImageParent.style.zIndex = zOrderValue;
    }

    if (imageProperty) {
        let props = imageProperty;
        let mainProps = currentIndex == 0 ? this.getIntroProps() : this.getProps();
        let imagePosition = mainProps && mainProps.imageposition ? mainProps.imageposition : "left";

        let menuJson = this.objDataToSG && this.objDataToSG.menufromjson ? this.objDataToSG.menufromjson : null;
        let coverParent = coverImageParent?.querySelector("[id*='coverParent']");
        if (menuJson && menuJson.floateroptions && menuJson.floateroptions.includes("imagebleed") && coverImageParent) {
            if (coverParent) coverParent.setAttribute("imagebleedoption", "true");
        }
        if (coverParent && this.sgData[currentIndex].coverimageprompt) coverParent.setAttribute("data-node-graphic-text", this.sgData[currentIndex].coverimageprompt);

        this.specialgraphicsPropertyUtils.applyImageProperties(props, assetParent, currentIndex, props);
        if (props.positionvalue && coverImageParent) coverImageParent.style.position = props.positionvalue;
        if (props.padding && props.padding.split(",").length == 4 && coverImageParent) this.specialgraphicsPropertyUtils.updateMargin(props.padding, coverImageParent);
        if (props.contrast && props.contrast == "fullbg") {
            let imageNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            if (imageNode) {
                imageNode.setAttribute("contrast", "fullbg");
                this.eventManager.dispatch("applyImageContrast", imageNode, assetParent);
            }
        } else if (props.contrast && props.contrast == "halfbg") {
            let imageNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            if (imageNode) {
                imageNode.setAttribute("contrast", "halfbg");
                this.eventManager.dispatch("applyImageContrast", imageNode, assetParent, true);
            }
        } else if (this.slideContent) {
            this.slideContent.classList.remove("fixedlightText");
            this.slideContent.classList.remove("fixeddarkText");
        }
        if (props.fixedcontrast) {
            assetParent.classList.remove("darkText");
            assetParent.classList.remove("lightText");
            assetParent.classList.remove("fixedlightText");
            assetParent.classList.remove("fixeddarkText");
            assetParent.classList.add(props.fixedcontrast);
            // assetParent.setAttribute("highlight", "false");
        }
        if (props.overlayindex && this.applyOverlayToImageSG) {
            let imageNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            if (imageNode && !imageNode.hasAttribute("data-csstext")) this.applyOverlayToImageSG(imageNode, props.overlayindex);
        }
        if (props.overlayname && this.applyOverlayToImageSG) {
            let imageNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            if (imageNode && !imageNode.hasAttribute("data-csstext")) this.applyOverlayToImageSG(imageNode, null, props.overlayname);
        }
        if (props.globalstyle && coverImageParent) {
            coverImageParent.classList.remove(props.globalstyle);
            coverImageParent.classList.add(props.globalstyle);
            coverImageParent.classList.add("clsSingleColorParent");

            let percentValue = window.getComputedStyle(coverImageParent).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
            percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
            let sourceNode = coverImageParent.querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
            if (sourceNode) coverImageParent.style.setProperty("--customNodeBorderImageWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
        }
        coverImageParent.classList.add("clsMultiColorParent");
        coverImageParent.style.setProperty("--customItemColor", "var(--accent" + currentIndex + "-color-rgb)", "important");
        if (props.multicoloroverlay && (props.multicoloroverlay == "true" || props.multicoloroverlay == true) && coverImageOverlay) coverImageOverlay.style.backgroundColor = "rgba(var(--node-theme-color),1)";

        if (props.vposition && coverImageParent) {
            let align = props.vposition == "top" || props.vposition == "start" ? "Top" : props.vposition == "center" || props.vposition == "middle" ? "Center" : "Bottom";
            coverImageParent.classList.add("coverAlign" + align);
        }

        // if (props.supportsvg) {
        let arrAssets = [];
        let hasSVG = this.sgData[currentIndex].coverimage.includes(".svg");
        // let path = this.sgData[currentIndex].coverimage.includes(".svg") ? this.sgData[currentIndex].coverimage : "genericassets/illustrations/industry_agnostic/breaker_slide/breaker_slide_1.svg";
        // this.sgData[currentIndex].coverimage = path;

        if (props.supportsvg && props.supportsvg == "false" && hasSVG) {
            this.sgData[currentIndex].coverimage = this.appStaticURL + "genericassets/placeholderimages/coverimage.jpg";
            this.sgParent.removeAttribute("data-svgsupport");
            hasSVG = false;
            if (this.sgParent.parentElement.parentElement) {
                let slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
                if (slideDomContentGroup.getElementsByTagName("coverimage").length > 0) slideDomContentGroup.getElementsByTagName("coverimage")[0].setAttribute("data-src", this.sgData[currentIndex].coverimage);
            }
        }

        if (hasSVG == true) {
            arrAssets.push({ url: this.sgData[currentIndex].coverimage, id: "svgdata", type: "SVG", parent: coverImageParent });
            this.arrCommonAssets.push({ array: arrAssets, callback: this.assetsLoadComplete });
        }

        let svgElementDiv = assetParent.querySelector("[id='svgElementDiv']");
        let coverimage = assetParent.querySelector("[data-target-id='coverimage']");
        if (svgElementDiv && coverimage) {
            svgElementDiv.style.display = hasSVG ? "flex" : "none";
            coverimage.style.display = hasSVG ? "none" : "flex";
        }
        // } else if (this.sgData[currentIndex].coverimage.includes(".svg")) {
        //     this.sgData[currentIndex].coverimage = this.appStaticURL + "genericassets/placeholderimages/coverimage.jpg";
        //     let svgElementDiv = this.sgParent.querySelector("[id='svgElementDiv']");
        //     let coverimage = this.sgParent.querySelector("[data-target-id='coverimage']");
        //     if (svgElementDiv) svgElementDiv.style.display = "none";
        //     if (coverimage) {
        //         coverimage.style.display = "block";
        //         coverimage.src = this.sgData[currentIndex].coverimage;
        //     }
        // }
        if (props.imageurl && coverImageParent) {
            let coverimage = coverImageParent.querySelector("[data-target-id='coverimage']");
            coverimage.src = this.appStaticURL + props.imageurl;
            this.specialGraphicsUtils.updateImageReSize(coverimage.getAttribute("data-width"), coverimage.getAttribute("data-height"), coverimage);
        }
        if (props.contentBG) {
            let arrAssets = [];
            arrAssets.push({ parent: coverImageParent, type: "svg", url: props.contentBG.value, id: props.contentBG.id });
            this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
        }
        if (props.resize && props.resize == "enable" && coverImageParent && coverImageParent.querySelector("[data-target-id='coverimage']")) {
            let imgNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            // imgNode.setAttribute("imageresize", "enable");
            coverImageParent.setAttribute("imageresize", "enable");
            this.sgParent.setAttribute("imageresizenode", "enable");
            let imagesizeFromProp = props.imagesize ? props.imagesize : "large";
            let coverimageSize = this.sgData[currentIndex] && this.sgData[currentIndex].coverimagesize ? this.sgData[currentIndex].coverimagesize : imagesizeFromProp;
            if (coverimageSize && coverImageParent) {
                //Implement image size change from floter
                // let multipleValue = coverimageSize == "small" ? 0.4 : coverimageSize == "medium" ? 0.7 : coverimageSize == "large" ? 1 : parseFloat(coverimageSize);
                let multipleValue = this.specialGraphicsUtils.getImageSizeSML(coverimageSize);
                let largeW = parseFloat(coverImageParent.getAttribute("data-largewidth"));
                let largeH = parseFloat(coverImageParent.getAttribute("data-largeheight"));
                if (isNaN(largeW)) largeW = parseFloat(window.getComputedStyle(coverImageParent).width);
                if (isNaN(largeW)) largeW = parseFloat(coverImageParent.style.width);
                if (isNaN(largeH)) largeH = parseFloat(window.getComputedStyle(coverImageParent).height);
                if (isNaN(largeH)) largeH = parseFloat(coverImageParent.style.height);
                let newW = largeW * (imagePosition == "left" || imagePosition == "right" ? multipleValue : 1);
                let newH = largeH * (imagePosition == "top" || imagePosition == "bottom" ? multipleValue : 1);

                if (newW > 0) coverImageParent.style.width = newW + "px";
                if (newH > 0) coverImageParent.style.height = newH + "px";

                let direction = "leftRight";
                if (imagePosition == "top" || imagePosition == "bottom") {
                    let largeH = parseFloat(coverImageParent.getAttribute("data-largeheight"));
                    if (isNaN(largeH)) {
                        let oldMinH = coverImageParent.style.minHeight;
                        coverImageParent.style.minHeight = coverImageParent.style.height;
                        largeH = parseFloat(window.getComputedStyle(coverImageParent).height);
                        coverImageParent.style.minHeight = oldMinH;
                    }
                    if (isNaN(largeH)) largeH = parseFloat(coverImageParent.style.height);
                    direction = "topBottom";
                    coverImageParent.setAttribute("imageresize_min", largeH * 0.35);
                    coverImageParent.setAttribute("imageresize_max", largeH);
                } else {
                    coverImageParent.setAttribute("imageresize_min", largeW * 0.35);
                    coverImageParent.setAttribute("imageresize_max", largeW);
                }
                coverImageParent.setAttribute("imageresize_direction", direction);
                coverImageParent.setAttribute("imageresize_position", imagePosition);
            }
        }
        if (this.sgData[currentIndex] && this.sgData[currentIndex]["coverimagedragvalue"]) {
            if (imagePosition == "left" || imagePosition == "right") coverImageParent.style.width = this.sgData[currentIndex]["coverimagedragvalue"] + "px";
            if (imagePosition == "bottom" || imagePosition == "top") coverImageParent.style.height = this.sgData[currentIndex]["coverimagedragvalue"] + "px";
        }
        // if (this.sgData[currentIndex] && this.sgData[currentIndex]["coverimageoverlayshow"]) {
        //     let overlayNode = coverImageParent.querySelector("[data-nodetype='imageOverlay']");
        //     if (overlayNode && this.sgData[currentIndex]["coverimageoverlayshow"] == "false") overlayNode.style.display = "none";
        // }

        //Image overlay check
        let imageHolder = coverImageParent?.querySelector("[data-nodetype='imageHolder']");
        let overlayNode = coverImageParent?.querySelector("[data-nodetype='imageOverlay']");
        if (imageHolder) imageHolder.removeAttribute("data-isoverlay");
        // if (overlayNode) overlayNode.style.display = "none";
        //Setting old overlay to new style
        if (this.sgData[currentIndex] && overlayNode && this.sgData[currentIndex]["coverimageoverlayshow"]) {
            overlayNode.style.display = this.sgData[currentIndex]["coverimageoverlayshow"] == "true" ? "block" : "none";
            if (imageHolder && this.sgData[currentIndex]["coverimageoverlayshow"] == "true") imageHolder.setAttribute("data-isoverlay", "true");
        }

        if (this.objDataToSG?.imageOverlayProps && overlayNode) {
            let moodImageProps = this.objDataToSG.imageOverlayProps;
            if (moodImageProps.support == "false" || moodImageProps.support == false) overlayNode.setAttribute("overlaysupport", false);
        }

        //If overlay not support by style we have disable by setiing display none
        // if (overlayNode?.hasAttribute("overlaysupport") && overlayNode?.getAttribute("overlaysupport") == "false") overlayNode.style.display = "none";

        // let captionPosition = this.sgData[currentIndex].coverimagecaptionposition ? this.sgData[currentIndex].coverimagecaptionposition : props.captionposition ? props.captionposition : "bottomleft";
        // if (captionPosition && coverImageParent && coverImageParent.querySelector("[id*='imageCaption']")) {
        //     let imageCaption = coverImageParent.querySelector("[id*='imageCaption']");
        //     let cls =
        //         captionPosition == "topleft" || captionPosition == "captionTL"
        //             ? "captionTL"
        //             : captionPosition == "topright" || captionPosition == "captionTR"
        //             ? "captionTR"
        //             : captionPosition == "bottomright" || captionPosition == "captionBR"
        //             ? "captionBR"
        //             : "captionBL";
        //     imageCaption.classList.remove("captionTL");
        //     imageCaption.classList.remove("captionTR");
        //     imageCaption.classList.remove("captionBL");
        //     imageCaption.classList.remove("captionBR");
        //     imageCaption.classList.add(cls);
        // }
        this.specialGraphicsUtils.setImageCaptionPosition(coverImageParent, currentIndex, this.sgData, props);
    } else if (this.slideContent) {
        this.slideContent.classList.remove("fixedlightText");
        this.slideContent.classList.remove("fixeddarkText");
    }
};

GenericSpecialgraphicsCommon.prototype.getImageProperty = function (currentIndex) {
    let mainProps = currentIndex == 0 ? this.getIntroProps() : this.getProps();

    let imageProperty = mainProps && mainProps.image ? mainProps.image : null;
    if (mainProps) {
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (mainProps["image" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                imageProperty = mainProps["image" + ind];
            }
        }
    }
    return imageProperty;
};
GenericSpecialgraphicsCommon.prototype.createCommonBgImage = function (parent, currentIndex) {
    if (currentIndex == 0 || currentIndex == 1) {
        let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
        this.createCommonBgImageNode(this.sgParent, props, currentIndex == 0);
        let presetImageParent = this.sgParent.querySelector("[id='commonBgImageParent" + (currentIndex == 0 ? "Intro" : "") + "']");
        if (currentIndex == 1) presetImageParent.style.zIndex = -1;
        let commonImageNode = presetImageParent.querySelector("[id='commonBgImage']");
        let commonVideoNode = presetImageParent.querySelector("[id='commonBgImage']");
        if (props.commonbg) this.applyCommonBgProps(presetImageParent, commonImageNode, commonVideoNode, props, currentIndex, this.getAssetParent(currentIndex));
    }
};
GenericSpecialgraphicsCommon.prototype.applySingleNodeProps = function (currentIndex, textParentId, textNodeId, textProp) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    this.sgParent.setAttribute("singlenode", "true");
    if (textProp && assetParent && assetParent.querySelector("[id='" + textParentId + "']")) {
        let sgTextNodeParent = assetParent.querySelector("[id='" + textParentId + "']");
        let sgTextNode = assetParent.querySelector("[id='" + textNodeId + "']");
        sgTextNodeParent.style.pointerEvents = "auto";
        sgTextNodeParent.style.order = "unset";
        if (textProp.position) this.specialgraphicsPropertyUtils.updatePosition(sgTextNodeParent, textProp.position);
        if (textProp.maxwidth) sgTextNodeParent.style.maxWidth = textProp.maxwidth + (textProp.maxwidth.includes("px") || textProp.maxwidth.includes("%") ? "" : "px");
        if (textProp.maxheight) {
            let mh = textProp.maxheight + (textProp.maxheight.includes("px") || textProp.maxheight.includes("%") ? "" : "px");
            sgTextNodeParent.style.maxHeight = mh;
            sgTextNode.setAttribute("data-maxheight", mh);
        }
        if (textProp.positionvalue) sgTextNodeParent.style.position = textProp.positionvalue;
        else sgTextNodeParent.style.position = "relative";
        if (textProp.padding) this.specialgraphicsPropertyUtils.updatePadding(textProp.padding, sgTextNodeParent, true);
        if (textProp.margin) this.specialgraphicsPropertyUtils.updateMargin(textProp.margin, sgTextNodeParent);
        if (textProp.zorder) sgTextNodeParent.style.zIndex = textProp.zorder;
        sgTextNode.classList.remove("titleColorBg");
        sgTextNode.classList.remove("subtitleColorBg");
        sgTextNode.classList.remove("transparentBg");
        if (textProp.support && textProp.support == "parent") {
            sgTextNode.setAttribute("data-support", "parent");
            this.createTextElement(sgTextNodeParent.parentElement);
            sgTextNode.setAttribute("data-parentid", sgTextNodeParent.parentElement.id);
        } else sgTextNode.removeAttribute("data-support");
        if (textProp.color) sgTextNode.classList.add(textProp.color);
        else sgTextNode.classList.add("transparentBg");

        if (textProp.titlecustomcolor) sgTextNode.style.setProperty("color", "rgba(var(--" + textProp.titlecustomcolor + "-color-rgb),1)", "important");
        if (textProp.bgcolor) sgTextNodeParent.style.backgroundColor = "rgba(var(--" + textProp.bgcolor + "-color-rgb),1)";
        if (textProp.bgshadow) sgTextNodeParent.style.boxShadow = textProp.bgshadow;
        if (textProp.contrast) this.applyContrastToText(sgTextNodeParent, textProp);
        if (textProp.halign) {
            let alignValue = textProp.halign == "end" || textProp.halign == "right" ? "flex-end" : textProp.halign == "center" || textProp.halign == "middle" ? "center" : "flex-start";
            let align = textProp.halign == "end" || textProp.halign == "right" ? "end" : textProp.halign == "center" || textProp.halign == "middle" ? "center" : "start";
            assetParent.style.setProperty("--textAlign", align);
            assetParent.style.setProperty("--textJustifyContent", alignValue);
        }
        if (textProp.valign) {
            let alignValue = textProp.valign == "bottom" || textProp.valign == "end" ? "flex-end" : textProp.valign == "center" || textProp.valign == "middle" ? "center" : "flex-start";
            sgTextNodeParent.style.alignItems = alignValue;
        }
        if (textProp.opacity) {
            sgTextNodeParent.style.opacity = textProp.opacity;
            this.specialGraphicsUtils.setOpacityAttribute(sgTextNodeParent);
        }
        if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(sgTextNode);
    }
};
GenericSpecialgraphicsCommon.prototype.changeVariation = function (slideDomContentGroup, updateOnlyVariation = false) {
    if (this.isPreviewMode == false) {
        let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
        this.updateIntroVisibility();
        for (let i = 0; i < assetParents.length; i++) {
            let subTitleNode = assetParents[i].querySelector("[id='sgSubTitleNode']");
            let oldDisplay = subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "";

            this.specialGraphicsUtils.changeVariation(assetParents[i], slideDomContentGroup, i);
            //Updating image positions for all images
            this.specialGraphicsUtils.updateImagePositions(assetParents[i]);

            if (updateOnlyVariation == false) {
                let titleNode = assetParents[i].querySelector("[id='sgTitleNode']");
                let newDisplay = subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "";
                if (titleNode && subTitleNode && newDisplay != oldDisplay && this.fontData.title.length <= 2) {
                    let isSubtitleEnabled = window.getComputedStyle(subTitleNode)["display"] == "none" ? false : true;
                    let isIntro = assetParents[i].classList.contains("introSlide") == true ? true : false;
                    titleNode.classList.remove(this.fontData[(isIntro ? "intro" : "") + "title"]);
                    titleNode.classList.remove(this.fontData[(isIntro ? "intro" : "") + "titleNoSubtitle"]);

                    this.specialGraphicsUtils.removeAllFontClass(titleNode);

                    let fontClass = isSubtitleEnabled == false ? this.fontData[(isIntro ? "intro" : "") + "titleNoSubtitle"] : this.fontData[(isIntro ? "intro" : "") + "title"];
                    if (!fontClass) fontClass = isSubtitleEnabled == false ? this.fontData["titleNoSubtitle"] : this.fontData["title"];
                    titleNode.classList.add(fontClass);
                    titleNode.setAttribute("data-font", fontClass);
                    titleNode.style.removeProperty("min-height");
                    titleNode.style.removeProperty("max-height");
                    titleNode.style.removeProperty("font-size");

                    titleNode.setAttribute("defaultsize", parseFloat(window.getComputedStyle(titleNode)["font-size"]));
                    if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(titleNode);
                    if (titleNode.hasAttribute("user-font-size")) {
                        this.specialGraphicsUtils.removeAllFontClass(titleNode);
                        titleNode.classList.add(titleNode.getAttribute("user-font-size"));
                        // titleNode.style.setProperty("font-size", titleNode.getAttribute("user-font-size") + "px", "important");
                    }
                    this.specialGraphicsUtils.doCheckMaxHeight(titleNode, this.sgParent);
                    this.specialGraphicsUtils.doFontFitForCss(titleNode, this.sgParent);
                }
                this.updateHeightForText(assetParents[i]);
                this.onTextChangeForAllNodes(assetParents[i], i);
                let textInnerParentNode = assetParents[i].querySelector("[id='textInnerParentNode']");
                this.textElementPositioning(assetParents[i], textInnerParentNode, i);
            }
            // Check and pply Flip & bleed options
            // this.specialGraphicsUtils.checkAndApplyFlipBleed(assetParents[i], this.sgParent, this.metaData, this.getProps());
            this.applyImageBleedCommon(assetParents[i]);
        }
        this.updatenavFloater();
        this.checkShapeDependency(this.currentNodeIndex - 1);
        // if (this.updateResizer && this.sgParent.hasAttribute("imageresizenode")) this.updateResizer(this.currentNodeIndex - 1);
        if (this.updateResizer) this.updateResizer(this.currentNodeIndex - 1);
    }
};
GenericSpecialgraphicsCommon.prototype.updateIntroVisibility = function (moveToStart = false, index = 0) {
    let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
    if (this.sgParent && this.sgParent.parentElement && this.sgParent.parentElement.parentElement && assetParents.length > 0) {
        let animationDIV = this.sgParent.parentElement.parentElement;
        let showIntro = animationDIV.getAttribute("data-ogdata-finalshow_0")?.split(",")?.includes("intro") ? "true" : "false";
        if (showIntro == "false" && assetParents[0].classList.contains("introSlide")) {
            if (animationDIV.hasAttribute("inlinefloaterchange") && animationDIV.getAttribute("inlinefloaterchange") == "true") {
            } else {
                assetParents[0].style.display = "none";
                this.currentNodeIndex = 2;
                this.floaterNavigation(0);
            }
        } else {
            assetParents[0].style.removeProperty("display");
            if (moveToStart == true) {
                this.currentNodeIndex = index;
                this.floaterNavigation(0);
            }
        }
    }
};
GenericSpecialgraphicsCommon.prototype.floaterNavigation = function (index) {
    let isPreview = this.isPreviewMode && this.isPreviewMode == true ? true : false;
    if (this.isPreviewMode == false || !this.isPreviewMode) {
        this.currentNodeIndex = this.currentNodeIndex + index;
        let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
        let commonBgImageParent = this.sgParent.querySelector("[id='commonBgImageParent']");
        let commonBgImageParentIntro = this.sgParent.querySelector("[id='commonBgImageParentIntro']");
        for (let i = 0; i < this.sgData.length + 1; i++) {
            let currentNode = this.sgParent.querySelector("[id='assetParent" + i + "']");
            if (this.currentNodeIndex - 1 == i && currentNode) {
                currentNode.style.opacity = 1;
                let isVideo = this.sgParent.hasAttribute("data-isvideo");
                if (!isVideo) currentNode.style.pointerEvents = "auto";
                else currentNode.style.pointerEvents = "none";
                currentNode.style.setProperty("--textPointerEvent", "auto");
                this.onTextChangeForAllNodes(currentNode, i);
                currentNode.removeAttribute("active");
            } else if (currentNode) {
                currentNode.setAttribute("active", "false");
                currentNode.style.opacity = 0;
                let isVideo = this.sgParent.hasAttribute("data-isvideo");
                if (!isVideo) currentNode.style.pointerEvents = "none";
                else currentNode.style.pointerEvents = "none";
                currentNode.style.setProperty("--textPointerEvent", "none");
            }
            if (commonBgImageParent) commonBgImageParent.style.opacity = this.currentNodeIndex - 1 == 0 ? 0 : 1;
            if (commonBgImageParentIntro) commonBgImageParentIntro.style.opacity = this.currentNodeIndex - 1 == 0 ? 1 : 0;

            if (deviceImageParentNode) {
                deviceImageParentNode.style.opacity = this.currentNodeIndex - 1 == 0 ? 0 : 1;
                deviceImageParentNode.style.pointerEvents = this.currentNodeIndex - 1 == 0 ? "none" : "auto";
            }
        }
        if (isPreview == false) {
            this.updatenavFloater();
            this.checkShapeDependency(this.currentNodeIndex - 1);
            this.eventManager.dispatch("positionchangecallback", this.currentNodeIndex - 1);
        }
        if (this.isPlayAnimation == false && this.updateResizer && this.sgParent.hasAttribute("imageresizenode")) this.updateResizer(this.currentNodeIndex - 1);
    }
};
GenericSpecialgraphicsCommon.prototype.updatenavFloater = function () {
    if (this.isPlayAnimation == false && this.isPresent != true) {
        let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
        if (assetParent0 && assetParent0.classList.contains("introSlide") && this.updateNavFloaterIndex) {
            let isIntroHide = this.sgParent?.parentElement?.parentElement?.getAttribute("data-ogdata-finalhide_0")?.split(",")?.includes("intro");
            let isVisible = isIntroHide ? -1 : 0;
            let slideID = this.slideContent && this.slideContent.id ? this.slideContent.id : null;
            this.updateNavFloaterIndex(this.currentNodeIndex + isVisible, slideID, isVisible, this.currentNodeIndex - 1 + isVisible);
        }
    }
};
GenericSpecialgraphicsCommon.prototype.initPresentSG = function (slideContent) {
    let hasEmptyIntro = this.checkIntroAnimation();
    let specialgraphicsParent = slideContent && slideContent.querySelector("[id='specialgraphicsParent']") ? slideContent.querySelector("[id='specialgraphicsParent']") : null;
    if (specialgraphicsParent) specialgraphicsParent.setAttribute("hasemptyintro", hasEmptyIntro);
    let lottieParent = slideContent?.querySelectorAll("[data-lottie*='/']");
    for (let a = 0; a < lottieParent.length; a++) {
        let arrAssets = [{ type: "json", url: lottieParent[a].getAttribute("data-lottie"), id: "commonbglottie", parent: lottieParent[a] }];
        // this.arrCommonAssets.push({ array: arrAssets, callback: this.lottieLoadCallback });
        this.loadAssets(arrAssets, this.lottieLoadCallback, this.assetError);
    }
};

GenericSpecialgraphicsCommon.prototype.gotoAndStopFirstNode = function (completeCallback, type, slideContent, indexValue = -1) {
    //Re-applying image contrast
    this.reApplyContrast();

    let textBaseParentNode = this.sgParent.querySelectorAll("[id*='textBaseParentNode']");
    for (let a = 0; a < textBaseParentNode.length; a++) {
        textBaseParentNode[a].style.overflow = "unset";
    }

    let hasEmptyIntro = this.checkIntroAnimation();
    this.currentNodeIndex = indexValue > -1 ? indexValue : this.isFromLastSlide == true ? this.sgData.length : hasEmptyIntro == true ? 2 : 1;
    this.floaterNavigation(0);
    this.eventManager.dispatch("positionchangecallback", this.currentNodeIndex - 1);

    if (hasEmptyIntro && this.getAssetParent(0)) {
        this.getAssetParent(0).style.display = "none";
        let introCommonBG = this.sgParent.querySelector("[id='commonBgImageParentIntro']");
        if (introCommonBG) introCommonBG.style.display = "none";
    }
    if (hasEmptyIntro && this.getAssetParent(1)) this.getAssetParent(1).removeAttribute("active");
    if (!hasEmptyIntro && this.getAssetParent(0)) this.getAssetParent(0).removeAttribute("active");

    this.sgParent.style.opacity = 1;
    if (hasEmptyIntro == false && this.getAssetParent(1)) this.getAssetParent(1).setAttribute("playshapeanimation", "false");

    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1);
};
GenericSpecialgraphicsCommon.prototype.hideAnimation = function (completeCallback) {
    if (this.isHeroImage() != true) this.updateShowHideInfo(this.currentNodeIndex - 1, false);
    else if (this.currentNodeIndex == 1) this.currentNodeIndex = this.currentNodeIndex + 1;
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1, "moodsutil", true);
};
GenericSpecialgraphicsCommon.prototype.updateShowHideInfo = function (index, isShow = true) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + index + "']");
    assetParent.style.opacity = 1;
    assetParent.classList.remove(isShow == true ? "hidesg" : "showsg");
    assetParent.classList.add(isShow == true ? "showsg" : "hidesg");
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (this.currentNodeIndex == 1 && this.isPlayAnimation == false && deviceImageParentNode) deviceImageParentNode.style.opacity = 0;
    else if (deviceImageParentNode && this.currentNodeIndex != 1) deviceImageParentNode.style.opacity = 1;
};
GenericSpecialgraphicsCommon.prototype.next = function (completeCallback) {
    let oldIndex = this.currentNodeIndex - 1 < 0 ? 0 : this.currentNodeIndex - 1;
    this.currentNodeIndex = this.currentNodeIndex + 1;
    if (this.currentNodeIndex > this.sgData.length) return;

    this.sgParent.removeAttribute("hasemptyintro");

    //HIDE ANIMATION
    this.updateShowHideInfo(oldIndex, false);
    this.sgParent.setAttribute("dotransition", "false");
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", completeCallback, this.isPlayAnimation, this.eventManager, oldIndex, "moodsutilintermediate");

    let hideAP = this.getAssetParent(oldIndex);
    if (hideAP) {
        hideAP.style.setProperty("--textPointerEvent", "none", "important");
        hideAP.style.setProperty("pointer-events", "none", "important");
    }

    if (this.currentNodeIndex > 1) this.showDevice(true);
    //SHOW ANIMATION
    this.updateShowHideInfo(this.currentNodeIndex - 1, true);
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1, "moodsutilintermediate");
    let showAP = this.getAssetParent(this.currentNodeIndex - 1);
    if (showAP) {
        showAP.removeAttribute("active");
        showAP.style.setProperty("--textPointerEvent", "auto", "important");
        showAP.style.setProperty("pointer-events", "auto", "important");
    }
    if (this.isPlayAnimation == false && this.currentNodeIndex == 2) {
        let assetParent = this.sgParent.querySelector("[id='assetParent0']");
        assetParent.style.opacity = 0;
    }
};
GenericSpecialgraphicsCommon.prototype.showDevice = function (showDevice = true) {
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (deviceImageParentNode) {
        deviceImageParentNode.style.opacity = showDevice == false ? 0 : 1;
        deviceImageParentNode.style.pointerEvents = showDevice == false ? "none" : "auto";
    }
    let commonBG = this.sgParent.querySelector("[id='commonBgImageParent']");
    if (commonBG) commonBG.style.opacity = showDevice == false ? 0 : 1;
    if (this.sgParent.querySelector("[id='deviceImageNode']") && showDevice == true) this.sgParent.querySelector("[id='deviceImageNode']").style.removeProperty("opacity");
    if (this.sgParent.querySelector("[id='deviceImageNode1']") && showDevice == true) this.sgParent.querySelector("[id='deviceImageNode1']").style.removeProperty("opacity");
    if (this.sgParent.querySelector("[id='videoElement']") && showDevice == true) this.sgParent.querySelector("[id='videoElement']").style.removeProperty("opacity");
    if (this.sgParent.querySelector("[id='secondaryAssetNode']") && showDevice == true) this.sgParent.querySelector("[id='secondaryAssetNode']").style.removeProperty("opacity");
};
GenericSpecialgraphicsCommon.prototype.previous = function (completeCallback) {
    let oldIndex = this.currentNodeIndex - 1 < 0 ? 0 : this.currentNodeIndex - 1;
    this.currentNodeIndex = this.currentNodeIndex - 1;

    this.sgParent.removeAttribute("hasemptyintro");

    let hasEmptyIntro = this.checkIntroAnimation();
    if (hasEmptyIntro == true && this.currentNodeIndex <= 1) return false;

    if (this.currentNodeIndex < 1) return;
    if (this.sgParent.querySelector("[id='assetParent0']").classList.contains("introSlide") && oldIndex == 1) {
        this.sgParent.querySelector("[id='assetParent1']").setAttribute("hashide", "true");
        if (this.sgParent.querySelector("[id='deviceImageNode']")) this.sgParent.querySelector("[id='deviceImageNode']").style.opacity = 1;
        if (this.sgParent.querySelector("[id='deviceImageNode1']")) this.sgParent.querySelector("[id='deviceImageNode1']").style.opacity = 1;
        if (this.sgParent.querySelector("[id='videoElement']")) this.sgParent.querySelector("[id='videoElement']").style.opacity = 1;
        if (this.sgParent.querySelector("[id='secondaryAssetNode']")) this.sgParent.querySelector("[id='secondaryAssetNode']").style.opacity = 1;
    }
    //HIDE ANIMATION
    this.updateShowHideInfo(oldIndex, false);
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", completeCallback, this.isPlayAnimation, this.eventManager, oldIndex, "moodsutilintermediate");
    let hideAP = this.getAssetParent(oldIndex);
    if (hideAP) {
        hideAP.style.setProperty("--textPointerEvent", "none", "important");
        hideAP.style.setProperty("pointer-events", "none", "important");
    }

    // let delayVal = 0;
    let newAssetparent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    // if (newAssetparent && newAssetparent.classList.contains("introSlide") && this.isPlayAnimation == true) delayVal = 1000;
    //SHOW ANIMATION
    // setTimeout(() => {
    this.updateShowHideInfo(this.currentNodeIndex - 1, true);
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1, "moodsutilintermediate");
    if (newAssetparent) {
        newAssetparent.style.setProperty("--textPointerEvent", "auto", "important");
        newAssetparent.style.setProperty("pointer-events", "auto", "important");
    }
    // }, delayVal);
};
GenericSpecialgraphicsCommon.prototype.checkIntroAnimation = function () {
    if (this.isHeroImage() == true) return true;
    if (this.sgParent && this.sgParent.parentElement && this.sgParent.parentElement.parentElement) {
        let animationDIV = this.sgParent.parentElement.parentElement;
        let showIntro = animationDIV.getAttribute("data-ogdata-finalshow_0")?.split(",")?.includes("intro") ? "true" : "false";
        if (showIntro == "false") return true;
    }
    let assetParent = this.getAssetParent(0);
    if (assetParent && assetParent.classList.contains("introSlide")) {
        let title = assetParent.querySelector("[id='sgTitleNode']");
        let subTitle = assetParent.querySelector("[id='sgSubTitleNode']");
        let titleLabel = assetParent.querySelector("[id='sgTitleLabelNode']");
        if (title && title.innerText.trim().length == 0 && subTitle && subTitle.innerText.trim().length == 0 && titleLabel && titleLabel.innerText.trim().length == 0) {
            return true;
        }
    }
    return false;
};
GenericSpecialgraphicsCommon.prototype.isHeroImage = function () {
    if (this.sgParent && this.sgParent.parentElement && this.sgParent.parentElement.parentElement && this.sgData.length < 2) {
        let count = this.sgParent.parentElement.parentElement.getAttribute("data-nodecount");
        if (count == "1") return true;
    }
};

GenericSpecialgraphicsCommon.prototype.updateImage = function (elementId, src, nodeIndex = null, resizeImage = false) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + (nodeIndex != null ? nodeIndex : this.currentNodeIndex - 1) + "']");
    let imageNode = assetParent ? assetParent.querySelector("[id='" + elementId + "']") : this.sgParent.querySelector("[id='" + elementId + "']");
    if (imageNode && src) {
        imageNode.src = src;
        if (resizeImage) this.specialGraphicsUtils.updateImageReSize(imageNode.getAttribute("data-width"), imageNode.getAttribute("data-height"), imageNode);
        // let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData ? this.metaData : null;
        // let imageID = imageNode.id.includes("sgAuthorImageNode") ? "authimg" : imageNode.id.toLocaleLowerCase().includes("presetimage") ? "presetimage" : "image";
        // let isNotMainImage = imageNode.id.includes("sgPlaceHolderImageNode") || imageNode.id.includes("sgLogoImageNode") ? false : true;
        // if (isNotMainImage && metaDataBase && metaDataBase.properties && metaDataBase.properties[imageID] && assetParent) {
        //     let props = metaDataBase.properties[imageID];
        //     if (props.contrast && props.contrast == "fullbg" && imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent);
        //     if (props.contrast && props.contrast == "halfbg" && imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent, true);
        // }
        this.updateImageContrastOnChange(imageNode, this.currentNodeIndex - 1);
        let duplicatedImages = assetParent ? assetParent.querySelectorAll("[data-target-id='coverimageduplicate']") : null;
        if (duplicatedImages?.length > 0 && elementId.includes("coverimage")) {
            for (let a = 0; a < duplicatedImages.length; a++) {
                let duplicatedImage = duplicatedImages[a];
                duplicatedImage.src = src;
            }
        }
        if (elementId.toLocaleLowerCase().includes("logo") || elementId.includes("sgPlaceHolderImageNode")) {
            imageNode.callback = this.rePositionTextAndElement;
            let type = elementId.includes("sgPlaceHolderImageNode") ? "image" : "logo";
            this.setLogoSizes(assetParent, type);
        }
    }
};
GenericSpecialgraphicsCommon.prototype.updateImageContrastOnChange = function (imageNode, index) {
    let assetParent = this.getAssetParent(index ? index : this.currentNodeIndex - 1);
    let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData ? this.metaData : null;
    let imageID = imageNode.id.includes("sgAuthorImageNode") ? "authimg" : imageNode.id.toLocaleLowerCase().includes("presetimage") ? "presetimage" : "image";
    let isNotMainImage = imageNode.id.includes("sgPlaceHolderImageNode") || imageNode.id.includes("sgLogoImageNode") ? false : true;
    if (isNotMainImage && metaDataBase && metaDataBase.properties && metaDataBase.properties[imageID] && assetParent) {
        let props = metaDataBase.properties[imageID];
        if (props.contrast && props.contrast == "fullbg" && imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent);
        if (props.contrast && props.contrast == "halfbg" && imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent, true);
    }
};
GenericSpecialgraphicsCommon.prototype.updateImageResizeOnTypeChange = function (type) {
    let assetParent = this.getAssetParent(this.currentNodeIndex - 1);
    this.setLogoSizes(assetParent, type);
    this.textFitOnImageResize();
    this.checkShapeDependency(this.currentNodeIndex - 1);
};
GenericSpecialgraphicsCommon.prototype.getAssetParent = function (index) {
    return this.sgParent.querySelector("[id='assetParent" + index + "']");
};
GenericSpecialgraphicsCommon.prototype.changeText = function (updatedText, elementId, targetIndex, textType) {
    let assetParent = this.getAssetParent(targetIndex);
    if (assetParent && assetParent.querySelector("[id='" + elementId + "']")) {
        let textNode = assetParent.querySelector("[id='" + elementId + "']");
        textNode = !textNode ? assetParent.querySelector("[id*='" + elementId + "']") : textNode;

        if (textNode) {
            let prefix = textNode.hasAttribute("prefix") ? textNode.getAttribute("prefix") : null;
            let suffix = textNode.hasAttribute("suffix") ? textNode.getAttribute("suffix") : null;
            if (prefix) {
                updatedText = updatedText.replace(prefix, "");
                updatedText = prefix + " " + updatedText;
            }
            if (suffix) {
                updatedText = updatedText.replace(suffix, "");
                updatedText = updatedText + " " + suffix;
            }
            textNode.setAttribute("data-heading", updatedText);
            textNode.setAttribute("data-oldtext", updatedText);
            textNode.setAttribute("data-changetext", "true");
            textNode.innerHTML = updatedText;

            this.specialGraphicsUtils.doFontFitForCss(textNode, this.sgParent, null, null, null, true);
            this.specialGraphicsUtils.updateImagePositions(this.sgParent);
        }
        this.checkShapeDependency(targetIndex);
    }
};
GenericSpecialgraphicsCommon.prototype.getTargetElement = function (elementID) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    if (assetParent && assetParent.querySelector("[id='" + elementID + "']")) return assetParent.querySelector("[id='" + elementID + "']");
};

GenericSpecialgraphicsCommon.prototype.resetFontDetails = function (elementID, parent, type) {
    let element = parent.querySelector("[id='" + elementID + "']");
    if (element) {
        element.classList.remove("h3");
        element.classList.remove("h4");
        element.classList.add(this.fontData[type]);
        element.style.removeProperty("max-height");
        element.style.removeProperty("min-height");
        element.style.removeProperty("font-size");
        if (element.hasAttribute("user-font-size")) {
            this.specialGraphicsUtils.removeAllFontClass(element);
            element.classList.add(element.getAttribute("user-font-size"));
            // element.style.setProperty("font-size", element.getAttribute("user-font-size") + "px", "important");
        }
        this.specialGraphicsUtils.doFontFitForCss(element, this.sgParent);
    }
};
GenericSpecialgraphicsCommon.prototype.updateFloaterOnPreviewEnd = function (index) {
    this.updateIntroVisibility(true, index);
};
GenericSpecialgraphicsCommon.prototype.getCurrentIndex = function () {
    return this.currentNodeIndex - 1;
};
GenericSpecialgraphicsCommon.prototype.startIndex = function (currentSlideData) {
    return this.specialGraphicsUtils.getStartIndex(currentSlideData, this.sgParent);

    // let presentParent = currentSlideData ? currentSlideData : this.sgParent;
    // let assetParent = presentParent ? presentParent.querySelector("[id='assetParent0']") : null;
    // let sgParent = presentParent ? presentParent.querySelector("[id='specialgraphicsParent']") : this.sgParent;

    // let isNotVisible = assetParent?.style?.display == "none" || assetParent?.style?.opacity == 0 || assetParent?.style?.opacity == "0";
    // if (isNotVisible) sgParent.setAttribute("startindex", "1");
    // else sgParent.removeAttribute("startindex");

    // let localParent = sgParent ? sgParent : this.sgParent;
    // let animationDIV = localParent?.parentElement?.parentElement ? localParent.parentElement.parentElement : null;
    // let showIntro = animationDIV?.hasAttribute("data-intro") ? animationDIV.getAttribute("data-intro") : "true";

    // return (isNotVisible || !assetParent) && showIntro != "true" ? 1 : 0;
};
GenericSpecialgraphicsCommon.prototype.focusOutElement = function (elementID) {
    SGBaseClass.prototype.focusOutElement.call(this, elementID);
    try {
        let assetParent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
        let element = assetParent ? assetParent.querySelector("[id=" + elementID + "]") : null;
        if (element) {
            element.setAttribute("focusout", "mannual");
            element.blur();
        }
    } catch (error) {}
};
GenericSpecialgraphicsCommon.prototype.setLogoSizes = function (assetParent, placeHolderType = "") {
    let assetParentNode = assetParent ? assetParent : this.getAssetParent(this.currentNodeIndex - 1);
    let imgNode = assetParentNode ? assetParentNode.querySelector("[id='sgLogoImageNode']") : null;

    let oldDisplay = assetParentNode ? assetParentNode.style.display : "";
    if (assetParentNode) assetParentNode.style.display = "block";

    if (placeHolderType == "icon") {
        imgNode = assetParentNode ? assetParentNode.querySelector("[id*='phIconSvgNode']") : null;
        this.setLogoSizesOP(imgNode);
    } else if (placeHolderType == "text") {
        imgNode = assetParentNode ? assetParentNode.querySelector("[id*='phTextNode']") : null;
        this.setLogoSizesOP(imgNode);
        this.onTextChangeUpdatePlaceholderNode(imgNode);
    } else {
        if (placeHolderType == "image") imgNode = assetParentNode ? assetParentNode.querySelector("[id='sgPlaceHolderImageNode']") : null;

        if (imgNode && imgNode.complete) this.setLogoSizesOP(imgNode);
        else if (imgNode) imgNode.addEventListener("load", this.logoLoadCallback);
    }
    if (assetParentNode) assetParentNode.style.display = oldDisplay;
};

GenericSpecialgraphicsCommon.prototype.logoLoadCallback = function (event) {
    event.target.removeEventListener("load", this.logoLoadCallback);
    this.setLogoSizesOP(event.target);
};
GenericSpecialgraphicsCommon.prototype.setLogoSizesOP = function (imgNode) {
    let logoRatio = this.specialGraphicsUtils.getLogoRatio(imgNode);
    // console.log("LOGO - ratio - " + logoRatio);
    if (!logoRatio) logoRatio = "square";
    if (logoRatio && imgNode) {
        let dummyDom = document.createElement("div");
        dummyDom.classList.add(logoRatio);
        dummyDom.style.position = "absolute";
        dummyDom.style.width = "var(--logoSizeWidth)";
        dummyDom.style.height = "var(--logoSizeHeight)";
        if (imgNode.id.includes("phTextNode")) imgNode.appendChild(dummyDom);
        else imgNode.parentElement.appendChild(dummyDom);
        let w = window.getComputedStyle(dummyDom).width;
        let h = window.getComputedStyle(dummyDom).height;
        if (w != "" && h != "" && w != "0px" && h != "0px") {
            let mainParent = imgNode.parentElement.parentElement.parentElement;
            if (imgNode.id.includes("phTextNode")) mainParent = imgNode.parentElement.parentElement;
            let lgWidth = window.getComputedStyle(dummyDom).getPropertyValue("--logoSizeWidth");
            if (lgWidth?.trim() == "100%") {
                mainParent.style.width = "100%";
                w = window.getComputedStyle(mainParent).width;
            }
            imgNode.parentElement.style.setProperty("--logoSizeWidth", w);
            imgNode.parentElement.style.setProperty("--logoSizeHeight", h);
            imgNode.parentElement.setAttribute("data-largewidth", parseFloat(w));
            imgNode.parentElement.setAttribute("data-largeheight", parseFloat(h));

            mainParent.setAttribute("data-largewidth", parseFloat(w));
            mainParent.setAttribute("data-largeheight", parseFloat(h));

            let placeholderimagesize = "medium";
            if (imgNode.parentElement.hasAttribute("data-placeholderimagesize")) placeholderimagesize = imgNode.parentElement.getAttribute("data-placeholderimagesize");
            else if (mainParent.hasAttribute("data-placeholderimagesize")) placeholderimagesize = mainParent.getAttribute("data-placeholderimagesize");
            else {
                let props = this.getProps();
                let property = props && props.placeholderimage ? props.placeholderimage : null;
                placeholderimagesize = property && property.placeholderimagesize ? property.placeholderimagesize : placeholderimagesize;
            }
            // let logoImageSizeValue = placeholderimagesize == "small" ? 0.4 : placeholderimagesize == "medium" ? 0.7 : placeholderimagesize == "large" ? 1 : parseFloat(placeholderimagesize);
            let logoImageSizeValue = this.specialGraphicsUtils.getImageSizeSML(placeholderimagesize);
            w = parseFloat(w) * parseFloat(logoImageSizeValue);
            h = parseFloat(h) * parseFloat(logoImageSizeValue);

            if (imgNode.id.includes("phTextNode")) imgNode.removeChild(dummyDom);
            else imgNode.parentElement.removeChild(dummyDom);

            imgNode.parentElement.parentElement.style.width = w + "px";
            imgNode.parentElement.parentElement.style.height = h + "px";
            mainParent.style.width = w + "px";
            mainParent.style.height = h + "px";
            if (mainParent.id.includes("placeHolderParent")) mainParent.style.minHeight = h + "px";
            imgNode.parentElement.style.width = w + "px";
            imgNode.parentElement.style.height = h + "px";
            imgNode.setAttribute("data-width", w);
            imgNode.setAttribute("data-height", h);
            if (imgNode && imgNode.hasAttribute("data-csstext") && imgNode.getAttribute("data-csstext") != "") {
                var imageDimensionRatio = imgNode.width / imgNode.height;
                var canvasDimensionRatio = w / h;
                if (imageDimensionRatio > canvasDimensionRatio) {
                    imgNode.parentElement.style.height = imgNode.height + "px";
                    imgNode.parentElement.parentElement.style.height = imgNode.height + "px";
                    imgNode.style.setProperty("bottom", 0);
                    imgNode.setAttribute("logosizecropheight", imgNode.height);
                }
            } else if (!imgNode.id.includes("phTextNode")) this.specialGraphicsUtils.updateImageReSize(w, h, imgNode);
            if (imgNode.callback) imgNode.callback();
            imgNode.callback = null;
            if (imgNode.id.includes("phTextNode")) {
                mainParent.style.maxHeight = h + "px";
                mainParent.style.height = "auto";
                mainParent.style.minHeight = "unset";

                mainParent.style.maxWidth = w + "px";
                mainParent.style.width = "auto";

                imgNode.parentElement.style.maxWidth = w + "px";
                imgNode.parentElement.style.width = "auto";

                imgNode.parentElement.style.maxHeight = h + "px";
                imgNode.parentElement.style.height = "auto";
                imgNode.parentElement.style.minHeight = "unset";
            }
        }
    }
};
GenericSpecialgraphicsCommon.prototype.rePositionTextAndElement = function () {
    this.onTextChangeForAllNodes();
    this.rePositioningTextElement();
};
GenericSpecialgraphicsCommon.prototype.textPositionChangeOperation = function (targetParent, pos) {
    if (targetParent) {
        for (let a = 0; a < targetParent.children.length; a++) {
            if (targetParent.children[a].style.position != "absolute") {
                let element = targetParent.children[a];
                let elementId = element.id;
                pos = pos.replace("sg", "");
                let textAlign = pos == "TL" || pos == "ML" || pos == "BL" ? "start" : pos == "TR" || pos == "MR" || pos == "BR" ? "end" : pos == "TM" || pos == "MM" || pos == "BM" ? "center" : "";
                if (elementId && elementId.includes("placeHolderParent")) {
                    if (element.querySelector("[id='phTextNode']")) element.querySelector("[id='phTextNode']").style.textAlign = textAlign;
                    element = element.querySelector("[id*='logoContentParent']");
                    elementId = element.id;
                }
                if (elementId.includes("logoContentParent")) {
                    if (element.getElementsByTagName("img").length > 0) {
                        let imageNode = element.getElementsByTagName("img")[0];
                        if (!imageNode.hasAttribute("data-oldimagecropalignment")) imageNode.setAttribute("data-oldimagecropalignment", imageNode.getAttribute("data-imagecropalignment"));
                        imageNode.setAttribute(
                            "data-imagecropalignment",
                            pos == "TL" || pos == "ML" || pos == "BL" ? "left" : pos == "TR" || pos == "MR" || pos == "BR" ? "right" : pos == "TM" || pos == "MM" || pos == "BM" ? "center" : imageNode.hasAttribute("data-oldimagecropalignment") ? imageNode.getAttribute("data-oldimagecropalignment") : "center"
                        );
                        imageNode.removeAttribute("data-style");
                        imageNode.removeAttribute("data-csstext");
                        if (imageNode.offsetHeight != 0) this.specialGraphicsUtils.updateImageReSize(imageNode.getAttribute("data-width"), imageNode.getAttribute("data-height"), imageNode);
                    }
                }
            }
        }
        //Text Element positioning after all text's props change
        this.rePositioningTextElement();
        this.checkShapeDependency();
    }
};
GenericSpecialgraphicsCommon.prototype.svgLoadCallback = function (responseData) {
    //Loading svg from menu for icon/image background svg global style - only for "contentBackground"
    for (let a = 0; a < responseData.length; a++) {
        let localSvgParent = responseData[a].parent;
        let colorClass = responseData[a] && responseData[a].color ? responseData[a].color : "clsAccentfill";
        if (localSvgParent && localSvgParent.querySelector("[id*='contentBackground']")) {
            let bgNode = localSvgParent.querySelector("[id*='contentBackground']");
            bgNode.classList.remove(colorClass);
            bgNode.classList.add(colorClass);
            var parser = new DOMParser();
            var doc = parser.parseFromString(responseData[a].data, "image/svg+xml");
            bgNode.innerHTML = "";
            bgNode.appendChild(doc.lastChild);
        }
    }
};
GenericSpecialgraphicsCommon.prototype.placeholderSvgLoadCallback = function (responseData) {
    //Loading svg from menu for icon/image background svg global style - only for "contentBackground"
    for (let a = 0; a < responseData.length; a++) {
        let localSvgParent = responseData[a].parent;
        let colorClass = responseData[a] && responseData[a].color ? responseData[a].color : "clsAccentfill";
        if (localSvgParent) {
            localSvgParent.classList.remove(colorClass);
            localSvgParent.classList.add(colorClass);
            var parser = new DOMParser();
            var doc = parser.parseFromString(responseData[a].data, "image/svg+xml");
            localSvgParent.innerHTML = "";
            localSvgParent.appendChild(doc.lastChild);
        }
    }
};
GenericSpecialgraphicsCommon.prototype.textFitOnImageResize = function (targetIndex) {
    this.onTextChangeForAllNodes(this.sgParent, targetIndex);
    this.rePositioningTextElement(targetIndex);
    this.checkShapeDependency(this.currentNodeIndex - 1);
};

GenericSpecialgraphicsCommon.prototype.checkShapeDependency = function (index = -1) {
    if (this.sgParent.hasAttribute("depends") && this.sgParent.getAttribute("depends") == "content") {
        for (let a = 0; a < (index == -1 ? this.sgData.length : 1); a++) {
            let assetParent = this.sgParent.querySelector("[id='assetParent" + (index == -1 ? a : index) + "']");
            // console.log("SG - checking shape height - " + assetParent.id);
            if (assetParent && assetParent.querySelector("[id='shape1']") && assetParent.querySelector("[id='shape1']").hasAttribute("depends")) {
                let shape = assetParent.querySelector("[id='shape1']");
                let parent = shape.parentElement;
                shape.style.height = "auto";
                shape.style.width = "auto";
                let oldH = parent.style.height;
                parent.style.height = "auto";
                let maxWidth = 0;
                for (let b = 0; b < parent.children.length; b++) {
                    if (parent.children[b].offsetWidth > maxWidth) maxWidth = parent.children[b].offsetWidth;
                }
                let elementPadding = this.specialGraphicsUtils.getPadding(parent);
                shape.style.height = parent.offsetHeight + "px";
                shape.style.width = maxWidth + parseFloat(elementPadding.paddingLeft) + parseFloat(elementPadding.paddingRight) + "px";
                parent.style.height = oldH;

                let tp = this.specialGraphicsUtils.getOldPositionClass(parent);
                if (tp) {
                    shape.style.top = tp == "TL" || tp == "TR" || tp == "TM" ? "0px" : "unset";
                    shape.style.bottom = tp == "BL" || tp == "BR" || tp == "BM" ? "0px" : "unset";
                    shape.style.left = tp == "BL" || tp == "TL" || tp == "ML" ? "0px" : "unset";
                    shape.style.right = tp == "BR" || tp == "TR" || tp == "MR" ? "0px" : "unset";
                }
            }
        }
    }
};
// Check and apply Flip & bleed options
GenericSpecialgraphicsCommon.prototype.applyImageBleedCommon = function (assetparent, tagName = null) {
    if (assetparent) {
        this.specialGraphicsUtils.checkAndApplyFlipBleed(assetparent, this.sgParent, this.metaData, this.getProps(), tagName);
    } else {
        let arrAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
        for (let a = 0; a < arrAssetParent.length; a++) {
            this.specialGraphicsUtils.checkAndApplyFlipBleed(arrAssetParent[a], this.sgParent, this.metaData, this.getProps(), tagName);
        }
    }
};

"use strict";

function GenericSpecialgraphicsDevice(sgParent, sgData, moodName, metaData, styleName, isPlayAnimation = true, textElementData, socialiconsData, fontData, objDataToSG) {
    this.metaData = metaData;
    this.specialGraphicsUtils = new window["SpecialGraphicsUtils"]();
    this.slideContent = objDataToSG && objDataToSG.slide ? objDataToSG.slide : null;
    this.deviceStyle = objDataToSG && objDataToSG.deviceStyle ? objDataToSG.deviceStyle : "photographic";
    this.isSafari = objDataToSG && objDataToSG.issafari ? objDataToSG.issafari : false;
    this.isSafari = false;
    this.sgData = sgData;

    if (this.metaData && this.metaData.menuData && this.metaData.menuData.filtercategory) {
        let arrData = this.metaData.menuData.filtercategory.split("-");
        sgParent.parentElement.parentElement.setAttribute("data-sgdevicemodel", arrData[0]);
        sgParent.parentElement.parentElement.setAttribute("data-sgorientation", arrData[1]);
        sgParent.parentElement.parentElement.setAttribute("data-sgalignment", arrData[2]);
    }
    this.decodeMetaData = this.decodeMetaData.bind(this);
    this.moodShapeSvgLoadComplete = this.moodShapeSvgLoadComplete.bind(this);
    this.deviceLoadComplete = this.deviceLoadComplete.bind(this);

    if (this.isPresent != true) this.decodedMetaData = this.decodeMetaData(sgParent, true);

    this.moodName = moodName;
    GenericSpecialgraphics.call(this, sgParent, sgData, moodName, metaData, styleName, isPlayAnimation, textElementData, socialiconsData, fontData, objDataToSG);
}

GenericSpecialgraphicsDevice.prototype = Object.create(GenericSpecialgraphics.prototype);

GenericSpecialgraphicsDevice.prototype.loadSvgAssets = function (arrAssets, callback) {
    let assetLoader = new window["SGAssetLoader"]();
    assetLoader
        .loadAssets(arrAssets, this.appStaticURL)
        .then((responseData) => {
            callback(arrAssets);
        })
        .catch(function (rej) {
            console.log("Downloaded Assets error on device imagestack");
            console.log(rej);
        });
};

GenericSpecialgraphicsDevice.prototype.deviceLoadComplete = function (arrAssets) {
    if (arrAssets.length > 0 && arrAssets.filter((obj) => obj.id == "deviceSVG")) {
        let imageData = arrAssets.filter((obj) => obj.id == "deviceSVG")[0];
        let deviceNode = imageData.node;
        let imagerul = imageData.imagerul;
        let assetname = imageData.assetname;
        deviceNode.innerHTML = imageData.data;
        if (deviceNode.getElementsByTagName("svg").length > 0) deviceNode.getElementsByTagName("svg")[0].setAttribute("data-nodetype", "deviceSVG");
        let clipPath = deviceNode.getElementsByTagName("clipPath");
        let clipID = null;
        if (clipPath && clipPath.length > 0 && imageData.masknode) {
            if (this.sgParent.hasAttribute("maskid")) clipPath[0].id = this.sgParent.getAttribute("maskid");
            else clipPath[0].id = clipPath[0].id + this.specialGraphicsUtils.generateRandomStringCSS();
            clipID = clipPath[0].id;

            imageData.masknode.style.setProperty("clip-path", "url(#" + clipID + ")");
            imageData.masknode.style.setProperty("-webkit-clip-path", "url(#" + clipID + ")");

            let deviceImageNode = this.sgParent.querySelector("[id='deviceImageNode']");
            if (deviceImageNode) deviceImageNode.setAttribute("svgid", clipID);
            let imageParent = this.sgParent.querySelectorAll("[id*='coverImageParent']");
            for (let a = 0; a < imageParent.length; a++) {
                imageParent[a].style.setProperty("clip-path", "url(#" + clipID + ")");
                imageParent[a].style.setProperty("-webkit-clip-path", "url(#" + clipID + ")");
            }
        }
        if (imageData.masknode && clipID) {
            let coverImage = imageData.masknode.querySelector("[data-target-id='coverimage']");
            if (coverImage) {
                let w = window.getComputedStyle(imageData.masknode).width;
                let h = window.getComputedStyle(imageData.masknode).height;
                //Setting up coverimage size for new device and applying new positioning for image crop
                coverImage.setAttribute("data-width", w);
                coverImage.setAttribute("data-height", h);
                if (coverImage && coverImage.dataset.csstext) {
                    coverImage.style = coverImage.dataset.csstext;
                } else this.specialGraphicsUtils.updateImageReSize(w, h, coverImage);
            }
        }
        if (deviceNode.querySelector("[id*='" + assetname + "-image']") && imagerul) {
            let imageNode = deviceNode.querySelector("[id*='" + assetname + "-image']").getElementsByTagName("image");
            if (imageNode && imageNode.length > 0) imageNode[0].setAttribute("xlink:href", imagerul);
        }
        let scaleValue = 1;
        if (deviceNode.getElementsByTagName("svg").length > 0 && clipID) {
            let svgDOM = deviceNode.getElementsByTagName("svg")[0];
            let assetImageParent = this.sgParent.parentElement.querySelector("[id='deviceImageParentNode']");
            let imageParentStyle = assetImageParent ? window.getComputedStyle(assetImageParent) : null;
            if (imageData.url && svgDOM) svgDOM.setAttribute("path", imageData.url);
            if (svgDOM && imageParentStyle && imageParentStyle.width != 0 && imageParentStyle.height != 0) {
                let scaleX = parseFloat(imageParentStyle.width) / parseFloat(svgDOM.getAttribute("viewBox").split(" ")[2]);
                let scaleY = parseFloat(imageParentStyle.height) / parseFloat(svgDOM.getAttribute("viewBox").split(" ")[3]);
                scaleValue = Math.min(scaleX, scaleY);
                let clipPathNode = svgDOM.querySelector("clipPath[id='" + clipID + "']");
                if (clipPathNode) clipPathNode.style.transform = "scale(" + scaleValue + ")";
            }
        }
        let bbox;
        try {
            bbox = clipPath ? clipPath[0].getBBox() : null;
        } catch (error) {}

        // if (deviceNode.querySelector("[data-name*='placeholder']")) {
        //     let placeholderNode = deviceNode.querySelector("[data-name*='placeholder']");
        //     let placeholderBBox = placeholderNode.getBBox();
        //     if (placeholderBBox && placeholderBBox.width != 0 && placeholderBBox.height != 0) bbox = placeholderBBox;
        // }
        if (deviceNode) {
            let clipPathGroupNode = deviceNode.querySelector("g[clip-path*='url(#" + assetname + "-clip-path)']");
            bbox = clipPathGroupNode ? clipPathGroupNode.getBBox() : { width: 0, height: 0, x: 0, y: 0 };
        }
        if (bbox && (bbox.width == 0 || bbox.height == 0) && imageData.masknode.querySelector("[id*='coverParent']")) {
            let arrCoverParent = this.sgParent.querySelectorAll("[id*='coverParent']");
            for (let a = 0; a < arrCoverParent.length; a++) {
                arrCoverParent[a].style.width = "100%";
                arrCoverParent[a].style.height = "100%";
                arrCoverParent[a].style.position = "relative";
            }
        }
        if (bbox && bbox.width && imageData.masknode.querySelector("[id*='coverParent']")) {
            let arrCoverParent = this.sgParent.querySelectorAll("[id*='coverParent']");
            for (let a = 0; a < arrCoverParent.length; a++) {
                let coverParent = arrCoverParent[a];
                let imageNode = coverParent.querySelector("[data-target-id='coverimage']");
                coverParent.style.position = "absolute";

                coverParent.style.width = bbox.width * scaleValue + "px";
                coverParent.style.height = bbox.height * scaleValue + "px";
                coverParent.style.left = bbox.x * scaleValue + "px";
                coverParent.style.top = bbox.y * scaleValue + "px";

                coverParent.style.setProperty("clip-path", "url(#" + clipID + ")");
                coverParent.style.setProperty("-webkit-clip-path", "url(#" + clipID + ")");
                coverParent.parentElement.style.removeProperty("-webkit-clip-path");
                coverParent.parentElement.style.removeProperty("clip-path");

                let clipPathNode = deviceNode.querySelector("clipPath[id='" + clipID + "']");
                if (clipPathNode) clipPathNode.style.transform = "scale(" + scaleValue + ") translate(" + parseFloat(bbox.x) * -1 + "px," + parseFloat(bbox.y) * -1 + "px)";

                coverParent.parentElement.classList.remove("slideGraphicElementTransformHoverState");
                coverParent.classList.remove("slideGraphicElementTransformHoverState");
                coverParent.classList.add("slideGraphicElementTransformHoverState");
                if (imageNode) {
                    imageNode.setAttribute("data-width", parseFloat(coverParent.style.width));
                    imageNode.setAttribute("data-height", parseFloat(coverParent.style.height));
                    imageNode.setAttribute("data-x", parseFloat(coverParent.style.left));
                    imageNode.setAttribute("data-y", parseFloat(coverParent.style.top));
                    if (imageNode.dataset.csstext && imageNode.dataset.csstext != "" && imageNode.dataset.csstext != "undefined") imageNode.style = imageNode.dataset.csstext;
                    else {
                        setTimeout(() => {
                            this.specialGraphicsUtils.updateImageReSize(parseFloat(coverParent.style.width), parseFloat(coverParent.style.height), imageNode);
                        }, 0);
                    }
                }
            }
        }

        let slideId = this.slideContent ? this.slideContent.id : this.sgParent.parentElement.parentElement.parentElement.id;
        if (this.updateThumbnail) this.updateThumbnail(slideId);
    }
};

GenericSpecialgraphicsDevice.prototype.decodeMetaData = function (sgParent, changeDeviceData = false) {
    try {
        //Getting Metada from details depends on device properties.
        let sgParentNode = sgParent ? sgParent : this.sgParent;
        let animationDIV = sgParentNode.parentElement && sgParentNode.parentElement.parentElement ? sgParentNode.parentElement.parentElement : null;

        let defaultData = this.specialGraphicsUtils.getDefaultDeviceData(this.metaData);
        let sgdevicemodel = animationDIV && animationDIV.dataset.sgdevicemodel ? animationDIV.dataset.sgdevicemodel : defaultData.sgdevicemodel;
        let sgorientation = animationDIV && animationDIV.dataset.sgorientation ? animationDIV.dataset.sgorientation : defaultData.sgorientation;
        let sgalignment = animationDIV && animationDIV.dataset.sgalignment ? animationDIV.dataset.sgalignment : defaultData.sgalignment;

        if (this.sgData && this.sgData[1] && (this.sgData[1].devicealign || this.sgData[1].deviceorientation) && this.metaData && this.metaData.menuData) {
            let newOrientation = this.sgData[1].deviceorientation ? this.sgData[1].deviceorientation : sgorientation;
            let newAlign = this.sgData[1].devicealign ? this.sgData[1].devicealign : sgalignment;
            let dataOnMenu = this.metaData.menuData[sgdevicemodel + newOrientation + newAlign];
            if (dataOnMenu) {
                sgalignment = newAlign;
                sgorientation = newOrientation;
            }
        }

        let selectedSettings = animationDIV.hasAttribute("data-variation-selected") && animationDIV.getAttribute("data-variation-selected") != "undefined" ? animationDIV.getAttribute("data-variation-selected") : animationDIV.hasAttribute("settingsmain") ? animationDIV.getAttribute("settingsmain") : "";
        if (changeDeviceData && selectedSettings.includes("flip") && sgalignment == "right") sgalignment = "left";
        if (changeDeviceData && !selectedSettings.includes("flip") && sgalignment == "left") sgalignment = "right";
        if (changeDeviceData && selectedSettings.includes("flip") && sgalignment == "top") sgalignment = "bottom";
        if (changeDeviceData && !selectedSettings.includes("flip") && sgalignment == "bottom") sgalignment = "top";

        if (animationDIV) animationDIV.dataset.sgalignment = sgalignment;

        animationDIV.setAttribute("data-sgdevicemodel", sgdevicemodel);
        animationDIV.setAttribute("data-sgorientation", sgorientation);
        animationDIV.setAttribute("data-sgalignment", sgalignment);
        if ((sgalignment == "top" || sgalignment == "bottom") && sgorientation == "landscape") animationDIV.setAttribute("fontmapping", "small");
        else animationDIV.removeAttribute("fontmapping");
        let alignmentOfDevice = sgalignment == "top" || sgalignment == "bottom" || sgalignment == "center" ? "center" : sgalignment == "left" ? "right" : "left";
        animationDIV.setAttribute("data-customlayout", animationDIV.getAttribute("data-customlayout-is") + "-" + alignmentOfDevice);

        let deviceModelData = this.metaData[sgdevicemodel] ? this.metaData[sgdevicemodel] : this.metaData;
        let orientationData = deviceModelData && deviceModelData[sgorientation] ? deviceModelData[sgorientation] : deviceModelData ? deviceModelData : this.metaData;
        let alignmentData = orientationData && orientationData[sgalignment] ? orientationData[sgalignment] : orientationData ? orientationData : this.metaData;

        let obj = {};
        obj.deviceModelData = deviceModelData;
        obj.alignmentData = alignmentData;
        obj.orientationData = orientationData;
        obj.sgalignment = sgalignment;
        obj.sgorientation = sgorientation;
        obj.sgdevicemodel = sgdevicemodel;
        return obj;
    } catch (error) {
        console.log("Error on decodeMetaData = " + error);
    }
};

GenericSpecialgraphicsDevice.prototype.changeDeviceProperties = function (doMainFunctions = false, newMenu) {
    //Changing device properties from setting menu on floater
    this.decodedMetaData = this.decodeMetaData(this.sgParent, doMainFunctions ? false : true);
    let animationDIV = this.sgParent.parentElement.parentElement;
    this.sgData = this.specialGraphicsUtils.buildDomContentArray(animationDIV);
    if (doMainFunctions) {
        //Change device type functionality flow..
        let sgalignment = this.decodedMetaData.sgalignment;
        let sgorientation = this.decodedMetaData.sgorientation;
        let sgdevicemodel = this.decodedMetaData.sgdevicemodel;
        if (sgalignment && sgorientation && sgdevicemodel) this.deviceModel = sgdevicemodel + sgorientation + sgalignment;

        let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData ? this.metaData : null;
        let property = metaDataBase && metaDataBase.properties;
        if (this.deviceModel != "" && metaDataBase[this.deviceModel] && metaDataBase[this.deviceModel].properties) property = metaDataBase[this.deviceModel].properties;
        let menuData = newMenu ? newMenu : null;
        if (!property) {
            menuData = menuData ? menuData : this.getMenuData ? this.getMenuData(animationDIV.getAttribute("data-asset-name")) : null;
            if (menuData && menuData.layoutMetadata && this.deviceModel != "" && menuData.layoutMetadata[this.deviceModel] && menuData.layoutMetadata[this.deviceModel].properties) {
                property = menuData.layoutMetadata[this.deviceModel].properties;
                this.metaData.menuData = menuData.layoutMetadata;
            }
        }
        this.currentNodeIndex = 2;
        this.oldContent = null;
    }
    this.initSpecialGraphicsCreation(doMainFunctions);
    let slideDomContentGroup = animationDIV ? animationDIV.querySelector("[id='AESpecialGraphics']") : null;
    if (slideDomContentGroup) {
        let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
        for (let i = 0; i < assetParents.length; i++) {
            this.specialGraphicsUtils.changeVariation(assetParents[i], slideDomContentGroup, i);
        }
    }
    this.sgParent.style.opacity = 1;
};

GenericSpecialgraphicsDevice.prototype.specialGraphicsSlideCreationComplete = function (index, loadAssets = true) {
    try {
        if (this.metaData) {
            // console.log("SGG - doing specialGraphicsSlideCreationComplete");
            let assetParent = this.sgParent.querySelector("[id='assetParent" + index + "']");
            // if (this.moodName == "simplecss" || this.moodName == "modern" || this.moodName == "tiniest") assetParent.style.removeProperty("z-index");
            // else assetParent.style.zIndex = "100";

            let contentMainParent = assetParent.querySelector("[id='contentMainParent']");
            contentMainParent.classList.remove("sgImageBleedChild");
            contentMainParent.classList.remove("sgFlipChild");

            // this.creatingMoodShapes(assetParent, index);
            let sgalignment = this.decodedMetaData.sgalignment;
            let sgorientation = this.decodedMetaData.sgorientation;
            let sgdevicemodel = this.decodedMetaData.sgdevicemodel;
            if (assetParent && assetParent.querySelector("[id='coverImageParent']")) {
                let deviceModelData = this.decodedMetaData.deviceModelData;

                let assetPathFromMetadata = this.specialGraphicsUtils.getDeviceAssetPath(sgdevicemodel);
                // let assetPathFromMetadata = deviceModelData.assetPath;

                let imageParent = assetParent.querySelector("[id='coverImageParent']");

                if (this.sgParent.hasAttribute("maskid")) {
                    let clipID = this.sgParent.getAttribute("maskid");
                    imageParent.style.setProperty("clip-path", "url(#" + clipID + ")");
                    imageParent.style.setProperty("-webkit-clip-path", "url(#" + clipID + ")");
                }

                if (sgdevicemodel.includes("phone") && (sgalignment == "top" || sgalignment == "bottom")) sgalignment = "left";
                let deviceNode = this.sgParent.querySelector("[id='deviceImageNode']");
                let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
                let commonName = assetPathFromMetadata;
                if (sgorientation == "landscape" && (sgdevicemodel.includes("phone") || sgdevicemodel.includes("tablet"))) {
                    if (sgalignment == "top" || sgalignment == "bottom" || sgalignment == "center") commonName = commonName + sgorientation + "left";
                    else commonName = commonName + sgorientation + sgalignment;
                }

                var svgPath = this.appStaticURL + "genericassets/device/" + this.deviceStyle + "/" + commonName + ".svg";
                var imagePath = this.appStaticURL + "genericassets/device/" + this.deviceStyle + "/" + assetPathFromMetadata + ".png";

                if (!deviceNode) {
                    // If device node is not there we create it here
                    deviceImageParentNode = document.createElement("div");
                    deviceImageParentNode.id = "deviceImageParentNode";
                    deviceImageParentNode.className = "deviceImageParentNode";
                    deviceImageParentNode.style.transformOrigin = "right top";
                    deviceImageParentNode.style.pointerEvents = "none";
                    deviceImageParentNode.setAttribute("device", "true");
                    this.sgParent.appendChild(deviceImageParentNode);

                    let deviceImageNode = document.createElement("div");
                    deviceImageNode.id = "deviceImageNode";
                    deviceImageNode.className = "deviceImageNode" + " moodanimation ";
                    deviceImageNode.setAttribute("data-nodetype", "deviceHolder");

                    let arrAssets = [{ url: svgPath, imagerul: imagePath, type: "SVG", node: deviceImageNode, id: "deviceSVG", masknode: imageParent, assetname: commonName }];
                    // this.loadSvgAssets(arrAssets, this.deviceLoadComplete);
                    this.arrCommonAssets.push({ array: arrAssets, callback: this.deviceLoadComplete });

                    deviceImageNode.style.zIndex = 0;
                    deviceImageParentNode.appendChild(deviceImageNode);
                    this.sgParent.appendChild(assetParent);
                    this.sgParent.parentElement.style.overflow = "hidden";
                    this.sgParent.parentElement.style.position = "absolute";

                    deviceImageNode.style.width = "100%";
                    deviceImageNode.style.height = "100%";
                } else if (index == 1 && loadAssets) {
                    // If device node is already exits changing image path here
                    if (deviceNode.children.length > 0) deviceNode.innerHTML = "";
                    let arrAssets = [{ url: svgPath, imagerul: imagePath, type: "SVG", node: deviceNode, id: "deviceSVG", masknode: imageParent, assetname: commonName }];
                    // this.loadSvgAssets(arrAssets, this.deviceLoadComplete);
                    this.arrCommonAssets.push({ array: arrAssets, callback: this.deviceLoadComplete });
                }

                let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData ? this.metaData : null;
                let property = metaDataBase && metaDataBase.properties;
                if (this.deviceModel != "" && metaDataBase[this.deviceModel] && metaDataBase[this.deviceModel].properties) property = metaDataBase[this.deviceModel].properties;

                let isShapeBelowDevice = "false";
                if (property && property.image) {
                    let deviceProp = property.image;
                    isShapeBelowDevice = deviceProp.shapebelowdevice ? deviceProp.shapebelowdevice : "false";
                    if (deviceProp.deviceposition) this.specialgraphicsPropertyUtils.updatePosition(deviceImageParentNode, deviceProp.deviceposition);
                    else if (deviceProp.position) this.specialgraphicsPropertyUtils.updatePosition(deviceImageParentNode, deviceProp.position);
                    if (deviceProp.padding) this.specialgraphicsPropertyUtils.updatePadding(deviceProp.padding, deviceImageParentNode);
                    if (deviceProp.margin) this.specialgraphicsPropertyUtils.updateMargin(deviceProp.margin, deviceImageParentNode);
                    if (property.image.deviceglobalstyle) {
                        deviceImageParentNode.classList.remove(property.image.deviceglobalstyle);
                        deviceImageParentNode.classList.add(property.image.deviceglobalstyle);
                        deviceImageParentNode.classList.add("clsSingleColorParent");
                    }
                }
                deviceImageParentNode.style.position = imageParent.style.position;
                // deviceImageParentNode.style.position = "absolute";

                if (isShapeBelowDevice == "true") {
                    assetParent.style.zIndex = "unset";
                    deviceImageParentNode.style.zIndex = "1";
                } else {
                    assetParent.style.zIndex = "100";
                    deviceImageParentNode.style.removeProperty("z-index");
                }
            }

            let arrAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
            for (let a = 0; a < arrAssetParent.length; a++) {
                let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
                let assetParent = arrAssetParent[a];
                if (assetParent0 && assetParent && assetParent0.querySelector("[id='coverImageParent']")) {
                    let imageParent = assetParent0.querySelector("[id='coverImageParent']");
                    let newImageParent = assetParent.querySelector("[id='coverImageParent']");
                    if (imageParent && imageParent.hasAttribute("svgid") && newImageParent) newImageParent.setAttribute("svgid", imageParent.getAttribute("svgid"));
                }
            }
        }
    } catch (error) {
        console.log("SG - Error on specialGraphicsSlideCreationComplete - Device imagestack" + error);
    }
    GenericSpecialgraphics.prototype.specialGraphicsSlideCreationComplete.call(this, index);
};

GenericSpecialgraphicsDevice.prototype.moodShapeSvgLoadComplete = function (arrAssets) {
    if (arrAssets.length > 0) {
        for (let i = 0; i < arrAssets.length; i++) {
            let assetParent = this.sgParent.querySelector("[id='assetParent" + arrAssets[i].index + "']");
            let moodShape = assetParent ? assetParent.querySelector("[id='" + arrAssets[i].shapeId + "']") : null;
            if (moodShape) {
                moodShape.innerHTML = arrAssets[i].data;
                let svgNode = moodShape.getElementsByTagName("svg");
                if (svgNode) {
                    svgNode[0].style.width = "100%";
                    svgNode[0].style.height = "100%";
                }
            }
        }
    }
};

// GenericSpecialgraphics.prototype.changeVariation = function (slideDomContentGroup, updateOnlyVariation = false, updatePosition = true) {
//     GenericSpecialgraphics.prototype.changeVariation.call(this, slideDomContentGroup, updateOnlyVariation, updatePosition);
//     let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
//     for (let i = 0; i < assetParents.length; i++) {
//         let flipChild1 = assetParents[i].querySelector("[class*='flipChild1']");
//         let flipChild2 = assetParents[i].querySelector("[class*='flipChild2']");
//
//     }
// };

"use strict";

function GenericCarouselImagestack(sgParent, sgData, moodName, metadata, styleName = "", isPlayAnimation = true, textElementData, socialiconsData, fontData, objDataToSG) {
    this.specialGraphicsUtils = new window["SpecialGraphicsUtils"]();
    this.specialGraphicsAnimationUtils = new window["SpecialGraphicsAnimationUtils"]();

    let styleData = {};

    let baseSet = {
        title: "h4",
        titleNoSubtitle: "h3",
        subtitle: "p4",
        label: "p3",
        number: "n1",
        introtitle: "h2",
        introtitleNoSubtitle: "h1",
        introsubtitle: "p3",
        introlabel: "p2",
    };
    baseSet = fontData ? fontData : baseSet;
    styleData.fontData = baseSet;
    this.fontData = JSON.parse(JSON.stringify(baseSet));

    baseSet.titleClass = baseSet.title;
    baseSet.subtitleClass = baseSet.subtitle;
    baseSet.labelClass = baseSet.label;
    baseSet.title = " " + baseSet.title + " ";
    baseSet.subtitle = " " + baseSet.subtitle + " ";
    baseSet.label = " " + baseSet.label + " ";
    baseSet.number = " " + baseSet.number + " ";

    this.sgParent = sgParent;
    this.sgSlideType = this.sgParent.dataset.slidetype;

    //Setting all nodes prompt text here
    styleData.titlePrompt = this.sgSlideType == "textstack" ? "Type a Headline" : "Type an image caption";
    styleData.subTitlePrompt = this.sgSlideType == "textstack" ? "A brief explanation about the headline" : "A brief explanation about the image you have used";
    styleData.titleLabelPrompt = "Title label here";

    styleData.styleName = styleName;

    this.socialiconsData = socialiconsData;

    this.sgParent.className = "genericspecialgraphics";

    this.isPlayAnimation = isPlayAnimation;
    this.slideContent = objDataToSG && objDataToSG.slide ? objDataToSG.slide : null;
    this.isPreviewMode = objDataToSG && objDataToSG.isPreviewMode ? objDataToSG.isPreviewMode : false;
    this.oldContent = objDataToSG && objDataToSG.isLoadedSlide ? objDataToSG.isLoadedSlide : null;

    this.assetsLoadComplete = this.assetsLoadComplete.bind(this);
    this.onTextChange = this.onTextChange.bind(this);
    this.changeVariation = this.changeVariation.bind(this);
    this.updateHeightForText = this.updateHeightForText.bind(this);
    this.textFitOnImageResize = this.textFitOnImageResize.bind(this);
    this.logoLoadCallback = this.logoLoadCallback.bind(this);
    this.updateImageResizeOnTypeChange = this.updateImageResizeOnTypeChange.bind(this);

    this.sgSlideType = "imagestack";

    this.isFromLastSlide = metadata ? metadata.isFromLastSlide : false;
    this.currentNodeIndex = this.isFromLastSlide == true ? sgData.length : 1;

    this.setTargetIndex(0, sgParent);
    this.specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL);
    this.specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });

    if (this.slideContent) {
        this.slideContent.classList.remove("darkText");
        this.slideContent.classList.remove("lightText");
        this.slideContent.classList.remove("fixedlightText");
        this.slideContent.classList.remove("fixeddarkText");
    }
    if (sgData.length > 2) sgParent.parentElement.parentElement.setAttribute("fulloptions", "true");
    else sgParent.parentElement.parentElement.setAttribute("fulloptions", "false");
    this.deviceModel = "";
    SGBaseClass.call(this, sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, this.fontData, "imagestack", styleData, objDataToSG);
}

GenericCarouselImagestack.prototype = Object.create(SGBaseClass.prototype);

GenericCarouselImagestack.prototype.setTargetIndex = function (index = 0, sgParent = null) {
    let localParent = sgParent ? sgParent : this.sgParent;
    let animationDIV = localParent && localParent.parentElement && localParent.parentElement.parentElement ? localParent.parentElement.parentElement : null;
    if (animationDIV && animationDIV.id == "animationDIV") animationDIV.setAttribute("data-target-index", index);
};

GenericCarouselImagestack.prototype.initSpecialGraphicsCreation = function () {
    this.specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL);
    this.specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
    if (this.isWidget == false || (this.objDataToSG && this.objDataToSG.menuChange)) {
        this.deviceModel = "";
        if (this.decodeMetaData) {
            let decodedMetaData = this.decodeMetaData(this.sgParent);
            let sgalignment = decodedMetaData.sgalignment;
            let sgorientation = decodedMetaData.sgorientation;
            let sgdevicemodel = decodedMetaData.sgdevicemodel;
            if (sgalignment && sgorientation && sgdevicemodel && sgalignment == "top" && sgdevicemodel.includes("phone") && sgorientation == "portrait") sgalignment = "left";
            if (sgalignment && sgorientation && sgdevicemodel) this.deviceModel = sgdevicemodel + sgorientation + sgalignment;
        }
        if (!this.oldContent) {
            for (let c = 0; c < this.sgData.length; c++) {
                let assetParent = this.createAssetParent(c, this.sgParent);
                // assetParent.setAttribute("iscarousel", "true");
                let imagestackIntro = (this.sgSlideType == "imagestack" || this.sgSlideType == "textstack") && c == 0 && this.sgData.length != 1 ? "introSlide" : "";
                if (imagestackIntro != "") assetParent.classList.add(imagestackIntro);

                //Creating nodes from menu
                let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData && this.metaData ? this.metaData : null;
                if (metaDataBase && metaDataBase[this.deviceModel] && (metaDataBase[this.deviceModel].supportedNodes || metaDataBase[this.deviceModel].introNodes)) metaDataBase = metaDataBase[this.deviceModel];
                if (metaDataBase && (metaDataBase.supportedNodes || metaDataBase.introNodes)) {
                    let supportNode = imagestackIntro != "" && metaDataBase.introNodes ? metaDataBase.introNodes : metaDataBase.supportedNodes;
                    // let intCount = supportNode.length;
                    // for (let i = 0; i < 1; i++) {
                    let nodeObj = supportNode;
                    let nodeParent = this.createNodes(nodeObj, assetParent, c);
                    if (nodeObj.subNodes && nodeParent) this.createNestedNodes(nodeObj.subNodes, nodeParent, c);
                    // }
                }

                let property = metaDataBase && metaDataBase.properties;
                if (this.deviceModel != "" && metaDataBase[this.deviceModel] && metaDataBase[this.deviceModel].properties) property = metaDataBase[this.deviceModel].properties;
                if (metaDataBase && metaDataBase.introproperties && c == 0) property = metaDataBase.introproperties;

                if (property) {
                    let props = property;
                    if (props && props.carousel && assetParent.querySelector("[id='contentMainParent']")) {
                        if (props.carousel.type == "type1") {
                            let contentMainParent = assetParent.querySelector("[id='contentMainParent']");
                            if (props.carousel.padding) this.specialgraphicsPropertyUtils.updatePadding(props.carousel.padding, contentMainParent, true);
                            if (props.carousel.margin) this.specialgraphicsPropertyUtils.updateMargin(props.carousel.margin, contentMainParent, true);
                            if (props.carousel.zorder) nodeParent.style.zIndex = props.carousel.zorder;
                            if (props.carousel.position && props.carousel.position.split(",").length == 4) this.specialgraphicsPropertyUtils.updatePosition(nodeParent, props.carousel.position);
                        }
                    }
                    if (props && !props.bgshape) props.bgshape = "emptylayoutshape";
                    if (this.objDataToSG?.layoutshapeoutline && props) props.bgshape = this.objDataToSG.layoutshapeoutline;

                    //Creating bgshape
                    if (props?.bgshape && this.slideContent && this.createLayoutShape) this.createLayoutShape("add", props.bgshape, this.slideContent);
                    else if (this.slideContent && this.createLayoutShape) this.createLayoutShape("remove", "", this.slideContent);

                    if (this.layoutShapeAddCallback) {
                        let slideID = this.slideContent && this.slideContent.id ? this.slideContent.id : null;
                        this.layoutShapeAddCallback(slideID);
                    }
                    //Applying textelement style property for slide
                    if (props && props.textelementstyle && this.slideContent) {
                        this.sgParent.parentElement.parentElement.setAttribute("data-textelementstyle", props.textelementstyle);
                        assetParent.setAttribute("data-textelementstyle", props.textelementstyle);
                    } else if (this.sgParent.parentElement && this.sgParent.parentElement.parentElement) {
                        this.sgParent.parentElement.parentElement.removeAttribute("data-textelementstyle");
                        assetParent.removeAttribute("data-textelementstyle");
                    }
                    if (assetParent.hasAttribute("textPosition") && assetParent.querySelector("[id*='textBaseParentNode']")) {
                        let textBaseParent = assetParent.querySelector("[id*='textBaseParentNode']");
                        this.textPositionChangeOperation(textBaseParent.parentElement, assetParent.getAttribute("textPosition"));
                    }
                    this.updateHeightForText(assetParent);
                    // let textInnerParentNode = assetParent.querySelector("[id*='textInnerParentNode']");
                    // if (props.number && props.number.depends && props.number.depends == "text" && textInnerParentNode && assetParent.querySelector("[id='sgNumberTextParent']")) {
                    //     //If number depends text then we have to do this
                    //     let numberNode = assetParent.querySelector("[id='sgNumberTextParent']");
                    //     let numberNodecontent = assetParent.querySelector("[id*='sgNumberTextNode']");
                    //     let node = numberNodecontent ? numberNodecontent : numberNode;

                    //     numberNode.parentElement.removeChild(numberNode);
                    //     textInnerParentNode.appendChild(numberNode);
                    //     numberNode.style.position = "relative";
                    //     numberNode.style.left = "unset";
                    //     numberNode.style.right = "unset";
                    //     numberNode.style.top = "unset";
                    //     numberNode.style.bottom = "unset";

                    //     assetParent.style.setProperty("--numberTop", "unset");
                    //     assetParent.style.setProperty("--numberLeft", "unset");
                    //     assetParent.style.setProperty("--numberRight", "unset");
                    //     assetParent.style.setProperty("--numberBottom", "unset");

                    //     let sgTitleNode = assetParent.querySelector("[id='sgTitleNode']");
                    //     let textAlign = sgTitleNode ? window.getComputedStyle(sgTitleNode)["text-align"] : "";
                    //     if (sgTitleNode && node) {
                    //         node.parentElement.style.alignSelf = textAlign == "right" || textAlign == "end" ? "flex-end" : textAlign == "center" ? "center" : "flex-start";
                    //         node.parentElement.style.justifyContent = textAlign == "right" || textAlign == "end" ? "flex-end" : textAlign == "center" ? "center" : "flex-start";
                    //     }
                    // }
                }

                let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
                let deviceBGColorParent = this.sgParent.querySelector("[id='deviceBGColorParent']");
                let deviceBGColorParentInside = deviceImageParentNode ? deviceImageParentNode.querySelector("[id='deviceBGColorParent']") : null;
                if (!deviceBGColorParentInside && deviceBGColorParent) {
                    deviceBGColorParent.parentElement.removeChild(deviceBGColorParent);
                    deviceImageParentNode.appendChild(deviceBGColorParent);
                }

                SGBaseClass.prototype.initSpecialGraphicsCreation.call(this);
                this.onTextChangeForAllNodes(this.sgParent, c);
                if (this.specialGraphicsSlideCreationComplete) this.specialGraphicsSlideCreationComplete(c);
            }
        } else {
            this.clearListener(false);
            for (let c = 0; c < this.sgData.length; c++) {
                let assetParent = this.createAssetParent(c, this.sgParent);
                let elements = assetParent ? assetParent.querySelectorAll("[listener='true']") : [];
                for (let a = 0; a < elements.length; a++) {
                    this.setTextFocus(elements[a], false, assetParent, true);
                }
            }
        }
    } else SGBaseClass.prototype.initSpecialGraphicsCreation.call(this);

    //Re-applying image contrast
    this.reApplyContrast();

    // if (this.oldContent || this.isWidget == true) {
    //     let allAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
    //     for (let c = 0; c < allAssetParent.length; c++) {
    //         let fullContrastElements = allAssetParent[c].querySelectorAll("[contrast='fullbg']");
    //         for (let a = 0; a < fullContrastElements.length; a++) {
    //             this.eventManager.dispatch("applyImageContrast", fullContrastElements[a], allAssetParent[c]);
    //         }
    //         let halfContrastElements = allAssetParent[c].querySelectorAll("[contrast='halfbg']");
    //         for (let b = 0; b < halfContrastElements.length; b++) {
    //             this.eventManager.dispatch("applyImageContrast", halfContrastElements[b], allAssetParent[c], true);
    //         }
    //     }
    // }
    if (this.isWidget) this.specialGraphicsUtils.updateImagePositions(this.sgParent);
    this.specialGraphicsCreationComplete();
};
GenericCarouselImagestack.prototype.reApplyContrast = function () {
    if (this.oldContent || this.isWidget == true || this.isPresent == true) {
        //Re-applying image contrast
        let allAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
        for (let c = 0; c < allAssetParent.length; c++) {
            let fullContrastElements = allAssetParent[c].querySelectorAll("[contrast='fullbg']");
            for (let a = 0; a < fullContrastElements.length; a++) {
                fullContrastElements[a].setAttribute("data-overlaychange", "false");
                this.eventManager.dispatch("applyImageContrast", fullContrastElements[a], allAssetParent[c]);
            }
            let halfContrastElements = allAssetParent[c].querySelectorAll("[contrast='halfbg']");
            for (let b = 0; b < halfContrastElements.length; b++) {
                halfContrastElements[b].setAttribute("data-overlaychange", "false");
                this.eventManager.dispatch("applyImageContrast", halfContrastElements[b], allAssetParent[c], true);
            }
        }
    }
};

GenericCarouselImagestack.prototype.specialGraphicsSlideCreationComplete = function (index) {
    // SGBaseClass.prototype.specialGraphicsSlideCreationComplete.call(this, index);
};
GenericCarouselImagestack.prototype.applyContrastToText = function (element, property) {
    if (property.contrast && (property.contrast == "true" || property.contrast == true) && element) element.setAttribute("data-supportcontrast", "true");
    else if (element) element.removeAttribute("data-supportcontrast");
};
GenericCarouselImagestack.prototype.applyChildStyleToParent = function (parent, child) {
    if (parent && child) {
        let childStyle = window.getComputedStyle(child);
        parent.style.width = child.style.width.includes("%") ? child.style.width : childStyle.width;
        parent.style.height = child.style.height.includes("%") ? child.style.height : childStyle.height;
        parent.style.left = childStyle.left;
        parent.style.top = childStyle.top;
        parent.style.position = childStyle.position;
        let margin = childStyle.margin == "" || childStyle.margin == "0px" ? child.style.margin : childStyle.margin;
        let padding = childStyle.padding == "" || childStyle.padding == "0px" ? child.style.padding : childStyle.padding;
        parent.style.margin = margin;
        parent.style.padding = padding;
        child.style.width = "100%";
        child.style.height = "100%";
        child.style.removeProperty("left");
        child.style.removeProperty("top");
        child.style.setProperty("margin", "unset", "important");
        child.style.setProperty("padding", "unset", "important");
    }
};
GenericCarouselImagestack.prototype.onTextChangeForAllNodes = function (sgParent = null, index = -1) {
    let assetParent = null;
    let indexValue = index != -1 ? index : this.currentNodeIndex - 1;
    if (sgParent) assetParent = sgParent.querySelector("[id='assetParent" + indexValue + "']");
    if (!assetParent) assetParent = this.sgParent.querySelector("[id='assetParent" + indexValue + "']");

    let oldDisplay = assetParent?.style?.display == "none" ? "none" : "";
    if (oldDisplay == "none") assetParent.style.display = "flex";

    let textBaseParentNode = assetParent.querySelector("[id*='textBaseParentNode']");
    if (!textBaseParentNode) textBaseParentNode = assetParent;
    if (textBaseParentNode) {
        textBaseParentNode.style.overflow = "hidden";
        // textBaseParentNode.style.removeProperty("max-height");
        let titleNode = textBaseParentNode.querySelector("[id='sgTitleNode']");
        let subTitleNode = textBaseParentNode.querySelector("[id='sgSubTitleNode']");
        let sgTitleLabelNode = textBaseParentNode.querySelector("[id='sgTitleLabelNode']");

        if (sgTitleLabelNode) {
            // sgTitleLabelNode.style.maxHeight = window.getComputedStyle(sgTitleLabelNode).lineHeight;
            // sgTitleLabelNode.parentElement.style.maxHeight = window.getComputedStyle(sgTitleLabelNode).lineHeight;
            let elementPadding = this.specialGraphicsUtils.getPadding(sgTitleLabelNode);
            let labelStyle = window.getComputedStyle(sgTitleLabelNode);
            sgTitleLabelNode.style.maxHeight = parseFloat(labelStyle.lineHeight) + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
            sgTitleLabelNode.parentElement.style.maxHeight = sgTitleLabelNode.style.maxHeight;
        }
        if (subTitleNode) {
            let supportParent = subTitleNode.hasAttribute("data-support") ? true : false;
            subTitleNode.style.removeProperty("max-height");
            if (supportParent != true) subTitleNode.parentElement.style.removeProperty("max-height");
            this.onTextChangeUpdate(subTitleNode, true, assetParent);
        }
        if (titleNode) {
            titleNode.style.removeProperty("max-height");
            titleNode.parentElement.style.removeProperty("max-height");
            this.onTextChangeUpdate(titleNode, true, assetParent);
        }

        // textBaseParentNode.style.removeProperty("overflow");
    }
    if (oldDisplay) assetParent.style.display = oldDisplay;
};

GenericCarouselImagestack.prototype.onTextChange = function (element) {
    let textNode = element;
    if (textNode && textNode.id.includes("sgTitleLabelNode")) {
        let labelStyle = window.getComputedStyle(textNode);
        let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
        textNode.style.maxHeight = parseFloat(labelStyle.lineHeight) + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
        textNode.parentElement.style.maxHeight = textNode.style.maxHeight;
    } else this.onTextChangeUpdate(textNode);
};

GenericCarouselImagestack.prototype.onTextChangeUpdate = function (textNode, isStart = false, assetParentNode = null) {
    let assetParent = assetParentNode ? assetParentNode : this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    let textBaseParentNode = assetParent.querySelector("[id*='textBaseParentNode']");
    let supportParent = textNode.hasAttribute("data-support") ? true : false;
    let singleNodeHeight = -1;
    if (supportParent == true && !textBaseParentNode && assetParent.querySelector("[id='sgTitleNode']")) {
        let titleNode = assetParent.querySelector("[id='sgTitleNode']");
        textBaseParentNode = titleNode.parentElement;
        let oldOverflowValue = textBaseParentNode.style.overflow;
        textBaseParentNode.style.overflow = "hidden";
        singleNodeHeight = parseFloat(window.getComputedStyle(textBaseParentNode).height);
        if (textBaseParentNode.style.height == "auto") {
            textBaseParentNode.style.height = textBaseParentNode.style.maxHeight;
            singleNodeHeight = parseFloat(window.getComputedStyle(textBaseParentNode).height);
            textBaseParentNode.style.height = "auto";
        }
        textBaseParentNode.style.overflow = oldOverflowValue;
    }
    if (textBaseParentNode) {
        if (textNode.id.includes("sgTitleLabelNode")) {
            let labelStyle = window.getComputedStyle(textNode);
            let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
            textNode.style.maxHeight = parseFloat(labelStyle.lineHeight) + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
            textNode.parentElement.style.maxHeight = textNode.style.maxHeight;
        } else {
            textNode.style.removeProperty("max-height");
            if (supportParent != true) textNode.parentElement.style.removeProperty("max-height");

            let titleNode = textBaseParentNode.querySelector("[id='sgTitleNode']");
            let subTitleNode = textBaseParentNode.querySelector("[id='sgSubTitleNode']");
            let sgTitleLabelNode = textBaseParentNode.querySelector("[id='sgTitleLabelNode']");
            let textInnerParentNode = textBaseParentNode.querySelector("[id='textInnerParentNode']");
            let sgNumberTextNode = textBaseParentNode.querySelector("[id*='sgNumberTextNode']");

            let numberStyle = sgNumberTextNode ? window.getComputedStyle(sgNumberTextNode) : null;
            let numberMargin = numberStyle ? parseFloat(numberStyle.height == "auto" ? 0 : numberStyle.height) + parseFloat(numberStyle.marginTop) + parseFloat(numberStyle.marginBottom) : 0;
            numberMargin = isNaN(numberMargin) ? 0 : numberMargin;

            let textParentStyle = textInnerParentNode ? window.getComputedStyle(textInnerParentNode.parentElement) : null;
            let textParentMargin = textParentStyle ? parseFloat(textParentStyle.marginTop) + parseFloat(textParentStyle.marginBottom) : 0;

            let innerParentStyle = textInnerParentNode ? window.getComputedStyle(textInnerParentNode) : null;
            let innerParentMargin = innerParentStyle ? parseFloat(innerParentStyle.marginTop) + parseFloat(innerParentStyle.marginBottom) : 0;

            let labelParentStyle = sgTitleLabelNode ? window.getComputedStyle(sgTitleLabelNode.parentElement) : null;
            let labelStyle = sgTitleLabelNode ? window.getComputedStyle(sgTitleLabelNode) : null;
            let hasLabel = (sgTitleLabelNode && sgTitleLabelNode.style.display == "none") || !sgTitleLabelNode ? false : true;
            let labelMargin = labelParentStyle ? parseFloat(labelParentStyle.marginTop) + parseFloat(labelParentStyle.marginBottom) : 0;
            labelMargin = hasLabel ? (labelStyle ? parseFloat(labelStyle.marginTop) + parseFloat(labelStyle.marginBottom) : 0) + labelMargin : 0;

            let subTitileParentStyle = subTitleNode ? window.getComputedStyle(subTitleNode.parentElement) : null;
            let subTitileStyle = subTitleNode ? window.getComputedStyle(subTitleNode) : null;
            let hasSubtitle = (subTitleNode && subTitleNode.style.display == "none") || !subTitleNode ? false : true;
            let subTitileMargin = subTitileParentStyle ? parseFloat(subTitileParentStyle.marginTop) + parseFloat(subTitileParentStyle.marginBottom) : 0;
            subTitileMargin = hasSubtitle ? (subTitileStyle ? parseFloat(subTitileStyle.marginTop) + parseFloat(subTitileStyle.marginBottom) : 0) + subTitileMargin : 0;

            let titileParentStyle = titleNode ? window.getComputedStyle(titleNode.parentElement) : null;
            let titileMargin = titileParentStyle ? parseFloat(titileParentStyle.marginTop) + parseFloat(titileParentStyle.marginBottom) : 0;

            let textBaseHeight = parseFloat(singleNodeHeight) > 0 ? parseFloat(singleNodeHeight) : parseFloat(window.getComputedStyle(textBaseParentNode).height);
            if (textBaseParentNode && textBaseParentNode.hasAttribute("fullheight")) textBaseHeight = parseFloat(textBaseParentNode.getAttribute("fullheight"));
            if (window.getComputedStyle(textBaseParentNode).height == "" && textBaseParentNode.style.maxHeight != "" && textBaseParentNode.style.maxHeight.includes("px")) textBaseHeight = parseFloat(textBaseParentNode.style.maxHeight);
            let maxHeight = window.getComputedStyle(textBaseParentNode).maxHeight;
            if (maxHeight != "" && maxHeight != "0px" && !isNaN(parseFloat(maxHeight))) {
                if (maxHeight.includes("px")) textBaseHeight = parseFloat(maxHeight);
                else if (maxHeight.includes("%")) {
                    let oldParentHeight = null;
                    if (textBaseParentNode.parentElement && textBaseParentNode.parentElement.style.height == "auto" && textBaseParentNode.parentElement.hasAttribute("fullheight")) {
                        oldParentHeight = textBaseParentNode.parentElement.style.height;
                        textBaseParentNode.parentElement.style.height = textBaseParentNode.parentElement.getAttribute("fullheight");
                    }
                    let oldParentH = textBaseParentNode.style.height;
                    textBaseParentNode.style.height = textBaseParentNode.style.maxHeight;
                    let hh = parseFloat(window.getComputedStyle(textBaseParentNode).height);
                    if (hh > 0 && !isNaN(hh)) textBaseHeight = hh;
                    textBaseParentNode.style.height = oldParentH;
                    if (oldParentHeight) textBaseParentNode.parentElement.style.height = oldParentHeight;
                }
            }

            //removing margin/padding things on total base height
            let textParentHeight =
                textBaseHeight - (isNaN(labelMargin) ? 0 : labelMargin) - (isNaN(subTitileMargin) ? 0 : subTitileMargin) - (isNaN(titileMargin) ? 0 : titileMargin) - (isNaN(innerParentMargin) ? 0 : innerParentMargin) - (isNaN(textParentMargin) ? 0 : textParentMargin) - (isNaN(numberMargin) ? 0 : numberMargin);
            let titleHeight = titleNode?.scrollHeight > 0 ? titleNode.scrollHeight : !titleNode || titleNode?.offsetHeight == 0 ? 0 : titleNode.style.maxHeight != "" && titleNode.style.display != "none" ? parseFloat(titleNode.style.maxHeight) : window.getComputedStyle(titleNode).height;
            let subTitleHeight = subTitleNode?.scrollHeight > 0 ? subTitleNode.scrollHeight : !subTitleNode || subTitleNode?.offsetHeight == 0 ? 0 : subTitleNode.style.maxHeight != "" && subTitleNode.style.display != "none" ? parseFloat(subTitleNode.style.maxHeight) : window.getComputedStyle(subTitleNode).height;
            let lableHeight = !sgTitleLabelNode || sgTitleLabelNode?.offsetHeight == 0 ? 0 : sgTitleLabelNode.style.maxHeight != "" && sgTitleLabelNode.style.display != "none" ? parseFloat(sgTitleLabelNode.style.maxHeight) : window.getComputedStyle(sgTitleLabelNode).height;
            //calculating total current text height
            let totalTextHeight = parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight);

            let lineHeight = window.getComputedStyle(textNode).lineHeight;
            let fontsize = window.getComputedStyle(textNode).fontSize;
            lineHeight = isNaN(parseFloat(lineHeight)) ? parseFloat(fontsize) * 1.2 : parseFloat(lineHeight);
            let noLines = Math.max(textNode.parentElement.offsetHeight / lineHeight, 1);
            let offDifference = noLines - parseInt(noLines);
            let lines = offDifference > 0.9 ? parseInt(noLines) + 1 : parseInt(noLines);

            //If text height increase total height we have doing fit logic
            if (typeof totalTextHeight == "string") totalTextHeight = parseFloat(totalTextHeight);
            if (typeof textParentHeight == "string") textParentHeight = parseFloat(textParentHeight);
            totalTextHeight = totalTextHeight.toFixed(1);
            textParentHeight = textParentHeight.toFixed(1);
            if (typeof totalTextHeight == "string") totalTextHeight = parseFloat(totalTextHeight);
            if (typeof textParentHeight == "string") textParentHeight = parseFloat(textParentHeight);
            let commonRemainingHeight = 0;
            if (totalTextHeight > textParentHeight) {
                // if (isStart == true) {
                //     let extraValues = totalTextHeight - textParentHeight;
                //     if (extraValues >= 0) {
                //         this.loop(lines, lineHeight, textNode, textParentHeight, titleNode, subTitleNode, sgTitleLabelNode);
                //     } else {
                //         textNode.style.removeProperty("max-height");
                //         if (supportParent != true) textNode.parentElement.style.removeProperty("max-height");
                //     }
                // } else {
                let targetNodeHeight =
                    textNode.id == "sgTitleNode"
                        ? parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                        : textNode.id == "sgSubTitleNode"
                        ? parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                        : parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight);
                let remainingHeight = textParentHeight - targetNodeHeight;
                commonRemainingHeight = remainingHeight;
                if (lines == 1) remainingHeight = lineHeight;

                let linesFinal = remainingHeight / lineHeight;
                let offDiff = linesFinal - parseInt(linesFinal);
                linesFinal = offDiff > 0.9 ? parseInt(linesFinal) + 1 : parseInt(linesFinal);

                let heightFinal = linesFinal * lineHeight;
                heightFinal = heightFinal == 0 ? lineHeight : heightFinal;

                textNode.style.maxHeight = heightFinal + "px";
                textNode.parentElement.style.maxHeight = heightFinal + "px";
                // }
            } else {
                let targetNodeHeight = textNode.id.includes("sgTitleNode")
                    ? parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : textNode.id.includes("sgSubTitleNode")
                    ? parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight);
                let remainingHeight = textParentHeight - targetNodeHeight;

                commonRemainingHeight = remainingHeight;
            }

            DiagramResizeUtils.commonFontResize(totalTextHeight, textParentHeight, commonRemainingHeight, textNode, textNode.parentElement, this.objDataToSG.fontClassLists, true);

            this.onTextUpdate(textNode);
        }
    }
};

GenericCarouselImagestack.prototype.loop = function (lines, lineHeight, textNode, textParentHeight, titleNode, subTitleNode, sgTitleLabelNode) {
    //Loop and fitting the text inside max avaiable height
    lines = lines - 1;
    if (lines == 0) return;
    let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
    let newHeight = lines * lineHeight + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom);
    textNode.style.maxHeight = newHeight + "px";
    // textNode.parentElement.style.maxHeight = newHeight + "px";

    let titleHeight = !titleNode ? 0 : titleNode.style.maxHeight != "" && titleNode.style.display != "none" ? parseFloat(titleNode.style.maxHeight) : window.getComputedStyle(titleNode).height;
    let subTitleHeight = !subTitleNode ? 0 : subTitleNode.style.maxHeight != "" && subTitleNode.style.display != "none" ? parseFloat(subTitleNode.style.maxHeight) : window.getComputedStyle(subTitleNode).height;
    let lableHeight = !sgTitleLabelNode ? 0 : sgTitleLabelNode.style.maxHeight != "" && sgTitleLabelNode.style.display != "none" ? parseFloat(sgTitleLabelNode.style.maxHeight) : window.getComputedStyle(sgTitleLabelNode).height;
    let totalTextHeight = parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight);
    if (textParentHeight < totalTextHeight) this.loop(lines, lineHeight, textNode, textParentHeight, titleNode, subTitleNode, sgTitleLabelNode);
};

GenericCarouselImagestack.prototype.onTextUpdate = function (textNode) {
    if (textNode.parentElement.offsetHeight <= textNode.offsetHeight) {
        let lineHeight = window.getComputedStyle(textNode).lineHeight;
        let fontsize = window.getComputedStyle(textNode).fontSize;
        lineHeight = isNaN(parseFloat(lineHeight)) ? parseFloat(fontsize) * 1.2 : parseFloat(lineHeight);
        let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
        let noLines = Math.max(textNode.parentElement.offsetHeight / lineHeight, 1);
        let offDifference = noLines - parseInt(noLines);
        let lines = offDifference > 0.9 ? parseInt(noLines) + 1 : parseInt(noLines);
        textNode.style.maxHeight = lines * lineHeight + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
        textNode.style.overflow = "hidden";
        textNode.parentElement.style.removeProperty("max-height");
    }
};

GenericCarouselImagestack.prototype.updateHeightForText = function (assetParent) {
    let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData && this.metaData ? this.metaData : null;
    if (metaDataBase && (metaDataBase.properties || metaDataBase.introproperties)) {
        let propData = assetParent.classList.contains("introSlide") && metaDataBase.introproperties ? metaDataBase.introproperties : metaDataBase.properties;
        let property = propData.text;
        if (property && property.maxheight) {
            let textBaseParentNode = assetParent.querySelector("[id*='textBaseParentNode']");
            let titleLabelTextParent = assetParent.querySelector("[id='titleLabelTextParent']");
            let sgTitleLabelNode = assetParent.querySelector("[id='sgTitleLabelNode']");

            let textParent = textBaseParentNode ? textBaseParentNode.parentElement : null;
            let remainingHeight = 0;
            if (textParent) {
                let parentHeight = parseFloat(window.getComputedStyle(textParent).height);
                if (textParent.hasAttribute("fullheight")) parentHeight = parseFloat(textParent.getAttribute("fullheight"));
                if (!isNaN(parentHeight) && parentHeight > 0) return;
                if (textBaseParentNode) textBaseParentNode.style.display = "none";
                if (textParent) {
                    let mainParentDisplay = textParent.parentElement.style.display;
                    textParent.parentElement.style.removeProperty("display");
                    let currentHeight = parseFloat(window.getComputedStyle(textParent).height);
                    textParent.parentElement.style.display = mainParentDisplay;

                    remainingHeight = parentHeight - currentHeight;
                }
            }
            let titleTextParent = assetParent.querySelector("[id='titleTextParent']");
            let sgTitleNode = assetParent.querySelector("[id='sgTitleNode']");

            let subTitleTextParent = assetParent.querySelector("[id='subTitleTextParent']");
            let sgSubTitleNode = assetParent.querySelector("[id='sgSubTitleNode']");

            if (titleLabelTextParent) titleLabelTextParent.style.removeProperty("max-height");
            if (sgTitleLabelNode) sgTitleLabelNode.style.removeProperty("max-height");
            if (titleTextParent) titleTextParent.style.removeProperty("max-height");
            if (sgTitleNode) sgTitleNode.style.removeProperty("max-height");
            if (subTitleTextParent) subTitleTextParent.style.removeProperty("max-height");
            if (sgSubTitleNode) sgSubTitleNode.style.removeProperty("max-height");

            if (textBaseParentNode && remainingHeight != 0) {
                textBaseParentNode.style.maxHeight = remainingHeight + "px";
                textBaseParentNode.style.removeProperty("display");
            }
        }
    }
};
//Set slide type
GenericCarouselImagestack.prototype.setSlideType = function (type) {
    this.sgSlideType = type;
};

GenericCarouselImagestack.prototype.specialGraphicsCreationComplete = function () {
    //Check and update font class depends on number of lines
    let arrTitleNodes = this.sgParent.querySelectorAll("[id*='sgTitleNode']");
    if (this.isPresent != true)
        for (let a = 0; a < arrTitleNodes.length; a++) {
            if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(arrTitleNodes[a]);
        }

    if (this.isPlayAnimation == false && this.isPresent != true) this.eventManager.dispatch("positionchangecallback", (this.isFromLastSlide == true ? this.sgData.length : 1) - 1);
    if (this.isPresent != true) {
        // let slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
        // if (slideDomContentGroup) this.changeVariation(slideDomContentGroup);
        //Updating image positions for all images
        this.specialGraphicsUtils.updateImagePositions(this.sgParent);

        let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
        let indexValue = assetParent0.classList.contains("introSlide") && assetParent0.style.display != "none" ? this.currentNodeIndex : 0;
        this.floaterNavigation(indexValue);
        this.setTargetIndex();

        //Text Element positioning after all text's props change
        this.rePositioningTextElement();
    }
    SGBaseClass.prototype.specialGraphicsCreationComplete.call(this);
};

//Assets load complete
GenericCarouselImagestack.prototype.assetsLoadComplete = function (responseData) {
    for (let i = 0; i < responseData.length; i++) {
        if (responseData[i].id.includes("svgdata")) name = "Illustration";
        if (name == "Illustration" && this.sgParent.querySelectorAll("[id='svgElementDiv']").length > 0) {
            let arrSvgParent = this.sgParent.querySelectorAll("[id='svgElementDiv']");
            for (let a = 0; a < arrSvgParent.length; a++) {
                arrSvgParent[a].innerHTML = responseData[i].data;
                this.applySVGData(arrSvgParent[a]);
            }
        }
    }
};
GenericCarouselImagestack.prototype.applySVGData = function (svgChild) {
    if (svgChild.getElementsByTagName("svg").length > 0) {
        let svgDOM = svgChild.getElementsByTagName("svg")[0];
        svgDOM.style.width = "100%";
        svgDOM.style.height = "100%";
    }
};
GenericCarouselImagestack.prototype.createNestedNodes = function (subNodes, nodeParentToInsert, currentIndex = 0) {
    for (let j = 0; j < subNodes.length; j++) {
        let nodeObj = subNodes[j];
        let nodeParent = this.createNodes(nodeObj, nodeParentToInsert, currentIndex);
        if (nodeObj.subNodes && nodeParent) {
            this.createNestedNodes(nodeObj.subNodes, nodeParent, currentIndex);
        }
    }
};
GenericCarouselImagestack.prototype.createNodes = function (nodeObj, nodeParent, currentIndex = 0) {
    let name = nodeObj.name;
    switch (name) {
        case "contentMainParent":
        case "contentNode":
        case "contentNode1":
        case "contentNode2":
        case "contentNode3":
        case "contentNode4":
        case "contentNode5":
        case "contentNode6":
        case "secContentNode":
        case "secContentNode1":
        case "secContentNode2":
        case "secContentNode3":
        case "secContentNode4":
        case "secContentNode5":
        case "secContentNode6":
            return this.createContentNode(nodeParent, nodeObj, name);
        case "img":
            this.createImageNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "tit":
        case "text":
            this.createTitleNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "title":
            this.createSingleTitleNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "subtitle":
            this.createSingleSubTitleNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "label":
            this.createSingleLabelNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "num":
            this.createNumberNode(nodeParent, currentIndex);
            break;
        case "bgimage1":
            this.createBgImage(1, currentIndex);
            break;
        case "bgimage2":
            this.createBgImage(2, currentIndex);
            break;
        case "presetimage":
            this.createPresetImage(currentIndex);
            break;
        case "pointimage":
        case "pointimage1":
        case "pointimage2":
        case "pointimage3":
        case "pointimage4":
        case "pointimage5":
        case "pointimage6":
        case "pointimage7":
        case "pointimage8":
        case "pointimage9":
        case "pointimage10":
            this.createPointImage(nodeParent, currentIndex);
            break;
        case "duplicateimage":
            this.createDuplicateImage(currentIndex);
            break;
        case "shape1":
        case "shape2":
        case "shape3":
        case "shape4":
        case "shape5":
            let propertyValue = null;
            let propName = currentIndex == 0 ? "introproperties" : "properties";
            let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData && this.metaData ? this.metaData : null;
            if (metaDataBase && metaDataBase[this.deviceModel]) metaDataBase = metaDataBase[this.deviceModel];
            if (metaDataBase && metaDataBase[propName] && metaDataBase[propName] && metaDataBase[propName][name]) propertyValue = metaDataBase[propName][name];
            this.createShapes(nodeParent, name, propertyValue, currentIndex);
            break;
        case "placeholderimage":
            this.createPlaceHolder(nodeParent, currentIndex);
            break;
        default:
            break;
    }
};
GenericCarouselImagestack.prototype.getProps = function () {
    //Get slide properties
    let props = null;
    let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData && this.metaData ? this.metaData : null;
    let secondaryProp = null;
    if (metaDataBase && metaDataBase.properties) secondaryProp = metaDataBase.properties;
    if (metaDataBase && metaDataBase[this.deviceModel]) metaDataBase = metaDataBase[this.deviceModel];
    if (metaDataBase && metaDataBase.properties) props = metaDataBase.properties;
    let returnVal = props ? props : secondaryProp;
    if (returnVal && ((returnVal.text && returnVal.text.textstyle) || (returnVal.number && returnVal.number.numberstyle) || (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle))) {
        let textPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.textproperties ? this.objDataToSG.sgMoodsData.textproperties : null;
        let numberPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.numberproperties ? this.objDataToSG.sgMoodsData.numberproperties : null;
        let placeholderPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.placeholderimageproperties ? this.objDataToSG.sgMoodsData.placeholderimageproperties : null;

        if (returnVal.text && returnVal.text.textstyle && textPropFromMood && textPropFromMood[returnVal.text.textstyle]) {
            let newValue = textPropFromMood[returnVal.text.textstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.text[key] = newValue[key];
            });
            delete returnVal.text.textstyle;
        }
        if (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle && placeholderPropFromMood && placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle]) {
            let newValue = placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.placeholderimage[key] = newValue[key];
            });
            delete returnVal.placeholderimage.placeholderimagestyle;
        }
        if (returnVal.number && returnVal.number.numberstyle && numberPropFromMood && numberPropFromMood[returnVal.number.numberstyle]) {
            let newValue = numberPropFromMood[returnVal.number.numberstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.number[key] = newValue[key];
            });
            delete returnVal.number.numberstyle;
        }
    }
    return returnVal;
};
GenericCarouselImagestack.prototype.getIntroProps = function () {
    //Get intro slide properties
    let props = null;
    let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData && this.metaData ? this.metaData : null;
    let secondaryProp = null;
    if (metaDataBase && metaDataBase.introproperties) secondaryProp = metaDataBase.introproperties;
    if (metaDataBase && metaDataBase[this.deviceModel]) metaDataBase = metaDataBase[this.deviceModel];
    if (metaDataBase && metaDataBase.introproperties) props = metaDataBase.introproperties;
    let returnVal = props ? props : secondaryProp ? secondaryProp : this.getProps();
    if (returnVal && ((returnVal.text && returnVal.text.textstyle) || (returnVal.number && returnVal.number.numberstyle) || (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle))) {
        let textPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.textproperties ? this.objDataToSG.sgMoodsData.textproperties : null;
        let numberPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.numberproperties ? this.objDataToSG.sgMoodsData.numberproperties : null;
        let placeholderPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.placeholderimageproperties ? this.objDataToSG.sgMoodsData.placeholderimageproperties : null;

        if (returnVal.text && returnVal.text.textstyle && textPropFromMood && textPropFromMood[returnVal.text.textstyle]) {
            let newValue = textPropFromMood[returnVal.text.textstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.text[key] = newValue[key];
            });
            delete returnVal.text.textstyle;
        }
        if (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle && placeholderPropFromMood && placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle]) {
            let newValue = placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.placeholderimage[key] = newValue[key];
            });
            delete returnVal.placeholderimage.placeholderimagestyle;
        }
        if (returnVal.number && returnVal.number.numberstyle && numberPropFromMood && numberPropFromMood[returnVal.number.numberstyle]) {
            let newValue = numberPropFromMood[returnVal.number.numberstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.number[key] = newValue[key];
            });
            delete returnVal.number.numberstyle;
        }
    }
    return returnVal;
};
GenericCarouselImagestack.prototype.createContentNode = function (parent, props, id) {
    if (id == "contentMainParent" && parent.querySelector("[id='contentMainParent']")) parent.querySelector("[id='contentMainParent']").parentElement.removeChild(parent.querySelector("[id='contentMainParent']"));
    let nodeParent = document.createElement("div");
    nodeParent.className = id;
    nodeParent.style.pointerEvents = "none";
    nodeParent.setAttribute("id", id);
    parent.appendChild(nodeParent);
    nodeParent.style.display = "flex";
    this.setTextType(nodeParent);

    if (props && props.class) {
        nodeParent.className = id + "  " + props.class;
        if (nodeParent.classList.contains("valign_s") || nodeParent.classList.contains("valign_c") || nodeParent.classList.contains("valign_e")) {
            let direction = window.getComputedStyle(nodeParent).flexDirection;
            if (direction == "row") nodeParent.style.alignItems = nodeParent.classList.contains("valign_c") ? "center" : nodeParent.classList.contains("valign_e") ? "flex-end" : "flex-start";
            else nodeParent.style.justifyContent = nodeParent.classList.contains("valign_c") ? "center" : nodeParent.classList.contains("valign_e") ? "flex-end" : "flex-start";
        }
        if (nodeParent.classList.contains("halign_s") || nodeParent.classList.contains("halign_c") || nodeParent.classList.contains("halign_e")) {
            let direction = window.getComputedStyle(nodeParent).flexDirection;
            if (direction == "row") nodeParent.style.justifyContent = nodeParent.classList.contains("halign_c") ? "center" : nodeParent.classList.contains("halign_e") ? "flex-end" : "flex-start";
            else nodeParent.style.alignItems = nodeParent.classList.contains("halign_c") ? "center" : nodeParent.classList.contains("halign_e") ? "flex-end" : "flex-start";
        }
    } else nodeParent.style.display = "block";
    if (props.positionvalue) nodeParent.style.position = props.positionvalue;
    if (props.zorder) nodeParent.style.zIndex = props.zorder;
    if (props.order) nodeParent.style.order = props.order;
    if (props.flexvalue) nodeParent.style.flex = props.flexvalue;
    if (props.position && props.position.split(",").length == 4) this.specialgraphicsPropertyUtils.updatePosition(nodeParent, props.position);

    if (props.padding) this.specialgraphicsPropertyUtils.updatePadding(props.padding, nodeParent, true);
    if (props.margin) this.specialgraphicsPropertyUtils.updateMargin(props.margin, nodeParent, true);
    if (props.maxwidth) {
        // nodeParent.style.maxWidth = props.maxwidth + (props.maxwidth.includes("px") || props.maxwidth.includes("%") ? "" : "px");
        nodeParent.style.width = props.maxwidth + (props.maxwidth.includes("px") || props.maxwidth.includes("%") ? "" : "px");
        nodeParent.setAttribute("fullwidth", window.getComputedStyle(nodeParent).width);
    }
    if (props.maxheight) {
        let oldH = null;
        if (nodeParent.parentElement.hasAttribute("fullheight")) {
            oldH = nodeParent.parentElement.style.height;
            nodeParent.parentElement.style.height = nodeParent.parentElement.getAttribute("fullheight");
        }

        let oldHeight = nodeParent.style.height;
        nodeParent.style.height = props.maxheight + (props.maxheight.includes("px") || props.maxheight.includes("%") ? "" : "px");
        nodeParent.style.maxHeight = props.maxheight + (props.maxheight.includes("px") || props.maxheight.includes("%") ? "" : "px");
        let h = window.getComputedStyle(nodeParent).height;
        nodeParent.style.height = oldHeight;
        nodeParent.setAttribute("fullheight", h);

        if (oldH && nodeParent.parentElement.hasAttribute("fullheight")) nodeParent.parentElement.style.height = oldH;
    }
    return nodeParent;
};
GenericCarouselImagestack.prototype.createPresetImage = function (currentIndex) {
    //Create preset image
    let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (!deviceImageParentNode) {
        deviceImageParentNode = document.createElement("div");
        deviceImageParentNode.id = "deviceImageParentNode";
        deviceImageParentNode.className = "deviceImageParentNode";
        this.sgParent.insertBefore(deviceImageParentNode, assetParent0);
    }

    this.createPresetImageNode(deviceImageParentNode);
    this.applyPresetImgeProperty(currentIndex);
};
GenericCarouselImagestack.prototype.applyPresetImgeProperty = function (currentIndex) {
    //Apply preset image properties
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props && props && props.presetimage && this.sgParent.querySelector("[id='presetImageParent']")) {
        let presetImageParent = this.sgParent.querySelector("[id='presetImageParent']");
        let presetImageNode = this.sgParent.querySelector("[id='presetImageNode']");
        if (props.presetimage.positionvalue && presetImageParent) presetImageParent.style.position = props.presetimage.positionvalue;
        if (props.presetimage.imageurl && presetImageNode) presetImageNode.src = this.appStaticURL + props.presetimage.imageurl;
        this.specialgraphicsPropertyUtils.applyImageBaseProps(props.presetimage, deviceImageParentNode, presetImageParent, "presetimage");
    }
};
GenericCarouselImagestack.prototype.createBgImage = function (imageIndex = 1, currentIndex) {
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let type = "img";
    let src = "";
    let bgImageProperty = null;
    if (props && props && props["bgimage" + imageIndex]) bgImageProperty = props["bgimage" + imageIndex];
    if (bgImageProperty && bgImageProperty.type && bgImageProperty.type == "video") type = "video";
    if (bgImageProperty && bgImageProperty.imageurl) src = bgImageProperty.imageurl;

    let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
    // let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let oldImage = this.sgParent.querySelector("[id*='bgImage" + (imageIndex == 1 ? "" : imageIndex) + "Node']");
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (!oldImage) {
        if (!deviceImageParentNode) {
            deviceImageParentNode = document.createElement("div");
            deviceImageParentNode.id = "deviceImageParentNode";
            deviceImageParentNode.className = "deviceImageParentNode";
            this.sgParent.insertBefore(deviceImageParentNode, assetParent0);
        }

        oldImage = this.createBgImageNode(deviceImageParentNode, (imageIndex == 1 ? "" : imageIndex) + "Node", type, src);
        oldImage.setAttribute("data-fit", "false");
    }
    this.applyBgImageProperty(imageIndex, bgImageProperty, currentIndex);
};
GenericCarouselImagestack.prototype.applyBgImageProperty = function (imageIndex, bgImageProperty, currentIndex) {
    if (!bgImageProperty) {
        let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
        if (props && props && props["bgimage" + imageIndex]) bgImageProperty = props["bgimage" + imageIndex];
    }
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let oldImage = this.sgParent.querySelector("[id*='bgImage" + (imageIndex == 1 ? "" : imageIndex) + "Node']");
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (bgImageProperty && oldImage) {
        let bgImage = oldImage;
        if (bgImageProperty.positionvalue && bgImage) bgImage.style.position = bgImageProperty.positionvalue;
        if (bgImageProperty.imageurl && bgImage) bgImage.src = this.appStaticURL + bgImageProperty.imageurl;
        this.specialgraphicsPropertyUtils.applyImageBaseProps(bgImageProperty, deviceImageParentNode, bgImage, "--bg");

        bgImage.parentElement.style.zIndex = bgImage.style.zIndex;
        if (bgImageProperty.contrast && bgImageProperty.contrast == "fullbg") {
            if (bgImage) {
                bgImage.setAttribute("contrast", "fullbg");
                this.eventManager.dispatch("applyImageContrast", bgImage, assetParent);
            }
        } else if (bgImageProperty.contrast && bgImageProperty.contrast == "halfbg") {
            if (bgImage) {
                bgImage.setAttribute("contrast", "halfbg");
                this.eventManager.dispatch("applyImageContrast", bgImage, assetParent, true);
            }
        } else if (this.slideContent) {
            this.slideContent.classList.remove("fixedlightText");
            this.slideContent.classList.remove("fixeddarkText");
        }
        if (bgImageProperty.position) {
            let arrPosition = bgImageProperty.position.split(",");
            if (arrPosition.length >= 4 && deviceImageParentNode) {
                let bg = "--bg" + (imageIndex == 1 ? "" : "2");
                deviceImageParentNode.style.setProperty(bg + "Left", arrPosition[0] + (arrPosition[0].includes("px") || arrPosition[0].includes("%") || arrPosition[0].includes("auto") ? "" : "px"));
                deviceImageParentNode.style.setProperty(bg + "Top", arrPosition[1] + (arrPosition[1].includes("px") || arrPosition[1].includes("%") || arrPosition[1].includes("auto") ? "" : "px"));
                deviceImageParentNode.style.setProperty(bg + "Width", arrPosition[2] + (arrPosition[2].includes("px") || arrPosition[2].includes("%") || arrPosition[2].includes("auto") ? "" : "px"));
                deviceImageParentNode.style.setProperty(bg + "Height", arrPosition[3] + (arrPosition[3].includes("px") || arrPosition[3].includes("%") || arrPosition[3].includes("auto") ? "" : "px"));
            }
        }
    }
};
GenericCarouselImagestack.prototype.createDuplicateImage = function (currentIndex) {
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    if (props) this.specialgraphicsPropertyUtils.applyDuplicateImageProperties(props, assetParent, currentIndex, true);
};
GenericCarouselImagestack.prototype.createPointImage = function (parent, currentIndex) {
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let nodes = this.sgParent.querySelectorAll("[id*='pointImageParent']");
    if (props && props && currentIndex != 0 && nodes.length == 0 && this.sgData.length - 1 == currentIndex) {
        let arrAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
        for (let a = 1; a < arrAssetParent.length; a++) {
            let innerParent = arrAssetParent[a].querySelector("[id='" + parent.id + "']");
            this.createPointImageNode(innerParent, a);
        }

        for (let a = 1; a < arrAssetParent.length; a++) {
            let imageProperty = props.pointimage;
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["pointimage" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((a - 1) % loopIndex) + 1;
                imageProperty = props["pointimage" + ind];
            }
            let pointImageParentNode = arrAssetParent[a].querySelector("[id*='pointImageParent']");
            if (pointImageParentNode && imageProperty.imageurl) {
                let pointImageNode = pointImageParentNode.querySelector("[id*='pointImageNode']");
                pointImageNode.src = this.appStaticURL + imageProperty.imageurl;
                pointImageNode.setAttribute("data-fit", "false");
                this.specialgraphicsPropertyUtils.applyImageBaseProps(imageProperty, assetParent, pointImageParentNode, "pointimage");
                if (imageProperty.positionvalue) arrAssetParent[a].style.setProperty("--pointImagePosition", imageProperty.positionvalue);
            }
        }
    }
};
GenericCarouselImagestack.prototype.createNumberNode = function (parent, currentIndex) {
    //number
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let numberContent = this.objDataToSG && this.objDataToSG.numberFormat ? this.specialGraphicsUtils.getSeqMoodStyle(this.objDataToSG.numberFormat, currentIndex) : null;
    if (!assetParent.classList.contains("introSlide")) this.createNumberTextNode(parent, currentIndex, numberContent);

    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props && props) {
        let numberProperty = props.number;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["number" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                numberProperty = props["number" + ind];
            }
        }
        if (numberProperty) {
            let covernumber = assetParent.querySelector("[id*='sgNumberTextNode']");
            let sgNumberTextParent = assetParent.querySelector("[id='sgNumberTextParent']");
            if (numberProperty.positionvalue && covernumber) {
                covernumber.style.position = numberProperty.positionvalue;
                if (sgNumberTextParent) sgNumberTextParent.style.position = numberProperty.positionvalue;
            }
            if (numberProperty.line && (numberProperty.line == "true") | (numberProperty.line == true) && covernumber) covernumber.parentElement.classList.add("numberline");
            let textAlign = null;
            if (numberProperty.halign && (covernumber || sgNumberTextParent)) {
                let hAlign = numberProperty.halign == "right" || numberProperty.halign == "end" ? "flex-end" : numberProperty.halign == "center" || numberProperty.valign == "middle" ? "center" : "flex-start";
                // covernumber.style.alignSelf = hAlign;
                covernumber.style.justifyContent = hAlign;
                textAlign = hAlign == "flex-end" ? "end" : hAlign == "center" ? "center" : "start";
            }
            if (numberProperty.valign && (covernumber || sgNumberTextParent)) {
                let vAlign = numberProperty.valign == "bottom" || numberProperty.valign == "end" ? "flex-end" : numberProperty.valign == "center" || numberProperty.valign == "middle" ? "center" : "flex-start";
                if (sgNumberTextParent) sgNumberTextParent.style.alignItems = vAlign;
                else covernumber.style.alignItems = vAlign;
            }
            this.specialgraphicsPropertyUtils.applyNumberProperties(props, covernumber, assetParent, 0, true);
            let node = covernumber;
            if (numberProperty.linecount && node) {
                node.setAttribute("data-linecount", numberProperty.linecount);
                this.specialGraphicsUtils.doFontFitForCss(node, this.sgParent);
            }
            if (numberProperty.rotate && sgNumberTextParent) {
                let lineHeight = parseFloat(window.getComputedStyle(covernumber)["line-height"]);
                lineHeight = isNaN(lineHeight) ? "40" : lineHeight;
                covernumber.style.minWidth = lineHeight + "px";
                covernumber.classList.add("covernumberRotation");
                covernumber.setAttribute("rotatednode", "true");
                covernumber.style.justifyContent = "flex-end";
                if (numberProperty.rotate.includes("-90")) covernumber.style.setProperty("--rotateTextRotation", "180deg");
                if (covernumber && textAlign) covernumber.style.setProperty("--rotateTextAlign", textAlign);
                this.specialGraphicsUtils.doFontFitForCss(covernumber, this.sgParent, null, null, null, true);
            }
            if (numberProperty.prefix && node) {
                node.setAttribute("prefix", numberProperty.prefix);
                node.innerText.replace(numberProperty.prefix, "");
                node.innerText = numberProperty.prefix + " " + node.innerText;
            }
            if (numberProperty.suffix && node) {
                node.setAttribute("suffix", numberProperty.suffix);
                node.innerText.replace(numberProperty.suffix, "");
                node.innerText = node.innerText + " " + numberProperty.suffix;
            }
            this.applyContrastToText(node, numberProperty);
        }
    }
};
GenericCarouselImagestack.prototype.createTitleNode = function (parent, flexValue = "", currentIndex) {
    //Text Nodes - "tit"
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let textInnerParent = this.createTextBase(parent, currentIndex);
    let textBaseParent = assetParent.querySelector("[id*='textBaseParentNode']");
    if (textBaseParent) {
        let zOrderValue = 0;
        let textZIndex = parseFloat(window.getComputedStyle(textBaseParent).zIndex);
        let parentZIndex = parseFloat(window.getComputedStyle(parent).zIndex);
        if (!isNaN(parentZIndex) && parentZIndex > 0) zOrderValue = parentZIndex;
        if (!isNaN(textZIndex) && textZIndex > 0) zOrderValue = zOrderValue + textZIndex;

        textBaseParent.style.zIndex = zOrderValue;
    }
    if (flexValue && flexValue != "") textBaseParent.style.flex = flexValue;
    this.createTitleSet(textInnerParent, currentIndex, assetParent);
    this.applyTextProperty(currentIndex, textBaseParent);
    if (this.objDataToSG && this.objDataToSG.theme && this.objDataToSG.theme) {
        let title = textInnerParent.querySelector("[id*='sgTitleNode']");
        let subTitle = textInnerParent.querySelector("[id*='sgSubTitleNode']");
        let label = textInnerParent.querySelector("[id*='sgTitleLabelNode']");
        let titleColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "title");
        let subtitleColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "subtitle");
        let labelColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "label");
        if (titleColor && title && !title.hasAttribute("data-supportcontrast")) {
            title.style.setProperty("color", titleColor);
            title.setAttribute("data-color", titleColor);
        }
        if (subtitleColor && subTitle && !subTitle.hasAttribute("data-supportcontrast")) {
            subTitle.style.setProperty("color", subtitleColor);
            subTitle.setAttribute("data-color", subtitleColor);
        }
        if (labelColor && label && !label.hasAttribute("data-supportcontrast")) {
            label.style.setProperty("color", labelColor);
            label.setAttribute("data-color", labelColor);
        }
    }
};
GenericCarouselImagestack.prototype.applyTextProperty = function (currentIndex, textBaseParent) {
    //Applying Text Property
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    if (props && assetParent) {
        let textProperty = props.text;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["text" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                textProperty = props["text" + ind];
            }
        }

        let defaultProp = null;
        let textPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.textproperties ? this.objDataToSG.sgMoodsData.textproperties : null;
        if (textPropFromMood) {
            const keys = Object.keys(textPropFromMood);
            keys.forEach((key) => {
                let element = textPropFromMood[key];
                if (element && element.default && (element.default == "true" || element.default == true)) defaultProp = element;
            });
        }
        let newTextProperty = !textProperty ? defaultProp : textProperty;
        if (newTextProperty) {
            this.specialgraphicsPropertyUtils.applyTextProperties(newTextProperty, assetParent, currentIndex, true, true);
            let isSupportTextPosition = newTextProperty.positionchange && (newTextProperty.positionchange == "true" || newTextProperty.positionchange == true) ? true : false;
            //Applying text position
            let textPosition = this.sgData[currentIndex] && this.sgData[currentIndex]["titletextposition"] ? this.sgData[currentIndex]["titletextposition"] : newTextProperty && newTextProperty.defaulttextposition ? newTextProperty.defaulttextposition : "sgMM";
            if (textPosition && textPosition != "" && textBaseParent && isSupportTextPosition) {
                this.specialGraphicsUtils.removeTextPositionClass(textBaseParent.parentElement);
                textBaseParent.parentElement.classList.add("sg" + textPosition.replace("sg", ""));
                assetParent.setAttribute("textPosition", textPosition);
            }
        }
    }
};
GenericCarouselImagestack.prototype.createSingleTitleNode = function (parent, flexValue = "", currentIndex) {
    //Text Nodes - title only
    let textParent = this.createSingleTitle(parent, currentIndex);
    if (flexValue && flexValue != "") textParent.style.flex = flexValue;

    this.applyTitleProperty(currentIndex);
};
GenericCarouselImagestack.prototype.applyTitleProperty = function (currentIndex) {
    //Apply single Title node property
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props && props) {
        let textProperty = props.title;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["title" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                textProperty = props["title" + ind];
            }
        }
        this.applySingleNodeProps(currentIndex, "titleTextParent", "sgTitleNode", textProperty);
    }
};
GenericCarouselImagestack.prototype.createSingleSubTitleNode = function (parent, flexValue = "", currentIndex) {
    //Text Nodes - title only
    let textParent = this.createSingleSubTitle(parent, currentIndex);
    if (flexValue && flexValue != "") textParent.style.flex = flexValue;

    this.applySubTitleProperty(currentIndex);
};
GenericCarouselImagestack.prototype.applySubTitleProperty = function (currentIndex) {
    //Apply single subtitle node property
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props && props) {
        let textProperty = props.subtitle;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["subtitle" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                textProperty = props["subtitle" + ind];
            }
        }
        this.applySingleNodeProps(currentIndex, "subTitleTextParent", "sgSubTitleNode", textProperty);
    }
};
GenericCarouselImagestack.prototype.createSingleLabelNode = function (parent, flexValue = "", currentIndex) {
    //Text Nodes - title only
    let textParent = this.createSingleLabel(parent, currentIndex);
    if (flexValue && flexValue != "") textParent.style.flex = flexValue;

    this.applyLabelProperty(currentIndex);
};
GenericCarouselImagestack.prototype.applyLabelProperty = function (currentIndex) {
    //Apply single title label proprty
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props && props) {
        let textProperty = props.label;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["label" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                textProperty = props["label" + ind];
            }
        }
        this.applySingleNodeProps(currentIndex, "titleLabelTextParent", "sgTitleLabelNode", textProperty);
    }
};
GenericCarouselImagestack.prototype.createImageNode = function (parent, flexValue = "", currentIndex) {
    //Coverimage - "img"
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let coverParent = this.createCoverImageParent(parent, currentIndex);
    let imageProperty = this.getImageProperty(currentIndex);
    let isSvgSupport = imageProperty?.supportsvg && imageProperty.supportsvg == "false" ? false : true;
    this.createCoverImageNode(coverParent, currentIndex, "generic", isSvgSupport);

    let coverImageParent = assetParent.querySelector("[id*='coverImageParent']");
    if (coverImageParent) {
        if (flexValue && flexValue != "") coverImageParent.style.flex = flexValue;
        let zOrderValue = 0;
        let imageZIndex = parseFloat(window.getComputedStyle(coverImageParent).zIndex);
        let parentZIndex = parseFloat(window.getComputedStyle(parent).zIndex);
        if (!isNaN(parentZIndex) && parentZIndex > 0) zOrderValue = parentZIndex;
        if (!isNaN(imageZIndex) && imageZIndex > 0) zOrderValue = zOrderValue + imageZIndex;

        coverImageParent.style.zIndex = zOrderValue;
    }

    if (imageProperty) {
        let props = imageProperty;
        this.specialgraphicsPropertyUtils.applyImageProperties(props, assetParent, currentIndex, props);
        if (props.positionvalue && coverImageParent) coverImageParent.style.position = props.positionvalue;
        if (props.padding && props.padding.split(",").length == 4 && coverImageParent) this.specialgraphicsPropertyUtils.updateMargin(props.padding, coverImageParent);
        if (coverParent && this.sgData[currentIndex].coverimageprompt) coverParent.setAttribute("data-node-graphic-text", this.sgData[currentIndex].coverimageprompt);
        if (props.contrast && props.contrast == "fullbg") {
            let imageNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            if (imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent);
        } else if (props.contrast && props.contrast == "halfbg") {
            let imageNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            if (imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent, true);
        } else if (this.slideContent) {
            this.slideContent.classList.remove("fixedlightText");
            this.slideContent.classList.remove("fixeddarkText");
        }
        if (props.margin) this.specialgraphicsPropertyUtils.updateMargin(props.margin, coverImageParent);
        if (props.overlayindex && this.applyOverlayToImageSG) {
            let imageNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            if (imageNode && !imageNode.hasAttribute("data-csstext")) this.applyOverlayToImageSG(imageNode, props.overlayindex);
        }
        if (props.overlayname && this.applyOverlayToImageSG) {
            let imageNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            if (imageNode && !imageNode.hasAttribute("data-csstext")) this.applyOverlayToImageSG(imageNode, null, props.overlayname);
        }
        if (props.globalstyle && coverImageParent) {
            coverImageParent.classList.remove(props.globalstyle);
            coverImageParent.classList.add(props.globalstyle);
            coverImageParent.classList.add("clsSingleColorParent");

            let percentValue = window.getComputedStyle(coverImageParent).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
            percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
            let sourceNode = coverImageParent.querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
            if (sourceNode) coverImageParent.style.setProperty("--customNodeBorderImageWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
        }
        if (props.vposition && coverImageParent) {
            let align = props.vposition == "top" || props.vposition == "start" ? "Top" : props.vposition == "center" || props.vposition == "middle" ? "Center" : "Bottom";
            coverImageParent.classList.add("coverAlign" + align);
        }

        // if (props.supportsvg) {
        let arrAssets = [];
        let hasSVG = this.sgData[currentIndex].coverimage.includes(".svg");
        // let path = this.sgData[currentIndex].coverimage.includes(".svg") ? this.sgData[currentIndex].coverimage : "genericassets/illustrations/industry_agnostic/breaker_slide/breaker_slide_1.svg";
        // this.sgData[currentIndex].coverimage = path;

        if (props.supportsvg && props.supportsvg == "false" && hasSVG) {
            this.sgData[currentIndex].coverimage = this.appStaticURL + "genericassets/placeholderimages/coverimage.jpg";
            this.sgParent.removeAttribute("data-svgsupport");
            hasSVG = false;
            if (this.sgParent.parentElement.parentElement) {
                let slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
                if (slideDomContentGroup.getElementsByTagName("coverimage").length > 0) slideDomContentGroup.getElementsByTagName("coverimage")[0].setAttribute("data-src", this.sgData[currentIndex].coverimage);
            }
        }

        if (hasSVG == true) {
            arrAssets.push({ url: this.sgData[currentIndex].coverimage, id: "svgdata", type: "SVG", parent: coverImageParent });
            this.arrCommonAssets.push({ array: arrAssets, callback: this.assetsLoadComplete });
        }

        let svgElementDiv = assetParent.querySelector("[id='svgElementDiv']");
        let coverimage = assetParent.querySelector("[data-target-id='coverimage']");
        if (svgElementDiv && coverimage) {
            svgElementDiv.style.display = hasSVG ? "flex" : "none";
            coverimage.style.display = hasSVG ? "none" : "flex";
        }
        // } else if (this.sgData[currentIndex].coverimage.includes(".svg")) {
        //     this.sgData[currentIndex].coverimage = this.appStaticURL + "genericassets/placeholderimages/coverimage.jpg";
        //     let svgElementDiv = this.sgParent.querySelector("[id='svgElementDiv']");
        //     let coverimage = this.sgParent.querySelector("[data-target-id='coverimage']");
        //     if (svgElementDiv) svgElementDiv.style.display = "none";
        //     if (coverimage) {
        //         coverimage.style.display = "block";
        //         coverimage.src = this.sgData[currentIndex].coverimage;
        //     }
        // }
        if (props.imageurl && coverImageParent) {
            let coverimage = coverImageParent.querySelector("[data-target-id='coverimage']");
            coverimage.src = this.appStaticURL + props.imageurl;
            this.specialGraphicsUtils.updateImageReSize(coverimage.getAttribute("data-width"), coverimage.getAttribute("data-height"), coverimage);
        }
        if (props.contentBG) {
            let arrAssets = [];
            arrAssets.push({ parent: coverImageParent, type: "svg", url: props.contentBG.value, id: props.contentBG.id });
            // this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
            this.loadAssets(arrAssets, this.svgLoadCallback);
        }
        if (props.resize && props.resize == "enable" && coverImageParent && coverImageParent.querySelector("[data-target-id='coverimage']")) {
            let imgNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            // imgNode.setAttribute("imageresize", "enable");
            // coverImageParent.setAttribute("imageresize", "enable");
            if (this.sgData[currentIndex] && this.sgData[currentIndex].coverimagesize && coverImageParent) {
                //Implement image size change from floter
                // let sizeV = this.sgData[currentIndex].coverimagesize;
                // let multipleValue = sizeV == "small" ? 0.4 : sizeV == "medium" ? 0.7 : sizeV == "large" ? 1 : parseFloat(sizeV);
                let multipleValue = this.specialGraphicsUtils.getImageSizeSML(this.sgData[currentIndex].coverimagesize);
                let largeW = parseFloat(coverImageParent.getAttribute("data-largewidth"));
                let newW = largeW * multipleValue;
                if (newW > 0) coverImageParent.style.width = newW + "px";
            }
        }
        // let captionPosition = this.sgData[currentIndex].coverimagecaptionposition ? this.sgData[currentIndex].coverimagecaptionposition : props.captionposition ? props.captionposition : "bottomleft";
        // if (captionPosition && coverImageParent && coverImageParent.querySelector("[id*='imageCaption']")) {
        //     let imageCaption = coverImageParent.querySelector("[id*='imageCaption']");
        //     let cls =
        //         captionPosition == "topleft" || captionPosition == "captionTL"
        //             ? "captionTL"
        //             : captionPosition == "topright" || captionPosition == "captionTR"
        //             ? "captionTR"
        //             : captionPosition == "bottomright" || captionPosition == "captionBR"
        //             ? "captionBR"
        //             : "captionBL";
        //     imageCaption.classList.remove("captionTL");
        //     imageCaption.classList.remove("captionTR");
        //     imageCaption.classList.remove("captionBL");
        //     imageCaption.classList.remove("captionBR");
        //     imageCaption.classList.add(cls);
        // }
        this.specialGraphicsUtils.setImageCaptionPosition(coverImageParent, currentIndex, this.sgData, props);
    } else if (this.slideContent) {
        this.slideContent.classList.remove("fixedlightText");
        this.slideContent.classList.remove("fixeddarkText");
    }
};

GenericCarouselImagestack.prototype.getImageProperty = function (currentIndex) {
    let mainProps = currentIndex == 0 ? this.getIntroProps() : this.getProps();

    let imageProperty = mainProps && mainProps.image ? mainProps.image : null;
    if (mainProps && mainProps) {
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (mainProps["image" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                imageProperty = mainProps["image" + ind];
            }
        }
    }
    return imageProperty;
};
GenericCarouselImagestack.prototype.applySingleNodeProps = function (currentIndex, textParentId, textNodeId, textProp) {
    this.sgParent.setAttribute("singlenode", "true");
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    if (textProp && assetParent && assetParent.querySelector("[id='" + textParentId + "']")) {
        let sgTextNodeParent = assetParent.querySelector("[id='" + textParentId + "']");
        let sgTextNode = assetParent.querySelector("[id='" + textNodeId + "']");
        sgTextNodeParent.style.pointerEvents = "auto";
        sgTextNodeParent.style.order = "unset";
        if (textProp.position) this.specialgraphicsPropertyUtils.updatePosition(sgTextNodeParent, textProp.position);
        if (textProp.maxwidth) sgTextNodeParent.style.maxWidth = textProp.maxwidth + (textProp.maxwidth.includes("px") || textProp.maxwidth.includes("%") ? "" : "px");
        if (textProp.maxheight) {
            let mh = textProp.maxheight + (textProp.maxheight.includes("px") || textProp.maxheight.includes("%") ? "" : "px");
            sgTextNodeParent.style.maxHeight = mh;
            sgTextNode.setAttribute("data-maxheight", mh);
        }
        if (textProp.positionvalue) sgTextNodeParent.style.position = textProp.positionvalue;
        else sgTextNodeParent.style.position = "relative";
        if (textProp.padding) this.specialgraphicsPropertyUtils.updatePadding(textProp.padding, sgTextNodeParent, true);
        if (textProp.margin) this.specialgraphicsPropertyUtils.updateMargin(textProp.margin, sgTextNodeParent);
        if (textProp.zorder) sgTextNodeParent.style.zIndex = textProp.zorder;
        sgTextNode.classList.remove("titleColorBg");
        sgTextNode.classList.remove("subtitleColorBg");
        sgTextNode.classList.remove("transparentBg");
        if (textProp.support && textProp.support == "parent") {
            sgTextNode.setAttribute("data-support", "parent");
            this.createTextElement(sgTextNodeParent.parentElement);
            sgTextNode.setAttribute("data-parentid", sgTextNodeParent.parentElement.id);
        } else sgTextNode.removeAttribute("data-support");
        if (textProp.color) sgTextNode.classList.add(textProp.color);
        else sgTextNode.classList.add("transparentBg");

        if (textProp.titlecustomcolor) sgTextNode.style.setProperty("color", "rgba(var(--" + textProp.titlecustomcolor + "-color-rgb),1)", "important");
        if (textProp.bgcolor) sgTextNodeParent.style.backgroundColor = "rgba(var(--" + textProp.bgcolor + "-color-rgb),1)";
        if (textProp.bgshadow) sgTextNodeParent.style.boxShadow = textProp.bgshadow;
        if (textProp.contrast) this.applyContrastToText(sgTextNodeParent, textProp);
        if (textProp.halign) {
            let alignValue = textProp.halign == "end" || textProp.halign == "right" ? "flex-end" : textProp.halign == "center" || textProp.halign == "middle" ? "center" : "flex-start";
            let align = textProp.halign == "end" || textProp.halign == "right" ? "end" : textProp.halign == "center" || textProp.halign == "middle" ? "center" : "start";
            assetParent.style.setProperty("--textAlign", align);
            assetParent.style.setProperty("--textJustifyContent", alignValue);
        }
        if (textProp.valign) {
            let alignValue = textProp.valign == "bottom" || textProp.valign == "end" ? "flex-end" : textProp.valign == "center" || textProp.valign == "middle" ? "center" : "flex-start";
            sgTextNodeParent.style.alignItems = alignValue;
        }
        if (textProp.opacity) {
            sgTextNodeParent.style.opacity = textProp.opacity;
            this.specialGraphicsUtils.setOpacityAttribute(sgTextNodeParent);
        }
        if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(sgTextNode);
    }
};
GenericCarouselImagestack.prototype.changeVariation = function (slideDomContentGroup, updateOnlyVariation = false) {
    let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
    this.updateIntroVisibility();
    for (let i = 0; i < assetParents.length; i++) {
        let subTitleNode = assetParents[i].querySelector("[id='sgSubTitleNode']");
        let oldDisplay = subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "";

        this.specialGraphicsUtils.changeVariation(assetParents[i], slideDomContentGroup, i);
        //Updating image positions for all images
        this.specialGraphicsUtils.updateImagePositions(assetParents[i]);

        if (updateOnlyVariation == false) {
            let titleNode = assetParents[i].querySelector("[id='sgTitleNode']");
            let newDisplay = subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "";
            if (titleNode && subTitleNode && newDisplay != oldDisplay && this.fontData.title.length <= 2) {
                let isSubtitleEnabled = window.getComputedStyle(subTitleNode)["display"] == "none" ? false : true;
                let isIntro = assetParents[i].classList.contains("introSlide") == true ? true : false;
                titleNode.classList.remove(this.fontData[(isIntro ? "intro" : "") + "title"]);
                titleNode.classList.remove(this.fontData[(isIntro ? "intro" : "") + "titleNoSubtitle"]);

                this.specialGraphicsUtils.removeAllFontClass(titleNode);

                let fontClass = isSubtitleEnabled == false ? this.fontData[(isIntro ? "intro" : "") + "titleNoSubtitle"] : this.fontData[(isIntro ? "intro" : "") + "title"];
                if (!fontClass) fontClass = isSubtitleEnabled == false ? this.fontData["titleNoSubtitle"] : this.fontData["title"];
                titleNode.classList.add(fontClass);
                titleNode.setAttribute("data-font", fontClass);
                titleNode.style.removeProperty("min-height");
                titleNode.style.removeProperty("max-height");
                titleNode.style.removeProperty("font-size");

                titleNode.setAttribute("defaultsize", parseFloat(window.getComputedStyle(titleNode)["font-size"]));
                if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(titleNode);
                if (titleNode.hasAttribute("user-font-size")) {
                    this.specialGraphicsUtils.removeAllFontClass(titleNode);
                    titleNode.classList.add(titleNode.getAttribute("user-font-size"));
                    // titleNode.style.setProperty("font-size", titleNode.getAttribute("user-font-size") + "px", "important");
                }
                this.specialGraphicsUtils.doCheckMaxHeight(titleNode, this.sgParent);
                this.specialGraphicsUtils.doFontFitForCss(titleNode, this.sgParent);
            }
            this.updateHeightForText(assetParents[i]);
            this.onTextChangeForAllNodes(assetParents[i], i);
            let textInnerParentNode = assetParents[i].querySelector("[id='textInnerParentNode']");
            this.textElementPositioning(assetParents[i], textInnerParentNode, i);
            this.updatenavFloater();
        }
    }
};
GenericCarouselImagestack.prototype.updateIntroVisibility = function (moveToStart = false, index = 0) {
    let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
    if (this.sgParent && this.sgParent.parentElement && this.sgParent.parentElement.parentElement && assetParents.length > 0) {
        let animationDIV = this.sgParent.parentElement.parentElement;
        let showIntro = animationDIV.getAttribute("data-ogdata-finalshow_0")?.split(",")?.includes("intro") ? "true" : "false";
        if (showIntro == "false" && assetParents[0].classList.contains("introSlide")) {
            if (animationDIV.hasAttribute("inlinefloaterchange") && animationDIV.getAttribute("inlinefloaterchange") == "true") {
            } else {
                assetParents[0].style.display = "none";
                this.currentNodeIndex = 2;
                this.floaterNavigation(0);
            }
        } else {
            assetParents[0].style.removeProperty("display");
            if (moveToStart == true) {
                this.currentNodeIndex = index;
                this.floaterNavigation(0);
            }
        }
    }
};
GenericCarouselImagestack.prototype.animatInnerSlide = function (floaterNav = false, animType = "", isAnimationPlaying = false) {
    floaterNav = false;
    let prevNode = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 2) + "']");
    let nextNode = this.sgParent.querySelector("[id='assetParent" + this.currentNodeIndex + "']");
    let next2Node = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex + (animType == "next" ? -3 : 1)) + "']");
    let currentNode = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");

    let easeingValue = "cubic-bezier(0.76, 0, 0.24, 1)";
    let duration = this.isPlayAnimation == false ? 0 : 1.2;

    let props = this.getProps();
    let alignType = "horizontal";
    let prevVisibleArea = alignType == "horizontal" ? "-950px" : "-520px";
    let nextVisibleArea = alignType == "horizontal" ? "950px" : "520px";
    let nextnodeopacity = "0.3";
    let prevnodeopacity = "0.3";
    let nextnodescale = 1;
    let prevnodescale = 1;
    let visibleAreaData = 0;
    if (props && props && props.carousel && props.carousel.nextprevnodevisiblearea) {
        if (props.carousel.aligntype) alignType = props.carousel.aligntype;
        if (props.carousel.nextprevnodevisiblearea) {
            if (props.carousel.prevnodeopacity) prevnodeopacity = props.carousel.prevnodeopacity;
            if (props.carousel.nextnodeopacity) nextnodeopacity = props.carousel.nextnodeopacity;
            if (props.carousel.prevnodescale) prevnodescale = props.carousel.prevnodescale;
            if (props.carousel.nextnodescale) nextnodescale = props.carousel.nextnodescale;
            if (props.carousel.nextprevnodevisiblearea) {
                visibleAreaData = parseFloat(props.carousel.nextprevnodevisiblearea);
                prevVisibleArea = (alignType == "horizontal" ? this.slideWidth : this.slideHeight) - visibleAreaData + "px";
                nextVisibleArea = (alignType == "horizontal" ? this.slideWidth : this.slideHeight) - visibleAreaData + "px";
            }
        }
        let arrAsstParents = this.sgParent.querySelectorAll("[id*='assetParent']");
        for (let a = 0; a < arrAsstParents.length; a++) {
            if (arrAsstParents[a] != currentNode && arrAsstParents[a] != prevNode && arrAsstParents[a] != nextNode) {
                arrAsstParents[a].style.opacity = 0;
            }
            if (props.carousel.visiblenode && props.carousel.visiblenode.imageshadow && a == this.currentNodeIndex - 1) {
                let coverImageParent = arrAsstParents[a].querySelector("[id*='coverImageParent']");
                let coverParent = arrAsstParents[a].querySelector("[id*='coverParent']");
                if (coverParent && coverImageParent) {
                    coverParent.style.transition = this.isPlayAnimation == false ? "box-shadow 0s" : "box-shadow " + duration + "s 0.001s " + easeingValue;
                    coverParent.style.setProperty("box-shadow", props.carousel.visiblenode.imageshadow);
                    coverImageParent.style.removeProperty("overflow");
                }
            } else {
                let coverImageParent = arrAsstParents[a].querySelector("[id*='coverImageParent']");
                let coverParent = arrAsstParents[a].querySelector("[id*='coverParent']");
                if (coverParent && coverImageParent) {
                    coverParent.style.transition = "box-shadow " + duration + "s 0.001s " + easeingValue;
                    coverParent.style.boxShadow = "unset";
                    coverImageParent.style.removeProperty("overflow");
                }
            }
        }
    }
    if (next2Node) {
        next2Node.style.removeProperty("z-index");
        next2Node.classList.remove("moveLeftForwardPrev");
        next2Node.classList.remove("moveLeftForwardCurrent");
        next2Node.classList.remove("moveLeftForwardNext");
        next2Node.classList.remove("moveLeftForwardNext2");

        next2Node.classList.remove("moveLeftBackwardPrev");
        next2Node.classList.remove("moveLeftBackwardCurrent");
        next2Node.classList.remove("moveLeftBackwardNext");
        next2Node.classList.remove("moveLeftBackwardNext2");
        next2Node.classList.remove("noAnimation");

        let moveValue = alignType == "horizontal" ? this.slideWidth : this.slideHeight;
        next2Node.style.setProperty("--prevValue", animType == "prev" ? (moveValue - visibleAreaData) * 2 + "px" : (-moveValue + visibleAreaData) * 2 + "px");
        next2Node.style.setProperty("--prevValueOld", animType == "prev" ? moveValue - visibleAreaData + "px" : -moveValue + visibleAreaData + "px");

        if (alignType == "horizontal") next2Node.classList.add("moveLeftForwardPrev");
        else next2Node.classList.add("moveLeftBackwardPrev");

        if (this.isPlayAnimation == false) next2Node.classList.add("noAnimation");
    }
    if (prevNode) {
        // prevNode.style.removeProperty("z-index");
        prevNode.style.zIndex = 0;
        prevNode.style.removeProperty("transition");
        prevNode.style.opacity = "1";

        prevNode.classList.remove("moveLeftForwardPrev");
        prevNode.classList.remove("moveLeftForwardCurrent");
        prevNode.classList.remove("moveLeftForwardNext");
        prevNode.classList.remove("moveLeftForwardNext2");

        prevNode.classList.remove("moveLeftBackwardPrev");
        prevNode.classList.remove("moveLeftBackwardCurrent");
        prevNode.classList.remove("moveLeftBackwardNext");
        prevNode.classList.remove("moveLeftBackwardNext2");

        prevNode.classList.remove("noAnimation");

        if (floaterNav == false) prevNode.style.transition = this.isPlayAnimation == false ? "all 0s linear" : "all " + duration + "s 0.001s " + easeingValue;

        //Next & Prev has same value
        prevNode.style.setProperty("--currentValue", animType == "prev" ? "-" + prevVisibleArea : "-" + prevVisibleArea);
        if (this.currentNodeIndex == 2 && animType == "next" && this.isPlayAnimation == true) prevNode.style.setProperty("--currentValue", animType == "prev" ? "-" + (alignType == "horizontal" ? "100%" : "100%") : "-" + (alignType == "horizontal" ? "100%" : "100%"));
        prevNode.style.setProperty("--currentValueOld", animType == "prev" ? -parseFloat(prevVisibleArea) * 2 + "px" : "0px");

        if (alignType == "horizontal") prevNode.classList.add("moveLeftForwardCurrent");
        else prevNode.classList.add("moveLeftBackwardCurrent");

        if (this.isPlayAnimation == false) prevNode.classList.add("noAnimation");
        prevNode.style.opacity = prevnodeopacity;
        let imageNode = prevNode.querySelector("[id='coverImageParent']");
        let pointImageNode = prevNode.querySelector("[id*='pointImageParent']");

        if (pointImageNode) {
            if (floaterNav == false) pointImageNode.parentElement.style.transition = this.isPlayAnimation == false ? "all 0s linear" : "all " + duration + "s 0.001s " + easeingValue;
            pointImageNode.parentElement.style.transformOrigin = alignType == "horizontal" ? "right center" : "bottom center";
            pointImageNode.parentElement.style.transform = "scale(" + prevnodescale + ")";
        } else if (imageNode) {
            if (floaterNav == false) imageNode.style.transition = this.isPlayAnimation == false ? "all 0s linear" : "all " + duration + "s 0.001s " + easeingValue;
            imageNode.style.transformOrigin = alignType == "horizontal" ? "right center" : "bottom center";
            imageNode.style.transform = "scale(" + prevnodescale + ")";
        }
        if (this.isPlayAnimation == false) {
            if (this.currentNodeIndex - 1 == 1) {
                let arrShapes = prevNode.querySelectorAll("[id*='shape']");
                for (let a = 0; a < arrShapes.length; a++) {
                    arrShapes[a].style.transition = this.isPlayAnimation == false ? "opacity 0s" : "opacity " + duration + "s 0.001s " + easeingValue;
                    arrShapes[a].style.opacity = 0;
                }
            }
            let textBaseParentNode = prevNode.querySelector("[id*='textBaseParentNode']");
            if (textBaseParentNode) {
                textBaseParentNode.style.transition = this.isPlayAnimation == false ? "opacity 0s" : "opacity " + duration + "s 0.001s " + easeingValue;
                textBaseParentNode.style.opacity = 0;
            } else {
                let titleLabelTextParent = prevNode.querySelector("[id*='titleLabelTextParent']");
                let titleTextParent = prevNode.querySelector("[id*='titleTextParent']");
                let subTitleTextParent = prevNode.querySelector("[id*='subTitleTextParent']");
                if (titleLabelTextParent) {
                    titleLabelTextParent.style.transition = this.isPlayAnimation == false ? "opacity 0s" : "opacity " + duration + "s 0.001s " + easeingValue;
                    titleLabelTextParent.style.opacity = 0;
                }
                if (titleTextParent) {
                    titleTextParent.style.transition = this.isPlayAnimation == false ? "opacity 0s" : "opacity " + duration + "s 0.001s " + easeingValue;
                    titleTextParent.style.opacity = 0;
                }
                if (subTitleTextParent) {
                    subTitleTextParent.style.transition = this.isPlayAnimation == false ? "opacity 0s" : "opacity " + duration + "s 0.001s " + easeingValue;
                    subTitleTextParent.style.opacity = 0;
                }
            }
            let sgNumberTextParent = prevNode.querySelector("[id*='sgNumberTextParent']");
            if (sgNumberTextParent) {
                sgNumberTextParent.style.transition = this.isPlayAnimation == false ? "opacity 0s" : "opacity " + duration + "s 0.001s " + easeingValue;
                sgNumberTextParent.style.opacity = 0;
            }
        }
        let coverParent = prevNode.querySelector("[id*='coverParent']");
        if (coverParent) {
            coverParent.style.transition = "box-shadow " + duration + "s 0.001s " + easeingValue;
            coverParent.style.setProperty("box-shadow", "unset");
            setTimeout(
                () => {
                    coverParent.style.removeProperty("transition");
                },
                this.isPlayAnimation == false ? 0 : 1200
            );
        }
    }
    if (currentNode) {
        currentNode.style.zIndex = 1;
        currentNode.style.transition = this.isPlayAnimation == false ? "all 0s linear" : "all " + duration + "s 0.001s " + easeingValue;
        currentNode.style.removeProperty("transform");
        currentNode.style.setProperty("--nextValue", animType == "prev" ? "0px" : "0px");
        currentNode.style.setProperty("--nextValueOld", animType == "prev" ? "-" + prevVisibleArea : parseFloat(prevVisibleArea) + "px");

        currentNode.classList.remove("moveLeftForwardPrev");
        currentNode.classList.remove("moveLeftForwardCurrent");
        currentNode.classList.remove("moveLeftForwardNext");
        currentNode.classList.remove("moveLeftForwardNext2");

        currentNode.classList.remove("moveLeftBackwardPrev");
        currentNode.classList.remove("moveLeftBackwardCurrent");
        currentNode.classList.remove("moveLeftBackwardNext");
        currentNode.classList.remove("moveLeftBackwardNext2");
        currentNode.classList.remove("noAnimation");

        if (alignType == "horizontal") currentNode.classList.add("moveLeftForwardNext");
        else currentNode.classList.add("moveLeftBackwardNext");

        if (this.isPlayAnimation == false) currentNode.classList.add("noAnimation");

        let textBaseParentNode = currentNode.querySelector("[id*='textBaseParentNode']");
        if (textBaseParentNode) textBaseParentNode.style.removeProperty("opacity");
        else {
            let titleLabelTextParent = currentNode.querySelector("[id*='titleLabelTextParent']");
            let titleTextParent = currentNode.querySelector("[id*='titleTextParent']");
            let subTitleTextParent = currentNode.querySelector("[id*='subTitleTextParent']");
            if (titleLabelTextParent) titleLabelTextParent.style.removeProperty("opacity");
            if (titleTextParent) titleTextParent.style.removeProperty("opacity");
            if (subTitleTextParent) subTitleTextParent.style.removeProperty("opacity");
        }
        let sgNumberTextParent = currentNode.querySelector("[id*='sgNumberTextParent']");
        if (sgNumberTextParent) sgNumberTextParent.style.removeProperty("opacity");
        let imageNode = currentNode.querySelector("[id='coverImageParent']");
        let pointImageNode = currentNode.querySelector("[id*='pointImageParent']");

        if (this.currentNodeIndex - 1 == 0) {
            let arrShapes = currentNode.querySelectorAll("[id*='shape']");
            for (let a = 0; a < arrShapes.length; a++) {
                arrShapes[a].style.removeProperty("opacity");
            }
        }

        if (pointImageNode) {
            pointImageNode.parentElement.style.removeProperty("transform");
            pointImageNode.parentElement.style.removeProperty("transform-origin");
        } else if (imageNode) {
            imageNode.style.removeProperty("transform");
            imageNode.style.removeProperty("transform-origin");
        }
    }
    if (nextNode) {
        nextNode.style.zIndex = 0;
        // nextNode.style.removeProperty("z-index");
        nextNode.style.removeProperty("z-index");
        nextNode.style.removeProperty("transition");
        if (animType != "prev") nextNode.style.opacity = "0";

        if (floaterNav == false) nextNode.style.transition = this.isPlayAnimation == false ? "all 0s linear" : "all " + duration + "s 0.001s " + easeingValue;
        nextNode.classList.remove("moveLeftForwardPrev");
        nextNode.classList.remove("moveLeftForwardCurrent");
        nextNode.classList.remove("moveLeftForwardNext");
        nextNode.classList.remove("moveLeftForwardNext2");

        nextNode.classList.remove("moveLeftBackwardPrev");
        nextNode.classList.remove("moveLeftBackwardCurrent");
        nextNode.classList.remove("moveLeftBackwardNext");
        nextNode.classList.remove("moveLeftBackwardNext2");
        nextNode.classList.remove("noAnimation");

        nextNode.style.setProperty("--next2Value", animType == "prev" ? nextVisibleArea : nextVisibleArea);
        nextNode.style.setProperty("--next2ValueOld", animType == "prev" ? "0px" : parseFloat(nextVisibleArea) * 2 + "px");
        if (alignType == "horizontal") nextNode.classList.add("moveLeftForwardNext2");
        else nextNode.classList.add("moveLeftBackwardNext2");

        if (this.isPlayAnimation == false) nextNode.classList.add("noAnimation");

        if (this.currentNodeIndex - 1 == 0) nextNode.style.opacity = 0;
        else nextNode.style.opacity = nextnodeopacity;
        let imageNode = nextNode.querySelector("[id='coverImageParent']");
        let pointImageNode = nextNode.querySelector("[id*='pointImageParent']");
        if (pointImageNode) {
            if (floaterNav == false) pointImageNode.parentElement.style.transition = this.isPlayAnimation == false ? "all 0s linear" : "all " + duration + "s 0.001s " + easeingValue;
            pointImageNode.parentElement.style.transform = "scale(" + nextnodescale + ")";
            pointImageNode.parentElement.style.transformOrigin = alignType == "horizontal" ? "left center" : "top center";
        } else if (imageNode) {
            if (floaterNav == false) imageNode.style.transition = this.isPlayAnimation == false ? "all 0s linear" : "all " + duration + "s 0.001s " + easeingValue;
            imageNode.style.transform = "scale(" + nextnodescale + ")";
            imageNode.style.transformOrigin = alignType == "horizontal" ? "left center" : "top center";
        }
        if (this.isPlayAnimation == false) {
            let textBaseParentNode = nextNode.querySelector("[id*='textBaseParentNode']");
            if (textBaseParentNode) {
                textBaseParentNode.style.transition = this.isPlayAnimation == false ? "opacity 0s" : "opacity " + duration + "s 0.001s " + easeingValue;
                textBaseParentNode.style.opacity = 0;
            } else {
                let titleLabelTextParent = nextNode.querySelector("[id*='titleLabelTextParent']");
                let titleTextParent = nextNode.querySelector("[id*='titleTextParent']");
                let subTitleTextParent = nextNode.querySelector("[id*='subTitleTextParent']");
                if (titleLabelTextParent) {
                    titleLabelTextParent.style.transition = this.isPlayAnimation == false ? "opacity 0s" : "opacity " + duration + "s 0.001s " + easeingValue;
                    titleLabelTextParent.style.opacity = 0;
                }
                if (titleTextParent) {
                    titleTextParent.style.transition = this.isPlayAnimation == false ? "opacity 0s" : "opacity " + duration + "s 0.001s " + easeingValue;
                    titleTextParent.style.opacity = 0;
                }
                if (subTitleTextParent) {
                    subTitleTextParent.style.transition = this.isPlayAnimation == false ? "opacity 0s" : "opacity " + duration + "s 0.001s " + easeingValue;
                    subTitleTextParent.style.opacity = 0;
                }
            }
            let sgNumberTextParent = nextNode.querySelector("[id*='sgNumberTextParent']");
            if (sgNumberTextParent) {
                sgNumberTextParent.style.transition = this.isPlayAnimation == false ? "opacity 0s" : "opacity " + duration + "s 0.001s " + easeingValue;
                sgNumberTextParent.style.opacity = 0;
            }
        }
        let coverParent = nextNode.querySelector("[id*='coverParent']");
        if (coverParent) {
            coverParent.style.transition = "box-shadow " + duration + "s 0.013s " + easeingValue;
            coverParent.style.setProperty("box-shadow", "unset");
            setTimeout(
                () => {
                    coverParent.style.removeProperty("transition");
                },
                this.isPlayAnimation == false ? 0 : 1200
            );
        }
    }
};
GenericCarouselImagestack.prototype.floaterNavigation = function (index, animType = "", animPlaying) {
    this.currentNodeIndex = this.currentNodeIndex + index;
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");

    for (let i = 0; i < this.sgData.length; i++) {
        let currentNode = this.sgParent.querySelector("[id='assetParent" + i + "']");
        if (this.currentNodeIndex - 1 == i && currentNode) {
            let textBaseParentNode = currentNode.querySelector("[id*='textBaseParentNode']");
            if (textBaseParentNode) textBaseParentNode.style.removeProperty("opacity");
            let sgNumberTextParent = currentNode.querySelector("[id*='sgNumberTextParent']");
            if (sgNumberTextParent) sgNumberTextParent.style.removeProperty("opacity");

            currentNode.style.opacity = 1;
            currentNode.style.pointerEvents = "auto";
            currentNode.style.setProperty("--textPointerEvent", "auto");
            this.onTextChangeForAllNodes(currentNode, i);
            currentNode.removeAttribute("active");
        } else if (currentNode) {
            if (animType == "") currentNode.style.opacity = 0;
            currentNode.setAttribute("active", "false");
            currentNode.style.pointerEvents = "none";
            currentNode.style.setProperty("--textPointerEvent", "none");
            if (animType == "goto") {
                currentNode.classList.remove("moveLeftForwardPrev");
                currentNode.classList.remove("moveLeftForwardCurrent");
                currentNode.classList.remove("moveLeftForwardNext");
                currentNode.classList.remove("moveLeftForwardNext2");

                currentNode.classList.remove("moveLeftBackwardPrev");
                currentNode.classList.remove("moveLeftBackwardCurrent");
                currentNode.classList.remove("moveLeftBackwardNext");
                currentNode.classList.remove("moveLeftBackwardNext2");
                currentNode.classList.remove("noAnimation");
            }
        }
        if (deviceImageParentNode) {
            deviceImageParentNode.style.opacity = this.currentNodeIndex - 1 == 0 ? 0 : 1;
            deviceImageParentNode.style.pointerEvents = this.currentNodeIndex - 1 == 0 ? "none" : "auto";
        }
        if (this.currentNodeIndex - 1 == 0 && i == 1) currentNode.style.opacity = 0;
    }
    this.animatInnerSlide(false, animType, animPlaying);
    this.updatenavFloater();
    this.eventManager.dispatch("positionchangecallback", this.currentNodeIndex - 1);
};
GenericCarouselImagestack.prototype.updatenavFloater = function () {
    if (this.isPlayAnimation == false && this.isPresent != true) {
        let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
        if (assetParent0 && assetParent0.classList.contains("introSlide") && this.updateNavFloaterIndex) {
            let isIntroHide = this.sgParent?.parentElement?.parentElement?.getAttribute("data-ogdata-finalhide_0")?.split(",")?.includes("intro");
            let isVisible = isIntroHide ? -1 : 0;
            let slideID = this.slideContent && this.slideContent.id ? this.slideContent.id : null;
            this.updateNavFloaterIndex(this.currentNodeIndex + isVisible, slideID, isVisible, this.currentNodeIndex - 1 + isVisible);
        }
    }
};

GenericCarouselImagestack.prototype.initPresentSG = function (slideContent) {
    let hasEmptyIntro = this.checkIntroAnimation();
    let specialgraphicsParent = slideContent && slideContent.querySelector("[id='specialgraphicsParent']") ? slideContent.querySelector("[id='specialgraphicsParent']") : null;
    if (specialgraphicsParent) specialgraphicsParent.setAttribute("hasemptyintro", hasEmptyIntro);
};

GenericCarouselImagestack.prototype.gotoAndStopFirstNode = function (completeCallback, type, slideContent, indexValue = -1) {
    //Re-applying image contrast
    this.reApplyContrast();

    let hasEmptyIntro = this.checkIntroAnimation();
    this.currentNodeIndex = indexValue > -1 ? indexValue : this.isFromLastSlide == true ? this.sgData.length : hasEmptyIntro == true ? 2 : 1;
    //This attribute for present without animation flow
    this.sgParent.setAttribute("supportanimation", "false");
    let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
    let bgImageNode = this.sgParent.querySelector("[id*='bgImageNode']");
    if (bgImageNode) {
        bgImageNode.classList.remove("moodanimation");
        bgImageNode.removeAttribute("data-animation");
    }
    for (let i = 0; i < assetParents.length; i++) {
        assetParents[i].style.opacity = "0";
        let moodAnimationData = assetParents[i].querySelectorAll("[class*='moodanimation']");
        for (let a = 0; a < moodAnimationData.length; a++) {
            if (moodAnimationData[a].id.includes("coverImageParent") || moodAnimationData[a].id.includes("pointImageParent")) {
                moodAnimationData[a].classList.remove("moodanimation");
                moodAnimationData[a].removeAttribute("data-animation");
            }
        }
    }
    this.eventManager.dispatch("positionchangecallback", this.currentNodeIndex - 1);
    let delayIntro = this.moodName && this.moodName == "simplecss" && hasEmptyIntro ? 1200 : 0;
    if (delayIntro != 0) this.sgParent.style.opacity = 0;
    setTimeout(() => {
        if (this.isPlayAnimation) this.sgParent.style.transition = "opacity 1s";
        this.sgParent.style.opacity = 1;
        this.floaterNavigation(0, "goto");
        let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
        if (this.isPlayAnimation && deviceImageParentNode && hasEmptyIntro) deviceImageParentNode.style.transition = "all 1.5s ease";

        if (hasEmptyIntro == false && this.getAssetParent(1)) {
            let assetParent = this.getAssetParent(1);
            assetParent.setAttribute("playshapeanimation", "false");
        }
        // if (completeCallback) completeCallback();
    }, delayIntro);
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1);
};
GenericCarouselImagestack.prototype.hideAnimation = function (completeCallback) {
    if (this.isHeroImage() != true) this.updateShowHideInfo(this.currentNodeIndex - 1, false);
    else if (this.currentNodeIndex == 1) this.currentNodeIndex = this.currentNodeIndex + 1;
    setTimeout(() => {
        completeCallback ? completeCallback() : "";
    }, 2000);
    // this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1, "moodsutil", true);
};
GenericCarouselImagestack.prototype.updateShowHideInfo = function (index, isShow = true, animType) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + index + "']");
    // if (!isShow) assetParent.style.opacity = 1;
    assetParent.classList.remove(isShow == true ? "hidesg" : "showsg");
    assetParent.classList.add(isShow == true ? "showsg" : "hidesg");
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (this.isPlayAnimation && deviceImageParentNode) deviceImageParentNode.style.transition = animType && animType == "next" ? "all 1s 0.5s ease" : "all 1.5s ease";
    if (this.currentNodeIndex == 1 && this.isPlayAnimation == false && deviceImageParentNode) deviceImageParentNode.style.opacity = 0;
    else if (deviceImageParentNode && this.currentNodeIndex != 1) deviceImageParentNode.style.opacity = 1;
};
GenericCarouselImagestack.prototype.next = function (completeCallback) {
    //For intermediate animation no need to return transition animate callback from moodsutil using OnNodeInserted method.
    this.sgParent.setAttribute("dotransition", "false");

    this.sgParent.removeAttribute("hasemptyintro");

    let oldIndex = this.currentNodeIndex - 1 < 0 ? 0 : this.currentNodeIndex - 1;
    this.currentNodeIndex = this.currentNodeIndex + 1;
    if (this.currentNodeIndex > this.sgData.length) return;

    //HIDE ANIMATION
    this.updateShowHideInfo(oldIndex, false, "next");
    this.floaterNavigation(0, "next", true);

    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", completeCallback, this.isPlayAnimation, this.eventManager, oldIndex, "moodsutilintermediate");
    if (this.currentNodeIndex > 1) this.showDevice(true);
    //SHOW ANIMATION
    this.updateShowHideInfo(this.currentNodeIndex - 1, true, "next");
    // if (completeCallback) completeCallback();
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1, "moodsutilintermediate");
    // if (this.isPlayAnimation == false && this.currentNodeIndex == 2) {
    //     let assetParent = this.sgParent.querySelector("[id='assetParent0']");
    //     assetParent.style.opacity = 0;
    // }
};
GenericCarouselImagestack.prototype.showDevice = function (showDevice = true) {
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (deviceImageParentNode) {
        deviceImageParentNode.style.opacity = showDevice == false ? 0 : 1;
        deviceImageParentNode.style.pointerEvents = showDevice == false ? "none" : "auto";
    }
    if (this.sgParent.querySelector("[id='deviceImageNode']") && showDevice == true) this.sgParent.querySelector("[id='deviceImageNode']").style.removeProperty("opacity");
    if (this.sgParent.querySelector("[id='deviceImageNode1']") && showDevice == true) this.sgParent.querySelector("[id='deviceImageNode1']").style.removeProperty("opacity");
    if (this.sgParent.querySelector("[id='videoElement']") && showDevice == true) this.sgParent.querySelector("[id='videoElement']").style.removeProperty("opacity");
    if (this.sgParent.querySelector("[id='secondaryAssetNode']") && showDevice == true) this.sgParent.querySelector("[id='secondaryAssetNode']").style.removeProperty("opacity");
};
GenericCarouselImagestack.prototype.previous = function (completeCallback) {
    let oldIndex = this.currentNodeIndex - 1 < 0 ? 0 : this.currentNodeIndex - 1;
    this.currentNodeIndex = this.currentNodeIndex - 1;

    this.sgParent.removeAttribute("hasemptyintro");

    let hasEmptyIntro = this.checkIntroAnimation();
    if (hasEmptyIntro == true && this.currentNodeIndex <= 1) return false;

    this.floaterNavigation(0, "prev", true);
    // setTimeout(() => {
    //     completeCallback ? completeCallback() : "";
    // }, 2000);

    if (this.currentNodeIndex < 1) return;
    // if (this.sgParent.querySelector("[id='assetParent0']").classList.contains("introSlide") && oldIndex == 1) {
    //     this.sgParent.querySelector("[id='assetParent1']").setAttribute("hashide", "true");
    //     if (this.sgParent.querySelector("[id='deviceImageNode']")) this.sgParent.querySelector("[id='deviceImageNode']").style.opacity = 1;
    //     if (this.sgParent.querySelector("[id='deviceImageNode1']")) this.sgParent.querySelector("[id='deviceImageNode1']").style.opacity = 1;
    //     if (this.sgParent.querySelector("[id='videoElement']")) this.sgParent.querySelector("[id='videoElement']").style.opacity = 1;
    //     if (this.sgParent.querySelector("[id='secondaryAssetNode']")) this.sgParent.querySelector("[id='secondaryAssetNode']").style.opacity = 1;
    // }
    //HIDE ANIMATION
    this.updateShowHideInfo(oldIndex, false);
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", completeCallback, this.isPlayAnimation, this.eventManager, oldIndex, "moodsutilintermediate");

    // let delayVal = 0;
    // let newAssetparent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    // if (newAssetparent && newAssetparent.classList.contains("introSlide") && this.isPlayAnimation == true) delayVal = 1000;

    //SHOW ANIMATION
    // setTimeout(() => {
    this.updateShowHideInfo(this.currentNodeIndex - 1, true);
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1, "moodsutilintermediate");
    // }, delayVal);
};
GenericCarouselImagestack.prototype.checkIntroAnimation = function () {
    if (this.isHeroImage() == true) return true;
    if (this.sgParent && this.sgParent.parentElement && this.sgParent.parentElement.parentElement) {
        let animationDIV = this.sgParent.parentElement.parentElement;
        let showIntro = animationDIV.getAttribute("data-ogdata-finalshow_0")?.split(",")?.includes("intro") ? "true" : "false";
        if (showIntro == "false") return true;
    }
    let assetParent = this.getAssetParent(0);
    if (assetParent && assetParent.classList.contains("introSlide")) {
        let title = assetParent.querySelector("[id='sgTitleNode']");
        let subTitle = assetParent.querySelector("[id='sgSubTitleNode']");
        let titleLabel = assetParent.querySelector("[id='sgTitleLabelNode']");
        if (title && title.innerText.trim().length == 0 && subTitle && subTitle.innerText.trim().length == 0 && titleLabel && titleLabel.innerText.trim().length == 0) {
            return true;
        }
    }
    return false;
};
GenericCarouselImagestack.prototype.isHeroImage = function () {
    if (this.sgParent && this.sgParent.parentElement && this.sgParent.parentElement.parentElement) {
        let count = this.sgParent.parentElement.parentElement.getAttribute("data-nodecount");
        if (count == "1") return true;
    }
};

GenericCarouselImagestack.prototype.updateImage = function (elementId, src, nodeIndex = null, resizeImage = false) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + (nodeIndex != null ? nodeIndex : this.currentNodeIndex - 1) + "']");
    let imageNode = assetParent ? assetParent.querySelector("[id='" + elementId + "']") : this.sgParent.querySelector("[id='" + elementId + "']");
    if (imageNode && src) {
        imageNode.src = src;
        if (resizeImage) this.specialGraphicsUtils.updateImageReSize(imageNode.getAttribute("data-width"), imageNode.getAttribute("data-height"), imageNode);
        let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData && this.metaData ? this.metaData : null;
        let isNotMainImage = imageNode.id.includes("sgPlaceHolderImageNode") || imageNode.id.includes("sgLogoImageNode") ? false : true;
        if (isNotMainImage && metaDataBase && metaDataBase.properties && metaDataBase.properties[imageID] && assetParent) {
            let props = metaDataBase.properties.image;
            if (props.contrast && props.contrast == "fullbg" && imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent);
            if (props.contrast && props.contrast == "halfbg" && imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent, true);
        }
        let duplicatedImages = assetParent ? assetParent.querySelectorAll("[data-target-id='coverimageduplicate']") : null;
        if (duplicatedImages?.length > 0 && elementId.includes("coverimage")) {
            for (let a = 0; a < duplicatedImages.length; a++) {
                let duplicatedImage = duplicatedImages[a];
                duplicatedImage.src = src;
            }
        }
        if (elementId.toLocaleLowerCase().includes("logo") || elementId.includes("sgPlaceHolderImageNode")) {
            imageNode.callback = this.rePositionTextAndElement;
            let type = elementId.includes("sgPlaceHolderImageNode") ? "image" : "logo";
            this.setLogoSizes(assetParent, type);
        }
    }
};
GenericCarouselImagestack.prototype.updateImageResizeOnTypeChange = function (type) {
    let assetParent = this.getAssetParent(this.currentNodeIndex - 1);
    this.setLogoSizes(assetParent, type);
    this.textFitOnImageResize();
};
GenericCarouselImagestack.prototype.getAssetParent = function (index) {
    return this.sgParent.querySelector("[id='assetParent" + index + "']");
};
GenericCarouselImagestack.prototype.changeText = function (updatedText, elementId, targetIndex, textType) {
    let assetParent = this.getAssetParent(this.currentNodeIndex - 1);
    if (assetParent && assetParent.querySelector("[id='" + elementId + "']")) {
        let textNode = assetParent.querySelector("[id='" + elementId + "']");
        textNode = !textNode ? assetParent.querySelector("[id*='" + elementId + "']") : textNode;

        if (textNode) {
            let prefix = textNode.hasAttribute("prefix") ? textNode.getAttribute("prefix") : null;
            let suffix = textNode.hasAttribute("suffix") ? textNode.getAttribute("suffix") : null;
            if (prefix) {
                updatedText = updatedText.replace(prefix, "");
                updatedText = prefix + " " + updatedText;
            }
            if (suffix) {
                updatedText = updatedText.replace(suffix, "");
                updatedText = updatedText + " " + suffix;
            }
            textNode.setAttribute("data-heading", updatedText);
            textNode.setAttribute("data-oldtext", updatedText);
            textNode.setAttribute("data-changetext", "true");
            textNode.innerHTML = updatedText;

            if (this.sgSlideType != "sectionbreak") this.specialGraphicsUtils.doFontFitForCss(textNode, this.sgParent, null, null, null, true);
            this.specialGraphicsUtils.updateImagePositions(this.sgParent);
        }
    }
};
GenericCarouselImagestack.prototype.getTargetElement = function (elementID) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    if (assetParent && assetParent.querySelector("[id='" + elementID + "']")) return assetParent.querySelector("[id='" + elementID + "']");
};

GenericCarouselImagestack.prototype.resetFontDetails = function (elementID, parent, type) {
    let element = parent.querySelector("[id='" + elementID + "']");
    if (element) {
        element.classList.remove("h3");
        element.classList.remove("h4");
        element.classList.add(this.fontData[type]);
        element.style.removeProperty("max-height");
        element.style.removeProperty("min-height");
        element.style.removeProperty("font-size");
        if (element.hasAttribute("user-font-size")) {
            this.specialGraphicsUtils.removeAllFontClass(element);
            element.classList.add(element.getAttribute("user-font-size"));
            // element.style.setProperty("font-size", element.getAttribute("user-font-size") + "px", "important");
        }
        this.specialGraphicsUtils.doFontFitForCss(element, this.sgParent);
    }
};
GenericCarouselImagestack.prototype.updateFloaterOnPreviewEnd = function (index) {
    this.updateIntroVisibility(false, index);
};

GenericCarouselImagestack.prototype.createPlaceHolder = function (parentNode, currentIndex) {
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    // let src = "";
    let placeholderProperty = null;
    if (props && props && props["placeholderimage"]) placeholderProperty = props["placeholderimage"];
    // if (placeholderProperty && placeholderProperty.imageurl) src = placeholderProperty.imageurl;
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");

    this.createPlaceHolderImage(parentNode, currentIndex);
    let parentElement = parentNode.querySelector("[id*='placeHolderParent']");
    let logoParent = parentElement.querySelector("[id*='logoContentParent']");
    let imageParent = parentElement.querySelector("[id*='phImageContentParent']");
    let iconParent = parentElement.querySelector("[id*='phIconContentParent']");
    let textParent = parentElement.querySelector("[id*='phTextParent']");
    let phTextNode = parentElement.querySelector("[id*='phTextNode']");
    let logoImageNode = logoParent ? logoParent.querySelector("[id='sgLogoImageNode']") : null;

    let placeHolderType = this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagetype ? this.sgData[currentIndex].placeholderimagetype : placeholderProperty.placeholderimagetype ? placeholderProperty.placeholderimagetype : "logo";
    if (placeHolderType && logoParent && imageParent && iconParent && textParent) {
        logoParent.classList.remove("placeholderactive");
        imageParent.classList.remove("placeholderactive");
        iconParent.classList.remove("placeholderactive");
        textParent.classList.remove("placeholderactive");
        if (placeHolderType == "logo") logoParent.classList.add("placeholderactive");
        if (placeHolderType == "image") imageParent.classList.add("placeholderactive");
        if (placeHolderType == "icon") iconParent.classList.add("placeholderactive");
        if (placeHolderType == "text") textParent.classList.add("placeholderactive");
        if (placeholderProperty.placeholdersizestyle) {
            let sizeStyle = placeholderProperty.placeholdersizestyle;
            if (!parentElement.classList.contains("placeholderSizeStyle")) parentElement.classList.add("placeholderSizeStyle");
            parentElement.setAttribute("data-placeholdersizestyle", sizeStyle);
            logoParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            imageParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            iconParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            textParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            if (!logoParent.classList.contains(sizeStyle)) logoParent.classList.add(sizeStyle);
            if (!imageParent.classList.contains(sizeStyle)) imageParent.classList.add(sizeStyle);
            if (!iconParent.classList.contains(sizeStyle)) iconParent.classList.add(sizeStyle);
            if (!textParent.classList.contains(sizeStyle)) textParent.classList.add(sizeStyle);
        }
    }

    this.specialgraphicsPropertyUtils.applyImageBaseProps(placeholderProperty, assetParent, parentElement, "--placeholderImage", false);

    let colorValue = placeholderProperty ? this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "secondary", placeholderProperty.textcolor) : null;
    // if (!colorValue && placeholderProperty.textcolor) colorValue = "rgba(var(--" + placeholderProperty.textcolor + "-color-rgb),1)";
    if (phTextNode && colorValue) {
        phTextNode.style.color = colorValue;
        phTextNode.setAttribute("data-color", colorValue);
    }

    if (this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagesize && parentElement) parentElement.setAttribute("data-placeholderimagesize", this.sgData[currentIndex].placeholderimagesize);
    if (placeHolderType == "image" || placeHolderType == "logo" || placeHolderType == "icon" || placeHolderType == "text") this.setLogoSizes(assetParent, placeHolderType);

    if (this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagealign) {
        let alignData = this.sgData[currentIndex].placeholderimagealign;
        if (alignData == "bottom" || alignData == "right") parentElement.classList.add("phPosition");
        else parentElement.classList.remove("phPosition");
    }
    if (placeholderProperty.placeholderalign) parentElement.setAttribute("phalign", placeholderProperty.placeholderalign);
    if (this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagesize) {
        //Implement placeholder size change from floter
        // let sizeV = this.sgData[currentIndex].placeholderimagesize;
        // let multipleValue = sizeV == "small" ? 0.4 : sizeV == "medium" ? 0.7 : sizeV == "large" ? 1 : parseFloat(sizeV);
        let multipleValue = this.specialGraphicsUtils.getImageSizeSML(this.sgData[currentIndex].placeholderimagesize);
        let largeW = parseFloat(parentElement.getAttribute("data-largewidth"));
        let largeH = parseFloat(parentElement.getAttribute("data-largeheight"));
        let newW = largeW * multipleValue;
        let newH = largeH * multipleValue;
        let cropHeight = logoImageNode && logoImageNode.hasAttribute("logosizecropheight") ? logoImageNode.getAttribute("logosizecropheight") : "";
        if (newW > 0 && newH > 0) {
            parentElement.style.width = newW + "px";
            if (cropHeight == "") parentElement.style.height = newH + "px";
        }
        if (logoImageNode) logoImageNode.removeAttribute("logosizecropheight");
    }
    let hasPlaceholderData = this.sgData[currentIndex].placeholderimage != null && this.sgData[currentIndex].placeholderimage != undefined;
    if (placeHolderType == "icon" && iconParent && hasPlaceholderData) {
        let iconPath = this.sgData[currentIndex].placeholderimage.includes(".svg") ? this.sgData[currentIndex].placeholderimage : this.appStaticURL + "genericassets/icons/fill/default/best.svg";
        let iconNodeParent = iconParent.querySelector("[id*='phIconSvgNode']");
        let arrAssets = [];
        if (iconNodeParent) iconNodeParent.setAttribute("data-src", iconPath);
        arrAssets.push({ url: iconPath, id: "svgdata", parent: iconNodeParent, type: "SVG" });
        // this.arrCommonAssets.push({ array: arrAssets, callback: this.placeholderSvgLoadCallback });
        this.loadAssets(arrAssets, this.placeholderSvgLoadCallback);
    }
    if (placeholderProperty && placeholderProperty.halign) {
        let halignProp = placeholderProperty.halign;
        let hAlign = halignProp == "right" || halignProp == "end" ? "flex-end" : halignProp == "center" || halignProp == "middle" ? "center" : "flex-start";
        let pos = halignProp == "right" || halignProp == "end" ? "right" : halignProp == "center" || halignProp == "middle" ? "center" : "left";
        if (logoImageNode) logoImageNode.setAttribute("data-imagecropalignment", pos);
        let phTextNode = textParent.querySelector("[id*='phTextNode']");
        if (phTextNode) phTextNode.style.textAlign = hAlign;
    }
    this.applyContrastToText(logoImageNode, placeholderProperty);
    this.applyContrastToText(phTextNode, placeholderProperty);
};
GenericCarouselImagestack.prototype.getCurrentIndex = function () {
    return this.currentNodeIndex - 1;
};
GenericCarouselImagestack.prototype.startIndex = function (currentSlideData) {
    return this.specialGraphicsUtils.getStartIndex(currentSlideData, this.sgParent);

    // let presentParent = currentSlideData ? currentSlideData : this.sgParent;
    // let assetParent = presentParent ? presentParent.querySelector("[id='assetParent0']") : null;
    // let sgParent = presentParent ? presentParent.querySelector("[id='specialgraphicsParent']") : this.sgParent;

    // let isNotVisible = assetParent?.style?.display == "none" || assetParent?.style?.opacity == 0 || assetParent?.style?.opacity == "0";
    // if (isNotVisible) sgParent.setAttribute("startindex", "1");
    // else sgParent.removeAttribute("startindex");

    // let localParent = sgParent ? sgParent : this.sgParent;
    // let animationDIV = localParent?.parentElement?.parentElement ? localParent.parentElement.parentElement : null;
    // let showIntro = animationDIV?.hasAttribute("data-intro") ? animationDIV.getAttribute("data-intro") : "true";

    // return (isNotVisible || !assetParent) && showIntro != "true" ? 1 : 0;
};
GenericCarouselImagestack.prototype.setLogoSizes = function (assetParent, placeHolderType = "") {
    let assetParentNode = assetParent ? assetParent : this.getAssetParent(this.currentNodeIndex - 1);
    let imgNode = assetParentNode ? assetParentNode.querySelector("[id='sgLogoImageNode']") : null;

    let oldDisplay = assetParentNode ? assetParentNode.style.display : "";
    if (assetParentNode) assetParentNode.style.display = "block";

    if (placeHolderType == "icon") {
        imgNode = assetParentNode ? assetParentNode.querySelector("[id*='phIconSvgNode']") : null;
        this.setLogoSizesOP(imgNode);
    } else if (placeHolderType == "text") {
        imgNode = assetParentNode ? assetParentNode.querySelector("[id*='phTextNode']") : null;
        this.setLogoSizesOP(imgNode);
        this.onTextChangeUpdatePlaceholderNode(imgNode);
    } else {
        if (placeHolderType == "image") imgNode = assetParentNode ? assetParentNode.querySelector("[id='sgPlaceHolderImageNode']") : null;

        if (imgNode && imgNode.complete) this.setLogoSizesOP(imgNode);
        else if (imgNode) imgNode.addEventListener("load", this.logoLoadCallback);
    }
    if (assetParentNode) assetParentNode.style.display = oldDisplay;
};

GenericCarouselImagestack.prototype.logoLoadCallback = function (event) {
    event.target.removeEventListener("load", this.logoLoadCallback);
    this.setLogoSizesOP(event.target);
};
GenericCarouselImagestack.prototype.setLogoSizesOP = function (imgNode) {
    let logoRatio = this.specialGraphicsUtils.getLogoRatio(imgNode);
    // console.log("LOGO - ratio - " + logoRatio);
    if (!logoRatio) logoRatio = "square";
    if (logoRatio && imgNode) {
        let dummyDom = document.createElement("div");
        dummyDom.classList.add(logoRatio);
        dummyDom.style.position = "absolute";
        dummyDom.style.width = "var(--logoSizeWidth)";
        dummyDom.style.height = "var(--logoSizeHeight)";
        if (imgNode.id.includes("phTextNode")) imgNode.appendChild(dummyDom);
        else imgNode.parentElement.appendChild(dummyDom);
        let w = window.getComputedStyle(dummyDom).width;
        let h = window.getComputedStyle(dummyDom).height;
        if (w != "" && h != "" && w != "0px" && h != "0px") {
            let mainParent = imgNode.parentElement.parentElement.parentElement;
            if (imgNode.id.includes("phTextNode")) mainParent = imgNode.parentElement.parentElement;
            let lgWidth = window.getComputedStyle(dummyDom).getPropertyValue("--logoSizeWidth");
            if (lgWidth?.trim() == "100%") {
                mainParent.style.width = "100%";
                w = window.getComputedStyle(mainParent).width;
            }
            imgNode.parentElement.style.setProperty("--logoSizeWidth", w);
            imgNode.parentElement.style.setProperty("--logoSizeHeight", h);
            imgNode.parentElement.setAttribute("data-largewidth", parseFloat(w));
            imgNode.parentElement.setAttribute("data-largeheight", parseFloat(h));

            mainParent.setAttribute("data-largewidth", parseFloat(w));
            mainParent.setAttribute("data-largeheight", parseFloat(h));

            let placeholderimagesize = "medium";
            if (imgNode.parentElement.hasAttribute("data-placeholderimagesize")) placeholderimagesize = imgNode.parentElement.getAttribute("data-placeholderimagesize");
            else if (mainParent.hasAttribute("data-placeholderimagesize")) placeholderimagesize = mainParent.getAttribute("data-placeholderimagesize");
            else {
                let props = this.getProps();
                let property = props && props && props.placeholderimage ? props.placeholderimage : null;
                placeholderimagesize = property && property.placeholderimagesize ? property.placeholderimagesize : placeholderimagesize;
            }
            // let logoImageSizeValue = placeholderimagesize == "small" ? 0.4 : placeholderimagesize == "medium" ? 0.7 : placeholderimagesize == "large" ? 1 : parseFloat(placeholderimagesize);
            let logoImageSizeValue = this.specialGraphicsUtils.getImageSizeSML(placeholderimagesize);
            w = parseFloat(w) * parseFloat(logoImageSizeValue);
            h = parseFloat(h) * parseFloat(logoImageSizeValue);

            if (imgNode.id.includes("phTextNode")) imgNode.removeChild(dummyDom);
            else imgNode.parentElement.removeChild(dummyDom);

            imgNode.parentElement.parentElement.style.width = w + "px";
            imgNode.parentElement.parentElement.style.height = h + "px";
            mainParent.style.width = w + "px";
            mainParent.style.height = h + "px";
            if (mainParent.id.includes("placeHolderParent")) mainParent.style.minHeight = h + "px";
            imgNode.parentElement.style.width = w + "px";
            imgNode.parentElement.style.height = h + "px";
            imgNode.setAttribute("data-width", w);
            imgNode.setAttribute("data-height", h);
            if (imgNode && imgNode.hasAttribute("data-csstext") && imgNode.getAttribute("data-csstext") != "") {
                var imageDimensionRatio = imgNode.width / imgNode.height;
                var canvasDimensionRatio = w / h;
                if (imageDimensionRatio > canvasDimensionRatio) {
                    imgNode.parentElement.style.height = imgNode.height + "px";
                    imgNode.parentElement.parentElement.style.height = imgNode.height + "px";
                    imgNode.style.setProperty("bottom", 0);
                    imgNode.setAttribute("logosizecropheight", imgNode.height);
                }
            } else if (!imgNode.id.includes("phTextNode")) this.specialGraphicsUtils.updateImageReSize(w, h, imgNode);
            if (imgNode.callback) imgNode.callback();
            imgNode.callback = null;
            if (imgNode.id.includes("phTextNode")) {
                mainParent.style.maxHeight = h + "px";
                mainParent.style.height = "auto";
                mainParent.style.minHeight = "unset";

                mainParent.style.maxWidth = w + "px";
                mainParent.style.width = "auto";

                imgNode.parentElement.style.maxWidth = w + "px";
                imgNode.parentElement.style.width = "auto";

                imgNode.parentElement.style.maxHeight = h + "px";
                imgNode.parentElement.style.height = "auto";
                imgNode.parentElement.style.minHeight = "unset";
            }
        }
    }
};
GenericCarouselImagestack.prototype.rePositionTextAndElement = function () {
    this.onTextChangeForAllNodes();
    this.rePositioningTextElement();
};

GenericCarouselImagestack.prototype.textPositionChangeOperation = function (targetParent, pos) {
    if (targetParent) {
        for (let a = 0; a < targetParent.children.length; a++) {
            if (targetParent.children[a].style.position != "absolute") {
                let element = targetParent.children[a];
                let elementId = element.id;
                // console.log("SGG - Childs - " + elementId);
                // let textAlign = pos == "TL" || pos == "ML" || pos == "BL" ? "start" : pos == "TR" || pos == "MR" || pos == "BR" ? "end" : pos == "TM" || pos == "MM" || pos == "BM" ? "center" : "";
                if (elementId && elementId.includes("placeHolderParent")) {
                    element = element.querySelector("[id*='logoContentParent']");
                    elementId = element.id;
                }
                if (elementId.includes("logoContentParent")) {
                    if (element.getElementsByTagName("img").length > 0) {
                        let imageNode = element.getElementsByTagName("img")[0];
                        if (!imageNode.hasAttribute("data-oldimagecropalignment")) imageNode.setAttribute("data-oldimagecropalignment", imageNode.getAttribute("data-imagecropalignment"));
                        imageNode.setAttribute(
                            "data-imagecropalignment",
                            pos == "TL" || pos == "ML" || pos == "BL" ? "left" : pos == "TR" || pos == "MR" || pos == "BR" ? "right" : pos == "TM" || pos == "MM" || pos == "BM" ? "center" : imageNode.hasAttribute("data-oldimagecropalignment") ? imageNode.getAttribute("data-oldimagecropalignment") : "center"
                        );
                        imageNode.removeAttribute("data-style");
                        imageNode.removeAttribute("data-csstext");
                        // console.log("SGG - Logo align - " + imageNode.getAttribute("data-imagecropalignment"));
                        if (imageNode.offsetHeight != 0) this.specialGraphicsUtils.updateImageReSize(imageNode.getAttribute("data-width"), imageNode.getAttribute("data-height"), imageNode);
                    }
                    // } else if (elementId == "sgNumberTextParent") {
                    //     element.style.justifyContent = textAlign == "start" ? "flex-start" : textAlign == "end" ? "flex-end" : "center";
                }
            }
        }
        //Text Element positioning after all text's props change
        this.rePositioningTextElement();
    }
};
GenericCarouselImagestack.prototype.svgLoadCallback = function (responseData) {
    //Loading svg from menu for icon/image background svg global style - only for "contentBackground"
    for (let a = 0; a < responseData.length; a++) {
        let localSvgParent = responseData[a].parent;
        let colorClass = responseData[a] && responseData[a].color ? responseData[a].color : "clsAccentfill";
        if (localSvgParent && localSvgParent.querySelector("[id*='contentBackground']")) {
            let bgNode = localSvgParent.querySelector("[id*='contentBackground']");
            bgNode.classList.remove(colorClass);
            bgNode.classList.add(colorClass);
            var parser = new DOMParser();
            var doc = parser.parseFromString(responseData[a].data, "image/svg+xml");
            bgNode.innerHTML = "";
            bgNode.appendChild(doc.lastChild);
        }
    }
};
GenericCarouselImagestack.prototype.placeholderSvgLoadCallback = function (responseData) {
    //Loading svg from menu for icon/image background svg global style - only for "contentBackground"
    for (let a = 0; a < responseData.length; a++) {
        let localSvgParent = responseData[a].parent;
        let colorClass = responseData[a] && responseData[a].color ? responseData[a].color : "clsAccentfill";
        if (localSvgParent) {
            localSvgParent.classList.remove(colorClass);
            localSvgParent.classList.add(colorClass);
            var parser = new DOMParser();
            var doc = parser.parseFromString(responseData[a].data, "image/svg+xml");
            localSvgParent.innerHTML = "";
            localSvgParent.appendChild(doc.lastChild);
        }
    }
};

//Re position text element
GenericCarouselImagestack.prototype.rePositioningTextElement = function (targetIndex = -1) {
    let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
    for (let i = 0; i < assetParents.length; i++) {
        if (targetIndex == -1 || targetIndex == i) {
            let textInnerParentNode = assetParents[i].querySelector("[id='textInnerParentNode']");

            if (this.sgParent.hasAttribute("singlenode") && this.sgParent.getAttribute("singlenode") == "true" && this.textElement && this.textElement.elementData && this.textElement.elementData.textelementproperties) {
                let textElementStyle = assetParents[i].getAttribute("data-textelementstyle");
                let props = this.textElement.elementData.textelementproperties;
                let textElementSelected = props[textElementStyle] ? props[textElementStyle] : Object.keys(props).length > 0 ? props[Object.keys(props)[0]] : null;
                let target = textElementSelected && textElementSelected.target ? textElementSelected.target : null;
                if (target && target == "title" && assetParents[i].querySelector("[id*='titleTextParent")) textInnerParentNode = assetParents[i].querySelector("[id*='titleTextParent']").parentElement;
                if (target && target == "label" && assetParents[i].querySelector("[id*='titleLabelTextParent")) textInnerParentNode = assetParents[i].querySelector("[id*='titleLabelTextParent']").parentElement;
                if (target && target == "subtitle" && assetParents[i].querySelector("[id*='subTitleTextParent")) textInnerParentNode = assetParents[i].querySelector("[id*='subTitleTextParent']").parentElement;
            }
            this.textElementPositioning(assetParents[i], textInnerParentNode, i);
        }
    }
};
GenericCarouselImagestack.prototype.textFitOnImageResize = function (targetIndex) {
    this.onTextChangeForAllNodes(this.sgParent, targetIndex);
    this.rePositioningTextElement(targetIndex);
};

"use strict";

function GenericCarouselImagestack2(sgParent, sgData, moodName, metadata, styleName = "", isPlayAnimation = true, textElementData, socialiconsData, fontData, objDataToSG) {
    this.specialGraphicsUtils = new window["SpecialGraphicsUtils"]();
    this.specialGraphicsAnimationUtils = new window["SpecialGraphicsAnimationUtils"]();

    let styleData = {};

    let baseSet = {
        title: "h4",
        titleNoSubtitle: "h3",
        subtitle: "p4",
        label: "p3",
        number: "n1",
        introtitle: "h2",
        introtitleNoSubtitle: "h1",
        introsubtitle: "p3",
        introlabel: "p2",
    };
    baseSet = fontData ? fontData : baseSet;
    styleData.fontData = baseSet;
    this.fontData = JSON.parse(JSON.stringify(baseSet));

    baseSet.titleClass = baseSet.title;
    baseSet.subtitleClass = baseSet.subtitle;
    baseSet.labelClass = baseSet.label;
    baseSet.title = " " + baseSet.title + " ";
    baseSet.subtitle = " " + baseSet.subtitle + " ";
    baseSet.label = " " + baseSet.label + " ";
    baseSet.number = " " + baseSet.number + " ";

    this.sgParent = sgParent;
    this.sgSlideType = this.sgParent.dataset.slidetype;

    //Setting all nodes prompt text here
    styleData.titlePrompt = this.sgSlideType == "textstack" ? "Type a Headline" : "Type an image caption";
    styleData.subTitlePrompt = this.sgSlideType == "textstack" ? "A brief explanation about the headline" : "A brief explanation about the image you have used";
    styleData.titleLabelPrompt = "Title label here";

    styleData.styleName = styleName;

    this.socialiconsData = socialiconsData;

    this.sgParent.className = "genericspecialgraphics";

    this.isPlayAnimation = isPlayAnimation;
    this.slideContent = objDataToSG && objDataToSG.slide ? objDataToSG.slide : null;
    this.isPreviewMode = objDataToSG && objDataToSG.isPreviewMode ? objDataToSG.isPreviewMode : false;
    this.oldContent = objDataToSG && objDataToSG.isLoadedSlide ? objDataToSG.isLoadedSlide : null;

    this.assetsLoadComplete = this.assetsLoadComplete.bind(this);
    this.onTextChange = this.onTextChange.bind(this);
    this.changeVariation = this.changeVariation.bind(this);
    this.updateHeightForText = this.updateHeightForText.bind(this);
    this.textFitOnImageResize = this.textFitOnImageResize.bind(this);
    this.logoLoadCallback = this.logoLoadCallback.bind(this);
    this.updateImageResizeOnTypeChange = this.updateImageResizeOnTypeChange.bind(this);
    this.updateImageContrastOnChange = this.updateImageContrastOnChange.bind(this);

    this.sgSlideType = "imagestack";

    this.currentNodeIndex = 1;

    this.setTargetIndex(0, sgParent);
    this.specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL);
    this.specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
    if (this.slideContent) {
        this.slideContent.classList.remove("darkText");
        this.slideContent.classList.remove("lightText");
        this.slideContent.classList.remove("fixedlightText");
        this.slideContent.classList.remove("fixeddarkText");
    }
    if (sgData.length > 2) sgParent.parentElement.parentElement.setAttribute("fulloptions", "true");
    else sgParent.parentElement.parentElement.setAttribute("fulloptions", "false");
    SGBaseClass.call(this, sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, this.fontData, "imagestack", styleData, objDataToSG);
}

GenericCarouselImagestack2.prototype = Object.create(SGBaseClass.prototype);

GenericCarouselImagestack2.prototype.setTargetIndex = function (index = 0, sgParent = null) {
    let localParent = sgParent ? sgParent : this.sgParent;
    let animationDIV = localParent && localParent.parentElement && localParent.parentElement.parentElement ? localParent.parentElement.parentElement : null;
    if (animationDIV && animationDIV.id == "animationDIV") animationDIV.setAttribute("data-target-index", index);
};

GenericCarouselImagestack2.prototype.initSpecialGraphicsCreation = function (doMainFunctions = true, doCompleteCallback = true) {
    this.specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL, this);
    this.specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
    if (!this.isWidget) this.isWidget = false;
    if (this.isWidget == false || (this.objDataToSG && this.objDataToSG.menuChange)) {
        if (!this.oldContent || !doMainFunctions) {
            let carouselImageParent = this.sgParent.querySelector("[id='carouselImageParent']");
            if (!carouselImageParent) {
                carouselImageParent = document.createElement("div");
                carouselImageParent.id = "carouselImageParent";
                carouselImageParent.className = "carouselImageParent";
                carouselImageParent.style.position = "absolute";
                carouselImageParent.style.zIndex = "2";
                carouselImageParent.style.width = "100%";
                carouselImageParent.style.height = "100%";
                carouselImageParent.style.pointerEvents = "none";
                this.sgParent.appendChild(carouselImageParent);
                this.setTextType(carouselImageParent);
            }
            for (let c = 0; c < this.sgData.length; c++) {
                let assetParent = this.createAssetParent(c, this.sgParent);
                // assetParent.setAttribute("iscarousel", "true");
                let imagestackIntro = (this.sgSlideType == "imagestack" || this.sgSlideType == "textstack") && c == 0 && this.sgData.length != 1 ? "introSlide" : "";
                if (imagestackIntro != "") assetParent.classList.add(imagestackIntro);

                //Creating nodes from menu
                let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData && this.metaData ? this.metaData : null;
                if (metaDataBase && (metaDataBase.supportedNodes || metaDataBase.introNodes)) {
                    let supportNode = imagestackIntro != "" && metaDataBase.introNodes ? metaDataBase.introNodes : metaDataBase.supportedNodes;
                    // let intCount = supportNode.length;
                    // for (let i = 0; i < 1; i++) {
                    let nodeObj = supportNode;
                    let nodeParent = this.createNodes(nodeObj, assetParent, c);
                    if (nodeObj.subNodes && nodeParent) this.createNestedNodes(nodeObj.subNodes, nodeParent, c);
                    // }
                }

                let property = metaDataBase && metaDataBase.properties;
                if (metaDataBase && metaDataBase.introproperties && c == 0) property = metaDataBase.introproperties;

                if (property) {
                    let props = property;
                    if (c != 0 && props && props.carousel && assetParent.querySelector("[id='coverImageParent']")) {
                        this.carouselcount = props.carousel.carouselcount ? parseInt(props.carousel.carouselcount) : 4;
                        let commonImageParent = document.createElement("div");
                        commonImageParent.id = "commonImageParent" + c;
                        commonImageParent.className = "commonImageParent";
                        commonImageParent.style.zIndex = this.sgData.length - 1 - c;
                        commonImageParent.style.width = "100%";
                        commonImageParent.style.height = "100%";
                        commonImageParent.style.position = "absolute";
                        commonImageParent.style.pointerEvents = "none";
                        if (carouselImageParent.querySelector("[id='" + commonImageParent.id + "']")) carouselImageParent.querySelector("[id='" + commonImageParent.id + "']").parentElement.removeChild(carouselImageParent.querySelector("[id='" + commonImageParent.id + "']"));
                        carouselImageParent.appendChild(commonImageParent);
                        let coverImageParent = assetParent.querySelector("[id='coverImageParent']");
                        coverImageParent.classList.add("hideNode");
                        // coverImageParent.style.opacity = 0;
                        coverImageParent.style.zIndex = 5 - c;
                        if (props.carousel.bgname) {
                            let imagePath = this.appStaticURL + props.carousel.bgname;
                            let backgroundImage = document.createElement("img");
                            backgroundImage.src = imagePath;
                            backgroundImage.id = "backgroundImage";
                            backgroundImage.className = "backgroundImage";
                            backgroundImage.style.position = "absolute";
                            backgroundImage.style.width = "100%";
                            backgroundImage.style.left = "0px";
                            backgroundImage.style.left = "0px";
                            backgroundImage.style.top = "0px";
                            backgroundImage.style.pointerEvents = "none";
                            backgroundImage.style.userSelect = "none";

                            let isBgCommon = props.carousel.bgcommon && (props.carousel.bgcommon == "true" || props.carousel.bgcommon == true) ? true : false;

                            if (isBgCommon == true && c == 1) {
                                assetParent.parentElement.appendChild(backgroundImage);
                                backgroundImage.style.zIndex = this.sgData.length + 1;
                            } else if (isBgCommon == false) {
                                coverImageParent.appendChild(backgroundImage);
                                let coverParentNode = coverImageParent.querySelector("[id*='coverParent']");
                                if (coverParentNode) coverParentNode.style.zIndex = 1;
                            }
                            if (props.carousel.bgposition) this.specialgraphicsPropertyUtils.updateImagePosition(backgroundImage, props.carousel.bgposition);
                        }
                        let imageCaption = coverImageParent.querySelector("[id*='imageCaption']");
                        if (imageCaption) imageCaption.style.pointerEvents = "var(--textPointerEvent)";

                        commonImageParent.appendChild(coverImageParent);
                        let imageElement = coverImageParent.querySelector("[id='coverimage']");
                        if (imageElement) {
                            imageElement.setAttribute("data-width", parseFloat(coverImageParent.offsetWidth));
                            imageElement.setAttribute("data-height", parseFloat(coverImageParent.offsetHeight));
                            if (imageElement.hasAttribute("data-csstext") && imageElement.getAttribute("data-csstext") != "") {
                            } else this.specialGraphicsUtils.updateImageReSize(imageElement.getAttribute("data-width"), imageElement.getAttribute("data-height"), imageElement);
                        }

                        //Applying mask for images
                        if (props.carousel.bgmask) {
                            let coverParent = commonImageParent.querySelector("[id*='coverParent']");
                            let imagePath = props.carousel.bgmask;
                            let clipPathID = imagePath.substr(imagePath.lastIndexOf("/") + 1);
                            if (c == 1) {
                                let arrAssets = [];
                                arrAssets.push({
                                    assetImageParent: commonImageParent,
                                    url: imagePath,
                                    type: "SVG",
                                    index: c,
                                    doMaskFit: false,
                                    parent: assetParent.parentElement,
                                    clipPathID: clipPathID.replace(".svg", "-clip-path"),
                                });

                                this.specialgraphicsPropertyUtils.loadSvgAssets(arrAssets, this.specialgraphicsPropertyUtils.imageMaskSvgLoadComplete);
                            } else {
                                coverParent.style.clipPath = "url(#" + clipPathID.replace(".svg", "-clip-path") + ")";
                                coverParent.style.setProperty("-webkit-clip-path", "url(#" + clipPathID.replace(".svg", "-clip-path") + ")");
                            }
                        }
                        if (props.carousel.maskposition) {
                            let coverParent = commonImageParent.querySelector("[id*='coverParent']");
                            this.specialgraphicsPropertyUtils.updateImagePosition(coverParent, props.carousel.maskposition);
                        }
                    }
                    if (props && !props.bgshape) props.bgshape = "emptylayoutshape";
                    if (this.objDataToSG?.layoutshapeoutline && props) props.bgshape = this.objDataToSG.layoutshapeoutline;

                    //Creating bgshape
                    if (props?.bgshape && this.slideContent && this.createLayoutShape) this.createLayoutShape("add", props.bgshape, this.slideContent);
                    else if (this.slideContent && this.createLayoutShape) this.createLayoutShape("remove", "", this.slideContent);

                    if (this.layoutShapeAddCallback) {
                        let slideID = this.slideContent && this.slideContent.id ? this.slideContent.id : null;
                        this.layoutShapeAddCallback(slideID);
                    }
                    //Applying textelement style property for slide
                    if (props && props.textelementstyle && this.slideContent) {
                        this.sgParent.parentElement.parentElement.setAttribute("data-textelementstyle", props.textelementstyle);
                        assetParent.setAttribute("data-textelementstyle", props.textelementstyle);
                    } else if (this.sgParent.parentElement && this.sgParent.parentElement.parentElement) {
                        this.sgParent.parentElement.parentElement.removeAttribute("data-textelementstyle");
                        assetParent.removeAttribute("data-textelementstyle");
                    }
                    if (assetParent.hasAttribute("textPosition") && assetParent.querySelector("[id*='textBaseParentNode']")) {
                        let textBaseParent = assetParent.querySelector("[id*='textBaseParentNode']");
                        this.textPositionChangeOperation(textBaseParent.parentElement, assetParent.getAttribute("textPosition"));
                    }
                    this.updateHeightForText(assetParent);
                    let textInnerParentNode = assetParent.querySelector("[id*='textInnerParentNode']");
                    // if (props.number && props.number.depends && props.number.depends == "text" && textInnerParentNode && assetParent.querySelector("[id='sgNumberTextParent']")) {
                    //     //If number depends text then we have to do this
                    //     let numberNode = assetParent.querySelector("[id='sgNumberTextParent']");
                    //     let numberNodecontent = assetParent.querySelector("[id*='sgNumberTextNode']");
                    //     let node = numberNodecontent ? numberNodecontent : numberNode;

                    //     numberNode.parentElement.removeChild(numberNode);
                    //     textInnerParentNode.appendChild(numberNode);
                    //     numberNode.style.position = "relative";
                    //     numberNode.style.left = "unset";
                    //     numberNode.style.right = "unset";
                    //     numberNode.style.top = "unset";
                    //     numberNode.style.bottom = "unset";

                    //     assetParent.style.setProperty("--numberTop", "unset");
                    //     assetParent.style.setProperty("--numberLeft", "unset");
                    //     assetParent.style.setProperty("--numberRight", "unset");
                    //     assetParent.style.setProperty("--numberBottom", "unset");

                    //     let sgTitleNode = assetParent.querySelector("[id='sgTitleNode']");
                    //     let textAlign = sgTitleNode ? window.getComputedStyle(sgTitleNode)["text-align"] : "";
                    //     if (sgTitleNode && node) {
                    //         node.parentElement.style.alignSelf = textAlign == "right" || textAlign == "end" ? "flex-end" : textAlign == "center" ? "center" : "flex-start";
                    //         node.parentElement.style.justifyContent = textAlign == "right" || textAlign == "end" ? "flex-end" : textAlign == "center" ? "center" : "flex-start";
                    //     }
                    // }
                }

                let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
                let deviceBGColorParent = this.sgParent.querySelector("[id='deviceBGColorParent']");
                let deviceBGColorParentInside = deviceImageParentNode ? deviceImageParentNode.querySelector("[id='deviceBGColorParent']") : null;
                if (!deviceBGColorParentInside && deviceBGColorParent) {
                    deviceBGColorParent.parentElement.removeChild(deviceBGColorParent);
                    deviceImageParentNode.appendChild(deviceBGColorParent);
                }

                SGBaseClass.prototype.initSpecialGraphicsCreation.call(this);
                this.onTextChangeForAllNodes(this.sgParent, c);
                if (this.specialGraphicsSlideCreationComplete) this.specialGraphicsSlideCreationComplete(c);
            }
            this.sgParent.removeChild(carouselImageParent);
            this.sgParent.insertBefore(carouselImageParent, this.getAssetParent(this.sgData.length - 1).nextSibling);
        } else {
            this.clearListener(false);
            for (let c = 0; c < this.sgData.length; c++) {
                let assetParent = this.createAssetParent(c, this.sgParent);
                let elements = assetParent ? assetParent.querySelectorAll("[listener='true']") : [];
                for (let a = 0; a < elements.length; a++) {
                    this.setTextFocus(elements[a], false, assetParent, true);
                }
                let clickElements = assetParent ? assetParent.querySelectorAll("[clicklistener='true']") : [];
                for (let a = 0; a < clickElements.length; a++) {
                    if (this.imageDoubleClickEvent) this.eventManager.addEvent(clickElements[a], "dblclick", this.imageDoubleClickEvent);
                }
            }
            let introParent = this.sgParent.querySelector("[id='introParent']");
            if (introParent) {
                let elements = introParent.querySelectorAll("[listener='true']");
                for (let a = 0; a < elements.length; a++) {
                    this.setTextFocus(elements[a], false, introParent, true);
                }
            }
            let textParent = this.sgParent.querySelectorAll("[id*='lytAssetTextParent']");
            if (textParent) {
                for (let b = 0; b < textParent.length; b++) {
                    let elements = textParent[b].querySelectorAll("[listener='true']");
                    for (let a = 0; a < elements.length; a++) {
                        this.setTextFocus(elements[a], false, textParent[b], true);
                    }
                }
            }
            let lottieParent = this.sgParent.querySelectorAll("[data-lottie*='/']");
            for (let a = 0; a < lottieParent.length; a++) {
                let arrAssets = [{ type: "json", url: lottieParent[a].getAttribute("data-lottie"), id: "commonbglottie", parent: lottieParent[a] }];
                this.arrCommonAssets.push({ array: arrAssets, callback: this.lottieLoadCallback });
            }
        }
    } else SGBaseClass.prototype.initSpecialGraphicsCreation.call(this);
    this.specialGraphicsCreationComplete();
};

GenericCarouselImagestack2.prototype.specialGraphicsSlideCreationComplete = function (index) {
    // SGBaseClass.prototype.specialGraphicsSlideCreationComplete.call(this, index);
};
GenericCarouselImagestack2.prototype.applyContrastToText = function (element, property) {
    if (property.contrast && (property.contrast == "true" || property.contrast == true) && element) element.setAttribute("data-supportcontrast", "true");
    else if (element) element.removeAttribute("data-supportcontrast");
};
GenericCarouselImagestack2.prototype.applyChildStyleToParent = function (parent, child) {
    if (parent && child) {
        let childStyle = window.getComputedStyle(child);
        parent.style.width = child.style.width.includes("%") ? child.style.width : childStyle.width;
        parent.style.height = child.style.height.includes("%") ? child.style.height : childStyle.height;
        parent.style.left = childStyle.left;
        parent.style.top = childStyle.top;
        parent.style.position = childStyle.position;
        let margin = childStyle.margin == "" || childStyle.margin == "0px" ? child.style.margin : childStyle.margin;
        let padding = childStyle.padding == "" || childStyle.padding == "0px" ? child.style.padding : childStyle.padding;
        parent.style.margin = margin;
        parent.style.padding = padding;
        child.style.width = "100%";
        child.style.height = "100%";
        child.style.removeProperty("left");
        child.style.removeProperty("top");
        child.style.setProperty("margin", "unset", "important");
        child.style.setProperty("padding", "unset", "important");
    }
};
GenericCarouselImagestack2.prototype.onTextChangeForAllNodes = function (sgParent = null, index = -1) {
    let assetParent = null;
    let indexValue = index != -1 ? index : this.currentNodeIndex - 1;
    if (sgParent) assetParent = sgParent.querySelector("[id='assetParent" + indexValue + "']");
    if (!assetParent) assetParent = this.sgParent.querySelector("[id='assetParent" + indexValue + "']");

    let oldDisplay = assetParent?.style?.display == "none" ? "none" : "";
    if (oldDisplay == "none") assetParent.style.display = "flex";
    let textBaseParentNode = assetParent.querySelector("[id*='textBaseParentNode']");
    if (!textBaseParentNode) textBaseParentNode = assetParent;
    if (textBaseParentNode) {
        textBaseParentNode.style.overflow = "hidden";
        let titleNode = textBaseParentNode.querySelector("[id='sgTitleNode']");
        let subTitleNode = textBaseParentNode.querySelector("[id='sgSubTitleNode']");
        let sgTitleLabelNode = textBaseParentNode.querySelector("[id='sgTitleLabelNode']");

        if (sgTitleLabelNode) {
            let elementPadding = this.specialGraphicsUtils.getPadding(sgTitleLabelNode);
            let labelStyle = window.getComputedStyle(sgTitleLabelNode);
            sgTitleLabelNode.style.maxHeight = parseFloat(labelStyle.lineHeight) + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
            sgTitleLabelNode.parentElement.style.maxHeight = sgTitleLabelNode.style.maxHeight;
        }
        if (subTitleNode) {
            let supportParent = subTitleNode.hasAttribute("data-support") ? true : false;
            subTitleNode.style.removeProperty("max-height");
            if (supportParent != true) subTitleNode.parentElement.style.removeProperty("max-height");
            this.onTextChangeUpdate(subTitleNode, true, assetParent);
        }
        if (titleNode) {
            titleNode.style.removeProperty("max-height");
            titleNode.parentElement.style.removeProperty("max-height");
            this.onTextChangeUpdate(titleNode, true, assetParent);
        }
    }

    if (oldDisplay) assetParent.style.display = oldDisplay;
};

GenericCarouselImagestack2.prototype.onTextChange = function (element) {
    let textNode = element;
    if (textNode && textNode.id.includes("sgTitleLabelNode")) {
        let labelStyle = window.getComputedStyle(textNode);
        let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
        textNode.style.maxHeight = parseFloat(labelStyle.lineHeight) + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
        textNode.parentElement.style.maxHeight = textNode.style.maxHeight;
    } else this.onTextChangeUpdate(textNode);
};

GenericCarouselImagestack2.prototype.onTextChangeUpdate = function (textNode, isStart = false, assetParentNode = null) {
    let assetParent = assetParentNode ? assetParentNode : this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    if (!assetParent) return;
    let textBaseParentNode = assetParent.querySelector("[id*='textBaseParentNode']");
    let supportParent = textNode.hasAttribute("data-support") ? true : false;
    let singleNodeHeight = -1;
    let isSingleNode = false;
    if (supportParent == true && !textBaseParentNode && assetParent.querySelector("[id*='sgTitleNode']")) {
        let titleNode = assetParent.querySelector("[id*='sgTitleNode']");
        textBaseParentNode = textNode.parentElement;
        let oldOverflowValue = textBaseParentNode.style.overflow;
        textBaseParentNode.style.overflow = "hidden";
        singleNodeHeight = parseFloat(window.getComputedStyle(textBaseParentNode).height);
        if (textBaseParentNode.style.height == "auto") {
            textBaseParentNode.style.height = textBaseParentNode.style.maxHeight;
            singleNodeHeight = parseFloat(window.getComputedStyle(textBaseParentNode).height);
            textBaseParentNode.style.height = "auto";
        }
        if (textNode.hasAttribute("data-maxheight")) {
            let textNodeMaxHeight = textNode.getAttribute("data-maxheight");
            if (textNodeMaxHeight.includes("%")) {
                let ph = textNode.parentElement.parentElement.offsetHeight;
                if (textNode.parentElement.parentElement.hasAttribute("fullheight")) ph = parseFloat(textNode.parentElement.parentElement.getAttribute("fullheight"));
                let mhFinal = ph * (parseFloat(textNodeMaxHeight) / 100);
                singleNodeHeight = mhFinal;
            } else {
                singleNodeHeight = parseFloat(textNodeMaxHeight);
            }
            textNode.parentElement.style.maxHeight = singleNodeHeight + "px";
            // textNode.parentElement.style.height = textNodeMaxHeight;
        }
        textBaseParentNode.style.overflow = oldOverflowValue;
        isSingleNode = true;
    }
    if (!textBaseParentNode) {
        textBaseParentNode = textNode.parentElement.parentElement;
        isSingleNode = true;
    }
    if (textBaseParentNode) {
        if (isSingleNode != true && textNode.id.includes("sgTitleLabelNode")) {
            let labelStyle = window.getComputedStyle(textNode);
            let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
            textNode.style.maxHeight = parseFloat(labelStyle.lineHeight) + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
            textNode.parentElement.style.maxHeight = textNode.style.maxHeight;
        } else {
            let removeMaxHeight = this.carouselType && this.carouselType == "onlytitle" ? false : true;
            if (removeMaxHeight) {
                textNode.style.removeProperty("max-height");
                textNode.style.removeProperty("height");
            }
            if (supportParent != true && isSingleNode != true) textNode.parentElement.style.removeProperty("max-height");

            let titleNode = textBaseParentNode.querySelector("[id*='sgTitleNode']");
            let subTitleNode = textBaseParentNode.querySelector("[id*='sgSubTitleNode']");
            let sgTitleLabelNode = textBaseParentNode.querySelector("[id*='sgTitleLabelNode']");
            let textInnerParentNode = textBaseParentNode.querySelector("[id*='textInnerParentNode']");
            let sgNumberTextNode = textBaseParentNode.querySelector("[id*='sgNumberTextNode']");

            let numberStyle = sgNumberTextNode ? window.getComputedStyle(sgNumberTextNode) : null;
            let numberMargin = numberStyle ? parseFloat(numberStyle.height == "auto" ? 0 : numberStyle.height) + parseFloat(numberStyle.marginTop) + parseFloat(numberStyle.marginBottom) : 0;
            numberMargin = isNaN(numberMargin) ? 0 : numberMargin;

            let textParentStyle = textInnerParentNode ? window.getComputedStyle(textInnerParentNode.parentElement) : null;
            let textParentMargin = textParentStyle ? parseFloat(textParentStyle.marginTop) + parseFloat(textParentStyle.marginBottom) : 0;

            let innerParentStyle = textInnerParentNode ? window.getComputedStyle(textInnerParentNode) : null;
            let innerParentMargin = innerParentStyle ? parseFloat(innerParentStyle.marginTop) + parseFloat(innerParentStyle.marginBottom) : 0;

            let labelParentStyle = sgTitleLabelNode ? window.getComputedStyle(sgTitleLabelNode.parentElement) : null;
            let labelStyle = sgTitleLabelNode ? window.getComputedStyle(sgTitleLabelNode) : null;
            let hasLabel = (sgTitleLabelNode && sgTitleLabelNode.style.display == "none") || !sgTitleLabelNode ? false : true;
            let labelMargin = labelParentStyle ? parseFloat(labelParentStyle.marginTop) + parseFloat(labelParentStyle.marginBottom) : 0;
            labelMargin = hasLabel ? (labelStyle ? parseFloat(labelStyle.marginTop) + parseFloat(labelStyle.marginBottom) : 0) + labelMargin : 0;

            let subTitileParentStyle = subTitleNode ? window.getComputedStyle(subTitleNode.parentElement) : null;
            let subTitileStyle = subTitleNode ? window.getComputedStyle(subTitleNode) : null;
            let hasSubtitle = (subTitleNode && subTitleNode.style.display == "none") || !subTitleNode ? false : true;
            let subTitileMargin = subTitileParentStyle ? parseFloat(subTitileParentStyle.marginTop) + parseFloat(subTitileParentStyle.marginBottom) : 0;
            subTitileMargin = hasSubtitle ? (subTitileStyle ? parseFloat(subTitileStyle.marginTop) + parseFloat(subTitileStyle.marginBottom) : 0) + subTitileMargin : 0;

            let titileParentStyle = titleNode ? window.getComputedStyle(titleNode.parentElement) : null;
            let titileMargin = titileParentStyle ? parseFloat(titileParentStyle.marginTop) + parseFloat(titileParentStyle.marginBottom) : 0;

            let textBaseHeight = parseFloat(singleNodeHeight) > 0 ? parseFloat(singleNodeHeight) : parseFloat(window.getComputedStyle(textBaseParentNode).height);
            if (textBaseParentNode && textBaseParentNode.hasAttribute("fullheight")) textBaseHeight = parseFloat(textBaseParentNode.getAttribute("fullheight"));
            if (window.getComputedStyle(textBaseParentNode).height == "" && textBaseParentNode.style.maxHeight != "" && textBaseParentNode.style.maxHeight.includes("px")) textBaseHeight = parseFloat(textBaseParentNode.style.maxHeight);
            let maxHeight = window.getComputedStyle(textBaseParentNode).maxHeight;
            if (maxHeight != "" && maxHeight != "0px" && !isNaN(parseFloat(maxHeight))) if (maxHeight.includes("px")) textBaseHeight = parseFloat(maxHeight);
            let isCarousel = assetParent && assetParent.id.includes("lytAssetTextParent") ? true : false;
            if (maxHeight != "" && maxHeight != "0px" && !isNaN(parseFloat(maxHeight)) && isCarousel == false) {
                if (maxHeight.includes("px")) textBaseHeight = parseFloat(maxHeight);
                else if (maxHeight.includes("%")) {
                    let oldParentHeight = null;
                    if (textBaseParentNode.parentElement && textBaseParentNode.parentElement.style.height == "auto" && textBaseParentNode.parentElement.hasAttribute("fullheight")) {
                        oldParentHeight = textBaseParentNode.parentElement.style.height;
                        textBaseParentNode.parentElement.style.height = textBaseParentNode.parentElement.getAttribute("fullheight");
                    }
                    let oldBkupH = null;
                    if (textBaseParentNode.parentElement.id == "introParent" && (textBaseParentNode.parentElement.style.height == "" || textBaseParentNode.parentElement.style.height == "auto")) {
                        oldBkupH = textBaseParentNode.parentElement.style.height;
                        textBaseParentNode.parentElement.style.height = window.getComputedStyle(textBaseParentNode.parentElement).maxHeight;
                    }
                    let oldParentH = textBaseParentNode.style.height;
                    textBaseParentNode.style.height = textBaseParentNode.style.maxHeight;
                    let hh = parseFloat(window.getComputedStyle(textBaseParentNode).height);
                    if (hh > 0 && !isNaN(hh)) textBaseHeight = hh;
                    textBaseParentNode.style.height = oldParentH;
                    if (oldParentHeight) textBaseParentNode.parentElement.style.height = oldParentHeight;
                    if (oldBkupH != null) textBaseParentNode.parentElement.style.height = oldBkupH;
                }
            }
            //removing margin/padding things on total base height
            let textParentHeight =
                textBaseHeight - (isNaN(labelMargin) ? 0 : labelMargin) - (isNaN(subTitileMargin) ? 0 : subTitileMargin) - (isNaN(titileMargin) ? 0 : titileMargin) - (isNaN(innerParentMargin) ? 0 : innerParentMargin) - (isNaN(textParentMargin) ? 0 : textParentMargin) - (isNaN(numberMargin) ? 0 : numberMargin);
            let titleHeight = titleNode?.scrollHeight > 0 ? titleNode.scrollHeight : !titleNode || titleNode?.offsetHeight == 0 ? 0 : titleNode.style.maxHeight != "" && titleNode.style.display != "none" ? parseFloat(titleNode.style.maxHeight) : window.getComputedStyle(titleNode).height;
            let subTitleHeight = subTitleNode?.scrollHeight > 0 ? subTitleNode.scrollHeight : !subTitleNode || subTitleNode?.offsetHeight == 0 ? 0 : subTitleNode.style.maxHeight != "" && subTitleNode.style.display != "none" ? parseFloat(subTitleNode.style.maxHeight) : window.getComputedStyle(subTitleNode).height;
            let lableHeight = !sgTitleLabelNode || sgTitleLabelNode?.offsetHeight == 0 ? 0 : sgTitleLabelNode.style.maxHeight != "" && sgTitleLabelNode.style.display != "none" ? parseFloat(sgTitleLabelNode.style.maxHeight) : window.getComputedStyle(sgTitleLabelNode).height;
            //calculating total current text height
            let totalTextHeight = parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight);

            let lineHeight = window.getComputedStyle(textNode).lineHeight;
            let fontsize = window.getComputedStyle(textNode).fontSize;
            lineHeight = isNaN(parseFloat(lineHeight)) ? parseFloat(fontsize) * 1.2 : parseFloat(lineHeight);
            let noLines = Math.max(textNode.parentElement.offsetHeight / lineHeight, 1);
            let offDifference = noLines - parseInt(noLines);
            let lines = offDifference > 0.9 ? parseInt(noLines) + 1 : parseInt(noLines);

            //If text height increase total height we have doing fit logic
            if (typeof totalTextHeight == "string") totalTextHeight = parseFloat(totalTextHeight);
            if (typeof textParentHeight == "string") textParentHeight = parseFloat(textParentHeight);
            totalTextHeight = totalTextHeight.toFixed(1);
            textParentHeight = textParentHeight.toFixed(1);
            if (typeof totalTextHeight == "string") totalTextHeight = parseFloat(totalTextHeight);
            if (typeof textParentHeight == "string") textParentHeight = parseFloat(textParentHeight);
            let commonRemainingHeight = 0;
            if (totalTextHeight > textParentHeight) {
                let targetNodeHeight = textNode.id.includes("sgTitleNode")
                    ? parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : textNode.id.includes("sgSubTitleNode")
                    ? parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight);
                let remainingHeight = textParentHeight - targetNodeHeight;
                if (isSingleNode) remainingHeight = textParentHeight;
                commonRemainingHeight = remainingHeight;
                if (lines == 1) remainingHeight = lineHeight;

                let linesFinal = remainingHeight / lineHeight;
                let offDiff = linesFinal - parseInt(linesFinal);
                linesFinal = offDiff > 0.9 ? parseInt(linesFinal) + 1 : parseInt(linesFinal);

                let heightFinal = linesFinal * lineHeight;
                heightFinal = heightFinal == 0 ? lineHeight : heightFinal;

                textNode.style.removeProperty("max-height");
                textNode.style.maxHeight = heightFinal + "px";
                if (!textNode.hasAttribute("data-maxheight")) textNode.parentElement.style.removeProperty("max-height");
                // }
            } else {
                let targetNodeHeight = textNode.id.includes("sgTitleNode")
                    ? parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : textNode.id.includes("sgSubTitleNode")
                    ? parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight);
                let remainingHeight = textParentHeight - targetNodeHeight;
                if (isSingleNode) remainingHeight = textParentHeight;

                commonRemainingHeight = remainingHeight;
            }

            textNode.style.removeProperty("min-height");
            DiagramResizeUtils.commonFontResize(totalTextHeight, textParentHeight, commonRemainingHeight, textNode, textNode.parentElement, this.objDataToSG.fontClassLists, true);

            if (isSingleNode == true) textNode.parentElement.style.removeProperty("height");

            this.onTextUpdate(textNode, isSingleNode);
        }
    }
};

GenericCarouselImagestack2.prototype.loop = function (lines, lineHeight, textNode, textParentHeight, titleNode, subTitleNode, sgTitleLabelNode) {
    //Loop and fitting the text inside max avaiable height
    lines = lines - 1;
    if (lines == 0) return;
    let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
    let newHeight = lines * lineHeight + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom);
    textNode.style.maxHeight = newHeight + "px";
    // textNode.parentElement.style.maxHeight = newHeight + "px";

    let titleHeight = !titleNode ? 0 : titleNode.style.maxHeight != "" && titleNode.style.display != "none" ? parseFloat(titleNode.style.maxHeight) : window.getComputedStyle(titleNode).height;
    let subTitleHeight = !subTitleNode ? 0 : subTitleNode.style.maxHeight != "" && subTitleNode.style.display != "none" ? parseFloat(subTitleNode.style.maxHeight) : window.getComputedStyle(subTitleNode).height;
    let lableHeight = !sgTitleLabelNode ? 0 : sgTitleLabelNode.style.maxHeight != "" && sgTitleLabelNode.style.display != "none" ? parseFloat(sgTitleLabelNode.style.maxHeight) : window.getComputedStyle(sgTitleLabelNode).height;
    let totalTextHeight = parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight);
    if (textParentHeight < totalTextHeight) this.loop(lines, lineHeight, textNode, textParentHeight, titleNode, subTitleNode, sgTitleLabelNode);
};

GenericCarouselImagestack2.prototype.onTextUpdate = function (textNode) {
    if (textNode.parentElement.offsetHeight <= textNode.offsetHeight) {
        let lineHeight = window.getComputedStyle(textNode).lineHeight;
        let fontsize = window.getComputedStyle(textNode).fontSize;
        lineHeight = isNaN(parseFloat(lineHeight)) ? parseFloat(fontsize) * 1.2 : parseFloat(lineHeight);
        let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
        let noLines = Math.max(textNode.parentElement.offsetHeight / lineHeight, 1);
        let offDifference = noLines - parseInt(noLines);
        let lines = offDifference > 0.9 ? parseInt(noLines) + 1 : parseInt(noLines);
        textNode.style.maxHeight = lines * lineHeight + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
        textNode.style.overflow = "hidden";
        textNode.parentElement.style.removeProperty("max-height");
    }
};

GenericCarouselImagestack2.prototype.updateHeightForText = function (assetParent) {
    let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData && this.metaData ? this.metaData : null;
    if (metaDataBase && (metaDataBase.properties || metaDataBase.introproperties)) {
        let propData = assetParent.classList.contains("introSlide") && metaDataBase.introproperties ? metaDataBase.introproperties : metaDataBase.properties;
        let property = propData.text;
        if (property && property.maxheight) {
            let textBaseParentNode = assetParent.querySelector("[id*='textBaseParentNode']");
            let titleLabelTextParent = assetParent.querySelector("[id='titleLabelTextParent']");
            let sgTitleLabelNode = assetParent.querySelector("[id='sgTitleLabelNode']");

            let textParent = textBaseParentNode ? textBaseParentNode.parentElement : null;
            let parentHeight = textParent ? parseFloat(window.getComputedStyle(textParent).height) : 0;
            if (textParent && textParent.hasAttribute("fullheight")) parentHeight = parseFloat(textParent.getAttribute("fullheight"));
            if (!isNaN(parentHeight) && parentHeight > 0) return;
            if (textBaseParentNode) textBaseParentNode.style.display = "none";
            let remainingHeight = 0;
            if (textParent) {
                // textParent.style.height = "auto";

                let mainParentDisplay = textParent.parentElement.style.display;
                textParent.parentElement.style.removeProperty("display");
                let currentHeight = parseFloat(window.getComputedStyle(textParent).height);
                textParent.parentElement.style.display = mainParentDisplay;

                remainingHeight = parentHeight - currentHeight;
                // textParent.style.height = parentHeight + "px";
            }
            let titleTextParent = assetParent.querySelector("[id='titleTextParent']");
            let sgTitleNode = assetParent.querySelector("[id='sgTitleNode']");

            let subTitleTextParent = assetParent.querySelector("[id='subTitleTextParent']");
            let sgSubTitleNode = assetParent.querySelector("[id='sgSubTitleNode']");

            if (titleLabelTextParent) titleLabelTextParent.style.removeProperty("max-height");
            if (sgTitleLabelNode) sgTitleLabelNode.style.removeProperty("max-height");
            if (titleTextParent) titleTextParent.style.removeProperty("max-height");
            if (sgTitleNode) sgTitleNode.style.removeProperty("max-height");
            if (subTitleTextParent) subTitleTextParent.style.removeProperty("max-height");
            if (sgSubTitleNode) sgSubTitleNode.style.removeProperty("max-height");

            if (textBaseParentNode && remainingHeight != 0) {
                textBaseParentNode.style.maxHeight = remainingHeight + "px";
                textBaseParentNode.style.removeProperty("display");
            }
        }
    }
};
//Set slide type
GenericCarouselImagestack2.prototype.setSlideType = function (type) {
    this.sgSlideType = type;
};

GenericCarouselImagestack2.prototype.specialGraphicsCreationComplete = function () {
    //Check and update font class depends on number of lines
    let arrTitleNodes = this.sgParent.querySelectorAll("[id*='sgTitleNode']");
    if (this.isPresent != true)
        for (let a = 0; a < arrTitleNodes.length; a++) {
            if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(arrTitleNodes[a]);
        }

    if (this.isPlayAnimation == false && this.isPresent != true) this.eventManager.dispatch("positionchangecallback", 1 - 1);
    if (this.isPresent != true) {
        this.currentNodeIndex = 2;
        this.setupCarouselPositions();
        // let slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
        // if (slideDomContentGroup) this.changeVariation(slideDomContentGroup);

        //Updating image positions for all images
        // let carouselImageParent = this.sgParent.querySelector("[id='carouselImageParent']");
        // this.specialGraphicsUtils.updateImagePositions(carouselImageParent);

        // let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
        // let indexValue = assetParent0.classList.contains("introSlide") && assetParent0.style.display != "none" && assetParent0.style.opacity != "0" && assetParent0.style.opacity != 0 ? this.currentNodeIndex : 0;
        // this.floaterNavigation(indexValue);

        // let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
        let finalShow = this.sgParent?.parentElement?.parentElement?.getAttribute("data-ogdata-finalshow_0")?.includes("intro") ? true : false;
        // let indexValue = assetParent0.classList.contains("introSlide") && finalShow ? this.currentNodeIndex : 0;

        if (!finalShow) this.currentNodeIndex = 2;
        this.floaterNavigation(0);

        // this.setTargetIndex();

        //Text Element positioning after all text's props change
        this.rePositioningTextElement();
    }
    SGBaseClass.prototype.specialGraphicsCreationComplete.call(this);
};

//Assets load complete
GenericCarouselImagestack2.prototype.assetsLoadComplete = function (responseData) {
    for (let i = 0; i < responseData.length; i++) {
        let name = "";
        if (responseData[i].id.includes("svgdata")) name = "Illustration";
        let parentNode = responseData[i].parent ? responseData[i].parent : this.sgParent;
        if (name == "Illustration" && parentNode.querySelectorAll("[id='svgElementDiv']").length > 0) {
            let arrSvgParent = parentNode.querySelectorAll("[id='svgElementDiv']");
            for (let a = 0; a < arrSvgParent.length; a++) {
                arrSvgParent[a].innerHTML = responseData[i].data;
                this.applySVGData(arrSvgParent[a]);
            }
        }
    }
};
GenericCarouselImagestack2.prototype.applySVGData = function (svgChild) {
    if (svgChild.getElementsByTagName("svg").length > 0) {
        let svgDOM = svgChild.getElementsByTagName("svg")[0];
        svgDOM.style.pointerEvents = "none";
        svgDOM.style.width = "100%";
        svgDOM.style.height = "100%";
    }
};
GenericCarouselImagestack2.prototype.createNestedNodes = function (subNodes, nodeParentToInsert, currentIndex = 0) {
    for (let j = 0; j < subNodes.length; j++) {
        let nodeObj = subNodes[j];
        let nodeParent = this.createNodes(nodeObj, nodeParentToInsert, currentIndex);
        if (nodeObj.subNodes && nodeParent) {
            this.createNestedNodes(nodeObj.subNodes, nodeParent, currentIndex);
        }
    }
};
GenericCarouselImagestack2.prototype.createNodes = function (nodeObj, nodeParent, currentIndex = 0) {
    let name = nodeObj.name;
    switch (name) {
        case "contentMainParent":
        case "contentNode":
        case "contentNode1":
        case "contentNode2":
        case "contentNode3":
        case "contentNode4":
        case "contentNode5":
        case "contentNode6":
        case "secContentNode":
        case "secContentNode1":
        case "secContentNode2":
        case "secContentNode3":
        case "secContentNode4":
        case "secContentNode5":
        case "secContentNode6":
            return this.createContentNode(nodeParent, nodeObj, name);
        case "img":
            this.createImageNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "tit":
        case "text":
            this.createTitleNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "title":
            this.createSingleTitleNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "subtitle":
            this.createSingleSubTitleNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "label":
            this.createSingleLabelNode(nodeParent, nodeObj.flexvalue, currentIndex);
            break;
        case "num":
            this.createNumberNode(nodeParent, currentIndex);
            break;
        case "bgimage1":
            this.createBgImage(1, currentIndex);
            break;
        case "bgimage2":
            this.createBgImage(2, currentIndex);
            break;
        case "presetimage":
            this.createPresetImage(currentIndex);
            break;
        case "pointimage":
        case "pointimage1":
        case "pointimage2":
        case "pointimage3":
        case "pointimage4":
        case "pointimage5":
        case "pointimage6":
        case "pointimage7":
        case "pointimage8":
        case "pointimage9":
        case "pointimage10":
            this.createPointImage(nodeParent, currentIndex);
            break;
        case "duplicateimage":
            this.createDuplicateImage(currentIndex);
            break;
        case "shape1":
        case "shape2":
        case "shape3":
        case "shape4":
        case "shape5":
            let propertyValue = null;
            let propName = currentIndex == 0 ? "introproperties" : "properties";
            let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData && this.metaData ? this.metaData : null;
            if (metaDataBase && metaDataBase[propName] && metaDataBase[propName] && metaDataBase[propName][name]) propertyValue = metaDataBase[propName][name];
            this.createShapes(nodeParent, name, propertyValue, currentIndex);
            break;
        case "placeholderimage":
            this.createPlaceHolder(nodeParent, currentIndex);
            break;
        default:
            break;
    }
};
GenericCarouselImagestack2.prototype.getProps = function () {
    //Get slide properties
    let props = null;
    let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData && this.metaData ? this.metaData : null;
    let secondaryProp = null;
    if (metaDataBase && metaDataBase.properties) secondaryProp = metaDataBase.properties;
    if (metaDataBase && metaDataBase.properties) props = metaDataBase.properties;
    let returnVal = props ? props : secondaryProp;
    if (returnVal && ((returnVal.text && returnVal.text.textstyle) || (returnVal.number && returnVal.number.numberstyle) || (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle))) {
        let textPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.textproperties ? this.objDataToSG.sgMoodsData.textproperties : null;
        let numberPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.numberproperties ? this.objDataToSG.sgMoodsData.numberproperties : null;
        let placeholderPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.placeholderimageproperties ? this.objDataToSG.sgMoodsData.placeholderimageproperties : null;

        if (returnVal.text && returnVal.text.textstyle && textPropFromMood && textPropFromMood[returnVal.text.textstyle]) {
            let newValue = textPropFromMood[returnVal.text.textstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.text[key] = newValue[key];
            });
            delete returnVal.text.textstyle;
        }
        if (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle && placeholderPropFromMood && placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle]) {
            let newValue = placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.placeholderimage[key] = newValue[key];
            });
            delete returnVal.placeholderimage.placeholderimagestyle;
        }
        if (returnVal.number && returnVal.number.numberstyle && numberPropFromMood && numberPropFromMood[returnVal.number.numberstyle]) {
            let newValue = numberPropFromMood[returnVal.number.numberstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.number[key] = newValue[key];
            });
            delete returnVal.number.numberstyle;
        }
    }
    return returnVal;
};
GenericCarouselImagestack2.prototype.getIntroProps = function () {
    //Get intro slide properties
    let props = null;
    let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData && this.metaData ? this.metaData : null;
    let secondaryProp = null;
    if (metaDataBase && metaDataBase.introproperties) secondaryProp = metaDataBase.introproperties;
    if (metaDataBase && metaDataBase.introproperties) props = metaDataBase.introproperties;
    let returnVal = props ? props : secondaryProp ? secondaryProp : this.getProps();
    if (returnVal && ((returnVal.text && returnVal.text.textstyle) || (returnVal.number && returnVal.number.numberstyle) || (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle))) {
        let textPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.textproperties ? this.objDataToSG.sgMoodsData.textproperties : null;
        let numberPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.numberproperties ? this.objDataToSG.sgMoodsData.numberproperties : null;
        let placeholderPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.placeholderimageproperties ? this.objDataToSG.sgMoodsData.placeholderimageproperties : null;

        if (returnVal.text && returnVal.text.textstyle && textPropFromMood && textPropFromMood[returnVal.text.textstyle]) {
            let newValue = textPropFromMood[returnVal.text.textstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.text[key] = newValue[key];
            });
            delete returnVal.text.textstyle;
        }
        if (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle && placeholderPropFromMood && placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle]) {
            let newValue = placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.placeholderimage[key] = newValue[key];
            });
            delete returnVal.placeholderimage.placeholderimagestyle;
        }
        if (returnVal.number && returnVal.number.numberstyle && numberPropFromMood && numberPropFromMood[returnVal.number.numberstyle]) {
            let newValue = numberPropFromMood[returnVal.number.numberstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.number[key] = newValue[key];
            });
            delete returnVal.number.numberstyle;
        }
    }
    return returnVal;
};
GenericCarouselImagestack2.prototype.createContentNode = function (parent, props, id) {
    if (id == "contentMainParent" && parent.querySelector("[id='contentMainParent']")) parent.querySelector("[id='contentMainParent']").parentElement.removeChild(parent.querySelector("[id='contentMainParent']"));
    let nodeParent = document.createElement("div");
    nodeParent.className = id;
    nodeParent.style.pointerEvents = "none";
    nodeParent.setAttribute("id", id);
    parent.appendChild(nodeParent);
    nodeParent.style.display = "flex";
    this.setTextType(nodeParent);

    if (props && props.class) {
        nodeParent.className = id + "  " + props.class;
        if (nodeParent.classList.contains("valign_s") || nodeParent.classList.contains("valign_c") || nodeParent.classList.contains("valign_e")) {
            let direction = window.getComputedStyle(nodeParent).flexDirection;
            if (direction == "row") nodeParent.style.alignItems = nodeParent.classList.contains("valign_c") ? "center" : nodeParent.classList.contains("valign_e") ? "flex-end" : "flex-start";
            else nodeParent.style.justifyContent = nodeParent.classList.contains("valign_c") ? "center" : nodeParent.classList.contains("valign_e") ? "flex-end" : "flex-start";
        }
        if (nodeParent.classList.contains("halign_s") || nodeParent.classList.contains("halign_c") || nodeParent.classList.contains("halign_e")) {
            let direction = window.getComputedStyle(nodeParent).flexDirection;
            if (direction == "row") nodeParent.style.justifyContent = nodeParent.classList.contains("halign_c") ? "center" : nodeParent.classList.contains("halign_e") ? "flex-end" : "flex-start";
            else nodeParent.style.alignItems = nodeParent.classList.contains("halign_c") ? "center" : nodeParent.classList.contains("halign_e") ? "flex-end" : "flex-start";
        }
    } else nodeParent.style.display = "block";
    if (props.positionvalue) nodeParent.style.position = props.positionvalue;
    if (props.zorder) nodeParent.style.zIndex = props.zorder;
    if (props.order) nodeParent.style.order = props.order;
    if (props.flexvalue) nodeParent.style.flex = props.flexvalue;
    if (props.position && props.position.split(",").length == 4) this.specialgraphicsPropertyUtils.updatePosition(nodeParent, props.position);

    if (props.padding) this.specialgraphicsPropertyUtils.updatePadding(props.padding, nodeParent, true);
    if (props.margin) this.specialgraphicsPropertyUtils.updateMargin(props.margin, nodeParent, true);
    if (props.maxwidth) {
        // nodeParent.style.maxWidth = props.maxwidth + (props.maxwidth.includes("px") || props.maxwidth.includes("%") ? "" : "px");
        nodeParent.style.width = props.maxwidth + (props.maxwidth.includes("px") || props.maxwidth.includes("%") ? "" : "px");
        nodeParent.setAttribute("fullwidth", window.getComputedStyle(nodeParent).width);
    }
    if (props.maxheight) {
        let oldH = null;
        if (nodeParent.parentElement.hasAttribute("fullheight")) {
            oldH = nodeParent.parentElement.style.height;
            nodeParent.parentElement.style.height = nodeParent.parentElement.getAttribute("fullheight");
        }

        let oldHeight = nodeParent.style.height;
        nodeParent.style.height = props.maxheight + (props.maxheight.includes("px") || props.maxheight.includes("%") ? "" : "px");
        nodeParent.style.maxHeight = props.maxheight + (props.maxheight.includes("px") || props.maxheight.includes("%") ? "" : "px");
        let h = window.getComputedStyle(nodeParent).height;
        nodeParent.style.height = oldHeight;
        nodeParent.setAttribute("fullheight", h);

        if (oldH && nodeParent.parentElement.hasAttribute("fullheight")) nodeParent.parentElement.style.height = oldH;
    }
    return nodeParent;
};
GenericCarouselImagestack2.prototype.createPresetImage = function (currentIndex) {
    //Create preset image
    let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (!deviceImageParentNode) {
        deviceImageParentNode = document.createElement("div");
        deviceImageParentNode.id = "deviceImageParentNode";
        deviceImageParentNode.className = "deviceImageParentNode";
        this.sgParent.insertBefore(deviceImageParentNode, assetParent0);
    }

    this.createPresetImageNode(deviceImageParentNode);
    this.applyPresetImgeProperty(currentIndex);
};
GenericCarouselImagestack2.prototype.applyPresetImgeProperty = function (currentIndex) {
    //Apply preset image properties
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props && props && props.presetimage && this.sgParent.querySelector("[id='presetImageParent']")) {
        let presetImageParent = this.sgParent.querySelector("[id='presetImageParent']");
        let presetImageNode = this.sgParent.querySelector("[id='presetImageNode']");
        if (props.presetimage.positionvalue && presetImageParent) presetImageParent.style.position = props.presetimage.positionvalue;
        if (props.presetimage.imageurl && presetImageNode) presetImageNode.src = this.appStaticURL + props.presetimage.imageurl;
        this.specialgraphicsPropertyUtils.applyImageBaseProps(props.presetimage, deviceImageParentNode, presetImageParent, "presetimage");
    }
};
GenericCarouselImagestack2.prototype.createBgImage = function (imageIndex = 1, currentIndex) {
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let type = "img";
    let src = "";
    let bgImageProperty = null;
    if (props && props && props["bgimage" + imageIndex]) bgImageProperty = props["bgimage" + imageIndex];
    if (bgImageProperty && bgImageProperty.type && bgImageProperty.type == "video") type = "video";
    if (bgImageProperty && bgImageProperty.imageurl) src = bgImageProperty.imageurl;

    let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
    // let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let oldImage = this.sgParent.querySelector("[id*='bgImage" + (imageIndex == 1 ? "" : imageIndex) + "Node']");
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (!oldImage) {
        if (!deviceImageParentNode) {
            deviceImageParentNode = document.createElement("div");
            deviceImageParentNode.id = "deviceImageParentNode";
            deviceImageParentNode.className = "deviceImageParentNode";
            this.sgParent.insertBefore(deviceImageParentNode, assetParent0);
        }

        oldImage = this.createBgImageNode(deviceImageParentNode, (imageIndex == 1 ? "" : imageIndex) + "Node", type, src);
        oldImage.setAttribute("data-fit", "false");
    }
    this.applyBgImageProperty(imageIndex, bgImageProperty, currentIndex);
};
GenericCarouselImagestack2.prototype.applyBgImageProperty = function (imageIndex, bgImageProperty, currentIndex) {
    if (!bgImageProperty) {
        let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
        if (props && props && props["bgimage" + imageIndex]) bgImageProperty = props["bgimage" + imageIndex];
    }
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let oldImage = this.sgParent.querySelector("[id*='bgImage" + (imageIndex == 1 ? "" : imageIndex) + "Node']");
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (bgImageProperty && oldImage) {
        let bgImage = oldImage;
        if (bgImageProperty.positionvalue && bgImage) bgImage.style.position = bgImageProperty.positionvalue;
        if (bgImageProperty.imageurl && bgImage) bgImage.src = this.appStaticURL + bgImageProperty.imageurl;
        this.specialgraphicsPropertyUtils.applyImageBaseProps(bgImageProperty, deviceImageParentNode, bgImage, "--bg");

        if (bgImageProperty.contrast && bgImageProperty.contrast == "fullbg") {
            if (bgImage) {
                bgImage.setAttribute("contrast", "fullbg");
                this.eventManager.dispatch("applyImageContrast", bgImage, assetParent);
            }
        } else if (bgImageProperty.contrast && bgImageProperty.contrast == "halfbg") {
            if (bgImage) {
                bgImage.setAttribute("contrast", "halfbg");
                this.eventManager.dispatch("applyImageContrast", bgImage, assetParent, true);
            }
        } else if (this.slideContent) {
            this.slideContent.classList.remove("fixedlightText");
            this.slideContent.classList.remove("fixeddarkText");
        }
        if (bgImageProperty.position) {
            let arrPosition = bgImageProperty.position.split(",");
            if (arrPosition.length >= 4 && deviceImageParentNode) {
                let bg = "--bg" + (imageIndex == 1 ? "" : "2");
                deviceImageParentNode.style.setProperty(bg + "Left", arrPosition[0] + (arrPosition[0].includes("px") || arrPosition[0].includes("%") || arrPosition[0].includes("auto") ? "" : "px"));
                deviceImageParentNode.style.setProperty(bg + "Top", arrPosition[1] + (arrPosition[1].includes("px") || arrPosition[1].includes("%") || arrPosition[1].includes("auto") ? "" : "px"));
                deviceImageParentNode.style.setProperty(bg + "Width", arrPosition[2] + (arrPosition[2].includes("px") || arrPosition[2].includes("%") || arrPosition[2].includes("auto") ? "" : "px"));
                deviceImageParentNode.style.setProperty(bg + "Height", arrPosition[3] + (arrPosition[3].includes("px") || arrPosition[3].includes("%") || arrPosition[3].includes("auto") ? "" : "px"));
            }
        }
    }
};
GenericCarouselImagestack2.prototype.createDuplicateImage = function (currentIndex) {
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    if (props) this.specialgraphicsPropertyUtils.applyDuplicateImageProperties(props, assetParent, currentIndex, true);
};
GenericCarouselImagestack2.prototype.createPointImage = function (parent, currentIndex) {
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let nodes = this.sgParent.querySelectorAll("[id*='pointImageParent']");
    if (props && props && currentIndex != 0 && nodes.length == 0 && this.sgData.length - 1 == currentIndex) {
        let arrAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
        for (let a = 1; a < arrAssetParent.length; a++) {
            let innerParent = arrAssetParent[a].querySelector("[id='" + parent.id + "']");
            this.createPointImageNode(innerParent, a);
        }

        for (let a = 1; a < arrAssetParent.length; a++) {
            let imageProperty = props.pointimage;
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["pointimage" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((a - 1) % loopIndex) + 1;
                imageProperty = props["pointimage" + ind];
            }
            let pointImageParentNode = arrAssetParent[a].querySelector("[id*='pointImageParent']");
            if (pointImageParentNode && imageProperty.imageurl) {
                let pointImageNode = pointImageParentNode.querySelector("[id*='pointImageNode']");
                pointImageNode.src = this.appStaticURL + imageProperty.imageurl;
                pointImageNode.setAttribute("data-fit", "false");
                this.specialgraphicsPropertyUtils.applyImageBaseProps(imageProperty, assetParent, pointImageParentNode, "pointimage");
                if (imageProperty.positionvalue) arrAssetParent[a].style.setProperty("--pointImagePosition", imageProperty.positionvalue);
            }
        }
    }
};
GenericCarouselImagestack2.prototype.createNumberNode = function (parent, currentIndex) {
    //number
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let numberContent = this.objDataToSG && this.objDataToSG.numberFormat ? this.specialGraphicsUtils.getSeqMoodStyle(this.objDataToSG.numberFormat, currentIndex) : null;
    if (!assetParent.classList.contains("introSlide")) this.createNumberTextNode(parent, currentIndex, numberContent);

    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props && props) {
        let numberProperty = props.number;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["number" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                numberProperty = props["number" + ind];
            }
        }
        if (numberProperty) {
            let covernumber = assetParent.querySelector("[id*='sgNumberTextNode']");
            let sgNumberTextParent = assetParent.querySelector("[id='sgNumberTextParent']");
            if (numberProperty.positionvalue && covernumber) {
                covernumber.style.position = numberProperty.positionvalue;
                if (sgNumberTextParent) sgNumberTextParent.style.position = numberProperty.positionvalue;
            }
            if (numberProperty.line && (numberProperty.line == "true") | (numberProperty.line == true) && covernumber) covernumber.parentElement.classList.add("numberline");
            let textAlign = null;
            if (numberProperty.halign && (covernumber || sgNumberTextParent)) {
                let hAlign = numberProperty.halign == "right" || numberProperty.halign == "end" ? "flex-end" : numberProperty.halign == "center" || numberProperty.valign == "middle" ? "center" : "flex-start";
                // covernumber.style.alignSelf = hAlign;
                covernumber.style.justifyContent = hAlign;
                textAlign = hAlign == "flex-end" ? "end" : hAlign == "center" ? "center" : "start";
            }
            if (numberProperty.valign && (covernumber || sgNumberTextParent)) {
                let vAlign = numberProperty.valign == "bottom" || numberProperty.valign == "end" ? "flex-end" : numberProperty.valign == "center" || numberProperty.valign == "middle" ? "center" : "flex-start";
                if (sgNumberTextParent) sgNumberTextParent.style.alignItems = vAlign;
                else covernumber.style.alignItems = vAlign;
            }
            this.specialgraphicsPropertyUtils.applyNumberProperties(props, covernumber, assetParent, 0, true);
            let node = covernumber;
            if (numberProperty.linecount && node) {
                node.setAttribute("data-linecount", numberProperty.linecount);
                this.specialGraphicsUtils.doFontFitForCss(node, this.sgParent);
            }
            if (numberProperty.rotate && sgNumberTextParent) {
                let lineHeight = parseFloat(window.getComputedStyle(covernumber)["line-height"]);
                lineHeight = isNaN(lineHeight) ? "40" : lineHeight;
                covernumber.style.minWidth = lineHeight + "px";
                covernumber.classList.add("covernumberRotation");
                covernumber.setAttribute("rotatednode", "true");
                covernumber.style.justifyContent = "flex-end";
                if (numberProperty.rotate.includes("-90")) covernumber.style.setProperty("--rotateTextRotation", "180deg");
                if (covernumber && textAlign) covernumber.style.setProperty("--rotateTextAlign", textAlign);
                this.specialGraphicsUtils.doFontFitForCss(covernumber, this.sgParent, null, null, null, true);
            }
            if (numberProperty.prefix && node) {
                node.setAttribute("prefix", numberProperty.prefix);
                node.innerText.replace(numberProperty.prefix, "");
                node.innerText = numberProperty.prefix + " " + node.innerText;
            }
            if (numberProperty.suffix && node) {
                node.setAttribute("suffix", numberProperty.suffix);
                node.innerText.replace(numberProperty.suffix, "");
                node.innerText = node.innerText + " " + numberProperty.suffix;
            }
            this.applyContrastToText(node, numberProperty);
        }
    }
};
GenericCarouselImagestack2.prototype.createTitleNode = function (parent, flexValue = "", currentIndex) {
    //Text Nodes - "tit"
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let textInnerParent = this.createTextBase(parent, currentIndex);
    let textBaseParent = assetParent.querySelector("[id*='textBaseParentNode']");
    if (textBaseParent) {
        let zOrderValue = 0;
        let textZIndex = parseFloat(window.getComputedStyle(textBaseParent).zIndex);
        let parentZIndex = parseFloat(window.getComputedStyle(parent).zIndex);
        if (!isNaN(parentZIndex) && parentZIndex > 0) zOrderValue = parentZIndex;
        if (!isNaN(textZIndex) && textZIndex > 0) zOrderValue = zOrderValue + textZIndex;

        textBaseParent.style.zIndex = zOrderValue;
    }
    if (flexValue && flexValue != "") textBaseParent.style.flex = flexValue;
    this.createTitleSet(textInnerParent, currentIndex, assetParent);
    this.applyTextProperty(currentIndex, textBaseParent);
    if (this.objDataToSG && this.objDataToSG.theme && this.objDataToSG.theme) {
        let title = textInnerParent.querySelector("[id*='sgTitleNode']");
        let subTitle = textInnerParent.querySelector("[id*='sgSubTitleNode']");
        let label = textInnerParent.querySelector("[id*='sgTitleLabelNode']");
        let titleColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "title");
        let subtitleColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "subtitle");
        let labelColor = this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "label");
        if (titleColor && title && !title.hasAttribute("data-supportcontrast")) {
            title.style.setProperty("color", titleColor);
            title.setAttribute("data-color", titleColor);
        }
        if (subtitleColor && subTitle && !subTitle.hasAttribute("data-supportcontrast")) {
            subTitle.style.setProperty("color", subtitleColor);
            subTitle.setAttribute("data-color", subtitleColor);
        }
        if (labelColor && label && !label.hasAttribute("data-supportcontrast")) {
            label.style.setProperty("color", labelColor);
            label.setAttribute("data-color", labelColor);
        }
    }
};
GenericCarouselImagestack2.prototype.applyTextProperty = function (currentIndex, textBaseParent) {
    //Applying Text Property
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    if (props && assetParent) {
        let textProperty = props.text;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["text" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                textProperty = props["text" + ind];
            }
        }

        let defaultProp = null;
        let textPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.textproperties ? this.objDataToSG.sgMoodsData.textproperties : null;
        if (textPropFromMood) {
            const keys = Object.keys(textPropFromMood);
            keys.forEach((key) => {
                let element = textPropFromMood[key];
                if (element && element.default && (element.default == "true" || element.default == true)) defaultProp = element;
            });
        }
        let newTextProperty = !textProperty ? defaultProp : textProperty;
        if (newTextProperty) {
            this.specialgraphicsPropertyUtils.applyTextProperties(newTextProperty, assetParent, currentIndex, true, true);
            let isSupportTextPosition = newTextProperty.positionchange && (newTextProperty.positionchange == "true" || newTextProperty.positionchange == true) ? true : false;
            //Applying text position
            let textPosition = this.sgData[currentIndex] && this.sgData[currentIndex]["titletextposition"] ? this.sgData[currentIndex]["titletextposition"] : newTextProperty && newTextProperty.defaulttextposition ? newTextProperty.defaulttextposition : "sgMM";
            if (textPosition && textPosition != "" && textBaseParent && isSupportTextPosition) {
                this.specialGraphicsUtils.removeTextPositionClass(textBaseParent.parentElement);
                textBaseParent.parentElement.classList.add("sg" + textPosition.replace("sg", ""));
                assetParent.setAttribute("textPosition", textPosition);
            }
        }
    }
};
GenericCarouselImagestack2.prototype.createSingleTitleNode = function (parent, flexValue = "", currentIndex) {
    //Text Nodes - title only
    let textParent = this.createSingleTitle(parent, currentIndex);
    if (flexValue && flexValue != "") textParent.style.flex = flexValue;

    this.applyTitleProperty(currentIndex);
};
GenericCarouselImagestack2.prototype.applyTitleProperty = function (currentIndex) {
    //Apply single Title node property
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props && props) {
        let textProperty = props.title;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["title" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                textProperty = props["title" + ind];
            }
        }
        this.applySingleNodeProps(currentIndex, "titleTextParent", "sgTitleNode", textProperty);
    }
};
GenericCarouselImagestack2.prototype.createSingleSubTitleNode = function (parent, flexValue = "", currentIndex) {
    //Text Nodes - title only
    let textParent = this.createSingleSubTitle(parent, currentIndex);
    if (flexValue && flexValue != "") textParent.style.flex = flexValue;

    this.applySubTitleProperty(currentIndex);
};
GenericCarouselImagestack2.prototype.applySubTitleProperty = function (currentIndex) {
    //Apply single subtitle node property
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props && props) {
        let textProperty = props.subtitle;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["subtitle" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                textProperty = props["subtitle" + ind];
            }
        }
        this.applySingleNodeProps(currentIndex, "subTitleTextParent", "sgSubTitleNode", textProperty);
    }
};
GenericCarouselImagestack2.prototype.createSingleLabelNode = function (parent, flexValue = "", currentIndex) {
    //Text Nodes - title only
    let textParent = this.createSingleLabel(parent, currentIndex);
    if (flexValue && flexValue != "") textParent.style.flex = flexValue;

    this.applyLabelProperty(currentIndex);
};
GenericCarouselImagestack2.prototype.applyLabelProperty = function (currentIndex) {
    //Apply single title label proprty
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    if (props && props) {
        let textProperty = props.label;
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (props["label" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                textProperty = props["label" + ind];
            }
        }
        this.applySingleNodeProps(currentIndex, "titleLabelTextParent", "sgTitleLabelNode", textProperty);
    }
};
GenericCarouselImagestack2.prototype.createImageNode = function (parent, flexValue = "", currentIndex) {
    //Coverimage - "img"
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    let coverParent = this.createCoverImageParent(parent, currentIndex);
    let imageProperty = this.getImageProperty(currentIndex);

    let isSvgSupport = imageProperty?.supportsvg && imageProperty.supportsvg == "false" ? false : true;
    this.createCoverImageNode(coverParent, currentIndex, "generic", isSvgSupport);

    let coverImageParent = assetParent.querySelector("[id*='coverImageParent']");
    if (coverImageParent) {
        if (flexValue && flexValue != "") coverImageParent.style.flex = flexValue;
        let zOrderValue = 0;
        let imageZIndex = parseFloat(window.getComputedStyle(coverImageParent).zIndex);
        let parentZIndex = parseFloat(window.getComputedStyle(parent).zIndex);
        if (!isNaN(parentZIndex) && parentZIndex > 0) zOrderValue = parentZIndex;
        if (!isNaN(imageZIndex) && imageZIndex > 0) zOrderValue = zOrderValue + imageZIndex;

        coverImageParent.style.zIndex = zOrderValue;
    }

    if (imageProperty) {
        if (coverParent && this.sgData[currentIndex].coverimageprompt) coverParent.setAttribute("data-node-graphic-text", this.sgData[currentIndex].coverimageprompt);

        let props = imageProperty;
        this.specialgraphicsPropertyUtils.applyImageProperties(props, assetParent, currentIndex, props);
        if (props.positionvalue && coverImageParent) coverImageParent.style.position = props.positionvalue;
        this.sgParent.style.setProperty("--coverImageShadow", assetParent.style.getPropertyValue("--coverImageShadow").trim());
        this.sgParent.style.setProperty("--coverImageBorder", assetParent.style.getPropertyValue("--coverImageBorder").trim());
        this.sgParent.style.setProperty("--coverImageRadius", assetParent.style.getPropertyValue("--coverImageRadius").trim());
        this.sgParent.style.setProperty("--coverImageFilter", assetParent.style.getPropertyValue("--coverImageFilter").trim());
        this.sgParent.style.setProperty("--coverImageBlend", assetParent.style.getPropertyValue("--coverImageBlend").trim());
        this.sgParent.style.setProperty("--coverParentImageFilter", assetParent.style.getPropertyValue("--coverParentImageFilter").trim());

        if (props.positionvalue && coverImageParent) coverImageParent.style.position = props.positionvalue;
        if (props.padding && props.padding.split(",").length == 4 && coverImageParent) this.specialgraphicsPropertyUtils.updateMargin(props.padding, coverImageParent);
        if (props.contrast && props.contrast == "fullbg") {
            let imageNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            if (imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent);
        } else if (props.contrast && props.contrast == "halfbg") {
            let imageNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            if (imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent, true);
        } else if (this.slideContent) {
            this.slideContent.classList.remove("fixedlightText");
            this.slideContent.classList.remove("fixeddarkText");
        }
        if (props.margin) this.specialgraphicsPropertyUtils.updateMargin(props.margin, coverImageParent);
        if (props.overlayindex && this.applyOverlayToImageSG) {
            let imageNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            if (imageNode && !imageNode.hasAttribute("data-csstext")) this.applyOverlayToImageSG(imageNode, props.overlayindex);
        }
        if (props.overlayname && this.applyOverlayToImageSG) {
            let imageNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            if (imageNode && !imageNode.hasAttribute("data-csstext")) this.applyOverlayToImageSG(imageNode, null, props.overlayname);
        }
        if (props.globalstyle && coverImageParent) {
            coverImageParent.classList.remove(props.globalstyle);
            coverImageParent.classList.add(props.globalstyle);
            coverImageParent.classList.add("clsSingleColorParent");

            let percentValue = window.getComputedStyle(coverImageParent).getPropertyValue("--cutomNodeBorderWidthPercent").trim();
            percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
            let sourceNode = coverImageParent.querySelector("[data-nodetype='iconHolder'],[data-nodetype='imageHolder']");
            if (sourceNode) coverImageParent.style.setProperty("--customNodeBorderImageWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
        }
        if (props.vposition && coverImageParent) {
            let align = props.vposition == "top" || props.vposition == "start" ? "Top" : props.vposition == "center" || props.vposition == "middle" ? "Center" : "Bottom";
            coverImageParent.classList.add("coverAlign" + align);
        }

        // if (props.supportsvg) {
        let arrAssets = [];
        let hasSVG = this.sgData[currentIndex].coverimage.includes(".svg");
        // let path = this.sgData[currentIndex].coverimage.includes(".svg") ? this.sgData[currentIndex].coverimage : "genericassets/illustrations/industry_agnostic/breaker_slide/breaker_slide_1.svg";
        // this.sgData[currentIndex].coverimage = path;

        if (props.supportsvg && props.supportsvg == "false" && hasSVG) {
            this.sgData[currentIndex].coverimage = this.appStaticURL + "genericassets/placeholderimages/coverimage.jpg";
            this.sgParent.removeAttribute("data-svgsupport");
            hasSVG = false;
            if (this.sgParent.parentElement.parentElement) {
                let slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
                if (slideDomContentGroup.getElementsByTagName("coverimage").length > 0) slideDomContentGroup.getElementsByTagName("coverimage")[0].setAttribute("data-src", this.sgData[currentIndex].coverimage);
            }
        }

        if (hasSVG == true) {
            arrAssets.push({ url: this.sgData[currentIndex].coverimage, id: "svgdata", type: "SVG", parent: coverImageParent });
            // this.arrCommonAssets.push({ array: arrAssets, callback: this.assetsLoadComplete });
            this.loadAssets(arrAssets, this.assetsLoadComplete);
        }

        let svgElementDiv = assetParent.querySelector("[id='svgElementDiv']");
        let coverimage = assetParent.querySelector("[data-target-id='coverimage']");
        if (svgElementDiv && coverimage) {
            svgElementDiv.style.display = hasSVG ? "flex" : "none";
            coverimage.style.display = hasSVG ? "none" : "flex";
        }
        // } else if (this.sgData[currentIndex].coverimage.includes(".svg")) {
        //     this.sgData[currentIndex].coverimage = this.appStaticURL + "genericassets/placeholderimages/coverimage.jpg";
        //     let svgElementDiv = this.sgParent.querySelector("[id='svgElementDiv']");
        //     let coverimage = this.sgParent.querySelector("[data-target-id='coverimage']");
        //     if (svgElementDiv) svgElementDiv.style.display = "none";
        //     if (coverimage) {
        //         coverimage.style.display = "block";
        //         coverimage.src = this.sgData[currentIndex].coverimage;
        //     }
        // }
        if (props.imageurl && coverImageParent) {
            let coverimage = coverImageParent.querySelector("[data-target-id='coverimage']");
            coverimage.src = this.appStaticURL + props.imageurl;
            this.specialGraphicsUtils.updateImageReSize(coverimage.getAttribute("data-width"), coverimage.getAttribute("data-height"), coverimage);
        }
        if (props.contentBG) {
            let arrAssets = [];
            arrAssets.push({ parent: coverImageParent, type: "svg", url: props.contentBG.value, id: props.contentBG.id });
            this.loadAssets(arrAssets, this.svgLoadCallback);
            // this.arrCommonAssets.push({ array: arrAssets, callback: this.svgLoadCallback });
        }
        if (props.resize && props.resize == "enable" && coverImageParent && coverImageParent.querySelector("[data-target-id='coverimage']")) {
            let imgNode = coverImageParent.querySelector("[data-target-id='coverimage']");
            // imgNode.setAttribute("imageresize", "enable");
            // coverImageParent.setAttribute("imageresize", "enable");
            if (this.sgData[currentIndex] && this.sgData[currentIndex].coverimagesize && coverImageParent) {
                //Implement image size change from floter
                // let sizeV = this.sgData[currentIndex].coverimagesize;
                // let multipleValue = sizeV == "small" ? 0.4 : sizeV == "medium" ? 0.7 : sizeV == "large" ? 1 : parseFloat(sizeV);
                let multipleValue = this.specialGraphicsUtils.getImageSizeSML(this.sgData[currentIndex].coverimagesize);
                let largeW = parseFloat(coverImageParent.getAttribute("data-largewidth"));
                let newW = largeW * multipleValue;
                if (newW > 0) coverImageParent.style.width = newW + "px";
            }
        }
        // let captionPosition = this.sgData[currentIndex].coverimagecaptionposition ? this.sgData[currentIndex].coverimagecaptionposition : props.captionposition ? props.captionposition : "bottomleft";
        // if (captionPosition && coverImageParent && coverImageParent.querySelector("[id*='imageCaption']")) {
        //     let imageCaption = coverImageParent.querySelector("[id*='imageCaption']");
        //     let cls =
        //         captionPosition == "topleft" || captionPosition == "captionTL"
        //             ? "captionTL"
        //             : captionPosition == "topright" || captionPosition == "captionTR"
        //             ? "captionTR"
        //             : captionPosition == "bottomright" || captionPosition == "captionBR"
        //             ? "captionBR"
        //             : "captionBL";
        //     imageCaption.classList.remove("captionTL");
        //     imageCaption.classList.remove("captionTR");
        //     imageCaption.classList.remove("captionBL");
        //     imageCaption.classList.remove("captionBR");
        //     imageCaption.classList.add(cls);
        // }
        this.specialGraphicsUtils.setImageCaptionPosition(coverImageParent, currentIndex, this.sgData, props);
    } else if (this.slideContent) {
        this.slideContent.classList.remove("fixedlightText");
        this.slideContent.classList.remove("fixeddarkText");
    }
};

GenericCarouselImagestack2.prototype.getImageProperty = function (currentIndex) {
    let mainProps = currentIndex == 0 ? this.getIntroProps() : this.getProps();

    let imageProperty = mainProps && mainProps && mainProps.image ? mainProps.image : null;
    if (mainProps && mainProps) {
        if (currentIndex != 0) {
            let loopIndex = 0;
            for (let a = 1; a <= 10; a++) {
                if (mainProps["image" + a]) loopIndex = loopIndex + 1;
            }
            let ind = 1;
            if (loopIndex > 0) {
                ind = ((currentIndex - 1) % loopIndex) + 1;
                imageProperty = mainProps["image" + ind];
            }
        }
    }
    return imageProperty;
};
GenericCarouselImagestack2.prototype.applySingleNodeProps = function (currentIndex, textParentId, textNodeId, textProp) {
    this.sgParent.setAttribute("singlenode", "true");
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");
    if (textProp && assetParent && assetParent.querySelector("[id='" + textParentId + "']")) {
        let sgTextNodeParent = assetParent.querySelector("[id='" + textParentId + "']");
        let sgTextNode = assetParent.querySelector("[id='" + textNodeId + "']");
        sgTextNodeParent.style.pointerEvents = "auto";
        sgTextNodeParent.style.order = "unset";
        if (textProp.position) this.specialgraphicsPropertyUtils.updatePosition(sgTextNodeParent, textProp.position);
        if (textProp.maxwidth) sgTextNodeParent.style.maxWidth = textProp.maxwidth + (textProp.maxwidth.includes("px") || textProp.maxwidth.includes("%") ? "" : "px");
        if (textProp.maxheight) {
            let mh = textProp.maxheight + (textProp.maxheight.includes("px") || textProp.maxheight.includes("%") ? "" : "px");
            sgTextNodeParent.style.maxHeight = mh;
            sgTextNode.setAttribute("data-maxheight", mh);
        }
        if (textProp.positionvalue) sgTextNodeParent.style.position = textProp.positionvalue;
        else sgTextNodeParent.style.position = "relative";
        if (textProp.padding) this.specialgraphicsPropertyUtils.updatePadding(textProp.padding, sgTextNodeParent, true);
        if (textProp.margin) this.specialgraphicsPropertyUtils.updateMargin(textProp.margin, sgTextNodeParent);
        if (textProp.zorder) sgTextNodeParent.style.zIndex = textProp.zorder;
        sgTextNode.classList.remove("titleColorBg");
        sgTextNode.classList.remove("subtitleColorBg");
        sgTextNode.classList.remove("transparentBg");
        if (textProp.support && textProp.support == "parent") {
            sgTextNode.setAttribute("data-support", "parent");
            this.createTextElement(sgTextNodeParent.parentElement);
            sgTextNode.setAttribute("data-parentid", sgTextNodeParent.parentElement.id);
        } else sgTextNode.removeAttribute("data-support");
        if (textProp.color) sgTextNode.classList.add(textProp.color);
        else sgTextNode.classList.add("transparentBg");

        if (textProp.titlecustomcolor) sgTextNode.style.setProperty("color", "rgba(var(--" + textProp.titlecustomcolor + "-color-rgb),1)", "important");
        if (textProp.bgcolor) sgTextNodeParent.style.backgroundColor = "rgba(var(--" + textProp.bgcolor + "-color-rgb),1)";
        if (textProp.bgshadow) sgTextNodeParent.style.boxShadow = textProp.bgshadow;
        if (textProp.contrast) this.applyContrastToText(sgTextNodeParent, textProp);
        if (textProp.halign) {
            let alignValue = textProp.halign == "end" || textProp.halign == "right" ? "flex-end" : textProp.halign == "center" || textProp.halign == "middle" ? "center" : "flex-start";
            let align = textProp.halign == "end" || textProp.halign == "right" ? "end" : textProp.halign == "center" || textProp.halign == "middle" ? "center" : "start";
            assetParent.style.setProperty("--textAlign", align);
            assetParent.style.setProperty("--textJustifyContent", alignValue);
        }
        if (textProp.valign) {
            let alignValue = textProp.valign == "bottom" || textProp.valign == "end" ? "flex-end" : textProp.valign == "center" || textProp.valign == "middle" ? "center" : "flex-start";
            sgTextNodeParent.style.alignItems = alignValue;
        }
        if (textProp.opacity) {
            sgTextNodeParent.style.opacity = textProp.opacity;
            this.specialGraphicsUtils.setOpacityAttribute(sgTextNodeParent);
        }
        if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(sgTextNode);
    }
};
GenericCarouselImagestack2.prototype.changeVariation = function (slideDomContentGroup, updateOnlyVariation = false) {
    let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
    this.updateIntroVisibility();
    for (let i = 0; i < assetParents.length; i++) {
        let subTitleNode = assetParents[i].querySelector("[id='sgSubTitleNode']");
        let oldDisplay = subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "";

        this.specialGraphicsUtils.changeVariation(assetParents[i], slideDomContentGroup, i);
        //Updating image positions for all images
        this.specialGraphicsUtils.updateImagePositions(assetParents[i]);

        if (updateOnlyVariation == false) {
            let titleNode = assetParents[i].querySelector("[id='sgTitleNode']");
            let newDisplay = subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "";
            if (titleNode && subTitleNode && newDisplay != oldDisplay && this.fontData.title.length <= 2) {
                let isSubtitleEnabled = window.getComputedStyle(subTitleNode)["display"] == "none" ? false : true;
                let isIntro = assetParents[i].classList.contains("introSlide") == true ? true : false;
                titleNode.classList.remove(this.fontData[(isIntro ? "intro" : "") + "title"]);
                titleNode.classList.remove(this.fontData[(isIntro ? "intro" : "") + "titleNoSubtitle"]);

                this.specialGraphicsUtils.removeAllFontClass(titleNode);

                let fontClass = isSubtitleEnabled == false ? this.fontData[(isIntro ? "intro" : "") + "titleNoSubtitle"] : this.fontData[(isIntro ? "intro" : "") + "title"];
                if (!fontClass) fontClass = isSubtitleEnabled == false ? this.fontData["titleNoSubtitle"] : this.fontData["title"];
                titleNode.classList.add(fontClass);
                titleNode.setAttribute("data-font", fontClass);
                titleNode.style.removeProperty("min-height");
                titleNode.style.removeProperty("max-height");
                titleNode.style.removeProperty("font-size");

                titleNode.setAttribute("defaultsize", parseFloat(window.getComputedStyle(titleNode)["font-size"]));
                if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(titleNode);
                if (titleNode.hasAttribute("user-font-size")) {
                    this.specialGraphicsUtils.removeAllFontClass(titleNode);
                    titleNode.classList.add(titleNode.getAttribute("user-font-size"));
                    // titleNode.style.setProperty("font-size", titleNode.getAttribute("user-font-size") + "px", "important");
                }
                this.specialGraphicsUtils.doCheckMaxHeight(titleNode, this.sgParent);
                this.specialGraphicsUtils.doFontFitForCss(titleNode, this.sgParent);
            }
            this.updateHeightForText(assetParents[i]);
            this.onTextChangeForAllNodes(assetParents[i], i);
            let textInnerParentNode = assetParents[i].querySelector("[id='textInnerParentNode']");
            this.textElementPositioning(assetParents[i], textInnerParentNode, i);
        }
    }
    this.updatenavFloater();
};
GenericCarouselImagestack2.prototype.updateIntroVisibility = function (moveToStart = false, index = 0) {
    let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
    if (this.sgParent && this.sgParent.parentElement && this.sgParent.parentElement.parentElement && assetParents.length > 0) {
        let animationDIV = this.sgParent.parentElement.parentElement;
        let showIntro = animationDIV.getAttribute("data-ogdata-finalshow_0")?.split(",")?.includes("intro") ? "true" : "false";
        if (showIntro == "false" && assetParents[0].classList.contains("introSlide")) {
            if (animationDIV.hasAttribute("inlinefloaterchange") && animationDIV.getAttribute("inlinefloaterchange") == "true") {
            } else {
                assetParents[0].style.display = "none";
                this.currentNodeIndex = 2;
                this.floaterNavigation(0);
            }
        } else {
            assetParents[0].style.removeProperty("display");
            if (moveToStart == true) {
                this.currentNodeIndex = index;
                this.floaterNavigation(0);
            }
        }
    }
};

GenericCarouselImagestack2.prototype.floaterNavigation = function (index, isFromAnimation = false, animType = "") {
    this.currentNodeIndex = this.currentNodeIndex + index;
    let assetParent = this.sgParent.querySelector("[id='assetParent0']");
    let assetParent1 = this.sgParent.querySelector("[id='assetParent1']");
    let carouselImageParent = this.sgParent.querySelector("[id='carouselImageParent']");
    let backgroundImageCommon = this.sgParent.querySelector("[id*='backgroundImage']");
    backgroundImageCommon = backgroundImageCommon && backgroundImageCommon.parentElement.id == "coverImageParent" ? null : backgroundImageCommon;
    if (this.currentNodeIndex - 1 == 0) {
        assetParent.style.opacity = 1;
        assetParent.removeAttribute("active");
        this.assetParentDisplayChange("none");
        if (backgroundImageCommon && isFromAnimation == false) backgroundImageCommon.style.display = "none";
        if (carouselImageParent) carouselImageParent.style.setProperty("--textPointerEvent", "none");
        assetParent.style.setProperty("--textPointerEvent", "auto");
        if (assetParent1) assetParent1.setAttribute("active", "false");
    } else {
        if (backgroundImageCommon && isFromAnimation == false) backgroundImageCommon.style.removeProperty("display");
        this.assetParentDisplayChange("flex");
        assetParent.style.opacity = 0;
        this.sgParent.style.setProperty("--numberOpacity", this.currentNodeIndex - 1 == 0 ? 0 : 1);
        if (carouselImageParent) carouselImageParent.style.setProperty("--textPointerEvent", "auto");
        assetParent.style.setProperty("--textPointerEvent", "none");

        for (let a = 1; a < this.sgData.length; a++) {
            let textBaseParentNode = this.sgParent.querySelector("[id='textBaseParentNode" + a + "']");
            let commonImageParent = this.sgParent.querySelector("[id='commonImageParent" + a + "']");
            let assetParent = this.sgParent.querySelector("[id='assetParent" + a + "']");
            let sgNumberTextParent = assetParent ? assetParent.querySelector("[id='sgNumberTextParent']") : null;
            let placeHolderParent = assetParent ? assetParent.querySelector("[id*='placeHolderParent']") : null;
            let shape1 = assetParent ? assetParent.querySelector("[id*='shape1']") : null;
            let shape2 = assetParent ? assetParent.querySelector("[id*='shape2']") : null;
            let shape3 = assetParent ? assetParent.querySelector("[id*='shape3']") : null;
            let shape4 = assetParent ? assetParent.querySelector("[id*='shape4']") : null;
            let shape5 = assetParent ? assetParent.querySelector("[id*='shape5']") : null;
            // if (a == this.currentNodeIndex - 1 && textBaseParentNode) assetParent.style.pointerEvents = "all";
            // else if (textBaseParentNode)
            assetParent.style.pointerEvents = "none";

            if (a == this.currentNodeIndex - 1) assetParent.removeAttribute("active");
            else assetParent.setAttribute("active", "false");

            if (textBaseParentNode) {
                textBaseParentNode.style.opacity = a == this.currentNodeIndex - 1 ? 1 : 0;
                textBaseParentNode.style.pointerEvents = a == this.currentNodeIndex - 1 ? "auto" : "none";
                textBaseParentNode.style.setProperty("--textPointerEvent", a == this.currentNodeIndex - 1 ? "auto" : "none");
            }
            if (commonImageParent) commonImageParent.style.setProperty("--textPointerEvent", a == this.currentNodeIndex - 1 ? "auto" : "none");
            if (shape1 && isFromAnimation == false) shape1.style.opacity = a == this.currentNodeIndex - 1 ? 1 : 0;
            if (shape2 && isFromAnimation == false) shape2.style.opacity = a == this.currentNodeIndex - 1 ? 1 : 0;
            if (shape3 && isFromAnimation == false) shape3.style.opacity = a == this.currentNodeIndex - 1 ? 1 : 0;
            if (shape4 && isFromAnimation == false) shape4.style.opacity = a == this.currentNodeIndex - 1 ? 1 : 0;
            if (shape5 && isFromAnimation == false) shape5.style.opacity = a == this.currentNodeIndex - 1 ? 1 : 0;
            if (sgNumberTextParent) sgNumberTextParent.style.opacity = a == this.currentNodeIndex - 1 ? 1 : 0;
            if (placeHolderParent && animType != "goto") placeHolderParent.style.opacity = a == this.currentNodeIndex - 1 ? 1 : 0;
        }
        if (animType == "") this.setupCarouselPositions(false, index == -1 ? true : false);
    }
    if (animType == "") {
        this.updatenavFloater();
        this.eventManager.dispatch("positionchangecallback", this.currentNodeIndex - 1);
    }
};

GenericCarouselImagestack2.prototype.updatenavFloater = function () {
    if (this.isPlayAnimation == false && this.isPresent != true) {
        let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
        if (assetParent0 && assetParent0.classList.contains("introSlide") && this.updateNavFloaterIndex) {
            let isIntroHide = this.sgParent?.parentElement?.parentElement?.getAttribute("data-ogdata-finalhide_0")?.split(",")?.includes("intro");
            let isVisible = isIntroHide ? -1 : 0;
            let slideID = this.slideContent && this.slideContent.id ? this.slideContent.id : null;
            this.updateNavFloaterIndex(this.currentNodeIndex + isVisible, slideID, isVisible, this.currentNodeIndex - 1 + isVisible);
        }
    }
};

GenericCarouselImagestack2.prototype.gotoAndStopFirstNode = function (completeCallback, type, slideContent, indexValue = -1) {
    let hasEmptyIntro = this.checkIntroAnimation();
    this.currentNodeIndex = indexValue > -1 ? indexValue : hasEmptyIntro == true ? 2 : 1;
    if (hasEmptyIntro == true) {
        this.updateCarouselOpacity(1, 1, "", true);
        this.setupCarouselPositions(false, false, true);
    } else this.updateCarouselOpacity(0, 0, "intro", true);

    let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
    for (let i = 0; i < assetParents.length; i++) {
        let carouselImageParent = this.sgParent.querySelector("[id='carouselImageParent']");
        if (carouselImageParent) {
            let moodAnimationData = carouselImageParent.querySelectorAll("[class*='moodanimation']");
            for (let a = 0; a < moodAnimationData.length; a++) {
                if (moodAnimationData[a].id.includes("coverImageParent")) {
                    moodAnimationData[a].classList.remove("moodanimation");
                    moodAnimationData[a].removeAttribute("data-animation");
                }
            }
        }
    }

    this.floaterNavigation(0, true, "goto");

    this.eventManager.dispatch("positionchangecallback", (hasEmptyIntro == true ? 2 : 1) - 1);
    if (hasEmptyIntro == false && this.getAssetParent(1)) {
        let assetParent = this.getAssetParent(1);
        assetParent.setAttribute("playshapeanimation", "false");
    }
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1);
};
GenericCarouselImagestack2.prototype.hideAnimation = function (completeCallback) {
    if (this.isHeroImage() != true) this.updateShowHideInfo(this.currentNodeIndex - 1, false);
    else if (this.currentNodeIndex == 1) this.currentNodeIndex = this.currentNodeIndex + 1;
    setTimeout(() => {
        completeCallback ? completeCallback() : "";
    }, 2000);
    // this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1, "moodsutil", true);
};
GenericCarouselImagestack2.prototype.updateShowHideInfo = function (index, isShow = true) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + index + "']");
    // if (!isShow) assetParent.style.opacity = 1;
    assetParent.classList.remove(isShow == true ? "hidesg" : "showsg");
    assetParent.classList.add(isShow == true ? "showsg" : "hidesg");
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (this.currentNodeIndex == 1 && this.isPlayAnimation == false && deviceImageParentNode) deviceImageParentNode.style.opacity = 0;
    else if (deviceImageParentNode && this.currentNodeIndex != 1) deviceImageParentNode.style.opacity = 1;
};
GenericCarouselImagestack2.prototype.next = function (completeCallback) {
    this.sgParent.setAttribute("dotransition", "false");
    let oldIndex = this.currentNodeIndex - 1 < 0 ? 0 : this.currentNodeIndex - 1;
    this.currentNodeIndex = this.currentNodeIndex + 1;
    if (this.currentNodeIndex > this.sgData.length) return;
    this.sgParent.removeAttribute("hasemptyintro");

    //HIDE ANIMATION
    this.updateShowHideInfo(oldIndex, false);
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", this.isPlayAnimation ? completeCallback : null, this.isPlayAnimation, this.eventManager, oldIndex, "moodsutilintermediate");
    if (this.currentNodeIndex > 1) this.showDevice(true);
    //SHOW ANIMATION
    this.updateShowHideInfo(this.currentNodeIndex - 1, true);
    let showParent = this.getAssetParent(this.currentNodeIndex - 1);
    if (showParent && showParent.querySelector("[id*='textBaseParentNode']")) showParent.querySelector("[id*='textBaseParentNode']").style.opacity = 1;
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", this.isPlayAnimation ? completeCallback : null, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1, "moodsutilintermediate");

    if (this.isPlayAnimation == false) {
        for (let a = 1; a < this.sgData.length; a++) {
            let assetParent = this.sgParent.querySelector("[id='assetParent" + a + "']");
            let sgNumberTextParent = assetParent ? assetParent.querySelector("[id='sgNumberTextParent']") : null;
            if (sgNumberTextParent) sgNumberTextParent.style.opacity = a == this.currentNodeIndex - 1 ? 1 : 0;

            assetParent.style.opacity = a == this.currentNodeIndex - 1 ? 1 : 0;
        }
        if (oldIndex == 0) this.updateCarouselOpacity(1, 1);
        this.setupCarouselPositions(false, false, this.currentNodeIndex > 2 ? false : true);
        setTimeout(() => {
            if (completeCallback) completeCallback();
        }, 100);
    } else
        setTimeout(() => {
            if (oldIndex == 0) this.updateCarouselOpacity(1, 1);
            this.setupCarouselPositions(false, false, this.currentNodeIndex > 2 ? false : true);
        }, 500);
    if (this.isPlayAnimation == false && this.currentNodeIndex == 2) {
        let assetParent = this.sgParent.querySelector("[id='assetParent0']");
        assetParent.style.opacity = 0;
    }
};
GenericCarouselImagestack2.prototype.showDevice = function (showDevice = true) {
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    if (deviceImageParentNode) {
        deviceImageParentNode.style.opacity = showDevice == false ? 0 : 1;
        deviceImageParentNode.style.pointerEvents = showDevice == false ? "none" : "auto";
    }
    if (this.sgParent.querySelector("[id='deviceImageNode']") && showDevice == true) this.sgParent.querySelector("[id='deviceImageNode']").style.removeProperty("opacity");
    if (this.sgParent.querySelector("[id='deviceImageNode1']") && showDevice == true) this.sgParent.querySelector("[id='deviceImageNode1']").style.removeProperty("opacity");
    if (this.sgParent.querySelector("[id='videoElement']") && showDevice == true) this.sgParent.querySelector("[id='videoElement']").style.removeProperty("opacity");
    if (this.sgParent.querySelector("[id='secondaryAssetNode']") && showDevice == true) this.sgParent.querySelector("[id='secondaryAssetNode']").style.removeProperty("opacity");
};
GenericCarouselImagestack2.prototype.previous = function (completeCallback) {
    let oldIndex = this.currentNodeIndex - 1 < 0 ? 0 : this.currentNodeIndex - 1;
    this.currentNodeIndex = this.currentNodeIndex - 1;

    this.sgParent.removeAttribute("hasemptyintro");
    let hasEmptyIntro = this.checkIntroAnimation();
    if (hasEmptyIntro == true && this.currentNodeIndex <= 1) return false;

    if (this.currentNodeIndex < 1) return;

    if (this.isPlayAnimation == false) {
        for (let a = 1; a < this.sgData.length; a++) {
            let assetParent = this.sgParent.querySelector("[id='assetParent" + a + "']");
            let sgNumberTextParent = assetParent ? assetParent.querySelector("[id='sgNumberTextParent']") : null;
            if (sgNumberTextParent) sgNumberTextParent.style.opacity = a == this.currentNodeIndex - 1 ? 1 : 0;
        }
    }

    if (this.currentNodeIndex - 1 == 0) this.updateCarouselOpacity(0);
    //HIDE ANIMATION
    this.updateShowHideInfo(oldIndex, false);
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", completeCallback, this.isPlayAnimation, this.eventManager, oldIndex, "moodsutilintermediate");

    //SHOW ANIMATION
    this.updateShowHideInfo(this.currentNodeIndex - 1, true);
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1, "moodsutilintermediate");
    if (this.currentNodeIndex - 1 != 0)
        setTimeout(
            () => {
                this.setupCarouselPositions(false, true);
            },
            this.isPlayAnimation == false ? 0 : 500
        );
};
GenericCarouselImagestack2.prototype.checkIntroAnimation = function () {
    if (this.isHeroImage() == true) return true;
    if (this.sgParent && this.sgParent.parentElement && this.sgParent.parentElement.parentElement) {
        let animationDIV = this.sgParent.parentElement.parentElement;
        let showIntro = animationDIV.getAttribute("data-ogdata-finalshow_0")?.split(",")?.includes("intro") ? "true" : "false";
        if (showIntro == "false") return true;
    }
    let assetParent = this.getAssetParent(0);
    if (assetParent && assetParent.classList.contains("introSlide")) {
        let title = assetParent.querySelector("[id='sgTitleNode']");
        let subTitle = assetParent.querySelector("[id='sgSubTitleNode']");
        let titleLabel = assetParent.querySelector("[id='sgTitleLabelNode']");
        if (title && title.innerText.trim().length == 0 && subTitle && subTitle.innerText.trim().length == 0 && titleLabel && titleLabel.innerText.trim().length == 0) {
            return true;
        }
    }
    return false;
};
GenericCarouselImagestack2.prototype.isHeroImage = function () {
    if (this.sgParent && this.sgParent.parentElement && this.sgParent.parentElement.parentElement) {
        let count = this.sgParent.parentElement.parentElement.getAttribute("data-nodecount");
        if (count == "1") return true;
    }
};

GenericCarouselImagestack2.prototype.updateImage = function (elementId, src, nodeIndex = null, resizeImage = false, imgNode) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + (nodeIndex != null ? nodeIndex : this.currentNodeIndex - 1) + "']");
    let imageNode = assetParent ? assetParent.querySelector("[id='" + elementId + "']") : this.sgParent.querySelector("[id='" + elementId + "']");
    if (!imageNode && imgNode) imageNode = imgNode;
    if (imageNode && src) {
        imageNode.src = src;
        if (resizeImage) this.specialGraphicsUtils.updateImageReSize(imageNode.getAttribute("data-width"), imageNode.getAttribute("data-height"), imageNode);
        // let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData && this.metaData ? this.metaData : null;
        // let isNotMainImage = imageNode.id.includes("sgPlaceHolderImageNode") || imageNode.id.includes("sgLogoImageNode") ? false : true;
        // if (isNotMainImage && metaDataBase && metaDataBase.properties && metaDataBase.properties[imageID] && assetParent) {
        //     let props = metaDataBase.properties.image;
        //     if (props.contrast && props.contrast == "fullbg" && imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent);
        //     if (props.contrast && props.contrast == "halfbg" && imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent, true);
        // }
        this.updateImageContrastOnChange(imageNode, this.currentNodeIndex - 1);
        let duplicatedImages = assetParent ? assetParent.querySelectorAll("[data-target-id='coverimageduplicate']") : null;
        if (duplicatedImages?.length > 0 && elementId.includes("coverimage")) {
            for (let a = 0; a < duplicatedImages.length; a++) {
                let duplicatedImage = duplicatedImages[a];
                duplicatedImage.src = src;
            }
        }
        if (elementId.toLocaleLowerCase().includes("logo") || elementId.includes("sgPlaceHolderImageNode")) {
            imageNode.callback = this.rePositionTextAndElement.bind(this);
            let type = elementId.includes("sgPlaceHolderImageNode") ? "image" : "logo";
            this.setLogoSizes(assetParent, type);
        }
    }
};
GenericCarouselImagestack2.prototype.updateImageContrastOnChange = function (imageNode, index) {
    let assetParent = this.getAssetParent(index ? index : this.currentNodeIndex - 1);
    let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData ? this.metaData : null;
    let imageID = imageNode.id.includes("sgAuthorImageNode") ? "authimg" : imageNode.id.toLocaleLowerCase().includes("presetimage") ? "presetimage" : "image";
    let isNotMainImage = imageNode.id.includes("sgPlaceHolderImageNode") || imageNode.id.includes("sgLogoImageNode") ? false : true;
    if (isNotMainImage && metaDataBase && metaDataBase.properties && metaDataBase.properties[imageID] && assetParent) {
        let props = metaDataBase.properties[imageID];
        if (props.contrast && props.contrast == "fullbg" && imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent);
        if (props.contrast && props.contrast == "halfbg" && imageNode) this.eventManager.dispatch("applyImageContrast", imageNode, assetParent, true);
    }
};
GenericCarouselImagestack2.prototype.updateImageResizeOnTypeChange = function (type) {
    let assetParent = this.getAssetParent(this.currentNodeIndex - 1);
    this.setLogoSizes(assetParent, type);
    this.textFitOnImageResize();
};
GenericCarouselImagestack2.prototype.getAssetParent = function (index) {
    return this.sgParent.querySelector("[id='assetParent" + index + "']");
};
GenericCarouselImagestack2.prototype.changeText = function (updatedText, elementId, targetIndex, textType) {
    let assetParent = this.getAssetParent(targetIndex != null && targetIndex != undefined ? targetIndex : this.currentNodeIndex - 1);
    if (assetParent && assetParent.querySelector("[id='" + elementId + "']")) {
        let textNode = assetParent.querySelector("[id='" + elementId + "']");
        textNode = !textNode ? assetParent.querySelector("[id*='" + elementId + "']") : textNode;

        if (textNode) {
            let prefix = textNode.hasAttribute("prefix") ? textNode.getAttribute("prefix") : null;
            let suffix = textNode.hasAttribute("suffix") ? textNode.getAttribute("suffix") : null;
            if (prefix) {
                updatedText = updatedText.replace(prefix, "");
                updatedText = prefix + " " + updatedText;
            }
            if (suffix) {
                updatedText = updatedText.replace(suffix, "");
                updatedText = updatedText + " " + suffix;
            }
            textNode.setAttribute("data-heading", updatedText);
            textNode.setAttribute("data-oldtext", updatedText);
            textNode.setAttribute("data-changetext", "true");
            textNode.innerHTML = updatedText;

            if (this.sgSlideType != "sectionbreak") this.specialGraphicsUtils.doFontFitForCss(textNode, this.sgParent, null, null, null, true);
            if (assetParent && assetParent.id != "assetParent0") this.specialGraphicsUtils.updateImagePositions(this.sgParent);
        }
    }
};
GenericCarouselImagestack2.prototype.getTargetElement = function (elementID) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    if (assetParent && assetParent.querySelector("[id='" + elementID + "']")) return assetParent.querySelector("[id='" + elementID + "']");

    let carouselImageParent = this.sgParent.querySelector("[id='carouselImageParent']");
    if (carouselImageParent) {
        let allNodes = carouselImageParent.querySelectorAll("[id*='" + elementID + "']");
        if (allNodes[this.currentNodeIndex - 2]) return allNodes[this.currentNodeIndex - 2];
        else if (allNodes.length == 1) return allNodes[0];
    }
};

GenericCarouselImagestack2.prototype.resetFontDetails = function (elementID, parent, type) {
    let element = parent.querySelector("[id='" + elementID + "']");
    if (element) {
        element.classList.remove("h3");
        element.classList.remove("h4");
        element.classList.add(this.fontData[type]);
        element.style.removeProperty("max-height");
        element.style.removeProperty("min-height");
        element.style.removeProperty("font-size");
        if (element.hasAttribute("user-font-size")) {
            this.specialGraphicsUtils.removeAllFontClass(element);
            element.classList.add(element.getAttribute("user-font-size"));
            // element.style.setProperty("font-size", element.getAttribute("user-font-size") + "px", "important");
        }
        this.specialGraphicsUtils.doFontFitForCss(element, this.sgParent);
    }
};
GenericCarouselImagestack2.prototype.updateFloaterOnPreviewEnd = function (index) {
    this.updateIntroVisibility(false, index);
};

//Seeting up carousel positions
GenericCarouselImagestack2.prototype.setupCarouselPositions = function (doNavigation = true, isPrevious = false, hideNodes = false) {
    try {
        let carouselImageParent = this.sgParent.querySelector("[id*='carouselImageParent']");
        let arrCoverImages = carouselImageParent ? carouselImageParent.querySelectorAll("[id*='coverImageParent']") : this.sgParent.querySelectorAll("[id*='coverImageParent']");
        let props = this.getProps();
        if (props && props && props.carousel && props.carousel.carouselcount) this.carouselcount = props.carousel.carouselcount ? parseInt(props.carousel.carouselcount) : 3;
        if (!this.carouselcount) this.carouselcount = 3;
        let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
        if (doNavigation == true) {
            for (let a = 0; a < this.sgData.length - (assetParent0.classList.contains("introSlide") ? 1 : 0); a++) {
                arrCoverImages[a].style.display = "none";
            }
        } else {
            let currentIndex = this.currentNodeIndex - 2;
            let scale = 1;

            if (arrCoverImages[currentIndex]) arrCoverImages[currentIndex].style.removeProperty("transition");

            for (let a = 0; a < this.sgData.length - (assetParent0.classList.contains("introSlide") ? 1 : 0); a++) {
                arrCoverImages[a].classList.add("hideNode");
                arrCoverImages[a].classList.remove("carouselFirstOut");
                arrCoverImages[a].classList.remove("carouselFirstIn");
                arrCoverImages[a].classList.remove("carouselSecondIn");
                arrCoverImages[a].classList.remove("carouselThirdIn");
                arrCoverImages[a].classList.remove("carouselFourthIn");
                arrCoverImages[a].classList.remove("carouselPrevLastOut");
                arrCoverImages[a].classList.remove("carouselPrevFirstIn");
                arrCoverImages[a].classList.remove("carouselPrevSecondIn");
                arrCoverImages[a].classList.remove("carouselPrevThirdIn");
                arrCoverImages[a].classList.remove("carouselPrevFourthIn");
            }
            if (hideNodes == false) this.imagePositionSet(arrCoverImages, assetParent0, currentIndex, isPrevious, scale);
            else {
                if (this.isPlayAnimation == false) this.imagePositionSet(arrCoverImages, assetParent0, currentIndex, isPrevious, scale);
                else
                    setTimeout(() => {
                        this.imagePositionSet(arrCoverImages, assetParent0, currentIndex, isPrevious, scale);
                    }, 1000);
            }
        }
        if (doNavigation == true) this.floaterNavigation(0);
    } catch (error) {
        console.log("SG - Error on render complete of carousel imagestack - " + error);
    }
};

GenericCarouselImagestack2.prototype.imagePositionSet = function (arrCoverImages, assetParent0, currentIndex, isPrevious, scale) {
    for (let a = 0; a < this.sgData.length - (assetParent0.classList.contains("introSlide") ? 1 : 0); a++) {
        let doClear = true;
        if (a == currentIndex && this.carouselcount >= 2) doClear = false;
        if (a == currentIndex + 1 && this.carouselcount >= 3) doClear = false;
        if (a == currentIndex + 2 && this.carouselcount >= 4) doClear = false;
        if (a == currentIndex + 3 && this.carouselcount >= 5) doClear = false;

        if (this.isPlayAnimation == false) arrCoverImages[a].classList.add("noAnimation");
        else arrCoverImages[a].classList.remove("noAnimation");

        let imgNode = arrCoverImages[a].querySelector("[id*='coverimage']");
        if (a == currentIndex) {
            if (imgNode) {
                imgNode.style.pointerEvents = "auto";
                if (imgNode.parentElement.querySelector("[id='svgElementDiv']")) {
                    let svgDiv = imgNode.parentElement.querySelector("[id='svgElementDiv']");
                    if (svgDiv.style.display == "none") {
                        imgNode.style.pointerEvents = "auto";
                        // svgDiv.style.pointerEvents = "none";
                    } else {
                        imgNode.style.pointerEvents = "none";
                        // svgDiv.style.pointerEvents = "auto";
                    }
                }
                // arrCoverImages[a].style.pointerEvents = "none";
            }
            // else arrCoverImages[a].style.pointerEvents = "auto";
        } else {
            if (imgNode) {
                imgNode.style.pointerEvents = "none";
                // arrCoverImages[a].style.pointerEvents = "none";
                // if (imgNode.parentElement.querySelector("[id='svgElementDiv']")) imgNode.parentElement.querySelector("[id='svgElementDiv']").style.pointerEvents = "none";
            }
            // else arrCoverImages[a].style.pointerEvents = "none";
        }
        let isReverse = this.isReverse();
        if (isReverse && arrCoverImages[a]) arrCoverImages[a].style.setProperty("transform-origin", "left", "important");
        else if (arrCoverImages[a]) arrCoverImages[a].style.setProperty("transform-origin", "right", "important");

        let index = isPrevious == true ? this.currentNodeIndex + 2 - (this.carouselcount == 3 ? 1 : this.carouselcount == 4 ? 0 : 2) : currentIndex - 1;
        if (arrCoverImages[index]) {
            let gapValues = this.getGapValue();
            let firstInValue = gapValues[0];
            let secondInValue = gapValues[1];
            let thirdInValue = gapValues[2];
            let fourthInValue = gapValues[3];

            this.sgParent.style.setProperty(
                "--carouselLastOut",
                this.carouselcount == 4 ? "scale(0.59) translateX(" + (isReverse ? "-" : "") + thirdInValue + "px)" : this.carouselcount == 3 ? "scale(0.72) translateX(" + (isReverse ? "-" : "") + secondInValue + "px)" : "scale(0.85) translateX(" + (isReverse ? "-" : "") + firstInValue + "px)"
            );
            this.sgParent.style.setProperty(
                "--carouselLastOutValue",
                this.carouselcount == 4 ? "scale(0.46) translateX(" + (isReverse ? "-" : "") + fourthInValue + "px)" : this.carouselcount == 3 ? "scale(0.59) translateX(" + (isReverse ? "-" : "") + thirdInValue + "px)" : "scale(0.71) translateX(" + (isReverse ? "-" : "") + secondInValue + "px)"
            );
            arrCoverImages[index].classList.remove("hideNode");
            arrCoverImages[index].classList.add(isPrevious == true ? "carouselPrevLastOut" : "carouselFirstOut");
        }
        if (doClear == true) {
            if (isPrevious == true) arrCoverImages[a].style.zIndex = 0;
            else {
                if (this.isPlayAnimation == false) arrCoverImages[a].style.zIndex = 0;
                else
                    setTimeout(() => {
                        arrCoverImages[a].style.zIndex = 0;
                    }, 1000);
            }
        }
    }

    scale = this.setImageVisibility(arrCoverImages, currentIndex, scale, 4, isPrevious, true);
    if (this.carouselcount >= 2) {
        if (arrCoverImages[currentIndex + 1]) arrCoverImages[currentIndex + 1].style.removeProperty("transition");
        scale = this.setImageVisibility(arrCoverImages, currentIndex + 1, scale, 3, isPrevious, true);
    }
    if (this.carouselcount >= 3) {
        if (arrCoverImages[currentIndex + 2]) arrCoverImages[currentIndex + 2].style.removeProperty("transition");
        scale = this.setImageVisibility(arrCoverImages, currentIndex + 2, scale, 2, isPrevious, true);
    }
    if (this.carouselcount >= 4) {
        if (arrCoverImages[currentIndex + 3]) arrCoverImages[currentIndex + 3].style.removeProperty("transition");
        scale = this.setImageVisibility(arrCoverImages, currentIndex + 3, scale, 1, isPrevious, true);
    }
};

GenericCarouselImagestack2.prototype.getGapValue = function () {
    let props = this.getProps();
    let arrGap;
    let arrTranslate = [0, 100, 210, 350];
    let c = this.carouselcount;
    if (props && props && props.carousel && props.carousel.gapvalue) arrGap = props.carousel.gapvalue.split(",");
    let arrTranslateFromMenu = arrGap && arrGap.length > 0 ? arrGap : [];
    let firstInValue = arrTranslateFromMenu[0] ? parseFloat(arrTranslateFromMenu[0]) : arrTranslate[1];
    let secondInValue = c == 2 && arrTranslateFromMenu[0] ? parseFloat(arrTranslateFromMenu[0]) * 1.7 : arrTranslateFromMenu[1] ? parseFloat(arrTranslateFromMenu[1]) : arrTranslate[2];
    let thirdInValue = c == 3 && arrTranslateFromMenu[1] ? parseFloat(arrTranslateFromMenu[1]) * 1.7 : arrTranslateFromMenu[2] ? parseFloat(arrTranslateFromMenu[2]) : arrTranslate[3];
    let fourthInValue = c == 4 && arrTranslateFromMenu[2] ? parseFloat(arrTranslateFromMenu[2]) * 1.7 : arrTranslateFromMenu[3] ? parseFloat(arrTranslateFromMenu[3]) : thirdInValue + firstInValue;
    let objTransform = [];
    objTransform.push(firstInValue);
    objTransform.push(secondInValue);
    objTransform.push(thirdInValue);
    objTransform.push(fourthInValue);
    return objTransform;
};

GenericCarouselImagestack2.prototype.setImageVisibility = function (arrCoverImages, currentIndex, scale, zIndex, isPrevious, setPrevious = false) {
    //current Node
    if (arrCoverImages[currentIndex]) {
        let props = this.getProps();
        let isReverse = this.isReverse();
        let arrTranslate = [0, 100, 210, 350];
        // let arrGap;
        let arrOpacity;
        // if (props && props && props.carousel && props.carousel.gapvalue) arrGap = props.carousel.gapvalue.split(",");
        if (props && props && props.carousel && props.carousel.opacityvalue) arrOpacity = props.carousel.opacityvalue.split(",");
        // let arrTranslateFromMenu = arrGap && arrGap.length > 0 ? arrGap : [];

        let arrClassNames = ["carousel" + (isPrevious == true ? "Prev" : "") + "FirstIn", "carousel" + (isPrevious == true ? "Prev" : "") + "SecondIn", "carousel" + (isPrevious == true ? "Prev" : "") + "ThirdIn", "carousel" + (isPrevious == true ? "Prev" : "") + "FourthIn"];

        let gapValues = this.getGapValue();
        let firstInValue = gapValues[0];
        let secondInValue = gapValues[1];
        let thirdInValue = gapValues[2];
        let fourthInValue = gapValues[3];

        this.sgParent.style.setProperty("--firstIn", (isReverse ? -firstInValue : firstInValue) + "px");
        this.sgParent.style.setProperty("--secondIn", (isReverse ? -secondInValue : secondInValue) + "px");
        this.sgParent.style.setProperty("--thirdIn", (isReverse ? -thirdInValue : thirdInValue) + "px");
        this.sgParent.style.setProperty("--fourthIn", (isReverse ? -fourthInValue : fourthInValue) + "px");
        this.sgParent.style.setProperty("--prevFirstIn", (isReverse ? firstInValue : -firstInValue) + "px");

        let selectedIndex = arrTranslate.indexOf(arrTranslate[4 - zIndex]);

        scale = scale - 0.1;
        arrCoverImages[currentIndex].style.display = "flex";
        arrCoverImages[currentIndex].setAttribute("old", arrCoverImages[currentIndex].style.transform);
        arrCoverImages[currentIndex].classList.remove("hideNode");

        let assetParent = this.sgParent;
        if (this.carouselcount == 2 && assetParent) assetParent.style.setProperty("--carouselSecondInOpacity", 0);
        if (this.carouselcount == 3 && assetParent) assetParent.style.setProperty("--carouselThirdInOpacity", 0);
        if (this.carouselcount == 4 && assetParent) assetParent.style.setProperty("--carouselFourthInOpacity", 0);

        this.sgParent.style.setProperty("--carouselFirstInOpacity", this.sgParent.style.getPropertyValue("--firstInOpacity").trim());

        let opacity1 = arrOpacity && arrOpacity[0] ? arrOpacity[0] : 1;
        let opacity2 = arrOpacity && arrOpacity[1] ? arrOpacity[1] : 1;
        let opacity3 = arrOpacity && arrOpacity[2] ? arrOpacity[2] : 1;

        let ind = 4 - zIndex;
        let coverParent = arrCoverImages[currentIndex].querySelector("[id*='coverParent']");
        coverParent.style.opacity = ind == 1 ? opacity1 : ind == 2 ? opacity2 : ind == 3 ? opacity3 : 1;

        arrCoverImages[currentIndex].classList.add(arrClassNames[selectedIndex]);

        //All nodes background color
        let bgcolor = props && props && props.carousel && props.carousel.bgcolor ? props.carousel.bgcolor : null;
        if (bgcolor && coverParent) coverParent.style.backgroundColor = "rgba(var(--" + bgcolor + "-color-rgb),1)";

        if (isPrevious == true || this.isStart == true) arrCoverImages[currentIndex].style.zIndex = zIndex;
        else {
            if (this.isPlayAnimation == false) arrCoverImages[currentIndex].style.zIndex = zIndex;
            else
                setTimeout(() => {
                    arrCoverImages[currentIndex].style.zIndex = zIndex;
                }, 1000);
        }
    }
    return scale;
};
//Check the asset is reverse side design
GenericCarouselImagestack2.prototype.isReverse = function () {
    let isReverse = false;
    let props = this.getProps();
    if (props && props && props.carousel && props.carousel.isreverse) isReverse = props.carousel.isreverse == "true" || props.carousel.isreverse == true ? true : false;
    return isReverse;
};
//Before present we have to hide some elements for animation - only for custion animation
GenericCarouselImagestack2.prototype.initPresentSG = function (slideContent) {
    let specialgraphicsParent = slideContent.querySelector("[id='specialgraphicsParent']");
    let carouselImageParent = slideContent.querySelector("[id='carouselImageParent']");
    if (specialgraphicsParent) specialgraphicsParent.style.opacity = 0;
    if (carouselImageParent) carouselImageParent.style.opacity = 0;

    let placeholderParent = slideContent.querySelectorAll("[id*='placeHolderParent'],[id='shape1'],[id='shape2'],[id='shape3'],[id='shape4'],[id='shape5']");
    placeholderParent.forEach((element) => {
        element.style.removeProperty("opacity");
    });

    let hasEmptyIntro = this.checkIntroAnimation();
    if (specialgraphicsParent) specialgraphicsParent.setAttribute("hasemptyintro", hasEmptyIntro);

    for (let a = 1; a < this.sgData.length; a++) {
        let assetParent = slideContent.querySelector("[id='assetParent" + a + "']");
        if (assetParent && a == 1 && hasEmptyIntro) assetParent.style.opacity = 1;
        else if (assetParent) assetParent.style.opacity = 0;
    }
};
//updating carousel image parent opacity depends on slides - for intro opacity id 0 remaining opacity is 1
GenericCarouselImagestack2.prototype.updateCarouselOpacity = function (opacity, delay = 0, from = "", isAnimStart = false) {
    for (let a = 1; a < this.sgData.length; a++) {
        let carouselImageParent = this.sgParent.querySelector("[id='carouselImageParent']");
        let backgroundImage = this.sgParent.querySelector("[id='backgroundImage']");
        if (carouselImageParent) {
            let commonImageParent = carouselImageParent.querySelector("[id='commonImageParent" + a + "']");
            carouselImageParent.style.transition = "opacity " + (this.isPlayAnimation == false ? 0 : 1) + "s " + (this.isPlayAnimation == false ? 0 : delay) + "s";
            carouselImageParent.style.opacity = opacity;
            if (commonImageParent) {
                let coverImageParent = commonImageParent.querySelector("[id='coverImageParent']");
                if (isAnimStart && coverImageParent) coverImageParent.style.zIndex = 5 - a;
                if (coverImageParent) coverImageParent.style.display = "flex";
                else commonImageParent.style.display = "flex";
            }
        }
        if (backgroundImage && backgroundImage.parentElement.id == "carouselMainParent") {
            if (from != "intro") backgroundImage.style.transition = "opacity " + (this.isPlayAnimation == false ? 0 : 1) + "s " + (this.isPlayAnimation == false ? 0 : delay) + "s";
            backgroundImage.style.opacity = opacity;
            backgroundImage.style.display = "flex";
        }
    }
};
//Setting up asset parent's display while floater navigate
GenericCarouselImagestack2.prototype.assetParentDisplayChange = function (display) {
    let arrAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
    for (let a = 1; a < arrAssetParent.length; a++) {
        if (arrAssetParent[a]) arrAssetParent[a].style.display = display;
        let commonImageParent = this.sgParent.querySelector("[id='commonImageParent" + a + "']");
        if (commonImageParent) {
            let coverImageParent = commonImageParent.querySelector("[id='coverImageParent']");
            if (coverImageParent) coverImageParent.style.display = display;
            else commonImageParent.style.display = display;
        }
    }
};
GenericCarouselImagestack2.prototype.focusOutElement = function (elementID) {
    try {
        let assetParent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
        let element = assetParent ? assetParent.querySelector("[id=" + elementID + "]") : null;
        if (element) {
            element.setAttribute("focusout", "mannual");
            element.blur();
        }
    } catch (error) {}
};

GenericCarouselImagestack2.prototype.createPlaceHolder = function (parentNode, currentIndex) {
    let props = currentIndex == 0 ? this.getIntroProps() : this.getProps();
    // let src = "";
    let placeholderProperty = null;
    if (props && props && props["placeholderimage"]) placeholderProperty = props["placeholderimage"];
    // if (placeholderProperty && placeholderProperty.imageurl) src = placeholderProperty.imageurl;
    let assetParent = this.sgParent.querySelector("[id='assetParent" + currentIndex + "']");

    this.createPlaceHolderImage(parentNode, currentIndex);
    let parentElement = parentNode.querySelector("[id*='placeHolderParent']");
    let logoParent = parentElement.querySelector("[id*='logoContentParent']");
    let imageParent = parentElement.querySelector("[id*='phImageContentParent']");
    let iconParent = parentElement.querySelector("[id*='phIconContentParent']");
    let textParent = parentElement.querySelector("[id*='phTextParent']");
    let phTextNode = parentElement.querySelector("[id*='phTextNode']");
    let logoImageNode = logoParent ? logoParent.querySelector("[id='sgLogoImageNode']") : null;

    let placeHolderType = this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagetype ? this.sgData[currentIndex].placeholderimagetype : placeholderProperty.placeholderimagetype ? placeholderProperty.placeholderimagetype : "logo";
    if (placeHolderType && logoParent && imageParent && iconParent && textParent) {
        logoParent.classList.remove("placeholderactive");
        imageParent.classList.remove("placeholderactive");
        iconParent.classList.remove("placeholderactive");
        textParent.classList.remove("placeholderactive");
        if (placeHolderType == "logo") logoParent.classList.add("placeholderactive");
        if (placeHolderType == "image") imageParent.classList.add("placeholderactive");
        if (placeHolderType == "icon") iconParent.classList.add("placeholderactive");
        if (placeHolderType == "text") textParent.classList.add("placeholderactive");
        if (placeholderProperty.placeholdersizestyle) {
            let sizeStyle = placeholderProperty.placeholdersizestyle;
            if (!parentElement.classList.contains("placeholderSizeStyle")) parentElement.classList.add("placeholderSizeStyle");
            parentElement.setAttribute("data-placeholdersizestyle", sizeStyle);
            logoParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            imageParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            iconParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            textParent.setAttribute("data-placeholdersizestyle", sizeStyle);
            if (!logoParent.classList.contains(sizeStyle)) logoParent.classList.add(sizeStyle);
            if (!imageParent.classList.contains(sizeStyle)) imageParent.classList.add(sizeStyle);
            if (!iconParent.classList.contains(sizeStyle)) iconParent.classList.add(sizeStyle);
            if (!textParent.classList.contains(sizeStyle)) textParent.classList.add(sizeStyle);
        }
    }

    this.specialgraphicsPropertyUtils.applyImageBaseProps(placeholderProperty, assetParent, parentElement, "--placeholderImage", false);
    parentElement.style.height = "auto";

    let colorValue = placeholderProperty ? this.specialGraphicsUtils.getNodeColor(this.objDataToSG, "secondary", placeholderProperty.textcolor) : null;
    // if (!colorValue && placeholderProperty.textcolor) colorValue = "rgba(var(--" + placeholderProperty.textcolor + "-color-rgb),1)";
    if (phTextNode && colorValue) {
        phTextNode.style.color = colorValue;
        phTextNode.setAttribute("data-color", colorValue);
    }

    if (this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagesize && parentElement) parentElement.setAttribute("data-placeholderimagesize", this.sgData[currentIndex].placeholderimagesize);
    if (placeHolderType == "image" || placeHolderType == "logo" || placeHolderType == "icon" || placeHolderType == "text") this.setLogoSizes(assetParent, placeHolderType);

    if (this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagealign) {
        let alignData = this.sgData[currentIndex].placeholderimagealign;
        if (alignData == "bottom" || alignData == "right") parentElement.classList.add("phPosition");
        else parentElement.classList.remove("phPosition");
    }
    if (placeholderProperty.placeholderalign) parentElement.setAttribute("phalign", placeholderProperty.placeholderalign);
    if (this.sgData[currentIndex] && this.sgData[currentIndex].placeholderimagesize) {
        //Implement placeholder size change from floter
        // let sizeV = this.sgData[currentIndex].placeholderimagesize;
        // let multipleValue = sizeV == "small" ? 0.4 : sizeV == "medium" ? 0.7 : sizeV == "large" ? 1 : parseFloat(sizeV);
        let multipleValue = this.specialGraphicsUtils.getImageSizeSML(this.sgData[currentIndex].placeholderimagesize);
        let largeW = parseFloat(parentElement.getAttribute("data-largewidth"));
        let largeH = parseFloat(parentElement.getAttribute("data-largeheight"));
        let newW = largeW * multipleValue;
        let newH = largeH * multipleValue;
        let cropHeight = logoImageNode && logoImageNode.hasAttribute("logosizecropheight") ? logoImageNode.getAttribute("logosizecropheight") : "";
        if (newW > 0 && newH > 0) {
            parentElement.style.width = newW + "px";
            if (cropHeight == "") parentElement.style.height = newH + "px";
        }
        if (logoImageNode) logoImageNode.removeAttribute("logosizecropheight");
    }
    let hasPlaceholderData = this.sgData[currentIndex].placeholderimage != null && this.sgData[currentIndex].placeholderimage != undefined;
    if (placeHolderType == "icon" && iconParent && hasPlaceholderData) {
        let iconPath = this.sgData[currentIndex].placeholderimage.includes(".svg") ? this.sgData[currentIndex].placeholderimage : this.appStaticURL + "genericassets/icons/fill/default/best.svg";
        let iconNodeParent = iconParent.querySelector("[id*='phIconSvgNode']");
        let arrAssets = [];
        if (iconNodeParent) iconNodeParent.setAttribute("data-src", iconPath);
        arrAssets.push({ url: iconPath, id: "svgdata", parent: iconNodeParent, type: "SVG" });
        // this.arrCommonAssets.push({ array: arrAssets, callback: this.placeholderSvgLoadCallback });
        this.loadAssets(arrAssets, this.placeholderSvgLoadCallback);
    }
    if (placeholderProperty && placeholderProperty.halign) {
        let halignProp = placeholderProperty.halign;
        let hAlign = halignProp == "right" || halignProp == "end" ? "flex-end" : halignProp == "center" || halignProp == "middle" ? "center" : "flex-start";
        let pos = halignProp == "right" || halignProp == "end" ? "right" : halignProp == "center" || halignProp == "middle" ? "center" : "left";
        if (logoImageNode) logoImageNode.setAttribute("data-imagecropalignment", pos);
        let phTextNode = textParent.querySelector("[id*='phTextNode']");
        if (phTextNode) phTextNode.style.textAlign = hAlign;
    }
    this.applyContrastToText(logoImageNode, placeholderProperty);
    this.applyContrastToText(phTextNode, placeholderProperty);
};
GenericCarouselImagestack2.prototype.getCurrentIndex = function () {
    return this.currentNodeIndex - 1;
};
GenericCarouselImagestack2.prototype.startIndex = function (currentSlideData) {
    return this.specialGraphicsUtils.getStartIndex(currentSlideData, this.sgParent);

    // let presentParent = currentSlideData ? currentSlideData : this.sgParent;
    // let assetParent = presentParent ? presentParent.querySelector("[id='assetParent0']") : null;
    // let sgParent = presentParent ? presentParent.querySelector("[id='specialgraphicsParent']") : this.sgParent;

    // let isNotVisible = assetParent?.style?.display == "none" || assetParent?.style?.opacity == 0 || assetParent?.style?.opacity == "0";
    // if (isNotVisible) sgParent.setAttribute("startindex", "1");
    // else sgParent.removeAttribute("startindex");

    // let localParent = sgParent ? sgParent : this.sgParent;
    // let animationDIV = localParent?.parentElement?.parentElement ? localParent.parentElement.parentElement : null;
    // let showIntro = animationDIV?.hasAttribute("data-intro") ? animationDIV.getAttribute("data-intro") : "true";

    // return (isNotVisible || !assetParent) && showIntro != "true" ? 1 : 0;
};
GenericCarouselImagestack2.prototype.setLogoSizes = function (assetParent, placeHolderType = "") {
    let assetParentNode = assetParent ? assetParent : this.getAssetParent(this.currentNodeIndex - 1);
    let imgNode = assetParentNode ? assetParentNode.querySelector("[id='sgLogoImageNode']") : null;

    let oldDisplay = assetParentNode ? assetParentNode.style.display : "";
    if (assetParentNode) assetParentNode.style.display = "block";

    if (placeHolderType == "icon") {
        imgNode = assetParentNode ? assetParentNode.querySelector("[id*='phIconSvgNode']") : null;
        this.setLogoSizesOP(imgNode);
    } else if (placeHolderType == "text") {
        imgNode = assetParentNode ? assetParentNode.querySelector("[id*='phTextNode']") : null;
        this.setLogoSizesOP(imgNode);
        this.onTextChangeUpdatePlaceholderNode(imgNode);
    } else {
        if (placeHolderType == "image") imgNode = assetParentNode ? assetParentNode.querySelector("[id='sgPlaceHolderImageNode']") : null;

        if (imgNode && imgNode.complete) this.setLogoSizesOP(imgNode);
        else if (imgNode) imgNode.addEventListener("load", this.logoLoadCallback);
    }
    if (assetParentNode) assetParentNode.style.display = oldDisplay;
};
GenericCarouselImagestack2.prototype.logoLoadCallback = function (event) {
    event.target.removeEventListener("load", this.logoLoadCallback);
    this.setLogoSizesOP(event.target);
};
GenericCarouselImagestack2.prototype.setLogoSizesOP = function (imgNode) {
    let logoRatio = this.specialGraphicsUtils.getLogoRatio(imgNode);
    // console.log("LOGO - ratio - " + logoRatio);
    if (!logoRatio) logoRatio = "square";
    if (logoRatio && imgNode) {
        let dummyDom = document.createElement("div");
        dummyDom.classList.add(logoRatio);
        dummyDom.style.position = "absolute";
        dummyDom.style.width = "var(--logoSizeWidth)";
        dummyDom.style.height = "var(--logoSizeHeight)";
        if (imgNode.id.includes("phTextNode")) imgNode.appendChild(dummyDom);
        else imgNode.parentElement.appendChild(dummyDom);
        let w = window.getComputedStyle(dummyDom).width;
        let h = window.getComputedStyle(dummyDom).height;
        if (w != "" && h != "" && w != "0px" && h != "0px") {
            let mainParent = imgNode.parentElement.parentElement.parentElement;
            if (imgNode.id.includes("phTextNode")) mainParent = imgNode.parentElement.parentElement;
            let lgWidth = window.getComputedStyle(dummyDom).getPropertyValue("--logoSizeWidth");
            if (lgWidth?.trim() == "100%") {
                mainParent.style.width = "100%";
                w = window.getComputedStyle(mainParent).width;
            }
            imgNode.parentElement.style.setProperty("--logoSizeWidth", w);
            imgNode.parentElement.style.setProperty("--logoSizeHeight", h);
            imgNode.parentElement.setAttribute("data-largewidth", parseFloat(w));
            imgNode.parentElement.setAttribute("data-largeheight", parseFloat(h));

            mainParent.setAttribute("data-largewidth", parseFloat(w));
            mainParent.setAttribute("data-largeheight", parseFloat(h));

            let placeholderimagesize = "medium";
            if (imgNode.parentElement.hasAttribute("data-placeholderimagesize")) placeholderimagesize = imgNode.parentElement.getAttribute("data-placeholderimagesize");
            else if (mainParent.hasAttribute("data-placeholderimagesize")) placeholderimagesize = mainParent.getAttribute("data-placeholderimagesize");
            else {
                let props = this.getProps();
                let property = props && props && props.placeholderimage ? props.placeholderimage : null;
                placeholderimagesize = property && property.placeholderimagesize ? property.placeholderimagesize : placeholderimagesize;
            }
            // let logoImageSizeValue = placeholderimagesize == "small" ? 0.4 : placeholderimagesize == "medium" ? 0.7 : placeholderimagesize == "large" ? 1 : parseFloat(placeholderimagesize);
            let logoImageSizeValue = this.specialGraphicsUtils.getImageSizeSML(placeholderimagesize);
            w = parseFloat(w) * parseFloat(logoImageSizeValue);
            h = parseFloat(h) * parseFloat(logoImageSizeValue);

            if (imgNode.id.includes("phTextNode")) imgNode.removeChild(dummyDom);
            else imgNode.parentElement.removeChild(dummyDom);

            imgNode.parentElement.parentElement.style.width = w + "px";
            imgNode.parentElement.parentElement.style.height = h + "px";
            mainParent.style.width = w + "px";
            mainParent.style.height = h + "px";
            if (mainParent.id.includes("placeHolderParent")) mainParent.style.minHeight = h + "px";
            imgNode.parentElement.style.width = w + "px";
            imgNode.parentElement.style.height = h + "px";
            imgNode.setAttribute("data-width", w);
            imgNode.setAttribute("data-height", h);
            if (imgNode && imgNode.hasAttribute("data-csstext") && imgNode.getAttribute("data-csstext") != "") {
                var imageDimensionRatio = imgNode.width / imgNode.height;
                var canvasDimensionRatio = w / h;
                if (imageDimensionRatio > canvasDimensionRatio) {
                    imgNode.parentElement.style.height = imgNode.height + "px";
                    imgNode.parentElement.parentElement.style.height = imgNode.height + "px";
                    imgNode.style.setProperty("bottom", 0);
                    imgNode.setAttribute("logosizecropheight", imgNode.height);
                }
            } else if (!imgNode.id.includes("phTextNode")) this.specialGraphicsUtils.updateImageReSize(w, h, imgNode);
            if (imgNode.callback) imgNode.callback();
            imgNode.callback = null;
            if (imgNode.id.includes("phTextNode")) {
                mainParent.style.maxHeight = h + "px";
                mainParent.style.height = "auto";
                mainParent.style.minHeight = "unset";

                mainParent.style.maxWidth = w + "px";
                mainParent.style.width = "auto";

                imgNode.parentElement.style.maxWidth = w + "px";
                imgNode.parentElement.style.width = "auto";

                imgNode.parentElement.style.maxHeight = h + "px";
                imgNode.parentElement.style.height = "auto";
                imgNode.parentElement.style.minHeight = "unset";
            }
        }
    }
};
GenericCarouselImagestack2.prototype.rePositionTextAndElement = function () {
    this.onTextChangeForAllNodes();
    this.rePositioningTextElement();
};
GenericCarouselImagestack2.prototype.textPositionChangeOperation = function (targetParent, pos) {
    if (targetParent) {
        for (let a = 0; a < targetParent.children.length; a++) {
            if (targetParent.children[a].style.position != "absolute") {
                let element = targetParent.children[a];
                let elementId = element.id;
                // console.log("SGG - Childs - " + elementId);
                // let textAlign = pos == "TL" || pos == "ML" || pos == "BL" ? "start" : pos == "TR" || pos == "MR" || pos == "BR" ? "end" : pos == "TM" || pos == "MM" || pos == "BM" ? "center" : "";
                if (elementId && elementId.includes("placeHolderParent")) {
                    element = element.querySelector("[id*='logoContentParent']");
                    elementId = element.id;
                }
                if (elementId.includes("logoContentParent")) {
                    if (element.getElementsByTagName("img").length > 0) {
                        let imageNode = element.getElementsByTagName("img")[0];
                        if (!imageNode.hasAttribute("data-oldimagecropalignment")) imageNode.setAttribute("data-oldimagecropalignment", imageNode.getAttribute("data-imagecropalignment"));
                        imageNode.setAttribute(
                            "data-imagecropalignment",
                            pos == "TL" || pos == "ML" || pos == "BL" ? "left" : pos == "TR" || pos == "MR" || pos == "BR" ? "right" : pos == "TM" || pos == "MM" || pos == "BM" ? "center" : imageNode.hasAttribute("data-oldimagecropalignment") ? imageNode.getAttribute("data-oldimagecropalignment") : "center"
                        );
                        imageNode.removeAttribute("data-style");
                        imageNode.removeAttribute("data-csstext");
                        // console.log("SGG - Logo align - " + imageNode.getAttribute("data-imagecropalignment"));
                        if (imageNode.offsetHeight != 0) this.specialGraphicsUtils.updateImageReSize(imageNode.getAttribute("data-width"), imageNode.getAttribute("data-height"), imageNode);
                    }
                    // } else if (elementId == "sgNumberTextParent") {
                    //     element.style.justifyContent = textAlign == "start" ? "flex-start" : textAlign == "end" ? "flex-end" : "center";
                }
            }
        }
        //Text Element positioning after all text's props change
        this.rePositioningTextElement();
    }
};
GenericCarouselImagestack2.prototype.svgLoadCallback = function (responseData) {
    //Loading svg from menu for icon/image background svg global style - only for "contentBackground"
    for (let a = 0; a < responseData.length; a++) {
        let localSvgParent = responseData[a].parent;
        let colorClass = responseData[a] && responseData[a].color ? responseData[a].color : "clsAccentfill";
        if (localSvgParent && localSvgParent.querySelector("[id*='contentBackground']")) {
            let bgNode = localSvgParent.querySelector("[id*='contentBackground']");
            bgNode.classList.remove(colorClass);
            bgNode.classList.add(colorClass);
            var parser = new DOMParser();
            var doc = parser.parseFromString(responseData[a].data, "image/svg+xml");
            bgNode.innerHTML = "";
            bgNode.appendChild(doc.lastChild);
        }
    }
};
GenericCarouselImagestack2.prototype.placeholderSvgLoadCallback = function (responseData) {
    //Loading svg from menu for icon/image background svg global style - only for "contentBackground"
    for (let a = 0; a < responseData.length; a++) {
        let localSvgParent = responseData[a].parent;
        let colorClass = responseData[a] && responseData[a].color ? responseData[a].color : "clsAccentfill";
        if (localSvgParent) {
            localSvgParent.classList.remove(colorClass);
            localSvgParent.classList.add(colorClass);
            var parser = new DOMParser();
            var doc = parser.parseFromString(responseData[a].data, "image/svg+xml");
            localSvgParent.innerHTML = "";
            localSvgParent.appendChild(doc.lastChild);
        }
    }
};

//Re position text element
GenericCarouselImagestack2.prototype.rePositioningTextElement = function (targetIndex = -1) {
    let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
    for (let i = 0; i < assetParents.length; i++) {
        if (targetIndex == -1 || targetIndex == i) {
            let textInnerParentNode = assetParents[i].querySelector("[id='textInnerParentNode']");

            if (this.sgParent.hasAttribute("singlenode") && this.sgParent.getAttribute("singlenode") == "true" && this.textElement && this.textElement.elementData && this.textElement.elementData.textelementproperties) {
                let textElementStyle = assetParents[i].getAttribute("data-textelementstyle");
                let props = this.textElement.elementData.textelementproperties;
                let textElementSelected = props[textElementStyle] ? props[textElementStyle] : Object.keys(props).length > 0 ? props[Object.keys(props)[0]] : null;
                let target = textElementSelected && textElementSelected.target ? textElementSelected.target : null;
                if (target && target == "title" && assetParents[i].querySelector("[id*='titleTextParent")) textInnerParentNode = assetParents[i].querySelector("[id*='titleTextParent']").parentElement;
                if (target && target == "label" && assetParents[i].querySelector("[id*='titleLabelTextParent")) textInnerParentNode = assetParents[i].querySelector("[id*='titleLabelTextParent']").parentElement;
                if (target && target == "subtitle" && assetParents[i].querySelector("[id*='subTitleTextParent")) textInnerParentNode = assetParents[i].querySelector("[id*='subTitleTextParent']").parentElement;
            }
            this.textElementPositioning(assetParents[i], textInnerParentNode, i);
        }
    }
};
GenericCarouselImagestack2.prototype.textFitOnImageResize = function (targetIndex) {
    this.onTextChangeForAllNodes(this.sgParent, targetIndex);
    this.rePositioningTextElement(targetIndex);
};

"use strict";

function GenericCarouselImagestack3(sgParent, sgData, moodName, metadata, styleName = "", isPlayAnimation = true, textElementData, socialiconsData, fontData, objDataToSG) {
    this.introType = "";
    this.fileclass = "GenericCarouselImagestack3";
    GenericSpecialgraphics.call(this, sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, fontData, objDataToSG);
}

GenericCarouselImagestack3.prototype = Object.create(GenericSpecialgraphics.prototype);

GenericCarouselImagestack3.prototype.initSpecialGraphicsCreation = function () {
    this.specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL);
    this.specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
    if (this.isWidget == false || (this.objDataToSG && this.objDataToSG.menuChange)) {
        GenericSpecialgraphics.prototype.initSpecialGraphicsCreation.call(this);
        this.setIntroType();
        let lytCarouselParent = this.sgParent.querySelector("[id='lytCarouselParent']");
        if (!lytCarouselParent) {
            lytCarouselParent = document.createElement("div");
            lytCarouselParent.id = "lytCarouselParent";
            this.setTextType(lytCarouselParent);
            lytCarouselParent.className = "lytCarouselParent";
            this.sgParent.appendChild(lytCarouselParent);
            if (this.introType == "insidecontent") lytCarouselParent.style.alignItems = "flex-start";
        }

        let startIndex = this.introType == "slidetop" || this.introType == "insidecontent" ? 0 : 1;
        let props = this.getProps();
        for (let c = startIndex; c < this.sgData.length; c++) {
            let assetParent = this.createAssetParent(c, this.sgParent);

            if (c > 0) {
                let lytCommonParent = this.sgParent.querySelector("[id='lytCommonParent']");
                let lytCommonTextParent = this.sgParent.querySelector("[id='lytCommonTextParent']");
                let lytCommonImageParent = this.sgParent.querySelector("[id='lytCommonImageParent']");
                let lytCommonNumberParent = this.sgParent.querySelector("[id='lytCommonNumberParent']");
                if (!lytCommonParent) {
                    lytCommonParent = document.createElement("div");
                    lytCommonParent.id = "lytCommonParent";
                    this.setTextType(lytCommonParent);
                    let animationGlobalClass = "defaultCarouselAnimation";
                    if (this.carouselType && this.carouselType == "onlytitle") animationGlobalClass = "defaultCarouselAnimation5";
                    if (props && props && props.globalanimation) animationGlobalClass = animationGlobalClass + " " + props.globalanimation;
                    lytCommonParent.className = "lytCommonParent " + animationGlobalClass;
                    if (this.introType == "slidetop") lytCommonParent.style.maxHeight = "70%";
                    if (this.introType == "insidecontent") {
                        lytCommonParent.style.position = "absolute";
                        lytCommonParent.style.alignItems = "flex-end";
                    }
                    lytCarouselParent.appendChild(lytCommonParent);
                }
                if (assetParent.querySelector("[id*='textBaseParentNode']")) {
                    //If number depends text then we have to do this
                    let textBaseParent = assetParent.querySelector("[id*='textBaseParentNode']");
                    let textInnerParentNode = textBaseParent.querySelector("[id*='textInnerParentNode']");
                    let placeHolderParent = assetParent.querySelector("[id*='placeHolderParent']");

                    let titleLabelTextParent = textBaseParent.querySelector("[id='titleLabelTextParent']");
                    titleLabelTextParent.classList.remove("commonLabelTitleGap");
                    titleLabelTextParent.classList.add("commonLabelTitleGap");

                    let subTitleTextParent = textBaseParent.querySelector("[id='subTitleTextParent']");
                    subTitleTextParent.classList.remove("commonTitleSubtitleGap");
                    subTitleTextParent.classList.add("commonTitleSubtitleGap");

                    let lytGroupParent = this.sgParent.querySelector("[id='lytGroupParent']");
                    if (!lytGroupParent && this.introType == "insidecontent") {
                        lytGroupParent = document.createElement("div");
                        this.setTextType(lytGroupParent);
                        lytGroupParent.id = "lytGroupParent";
                        lytGroupParent.className = "lytGroupParent";
                        lytCommonParent.appendChild(lytGroupParent);
                        let introParentNode = this.sgParent.querySelector("[id='introParent']");
                        if (introParentNode) {
                            introParentNode.parentElement.removeChild(introParentNode);
                            lytGroupParent.appendChild(introParentNode);
                        }
                    }
                    if (!lytCommonTextParent) {
                        lytCommonTextParent = document.createElement("div");
                        this.setTextType(lytCommonTextParent);
                        lytCommonTextParent.id = "lytCommonTextParent";
                        lytCommonTextParent.className = "lytCommonTextParent";
                        if (lytGroupParent) lytGroupParent.appendChild(lytCommonTextParent);
                        else lytCommonParent.appendChild(lytCommonTextParent);
                    }
                    let lytAssetTextParent = this.sgParent.querySelector("[id='lytAssetTextParent']");
                    lytAssetTextParent = document.createElement("div");
                    lytAssetTextParent.id = "lytAssetTextParent" + c;
                    lytAssetTextParent.className = "lytAssetTextParent";
                    this.setTextType(lytAssetTextParent);
                    lytCommonTextParent.appendChild(lytAssetTextParent);
                    if (textInnerParentNode) {
                        if (this.carouselType == "onlytitle") {
                            lytAssetTextParent.style.margin = window.getComputedStyle(textInnerParentNode).margin;
                            if (c == this.sgData.length - 1) lytAssetTextParent.style.marginBottom = "unset";
                        } else {
                            lytAssetTextParent.style.padding = window.getComputedStyle(textInnerParentNode).margin;
                            if (c == this.sgData.length - 1) lytAssetTextParent.style.paddingBottom = "unset";
                        }
                        textInnerParentNode.style.margin = "unset";
                    }

                    textBaseParent.style.width = "100%";
                    textBaseParent.style.maxHeight = "100%";
                    textBaseParent.parentElement.removeChild(textBaseParent);

                    const inlineStyles = assetParent.getAttribute("style");
                    const styleDeclarations = inlineStyles.split(";");
                    styleDeclarations.forEach((declaration) => {
                        try {
                            const trimmedDeclaration = declaration.trim().split(":")[0];
                            if (trimmedDeclaration.includes("--placeholder")) {
                                lytAssetTextParent.style.setProperty(trimmedDeclaration, assetParent.style.getPropertyValue(trimmedDeclaration));
                            }
                        } catch (error) {}
                    });

                    if (placeHolderParent) {
                        lytAssetTextParent.appendChild(placeHolderParent);
                        textBaseParent.style.flex = "2";
                    }
                    textBaseParent.style.width = "50%";
                    lytAssetTextParent.appendChild(textBaseParent);
                    lytCommonTextParent.scrollTop = 0;
                    if (c == 1) textBaseParent.classList.add("active");
                }
                if (assetParent.querySelector("[id*='coverImageParent']")) {
                    //If number depends text then we have to do this
                    let coverImageParent = assetParent.querySelector("[id*='coverImageParent']");
                    if (!lytCommonImageParent) {
                        lytCommonImageParent = document.createElement("div");
                        lytCommonImageParent.id = "lytCommonImageParent";
                        this.setTextType(lytCommonImageParent);
                        lytCommonImageParent.className = "lytCommonImageParent";
                        lytCommonParent.appendChild(lytCommonImageParent);

                        [...assetParent.attributes].forEach((attr) => {
                            if (attr.name && attr.name == "style") lytCommonImageParent.setAttribute(attr.nodeName, attr.nodeValue);
                        });
                    }
                    if (c == 1) coverImageParent.classList.add("active");
                    coverImageParent.style.width = "100%";
                    coverImageParent.style.left = "0px";
                    coverImageParent.style.top = "0px";
                    coverImageParent.parentElement.removeChild(coverImageParent);
                    lytCommonImageParent.appendChild(coverImageParent);
                }
                if (assetParent.querySelector("[id='sgNumberTextParent']")) {
                    //If number depends text then we have to do this
                    let numberParent = assetParent.querySelector("[id='sgNumberTextParent']");
                    if (c == this.sgData.length - 1) numberParent.style.marginBottom = "unset";
                    if (c == 1) numberParent.style.marginTop = "unset";
                    if (!lytCommonNumberParent) {
                        lytCommonNumberParent = document.createElement("div");
                        this.setTextType(lytCommonNumberParent);
                        lytCommonNumberParent.id = "lytCommonNumberParent";
                        lytCommonNumberParent.className = "lytCommonNumberParent";
                        lytCommonParent.appendChild(lytCommonNumberParent);
                    }
                    let numberSelector = document.createElement("div");
                    numberSelector.id = "numberSelector";
                    numberSelector.className = "numberSelector";
                    numberParent.appendChild(numberSelector);

                    let numberFontSize = assetParent.style.getPropertyValue("--numberFont").trim();
                    numberParent.style.setProperty("--numberFont", numberFontSize);
                    if (c == 1) numberParent.classList.add("active");
                    numberParent.parentElement.removeChild(numberParent);
                    lytCommonNumberParent.appendChild(numberParent);
                }
                this.applyPropsForNodes(c);
                if (lytCommonTextParent) {
                    let textFulHeight = parseFloat(window.getComputedStyle(lytCommonTextParent).height);
                    let lytAssetTextParent = lytCommonTextParent.querySelector("[id*='lytAssetTextParent" + c + "']");
                    let textBaseParent = lytAssetTextParent ? lytAssetTextParent.querySelector("[id*='textBaseParentNode']") : null;
                    let divideValue = this.introType == "slidetop" ? 2 : 1;
                    if (textBaseParent) textBaseParent.setAttribute("fullheight", parseFloat(textFulHeight) / divideValue);
                }
                if (this.introType == "insidecontent" && c == 1) {
                    let introText = this.sgParent.querySelector("[id='lytAssetTextParent0']");
                    if (introText) {
                        let textFulHeight = parseFloat(window.getComputedStyle(introText).height);
                        let textBaseParent = introText ? introText.querySelector("[id*='textBaseParentNode']") : null;
                        if (textBaseParent) textBaseParent.setAttribute("fullheight", parseFloat(textFulHeight));
                    }
                }
                let coverImageParent = lytCommonImageParent ? lytCommonImageParent.querySelector("[id*='coverImageParent']") : null;
                let coverimage = coverImageParent ? coverImageParent.querySelector("[data-target-id='coverimage']") : null;
                if (coverimage) {
                    let styleNode = window.getComputedStyle(coverImageParent);
                    coverimage.setAttribute("data-height", parseFloat(styleNode.height));
                    coverimage.setAttribute("data-width", parseFloat(styleNode.width));
                    this.specialGraphicsUtils.updateImageReSize(coverimage.getAttribute("data-width"), coverimage.getAttribute("data-height"), coverimage);
                }
                this.onTextChangeForAllNodes(this.sgParent, c);
            } else if (c == 0 && assetParent.querySelector("[id*='textBaseParentNode']")) {
                let textBaseNode = assetParent.querySelector("[id*='textBaseParentNode']");
                let introParent = this.sgParent.querySelector("[id='introParent']");
                if (!introParent) {
                    introParent = document.createElement("div");
                    introParent.id = "introParent";
                    introParent.className = "introParent";
                    lytCarouselParent.appendChild(introParent);
                }

                let lytAssetTextParent = this.sgParent.querySelector("[id='lytAssetTextParent']");
                lytAssetTextParent = document.createElement("div");
                lytAssetTextParent.id = "lytAssetTextParent" + c;
                lytAssetTextParent.className = "lytAssetTextParent";
                this.setTextType(lytAssetTextParent);
                introParent.appendChild(lytAssetTextParent);

                textBaseNode.parentElement.removeChild(textBaseNode);
                lytAssetTextParent.appendChild(textBaseNode);
                introParent.style.maxHeight = textBaseNode.style.maxHeight;
                introParent.style.height = textBaseNode.style.height;
                if (this.introType == "insidecontent") {
                    introParent.style.setProperty("max-height", "32%", "important");
                    introParent.style.height = "auto";
                }
                textBaseNode.style.maxHeight = "100%";
                textBaseNode.style.height = "auto";

                let sgTitleNode = textBaseNode.querySelector("[id='sgTitleNode']");
                if (sgTitleNode) {
                    sgTitleNode.id = sgTitleNode.id + "0";
                    sgTitleNode.parentElement.id = sgTitleNode.parentElement.id + "0";
                }
                let sgTitleLabelNode = textBaseNode.querySelector("[id='sgTitleLabelNode']");
                if (sgTitleLabelNode) {
                    sgTitleLabelNode.id = sgTitleLabelNode.id + "0";
                    sgTitleLabelNode.parentElement.id = sgTitleLabelNode.parentElement.id + "0";
                }
                let sgSubTitleNode = textBaseNode.querySelector("[id='sgSubTitleNode']");
                if (sgSubTitleNode) {
                    sgSubTitleNode.id = sgSubTitleNode.id + "0";
                    sgSubTitleNode.parentElement.id = sgSubTitleNode.parentElement.id + "0";
                }
                let textFulHeight = parseFloat(window.getComputedStyle(introParent).height);
                textBaseNode.setAttribute("fullheight", parseFloat(textFulHeight));
                assetParent.style.display = "none";
            }
        }
        this.setScrollData(true);
        this.updateImageNodes();
    }
};

GenericCarouselImagestack3.prototype.applyPropsForNodes = function (index) {
    let props = this.getProps();
    let lytCommonImageParent = this.sgParent.querySelector("[id='lytCommonImageParent']");
    let lytCommonTextParent = this.sgParent.querySelector("[id='lytCommonTextParent']");
    let lytCommonNumberParent = this.sgParent.querySelector("[id='lytCommonNumberParent']");
    if (index == 1 && props && props) {
        if (lytCommonTextParent) {
            this.applyProps(index, lytCommonTextParent, "text");
            let lytGroupParent = this.sgParent.querySelector("[id='lytGroupParent']");
            if (lytGroupParent) {
                lytGroupParent.style.width = lytCommonTextParent.style.width;
                lytGroupParent.style.margin = lytCommonTextParent.style.margin;
                let styleNode = window.getComputedStyle(lytGroupParent);
                lytGroupParent.style.height = "calc(100% - " + (parseFloat(styleNode.marginLeft) + parseFloat(styleNode.marginRight)) + "px)";
                lytCommonTextParent.style.width = "100%";
                lytCommonTextParent.style.margin = "unset";
            }
        }
        if (lytCommonImageParent) this.applyProps(index, lytCommonImageParent, "image");
        if (lytCommonNumberParent) {
            this.applyProps(index, lytCommonNumberParent, "number");
            if (this.introType == "slidetop") {
                lytCommonNumberParent.style.maxHeight = lytCommonNumberParent.style.height;
                lytCommonNumberParent.style.height = "auto";
            }
        }
    }
};
GenericCarouselImagestack3.prototype.applyProps = function (c, targetNode, propName = "") {
    let props = this.getProps();
    if (c == 1 && props) {
        if (props[propName]) {
            let textStyle = window.getComputedStyle(targetNode);
            if (props[propName].parentposition) this.specialgraphicsPropertyUtils.updatePosition(targetNode, props[propName].parentposition);
            if (props[propName].parentmargin) {
                this.specialgraphicsPropertyUtils.updateMargin(props[propName].parentmargin, targetNode);
                // targetNode.style.height = "calc(" + textStyle.height + " - " + (parseFloat(textStyle.marginBottom) + parseFloat(textStyle.marginTop)) + "px)";
                targetNode.style.height = "calc(100% - " + (parseFloat(textStyle.marginBottom) + parseFloat(textStyle.marginTop)) + "px)";
            }
        }
    }
};
GenericCarouselImagestack3.prototype.updateImageNodes = function () {
    let arrImageNodes = this.sgParent.querySelectorAll("[id*='coverImageParent']");
    for (let a = 0; a < arrImageNodes.length; a++) {
        let imageNode = arrImageNodes[a].querySelector("img[id*='coverimage']");
        imageNode.setAttribute("data-width", parseFloat(imageNode.parentElement.parentElement.clientWidth));
        imageNode.setAttribute("data-height", parseFloat(imageNode.parentElement.parentElement.clientHeight));
        if (imageNode) this.specialGraphicsUtils.updateImageReSize(imageNode.getAttribute("data-width"), imageNode.getAttribute("data-height"), imageNode);
    }
};
GenericCarouselImagestack3.prototype.specialGraphicsCreationComplete = function () {
    this.setIntroType();
    GenericSpecialgraphics.prototype.specialGraphicsCreationComplete.call(this, false);
};

GenericCarouselImagestack3.prototype.changeVariation = function (slideDomContentGroup, updateOnlyVariation = false) {
    GenericSpecialgraphics.prototype.changeVariation.call(this, slideDomContentGroup, updateOnlyVariation, false);

    this.applyPropsForNodes(1);
    //Setting up number visibility using floater number enable/disable option
    let nodeData = slideDomContentGroup.getElementsByTagName("numbertext")[0];
    let arrNumber = this.sgParent.querySelectorAll("[id*='sgNumberTextNode']");
    for (let a = 0; a < arrNumber.length; a++) {
        if (arrNumber[a] && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
            arrNumber[a].style.display = "none";
            arrNumber[a].parentElement.style.display = "none";
        } else if (arrNumber[a]) {
            var display = arrNumber[a].hasAttribute("display") ? arrNumber[a].getAttribute("display") : "";
            arrNumber[a].style.display = display;
            arrNumber[a].parentElement.style.display = display;
        }
    }
    //if number is disble hiding the number parent
    let lytCommonNumberParent = this.sgParent.querySelector("[id='lytCommonNumberParent']");
    if (arrNumber.length > 0 && lytCommonNumberParent && arrNumber[0].style.display == "none") lytCommonNumberParent.style.display = "none";
    else if (lytCommonNumberParent) lytCommonNumberParent.style.removeProperty("display");

    this.resetHeight();
    this.setScrollData(true);
};

GenericCarouselImagestack3.prototype.resetHeight = function () {
    if (this.carouselType && this.carouselType == "onlytitle") {
        let animationDiv = this.sgParent.parentElement && this.sgParent.parentElement.parentElement ? this.sgParent.parentElement.parentElement : null;
        let hasIntro = animationDiv && animationDiv.hasAttribute("data-variation-type") && animationDiv.getAttribute("data-variation-type").includes("intro") ? false : true;
        let introParent = this.sgParent.querySelector("[id='introParent']");
        if (introParent) introParent.style.display = hasIntro ? "flex" : "none";
        let lytCommonTextParent = this.sgParent.querySelector("[id='lytCommonTextParent']");
        if (lytCommonTextParent) {
            if (lytCommonTextParent.hasAttribute("maxheight")) lytCommonTextParent.removeAttribute("maxheight");
            if (lytCommonTextParent.hasAttribute("fullheight")) lytCommonTextParent.removeAttribute("fullheight");
            lytCommonTextParent.style.removeProperty("height");
            lytCommonTextParent.style.flex = "2";
            let targetNodeStyle = window.getComputedStyle(lytCommonTextParent);
            let maxHeight = targetNodeStyle.height;
            let mb = isNaN(parseFloat(targetNodeStyle.marginBottom)) ? 0 : parseFloat(targetNodeStyle.marginBottom);
            let mt = isNaN(parseFloat(targetNodeStyle.marginTop)) ? 0 : parseFloat(targetNodeStyle.marginTop);
            maxHeight = parseFloat(maxHeight) - (mb + mt);
            lytCommonTextParent.setAttribute("fullheight", maxHeight);
            lytCommonTextParent.style.removeProperty("flex");
        }
    }
};
GenericCarouselImagestack3.prototype.floaterNavigation = function (index) {
    GenericSpecialgraphics.prototype.floaterNavigation.call(this, index);
    if (this.currentNodeIndex != 1) this.setScrollData();
    else if (this.currentNodeIndex == 1 && ((this.introType != "slidetop" && this.introType != "insidecontent") || (this.carouselType && this.carouselType == "onlytitle"))) this.setActiveData();
};

GenericCarouselImagestack3.prototype.setScrollData = function (checkCondition = false) {
    this.setActiveData();
    let textParent = this.sgParent.querySelector("[id='lytAssetTextParent" + (this.currentNodeIndex - 1) + "']");
    let lytCommonTextParent = this.sgParent.querySelector("[id='lytCommonTextParent']");
    let lytCommonNumberParent = this.sgParent.querySelector("[id='lytCommonNumberParent']");
    if (lytCommonTextParent && textParent && lytCommonTextParent.offsetHeight != 0 && lytCommonTextParent.offsetWidth != 0) {
        let maxHeight = window.getComputedStyle(lytCommonTextParent).height;
        let scrollValue = textParent.offsetTop - lytCommonTextParent.scrollTop;
        let isInside = scrollValue >= 0 && scrollValue < parseInt(maxHeight) ? true : false;

        if (isInside == false || this.currentNodeIndex - 1 == 1 || checkCondition) {
            if (!lytCommonTextParent.hasAttribute("fullheight")) lytCommonTextParent.setAttribute("fullheight", maxHeight);
            else if (lytCommonTextParent.hasAttribute("fullheight")) maxHeight = lytCommonTextParent.getAttribute("fullheight");
            lytCommonTextParent.style.height = parseFloat(maxHeight) + "px";
            if (textParent) textParent.scrollIntoView(false);

            let totalHeight = 0;
            for (let a = 1; a < this.sgData.length; a++) {
                let lytAssetTextParent = lytCommonTextParent.querySelector("[id='lytAssetTextParent" + a + "']");
                if (lytAssetTextParent) {
                    let textStyle = window.getComputedStyle(lytAssetTextParent);
                    let nodeHeight = parseFloat(textStyle.height) + parseFloat(textStyle.marginTop) + parseFloat(textStyle.marginBottom);

                    let parentTop = lytCommonTextParent.getBoundingClientRect().top;
                    let childTop = lytAssetTextParent.getBoundingClientRect().top;
                    let offsetTopValue = childTop - parentTop;

                    offsetTopValue = lytAssetTextParent.offsetTop - lytCommonTextParent.scrollTop;

                    let check1 = offsetTopValue + parseInt(nodeHeight) <= parseInt(maxHeight);
                    let check2 = offsetTopValue + parseInt(nodeHeight) <= parseInt(maxHeight) + 5;
                    let check3 = offsetTopValue + parseInt(nodeHeight) + 5 <= parseInt(maxHeight);
                    if (lytAssetTextParent && offsetTopValue >= 0 && (check1 || check2 || check3)) {
                        let newHeight = totalHeight + parseFloat(nodeHeight);
                        if (newHeight > parseFloat(maxHeight)) {
                            a = 100;
                            lytCommonTextParent.style.height = totalHeight + "px";
                        } else totalHeight = newHeight;
                    }
                    if (this.sgData.length - 1 == a && totalHeight < parseFloat(maxHeight)) lytCommonTextParent.style.height = totalHeight + "px";
                }
            }
            if (textParent) textParent.scrollIntoView(false);
            // if (textParent && this.isPlayAnimation == false) textParent.scrollIntoView(false);
            // else if (textParent) textParent.scrollIntoView({ behavior: "smooth", block: "end", inline: "nearest" });
        }
        if (lytCommonNumberParent) {
            let arrNumbres = lytCommonNumberParent.querySelectorAll("[id*='sgNumberTextParent']");
            let numberNode = arrNumbres[this.currentNodeIndex - 2] ? arrNumbres[this.currentNodeIndex - 2] : null;
            if (numberNode) {
                let numberMaxHeight = window.getComputedStyle(lytCommonNumberParent).height;
                let numberScrollValue = numberNode.offsetTop - lytCommonNumberParent.scrollTop;
                let isNumberInside = numberScrollValue >= 0 && numberScrollValue < parseInt(numberMaxHeight) ? true : false;
                if (isNumberInside == false) numberNode.scrollIntoView(false);
            }
        }
    }
};
GenericCarouselImagestack3.prototype.setActiveData = function () {
    let lytCommonTextParent = this.sgParent.querySelector("[id='lytCommonTextParent']");
    let arrTextSelector = lytCommonTextParent ? lytCommonTextParent.querySelectorAll("[id*='textBaseParentNode']") : this.sgParent.querySelectorAll("[id*='textBaseParentNode']");
    let lytCommonImageParent = this.sgParent.querySelector("[id='lytCommonImageParent']");
    let arrImageSelector = lytCommonImageParent ? lytCommonImageParent.querySelectorAll("[id='coverImageParent']") : this.sgParent.querySelectorAll("[id='coverImageParent']");
    let lytCommonNumberParent = this.sgParent.querySelector("[id='lytCommonNumberParent']");
    let arrNumberSelector = lytCommonNumberParent ? lytCommonNumberParent.querySelectorAll("[id='sgNumberTextParent']") : this.sgParent.querySelectorAll("[id='sgNumberTextParent']");

    let startIndex = this.introType == "slidetop" || this.introType == "insidecontent" ? 1 : 0;
    for (let a = startIndex; a < this.sgData.length; a++) {
        if (this.currentNodeIndex - 1 != 0) {
            if (arrNumberSelector[a - 1] && this.isPlayAnimation == false) arrNumberSelector[a - 1].classList.add("editorAnimation");
            if (arrNumberSelector[a - 1]) arrNumberSelector[a - 1].classList.add("nonActive");
            if (arrNumberSelector[a - 1] && a == this.currentNodeIndex - 1) {
                arrNumberSelector[a - 1].classList.add("active");
                arrNumberSelector[a - 1].classList.remove("nonActive");
            } else if (arrNumberSelector[a - 1]) arrNumberSelector[a - 1].classList.remove("active");

            if (arrImageSelector[a - 1] && this.isPlayAnimation == false) arrImageSelector[a - 1].classList.add("editorAnimation");
            if (arrImageSelector[a - 1]) arrImageSelector[a - 1].style.setProperty("--textPointerEvent", "none");
            if (arrImageSelector[a - 1]) arrImageSelector[a - 1].classList.add("nonActive");
            if (arrImageSelector[a - 1]) arrImageSelector[a - 1].classList.remove("carouselimagehide");

            if (arrImageSelector[a - 1] && a == this.currentNodeIndex - 1) {
                arrImageSelector[a - 1].classList.add("active");
                arrImageSelector[a - 1].classList.remove("nonActive");
                arrImageSelector[a - 1].style.setProperty("--textPointerEvent", "auto");
            } else if (arrImageSelector[a - 1]) arrImageSelector[a - 1].classList.remove("active");

            if (arrTextSelector[a - 1] && this.isPlayAnimation == false) {
                arrTextSelector[a - 1].classList.add("editorAnimation");
                arrTextSelector[a - 1].parentElement.classList.add("editorAnimation");
            }
            if (arrTextSelector[a - 1]) arrTextSelector[a - 1].parentElement.style.setProperty("--textPointerEvent", "none");
            if (arrTextSelector[a - 1]) arrTextSelector[a - 1].parentElement.classList.add("nonActive");

            if (arrTextSelector[a - 1] && a == this.currentNodeIndex - 1) {
                arrTextSelector[a - 1].parentElement.classList.add("active");
                arrTextSelector[a - 1].parentElement.classList.remove("nonActive");
                arrTextSelector[a - 1].parentElement.style.setProperty("--textPointerEvent", "auto");
            } else if (arrTextSelector[a - 1]) arrTextSelector[a - 1].parentElement.classList.remove("active");

            if (a == this.currentNodeIndex - 2 && arrImageSelector[a - 1] && this.isPlayAnimation) arrImageSelector[a - 1].classList.add("carouselimagehide");
        } else {
            if (arrImageSelector[a - 1]) arrImageSelector[a - 1].style.setProperty("--textPointerEvent", "none");
            if (arrTextSelector[a - 1]) arrTextSelector[a - 1].parentElement.style.setProperty("--textPointerEvent", "none");
        }
    }
};

GenericCarouselImagestack3.prototype.initIntroAnimation = function (isShow = true) {
    //1-into  2-text  3-image  4-number
    let delay = [1, 1.2, 1.4, 1.6, 1.8];
    let duration = [1, 1, 1, 1];
    let easeValue = "cubic-bezier(0.65, 0, 0.35, 1)";
    let startYValue = 100;
    for (let a = 0; a < 4; a++) {
        let id = a == 1 ? "lytCommonTextParent" : a == 2 ? "lytCommonImageParent" : a == 3 ? "lytCommonNumberParent" : "introParent";
        let element = this.sgParent.querySelector("[id='" + id + "']");
        if (element) {
            element.style.setProperty("--carouselIntroY", startYValue + "px");
            element.classList.remove("carouselinit");
            element.classList.add("carouselinit");
            if (isShow) {
                setTimeout(() => {
                    duration[a] = this.isPlayAnimation ? duration[a] : 0;
                    delay[a] = this.isPlayAnimation ? delay[a] : 0;
                    if (this.isPlayAnimation) {
                        element.style.transition = "all " + duration[a] + "s " + delay[a] + "s " + easeValue;
                        setTimeout(() => {
                            element.style.transition = "unset";
                        }, (duration[a] + delay[a]) * 1000);
                    }
                    element.style.opacity = 1;
                    element.style.willChange = "transform";
                    element.style.transform = "unset";
                }, 0);
            }
        }
    }
};

GenericCarouselImagestack3.prototype.initPresentSG = function (slideContent) {
    let hasEmptyIntro = this.checkIntroAnimation();
    let specialgraphicsParent = slideContent && slideContent.querySelector("[id='specialgraphicsParent']") ? slideContent.querySelector("[id='specialgraphicsParent']") : null;
    if (specialgraphicsParent) specialgraphicsParent.setAttribute("hasemptyintro", hasEmptyIntro);
};

GenericCarouselImagestack3.prototype.gotoAndStopFirstNode = function (completeCallback) {
    let lytCommonParent = this.sgParent.querySelector("[id='lytCommonParent']");
    let lytCommonTextParent = this.sgParent.querySelector("[id='lytCommonTextParent']");
    let lytCommonImageParent = this.sgParent.querySelector("[id='lytCommonImageParent']");
    let lytCommonNumberParent = this.sgParent.querySelector("[id='lytCommonNumberParent']");
    let arrAnimationNodes = lytCommonTextParent ? lytCommonTextParent.querySelectorAll("[class*='moodanimation']") : [];
    for (let a = 0; a < arrAnimationNodes.length; a++) {
        arrAnimationNodes[a].classList.remove("moodanimation");
    }
    arrAnimationNodes = lytCommonImageParent ? lytCommonImageParent.querySelectorAll("[class*='moodanimation']") : [];
    for (let a = 0; a < arrAnimationNodes.length; a++) {
        arrAnimationNodes[a].classList.remove("moodanimation");
    }
    arrAnimationNodes = lytCommonNumberParent ? lytCommonNumberParent.querySelectorAll("[class*='moodanimation']") : [];
    for (let a = 0; a < arrAnimationNodes.length; a++) {
        arrAnimationNodes[a].classList.remove("moodanimation");
    }
    if (this.isPlayAnimation && lytCommonParent) {
        let arrAnimationNodesEditor = lytCommonParent.querySelectorAll("[class*='editorAnimation']");
        for (let a = 0; a < arrAnimationNodesEditor.length; a++) {
            arrAnimationNodesEditor[a].classList.remove("editorAnimation");
        }
    }
    this.setIntroType();
    let hasEmptyIntro = this.checkIntroAnimation();
    let delay = this.isPlayAnimation ? 1000 : 0;
    if (this.introType == "slidetop" || this.introType == "insidecontent") {
        hasEmptyIntro = true;
        this.initIntroAnimation();
        this.currentNodeIndex = 2;
        this.floaterNavigation(0);
        this.eventManager.dispatch("positionchangecallback", hasEmptyIntro == true ? 1 : 0);

        setTimeout(() => {
            completeCallback ? completeCallback() : "";
        }, delay);
        this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", null, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 2);
        this.currentNodeIndex = 2;
    } else {
        if (this.currentNodeIndex - 1 == 0 && lytCommonImageParent) lytCommonParent.style.opacity = 0;
        this.initIntroAnimation(hasEmptyIntro);
        if (hasEmptyIntro && completeCallback) {
            setTimeout(() => {
                completeCallback();
            }, delay);
        }
        GenericSpecialgraphics.prototype.gotoAndStopFirstNode.call(this, completeCallback);
        if (lytCommonParent && this.isPlayAnimation && hasEmptyIntro) lytCommonParent.style.transition = "opacity 2s 1.5s ease";
        if (this.currentNodeIndex - 1 == 1 && lytCommonParent) lytCommonParent.style.opacity = 1;
    }
};
GenericCarouselImagestack3.prototype.next = function (completeCallback) {
    this.sgParent.setAttribute("dotransition", "false");
    let oldIndex = this.currentNodeIndex - 1 < 0 ? 0 : this.currentNodeIndex - 1;
    this.currentNodeIndex = this.currentNodeIndex + 1;
    if (this.currentNodeIndex > this.sgData.length) return;
    this.sgParent.removeAttribute("hasemptyintro");

    let lytCommonParent = this.sgParent.querySelector("[id='lytCommonParent']");
    if (lytCommonParent && this.isPlayAnimation) lytCommonParent.style.transition = "opacity 2s 1.5s ease";

    if (this.currentNodeIndex == 2 && this.introType != "slidetop" && this.introType != "insidecontent") {
        this.initIntroAnimation();
        this.updateShowHideInfo(oldIndex, false);
        this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", completeCallback, this.isPlayAnimation, this.eventManager, oldIndex, "moodsutilintermediate");
    }
    if (!this.isPlayAnimation) {
        let assetParent = this.sgParent.querySelector("[id='assetParent0']");
        if (assetParent) assetParent.style.opacity = 0;
    }
    this.updateShowHideInfo(this.currentNodeIndex - 1);
    this.setScrollData();

    setTimeout(
        () => {
            completeCallback ? completeCallback() : "";
        },
        this.isPlayAnimation ? 1000 : 0
    );
};
GenericCarouselImagestack3.prototype.previous = function (completeCallback) {
    this.currentNodeIndex = this.currentNodeIndex - 1;
    this.sgParent.removeAttribute("hasemptyintro");

    let hasEmptyIntro = this.checkIntroAnimation();
    if (this.introType == "slidetop" || this.introType == "insidecontent") hasEmptyIntro = true;
    if (hasEmptyIntro == true && this.currentNodeIndex <= 1) return false;
    if (this.currentNodeIndex <= 0) return false;

    this.updateShowHideInfo(this.currentNodeIndex - 1);
    if (this.currentNodeIndex == 1) {
        if (this.sgParent.querySelector("[id='lytCommonParent']")) {
            if (this.isPlayAnimation) this.sgParent.querySelector("[id='lytCommonParent']").style.transition = "opacity 2s 0.5s ease";
            this.sgParent.querySelector("[id='lytCommonParent']").style.opacity = 0;
        }
        this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1, "moodsutilintermediate");
    }
    this.setScrollData();

    setTimeout(
        () => {
            completeCallback ? completeCallback() : "";
        },
        this.isPlayAnimation ? 1000 : 0
    );
};

GenericCarouselImagestack3.prototype.updateHeightForText = function (assetParent) {
    let index = parseFloat(assetParent.id.replace("assetParent", ""));
    let textParent = this.sgParent.querySelector("[id='lytAssetTextParent" + index + "']");
    GenericSpecialgraphics.prototype.updateHeightForText.call(this, textParent ? textParent : assetParent);
};
GenericCarouselImagestack3.prototype.getTargetElement = function (elementID) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    if (assetParent && assetParent.querySelector("[id='" + elementID + "']")) return assetParent.querySelector("[id='" + elementID + "']");
    let lytCommonTextParent = this.sgParent.querySelector("[id='lytCommonTextParent']");
    if (lytCommonTextParent) {
        let allNodes = lytCommonTextParent.querySelectorAll("[id*='" + elementID + "']");
        if (allNodes[this.currentNodeIndex - 2]) return allNodes[this.currentNodeIndex - 2];
    }
    let lytCommonImageParent = this.sgParent.querySelector("[id='lytCommonImageParent']");
    if (lytCommonImageParent) {
        let allNodes = lytCommonImageParent.querySelectorAll("[id*='" + elementID + "']");
        if (allNodes[this.currentNodeIndex - 2]) return allNodes[this.currentNodeIndex - 2];
        else if (allNodes.length == 1) return allNodes[0];
    }
    let introParent = this.sgParent.querySelector("[id='introParent']");
    if (introParent && introParent.querySelector("[id*='" + elementID + "']")) return introParent.querySelector("[id*='" + elementID + "']");
};

GenericCarouselImagestack3.prototype.setIntroType = function () {
    let propsData = this.getProps();
    this.introType = propsData && propsData && propsData.introtype ? propsData.introtype : "";
    this.sgParent.parentElement.parentElement.setAttribute("introtype", this.introType);
    this.sgParent.parentElement.parentElement.setAttribute("data-intro", this.introType == "slidetop" || this.introType == "insidecontent" ? false : true);
};

GenericCarouselImagestack3.prototype.changeText = function (updatedText, elementId, targetIndex, textType) {
    GenericSpecialgraphics.prototype.changeText.call(this, updatedText, elementId, targetIndex, textType);
    this.resetHeight();
    this.setScrollData(true);
};

GenericCarouselImagestack3.prototype.startIndex = function (currentSlideData) {
    return this.specialGraphicsUtils.getStartIndex(currentSlideData, this.sgParent);

    // let presentParent = currentSlideData ? currentSlideData : this.sgParent;
    // let introParent = presentParent ? presentParent.querySelector("[id='introParent']") : null;
    // let sgParent = presentParent ? presentParent.querySelector("[id='specialgraphicsParent']") : this.sgParent;
    // if (this.introType != "slidetop" && this.introType != "insidecontent" && presentParent) introParent = presentParent.querySelector("[id='assetParent0']");

    // let isNotVisible = introParent?.style?.display == "none" || introParent?.style?.opacity == 0 || introParent?.style?.opacity == "0";
    // if (isNotVisible) sgParent.setAttribute("startindex", "1");
    // else sgParent.removeAttribute("startindex");

    // let localParent = sgParent ? sgParent : this.sgParent;
    // let animationDIV = localParent?.parentElement?.parentElement ? localParent.parentElement.parentElement : null;
    // let showIntro = animationDIV?.hasAttribute("data-intro") ? animationDIV.getAttribute("data-intro") : "true";

    // return (isNotVisible || !assetParent) && showIntro != "true" ? 1 : 0;
};

"use strict";

function GenericCarouselImagestack4(sgParent, sgData, moodName, metadata, styleName = "", isPlayAnimation = true, textElementData, socialiconsData, fontData, objDataToSG) {
    this.carouselType = "type4";
    GenericSpecialgraphics.call(this, sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, fontData, objDataToSG);
}

GenericCarouselImagestack4.prototype = Object.create(GenericSpecialgraphics.prototype);

GenericCarouselImagestack4.prototype.initSpecialGraphicsCreation = function () {
    this.specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL);
    this.specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
    GenericSpecialgraphics.prototype.initSpecialGraphicsCreation.call(this);
    this.sgParent.parentElement.parentElement.setAttribute("data-intro", "false");
    if (this.isWidget == false || (this.objDataToSG && this.objDataToSG.menuChange)) {
        let props = this.getProps();

        let lytCommonParent = this.sgParent.querySelector("[id='lytCommonParent']");
        if (!lytCommonParent) {
            lytCommonParent = document.createElement("div");
            lytCommonParent.id = "lytCommonParent";
            lytCommonParent.className = "lytCommon4Parent";
            this.setTextType(lytCommonParent);
            this.sgParent.appendChild(lytCommonParent);
        }

        let lytImageParent = this.sgParent.querySelector("[id='lytImageParent']");
        let lytTextParent = this.sgParent.querySelector("[id='lytTextParent']");
        let lytNumberParent = this.sgParent.querySelector("[id='lytNumberParent']");

        let animationGlobalClass = "defaultCarouselAnimation";
        if (props && props && props.globalanimation) animationGlobalClass = props.globalanimation;
        if (!this.oldContent) {
            for (let c = 0; c < this.sgData.length; c++) {
                let assetParent = this.createAssetParent(c, this.sgParent);

                if (c > 0) {
                    let lytCarousel4Parent = this.sgParent.querySelector("[id='lytCarousel4Parent']");
                    if (!lytCarousel4Parent) {
                        lytCarousel4Parent = document.createElement("div");
                        lytCarousel4Parent.id = "lytCarousel4Parent";
                        this.setTextType(lytCarousel4Parent);
                        lytCarousel4Parent.className = "lytCarousel4Parent";
                        lytCommonParent.appendChild(lytCarousel4Parent);
                    }
                    let contentMainParent = assetParent.querySelector("[id='contentMainParent']");
                    if (contentMainParent) {
                        contentMainParent.style.maxWidth = "100%";
                        contentMainParent.style.width = "auto";
                    }

                    let numberAbsolute = props && props && props.number && props.number.positionvalue && props.number.positionvalue == "absolute" ? true : false;
                    if (numberAbsolute) {
                        if (!lytNumberParent) {
                            lytNumberParent = document.createElement("div");
                            lytNumberParent.id = "lytNumberParent";
                            this.setTextType(lytNumberParent);
                            lytNumberParent.className = "lytNumberParent " + animationGlobalClass;
                            lytCarousel4Parent.appendChild(lytNumberParent);
                            if (props && props && props.number) {
                                if (props.number.parentposition) this.specialgraphicsPropertyUtils.updatePosition(lytNumberParent, props.number.parentposition);
                                if (props.number.parentmargin) this.specialgraphicsPropertyUtils.updateMargin(props.number.parentmargin, lytNumberParent);
                            }
                            lytNumberParent.scrollTop = 0;
                        }
                        if (assetParent.querySelector("[id*='sgNumberTextParent']")) {
                            let numberParent = document.createElement("div");
                            numberParent.id = "numberParent" + c;
                            this.setTextType(numberParent);
                            numberParent.className = "numberParent " + animationGlobalClass;
                            lytNumberParent.appendChild(numberParent);

                            let numberNode = assetParent.querySelector("[id*='sgNumberTextParent']");
                            numberNode.parentElement.removeChild(numberNode);
                            numberParent.appendChild(numberNode);
                            [...assetParent.attributes].forEach((attr) => {
                                if (attr.name && attr.name == "style") numberParent.setAttribute(attr.nodeName, attr.nodeValue);
                            });
                            if (props && props && props.number && props && props && props.number.globalstyle) {
                                numberParent.classList.remove(props.number.globalstyle);
                                numberParent.classList.add(props.number.globalstyle);
                                numberParent.classList.add("clsSingleColorParent");
                            }
                        }
                    }
                    if (!lytImageParent) {
                        lytImageParent = document.createElement("div");
                        lytImageParent.id = "lytImageParent";
                        this.setTextType(lytImageParent);
                        lytImageParent.className = "lytImageParent " + animationGlobalClass;
                        lytCarousel4Parent.appendChild(lytImageParent);
                        if (props && props && props.image) {
                            if (props.image.parentposition) this.specialgraphicsPropertyUtils.updatePosition(lytImageParent, props.image.parentposition);
                            if (props.image.parentmargin) this.specialgraphicsPropertyUtils.updateMargin(props.image.parentmargin, lytImageParent);
                            if (props.image.radius) lytImageParent.style.setProperty("--imageRadius", props.image.radius);
                            lytImageParent.style.width = "auto";
                        }
                        lytImageParent.scrollTop = 0;
                    }
                    if (!lytTextParent) {
                        lytTextParent = document.createElement("div");
                        lytTextParent.id = "lytTextParent";
                        this.setTextType(lytTextParent);
                        lytTextParent.className = "lytTextParent " + animationGlobalClass;
                        lytCarousel4Parent.appendChild(lytTextParent);
                        if (props?.text) {
                            if (props.text.parentposition) this.specialgraphicsPropertyUtils.updatePosition(lytTextParent, props.text.parentposition);
                            if (props.text.parentmargin) {
                                this.specialgraphicsPropertyUtils.updateMargin(props.text.parentmargin, lytTextParent);
                                let margin = parseFloat(lytTextParent.style.marginBottom) + parseFloat(lytTextParent.style.marginTop);
                                lytTextParent.style.maxWidth = lytTextParent.style.width;
                                lytTextParent.style.width = "auto";
                                lytTextParent.style.maxHeight = "calc(100% - " + margin + "px)";
                            }
                        }
                        lytTextParent.scrollTop = 0;
                    }
                    if (props?.text?.titlesubtitlegap) {
                        let sgTitleNode = assetParent.querySelector("[id='sgTitleNode']");
                        if (sgTitleNode) sgTitleNode.style.marginBottom = props.text.titlesubtitlegap + this.specialgraphicsPropertyUtils.getSuffixForPositiom(props.text.titlesubtitlegap);
                    }
                    if (props?.text?.titlelabelgap) {
                        let sgTitleNode = assetParent.querySelector("[id='sgTitleNode']");
                        if (sgTitleNode) sgTitleNode.style.marginTop = props.text.titlelabelgap + this.specialgraphicsPropertyUtils.getSuffixForPositiom(props.text.titlelabelgap);
                    }
                    if (assetParent.querySelector("[id*='coverImageParent']")) {
                        //If number depends text then we have to do this
                        let coverImageParent = assetParent.querySelector("[id*='coverImageParent']");
                        coverImageParent.classList.add(c == 1 ? "active" : "nonActive");
                        coverImageParent.style.minWidth = coverImageParent.style.width;
                        coverImageParent.style.minHeight = coverImageParent.style.height;
                        let coverParent = coverImageParent.querySelector("[id*='coverParent']");
                        if (coverParent) coverParent.setAttribute("supportcaption", "false");

                        let imageNode = coverImageParent.querySelector("img[id*='coverimage']");
                        if (imageNode) {
                            imageNode.setAttribute("data-width", parseFloat(coverImageParent.clientWidth));
                            imageNode.setAttribute("data-height", parseFloat(coverImageParent.clientHeight));
                            this.specialGraphicsUtils.updateImageReSize(imageNode.getAttribute("data-width"), imageNode.getAttribute("data-height"), imageNode);
                        }
                        coverImageParent.parentElement.removeChild(coverImageParent);
                        lytImageParent.appendChild(coverImageParent);
                    }
                    lytTextParent.appendChild(assetParent);
                } else {
                    let introParent = this.sgParent.querySelector("[id='introParent']");
                    if (!introParent) {
                        introParent = document.createElement("div");
                        introParent.id = "introParent";
                        introParent.className = "introParent";
                        this.setTextType(introParent);
                        lytCommonParent.appendChild(introParent);
                    }
                    if (assetParent.querySelector("[id*='textBaseParentNode']")) {
                        let textBaseNode = assetParent.querySelector("[id*='textBaseParentNode']");
                        textBaseNode.parentElement.removeChild(textBaseNode);
                        introParent.appendChild(textBaseNode);
                        textBaseNode.style.height = "auto";
                        textBaseNode.style.maxHeight = "100%";

                        let sgTitleNode = textBaseNode.querySelector("[id='sgTitleNode']");
                        if (sgTitleNode) {
                            sgTitleNode.id = sgTitleNode.id + "0";
                            sgTitleNode.parentElement.id = sgTitleNode.parentElement.id + "0";
                        }
                        let sgTitleLabelNode = textBaseNode.querySelector("[id='sgTitleLabelNode']");
                        if (sgTitleLabelNode) {
                            sgTitleLabelNode.id = sgTitleLabelNode.id + "0";
                            sgTitleLabelNode.parentElement.id = sgTitleLabelNode.parentElement.id + "0";
                        }
                        let sgSubTitleNode = textBaseNode.querySelector("[id='sgSubTitleNode']");
                        if (sgSubTitleNode) {
                            sgSubTitleNode.id = sgSubTitleNode.id + "0";
                            sgSubTitleNode.parentElement.id = sgSubTitleNode.parentElement.id + "0";
                        }
                        let textFulHeight = parseFloat(window.getComputedStyle(introParent).height);
                        textBaseNode.setAttribute("fullheight", parseFloat(textFulHeight));
                        assetParent.style.display = "none";
                        assetParent.setAttribute("hide", "true");
                    }
                }
            }
        } else {
            this.clearListener(false);
            let elements = this.sgParent.querySelectorAll("[listener='true']");
            for (let a = 0; a < elements.length; a++) {
                this.setTextFocus(elements[a], false, null, true);
            }
        }
        this.setActiveData();
        this.bringTargetInside();
        this.updateIntroVisibility();
        this.rePositioningTextElement();
    }
};

GenericCarouselImagestack4.prototype.specialGraphicsCreationComplete = function () {
    GenericSpecialgraphics.prototype.specialGraphicsCreationComplete.call(this, false);
    this.specialGraphicsUtils.updateImagePositions(this.sgParent);
};

GenericCarouselImagestack4.prototype.changeVariation = function (slideDomContentGroup, updateOnlyVariation = false) {
    GenericSpecialgraphics.prototype.changeVariation.call(this, slideDomContentGroup, updateOnlyVariation, false);
    //Setting up number visibility using floater number enable/disable option
    let nodeData = slideDomContentGroup.getElementsByTagName("numbertext")[0];
    let arrNumber = this.sgParent.querySelectorAll("[id*='sgNumberTextNode']");
    for (let a = 0; a < arrNumber.length; a++) {
        if (arrNumber[a] && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
            arrNumber[a].style.display = "none";
            arrNumber[a].parentElement.style.display = "none";
        } else if (arrNumber[a]) {
            var display = arrNumber[a].hasAttribute("display") ? arrNumber[a].getAttribute("display") : "";
            arrNumber[a].style.display = display;
            arrNumber[a].parentElement.style.display = display;
        }
    }

    let introParent = this.sgParent.querySelector("[id='introParent']");
    let lytCarousel4Parent = this.sgParent.querySelector("[id='lytCarousel4Parent']");
    if (introParent && lytCarousel4Parent) {
        let finalShow = this.sgParent.parentElement.parentElement.getAttribute("data-ogdata-finalshow_0")?.includes("intro") ? true : false;
        if (!finalShow) {
            introParent.style.display = "none";
            lytCarousel4Parent.style.height = "100%";
        } else {
            introParent.style.removeProperty("display");
            lytCarousel4Parent.style.removeProperty("height");
        }
        let lytImageParent = this.sgParent.querySelector("[id='lytImageParent']");
        if (lytImageParent) {
            if (lytImageParent.hasAttribute("maxheight")) lytImageParent.removeAttribute("maxheight");
            if (lytImageParent.hasAttribute("finalHeight")) lytImageParent.removeAttribute("finalHeight");
            lytImageParent.style.removeProperty("height");
        }

        this.setActiveData();
        this.bringTargetInside();
    }
};

GenericCarouselImagestack4.prototype.floaterNavigation = function (index) {
    GenericSpecialgraphics.prototype.floaterNavigation.call(this, index, "type4");
    this.setActiveData();
    this.bringTargetInside(index == -1);
};

GenericCarouselImagestack4.prototype.setActiveData = function () {
    if (this.isPreviewMode == false || !this.isPreviewMode) {
        let targetIndex = this.currentNodeIndex - 1 < 1 ? 1 : this.currentNodeIndex - 1;
        let finalShow = this.sgParent.parentElement.parentElement.getAttribute("data-ogdata-finalshow_0")?.includes("intro") ? true : false;
        // if (finalShow) targetIndex = targetIndex + 1;
        for (let i = 1; i < this.sgData.length + 1; i++) {
            let currentNode = this.sgParent.querySelector("[id='assetParent" + i + "']");
            if (currentNode && currentNode.id != "assetParent0") currentNode.style.removeProperty("display");
            if (currentNode) {
                currentNode.classList.remove("carousel4hide");
                if (this.isPlayAnimation == false) currentNode.classList.add("noAnimationSg");
            }
            if (targetIndex == i && currentNode) {
                currentNode.style.pointerEvents = "auto";
                currentNode.style.setProperty("--textPointerEvent", "auto");
                currentNode.classList.remove("active");
                currentNode.classList.remove("nonActive");
                currentNode.classList.add("active");
            } else if (currentNode) {
                currentNode.style.pointerEvents = "none";
                currentNode.style.setProperty("--textPointerEvent", "none");
                currentNode.classList.remove("active");
                currentNode.classList.remove("nonActive");
                currentNode.classList.add("nonActive");
                if (i == targetIndex - 1 && i != 0) currentNode.classList.add("carousel4hide");
            }
        }
        let arrCoverImageParent = this.sgParent.querySelectorAll("[id='coverImageParent']");
        let lytNumberParent = this.sgParent.querySelector("[id*='lytNumberParent']");
        let arrNumberParent = lytNumberParent ? lytNumberParent.querySelectorAll("[id*='numberParent']") : [];
        for (let a = 0; a < arrCoverImageParent.length; a++) {
            if (this.isPlayAnimation == false) arrCoverImageParent[a].classList.add("noAnimationSg");
            if (this.isPlayAnimation == false && arrNumberParent[a]) {
                arrNumberParent[a].classList.add("noAnimationSg");
                arrNumberParent[a].classList.remove("carousel4hide");
            }
            if (!arrCoverImageParent[a].hasAttribute("originalW")) arrCoverImageParent[a].setAttribute("originalW", parseFloat(arrCoverImageParent[a].style.width));
            if (!arrCoverImageParent[a].hasAttribute("originalH")) arrCoverImageParent[a].setAttribute("originalH", parseFloat(arrCoverImageParent[a].style.height));
            if (a == targetIndex - 1) {
                arrCoverImageParent[a].classList.remove("active");
                arrCoverImageParent[a].classList.remove("nonActive");
                arrCoverImageParent[a].classList.add("active");
                arrCoverImageParent[a].style.setProperty("--textPointerEvent", "auto");

                if (arrNumberParent[a]) {
                    arrNumberParent[a].classList.remove("active");
                    arrNumberParent[a].classList.remove("nonActive");
                    arrNumberParent[a].classList.add("active");
                    arrNumberParent[a].style.setProperty("--textPointerEvent", "auto");
                }
            } else {
                arrCoverImageParent[a].classList.remove("active");
                arrCoverImageParent[a].classList.remove("nonActive");
                arrCoverImageParent[a].classList.add("nonActive");
                arrCoverImageParent[a].style.setProperty("--textPointerEvent", "none");
                if (arrNumberParent[a]) {
                    arrNumberParent[a].classList.remove("active");
                    arrNumberParent[a].classList.remove("nonActive");
                    arrNumberParent[a].classList.add("nonActive");
                    arrNumberParent[a].style.setProperty("--textPointerEvent", "none");
                }
            }
            if (arrCoverImageParent[a]) {
                arrCoverImageParent[a].style.removeProperty("transform");
                let scale = new WebKitCSSMatrix(window.getComputedStyle(arrCoverImageParent[a]).transform).a;
                arrCoverImageParent[a].style.minWidth = arrCoverImageParent[a].getAttribute("originalW") * (scale && scale > 0 ? scale : 1) + "px";
                arrCoverImageParent[a].style.minHeight = arrCoverImageParent[a].getAttribute("originalH") * (scale && scale > 0 ? scale : 1) + "px";
                arrCoverImageParent[a].style.transform = "scale(1)";
            }
            if (a == targetIndex - 2 && arrNumberParent[a]) arrNumberParent[a].classList.add("carousel4hide");
        }
    }
};
GenericCarouselImagestack4.prototype.bringTargetInside = function (isPrev = false) {
    let lytImageParent = this.sgParent.querySelector("[id='lytImageParent']");
    let lytTextParent = this.sgParent.querySelector("[id='lytTextParent']");
    let arrCoverImageParent = this.sgParent.querySelectorAll("[id='coverImageParent']");
    if (lytImageParent && arrCoverImageParent.length > 0) {
        let parentStyle = window.getComputedStyle(lytImageParent);
        let maxHeight = parseFloat(parentStyle.height) - (parseFloat(parentStyle.marginTop) + parseFloat(parentStyle.marginBottom));
        if (!lytImageParent.hasAttribute("maxheight")) lytImageParent.setAttribute("maxheight", parseFloat(maxHeight));
        if (lytImageParent.hasAttribute("maxheight")) maxHeight = parseFloat(lytImageParent.getAttribute("maxheight"));
        if (lytImageParent.hasAttribute("finalHeight")) maxHeight = parseFloat(lytImageParent.getAttribute("finalHeight"));
        if (!lytImageParent.hasAttribute("finalHeight")) {
            let finalHeight = 0;
            // console.log("maxHeight - " + maxHeight);
            let isHeightSet = false;
            let visibieChildCount = 0;
            let childWithNonActive;
            let childWithActive;
            parent.scrollTop = 0;
            for (let c = 0; c < arrCoverImageParent.length; c++) {
                let isNonActive = arrCoverImageParent[c].classList.contains("nonActive");
                if (!childWithNonActive && isNonActive) childWithNonActive = arrCoverImageParent[c];
                else if (!childWithActive && !isNonActive) childWithActive = arrCoverImageParent[c];
            }
            for (let a = 0; a < arrCoverImageParent.length; a++) {
                let node = arrCoverImageParent[a];
                let nodeStyle = window.getComputedStyle(node);
                node.style.removeProperty("transform");
                let scale = new WebKitCSSMatrix(window.getComputedStyle(node).transform).a;
                if (!node.hasAttribute("originalW")) node.setAttribute("originalW", parseFloat(node.style.minWidth));
                if (!node.hasAttribute("originalH")) node.setAttribute("originalH", parseFloat(node.style.minHeight));
                node.style.minWidth = node.getAttribute("originalW") * (scale && scale > 0 ? scale : 1) + "px";
                node.style.minHeight = node.getAttribute("originalH") * (scale && scale > 0 ? scale : 1) + "px";
                node.style.transform = "scale(1)";
                let isNonActive = node.classList.contains("nonActive");
                let offsetHeight = parseFloat(node.style.minHeight) + parseFloat(nodeStyle.marginTop) + parseFloat(nodeStyle.marginBottom) + (isNonActive ? parseFloat(nodeStyle.borderWidth) : 0);
                // console.log("offsetHeight - " + offsetHeight);
                let h = finalHeight + offsetHeight;
                if (h > maxHeight) {
                    isHeightSet = true;
                    // console.log("visibieChildCount - " + visibieChildCount);
                    if (childWithNonActive && childWithActive && visibieChildCount > 0) {
                        let childWithNonActiveStyle = window.getComputedStyle(childWithNonActive);
                        let childWithActiveStyle = window.getComputedStyle(childWithActive);
                        let nonActiveChildData = childWithNonActive.offsetHeight + parseFloat(childWithNonActiveStyle.marginTop) + parseFloat(childWithNonActiveStyle.marginBottom);
                        let activeChildData = childWithActive.offsetHeight + parseFloat(childWithActiveStyle.marginTop) + parseFloat(childWithActiveStyle.marginBottom);
                        finalHeight = nonActiveChildData * (visibieChildCount - 1) + activeChildData;
                    }
                    lytImageParent.style.height = finalHeight + "px";
                    lytImageParent.setAttribute("finalHeight", parseFloat(lytImageParent.style.height));
                    // console.log("finalHeight - " + lytImageParent.style.height);
                    a = arrCoverImageParent.length + 1;
                } else finalHeight = h;
                visibieChildCount++;
            }
            if (isHeightSet == false && finalHeight > 0) lytImageParent.style.height = finalHeight + "px";
        }
        if (arrCoverImageParent[this.currentNodeIndex - 2]) {
            let targetNode = arrCoverImageParent[this.currentNodeIndex - 2];
            // console.log(targetNode);
            // let scrollValue = targetNode.offsetTop - lytImageParent.scrollTop;
            let scrollValue = targetNode.offsetTop - lytImageParent.scrollTop + (isPrev ? 0 : parseFloat(targetNode.style.minHeight));
            let isInside = scrollValue >= 0 && scrollValue < parseInt(maxHeight) ? true : false;
            // console.log("isInside - " + isInside);
            if (isInside == false) {
                let childWithNonActive = null;
                for (let c = 0; c < arrCoverImageParent.length; c++) {
                    if (arrCoverImageParent[c].classList.contains("nonActive") && !childWithNonActive) {
                        childWithNonActive = arrCoverImageParent[c];
                        c = arrCoverImageParent.length + 1;
                    }
                }
                scrollIntoView(lytImageParent, targetNode, childWithNonActive, isPrev);
            }
            // if (isInside == false) targetNode.scrollIntoView(false);
        }
    }
    if (lytTextParent && this.isPlayAnimation == false) {
        let arrAssetParents = lytTextParent.querySelectorAll("[id*='assetParent']");
        let top = 0;
        for (let b = 0; b < arrAssetParents.length; b++) {
            arrAssetParents[b].style.top = -top + "%";
            top = top + 100;
        }
    }
};

// This is the main function where which pass two ref parameters of Parent element & Child element
function scrollIntoView(parent, child, childWithNonActive, isPrev) {
    let childWithNonActiveStyle = window.getComputedStyle(childWithNonActive ? childWithNonActive : child);
    let reducingValue = childWithNonActiveStyle && childWithNonActive ? childWithNonActive.offsetHeight + parseFloat(childWithNonActiveStyle.marginTop) + parseFloat(childWithNonActiveStyle.marginBottom) : null;

    // console.log("reducingValue - " + reducingValue);
    if (isPrev && reducingValue) scrollToSG(parent, -reducingValue, 300);
    else if (!isPrev && reducingValue) scrollToSG(parent, reducingValue, 300);
}

function scrollToSG(element, to, duration) {
    let start = element.scrollTop,
        currentTime = 0,
        increment = 50;

    let animateScroll = function () {
        currentTime += increment;

        let val = easeInOutQuad(currentTime, start, to, duration);
        element.scrollTop = val;

        if (currentTime < duration) setTimeout(animateScroll, increment);
    };

    animateScroll();
}
// Function for smooth scroll animation with the time duration
function easeInOutQuad(time, startPos, endPos, duration) {
    time /= duration / 2;

    if (time < 1) return (endPos / 2) * time * time + startPos;
    time--;
    return (-endPos / 2) * (time * (time - 2) - 1) + startPos;
}

GenericCarouselImagestack4.prototype.gotoAndStopFirstNode = function (completeCallback) {
    this.currentNodeIndex = 2;
    this.floaterNavigation(0);
    this.eventManager.dispatch("positionchangecallback", 1);

    let lytCarousel4Parent = this.sgParent.querySelector("[id='lytCarousel4Parent']");
    let arrAnimationNodes = lytCarousel4Parent ? lytCarousel4Parent.querySelectorAll("[class*='moodanimation']") : [];
    let introParent = this.sgParent.querySelector("[id='introParent']");
    for (let a = 0; a < arrAnimationNodes.length; a++) {
        arrAnimationNodes[a].classList.remove("moodanimation");
        arrAnimationNodes[a].removeAttribute("data-animation");
    }
    if (this.isPlayAnimation) {
        let arrAnimationNodesEditor = this.sgParent.querySelectorAll("[class*='noAnimationSg']");
        for (let a = 0; a < arrAnimationNodesEditor.length; a++) {
            arrAnimationNodesEditor[a].classList.remove("noAnimationSg");
        }
    }
    if (lytCarousel4Parent) {
        lytCarousel4Parent.classList.add("initAnimation");
        setTimeout(() => {
            if (this.isPlayAnimation) lytCarousel4Parent.style.transition = "all 1s 1.5s";
            lytCarousel4Parent.style.opacity = 1;
            lytCarousel4Parent.style.transform = "unset";
        }, 0);
    }
    if (introParent.style.display == "none") {
        this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", null, this.isPlayAnimation, this.eventManager, 0);
        setTimeout(
            () => {
                completeCallback ? completeCallback() : "";
            },
            this.isPlayAnimation ? 1000 : 0
        );
    } else {
        let index = introParent && introParent.style.display == "none" ? this.currentNodeIndex - 1 : this.currentNodeIndex - 2;
        this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, index);
    }
    this.sgParent.removeAttribute("startindex");
};

GenericCarouselImagestack4.prototype.next = function (completeCallback) {
    this.sgParent.setAttribute("dotransition", "false");
    this.currentNodeIndex = this.currentNodeIndex + 1;
    if (this.currentNodeIndex > this.sgData.length) return;

    this.setActiveData();
    this.bringTargetInside();
    setTimeout(
        () => {
            completeCallback ? completeCallback() : "";
        },
        this.isPlayAnimation ? 1000 : 0
    );
};
GenericCarouselImagestack4.prototype.previous = function (completeCallback) {
    this.currentNodeIndex = this.currentNodeIndex - 1;
    if (this.currentNodeIndex <= 1) return false;
    this.setActiveData();
    this.bringTargetInside(true);
    setTimeout(
        () => {
            completeCallback ? completeCallback() : "";
        },
        this.isPlayAnimation ? 1000 : 0
    );
};

GenericCarouselImagestack4.prototype.getTargetElement = function (elementID) {
    let index = this.currentNodeIndex - 1 == 0 ? this.currentNodeIndex : this.currentNodeIndex - 1;
    let assetParent = this.sgParent.querySelector("[id='assetParent" + index + "']");

    let lytImageParent = this.sgParent.querySelector("[id='lytImageParent']");
    if (lytImageParent) {
        let allNodes = lytImageParent.querySelectorAll("[id*='" + elementID + "']");
        if (allNodes[this.currentNodeIndex - 2]) return allNodes[this.currentNodeIndex - 2];
        else if (allNodes.length == 1) return allNodes[0];
    }

    if (assetParent && assetParent.querySelector("[id='" + elementID + "']")) return assetParent.querySelector("[id='" + elementID + "']");
    let introParent = this.sgParent.querySelector("[id='introParent']");
    if (introParent && introParent.querySelector("[id*='" + elementID + "']")) return introParent.querySelector("[id*='" + elementID + "']");
};

GenericCarouselImagestack4.prototype.updateHeightForText = function (assetParent) {
    let index = parseFloat(assetParent.id.replace("assetParent", ""));
    let textParent = index == 0 ? this.sgParent.querySelector("[id='introParent']") : assetParent;
    GenericSpecialgraphics.prototype.updateHeightForText.call(this, textParent ? textParent : assetParent);
};

GenericCarouselImagestack4.prototype.onTextChangeUpdate = function (textNode, isStart = false) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    let index = textNode && textNode.id.includes("0") ? 0 : this.currentNodeIndex - 1;
    let textParent = index == 0 ? this.sgParent.querySelector("[id='introParent']") : assetParent;
    GenericSpecialgraphics.prototype.onTextChangeUpdate.call(this, textNode, isStart, textParent);
};

GenericCarouselImagestack4.prototype.changeText = function (updatedText, elementId, targetIndex, textType) {
    GenericSpecialgraphics.prototype.changeText.call(this, updatedText, elementId, targetIndex, textType);
    this.setActiveData();
    this.bringTargetInside();
};
GenericCarouselImagestack4.prototype.updatenavFloater = function () {
    if (this.isPlayAnimation == false && this.isPresent != true && this.updateNavFloaterIndex) {
        let slideID = this.slideContent && this.slideContent.id ? this.slideContent.id : null;
        let isIntroHide = this.sgParent?.parentElement?.parentElement?.getAttribute("data-ogdata-finalhide_0")?.split(",")?.includes("intro");
        // let isVisible = isIntroHide ? -1 : 0;
        let isVisible = -1;
        // this.updateNavFloaterIndex(this.currentNodeIndex - 1 < 1 ? 1 : this.currentNodeIndex - 1, slideID, -1);
        this.updateNavFloaterIndex(this.currentNodeIndex + isVisible, slideID, 0, this.currentNodeIndex - 1 + isVisible);
    }
};

GenericCarouselImagestack4.prototype.startIndex = function (currentSlideData) {
    return this.specialGraphicsUtils.getStartIndex(currentSlideData, this.sgParent);

    // let presentParent = currentSlideData ? currentSlideData : this.sgParent;
    // let introParent = presentParent ? presentParent.querySelector("[id='introParent']") : null;
    // let sgParent = presentParent ? presentParent.querySelector("[id='specialgraphicsParent']") : this.sgParent;

    // let isNotVisible = introParent?.style?.display == "none" || introParent?.style?.opacity == 0 || introParent?.style?.opacity == "0";
    // if (isNotVisible) sgParent.setAttribute("startindex", "1");
    // else sgParent.removeAttribute("startindex");

    // let localParent = sgParent ? sgParent : this.sgParent;
    // let animationDIV = localParent?.parentElement?.parentElement ? localParent.parentElement.parentElement : null;
    // let showIntro = animationDIV?.hasAttribute("data-intro") ? animationDIV.getAttribute("data-intro") : "true";

    // return (isNotVisible || !assetParent) && showIntro != "true" ? 1 : 0;
};

"use strict";

function GenericCarouselImagestack5(sgParent, sgData, moodName, metadata, styleName = "", isPlayAnimation = true, textElementData, socialiconsData, fontData, objDataToSG) {
    this.carouselType = "onlytitle";
    GenericCarouselImagestack3.call(this, sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, fontData, objDataToSG);
}

GenericCarouselImagestack5.prototype = Object.create(GenericCarouselImagestack3.prototype);

GenericCarouselImagestack5.prototype.initSpecialGraphicsCreation = function () {
    GenericCarouselImagestack3.prototype.initSpecialGraphicsCreation.call(this);
    if (this.introType == "slidetop" || this.introType == "insidecontent") {
        let introParent = this.sgParent.querySelector("[id='introParent']");
        let titleNode = introParent ? introParent.querySelector("[id='sgTitleNode0']") : null;
        if (titleNode) titleNode.setAttribute("dofocusout", "false");
    }
};
GenericCarouselImagestack5.prototype.setScrollData = function (checkCondition = false) {
    this.setActiveData();
    let textParent = this.sgParent.querySelector("[id='lytAssetTextParent" + (this.currentNodeIndex - 1) + "']");
    let lytCommonTextParent = this.sgParent.querySelector("[id='lytCommonTextParent']");
    let lytCommonNumberParent = this.sgParent.querySelector("[id='lytCommonNumberParent']");
    if (lytCommonTextParent) {
        // console.log("s0");
        let targetNodeStyle = window.getComputedStyle(lytCommonTextParent);
        let maxHeight = targetNodeStyle.height;
        if (!lytCommonTextParent.hasAttribute("fullheight")) {
            let mb = isNaN(parseFloat(targetNodeStyle.marginBottom)) ? 0 : parseFloat(targetNodeStyle.marginBottom);
            let mt = isNaN(parseFloat(targetNodeStyle.marginTop)) ? 0 : parseFloat(targetNodeStyle.marginTop);
            maxHeight = parseFloat(maxHeight) - (mb + mt);
            lytCommonTextParent.setAttribute("fullheight", maxHeight);
        } else if (lytCommonTextParent.hasAttribute("fullheight")) maxHeight = lytCommonTextParent.getAttribute("fullheight");
        lytCommonTextParent.style.height = parseFloat(maxHeight) + "px";
        if (textParent) {
            let sgSubTitleNode = textParent.querySelector("[id='sgSubTitleNode']");
            if (sgSubTitleNode) {
                sgSubTitleNode.style.opacity = 0;
                sgSubTitleNode.style.transition = "opacity 1s";
            }
            textParent.scrollIntoView(false);
            if (sgSubTitleNode) {
                sgSubTitleNode.style.transition = "opacity 1s";
                sgSubTitleNode.style.removeProperty("opacity");
            }
        }

        let totalHeight = 0;
        // console.log("s1");
        for (let a = 1; a < this.sgData.length; a++) {
            let lytAssetTextParent = lytCommonTextParent.querySelector("[id='lytAssetTextParent" + a + "']");
            if (lytAssetTextParent) {
                let textStyle = window.getComputedStyle(lytAssetTextParent);
                let nodeHeight = parseFloat(textStyle.height) + parseFloat(textStyle.marginTop) + parseFloat(textStyle.marginBottom);

                let mt = isNaN(parseFloat(textStyle.marginTop)) ? 0 : parseFloat(textStyle.marginTop);
                let offsetTopValue = lytAssetTextParent.offsetTop - lytCommonTextParent.scrollTop - mt;

                let check1 = offsetTopValue + parseInt(nodeHeight) <= parseInt(maxHeight);
                let check2 = offsetTopValue + parseInt(nodeHeight) <= parseInt(maxHeight) + 5;
                let check3 = offsetTopValue + parseInt(nodeHeight) + 5 <= parseInt(maxHeight);
                if (lytAssetTextParent && offsetTopValue >= 0 && (check1 || check2 || check3)) {
                    let newHeight = totalHeight + parseFloat(nodeHeight);
                    if (newHeight > parseFloat(maxHeight)) {
                        a = 100;
                        // console.log("s4");
                        lytCommonTextParent.style.height = totalHeight + (this.isPlayAnimation ? 20 : 0) + "px";
                    } else totalHeight = newHeight;
                }
                // console.log("s2");
                if (this.sgData.length - 1 == a && totalHeight < parseInt(maxHeight)) {
                    // console.log("s3");
                    lytCommonTextParent.style.height = totalHeight + (this.isPlayAnimation ? 20 : 0) + "px";
                    // console.log("totalHeight - " + totalHeight);
                }
            }
        }
        // setTimeout(() => {
        if (textParent) textParent.scrollIntoView(false);
        // }, 0);
        // if (textParent && this.isPlayAnimation == false) textParent.scrollIntoView({ block: "nearest" });
        // else if (textParent) textParent.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "nearest" });
    }
    if (lytCommonNumberParent) {
        let arrNumbres = lytCommonNumberParent.querySelectorAll("[id*='sgNumberTextParent']");
        let numberNode = arrNumbres[this.currentNodeIndex - 2] ? arrNumbres[this.currentNodeIndex - 2] : null;
        if (numberNode) {
            let numberMaxHeight = window.getComputedStyle(lytCommonNumberParent).height;
            let numberScrollValue = numberNode.offsetTop - lytCommonNumberParent.scrollTop;
            let isNumberInside = numberScrollValue >= 0 && numberScrollValue < parseInt(numberMaxHeight) ? true : false;
            if (isNumberInside == false) numberNode.scrollIntoView(false);
        }
    }
};

"use strict";

function GenericCarouselImagestack6(sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, fontData, objDataToSG) {
    GenericSpecialgraphics.call(this, sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, fontData, objDataToSG);
}

GenericCarouselImagestack6.prototype = Object.create(GenericSpecialgraphics.prototype);

GenericCarouselImagestack6.prototype.initSpecialGraphicsCreation = function () {
    this.specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL);
    this.specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
    GenericSpecialgraphics.prototype.initSpecialGraphicsCreation.call(this, true, false);
    if ((this.isWidget == false || (this.objDataToSG && this.objDataToSG.menuChange)) && !this.oldContent) {
        let props = this.getProps();
        let carouselProp = props.carousel;
        let placeholderCommonParent = this.sgParent.querySelector("[id='placeholderCommonParent']");
        if (!placeholderCommonParent) {
            placeholderCommonParent = document.createElement("div");
            placeholderCommonParent.id = "placeholderCommonParent";
            placeholderCommonParent.className = "placeholderCommonParent" + this.moodanimation;
            placeholderCommonParent.setAttribute("data-animation", "device");
            placeholderCommonParent.style.position = "absolute";
            placeholderCommonParent.style.opacity = 1;
            this.sgParent.appendChild(placeholderCommonParent);
            placeholderCommonParent.setAttribute("data-customopacity", 1);
            if (this.sgData.length < 3) {
                placeholderCommonParent.style.display = "flex";
                placeholderCommonParent.style.flexDirection = "column";
                placeholderCommonParent.style.justifyContent = "center";
            }
            for (let a = 1; a < this.sgData.length; a++) {
                let phChildParent = document.createElement("div");
                phChildParent.id = "phChildParent" + a;
                phChildParent.className = "phChildParent moodanimation";
                phChildParent.setAttribute("data-animation", "covershape1");
                if (a == 1) {
                    phChildParent.classList.add("active");
                    phChildParent.classList.add("subtitleColorBg");
                }
                placeholderCommonParent.appendChild(phChildParent);

                let phNode = this.sgParent.querySelector("[id='placeHolderParent" + a + "']");
                phNode.parentElement.removeChild(phNode);
                phNode.style.display = "flex";
                phChildParent.appendChild(phNode);
                if (phNode.querySelector("[id='sgLogoImageNode']")) phNode.querySelector("[id='sgLogoImageNode']").setAttribute("data-supportcontrast", "true");
                if (phNode.querySelector("[id='phTextNode']")) phNode.querySelector("[id='phTextNode']").setAttribute("data-supportcontrast", "true");

                if (carouselProp.nodeposition) this.specialgraphicsPropertyUtils.updatePosition(phChildParent, carouselProp.nodeposition);
                if (carouselProp.nodeactivebg) {
                    let opacity = carouselProp.nodeactivebgopacity || 1;
                    placeholderCommonParent.style.setProperty("--activePhBg", "rgba(var(--" + carouselProp.nodeactivebg + "-color-rgb)," + opacity + ")");
                }
                if (carouselProp.nodebg) {
                    let opacity = carouselProp.nodebgopacity || 1;
                    placeholderCommonParent.style.setProperty("--nonActivePhBg", "rgba(var(--" + carouselProp.nodebg + "-color-rgb)," + opacity + ")");
                }
                if (carouselProp.nodepadding) this.specialgraphicsPropertyUtils.updatePadding(carouselProp.nodepadding, phChildParent);
                if (carouselProp.nodemargin) this.specialgraphicsPropertyUtils.updateMargin(carouselProp.nodemargin, phChildParent);
                if (carouselProp.noderadius) {
                    if (carouselProp.noderadius.includes(",") && carouselProp.noderadius.split(",").length == 4) {
                        let radiusValue = carouselProp.noderadius.split(",");
                        phChildParent.style.borderRadius = radiusValue[0] + "px " + radiusValue[1] + "px " + radiusValue[2] + "px " + radiusValue[3] + "px";
                    } else phChildParent.style.borderRadius = carouselProp.noderadius;
                }

                let logoNode = phNode.querySelector("[id='sgLogoImageNode']");
                if (logoNode) this.specialGraphicsUtils.updateImageReSize(logoNode.getAttribute("data-width"), logoNode.getAttribute("data-height"), logoNode);
            }
        }
        if (carouselProp) {
            if (carouselProp.position) this.specialgraphicsPropertyUtils.updatePosition(placeholderCommonParent, carouselProp.position);
        }
        let slideId = this.slideContent ? this.slideContent.id : this.sgParent.parentElement.parentElement.parentElement.id;
        if (this.updateThumbnail) this.updateThumbnail(slideId);
    }
    setTimeout(() => {
        this.specialGraphicsCreationComplete();
    }, 0);
};

GenericCarouselImagestack6.prototype.floaterNavigation = function (index, type = "") {
    GenericSpecialgraphics.prototype.floaterNavigation.call(this, index, type);
    this.setActivePh(index);
};

GenericCarouselImagestack6.prototype.setActivePh = function (index = 0) {
    let placeholderCommonParent = this.sgParent.querySelector("[id='placeholderCommonParent");
    if (placeholderCommonParent && this.sgParent.querySelectorAll("[id*='phChildParent").length > 0) {
        let selectedNode = null;
        for (let a = 1; a < this.sgData.length; a++) {
            let phChildParent = this.sgParent.querySelector("[id='phChildParent" + a + "");
            phChildParent.classList.remove("active");
            phChildParent.classList.remove("lightText");
            if (a == this.currentNodeIndex - 1) {
                phChildParent.classList.add("active");
                phChildParent.classList.add("subtitleColorBg");
                selectedNode = phChildParent;
            }
            phChildParent.style.setProperty("--textPointerEvent", a == this.currentNodeIndex - 1 ? "auto" : "none");
        }
        if (selectedNode) {
            let parentStyle = window.getComputedStyle(placeholderCommonParent);
            let maxHeight = parseFloat(parentStyle.height) - (parseFloat(parentStyle.marginTop) + parseFloat(parentStyle.marginBottom));
            let scrollValue = selectedNode.offsetTop - placeholderCommonParent.scrollTop + (index == -1 ? 0 : parseFloat(selectedNode.style.height));
            let isInside = scrollValue >= 0 && scrollValue < parseInt(maxHeight) ? true : false;
            if (isInside == false) this.specialGraphicsUtils.scrollIntoView(placeholderCommonParent, selectedNode, null, index == -1);
        }
    }
};
GenericCarouselImagestack6.prototype.gotoAndStopFirstNode = function (completeCallback, type, slideContent, indexValue = -1) {
    let placeholderCommonParent = this.sgParent.querySelector("[id='placeholderCommonParent");
    let arrAnimationNodes = placeholderCommonParent.querySelectorAll("[class*='moodanimation']");
    for (let a = 0; a < arrAnimationNodes.length; a++) {
        arrAnimationNodes[a].classList.remove("moodanimation");
    }
    GenericSpecialgraphics.prototype.gotoAndStopFirstNode.call(this, completeCallback, type, slideContent, indexValue);
};
GenericCarouselImagestack6.prototype.getTargetElement = function (elementID) {
    let index = this.currentNodeIndex - 1;
    let assetParent = this.sgParent.querySelector("[id='assetParent" + index + "']");
    if (assetParent && assetParent.querySelector("[id='" + elementID + "']")) return assetParent.querySelector("[id='" + elementID + "']");
    let introParent = this.sgParent.querySelector("[id='placeholderCommonParent']");
    if (introParent && introParent.querySelector("[id*='phChildParent" + index + "']")) {
        let phChildParent = introParent.querySelector("[id*='phChildParent" + index + "']");
        if (phChildParent?.querySelector("[id*='" + elementID + "']")) return phChildParent.querySelector("[id*='" + elementID + "']");
    }
    if (introParent && introParent.querySelector("[id*='" + elementID + "']")) return introParent.querySelector("[id*='" + elementID + "']");
};

GenericCarouselImagestack6.prototype.previous = function (completeCallback) {
    let returnVal = GenericSpecialgraphics.prototype.previous.call(this, completeCallback);
    this.setActivePh();
    return returnVal;
};
GenericCarouselImagestack6.prototype.next = function (completeCallback) {
    let returnVal = GenericSpecialgraphics.prototype.next.call(this, completeCallback);
    this.setActivePh();
    return returnVal;
};

"use strict";

function GenericCarouselImagestack7(sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, fontData, objDataToSG) {
    GenericSpecialgraphics.call(this, sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, fontData, objDataToSG);
}

GenericCarouselImagestack7.prototype = Object.create(GenericSpecialgraphics.prototype);

GenericCarouselImagestack7.prototype.initSpecialGraphicsCreation = function () {
    this.sgParent.style.opacity = 0;
    this.specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL);
    this.specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
    GenericSpecialgraphics.prototype.initSpecialGraphicsCreation.call(this, true, false);
    if ((this.isWidget == false || (this.objDataToSG && this.objDataToSG.menuChange)) && !this.oldContent) {
        let commonCarouselParent = this.sgParent.querySelector("[id='commonCarouselParent']");
        if (!commonCarouselParent) {
            commonCarouselParent = document.createElement("div");
            commonCarouselParent.id = "commonCarouselParent";
            commonCarouselParent.className = "commonCarouselParent moodanimation";
            commonCarouselParent.removeAttribute("data-animation");
            this.sgParent.appendChild(commonCarouselParent);
        }
        if (this.sgData.length < 4) commonCarouselParent.style.justifyContent = "center";
        else {
            let dummyDiv = document.createElement("div");
            dummyDiv.id = "dummyDiv";
            dummyDiv.className = "dummyDiv";
            commonCarouselParent.appendChild(dummyDiv);
            // dummyDiv.style.setProperty("--overlayColor", "rgba(var(--item1-color-rgb), 0.5)");
        }

        let arrAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
        let ind = 2;
        for (let a = 1; a < arrAssetParent.length; a++) {
            arrAssetParent[a].style.width = "33.33%";
            arrAssetParent[a].style.minWidth = "33.33%";
            arrAssetParent[a].style.position = "relative";
            // arrAssetParent[a].style.setProperty("--overlayColor", "rgba(var(--item" + ind + "-color-rgb), 0.5)");
            ind = ind + 1 > 6 ? 1 : ind + 1;
            commonCarouselParent.appendChild(arrAssetParent[a]);
            // if (a != 1) arrAssetParent[a].classList.add("nonActiveCard");

            if (this.sgData.length > 3) {
                if (a == this.currentNodeIndex - 2) arrAssetParent[a].classList.add("previousCard");
                else if (a == this.currentNodeIndex - 1) arrAssetParent[a].classList.add("currentCard");
                else if (a == this.currentNodeIndex) arrAssetParent[a].classList.add("nextCard");
                else arrAssetParent[a].classList.add("nextHideCard");
            }
        }
        if (this.sgData.length > 3) {
            let dummyDiv = document.createElement("div");
            dummyDiv.id = "dummyDiv";
            dummyDiv.className = "dummyDiv";
            commonCarouselParent.appendChild(dummyDiv);
        }
    }
    // setTimeout(() => {
    this.setActivePh(0, false);
    this.sgParent.style.opacity = 1;
    this.specialGraphicsCreationComplete();
    let slideId = this.slideContent ? this.slideContent.id : this.sgParent.parentElement.parentElement.parentElement.id;
    if (this.updateThumbnail) this.updateThumbnail(slideId);
    // }, 0);
};

GenericCarouselImagestack7.prototype.floaterNavigation = function (index, type = "") {
    GenericSpecialgraphics.prototype.floaterNavigation.call(this, index, type);
    this.setActivePh(index, false);
};

GenericCarouselImagestack7.prototype.setActivePh = function (index = 1, doAnimation = false) {
    let commonCarouselParent = this.sgParent.querySelector("[id='commonCarouselParent");
    if (!commonCarouselParent) return;
    if (!doAnimation || !this.isPlayAnimation) {
        commonCarouselParent.style.setProperty("--carouselDuration", "0s");
        commonCarouselParent.style.setProperty("--carouselDelay", "0s");
    } else {
        commonCarouselParent.style.removeProperty("--carouselDuration");
        commonCarouselParent.style.removeProperty("--carouselDelay");
    }
    let ii = this.currentNodeIndex;
    if (this.sgData.length < 4) ii = this.currentNodeIndex - 1;
    for (let a = 0; a < commonCarouselParent.children.length; a++) {
        commonCarouselParent.children[a].classList.remove("noAnimationCard");
        commonCarouselParent.children[a].classList.remove("previousHideCard");
        commonCarouselParent.children[a].classList.remove("previousCard");
        commonCarouselParent.children[a].classList.remove("currentCard");
        commonCarouselParent.children[a].classList.remove("nextCard");
        commonCarouselParent.children[a].classList.remove("nextHideCard");
        if (a == ii - 3) {
            commonCarouselParent.children[a].classList.add("noAnimationCard");
            commonCarouselParent.children[a].classList.add(index == -1 ? "previousHideCard" : "previousCard");
            // setTimeout(() => {
                commonCarouselParent.children[a].classList.remove("previousCard");
                commonCarouselParent.children[a].classList.remove("previousHideCard");
                if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                commonCarouselParent.children[a].classList.add("previousHideCard");
            // }, 0);
        } else if (a == ii - 2) {
            commonCarouselParent.children[a].classList.add("noAnimationCard");
            commonCarouselParent.children[a].classList.add(index == -1 ? "previousHideCard" : "currentCard");
            // setTimeout(() => {
                commonCarouselParent.children[a].classList.remove("currentCard");
                commonCarouselParent.children[a].classList.remove("previousHideCard");
                if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                commonCarouselParent.children[a].classList.add("previousCard");
            // }, 0);
        } else if (a == ii - 1) {
            commonCarouselParent.children[a].classList.add("noAnimationCard");
            commonCarouselParent.children[a].classList.add(index == -1 ? "previousCard" : "nextCard");
            // setTimeout(() => {
                commonCarouselParent.children[a].classList.remove("nextCard");
                commonCarouselParent.children[a].classList.remove("previousCard");
                if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                commonCarouselParent.children[a].classList.add("currentCard");
            // }, 0);
        } else if (a == ii) {
            commonCarouselParent.children[a].classList.add("noAnimationCard");
            commonCarouselParent.children[a].classList.add(index == -1 ? "currentCard" : "nextHideCard");
            // setTimeout(() => {
                commonCarouselParent.children[a].classList.remove("currentCard");
                commonCarouselParent.children[a].classList.remove("nextHideCard");
                if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                commonCarouselParent.children[a].classList.add("nextCard");
            // }, 0);
        } else if (a == ii + 1 && index == -1) {
            commonCarouselParent.children[a].classList.add("noAnimationCard");
            commonCarouselParent.children[a].classList.add("nextCard");
            // setTimeout(() => {
                commonCarouselParent.children[a].classList.remove("nextCard");
                if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                commonCarouselParent.children[a].classList.add("nextHideCard");
            // }, 0);
        } else {
            // if (index != -1) {
            commonCarouselParent.children[a].classList.remove("noAnimationCard");
            commonCarouselParent.children[a].classList.add("noAnimationCard");
            commonCarouselParent.children[a].classList.add("nextHideCard");
            // } else {
            //     commonCarouselParent.children[a].classList.add("noAnimationCard");
            //     commonCarouselParent.children[a].classList.add("nextCard");
            //     setTimeout(() => {
            //         if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
            //         commonCarouselParent.children[a].classList.remove("nextCard");
            //         commonCarouselParent.children[a].classList.add("nextHideCard");
            //     }, 0);
            // }
        }
    }
};
GenericCarouselImagestack7.prototype.initPresentSG = function (slideContent) {
    // let commonCarouselParent = slideContent.querySelector("[id='commonCarouselParent']");
    // if (commonCarouselParent) {
    //     commonCarouselParent.style.opacity = 0;
    //     commonCarouselParent.style.transition = "opacity 0s 0s";
    // }
};
GenericCarouselImagestack7.prototype.gotoAndStopFirstNode = function (completeCallback, type, slideContent, indexValue = -1) {
    GenericSpecialgraphics.prototype.gotoAndStopFirstNode.call(this, completeCallback, type, slideContent, indexValue);
    let commonCarouselParent = this.sgParent.querySelector("[id='commonCarouselParent']");
    if (this.isPlayAnimation && commonCarouselParent && this.currentNodeIndex == 1) commonCarouselParent.style.transition = "opacity 1s 0.5s";
    if (commonCarouselParent && this.currentNodeIndex == 2) {
        commonCarouselParent.style.removeProperty("opacity");
    }
    if (commonCarouselParent && this.currentNodeIndex == 1) {
        commonCarouselParent.style.opacity = 0;
    }
};
GenericCarouselImagestack7.prototype.previous = function (completeCallback) {
    let returnVal = GenericSpecialgraphics.prototype.previous.call(this, completeCallback);
    this.setActivePh(-1, true);
    if (this.currentNodeIndex == 1) {
        let commonCarouselParent = this.sgParent.querySelector("[id='commonCarouselParent']");
        if (commonCarouselParent) commonCarouselParent.style.opacity = 0;
    }
    return returnVal;
};
GenericCarouselImagestack7.prototype.next = function (completeCallback) {
    let returnVal = GenericSpecialgraphics.prototype.next.call(this, completeCallback);
    this.setActivePh(1, true);
    if (this.currentNodeIndex == 2) {
        let commonCarouselParent = this.sgParent.querySelector("[id='commonCarouselParent']");
        if (commonCarouselParent) commonCarouselParent.style.removeProperty("opacity");
    }
    return returnVal;
};

"use strict";

function GenericCarouselImagestack8(sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, fontData, objDataToSG) {
    GenericSpecialgraphics.call(this, sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, fontData, objDataToSG);
}

GenericCarouselImagestack8.prototype = Object.create(GenericSpecialgraphics.prototype);

GenericCarouselImagestack8.prototype.initSpecialGraphicsCreation = function () {
    this.specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL);
    this.specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
    GenericSpecialgraphics.prototype.initSpecialGraphicsCreation.call(this, true, false);
    this.sgParent.classList.remove("genericCarouselImagestack8");
    this.sgParent.classList.add("genericCarouselImagestack8");
    if ((this.isWidget == false || (this.objDataToSG && this.objDataToSG.menuChange)) && !this.oldContent) {
        let props = this.getProps();
        let commonCarouselParentVertical = this.sgParent.querySelector("[id='commonCarouselParentVertical']");
        if (!commonCarouselParentVertical) {
            commonCarouselParentVertical = document.createElement("div");
            commonCarouselParentVertical.id = "commonCarouselParentVertical";
            commonCarouselParentVertical.className = "commonCarouselParentVertical";
            this.sgParent.appendChild(commonCarouselParentVertical);
        }
        if (this.sgData.length < 4) commonCarouselParentVertical.style.justifyContent = "center";

        if (props?.carousel?.lineposition) commonCarouselParentVertical.style.setProperty("--lineLeft", props.carousel.lineposition);
        if (props?.carousel?.startlineheight) commonCarouselParentVertical.style.setProperty("--startLineHeight", props.carousel.startlineheight + this.specialgraphicsPropertyUtils.getSuffixForPositiom(props.carousel.startlineheight));
        if (props?.carousel?.endlineheight) commonCarouselParentVertical.style.setProperty("--endLineHeight", props.carousel.endlineheight + this.specialgraphicsPropertyUtils.getSuffixForPositiom(props.carousel.endlineheight));
        if (props?.carousel?.linewidth) commonCarouselParentVertical.style.setProperty("--lineWidth", props.carousel.linewidth + this.specialgraphicsPropertyUtils.getSuffixForPositiom(props.carousel.linewidth));

        let arrAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
        for (let a = 0; a < arrAssetParent.length; a++) {
            arrAssetParent[a].style.position = "absolute";
            commonCarouselParentVertical.appendChild(arrAssetParent[a]);

            if (a != 0 && a != 1) {
                let startLine = document.createElement("div");
                startLine.id = "startLine";
                startLine.className = "startLine";
                if (props?.carousel?.startlineclass) startLine.classList.add(props.carousel.startlineclass);
                arrAssetParent[a].appendChild(startLine);
            }
            if (a != arrAssetParent.length - 1 && a != 0) {
                let endLine = document.createElement("div");
                endLine.id = "endLine";
                endLine.className = "endLine";
                if (props?.carousel?.endlineclass) startLine.classList.add(props.carousel.endlineclass);
                arrAssetParent[a].appendChild(endLine);
            }

            if (a == 1) arrAssetParent[a].classList.add("currentCard");
            else arrAssetParent[a].classList.add("nextCard");
        }
    }
    this.specialGraphicsCreationComplete();
    let slideId = this.slideContent ? this.slideContent.id : this.sgParent.parentElement.parentElement.parentElement.id;
    setTimeout(() => {
        if (this.updateThumbnail) this.updateThumbnail(slideId);
    }, 0);
};

GenericCarouselImagestack8.prototype.floaterNavigation = function (index, type = "") {
    GenericSpecialgraphics.prototype.floaterNavigation.call(this, index, type);
    this.setActivePh(index, false);
};

GenericCarouselImagestack8.prototype.setActivePh = function (index = 1, doAnimation = false) {
    if (!this.isPlayAnimation) doAnimation = false;
    let arrAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
    for (let a = 0; a < arrAssetParent.length; a++) {
        let startLine = arrAssetParent[a].querySelector("[id='startLine']");
        let endLine = arrAssetParent[a].querySelector("[id='endLine']");
        if (startLine) startLine.style.removeProperty("display");
        if (a == 1) {
            let hasIntro = arrAssetParent[0].style.display != "none";
            if (!hasIntro && startLine) startLine.style.display = "none";
        }
        arrAssetParent[a].classList.remove("previousCard");
        arrAssetParent[a].classList.remove("currentCard");
        arrAssetParent[a].classList.remove("nextCard");
        arrAssetParent[a].classList.remove("noAnimationCard");
        arrAssetParent[a].classList.remove("noAnimationCard");
        arrAssetParent[a].classList.remove("noAnimationCard");

        if (startLine) startLine.classList.remove("noAnimationCard");
        if (endLine) endLine.classList.remove("noAnimationCard");
        if (a == this.currentNodeIndex - 1) {
            arrAssetParent[a].classList.add("noAnimationCard");
            arrAssetParent[a].classList.add(index == -1 ? "previousCard" : "nextCard");

            if (startLine) {
                startLine.style.transition = "none";
                if (!this.isPlayAnimation) startLine.classList.add("noAnimationCard");
            }
            if (endLine) {
                endLine.style.transition = "none";
                if (!this.isPlayAnimation) endLine.classList.add("noAnimationCard");
            }
            if (index == 1) {
                if (startLine) {
                    startLine.style.transformOrigin = "center top";
                    startLine.style.transform = "scaleY(0)";
                }
                if (endLine) {
                    endLine.style.transformOrigin = "center top";
                    endLine.style.transform = "scaleY(0)";
                }
            } else {
                if (startLine) {
                    startLine.style.transformOrigin = "center bottom";
                    startLine.style.transform = "scaleY(0)";
                }
                if (endLine) {
                    endLine.style.transformOrigin = "center bottom";
                    endLine.style.transform = "scaleY(0)";
                }
            }
            if (!this.isPlayAnimation) {
                arrAssetParent[a].classList.remove("nextCard");
                arrAssetParent[a].classList.remove("previousCard");
                if (doAnimation) arrAssetParent[a].classList.remove("noAnimationCard");
                arrAssetParent[a].classList.add("currentCard");
                if (index == 1) {
                    if (startLine) {
                        startLine.style.transition = "all var(--carouselLineDuration) var(--carouselLineDelay)";
                        startLine.style.transform = "scaleY(1)";
                    }
                    if (endLine) {
                        endLine.style.transition = "all var(--carouselLineDuration) var(--carouselStartLineDelay)";
                        endLine.style.transform = "scaleY(1)";
                    }
                } else {
                    if (startLine) {
                        startLine.style.transition = "all var(--carouselLineDuration) var(--carouselStartLineDelay)";
                        startLine.style.transform = "scaleY(1)";
                    }
                    if (endLine) {
                        endLine.style.transition = "all var(--carouselLineDuration) var(--carouselLineDelay)";
                        endLine.style.transform = "scaleY(1)";
                    }
                }
            } else
                setTimeout(() => {
                    arrAssetParent[a].classList.remove("nextCard");
                    arrAssetParent[a].classList.remove("previousCard");
                    if (doAnimation) arrAssetParent[a].classList.remove("noAnimationCard");
                    arrAssetParent[a].classList.add("currentCard");
                    if (index == 1) {
                        if (startLine) {
                            startLine.style.transition = "all var(--carouselLineDuration) var(--carouselLineDelay)";
                            startLine.style.transform = "scaleY(1)";
                        }
                        if (endLine) {
                            endLine.style.transition = "all var(--carouselLineDuration) var(--carouselStartLineDelay)";
                            endLine.style.transform = "scaleY(1)";
                        }
                    } else {
                        if (startLine) {
                            startLine.style.transition = "all var(--carouselLineDuration) var(--carouselStartLineDelay)";
                            startLine.style.transform = "scaleY(1)";
                        }
                        if (endLine) {
                            endLine.style.transition = "all var(--carouselLineDuration) var(--carouselLineDelay)";
                            endLine.style.transform = "scaleY(1)";
                        }
                    }
                }, 0);
        } else if (a == this.currentNodeIndex - 2 && index == 1) {
            arrAssetParent[a].classList.add("noAnimationCard");
            arrAssetParent[a].classList.add("currentCard");
            if (!this.isPlayAnimation) {
                arrAssetParent[a].classList.remove("currentCard");
                if (doAnimation) arrAssetParent[a].classList.remove("noAnimationCard");
                arrAssetParent[a].classList.add("previousCard");
            } else
                setTimeout(() => {
                    arrAssetParent[a].classList.remove("currentCard");
                    if (doAnimation) arrAssetParent[a].classList.remove("noAnimationCard");
                    arrAssetParent[a].classList.add("previousCard");
                }, 0);
        } else if (a == this.currentNodeIndex && index == -1) {
            if (endLine) endLine.style.transformOrigin = "center top";

            arrAssetParent[a].classList.add("noAnimationCard");
            arrAssetParent[a].classList.add("currentCard");
            if (!this.isPlayAnimation) {
                arrAssetParent[a].classList.remove("currentCard");
                if (doAnimation) arrAssetParent[a].classList.remove("noAnimationCard");
                arrAssetParent[a].classList.add("nextCard");
            } else
                setTimeout(() => {
                    arrAssetParent[a].classList.remove("currentCard");
                    if (doAnimation) arrAssetParent[a].classList.remove("noAnimationCard");
                    arrAssetParent[a].classList.add("nextCard");
                }, 0);
        } else {
            arrAssetParent[a].classList.add("noAnimationCard");
            arrAssetParent[a].classList.add("nextCard");
        }
    }
};
GenericCarouselImagestack8.prototype.gotoAndStopFirstNode = function (completeCallback, type, slideContent, indexValue = -1) {
    GenericSpecialgraphics.prototype.gotoAndStopFirstNode.call(this, completeCallback, type, slideContent, indexValue);
    let hasEmptyIntro = this.checkIntroAnimation();
    let commonCarouselParentVertical = this.sgParent.querySelector("[id='commonCarouselParentVertical']");
    if (hasEmptyIntro && commonCarouselParentVertical) {
        commonCarouselParentVertical.style.setProperty("--carouselLineDelay", "1.5s");
    }
    this.setActiveAssetparent();
};
GenericCarouselImagestack8.prototype.setActiveAssetparent = function () {
    if (!this.isPlayAnimation) {
        let arrAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
        for (let a = 0; a < arrAssetParent.length; a++) {
            if (a == this.currentNodeIndex - 1) arrAssetParent[a].style.setProperty("opacity", "1", "important");
            else arrAssetParent[a].style.setProperty("opacity", "0", "important");
        }
    }
};
GenericCarouselImagestack8.prototype.previous = function (completeCallback) {
    let returnVal = GenericSpecialgraphics.prototype.previous.call(this, completeCallback);
    let hasEmptyIntro = this.checkIntroAnimation();
    if (hasEmptyIntro == true && this.currentNodeIndex <= 1) return returnVal;
    this.setActivePh(-1, true);
    this.setActiveAssetparent();
    return returnVal;
};
GenericCarouselImagestack8.prototype.next = function (completeCallback) {
    let returnVal = GenericSpecialgraphics.prototype.next.call(this, completeCallback);
    if (this.currentNodeIndex > this.sgData.length) return returnVal;
    this.setActivePh(1, true);
    this.setActiveAssetparent();
    return returnVal;
};

"use strict";

function GenericCarouselImagestack9(sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, fontData, objDataToSG) {
    this.carouselType = "type9";
    GenericSpecialgraphics.call(this, sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, fontData, objDataToSG);
}

GenericCarouselImagestack9.prototype = Object.create(GenericSpecialgraphics.prototype);

GenericCarouselImagestack9.prototype.initSpecialGraphicsCreation = function () {
    this.specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL);
    this.specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
    GenericSpecialgraphics.prototype.initSpecialGraphicsCreation.call(this, true, false);
    this.sgParent.parentElement.parentElement.setAttribute("data-intro", "false");
    if ((this.isWidget == false || (this.objDataToSG && this.objDataToSG.menuChange)) && !this.oldContent) {
        let carouselParentHorizontal = this.sgParent.querySelector("[id='carouselParentHorizontal']");
        if (!carouselParentHorizontal) {
            carouselParentHorizontal = document.createElement("div");
            carouselParentHorizontal.id = "carouselParentHorizontal";
            carouselParentHorizontal.className = "carouselParentHorizontal";
            this.sgParent.appendChild(carouselParentHorizontal);
        }

        let arrAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
        for (let a = 0; a < arrAssetParent.length; a++) {
            let assetParent = this.createAssetParent(a, this.sgParent);
            if (a == 0) {
                let introParent = this.sgParent.querySelector("[id='introParent']");
                if (!introParent) {
                    introParent = document.createElement("div");
                    introParent.id = "introParent";
                    introParent.className = "introParent";
                    this.setTextType(introParent);
                    carouselParentHorizontal.appendChild(introParent);
                }
                let sgTitleNode = assetParent.querySelector("[id='sgTitleNode']");
                let sgSubTitleNode = assetParent.querySelector("[id='sgSubTitleNode']");
                let sgTitleLabelNode = assetParent.querySelector("[id='sgTitleLabelNode']");
                if (sgTitleNode) {
                    sgTitleNode.id = sgTitleNode.id + "0";
                    sgTitleNode.parentElement.id = sgTitleNode.parentElement.id + "0";
                }
                if (sgTitleLabelNode) {
                    sgTitleLabelNode.id = sgTitleLabelNode.id + "0";
                    sgTitleLabelNode.parentElement.id = sgTitleLabelNode.parentElement.id + "0";
                }
                if (sgSubTitleNode) {
                    sgSubTitleNode.id = sgSubTitleNode.id + "0";
                    sgSubTitleNode.parentElement.id = sgSubTitleNode.parentElement.id + "0";
                }

                introParent.appendChild(assetParent);
            } else {
                let scrollParent = this.sgParent.querySelector("[id='scrollParent']");
                if (!scrollParent) {
                    scrollParent = document.createElement("div");
                    scrollParent.id = "scrollParent";
                    scrollParent.className = "scrollParent";
                    this.setTextType(scrollParent);
                    carouselParentHorizontal.appendChild(scrollParent);
                }
                let cmp = arrAssetParent[a].querySelector("[id='contentMainParent']");
                if (cmp && this.isPlayAnimation) {
                    cmp.style.setProperty("transition", "opacity 1.5s");
                    cmp.style.setProperty("height", "100%", "important");
                }
                let titleLabelTextParent = arrAssetParent[a].querySelector("[id='titleLabelTextParent']");
                if (titleLabelTextParent) titleLabelTextParent.style.setProperty("margin-bottom", "0px");

                scrollParent.appendChild(arrAssetParent[a]);
                let textBaseParent = arrAssetParent[a].querySelector("[id*='textBaseParentNode']");
                if (textBaseParent) {
                    // textBaseParent.style.maxHeight = "100%";
                    textBaseParent.style["flex-grow"] = 1;
                }

                if (this.sgData.length > 5) {
                    if (a == 1) arrAssetParent[a].classList.add("currentCard");
                    else if (a == 2) arrAssetParent[a].classList.add("nextCard");
                    else if (a == 3) arrAssetParent[a].classList.add("next2Card");
                    else if (a == this.sgData.length - 1) arrAssetParent[a].classList.add("previousCard");
                    else if (a == this.sgData.length - 2) arrAssetParent[a].classList.add("previous2Card");
                    else arrAssetParent[a].classList.add("nextHideCard");
                }
            }
        }
    }
    setTimeout(() => {
        this.specialGraphicsCreationComplete();
        let slideId = this.slideContent ? this.slideContent.id : this.sgParent.parentElement.parentElement.parentElement.id;
        if (this.updateThumbnail) this.updateThumbnail(slideId);
    }, 0);
};

GenericCarouselImagestack9.prototype.floaterNavigation = function (index, type = "") {
    if (this.currentNodeIndex + index <= 1) this.currentNodeIndex = 2;
    GenericSpecialgraphics.prototype.floaterNavigation.call(this, index, type);
    this.setActivePh(index, false);
    setTimeout(() => {
        this.rePositioningTextElement(this.currentNodeIndex - 1);
    }, 0);
};

GenericCarouselImagestack9.prototype.setActivePh = function (index = 1, doAnimation = false) {
    if (this.sgParent.offsetHeight == 0) {
        let arrSubtitles = this.sgParent.querySelectorAll("[id='subTitleTextParent']");
        arrSubtitles.forEach((element) => {
            try {
                element.style.removeProperty("max-height");
                element.children[0].style.removeProperty("max-height");
            } catch (error) {}
        });
    }
    if (this.currentNodeIndex <= 1) this.currentNodeIndex = 2;
    let commonCarouselParent = this.sgParent.querySelector("[id='scrollParent");
    for (let a = 0; a < commonCarouselParent.children.length; a++) {
        commonCarouselParent.children[a].classList.remove("noAnimationCard");
        commonCarouselParent.children[a].classList.remove("previousHideCard");
        commonCarouselParent.children[a].classList.remove("previous2Card");
        commonCarouselParent.children[a].classList.remove("previousCard");
        commonCarouselParent.children[a].classList.remove("currentCard");
        commonCarouselParent.children[a].classList.remove("nextCard");
        commonCarouselParent.children[a].classList.remove("next2Card");
        commonCarouselParent.children[a].classList.remove("nextHideCard");
        if (a == this.currentNodeIndex - 5 && index != -1) {
            //previous 3
            commonCarouselParent.children[a].classList.add("noAnimationCard");
            commonCarouselParent.children[a].classList.add("previous2Card");
            if (this.isPlayAnimation == false) {
                commonCarouselParent.children[a].classList.remove("previous2Card");
                if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                commonCarouselParent.children[a].classList.add("previousHideCard");

                this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
            } else
                setTimeout(() => {
                    commonCarouselParent.children[a].classList.remove("previous2Card");
                    if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                    commonCarouselParent.children[a].classList.add("previousHideCard");

                    setTimeout(() => {
                        this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
                    }, 0);
                }, 0);
        } else if (a == this.currentNodeIndex - 4) {
            //previous 2
            commonCarouselParent.children[a].classList.add("noAnimationCard");
            commonCarouselParent.children[a].classList.add(index == -1 ? "previousHideCard" : "previousCard");
            if (this.isPlayAnimation == false) {
                commonCarouselParent.children[a].classList.remove("previousHideCard");
                commonCarouselParent.children[a].classList.remove("previousCard");
                if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                commonCarouselParent.children[a].classList.add("previous2Card");

                this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
            } else
                setTimeout(() => {
                    commonCarouselParent.children[a].classList.remove("previousHideCard");
                    commonCarouselParent.children[a].classList.remove("previousCard");
                    if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                    commonCarouselParent.children[a].classList.add("previous2Card");

                    setTimeout(() => {
                        this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
                    }, 0);
                }, 0);
        } else if (a == this.currentNodeIndex - 3) {
            //previous
            commonCarouselParent.children[a].classList.add("noAnimationCard");
            commonCarouselParent.children[a].classList.add(index == -1 ? "previous2Card" : "currentCard");
            if (this.isPlayAnimation == false) {
                commonCarouselParent.children[a].classList.remove("currentCard");
                commonCarouselParent.children[a].classList.remove("previous2Card");
                if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                commonCarouselParent.children[a].classList.add("previousCard");

                this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
            } else
                setTimeout(() => {
                    commonCarouselParent.children[a].classList.remove("currentCard");
                    commonCarouselParent.children[a].classList.remove("previous2Card");
                    if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                    commonCarouselParent.children[a].classList.add("previousCard");

                    setTimeout(() => {
                        this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
                    }, 0);
                }, 0);
        } else if (a == this.currentNodeIndex - 2) {
            //Current
            commonCarouselParent.children[a].classList.add("noAnimationCard");
            commonCarouselParent.children[a].classList.add(index == -1 ? "previousCard" : "nextCard");
            if (this.isPlayAnimation == false) {
                commonCarouselParent.children[a].classList.remove("nextCard");
                commonCarouselParent.children[a].classList.remove("previousCard");
                if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                commonCarouselParent.children[a].classList.add("currentCard");

                this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
            } else
                setTimeout(() => {
                    commonCarouselParent.children[a].classList.remove("nextCard");
                    commonCarouselParent.children[a].classList.remove("previousCard");
                    if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                    commonCarouselParent.children[a].classList.add("currentCard");

                    setTimeout(
                        () => {
                            this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
                        },
                        doAnimation ? 500 : 0
                    );
                }, 0);
        } else if (a == this.currentNodeIndex - 1) {
            //next
            commonCarouselParent.children[a].classList.add("noAnimationCard");
            commonCarouselParent.children[a].classList.add(index == -1 ? "currentCard" : "next2Card");
            if (this.isPlayAnimation == false) {
                commonCarouselParent.children[a].classList.remove("currentCard");
                commonCarouselParent.children[a].classList.remove("next2Card");
                if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                commonCarouselParent.children[a].classList.add("nextCard");

                this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
            } else
                setTimeout(() => {
                    commonCarouselParent.children[a].classList.remove("currentCard");
                    commonCarouselParent.children[a].classList.remove("next2Card");
                    if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                    commonCarouselParent.children[a].classList.add("nextCard");

                    setTimeout(() => {
                        this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
                    }, 0);
                }, 0);
        } else if (a == this.currentNodeIndex) {
            //next 2
            commonCarouselParent.children[a].classList.add("noAnimationCard");
            commonCarouselParent.children[a].classList.add(index == -1 ? "nextCard" : "nextHideCard");
            if (this.isPlayAnimation == false) {
                commonCarouselParent.children[a].classList.remove("nextCard");
                commonCarouselParent.children[a].classList.remove("nextHideCard");
                if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                commonCarouselParent.children[a].classList.add("next2Card");

                this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
            } else
                setTimeout(() => {
                    commonCarouselParent.children[a].classList.remove("nextCard");
                    commonCarouselParent.children[a].classList.remove("nextHideCard");
                    if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                    commonCarouselParent.children[a].classList.add("next2Card");

                    setTimeout(() => {
                        this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
                    }, 0);
                }, 0);
        } else if (a == this.currentNodeIndex + 1 && index == -1) {
            //next 2
            commonCarouselParent.children[a].classList.add("noAnimationCard");
            commonCarouselParent.children[a].classList.add("next2Card");
            if (this.isPlayAnimation == false) {
                commonCarouselParent.children[a].classList.remove("next2Card");
                if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                commonCarouselParent.children[a].classList.add("nextHideCard");

                this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
            } else
                setTimeout(() => {
                    commonCarouselParent.children[a].classList.remove("next2Card");
                    if (doAnimation) commonCarouselParent.children[a].classList.remove("noAnimationCard");
                    commonCarouselParent.children[a].classList.add("nextHideCard");

                    setTimeout(() => {
                        this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
                    }, 0);
                }, 0);
        } else {
            if (index != -1) {
                commonCarouselParent.children[a].classList.remove("noAnimationCard");
                commonCarouselParent.children[a].classList.add("noAnimationCard");
                commonCarouselParent.children[a].classList.add("nextHideCard");
                if (this.isPlayAnimation == false) {
                    this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
                } else
                    setTimeout(() => {
                        this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
                    }, 0);
            } else {
                if (this.isPlayAnimation == false) {
                    commonCarouselParent.children[a].classList.add("noAnimationCard");
                    commonCarouselParent.children[a].classList.add("previousHideCard");
                    this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
                } else
                    setTimeout(() => {
                        commonCarouselParent.children[a].classList.add("noAnimationCard");
                        commonCarouselParent.children[a].classList.add("previousHideCard");
                        setTimeout(() => {
                            this.doFontFitOnNode(commonCarouselParent.children[a], a + 1);
                        }, 0);
                    }, 0);
            }
        }
    }
};

GenericCarouselImagestack9.prototype.doFontFitOnNode = function (assetParentFinal, i) {
    if (assetParentFinal?.offsetHeight == 0 || assetParentFinal?.offsetWidth == 0) return;
    let titleNode = assetParentFinal.querySelector("[id*='sgTitleNode']");
    let subTitleNode = assetParentFinal.querySelector("[id*='sgSubTitleNode']");
    if (titleNode && subTitleNode && this.fontData.title.length <= 2) {
        let isSubtitleEnabled = window.getComputedStyle(subTitleNode)["display"] == "none" ? false : true;
        titleNode.classList.remove(this.fontData["title"]);
        titleNode.classList.remove(this.fontData["titleNoSubtitle"]);

        this.specialGraphicsUtils.removeAllFontClass(titleNode);

        let fontClass = isSubtitleEnabled == false ? this.fontData["titleNoSubtitle"] : this.fontData["title"];
        if (!fontClass) fontClass = isSubtitleEnabled == false ? this.fontData["titleNoSubtitle"] : this.fontData["title"];
        titleNode.classList.add(fontClass);
        titleNode.setAttribute("data-font", fontClass);
        titleNode.style.removeProperty("min-height");
        titleNode.style.removeProperty("max-height");
        titleNode.style.removeProperty("font-size");

        titleNode.setAttribute("defaultsize", parseFloat(window.getComputedStyle(titleNode)["font-size"]));
        if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(titleNode);
        if (titleNode.hasAttribute("user-font-size")) {
            this.specialGraphicsUtils.removeAllFontClass(titleNode);
            titleNode.classList.add(titleNode.getAttribute("user-font-size"));
        }
        this.specialGraphicsUtils.doCheckMaxHeight(titleNode, this.sgParent);
        this.specialGraphicsUtils.doFontFitForCss(titleNode, this.sgParent);
    }
    this.updateHeightForText(assetParentFinal);
    this.onTextChangeForAllNodes(assetParentFinal, i);
    // assetParentFinal.style.height = window.getComputedStyle(assetParentFinal).maxHeight;
    // let contentMainParent = assetParentFinal.querySelector("[id='contentMainParent']");
    // if (contentMainParent) contentMainParent.style.setProperty("height", window.getComputedStyle(assetParentFinal).maxHeight, "important");
    // setTimeout(() => {
    //     this.onTextChangeForAllNodes(assetParentFinal, i);
    //     assetParentFinal.style.height = "auto";
    //     if (contentMainParent) contentMainParent.style.removeProperty("height");
    // }, 0);
};
GenericCarouselImagestack9.prototype.getTargetElement = function (elementID) {
    let index = this.currentNodeIndex - 1 == 0 ? this.currentNodeIndex : this.currentNodeIndex - 1;
    let assetParent = this.sgParent.querySelector("[id='assetParent" + index + "']");
    if (assetParent && assetParent.querySelector("[id='" + elementID + "']")) return assetParent.querySelector("[id='" + elementID + "']");
    let introParent = this.sgParent.querySelector("[id='introParent']");
    if (introParent && introParent.querySelector("[id*='" + elementID + "']")) return introParent.querySelector("[id*='" + elementID + "']");
};

GenericCarouselImagestack9.prototype.updatenavFloater = function () {
    if (this.isPlayAnimation == false && this.isPresent != true && this.updateNavFloaterIndex) {
        let slideID = this.slideContent && this.slideContent.id ? this.slideContent.id : null;
        this.updateNavFloaterIndex(this.currentNodeIndex - 1 < 1 ? 1 : this.currentNodeIndex - 1, slideID, -1);
    }
};

GenericCarouselImagestack9.prototype.getCurrentIndex = function (elementID) {
    if (elementID?.includes("0")) return 0;
    return this.currentNodeIndex - 1;
};

GenericCarouselImagestack9.prototype.onTextChange = function (element) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    let contentMainParent = assetParent?.querySelector("[id='contentMainParent']");
    if (contentMainParent) contentMainParent.style.height = window.getComputedStyle(assetParent).maxHeight;
    GenericSpecialgraphics.prototype.onTextChange.call(this, element);
    if (contentMainParent) contentMainParent.style.removeProperty("height");
};

GenericCarouselImagestack9.prototype.startIndex = function (currentSlideData) {
    return this.specialGraphicsUtils.getStartIndex(currentSlideData, this.sgParent);

    // let presentParent = currentSlideData ? currentSlideData : this.sgParent;
    // let introParent = presentParent ? presentParent.querySelector("[id='introParent']") : null;
    // let sgParent = presentParent ? presentParent.querySelector("[id='specialgraphicsParent']") : this.sgParent;

    // let isNotVisible = introParent?.style?.display == "none" || introParent?.style?.opacity == 0 || introParent?.style?.opacity == "0";
    // if (isNotVisible) sgParent.setAttribute("startindex", "1");
    // else sgParent.removeAttribute("startindex");

    // let localParent = sgParent ? sgParent : this.sgParent;
    // let animationDIV = localParent?.parentElement?.parentElement ? localParent.parentElement.parentElement : null;
    // let showIntro = animationDIV?.hasAttribute("data-intro") ? animationDIV.getAttribute("data-intro") : "true";

    // return (isNotVisible || !assetParent) && showIntro != "true" ? 1 : 0;
};

GenericCarouselImagestack9.prototype.initPresentSG = function (slideContent) {
    let scrollParent = slideContent.querySelector("[id='scrollParent']");
    if (scrollParent) scrollParent.style.opacity = 0;
    let arrNodes = scrollParent?.querySelectorAll("[class*='moodanimation']");
    for (let a = 0; a < arrNodes.length; a++) {
        arrNodes[a].classList.remove("moodanimation");
        arrNodes[a].removeAttribute("data-animation");
    }
};
GenericCarouselImagestack9.prototype.gotoAndStopFirstNode = function (completeCallback, type, slideContent, indexValue = -1) {
    let scrollParent = slideContent ? slideContent.querySelector("[id='scrollParent']") : this.sgParent.querySelector("[id='scrollParent']");
    if (scrollParent) {
        scrollParent.style.transition = "all " + (this.isPlayAnimation ? "2s" : "0s");
        scrollParent.style.opacity = 1;
    }

    this.currentNodeIndex = 2;
    this.floaterNavigation(0);
    let introParent = this.sgParent.querySelector("[id='introParent']");

    let commonCarouselParent = this.sgParent.querySelector("[id='scrollParent");
    let fitChild = commonCarouselParent.children[this.currentNodeIndex - 2];
    this.doFontFitOnNode(fitChild, 1);

    if (introParent.style.display == "none") {
        this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", null, this.isPlayAnimation, this.eventManager, 0);
        setTimeout(
            () => {
                completeCallback ? completeCallback() : "";
            },
            this.isPlayAnimation ? 1600 : 0
        );
    } else {
        let index = introParent && introParent.style.display == "none" ? this.currentNodeIndex - 1 : this.currentNodeIndex - 2;
        this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, index);
    }
    this.sgParent.removeAttribute("startindex");
};
GenericCarouselImagestack9.prototype.previous = function (completeCallback) {
    //     GenericSpecialgraphics.prototype.previous.call(this, completeCallback);
    //     let hasEmptyIntro = this.checkIntroAnimation();
    //     if (hasEmptyIntro == true && this.currentNodeIndex <= 1) return;

    this.currentNodeIndex = this.currentNodeIndex - 1;
    if (this.currentNodeIndex <= 1) return false;
    this.setActivePh(-1, this.isPlayAnimation);
    setTimeout(() => {
        this.rePositioningTextElement(this.currentNodeIndex - 1);
    }, 0);
    setTimeout(
        () => {
            completeCallback ? completeCallback() : "";
        },
        this.isPlayAnimation ? 1600 : 0
    );
};
GenericCarouselImagestack9.prototype.next = function (completeCallback) {
    //     GenericSpecialgraphics.prototype.next.call(this, completeCallback);
    //     if (this.currentNodeIndex > this.sgData.length) return;
    this.sgParent.setAttribute("dotransition", "false");
    this.currentNodeIndex = this.currentNodeIndex + 1;
    if (this.currentNodeIndex > this.sgData.length) return;

    this.setActivePh(1, this.isPlayAnimation);
    setTimeout(
        () => {
            completeCallback ? completeCallback() : "";
        },
        this.isPlayAnimation ? 1600 : 0
    );
};

"use strict";

function SGAssetLoader() {}

SGAssetLoader.prototype.loadAssets = function (arrayAssets, appStaticURL) {
    this.intLoadCount = 0;
    this.params = arrayAssets;
    return new Promise((resolve, reject) => {
        if (!arrayAssets || arrayAssets.length === 0) {
            resolve(this.params);
            return;
        }

        for (let i = 0; i < arrayAssets.length; i++) {
            let strAssetPrefixURL = appStaticURL || "";
            const strAssetUrl = arrayAssets[i].url;
            strAssetPrefixURL = !!arrayAssets[i].corporateUrl && arrayAssets[i].corporateUrl != "" ? appCorporateURL : strAssetPrefixURL;
            let url = strAssetUrl;
            url = this.checkAppStaticURLSG(url, strAssetPrefixURL)
            // if ((url.includes("genericassets/") || url.includes("moods/") || url.includes("imagestack/") || url.includes("textstack/")) && !url.includes("assets/projectresources/"))
            //     url = strAssetPrefixURL + url;
            // if (strAssetUrl.includes(strAssetPrefixURL) == true) url = strAssetUrl;

            let urlType = strAssetUrl.split("/pictures/");
            if (urlType.length == 2) url = strAssetUrl;
            this.downloadAsset(arrayAssets, url, i, resolve, reject);
        }
    });
};

SGAssetLoader.prototype.checkAppStaticURLSG = function (imageURL, appStaticURL) {
    if (imageURL?.includes("assets/projectresources/assets/projectresources/")) imageURL = imageURL.replace("assets/projectresources/assets/projectresources/", "assets/projectresources/");
    return imageURL?.startsWith("http") || imageURL?.startsWith(appStaticURL) ? imageURL : appStaticURL + imageURL;
};

SGAssetLoader.prototype.downloadAsset = function (arrayAssets, url, index, resolve, reject) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url + "");

    xhr.onload = (data) => {
        if (arrayAssets.type != "image") arrayAssets[index].data = data.target.response;
        this.intLoadCount++;
        if (arrayAssets.length == this.intLoadCount) resolve(this.params);
    };

    xhr.onerror = () => {
        this.intLoadCount++;
        if (arrayAssets.length == this.intLoadCount) resolve(this.params);
        console.log("File could not be loaded..." + xhr.statusText);
    };

    xhr.send();
};

"use strict";

function SpecialGraphicsUtils() {}

SpecialGraphicsUtils.prototype.setAssetType = function (slideType) {
    this.slideType = slideType;

    this.fontSizeJSON = {
        coverpage: {
            titlelabel: 1,
            title: 2,
            subtitle: 3,
            venue: 4,
            creatorname: 1,
            speakerprimary: 1,
            speakersecondary: 1,
            creatorname: 1,
            creatordesignation: 1,
            creatorphone: 1,
            creatorwebsite: 1,
            creatoremail: 1,
            creatorfacebook: 1,
            creatortwitter: 1,
            creatorinstagram: 1,
            creatorlinkedin: 1,
            creatorskype: 1,
            presentedto: 1,
            titleNoSubtitle: 3,
            titleNoTitleLabel: 2,
            titleNoSubtitleTitleLabel: 4,
        },
        coverpagesmall: {
            titlelabel: 1,
            title: 1,
            subtitle: 2,
            venue: 4,
            titleNoSubtitle: 2,
            titleNoTitleLabel: 1,
            titleNoSubtitleTitleLabel: 3,
        },
        coverpagemedium: {
            titlelabel: 1,
            title: 2,
            subtitle: 3,
            titleNoSubtitle: 2,
            titleNoTitleLabel: 2,
            titleNoSubtitleTitleLabel: 3,
        },
        cta: {
            title: 1,
            subtitle: 2,
            titleNoSubtitle: 2,
        },
        quote: {
            titleGenericNoAuthName: 3,
            titleGenericNoAuthImage: 3,
            titleGenericNoAuthDetails: 5,
            titleGenericNoAuthDesigination: 3,
            titleGenericNoAuthNameDesigination: 4,
            authorname: 1,
            authordesignation: 2,
            titleauthordesignation: 1,
            title: 4,
            // New Quote Auth name as Main type start
            titleAuthorTypeName: 2,
            titleAuthorTypeDesigination: 2,
            titleAuthorTypeTitle: 6,
            titleAuthorTypeTitleElegant: 10,
            // New Quote Auth name as Main type end
            titleNoAuthName: 5,
            titleNoAuthDesigination: 5,
            titleNoAuthNameDesigination: 6,
            titleNoAuthImage: 5,
            titleNoAuthDetails: 6,
            titlePlaceHolder: 2,
            titlePlaceHolder2: 2,
        },
        quotesmall: {
            authorname: 1,
            authordesignation: 2,
            title: 3,
            titleNoAuthName: 3,
            titleNoAuthDesigination: 3,
            titleNoAuthNameDesigination: 4,
        },
        sectiontitle: {
            titlelabel: 1,
            title: 3,
            subtitle: 2,
            titleNoSubtitle: 4,
            titleNoTitleLabel: 3,
            titleNoSubtitleTitleLabel: 4,
        },
        sectiontitlelarge: {
            titlelabel: 1,
            title: 3,
            subtitle: 5,
            titleNoSubtitle: 3,
            titleNoTitleLabel: 3,
            titleNoSubtitleTitleLabel: 4,
        },
        imagestackLeft: {
            titlelabel: 1,
            title: 4,
            titleNoTitleLabel: 4,
            titleNoSubtitle: 6,
            subtitle: 3,
        },
        imagestackTop: {
            titlelabel: 1,
            title: 2,
            titleNoTitleLabel: 2,
            titleNoSubtitle: 3,
            subtitle: 1,
        },
        imagestack: {
            titlelabel: 1,
            title: 3,
            titleNoTitleLabel: 3,
            titleNoSubtitle: 4,
            subtitle: 2,
        },
        textstack: {
            titlelabel: 1,
            title: 2,
            titleNoTitleLabel: 2,
            titleNoSubtitle: 4,
            subtitle: 3,
        },
        textstackSingle: {
            titlelabel: 1,
            title: 1,
            titleNoTitleLabel: 1,
            titleNoSubtitle: 2,
            subtitle: 1,
        },
        textstackTop: {
            titlelabel: 1,
            title: 2,
            titleNoTitleLabel: 2,
            titleNoSubtitle: 3,
            subtitle: 1,
        },
        textstackCenter: {
            titlelabel: 1,
            title: 2,
            titleNoTitleLabel: 2,
            titleNoSubtitle: 2,
            subtitle: 1,
        },
        textstackOneLine: {
            titlelabel: 1,
            title: 1,
            titleNoTitleLabel: 1,
            titleNoSubtitle: 1,
            subtitle: 1,
        },
        agenda: {
            titlelabel: 1,
            title: 1,
            titleNoTitleLabel: 1,
            titleNoSubtitle: 2,
            subtitle: 2,
        },
    };
};

//Create Text element nodes with Default text size
SpecialGraphicsUtils.prototype.createTextElement = function (parent, textContent, id, className, slideType, showSelector) {
    var textElement = document.createElement("div");
    textContent = textContent ? textContent.toString() : "";
    // if (
    //     textContent.includes("<span") ||
    //     textContent.includes("<br>") ||
    //     textContent.includes("</a>") ||
    //     textContent.includes("<div") ||
    //     textContent.includes("<removediv") ||
    //     textContent.includes("<section")
    // )
    //     textElement.innerHTML = textContent;
    // else textElement.innerText = textContent;

    textElement.innerHTML = textContent;

    // textElement.innerText = textContent;
    // console.log("Sgg - text1 - " + textElement.id + "  --  " + textElement.innerText);
    textElement.id = id;
    textElement.className = className;
    textElement.setAttribute("data-type", "TEXT");
    textElement.setAttribute("data-cssslide", "slide0" + slideType);
    textElement.setAttribute("data-textelement", "true");
    textElement.setAttribute("spellcheck", "false");
    textElement.setAttribute("data-focus", "true");
    if (showSelector != null) textElement.setAttribute("data-showselector", showSelector);
    this.setTextDefaultSize(textElement, parent);
    this.setOpacityAttribute(textElement);
    this.setHighlightData(textElement);

    let modifiedString = TextHighLightUtils.highlightToString(textElement.innerHTML);
    // // let oldHTML = textElement.innerHTML;
    textElement.innerHTML = modifiedString;
    textElement.innerText = modifiedString;
    // let sd = textElement.innerHTML;
    TextHighLightUtils.updateHighlight(textElement, textElement.innerHTML, "", true);
    // textElement.innerHTML = oldHTML;
    textElement.setAttribute("data-heading", textElement.innerHTML);
    textElement.setAttribute("data-oldtext", textElement.innerHTML);
    this.setHighlightData(textElement);
    // console.log(textElement.innerHTML);
    // textElement.innerHTML = textElement.textContent.replace("\n", "<br>").replace("\n", "<br>").replace("\n", "<br>").replace("\n", "<br>").replace("\n", "<br>");
    return textElement;
};

SpecialGraphicsUtils.prototype.setHighlightData = function (textNode) {
    let textSpan = textNode.querySelectorAll("[data-highlightanimation=animate]");
    if (textSpan.length > 0 && textNode.hasAttribute("data-supportedtexthighlight") == false) {
        let value = textSpan[0].classList.contains("animatehighlightbg") ? "bigtext" : "smalltext";
        textNode.setAttribute("data-supportedtexthighlight", value);
    }
};

// Set default text fint size setting for text element
SpecialGraphicsUtils.prototype.setTextDefaultSize = function (textElement, parent) {
    let op = textElement.style.opacity;
    textElement.style.opacity = 0;
    if (parent) parent.appendChild(textElement);
    textElement.setAttribute("defaultsize", parseFloat(window.getComputedStyle(textElement)["font-size"]));
    textElement.style.opacity = op;
};

//Create Image element nodes with styles
SpecialGraphicsUtils.prototype.createImageElement = function (parent, className, pos, src, width, height, x, y, targetID = "coverimage", objNode, assetID = null, directID) {
    var imageElement = document.createElement("img");
    imageElement.id = directID ? directID : (assetID ? assetID : "coverimage") + pos;
    imageElement.setAttribute("data-target-id", targetID);
    if (!!className && className != "") imageElement.className = className;
    if (src && src != "") imageElement.src = src;
    else imageElement.style.display = "none";
    if (width != 0 && width != "NaN") {
        imageElement.style.width = width + "px";
        imageElement.setAttribute("data-width", width);
    }
    if (height != 0 && height != "NaN") {
        imageElement.style.height = height + "px";
        imageElement.setAttribute("data-height", height);
    }
    imageElement.setAttribute("data-x", x);
    imageElement.setAttribute("data-y", y);
    parent.appendChild(imageElement);

    if (objNode) {
        if (objNode[targetID + "style"]) {
            imageElement.style = objNode[targetID + "style"];
            imageElement.setAttribute("data-csstext", objNode[targetID + "style"]);
            this.applyOverlayToCSSImage(imageElement, objNode, targetID);
        } else if (width != 0 && height != 0) this.updateImageReSize(width, height, imageElement);
    }
    return imageElement;
};

//Applying overlay for Image if style is there.
SpecialGraphicsUtils.prototype.applyOverlayToCSSImage = function (imageDetails, elementData, targetID) {
    if (imageDetails && imageDetails != "" && !!elementData && elementData[targetID + "style"] && elementData[targetID + "style"].includes("color")) {
        let isOverLayDiv = imageDetails.parentNode.querySelector("[id='coverImageOverlay']");

        if (isOverLayDiv && isOverLayDiv != "") isOverLayDiv.parentNode.removeChild(isOverLayDiv);
        if (imageDetails.style.color && imageDetails.style.color != "") {
            let overLayDiv = document.createElement("div");
            overLayDiv.setAttribute("id", "coverImageOverlay");
            overLayDiv.setAttribute("class", "coverImageOverlay");
            overLayDiv.setAttribute("data-type", "overlay");
            overLayDiv.setAttribute("data-nodetype", "imageOverlay");
            overLayDiv.style.pointerEvents = "none";
            overLayDiv.style.setProperty("background", imageDetails.style.color, "important");
            imageDetails.parentNode.appendChild(overLayDiv);
        }
    }
};

// Image fit logic
SpecialGraphicsUtils.prototype.updateImageReSize = function (width, height, originalImageNode, callback = null, src = null) {
    if (width == "NaN" || height == "NaN" || width == 0 || height == 0 || parseFloat(width) == 0 || parseFloat(height) == 0 || !originalImageNode) return;
    const imgSrc = src ? src : originalImageNode.src;

    let targetId = originalImageNode?.dataset?.targetId ? originalImageNode.dataset.targetId : "";
    const isLogoImage = targetId?.toLowerCase()?.includes("logo");

    let properties = { isSpecialgraphcis: true, containerwidth: parseInt(width), containerheight: parseInt(height), filltype: isLogoImage ? "fitcanvas" : "fillcanvas" };
    let callbackparam = { isLogoImage: isLogoImage, originalImageNode: originalImageNode, src: imgSrc, callback: callback, ...properties };
    if (originalImageNode.offsetHeight != 0 && originalImageNode.offsetWidth != 0) CommonImageUtils.updateImageReSize(originalImageNode, properties, this.imgLoadCompleteCallback, callbackparam);

    // if (originalImageNode.complete) SpecialGraphicsUtils.updateImageReSizeAfterLoad(width, height, originalImageNode, callback, src);
    // else {
    //     originalImageNode.onload = function (event) {
    //         let w = originalImageNode.hasAttribute("data-width") ? parseInt(originalImageNode.getAttribute("data-width")) : 0;
    //         if (w == parseInt(width)) SpecialGraphicsUtils.updateImageReSizeAfterLoad(width, height, originalImageNode, callback, src);
    //         originalImageNode.onload = null;
    //     };
    //     originalImageNode.src = imgSrc;
    //     originalImageNode.onerror = function () {
    //         callback ? callback() : "";
    //         console.log("SGG - loadimage error - " + originalImageNode.id + "   -   " + originalImageNode.src);
    //     };
    // }
};

SpecialGraphicsUtils.prototype.imgLoadCompleteCallback = function (callbackparam) {
    let { originalImageNode, isLogoImage, containerwidth, callback } = callbackparam;
    if (isLogoImage) {
        if (originalImageNode.hasAttribute("data-imagecropalignment") && originalImageNode.getAttribute("data-imagecropalignment") == "center") {
        } else {
            let xLogo = originalImageNode.offsetLeft;
            xLogo = originalImageNode.hasAttribute("data-imagecropalignment") && originalImageNode.getAttribute("data-imagecropalignment") == "right" ? 900 : xLogo;
            if (xLogo > 600) originalImageNode.style.setProperty("left", (containerwidth - originalImageNode.width) / (containerwidth / 100) + "%");
            else originalImageNode.style.setProperty("left", "0");
            originalImageNode.style.setProperty("top", "0");
        }
    }
    if (originalImageNode.imgLoadCallback) {
        originalImageNode.imgLoadCallback();
        // console.log("SG - prompt image load callback for thumbnail update");
    }
    callback ? callback() : "";
};

// SpecialGraphicsUtils.updateImageReSizeAfterLoad = function (width, height, originalImageNode, callback = null) {
//     const numContainerW = parseInt(width);
//     const numContainerH = parseInt(height);
//     if (originalImageNode.height == 0 || originalImageNode.width == 0 || isNaN(numContainerW) || isNaN(numContainerH)) return;

//     originalImageNode.style.removeProperty("min-width");
//     originalImageNode.style.removeProperty("min-height");
//     originalImageNode.style.removeProperty("max-width");
//     originalImageNode.style.removeProperty("max-height");
//     originalImageNode.style.removeProperty("filter");

//     originalImageNode.style.setProperty("width", "auto");
//     originalImageNode.style.setProperty("height", "auto");
//     originalImageNode.style.setProperty("margin", "auto");
//     originalImageNode.style.setProperty("left", "unset");
//     originalImageNode.style.setProperty("right", "unset");
//     originalImageNode.style.setProperty("top", "unset");
//     originalImageNode.style.setProperty("bottom", "unset");
//     originalImageNode.style.setProperty("x", "0");
//     originalImageNode.style.setProperty("y", "0");
//     originalImageNode.style.setProperty("transform", "scale(1)");
//     originalImageNode.style.setProperty("object-fit", "unset");

//     let targetId = originalImageNode.dataset && originalImageNode.dataset.targetId && originalImageNode.dataset.targetId ? originalImageNode.dataset.targetId : "";
//     const isLogoImage = targetId.toLowerCase().includes("logo");
//     var imageDimensionRatio = (originalImageNode.width / originalImageNode.height).toFixed(1);
//     var canvasDimensionRatio = (numContainerW / numContainerH).toFixed(1);
//     if (imageDimensionRatio < canvasDimensionRatio) {
//         if (!isLogoImage) SpecialGraphicsUtils.prototype.fitWidth(originalImageNode, numContainerH);
//         else SpecialGraphicsUtils.prototype.fitHeight(originalImageNode, numContainerW);
//     } else if (imageDimensionRatio > canvasDimensionRatio) {
//         if (!isLogoImage) SpecialGraphicsUtils.prototype.fitHeight(originalImageNode, numContainerW);
//         else SpecialGraphicsUtils.prototype.fitWidth(originalImageNode, numContainerH, isLogoImage);
//     } else {
//         originalImageNode.style.setProperty("width", "100%");
//         originalImageNode.style.setProperty("height", "100%");
//         originalImageNode.style.setProperty("left", "0");
//         originalImageNode.style.setProperty("margin", "unset");
//         originalImageNode.style.setProperty("top", "0");
//     }
//     if (originalImageNode.parentElement) {
//         originalImageNode.parentElement.dataset.orginalwidth = originalImageNode.width;
//         originalImageNode.parentElement.dataset.orginalheight = originalImageNode.height;
//         originalImageNode.parentElement.dataset.containerwidth = numContainerW;
//         originalImageNode.parentElement.dataset.containerheight = numContainerH;
//     }
//     if (isLogoImage) {
//         if (originalImageNode.hasAttribute("data-imagecropalignment") && originalImageNode.getAttribute("data-imagecropalignment") == "center") {
//         } else {
//             let xLogo = originalImageNode.offsetLeft;
//             xLogo = originalImageNode.hasAttribute("data-imagecropalignment") && originalImageNode.getAttribute("data-imagecropalignment") == "right" ? 900 : xLogo;
//             if (xLogo > 600) originalImageNode.style.setProperty("left", (numContainerW - originalImageNode.width) / (numContainerW / 100) + "%");
//             else originalImageNode.style.setProperty("left", "0");
//             originalImageNode.style.setProperty("top", "0");
//         }
//     }
//     if (originalImageNode.imgLoadCallback) {
//         originalImageNode.imgLoadCallback();
//         console.log("SG - prompt image load callback for thumbnail update");
//     }
//     callback ? callback() : "";
// };

// // Fit image to height
// SpecialGraphicsUtils.prototype.fitHeight = function (originalImageNode, numContainerW) {
//     originalImageNode.style.setProperty("height", "100%");
//     originalImageNode.style.setProperty("width", "auto");
//     originalImageNode.style.setProperty("margin", "unset");
//     originalImageNode.style.setProperty("top", "0");
//     originalImageNode.style.setProperty("left", (numContainerW - originalImageNode.width) / 2 / (numContainerW / 100) + "%");
// };

// // Fit image to width
// SpecialGraphicsUtils.prototype.fitWidth = function (originalImageNode, numContainerH, isLogoImage) {
//     originalImageNode.style.setProperty("width", "100%");
//     originalImageNode.style.setProperty("height", "auto");
//     originalImageNode.style.setProperty("left", "0");
//     originalImageNode.style.setProperty("margin", "unset");
//     originalImageNode.style.setProperty("top", (numContainerH - originalImageNode.height) / 2 / (numContainerH / 100) + "%");
//     // let isPlaceholder = originalImageNode.id.toLowerCase().includes("placeholder") ? true : false;
//     if (isLogoImage == true && originalImageNode.parentElement && originalImageNode.parentElement.parentElement) {
//         let logoContentParent = originalImageNode.parentElement.parentElement;
//         originalImageNode.parentElement.style.height = originalImageNode.height + "px";
//         originalImageNode.parentElement.parentElement.style.height = originalImageNode.height + "px";
//         originalImageNode.style.setProperty("top", 0);
//         if (logoContentParent.parentElement && logoContentParent.parentElement.id.includes("placeHolderParent")) {
//             logoContentParent.parentElement.style.height = originalImageNode.height + "px";
//             logoContentParent.parentElement.style.minHeight = originalImageNode.height + "px";
//         }
//     }
// };

SpecialGraphicsUtils.prototype.isOldAssets = function (instance = null, parentElement = null) {
    try {
        let name = instance.sgParent.parentElement.parentElement.dataset.prototypename;
        if (
            name == "Cta" ||
            name == "Coverpage" ||
            name == "Quote" ||
            name == "BoldQuote" ||
            name == "BoldSectiontitle" ||
            name == "BoldCoverPage" ||
            name == "BoldCta" ||
            name == "DeviceImageStack" ||
            name == "OverlayTextStack" ||
            name == "Fancyslide" ||
            name == "OrigamiTextStack" ||
            name == "FramesTextStack" ||
            name == "FramesImageStack" ||
            name == "MultipleImageStack" ||
            name == "MultipleImageStack2"
        )
            return true;
    } catch (error) {}
    try {
        let name = parentElement.parentElement.parentElement.dataset.prototypename;
        if (
            name == "Cta" ||
            name == "Coverpage" ||
            name == "Sectiontitle" ||
            name == "Quote" ||
            name == "BoldQuote" ||
            name == "BoldSectiontitle" ||
            name == "BoldCoverPage" ||
            name == "BoldCta" ||
            name == "DeviceImageStack" ||
            name == "OverlayTextStack" ||
            name == "Fancyslide" ||
            name == "OrigamiTextStack" ||
            name == "FramesTextStack" ||
            name == "FramesImageStack" ||
            name == "MultipleImageStack" ||
            name == "MultipleImageStack2"
        )
            return true;
    } catch (error) {}
    return false;
};

//Call Font fit initially for font fit
SpecialGraphicsUtils.prototype.doFontFitForCss = function (element, parentElement, secondaryElement = null, textElementPositioning = null, instance = null, clearData = false) {
    if (element && element.hasAttribute("user-font-size")) return;
    // if (element && element.hasAttribute("herotext") && element.getAttribute("herotext") == "true") return;

    if (element.hasAttribute("data-fontfit") && element.getAttribute("data-fontfit") == "false") {
        this.doCheckMaxHeight(element, parentElement, instance);
        return;
    }
    if (element.commonheightfit) return;
    if (element.contactnodesheightfit) return;
    if (element.socialheightfit) return;

    let isHeroText = element.hasAttribute("herotext") && element.getAttribute("herotext") == "true" ? true : false;
    if (isHeroText == false && this.isOldAssets(instance, parentElement) == false && (element.id.includes("sgTitleNode") || element.id.includes("sgTitleLabelNode") || element.id.includes("sgSubTitleNode"))) return;
    let defaultsize = parseFloat(element.getAttribute("defaultsize"));
    let minfontsize = element.hasAttribute("minfontsize") ? element.getAttribute("minfontsize") : 4;
    if (clearData == true && element) {
        element.style.removeProperty("min-height");
        element.style.removeProperty("max-height");
        element.style.removeProperty("font-size");
    }
    this.adjustFontSize(parentElement, element, defaultsize - minfontsize, defaultsize, secondaryElement, textElementPositioning, instance);
};

// Font fit Logic
SpecialGraphicsUtils.prototype.adjustFontSize = function (parentElement, nodeTextElement, intMinFontSize, intMaxFontSize, secondaryElement = null, textElementPositioning = null, instance = null) {
    if (nodeTextElement && nodeTextElement.hasAttribute("user-font-size")) return;
    if (isNaN(intMinFontSize) || isNaN(intMaxFontSize)) return;
    // let isFontChanged = false;
    if (nodeTextElement) {
        nodeTextElement.style.wordBreak = "break-word";
        const cssValue = window.getComputedStyle(nodeTextElement);
        let intFontSize = this.getPixelValueFromPercentage(cssValue["font-size"], intMaxFontSize);
        let numScrollH = nodeTextElement.scrollHeight;
        let numClientH = nodeTextElement.clientHeight;
        if (nodeTextElement.hasAttribute("rotatednode")) {
            numScrollH = nodeTextElement.scrollWidth;
            numClientH = nodeTextElement.clientWidth;
        }
        if (numClientH == numScrollH) {
            while (numScrollH <= numClientH) {
                intFontSize += 1;
                if (intFontSize > intMaxFontSize) break;
                // isFontChanged = true;
                nodeTextElement.style.setProperty("font-size", intFontSize + "px", "important");
                if (secondaryElement) secondaryElement.style.setProperty("font-size", intFontSize + "px", "important");
                numScrollH = nodeTextElement.scrollHeight;
                numClientH = nodeTextElement.clientHeight;
                if (nodeTextElement.hasAttribute("rotatednode")) {
                    numScrollH = nodeTextElement.scrollWidth;
                    numClientH = nodeTextElement.clientWidth;
                }
            }
        }
        if (numClientH < numScrollH) {
            while (numScrollH > numClientH) {
                intFontSize -= 1;
                if (intFontSize < intMinFontSize) break;
                // isFontChanged = true;
                nodeTextElement.style.setProperty("font-size", intFontSize + "px", "important");
                if (secondaryElement) secondaryElement.style.setProperty("font-size", intFontSize + "px", "important");
                numScrollH = nodeTextElement.scrollHeight;
                numClientH = nodeTextElement.clientHeight;
                if (nodeTextElement.hasAttribute("rotatednode")) {
                    numScrollH = nodeTextElement.scrollWidth;
                    numClientH = nodeTextElement.clientWidth;
                }
            }
        }
    }
    if (nodeTextElement.id == "sgTitleNode" || nodeTextElement.id == "sgSubTitleNode" || nodeTextElement.id == "sgTitleLabelNode") textElementPositioning ? textElementPositioning(instance) : "";
    this.doCheckMaxHeight(nodeTextElement, parentElement, instance);
};

//Using for getting font size from element - used in font fit logic
SpecialGraphicsUtils.prototype.getPixelValueFromPercentage = function (strInput, numDefaultValue) {
    if (strInput && strInput != "") {
        if (strInput.indexOf("px") != -1) {
            return Number(strInput.split("px")[0]);
        } else if (strInput.indexOf("%") != -1) {
            const numPercentage = Number(strInput.split("%")[0]);
            if (!isNaN(numPercentage)) {
                const numPerPixel = (this.slideHeight * 1 * numPercentage) / 100;
                return numPerPixel;
            }
        }
    }
    return numDefaultValue;
};

//Check and set max height font fit. Line cut will be fixed on this method
SpecialGraphicsUtils.prototype.doCheckMaxHeight = function (element, commonClassParent, instance, doMaxHeightCheck = true) {
    if (element && (element.tagName.toLowerCase() == "li" || element.tagName.toLowerCase() == "ul")) {
        if (element.parentElement && element.parentElement.tagName.toLowerCase() == "div") element = element.parentElement;
        else if (element.parentElement.parentElement && element.parentElement.parentElement.tagName.toLowerCase() == "div") element = element.parentElement.parentElement;
    }
    let elementStyle = window.getComputedStyle(element);
    let lineHeight = parseFloat(elementStyle["line-height"]);
    lineHeight = isNaN(lineHeight) ? "40" : lineHeight;
    // let fontsize = window.getComputedStyle(element).fontSize;
    // lineHeight = parseFloat(fontsize) * 1.5;
    const numMinH = Math.ceil(lineHeight) + 2;

    if (
        element.id.includes("sgPresentedByNode") ||
        element.id.includes("sgCtaButtonNode") ||
        element.id.includes("ctaButtonParent") ||
        element.id.includes("sgVenueTitleNode") ||
        element.id.includes("sgWebsiteLinkNode") ||
        element.id.includes("sgAuthorTitleNode") ||
        element.id.includes("sgDateTitleNode") ||
        element.id.includes("sgPresentedToNode") ||
        element.id.includes("sgPresenterCompanyNode") ||
        element.id.includes("sgCustomerCompanyNode")
    ) {
        element.style.setProperty("min-height", numMinH + "px");
        let elementPadding = this.getPadding(element);
        let borderWidth = parseFloat(elementStyle.borderWidth);
        let mh = parseFloat(numMinH) - 2 + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + borderWidth * 2;
        element.style.setProperty("max-height", mh + "px");
        return;
    }
    if (element.id.includes("sgSpeaker") || element.hasAttribute("data-agendaindex")) return;
    if (element.commonheightfit) return;
    if (element.contactnodesheightfit) return;
    if (element.socialheightfit) return;

    let checkHeight = true;
    if (element.hasAttribute("data-fontfit") && element.getAttribute("data-fontfit") == "false") checkHeight = false;
    if (!element.style.minHeight) element.style.setProperty("min-height", numMinH + "px");
    if ((this.isOldAssets(instance, commonClassParent) == false && element.id == "sgTitleLabelNode") || checkHeight == false) {
        let elementPadding = this.getPadding(element);
        let newMaxH = numMinH - 2 + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom);
        element.style.setProperty("min-height", newMaxH + "px");
        element.style.setProperty("max-height", newMaxH + "px");
        element.parentElement.style.removeProperty("min-height");
        element.parentElement.style.removeProperty("max-height");
    }
    if (checkHeight == false) return;
    let isHeroText = element.hasAttribute("herotext") && element.getAttribute("herotext") == "true" ? true : false;
    if (isHeroText == false && this.isOldAssets(instance, commonClassParent) == false && (element.id == "sgTitleLabelNode" || element.id == "sgTitleNode" || element.id == "sgSubTitleNode")) {
        element.style.setProperty("min-height", numMinH + "px");
        return;
    }
    let numLineCount = 1;
    if (commonClassParent) {
        let assetType = this.slideType;
        let elementCustomMapping = element.hasAttribute("ImagestackPosition") ? element.getAttribute("ImagestackPosition") : "imagestack";
        assetType = assetType == "imagestack" || assetType == "textstack" || ((assetType == "coverpage" || assetType == "quote") && element.hasAttribute("ImagestackPosition")) ? elementCustomMapping : assetType;
        let assetNameIn = element.dataset.cssslide ? element.dataset.cssslide.replace("slide0", "") : "";
        if (assetNameIn && (assetNameIn == "title" || assetNameIn == "authordesignation" || assetNameIn == "quotetakeaway" || assetNameIn == "authorname") && element.hasAttribute("increaseHeight")) {
            assetNameIn = "title" + element.getAttribute("increaseHeight");
        }
        if (element.hasAttribute("maxlinemapping")) assetType = element.getAttribute("maxlinemapping");
        if (assetType) {
            let jsonItem = this.fontSizeJSON[assetType];
            if ((this.slideType == "imagestack" || this.slideType == "textstack") && assetNameIn == "titleNoSubtitleTitleLabel") assetNameIn = "titleNoSubtitle";
            if (jsonItem && jsonItem[assetNameIn]) numLineCount = jsonItem[assetNameIn];
            if (element.id.includes("sgmailingAddress") && assetNameIn == "venue") numLineCount = 1;
        }
    }
    if (numLineCount > 0) {
        if (element && element.hasAttribute("data-linecount")) numLineCount = parseFloat(element.getAttribute("data-linecount"));
        numLineCount = numLineCount < 1 ? 1 : numLineCount;
        numLineCount = numLineCount + 0.05;
        let numMaxRequiredH = Math.ceil(lineHeight * numLineCount);

        let min = parseInt(element.style.minHeight);
        let elementPadding = this.getPadding(element);
        let newMaxH = numMaxRequiredH + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom);

        if (element.hasAttribute("rotatednode")) element.style.setProperty("max-width", newMaxH + "px");
        else element.style.setProperty("max-height", newMaxH + "px");

        if (isNaN(min) == false && newMaxH < min) element.style.removeProperty("min-height");
    }
};

SpecialGraphicsUtils.prototype.checkTitleVisibility = function (mainParent) {
    if (mainParent.querySelector("[id='sgTitleNode']")) {
        let isSpecialQuote = false;
        if (mainParent.querySelector("[id='sgTitleNode']") && mainParent.querySelector("[id='sgTitleNode']").hasAttribute("increaseHeight")) isSpecialQuote = mainParent.querySelector("[id='sgTitleNode']").getAttribute("increaseHeight").includes("AuthorTypeTitle") ? true : false;
        if (isSpecialQuote == false && mainParent.querySelector("[id='sgTitleNode']")) mainParent.querySelector("[id='sgTitleNode']").setAttribute("increaseHeight", "");
        if (isSpecialQuote == false && mainParent.querySelector("[id='sgSubTitleNode']") && mainParent.querySelector("[id='sgSubTitleNode']").style.display == "none") {
            mainParent.querySelector("[id='sgTitleNode']").setAttribute("increaseHeight", "NoSubtitle");
        }
        if (isSpecialQuote == false && mainParent.querySelector("[id='sgTitleLabelNode']") && mainParent.querySelector("[id='sgTitleLabelNode']").style.display == "none") {
            mainParent.querySelector("[id='sgTitleNode']").setAttribute("increaseHeight", "NoTitleLabel");
        }
        if (isSpecialQuote == false && mainParent.querySelector("[id='sgTitleLabelNode']") && mainParent.querySelector("[id='sgTitleLabelNode']").style.display == "none" && mainParent.querySelector("[id='sgSubTitleNode']") && mainParent.querySelector("[id='sgSubTitleNode']").style.display == "none") {
            mainParent.querySelector("[id='sgTitleNode']").setAttribute("increaseHeight", "NoSubtitleTitleLabel");
        }
    }
};

//Setting option from floater
SpecialGraphicsUtils.prototype.changeVariation = function (mainParent, slideDomContentGroup, currentIndex = -1) {
    if (mainParent == null || mainParent == undefined) return;
    let nodeIndex = slideDomContentGroup.getElementsByTagName("title").length > 1 ? 1 : 0;
    let nodeData = slideDomContentGroup.getElementsByTagName("title")[nodeIndex];
    let animationDiv = mainParent.parentElement && mainParent.parentElement.parentElement && mainParent.parentElement.parentElement.parentElement ? mainParent.parentElement.parentElement.parentElement : null;
    if (mainParent.parentElement && mainParent.parentElement.parentElement && mainParent.parentElement.parentElement.id.includes("animationDIV")) animationDiv = mainParent.parentElement.parentElement;
    let finalHide = animationDiv?.hasAttribute("data-ogdata-finalhide_" + currentIndex) ? animationDiv?.getAttribute("data-ogdata-finalhide_" + currentIndex) : animationDiv?.getAttribute("data-ogdata-finalhide");
    let isTitlteOff = finalHide?.split(",")?.includes("tit") ? true : false;
    let isIntroParent = mainParent && mainParent.id.includes("assetParent0") ? true : false;
    if (isIntroParent == false && !!mainParent.querySelector("[id*='sgTitleNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id*='sgTitleNode']").style.display = "none";
    } else if (!!mainParent.querySelector("[id*='sgTitleNode']")) {
        var display = mainParent.querySelector("[id*='sgTitleNode']").hasAttribute("display") ? mainParent.querySelector("[id*='sgTitleNode']").getAttribute("display") : "";
        mainParent.querySelector("[id*='sgTitleNode']").style.display = display;
    }
    // nodeData = slideDomContentGroup.getElementsByTagName("titlelabel")[nodeIndex];
    nodeData = slideDomContentGroup.getElementsByTagName("titlelabel")[currentIndex >= 0 ? currentIndex : nodeIndex];
    if (!!mainParent.querySelector("[id*='sgTitleLabelNode']") && (isTitlteOff || (nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true"))) {
        mainParent.querySelector("[id*='sgTitleLabelNode']").style.display = "none";
        if (mainParent.querySelector("[id*='titleLabelTextParent']")) mainParent.querySelector("[id*='titleLabelTextParent']").style.display = "none";
    } else if (!!mainParent.querySelector("[id*='sgTitleLabelNode']")) {
        if (isTitlteOff == false || (isTitlteOff && isIntroParent)) {
            var display = mainParent.querySelector("[id*='sgTitleLabelNode']").hasAttribute("display") ? mainParent.querySelector("[id*='sgTitleLabelNode']").getAttribute("display") : "";
            mainParent.querySelector("[id*='sgTitleLabelNode']").style.display = display;
            if (mainParent.querySelector("[id*='titleLabelTextParent']")) mainParent.querySelector("[id*='titleLabelTextParent']").style.display = display;
        }
    }
    // nodeData = slideDomContentGroup.getElementsByTagName("subtitle")[nodeIndex];
    nodeData = slideDomContentGroup.getElementsByTagName("subtitle")[currentIndex >= 0 ? currentIndex : nodeIndex];
    if (!!mainParent.querySelector("[id*='sgSubTitleNode']") && (isTitlteOff || (nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true"))) {
        mainParent.querySelector("[id*='sgSubTitleNode']").style.display = "none";
        if (mainParent.querySelector("[id*='subTitleTextParent']")) mainParent.querySelector("[id*='subTitleTextParent']").style.display = "none";
    } else if (!!mainParent.querySelector("[id*='sgSubTitleNode']")) {
        if (isTitlteOff == false || (isTitlteOff && isIntroParent)) {
            var display = mainParent.querySelector("[id*='sgSubTitleNode']").hasAttribute("display") ? mainParent.querySelector("[id*='sgSubTitleNode']").getAttribute("display") : "";
            mainParent.querySelector("[id*='sgSubTitleNode']").style.display = display;
            if (mainParent.querySelector("[id*='subTitleTextParent']")) mainParent.querySelector("[id*='subTitleTextParent']").style.display = display;
        }
    }
    nodeData = slideDomContentGroup.getElementsByTagName("venue")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgVenueParent']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgVenueParent']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgVenueParent']")) {
        var display = mainParent.querySelector("[id='sgVenueParent']").hasAttribute("display") ? mainParent.querySelector("[id='sgVenueParent']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgVenueParent']").style.display = display;
    }
    //Presenter details
    nodeData = slideDomContentGroup.getElementsByTagName("creatorname")[nodeIndex];
    let presenterParent = mainParent.querySelector("[id='presenterParent']");
    let prenameNode = mainParent.querySelector("[id='sgPresentorNameNode']");
    if (!!prenameNode && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        prenameNode.style.display = "none";
        prenameNode.parentElement.setAttribute("data-namevisibility", "none");
        prenameNode.parentElement.parentElement.setAttribute("data-namevisibility", "none");
        if (presenterParent) presenterParent.removeAttribute("data-presentorvisibility");
    } else if (!!prenameNode) {
        var display = prenameNode.hasAttribute("display") ? prenameNode.getAttribute("display") : "";
        prenameNode.style.display = display;
        prenameNode.parentElement.removeAttribute("data-namevisibility");
        prenameNode.parentElement.parentElement.removeAttribute("data-namevisibility");
        if (presenterParent) presenterParent.removeAttribute("data-presentorvisibility");
    }
    nodeData = slideDomContentGroup.getElementsByTagName("creatordesignation")[nodeIndex];
    let preDesiginationNode = mainParent.querySelector("[id='sgPresentorDesiginationNode']");
    if (!!preDesiginationNode && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        preDesiginationNode.style.display = "none";
        preDesiginationNode.parentElement.setAttribute("data-desiginationvisibility", "none");
        preDesiginationNode.parentElement.parentElement.setAttribute("data-desiginationvisibility", "none");
        if (presenterParent) presenterParent.removeAttribute("data-presentorvisibility");
    } else if (!!preDesiginationNode) {
        var display = preDesiginationNode.hasAttribute("display") ? preDesiginationNode.parentElement.getAttribute("display") : "block";
        preDesiginationNode.style.display = display;
        preDesiginationNode.parentElement.removeAttribute("data-desiginationvisibility");
        preDesiginationNode.parentElement.parentElement.removeAttribute("data-desiginationvisibility");
        if (presenterParent) presenterParent.removeAttribute("data-presentorvisibility");
    }
    if (prenameNode && preDesiginationNode && prenameNode.parentElement && preDesiginationNode.parentElement && presenterParent) {
        let preNameVisibility = prenameNode.parentElement.hasAttribute("data-namevisibility") ? prenameNode.parentElement.getAttribute("data-namevisibility") : "";
        let preDesiginationVisibility = preDesiginationNode.parentElement.hasAttribute("data-desiginationvisibility") ? preDesiginationNode.parentElement.getAttribute("data-desiginationvisibility") : "";
        if (preNameVisibility == "none" && preDesiginationVisibility == "none") {
            presenterParent.setAttribute("data-presentorvisibility", "none");
        }
    }
    nodeData = slideDomContentGroup.getElementsByTagName("creatorimage")[nodeIndex];
    let presenterImageNode = mainParent.querySelector("[id='presenterContentParent']");
    if (!!mainParent.querySelector("[id='presenterImageParent']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='presenterImageParent']").style.display = "none";
        if (mainParent.querySelector("[id='imgParentNode']")) mainParent.querySelector("[id='imgParentNode']").style.display = "none";
        if (presenterImageNode) {
            presenterImageNode.style.display = "none";
            if (presenterImageNode.parentElement) presenterImageNode.parentElement.setAttribute("data-preimg", "none");
        }
    } else if (!!mainParent.querySelector("[id='presenterImageParent']")) {
        let presenterImageParent = mainParent.querySelector("[id='presenterImageParent']");
        let imgParentNode = mainParent.querySelector("[id='imgParentNode']");
        var display = presenterImageParent.hasAttribute("display") ? presenterImageParent.getAttribute("display") : "";
        if (presenterImageNode) {
            presenterImageNode.style.display = display;
            if (presenterImageNode.parentElement) presenterImageNode.parentElement.removeAttribute("data-preimg");
        }
        presenterImageParent.style.display = display;
        if (imgParentNode) imgParentNode.style.display = display;
        let presenterImage = presenterImageParent.querySelector("[id='sgPresentorImageNode']");
        if (presenterImage && presenterImage.dataset.csstext) presenterImage.style = presenterImage.dataset.csstext;
        else if (presenterImage) this.updateImageReSize(presenterImage.getAttribute("data-width"), presenterImage.getAttribute("data-height"), presenterImage);
    }
    //Customer details
    nodeData = slideDomContentGroup.getElementsByTagName("customername")[nodeIndex];
    let customerParent = mainParent.querySelector("[id='customerParent']");
    let cusNameNode = mainParent.querySelector("[id='sgCustomerNameNode']");
    if (!!cusNameNode && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        cusNameNode.style.display = "none";
        cusNameNode.parentElement.setAttribute("data-namevisibility", "none");
        cusNameNode.parentElement.parentElement.setAttribute("data-namevisibility", "none");
        if (customerParent) customerParent.removeAttribute("data-presentorvisibility");
    } else if (!!cusNameNode) {
        var display = cusNameNode.hasAttribute("display") ? cusNameNode.getAttribute("display") : "";
        cusNameNode.style.display = display;
        cusNameNode.parentElement.removeAttribute("data-namevisibility");
        cusNameNode.parentElement.parentElement.removeAttribute("data-namevisibility");
        if (customerParent) customerParent.removeAttribute("data-presentorvisibility");
    }
    nodeData = slideDomContentGroup.getElementsByTagName("customerdesignation")[nodeIndex];
    let cusDesiginationNode = mainParent.querySelector("[id='sgCustomerDesiginationNode']");
    if (!!cusDesiginationNode && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        cusDesiginationNode.style.display = "none";
        cusDesiginationNode.parentElement.setAttribute("data-desiginationvisibility", "none");
        cusDesiginationNode.parentElement.parentElement.setAttribute("data-desiginationvisibility", "none");
        if (customerParent) customerParent.removeAttribute("data-presentorvisibility");
    } else if (!!cusDesiginationNode) {
        var display = cusDesiginationNode.hasAttribute("display") ? cusDesiginationNode.parentElement.getAttribute("display") : "block";
        cusDesiginationNode.style.display = display;
        cusDesiginationNode.parentElement.removeAttribute("data-desiginationvisibility");
        cusDesiginationNode.parentElement.parentElement.removeAttribute("data-desiginationvisibility");
        if (customerParent) customerParent.removeAttribute("data-presentorvisibility");
    }
    if (cusNameNode && cusDesiginationNode && cusNameNode.parentElement && cusDesiginationNode.parentElement && customerParent) {
        let cusNameVisibility = cusNameNode.parentElement.hasAttribute("data-namevisibility") ? cusNameNode.parentElement.getAttribute("data-namevisibility") : "";
        let cusDesiginationVisibility = cusDesiginationNode.parentElement.hasAttribute("data-desiginationvisibility") ? cusDesiginationNode.parentElement.getAttribute("data-desiginationvisibility") : "";
        if (cusNameVisibility == "none" && cusDesiginationVisibility == "none") {
            customerParent.setAttribute("data-presentorvisibility", "none");
        }
    }
    nodeData = slideDomContentGroup.getElementsByTagName("customerimage")[nodeIndex];
    let customerImageNode = mainParent.querySelector("[id='customerContentParent']");
    if (!!mainParent.querySelector("[id='customerImageParent']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='customerImageParent']").style.display = "none";
        if (customerImageNode) {
            customerImageNode.style.display = "none";
            if (customerImageNode.parentElement) customerImageNode.parentElement.setAttribute("data-preimg", "none");
        }
    } else if (!!mainParent.querySelector("[id='customerImageParent']")) {
        let customerImageParent = mainParent.querySelector("[id='customerImageParent']");
        var display = customerImageParent.hasAttribute("display") ? customerImageParent.getAttribute("display") : "";
        if (customerImageNode) {
            customerImageNode.style.display = display;
            if (customerImageNode.parentElement) customerImageNode.parentElement.removeAttribute("data-preimg");
        }
        customerImageParent.style.display = display;
        let customerImage = customerImageParent.querySelector("[id='sgPresentorImageNode']");
        if (customerImage && customerImage.dataset.csstext) customerImage.style = customerImage.dataset.csstext;
        else if (customerImage) this.updateImageReSize(customerImage.getAttribute("data-width"), customerImage.getAttribute("data-height"), customerImage);
    }
    nodeData = slideDomContentGroup.getElementsByTagName("logoimage")[nodeIndex];
    // let logoParentNode = mainParent.querySelector("[id='logoImageParent']");
    let logoParentNode = mainParent.querySelector("[id='logoGridParent']");
    if (!!logoParentNode && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        logoParentNode.style.display = "none";
        if (mainParent.querySelector("[id='logoContentParent']")) mainParent.querySelector("[id='logoContentParent']").style.display = "none";
    } else if (!!logoParentNode) {
        var display = logoParentNode.hasAttribute("display") ? logoParentNode.getAttribute("display") : "";
        logoParentNode.style.display = display;
        if (mainParent.querySelector("[id='logoContentParent']")) mainParent.querySelector("[id='logoContentParent']").style.display = display;
    }
    nodeData = slideDomContentGroup.getElementsByTagName("customerlogoimage")[nodeIndex];
    if (!!mainParent.querySelector("[id='customerLogoImageParent']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='customerLogoImageParent']").style.display = "none";
        if (mainParent.querySelector("[id='customerLogoContentParent']")) mainParent.querySelector("[id='customerLogoContentParent']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='customerLogoImageParent']")) {
        var display = mainParent.querySelector("[id='customerLogoImageParent']").hasAttribute("display") ? mainParent.querySelector("[id='customerLogoImageParent']").getAttribute("display") : "";
        mainParent.querySelector("[id='customerLogoImageParent']").style.display = display;
        if (mainParent.querySelector("[id='customerLogoContentParent']")) mainParent.querySelector("[id='customerLogoContentParent']").style.display = display;
    }
    nodeData = slideDomContentGroup.getElementsByTagName("presenterlogoimage")[nodeIndex];
    if (!!mainParent.querySelector("[id='presenterLogoImageParent']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='presenterLogoImageParent']").style.display = "none";
        if (mainParent.querySelector("[id='presenterLogoContentParent']")) mainParent.querySelector("[id='presenterLogoContentParent']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='presenterLogoImageParent']")) {
        var display = mainParent.querySelector("[id='presenterLogoImageParent']").hasAttribute("display") ? mainParent.querySelector("[id='presenterLogoImageParent']").getAttribute("display") : "";
        mainParent.querySelector("[id='presenterLogoImageParent']").style.display = display;
        if (mainParent.querySelector("[id='presenterLogoContentParent']")) mainParent.querySelector("[id='presenterLogoContentParent']").style.display = display;
    }
    nodeData = slideDomContentGroup.getElementsByTagName("coverimage")[nodeIndex];
    let deviceParentNode = mainParent.querySelector("[id='deviceContainerNode']");
    if (!!mainParent.querySelector("[id='coverImageParent']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='coverImageParent']").style.display = "none";
        if (deviceParentNode) deviceParentNode.style.display = "none";
    } else if (!!mainParent.querySelector("[id='coverImageParent']")) {
        var display = mainParent.querySelector("[id='coverImageParent']").hasAttribute("display") ? mainParent.querySelector("[id='coverImageParent']").getAttribute("display") : "";
        mainParent.querySelector("[id='coverImageParent']").style.display = display;
        if (deviceParentNode) deviceParentNode.style.display = display;
    }
    nodeData = slideDomContentGroup.getElementsByTagName("creatorphone")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgPresentorPhoneNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgPresentorPhoneNode']").parentElement.style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgPresentorPhoneNode']")) {
        var display = mainParent.querySelector("[id='sgPresentorPhoneNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgPresentorPhoneNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgPresentorPhoneNode']").parentElement.style.display = display;
    }
    nodeData = slideDomContentGroup.getElementsByTagName("creatorwebsite")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgPresentorWebsiteNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgPresentorWebsiteNode']").parentElement.style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgPresentorWebsiteNode']")) {
        var display = mainParent.querySelector("[id='sgPresentorWebsiteNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgPresentorWebsiteNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgPresentorWebsiteNode']").parentElement.style.display = display;
    }
    nodeData = slideDomContentGroup.getElementsByTagName("creatoremail")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgPresentorEmailNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgPresentorEmailNode']").parentElement.style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgPresentorEmailNode']")) {
        var display = mainParent.querySelector("[id='sgPresentorEmailNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgPresentorEmailNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgPresentorEmailNode']").parentElement.style.display = display;
    }
    nodeData = slideDomContentGroup.getElementsByTagName("creatorfacebook")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgPresentorFacebookNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgPresentorFacebookNode']").parentElement.style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgPresentorFacebookNode']")) {
        var display = mainParent.querySelector("[id='sgPresentorFacebookNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgPresentorFacebookNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgPresentorFacebookNode']").parentElement.style.display = display;
    }
    nodeData = slideDomContentGroup.getElementsByTagName("creatortwitter")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgPresentorTwitterNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgPresentorTwitterNode']").parentElement.style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgPresentorTwitterNode']")) {
        var display = mainParent.querySelector("[id='sgPresentorTwitterNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgPresentorTwitterNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgPresentorTwitterNode']").parentElement.style.display = display;
    }
    nodeData = slideDomContentGroup.getElementsByTagName("creatorinstagram")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgPresentorInstagramNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgPresentorInstagramNode']").parentElement.style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgPresentorInstagramNode']")) {
        var display = mainParent.querySelector("[id='sgPresentorInstagramNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgPresentorInstagramNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgPresentorInstagramNode']").parentElement.style.display = display;
    }
    nodeData = slideDomContentGroup.getElementsByTagName("creatorlinkedin")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgPresentorLinkedinNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgPresentorLinkedinNode']").parentElement.style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgPresentorLinkedinNode']")) {
        var display = mainParent.querySelector("[id='sgPresentorLinkedinNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgPresentorLinkedinNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgPresentorLinkedinNode']").parentElement.style.display = display;
    }
    nodeData = slideDomContentGroup.getElementsByTagName("creatorskype")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgPresentorSkypeNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgPresentorSkypeNode']").parentElement.style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgPresentorSkypeNode']")) {
        var display = mainParent.querySelector("[id='sgPresentorSkypeNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgPresentorSkypeNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgPresentorSkypeNode']").parentElement.style.display = display;
    }
    nodeData = slideDomContentGroup.getElementsByTagName("numbertext")[nodeIndex];
    if (!!mainParent.querySelector("[id*='sgNumberTextNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id*='sgNumberTextNode']").style.display = "none";
        if (mainParent.querySelector("[id*='sgNumberTextParent']")) mainParent.querySelector("[id*='sgNumberTextParent']").style.display = "none";
    } else if (!!mainParent.querySelector("[id*='sgNumberTextNode']")) {
        var display = mainParent.querySelector("[id*='sgNumberTextNode']").hasAttribute("display") ? mainParent.querySelector("[id*='sgNumberTextNode']").getAttribute("display") : "";
        mainParent.querySelector("[id*='sgNumberTextNode']").style.display = display;
        if (mainParent.querySelector("[id*='sgNumberTextParent']")) mainParent.querySelector("[id*='sgNumberTextParent']").style.display = display;
    }

    //PRESENTOR INFO
    nodeData = slideDomContentGroup.getElementsByTagName("authorname")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgAuthorNameNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgAuthorNameNode']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgAuthorNameNode']")) {
        var display = mainParent.querySelector("[id='sgAuthorNameNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgAuthorNameNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgAuthorNameNode']").style.display = display;
    }
    nodeData = slideDomContentGroup.getElementsByTagName("authordesignation")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgAuthorDesignationNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgAuthorDesignationNode']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgAuthorDesignationNode']")) {
        var display = mainParent.querySelector("[id='sgAuthorDesignationNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgAuthorDesignationNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgAuthorDesignationNode']").style.display = display;
    }
    nodeData = slideDomContentGroup.getElementsByTagName("authorimage")[nodeIndex];
    if (!!mainParent.querySelector("[id='authorContentParent']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        let sgAuthorImageNode = mainParent.querySelector("[id='authorContentParent']");
        sgAuthorImageNode.style.display = "none";
    } else if (!!mainParent.querySelector("[id='authorContentParent']")) {
        let sgAuthorImageNode = mainParent.querySelector("[id='authorContentParent']");
        sgAuthorImageNode.style.removeProperty("display");
        if (sgAuthorImageNode && sgAuthorImageNode.dataset.csstext) sgAuthorImageNode.style = sgAuthorImageNode.dataset.csstext;
        else {
            let widthValue = window.getComputedStyle(sgAuthorImageNode.parentElement).width;
            let heightValue = window.getComputedStyle(sgAuthorImageNode.parentElement).height;
            this.updateImageReSize(widthValue, heightValue, sgAuthorImageNode);
        }
    }

    //CTA contact styles
    let totalContact = 0;
    if (mainParent.querySelector("[id='contactLine1']")) mainParent.querySelector("[id='contactLine1']").style.removeProperty("display");
    if (mainParent.querySelector("[id='contactLine2']")) mainParent.querySelector("[id='contactLine2']").style.removeProperty("display");
    if (mainParent.querySelector("[id='contactLine3']")) mainParent.querySelector("[id='contactLine3']").style.removeProperty("display");
    nodeData = slideDomContentGroup.getElementsByTagName("phone")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgphoneNumberParent']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgphoneNumberParent']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgphoneNumberParent']")) {
        var display = mainParent.querySelector("[id='sgphoneNumberParent']").hasAttribute("display") ? mainParent.querySelector("[id='sgphoneNumberParent']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgphoneNumberParent']").style.display = display;
        totalContact = totalContact + 1;
    }
    nodeData = slideDomContentGroup.getElementsByTagName("creatoremail")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgemailAddressParent']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgemailAddressParent']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgemailAddressParent']")) {
        var display = mainParent.querySelector("[id='sgemailAddressParent']").hasAttribute("display") ? mainParent.querySelector("[id='sgemailAddressParent']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgemailAddressParent']").style.display = display;
        totalContact = totalContact + 1;
    }
    nodeData = slideDomContentGroup.getElementsByTagName("venue")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgmailingAddressParent']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgmailingAddressParent']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgmailingAddressParent']")) {
        var display = mainParent.querySelector("[id='sgmailingAddressParent']").hasAttribute("display") ? mainParent.querySelector("[id='sgmailingAddressParent']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgmailingAddressParent']").style.display = display;
        totalContact = totalContact + 1;
    }
    nodeData = slideDomContentGroup.getElementsByTagName("website")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgwebsiteParent']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgwebsiteParent']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgwebsiteParent']")) {
        var display = mainParent.querySelector("[id='sgwebsiteParent']").hasAttribute("display") ? mainParent.querySelector("[id='sgwebsiteParent']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgwebsiteParent']").style.display = display;
        totalContact = totalContact + 1;
    }
    if (totalContact == 1) {
        //Hide intermediate line
        if (mainParent.querySelector("[id='contactLine1']")) mainParent.querySelector("[id='contactLine1']").style.display = "none";
        if (mainParent.querySelector("[id='contactLine2']")) mainParent.querySelector("[id='contactLine2']").style.display = "none";
        if (mainParent.querySelector("[id='contactLine3']")) mainParent.querySelector("[id='contactLine3']").style.display = "none";
    }
    if (totalContact == 0 && mainParent.querySelector("[id='contactParent']")) mainParent.querySelector("[id='contactParent']").style.display = "none";
    else if (mainParent.querySelector("[id='contactParent']")) mainParent.querySelector("[id='contactParent']").style.removeProperty("display");

    if (mainParent.querySelector("[id='contactParent']")) mainParent.querySelector("[id='contactParent']").setAttribute("data-visibilitycount", totalContact);

    let emailParent = mainParent.querySelector("[id='sgemailAddressParent']");
    let phoneParent = mainParent.querySelector("[id='sgphoneNumberParent']");
    let websiteParent = mainParent.querySelector("[id='sgwebsiteParent']");
    if (websiteParent && websiteParent.style.display == "none") {
        if (phoneParent && phoneParent.style.display != "none" && phoneParent.querySelector("[id*='contactLine']")) phoneParent.querySelector("[id*='contactLine']").style.display = "none";
        else if (emailParent && emailParent.style.display != "none" && emailParent.querySelector("[id*='contactLine']")) emailParent.querySelector("[id*='contactLine']").style.display = "none";
    }

    //Cover number
    nodeData = slideDomContentGroup.getElementsByTagName("covernumber")[nodeIndex];
    if (!!mainParent.querySelector("[id='covernumber']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='covernumber']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='covernumber']")) {
        var display = mainParent.querySelector("[id='covernumber']").hasAttribute("display") ? mainParent.querySelector("[id='covernumber']").getAttribute("display") : "";
        mainParent.querySelector("[id='covernumber']").style.display = display;
    }

    //Quote icon
    nodeData = slideDomContentGroup.getElementsByTagName("quoteicon")[nodeIndex];
    let quoteIcon = mainParent.querySelector("[id*='quoteicon']") ? mainParent.querySelector("[id*='quoteicon']") : mainParent.querySelector("[id*='quoteIcon']");
    if (!!quoteIcon && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        quoteIcon.style.display = "none";
        if (quoteIcon.parentElement.id.toLowerCase().includes("quote")) quoteIcon.parentElement.style.display = "none";
    } else if (!!quoteIcon) {
        var display = quoteIcon.hasAttribute("display") ? quoteIcon.getAttribute("display") : "";
        quoteIcon.style.display = display;
        if (quoteIcon.parentElement.id.toLowerCase().includes("quote")) quoteIcon.parentElement.style.display = display;
    }
    //Quote icon2
    nodeData = slideDomContentGroup.getElementsByTagName("quoteicon2")[nodeIndex];
    let quoteIcon2 = mainParent.querySelector("[id*='quoteicon2']") ? mainParent.querySelector("[id*='quoteicon2']") : mainParent.querySelector("[id*='quoteIcon2']");
    if (!!quoteIcon2 && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        quoteIcon2.style.display = "none";
        if (quoteIcon2.parentElement.id.toLowerCase().includes("quote")) quoteIcon2.parentElement.style.display = "none";
    } else if (!!quoteIcon2) {
        var display = quoteIcon2.hasAttribute("display") ? quoteIcon2.getAttribute("display") : "";
        quoteIcon2.style.display = display;
        if (quoteIcon2.parentElement.id.toLowerCase().includes("quote")) quoteIcon2.parentElement.style.display = display;
    }
    //Quote icon3
    nodeData = slideDomContentGroup.getElementsByTagName("quoteicon3")[nodeIndex];
    let quoteIcon3 = mainParent.querySelector("[id*='quoteicon3']") ? mainParent.querySelector("[id*='quoteicon3']") : mainParent.querySelector("[id*='quoteIcon3']");
    if (!!quoteIcon3 && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        quoteIcon3.style.display = "none";
        if (quoteIcon3.parentElement.id.toLowerCase().includes("quote")) quoteIcon3.parentElement.style.display = "none";
    } else if (!!quoteIcon3) {
        var display = quoteIcon3.hasAttribute("display") ? quoteIcon3.getAttribute("display") : "";
        quoteIcon3.style.display = display;
        if (quoteIcon3.parentElement.id.toLowerCase().includes("quote")) quoteIcon3.parentElement.style.display = display;
    }
    //Quote placeholder
    nodeData = slideDomContentGroup.getElementsByTagName("quotetakeaway")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgQuoteTextAwayNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgQuoteTextAwayNode']").parentElement.style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgQuoteTextAwayNode']")) {
        var display = mainParent.querySelector("[id='sgQuoteTextAwayNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgQuoteTextAwayNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgQuoteTextAwayNode']").parentElement.style.display = display;
    }
    //Quote placeholder
    nodeData = slideDomContentGroup.getElementsByTagName("quotetitle")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgQuoteTextNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgQuoteTextNode']").parentElement.style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgQuoteTextNode']")) {
        var display = mainParent.querySelector("[id='sgQuoteTextNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgQuoteTextNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgQuoteTextNode']").parentElement.style.display = display;
    }
    //Presented to node
    nodeData = slideDomContentGroup.getElementsByTagName("presentedto")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgPresentedToNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgPresentedToNode']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgPresentedToNode']")) {
        var display = mainParent.querySelector("[id='sgPresentedToNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgPresentedToNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgPresentedToNode']").style.display = display;
    }
    //Venue title node
    nodeData = slideDomContentGroup.getElementsByTagName("venuetitle")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgVenueTitleNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgVenueTitleNode']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgVenueTitleNode']")) {
        var display = mainParent.querySelector("[id='sgVenueTitleNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgVenueTitleNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgVenueTitleNode']").style.display = display;
    }
    //Website link node
    nodeData = slideDomContentGroup.getElementsByTagName("websitelink")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgWebsiteLinkNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgWebsiteLinkNode']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgWebsiteLinkNode']")) {
        var display = mainParent.querySelector("[id='sgWebsiteLinkNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgWebsiteLinkNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgWebsiteLinkNode']").style.display = display;
    }
    //Author title node
    nodeData = slideDomContentGroup.getElementsByTagName("authortitle")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgAuthorTitleNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgAuthorTitleNode']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgAuthorTitleNode']")) {
        var display = mainParent.querySelector("[id='sgAuthorTitleNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgAuthorTitleNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgAuthorTitleNode']").style.display = display;
    }
    //Date title node
    nodeData = slideDomContentGroup.getElementsByTagName("datetitle")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgDateTitleNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgDateTitleNode']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgDateTitleNode']")) {
        var display = mainParent.querySelector("[id='sgDateTitleNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgDateTitleNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgDateTitleNode']").style.display = display;
    }
    //Presented by node
    nodeData = slideDomContentGroup.getElementsByTagName("presentedby")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgPresentedByNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgPresentedByNode']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgPresentedByNode']")) {
        var display = mainParent.querySelector("[id='sgPresentedByNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgPresentedByNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgPresentedByNode']").style.display = display;
    }
    //Presenter company node
    nodeData = slideDomContentGroup.getElementsByTagName("presentercompany")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgPresenterCompanyNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgPresenterCompanyNode']").style.display = "none";
        mainParent.querySelector("[id='sgPresenterCompanyNode']").parentElement.style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgPresenterCompanyNode']")) {
        var display = mainParent.querySelector("[id='sgPresenterCompanyNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgPresenterCompanyNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgPresenterCompanyNode']").style.display = display;
        mainParent.querySelector("[id='sgPresenterCompanyNode']").parentElement.style.display = display;
    }
    //Cta button node
    nodeData = slideDomContentGroup.getElementsByTagName("ctabutton")[currentIndex >= 0 ? currentIndex : nodeIndex];
    if (!!mainParent.querySelector("[id='ctaButtonParent']") && (isTitlteOff || (nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true"))) {
        mainParent.querySelector("[id='ctaButtonParent']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='ctaButtonParent']")) {
        var display = mainParent.querySelector("[id='ctaButtonParent']").hasAttribute("display") ? mainParent.querySelector("[id='ctaButtonParent']").getAttribute("display") : "";
        mainParent.querySelector("[id='ctaButtonParent']").style.display = display;
    }
    //Customer company node
    nodeData = slideDomContentGroup.getElementsByTagName("customercompany")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgCustomerCompanyNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgCustomerCompanyNode']").style.display = "none";
        mainParent.querySelector("[id='sgCustomerCompanyNode']").parentElement.style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgCustomerCompanyNode']")) {
        var display = mainParent.querySelector("[id='sgCustomerCompanyNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgCustomerCompanyNode']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgCustomerCompanyNode']").style.display = display;
        mainParent.querySelector("[id='sgCustomerCompanyNode']").parentElement.style.display = display;
    }
    //Footer
    nodeData = slideDomContentGroup.getElementsByTagName("sgfooter")[nodeIndex];
    if (!!mainParent.querySelector("[id='sgFooterParent']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='sgFooterParent']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='sgFooterParent']")) {
        var display = mainParent.querySelector("[id='sgFooterParent']").hasAttribute("display") ? mainParent.querySelector("[id='sgFooterParent']").getAttribute("display") : "";
        mainParent.querySelector("[id='sgFooterParent']").style.display = display;
    }
    // //Map
    // nodeData = slideDomContentGroup.getElementsByTagName("map")[nodeIndex];
    // if (!!mainParent.querySelector("[id='sgMapParentNode']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
    //     mainParent.querySelector("[id='sgMapParentNode']").style.display = "none";
    // } else if (!!mainParent.querySelector("[id='sgMapParentNode']")) {
    //     var display = mainParent.querySelector("[id='sgMapParentNode']").hasAttribute("display") ? mainParent.querySelector("[id='sgMapParentNode']").getAttribute("display") : "";
    //     mainParent.querySelector("[id='sgMapParentNode']").style.display = display;
    // }
    //Social icon prompt
    let isSocialPromptHide = finalHide?.split(",")?.includes("socialiconprompt");
    nodeData = slideDomContentGroup.getElementsByTagName("socialiconprompt")[nodeIndex];
    if (!!mainParent.querySelector("[id='ctaSocialParent']") && (isSocialPromptHide || (nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true"))) {
        mainParent.querySelector("[id='ctaSocialParent']").classList.add("sgHidePrompt");
    } else if (!!mainParent.querySelector("[id='ctaSocialParent']")) {
        mainParent.querySelector("[id='ctaSocialParent']").classList.remove("sgHidePrompt");
    }
    //Social icon
    let isSocialIconHide = finalHide?.split(",")?.includes("socialicon");
    nodeData = slideDomContentGroup.getElementsByTagName("socialicon")[nodeIndex];
    if (!!mainParent.querySelector("[id='ctaSocialParent']") && (isSocialIconHide || (nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true"))) {
        mainParent.querySelector("[id='ctaSocialParent']").classList.add("sgHideIcons");
    } else if (!!mainParent.querySelector("[id='ctaSocialParent']")) {
        mainParent.querySelector("[id='ctaSocialParent']").classList.remove("sgHideIcons");
    }
    //quote testimonial
    nodeData = slideDomContentGroup.getElementsByTagName("rating")[nodeIndex];
    if (!!mainParent.querySelector("[id='quoteTestimonialParent']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id='quoteTestimonialParent']").style.display = "none";
    } else if (!!mainParent.querySelector("[id='quoteTestimonialParent']")) {
        var display = mainParent.querySelector("[id='quoteTestimonialParent']").hasAttribute("display") ? mainParent.querySelector("[id='quoteTestimonialParent']").getAttribute("display") : "";
        mainParent.querySelector("[id='quoteTestimonialParent']").style.display = display;
    }
    // Custom Social links
    let socialCount = 5;
    let hideCtaSocialNodes = "";
    for (let i = 1; i < 6; i++) {
        nodeData = slideDomContentGroup.getElementsByTagName("customsociallink" + i)[nodeIndex];
        let ids = "[id='sgCustomSocialLink" + i + "']";
        if (!!mainParent.querySelector(ids) && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
            mainParent.querySelector(ids).style.display = "none";
            socialCount = socialCount - 1;
            hideCtaSocialNodes = hideCtaSocialNodes + (hideCtaSocialNodes == "" ? "" : ",") + i;
        } else if (!!mainParent.querySelector(ids)) {
            var display = mainParent.querySelector(ids).hasAttribute("display") ? mainParent.querySelector(ids).getAttribute("display") : "";
            mainParent.querySelector(ids).style.display = display;
        }
    }

    let customLinkIconParent = mainParent.querySelector("[id='customLinkIconParent']");
    if (customLinkIconParent) {
        //Enable/disable social lines depends on node visiblity
        for (let i = 1; i <= 4; i++) {
            let socialLine = mainParent.querySelector("[id='socialLine" + i + "']");
            if (socialLine) socialLine.style.removeProperty("display");
        }
        let twitterParent = mainParent.querySelector("[id='sgCustomSocialLink2']");
        let fbParent = mainParent.querySelector("[id='sgCustomSocialLink3']");
        let instaParent = mainParent.querySelector("[id='sgCustomSocialLink4']");
        let skypeParent = mainParent.querySelector("[id='sgCustomSocialLink5']");
        if (skypeParent && skypeParent.style.display == "none") {
            if (instaParent && instaParent.style.display != "none" && instaParent.querySelector("[id*='socialLine']")) instaParent.querySelector("[id*='socialLine']").style.display = "none";
            else if (fbParent && fbParent.style.display != "none" && fbParent.querySelector("[id*='socialLine']")) fbParent.querySelector("[id*='socialLine']").style.display = "none";
            else if (twitterParent && twitterParent.style.display != "none" && twitterParent.querySelector("[id*='socialLine']")) twitterParent.querySelector("[id*='socialLine']").style.display = "none";
        }
        // if only one node is there we set all social lines visibility hidden.
        if (socialCount == 1) {
            for (let i = 1; i < 4; i++) {
                let socialLine = mainParent.querySelector("[id='socialLine" + i + "']");
                if (socialLine) socialLine.style.display = "none";
            }
        }
        // if all nodes are not visible we set parent display as none.so other nodes will take this area also.
        if (socialCount == 0) customLinkIconParent.style.display = "none";
        else customLinkIconParent.style.removeProperty("display");
    }

    if (mainParent.querySelectorAll("[id*='speakerNodeGroup']").length > 0) {
        // Speaker Nodes
        for (let i = 0; i < 4; i++) {
            nodeData = slideDomContentGroup.getElementsByTagName("speakersecondary")[nodeIndex];
            let secondaryNode = mainParent.querySelector("[id='sgSpeakerSecondary" + (i + 1) + "']");
            let imageNode = mainParent.querySelector("[id='speakerContentParent" + (i + 1) + "']");
            let isSpeakerSecondaryHide = finalHide?.split(",")?.includes("speakersecondary");
            if (!!secondaryNode && (isSpeakerSecondaryHide || (nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true"))) secondaryNode.style.display = "none";
            else if (!!secondaryNode) secondaryNode.style.display = secondaryNode.hasAttribute("display") ? secondaryNode.getAttribute("display") : "";

            nodeData = slideDomContentGroup.getElementsByTagName("speakerimage")[nodeIndex];
            let isSpeakerImageHide = finalHide?.split(",")?.includes("speakerimage");
            if (!!imageNode && (isSpeakerImageHide || (nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true"))) imageNode.style.display = "none";
            else if (!!imageNode) imageNode.style.display = imageNode.hasAttribute("display") ? imageNode.getAttribute("display") : "";
        }
    }
    // Custom Reference links
    let totalReference = 4;
    for (let i = 0; i < 5; i++) {
        nodeData = slideDomContentGroup.getElementsByTagName("reference" + (i + 1))[nodeIndex];
        let ids = "[id='sgreferenceLink" + (i + 1) + "Parent']";
        if (!!mainParent.querySelector(ids) && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
            mainParent.querySelector(ids).style.display = "none";
            totalReference = totalReference - 1;
            if (i == 3 && mainParent.querySelector("[id='referenceLine3']")) mainParent.querySelector("[id='referenceLine3']").style.display = "none";
        } else if (!!mainParent.querySelector(ids)) {
            var display = mainParent.querySelector(ids).hasAttribute("display") ? mainParent.querySelector(ids).getAttribute("display") : "";
            mainParent.querySelector(ids).style.display = display;
        }
    }
    for (let i = 1; i < 4; i++) {
        let referenceLine = mainParent.querySelector("[id='referenceLine" + i + "']");
        if (referenceLine) referenceLine.style.removeProperty("display");
    }
    let ref2 = mainParent.querySelector("[id='sgreferenceLink2Parent']");
    let ref3 = mainParent.querySelector("[id='sgreferenceLink3Parent']");
    let ref4 = mainParent.querySelector("[id='sgreferenceLink4Parent']");
    if (ref4 && ref4.style.display == "none") {
        if (ref3 && ref3.style.display != "none" && ref3.querySelector("[id*='referenceLine']")) ref3.querySelector("[id*='referenceLine']").style.display = "none";
        else if (ref2 && ref2.style.display != "none" && ref2.querySelector("[id*='referenceLine']")) ref2.querySelector("[id*='referenceLine']").style.display = "none";
    }
    if (totalReference == 1) {
        for (let i = 1; i < 4; i++) {
            let referenceLine = mainParent.querySelector("[id='referenceLine" + i + "']");
            if (referenceLine) referenceLine.style.display = "none";
        }
    }
    if (totalReference == 0 && mainParent.querySelector("[id='referenceParent']")) mainParent.querySelector("[id='referenceParent']").style.display = "none";
    else if (mainParent.querySelector("[id='referenceParent']")) mainParent.querySelector("[id='referenceParent']").style.removeProperty("display");

    //Check title node visibility and hide textbase also
    let textBaseParentNode = mainParent.querySelector("[id*='textBaseParentNode']");
    let titleNode = textBaseParentNode ? textBaseParentNode.querySelector("[id='sgTitleNode']") : null;
    let titleLabelNode = textBaseParentNode ? textBaseParentNode.querySelector("[id='sgTitleLabelNode']") : null;
    let subtitleNode = textBaseParentNode ? textBaseParentNode.querySelector("[id='sgSubTitleNode']") : null;
    let sgNumberTextParent = textBaseParentNode ? textBaseParentNode.querySelector("[id='sgNumberTextParent']") : null;

    if ((!sgNumberTextParent || (sgNumberTextParent && sgNumberTextParent.style.display == "none")) && textBaseParentNode && titleNode && titleNode.style.display == "none" && titleLabelNode && titleLabelNode.style.display == "none" && subtitleNode && subtitleNode.style.display == "none") {
        textBaseParentNode.style.display = "none";
    } else if (textBaseParentNode) textBaseParentNode.style.display = "flex";

    //placeholder image for textstack and imagestack
    nodeData = slideDomContentGroup.getElementsByTagName("placeholderimage")[currentIndex >= 0 ? currentIndex : nodeIndex];
    if (!!mainParent.querySelector("[id*='placeHolderParent']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        mainParent.querySelector("[id*='placeHolderParent']").style.display = "none";
        // nodeData.removeAttribute("data-isvisible");
    } else if (nodeData && !!mainParent.querySelector("[id*='placeHolderParent']")) {
        var display = mainParent.querySelector("[id*='placeHolderParent']").hasAttribute("display") ? mainParent.querySelector("[id*='placeHolderParent']").getAttribute("display") : "";
        mainParent.querySelector("[id*='placeHolderParent']").style.display = display;
        // nodeData.removeAttribute("data-isvisible");
    }

    this.checkSingleNodeParent(mainParent, "logoContentParent");
    this.checkSingleNodeParent(mainParent, "logoGridParent");
    this.checkSingleNodeParent(mainParent, "customerLogoContentParent");
    this.checkSingleNodeParent(mainParent, "presenterLogoContentParent");
    this.checkSingleNodeParent(mainParent, "sgVenueParent");
    this.checkSingleNodeParent(mainParent, "covernumber");
    this.checkSingleNodeParent(mainParent, "sgNumberTextParent");
    this.checkSingleNodeParent(mainParent, "sgAuthorTitleNode");
    this.checkSingleNodeParent(mainParent, "sgDateTitleNode");
    this.checkSingleNodeParent(mainParent, "sgVenueTitleNode");
    this.checkSingleNodeParent(mainParent, "sgWebsiteLinkNode");
    this.checkSingleNodeParent(mainParent, "coverImageParent");
    this.checkSingleNodeParent(mainParent, "referenceParent");
    this.checkSingleNodeParent(mainParent, "contactParent");
    this.checkSingleNodeParent(mainParent, "customLinkIconParent");
    this.checkSingleNodeParent(mainParent, "sgMapParentNode");
    this.checkSingleNodeParent(mainParent, "sgPresenterCompanyNode");

    this.checkTitleVisibility(mainParent);
    if (mainParent && mainParent.hasAttribute("data-slidetype") && mainParent.getAttribute("data-slidetype") == "cta") this.checkPresenterDataCta(mainParent);
    let isAlonePresenter = false;
    let isAloneCustomer = false;
    if (mainParent && mainParent.hasAttribute("data-slidetype") && mainParent.getAttribute("data-slidetype") == "coverpage") {
        isAlonePresenter = this.checkPresenterData(mainParent);
        isAloneCustomer = this.checkCustomerData(mainParent);
    }
    this.checkAuthorData(mainParent);
    this.checkSingleNodeParent(mainParent, "sgAuthorNameNode");
    this.checkSingleNodeParent(mainParent, "sgFooterParent");
    if (isAlonePresenter) {
        this.checkSingleNodeParent(mainParent, "presenterParent");
        this.checkSingleNodeParent(mainParent, "presenterContentParent");
    } else this.checkSingleNodeParent(mainParent, "presenterParent");

    if (isAloneCustomer) {
        this.checkSingleNodeParent(mainParent, "customerParent");
        this.checkSingleNodeParent(mainParent, "customerContentParent");
    }
};

SpecialGraphicsUtils.prototype.checkSingleNodeParent = function (mainParent, elementId) {
    let element = mainParent.querySelector("[id='" + elementId + "']");
    if (element && element.parentElement && element.parentElement.children.length == 1 && !element.parentElement.id.includes("placeHolderParent")) {
        let display = element.style.display;
        element.parentElement.style.display = display != "none" ? "flex" : element.style.display;
    } else if (element && element.parentElement && element.parentElement.children.length >= 1 && !element.parentElement.id.includes("placeHolderParent")) {
        let hideCount = 0;
        for (let a = 0; a < element.parentElement.children.length; a++) {
            let innerChild = element.parentElement.children[a];
            if (innerChild.style.display == "none" || window.getComputedStyle(innerChild).display == "none") hideCount++;
        }
        if (element.parentElement.id == "authorInnerParent") element.parentElement.parentElement.style.display = hideCount == element.parentElement.children.length ? "none" : "flex";
        else element.parentElement.style.display = hideCount == element.parentElement.children.length ? "none" : "flex";
    }
};
// Check and hide author parent if all data is off in setting floater menu
SpecialGraphicsUtils.prototype.checkAuthorData = function (mainParent) {
    let authorParent = mainParent.querySelector("[id='authorParent']");
    // let authorContentParent = mainParent.querySelector("[id='authorContentParent']");
    let name = mainParent.querySelector("[id='sgAuthorNameNode']");
    let authorContentParent = mainParent.querySelector("[id='authorContentParent']");
    let desigination = mainParent.querySelector("[id='sgAuthorDesignationNode']");
    if (name && desigination && authorParent && name.style.display == "none" && authorContentParent && authorContentParent.style.display == "none" && desigination.style.display == "none") {
        authorParent.style.display = "none";
        // if (authorContentParent) authorContentParent.style.display = "none";
    } else if (authorParent) {
        authorParent.style.display = "";
        // if (authorContentParent) authorContentParent.style.display = "";
    }
};

// Check and hide presenter parent if all data is off in setting floater menu
SpecialGraphicsUtils.prototype.checkPresenterData = function (mainParent) {
    let presenterParent = mainParent.querySelector("[id='presenterParent']");
    let isAlone = presenterParent && presenterParent.hasAttribute("presenteralone") && presenterParent.getAttribute("presenteralone") == "true";
    let name = mainParent.querySelector("[id='sgPresentorNameNode']");
    let desigination = mainParent.querySelector("[id='sgPresentorDesiginationNode']");
    let presenterImageParent = mainParent.querySelector("[id='presenterImageParent']");
    let presenterLine = mainParent.querySelector("[id='presenterLine']");
    let hideDependChild = presenterParent && presenterParent.hasAttribute("data-hidedepend") ? presenterParent.getAttribute("data-hidedepend") : "";
    let dependNode = hideDependChild != "" && mainParent.querySelector("[id='" + hideDependChild + "']") ? mainParent.querySelector("[id='" + hideDependChild + "']") : null;
    if (isAlone) {
        if (name && desigination && presenterParent && name.style.display == "none" && desigination.style.display == "none") {
            presenterParent.style.display = "none";
            if (dependNode) dependNode.style.display = "none";
        } else if (presenterParent) {
            presenterParent.style.display = "";
            if (dependNode) dependNode.style.removeProperty("display");
        }
    } else {
        if (name && desigination && presenterParent && presenterImageParent && name.style.display == "none" && desigination.style.display == "none" && presenterImageParent.style.display == "none") {
            presenterParent.style.display = "none";
            if (dependNode) dependNode.style.display = "none";
        } else if (presenterParent) {
            presenterParent.style.display = "";
            if (dependNode) dependNode.style.removeProperty("display");
        }
    }

    if (presenterLine && ((desigination && desigination.style.display == "none") || (name && name.style.display == "none"))) presenterLine.style.display = "none";
    else if (presenterLine) presenterLine.style.removeProperty("display");
    return isAlone;
};
// Check and hide customer parent if all data is off in setting floater menu
SpecialGraphicsUtils.prototype.checkCustomerData = function (mainParent) {
    let customerParent = mainParent.querySelector("[id='customerParent']");
    let isAlone = customerParent && customerParent.hasAttribute("presenteralone") && customerParent.getAttribute("presenteralone") == "true";
    let name = mainParent.querySelector("[id='sgCustomerNameNode']");
    let desigination = mainParent.querySelector("[id='sgCustomerDesiginationNode']");
    let customerImageParent = mainParent.querySelector("[id='customerImageParent']");
    let customerLine = mainParent.querySelector("[id='customerLine']");
    let hideDependChild = customerParent && customerParent.hasAttribute("data-hidedepend") ? customerParent.getAttribute("data-hidedepend") : "";
    let dependNode = hideDependChild != "" && mainParent.querySelector("[id='" + hideDependChild + "']") ? mainParent.querySelector("[id='" + hideDependChild + "']") : null;
    if (isAlone) {
        if (name && desigination && customerParent && name.style.display == "none" && desigination.style.display == "none") {
            customerParent.style.display = "none";
            if (dependNode) dependNode.style.display = "none";
        } else if (customerParent) {
            customerParent.style.display = "";
            if (dependNode) dependNode.style.removeProperty("display");
        }
    } else {
        if (name && desigination && customerParent && customerImageParent && name.style.display == "none" && desigination.style.display == "none" && customerImageParent.style.display == "none") {
            customerParent.style.display = "none";
            if (dependNode) dependNode.style.display = "none";
        } else if (customerParent) {
            customerParent.style.display = "";
            if (dependNode) dependNode.style.removeProperty("display");
        }
    }

    if (customerLine && ((desigination && desigination.style.display == "none") || (name && name.style.display == "none"))) customerLine.style.display = "none";
    else if (customerLine) customerLine.style.removeProperty("display");
    return isAlone;
};

SpecialGraphicsUtils.prototype.checkPresenterDataCta = function (mainParent) {
    let presenterParent = mainParent.querySelector("[id='presenterParent']");
    let name = mainParent.querySelector("[id='sgPresentorNameNode']");
    let desigination = mainParent.querySelector("[id='sgPresentorDesiginationNode']");
    let presenterTwitterBase = mainParent.querySelector("[id='presenterTwitterBase']");
    let presenterSkypeBase = mainParent.querySelector("[id='presenterSkypeBase']");
    let presenterEmailBase = mainParent.querySelector("[id='presenterEmailBase']");
    let presenterWebsiteBase = mainParent.querySelector("[id='presenterWebsiteBase']");
    let presenterPhoneBase = mainParent.querySelector("[id='presenterPhoneBase']");
    let presenterFacebookBase = mainParent.querySelector("[id='presenterFacebookBase']");
    let presenterLinkedinBase = mainParent.querySelector("[id='presenterLinkedinBase']");
    if (
        name &&
        desigination &&
        presenterParent &&
        presenterSkypeBase &&
        presenterTwitterBase &&
        presenterWebsiteBase &&
        presenterPhoneBase &&
        presenterEmailBase &&
        presenterFacebookBase &&
        presenterLinkedinBase &&
        name.style.display == "none" &&
        desigination.style.display == "none" &&
        presenterEmailBase.style.display == "none" &&
        presenterSkypeBase.style.display == "none" &&
        presenterWebsiteBase.style.display == "none" &&
        presenterPhoneBase.style.display == "none" &&
        presenterFacebookBase.style.display == "none" &&
        presenterLinkedinBase.style.display == "none" &&
        presenterTwitterBase.style.display == "none"
    ) {
        presenterParent.style.display = "none";
    } else if (presenterParent) presenterParent.style.display = "";

    if (mainParent.querySelector("[id='sgTitleLabelNode']")) this.doCheckMaxHeight(mainParent.querySelector("[id='sgTitleLabelNode']"), mainParent);
    if (mainParent.querySelector("[id='sgSubTitleNode']")) this.doCheckMaxHeight(mainParent.querySelector("[id='sgSubTitleNode']"), mainParent);
    if (mainParent.querySelector("[id='sgTitleNode']")) this.doCheckMaxHeight(mainParent.querySelector("[id='sgTitleNode']"), mainParent);
};

// Get gradient color from theme(item1 - item6)
SpecialGraphicsUtils.prototype.getGradientColor = function (parentDiv) {
    let arrGradientColor = [];
    let color = this.getThemeColor(parentDiv, "theme-fill", "fill");
    arrGradientColor = this.itemColor(parentDiv);
    if (arrGradientColor[0] == arrGradientColor[1]) {
        arrGradientColor = this.shade(color);
    }
    return arrGradientColor;
};

// Get color from theme class names
SpecialGraphicsUtils.prototype.getThemeColor = function (parentDiv, className, attribute) {
    let textDummy = document.createElement("div");
    textDummy.className = className;
    parentDiv.appendChild(textDummy);
    let elementStyleColor = window.getComputedStyle(textDummy, null)[attribute];
    textDummy.remove();
    return elementStyleColor;
};

// Get shade colors custom.If all item colors are same
SpecialGraphicsUtils.prototype.shade = function (color) {
    let arrShadeColors = [];
    let colorValue = color == "rgb(255, 255, 255)" ? 255 : 0;
    let isDarkShade = colorValue == 0;
    arrShadeColors.push(`rgba(${colorValue},${colorValue},${colorValue},0.5)`);
    for (var i = 0; i < 5; i++) {
        if (isDarkShade) colorValue = colorValue + 60 > 255 ? 255 : colorValue + 60;
        else colorValue = colorValue - 60 < 0 ? 0 : colorValue - 60;
        arrShadeColors.push(`rgb(${colorValue},${colorValue},${colorValue})`);
    }
    return arrShadeColors;
};

//Get item colors from theme
SpecialGraphicsUtils.prototype.itemColor = function (parentDiv) {
    let arrItemColors = [];
    for (var i = 1; i < 7; i++) {
        let color = i == 1 ? "theme-fill" : "accent" + i + "-fill";
        arrItemColors.push(this.getThemeColor(parentDiv, color, "fill"));
    }
    return arrItemColors;
};

//Get offset of element
SpecialGraphicsUtils.prototype.getOffset = function (el) {
    var _x = 0;
    var _y = 0;
    while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
        _x += el.offsetLeft - el.scrollLeft;
        _y += el.offsetTop - el.scrollTop;
        el = el.offsetParent;
    }
    return { top: _y, left: _x };
};

// Get custom override font class from menu's layout metadata
SpecialGraphicsUtils.prototype.getFontClass = function (baseSet, metadata, type) {
    if (type == "cover") {
        if (metadata && metadata.presentorname) baseSet.creatorname = metadata.presentorname;
        if (metadata && metadata.presentordesigination) baseSet.desigination = metadata.presentordesigination;
        if (metadata && metadata.socialicon) baseSet.socialiconcontent = metadata.socialicon;
        if (metadata && metadata.venue) baseSet.venue = metadata.venue;
        if (metadata && metadata.number) baseSet.covernumber = metadata.number;
    } else if (type == "cta") {
        if (metadata && metadata.socialhead) baseSet.socialicontitle = metadata.socialhead;
        if (metadata && metadata.socialcontent) baseSet.socialiconcontent = metadata.socialcontent;
        if (metadata && metadata.referencehead) baseSet.referencetitle = metadata.referencehead;
        if (metadata && metadata.referencelink) baseSet.referencecontent = metadata.referencelink;
    }
    if (metadata && metadata.title) baseSet.title = metadata.title;
    if (metadata && metadata.subtitle) baseSet.subtitle = metadata.subtitle;
    if (metadata && metadata.label) baseSet.label = metadata.subtitle;
    return baseSet;
};

//Search image from online and return image url
SpecialGraphicsUtils.prototype.searchImage = function (sgParent, appBaseURL, searchText, position, instance, type = "image", imgNode, searchImageCallback, newType, appStaticURL) {
    try {
        if (appBaseURL) {
            let slideType = sgParent.parentElement?.parentElement?.parentElement?.parentElement?.getAttribute("data-slidetype") || "nodes";
            let iconStyle = instance?.objDataToSG?.fullMoodsData?.iconstyle || "illustrative";
            let searchType = newType ? newType : type == "creatorimage" || type == "customerimage" || type == "authorimage" ? "person" : type == "logoimage" || type == "customerlogoimage" || type == "presenterlogoimage" ? "logo" : type == "coverimage" || type == "presetimage" ? "image" : type;

            let dummyDiv = document.createElement("div");
            dummyDiv.innerHTML = searchText;
            if (sgParent) {
                sgParent.appendChild(dummyDiv);
                searchText = dummyDiv.innerText;
                sgParent.removeChild(dummyDiv);
            }

            let objSearch = { text: [searchText], type: searchType, style: iconStyle, imgtype: slideType == "imagestack" || slideType == "textstack" ? "nodes" : slideType };
            if (searchType == "person" || searchType == "logo" || searchType == "image" || searchType == "illustrations") delete objSearch.style;
            AISearchUtils.searchIcon(appBaseURL, objSearch, this.searchImageAPICallback.bind(this), {
                type: type,
                imgNode: imgNode,
                instance: instance,
                position: position,
                searchImageCallback: searchImageCallback,
                searchType: searchType,
                sgParent: sgParent,
                appStaticURL: appStaticURL,
            });

            // let xhr = new XMLHttpRequest();
            // xhr.open("GET", strURL);
            // xhr.onload = (data) => {
            //     try {
            //         let objResponse = JSON.parse(xhr.responseText);
            //         if (objResponse && objResponse.status == 0) {
            //             let logoData = objResponse.variants ? objResponse.variants : [objResponse.logo];
            //             if (logoData && (type == "logoimage" || type == "customerlogoimage" || type == "presenterlogoimage") && imgNode) {
            //                 if (imgNode.querySelector("[id*='sgLogoImageNode']")) imgNode = imgNode.querySelector("[id*='sgLogoImageNode']");
            //                 if (type != "presenterlogoimage" && imgNode.querySelector("[id*='sgCustomerLogoImageNode']")) imgNode = imgNode.querySelector("[id*='sgCustomerLogoImageNode']");
            //                 if (type == "presenterlogoimage" && imgNode.querySelector("[id*='sgPresenterLogoImageNode']")) imgNode = imgNode.querySelector("[id*='sgPresenterLogoImageNode']");
            //                 let path = this.setLogoUrlData(imgNode, logoData, type);
            //                 if (path) {
            //                     if (instance && instance.updateImage) instance.updateImage(imgNode.id, path);
            //                     this.setCoverUrl(sgParent, path, position ? position : 0, type, imgNode);
            //                     if (instance && instance.sgData.logoimage != null && instance.sgData.logoimage != undefined) instance.sgData.logoimage = path;
            //                     else if (instance) instance.sgData[position ? position : 0].logoimage = path;
            //                 }
            //             } else if (objResponse.url && searchType == "person" && imgNode) {
            //                 if (instance && instance.updateImage) instance.updateImage(imgNode.id, objResponse.url, 0, true);
            //                 this.setCoverUrl(sgParent, objResponse.url, 0, type, imgNode);
            //                 if (instance && instance.sgData[type] != null && instance.sgData[type] != undefined) instance.sgData[type] = objResponse.url;
            //                 else if (instance) instance.sgData[0][type] = objResponse.url;
            //                 if (searchImageCallback) searchImageCallback();
            //             } else if (objResponse.url && type != "logoimage" && type != "person" && type != "customerlogoimage" && type != "presenterlogoimage") {
            //                 let assetParent = sgParent.querySelector("[id='assetParent" + position + "']");
            //                 let imageHolder = sgParent.querySelector("[id='coverImageParent']");
            //                 if (assetParent && assetParent.querySelector("[id='coverImageParent']")) imageHolder = assetParent.querySelector("[id='coverImageParent']");
            //                 if (instance?.getTargetElement) imageHolder = instance.getTargetElement("coverImageParent");
            //                 if (imageHolder && imageHolder.querySelector("[data-target-id='coverimage']")) {
            //                     let imageNode = imageHolder.querySelector("[data-target-id='coverimage']");
            //                     imageNode.src = objResponse.url;
            //                     this.setCoverUrl(sgParent, objResponse.url, position ? position : 0);
            //                     if (instance && instance.sgData.coverimage != null && instance.sgData.coverimage != undefined) instance.sgData.coverimage = objResponse.url;
            //                     else if (instance) instance.sgData[0].coverimage = objResponse.url;
            //                     if (imageNode.autoImageChange) imageNode.autoImageChange(imageNode);
            //                     this.updateImageReSize(imageNode.getAttribute("data-width"), imageNode.getAttribute("data-height"), imageNode);
            //                 }
            //                 if (searchImageCallback) searchImageCallback();
            //             }
            //         }
            //     } catch (e) {
            //         console.log("SG - catch - Load Stock Image Error..." + xhr.status + "...url  =  " + strURL + "...error = " + e);
            //     }
            // };
            // xhr.onerror = () => {
            //     console.log("SG - onerror - Load Stock Image Error..." + xhr.status + "...url  =  " + strURL);
            // };
            // xhr.send();
        }
    } catch (error) {
        console.log("SG - Error on searching coverimage from online using title text - " + error);
    }
};

SpecialGraphicsUtils.prototype.searchImageAPICallback = function (objResponse, objParams) {
    try {
        let { type, imgNode, instance, position, searchImageCallback, searchType, sgParent, appStaticURL } = objParams;
        if (objResponse?.status == 0 && objResponse?.data?.length > 0) {
            let objResponseData = objResponse.data[0];
            if (objResponseData.status == 1) return;
            let logoData = objResponseData.variants ? objResponseData.variants : [objResponseData.logo];
            if (logoData && (type == "logoimage" || type == "customerlogoimage" || type == "presenterlogoimage") && imgNode) {
                if (imgNode.querySelector("[id*='sgLogoImageNode']")) imgNode = imgNode.querySelector("[id*='sgLogoImageNode']");
                if (type != "presenterlogoimage" && imgNode.querySelector("[id*='sgCustomerLogoImageNode']")) imgNode = imgNode.querySelector("[id*='sgCustomerLogoImageNode']");
                if (type == "presenterlogoimage" && imgNode.querySelector("[id*='sgPresenterLogoImageNode']")) imgNode = imgNode.querySelector("[id*='sgPresenterLogoImageNode']");
                let path = this.setLogoUrlData(imgNode, logoData, type);
                if (path) {
                    if (instance && instance.updateImage) instance.updateImage(imgNode.id, path);
                    this.setCoverUrl(sgParent, path, position ? position : 0, type, imgNode);
                    if (instance && instance.sgData.logoimage != null && instance.sgData.logoimage != undefined) instance.sgData.logoimage = path;
                    else if (instance) instance.sgData[position ? position : 0].logoimage = path;
                }
            } else if (objResponseData.url && searchType == "person" && imgNode) {
                if (instance && instance.updateImage) instance.updateImage(imgNode.id, objResponseData.url, 0, true);
                this.setCoverUrl(sgParent, objResponseData.url, 0, type, imgNode);
                if (instance && instance.sgData[type] != null && instance.sgData[type] != undefined) instance.sgData[type] = objResponseData.url;
                else if (instance) instance.sgData[0][type] = objResponseData.url;
                if (searchImageCallback) searchImageCallback();
            } else if (searchType == "illustrations") {
                let assetParent = sgParent.querySelector("[id='assetParent" + position + "']");
                let imageHolder = sgParent.querySelector("[id='coverImageParent']");
                if (assetParent && assetParent.querySelector("[id='coverImageParent']")) imageHolder = assetParent.querySelector("[id='coverImageParent']");
                if (instance?.getTargetElement) imageHolder = instance.getTargetElement("coverImageParent");
                let imageNode = imageHolder?.querySelector("[id='svgElementDiv']");
                if (imageNode) {
                    let assetLoader = new window["SGAssetLoader"]();
                    assetLoader
                        .loadAssets([{ type: "svg", url: objResponseData.url }], appStaticURL)
                        .then((responseData) => {
                            if (responseData?.[0]?.data) imageNode.innerHTML = responseData[0].data;
                            let tagName = "coverimage";
                            this.setCoverUrl(sgParent, objResponseData.url, position ? position : 0, tagName);
                            if (instance && instance.sgData[tagName] != null && instance.sgData[tagName] != undefined) instance.sgData[tagName] = objResponseData.url;
                            else if (instance) instance.sgData[0][tagName] = objResponseData.url;
                            if (searchImageCallback) searchImageCallback();
                        })
                        .catch(function (rej) {
                            if (searchImageCallback) searchImageCallback();
                            console.log("SG - Error on Specialgraphics assets", rej);
                        });
                }
            } else if (objResponseData.url && type != "logoimage" && type != "person" && type != "customerlogoimage" && type != "presenterlogoimage") {
                let assetParent = sgParent.querySelector("[id='assetParent" + position + "']");
                let imageHolder = sgParent.querySelector("[id='coverImageParent']");
                if (type == "presetimage") imageHolder = sgParent.querySelector("[id='presetImageContentParent']");
                if (assetParent && assetParent.querySelector("[id='coverImageParent']")) imageHolder = assetParent.querySelector("[id='coverImageParent']");
                if (instance?.getTargetElement) imageHolder = instance.getTargetElement("coverImageParent");
                let imageNode = imageHolder?.querySelector("[data-target-id='coverimage']");
                if (type == "presetimage") imageNode = imageHolder?.querySelector("[data-target-id='presetimage']");
                if (imageHolder && imageNode) {
                    imageNode.src = objResponseData.url;
                    let tagName = type == "presetimage" ? "presetimage" : "coverimage";
                    this.setCoverUrl(sgParent, objResponseData.url, position ? position : 0, tagName);
                    if (instance && instance.sgData[tagName] != null && instance.sgData[tagName] != undefined) instance.sgData[tagName] = objResponseData.url;
                    else if (instance) instance.sgData[0][tagName] = objResponseData.url;
                    if (imageNode.autoImageChange) imageNode.autoImageChange(imageNode);
                    this.updateImageReSize(imageNode.getAttribute("data-width"), imageNode.getAttribute("data-height"), imageNode);
                }
                if (searchImageCallback) searchImageCallback();
            }
        }
    } catch (e) {
        console.log("SG - catch - Load Stock Image Error...", e, objResponse);
    }
};
SpecialGraphicsUtils.prototype.setLogoUrlData = function (targetLogo, arrLogoData, type) {
    if (!targetLogo) return "";
    let strLogoData = "";
    let imageURL = null;
    let prefix = type == "customerlogoimage" ? "customer" : type == "presenterlogoimage" ? "customer" : "";
    arrLogoData.forEach((data, index) => {
        strLogoData += data.type + "___" + data.url + (index != arrLogoData.length - 1 ? "," : "");
        if (index == 0) {
            imageURL = data.url;
            targetLogo.setAttribute("data-" + prefix + "logotype", data.type);
        }
    });
    targetLogo.removeAttribute("data-" + prefix + "logobaseurl");
    targetLogo.setAttribute("data-" + prefix + "logodata", strLogoData);

    return imageURL ? imageURL : null;
};

// Set cover url from nodes - Aespecialgraphics node
SpecialGraphicsUtils.prototype.setCoverUrl = function (mainParent, url, index, type = "coverimage", imgNode) {
    if (mainParent && mainParent.parentElement && mainParent.parentElement.parentElement) {
        var slideDomContentGroup = mainParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
        if (slideDomContentGroup) {
            let nodeDataList = slideDomContentGroup.getElementsByTagName(type);
            if (nodeDataList) {
                nodeDataList[index].setAttribute("data-src", url);
                if (imgNode && imgNode.hasAttribute("data-logotype") && type.includes("logoimage")) {
                    nodeDataList[index].setAttribute("data-logotype", imgNode.getAttribute("data-logotype"));
                    if (imgNode.hasAttribute("data-logodata")) nodeDataList[index].setAttribute("data-logodata", imgNode.getAttribute("data-logodata"));
                    imgNode.removeAttribute("data-logotype");
                }
                if (imgNode && imgNode.hasAttribute("data-customerlogotype") && type.includes("customerlogoimage")) {
                    nodeDataList[index].setAttribute("data-customerlogotype", imgNode.getAttribute("data-customerlogotype"));
                    if (imgNode.hasAttribute("data-customerlogodata")) nodeDataList[index].setAttribute("data-customerlogodata", imgNode.getAttribute("data-customerlogodata"));
                    imgNode.removeAttribute("data-customerlogotype");
                }
                if (imgNode && imgNode.hasAttribute("data-presenterlogotype") && type.includes("presenterlogoimage")) {
                    nodeDataList[index].setAttribute("data-presenterlogotype", imgNode.getAttribute("data-presenterlogotype"));
                    if (imgNode.hasAttribute("data-presenterlogodata")) nodeDataList[index].setAttribute("data-presenterlogodata", imgNode.getAttribute("data-presenterlogodata"));
                    imgNode.removeAttribute("data-presenterlogotype");
                }
                if (type == "creatorimage" || type == "customerimage") {
                    nodeDataList[index].setAttribute("needassetupdate", "false");
                }
            }
        }
    }
};

//Hiding the empty nodes whilw going to present mode.
SpecialGraphicsUtils.prototype.checkAndHideNodesForPresentation = function (mainParent, index = 0) {};

//Getting offset by Parent element.
SpecialGraphicsUtils.prototype.getOffsetRectByParent = function (parent, element) {
    let top = element.offsetTop;
    let left = element.offsetLeft;
    let elementParent = element.parentElement;

    while (parent != elementParent) {
        top = top + elementParent.offsetTop;
        left = left + elementParent.offsetLeft;
        elementParent = elementParent.parentElement;
    }

    return { top: top, left: left, width: element.offsetWidth, height: element.offsetHeight };
};

SpecialGraphicsUtils.prototype.updateCoverImagePositions = function (mainParent, doClearStyle = false) {
    let coverImageParent = mainParent ? mainParent.querySelector("[id='coverImageParent']") : null;
    let coverimage = coverImageParent ? coverImageParent.querySelector("[data-target-id='coverimage']") : null;
    let deviceContainerNode = mainParent ? mainParent.querySelector("[id='deviceContainerNode']") : null;
    if (coverimage && !deviceContainerNode) {
        if (coverImageParent && coverImageParent.hasAttribute("data-oriwidth")) coverImageParent.style.height = coverImageParent.getAttribute("data-oriwidth");
        if (doClearStyle) coverimage.dataset.csstext = "";
        this.applyImagePositions(coverImageParent, coverimage, mainParent);
    }
};
SpecialGraphicsUtils.prototype.updateImagePositions = function (mainParent) {
    //Setting up Image edit position after slide create.Because we update class names so image edit position will change.
    // let coverImageParent = mainParent.querySelector("[id='coverImageParent']");
    // let coverimage = coverImageParent ? coverImageParent.querySelector("[data-target-id='coverimage']") : null;

    this.updateCoverImagePositions(mainParent);
    let presenterImageParent = mainParent.querySelector("[id='presenterImageParent']");
    presenterImageParent = mainParent.querySelector("[id='presenterContentParent']") ? mainParent.querySelector("[id='presenterContentParent']") : presenterImageParent;
    let sgPresentorImageNode = presenterImageParent ? presenterImageParent.querySelector("[id='sgPresentorImageNode']") : null;

    let customerImageParent = mainParent.querySelector("[id='customerImageParent']");
    customerImageParent = mainParent.querySelector("[id='customerContentParent']") ? mainParent.querySelector("[id='customerContentParent']") : customerImageParent;
    let sgCustomerImageNode = customerImageParent ? customerImageParent.querySelector("[id='sgCustomerImageNode']") : null;

    let authorImageParent = mainParent.querySelector("[id='authorImageParent']");
    authorImageParent = mainParent.querySelector("[id='authorContentParent']") ? mainParent.querySelector("[id='authorContentParent']") : authorImageParent;
    let sgAuthorImageNode = authorImageParent ? authorImageParent.querySelector("[id='sgAuthorImageNode']") : null;

    let logoImageParent = mainParent.querySelector("[id='logoImageParent']");
    logoImageParent = mainParent.querySelector("[id='logoContentParent']") ? mainParent.querySelector("[id='logoContentParent']") : logoImageParent;
    let sgLogoImageNode = logoImageParent ? logoImageParent.querySelector("[id='sgLogoImageNode']") : null;

    let customerLogoImageParent = mainParent.querySelector("[id='customerLogoImageParent']");
    customerLogoImageParent = mainParent.querySelector("[id='customerLogoContentParent']") ? mainParent.querySelector("[id='customerLogoContentParent']") : customerLogoImageParent;
    let sgCustomerLogoImageNode = customerLogoImageParent ? customerLogoImageParent.querySelector("[id='sgCustomerLogoImageNode']") : null;

    let presenterLogoImageParent = mainParent.querySelector("[id='presenterLogoImageParent']");
    presenterLogoImageParent = mainParent.querySelector("[id='presenterLogoContentParent']") ? mainParent.querySelector("[id='presenterLogoContentParent']") : presenterLogoImageParent;
    let sgPresenterLogoImageNode = presenterLogoImageParent ? presenterLogoImageParent.querySelector("[id='sgPresenterLogoImageNode']") : null;

    let presetImageParent = mainParent.querySelector("[id='presetImageParent']");
    presetImageParent = mainParent.querySelector("[id='presetContentParent']") ? mainParent.querySelector("[id='presetContentParent']") : presetImageParent;
    let sgPresetImageNode = presetImageParent ? presetImageParent.querySelector("[id='presetImageNode']") : null;

    let arrSpeakerImages = mainParent.querySelectorAll("img[id*='sgSpeakerImageNode']");
    for (let a = 0; a < arrSpeakerImages.length; a++) {
        if (arrSpeakerImages[a] && arrSpeakerImages[a].parentElement) this.applyImagePositions(arrSpeakerImages[a].parentElement, arrSpeakerImages[a], mainParent);
    }
    // this.applyImagePositions(coverImageParent, coverimage, mainParent);
    this.applyImagePositions(presenterImageParent, sgPresentorImageNode, mainParent);
    this.applyImagePositions(customerImageParent, sgCustomerImageNode, mainParent);
    this.applyImagePositions(authorImageParent, sgAuthorImageNode, mainParent);
    if (logoImageParent && logoImageParent.offsetHeight != 0) this.applyImagePositions(logoImageParent, sgLogoImageNode, mainParent);
    this.applyImagePositions(customerLogoImageParent, sgCustomerLogoImageNode, mainParent);
    this.applyImagePositions(presenterLogoImageParent, sgPresenterLogoImageNode, mainParent);
    this.applyImagePositions(presetImageParent, sgPresetImageNode, mainParent);
};

//Appluying image positions z,y width and height.s
SpecialGraphicsUtils.prototype.applyImagePositions = function (parent, element, mainParent) {
    if (element && parent) {
        let width = parseFloat(window.getComputedStyle(parent).width);
        let height = parseFloat(window.getComputedStyle(parent).height);
        if (parent.querySelector("[id*='coverParent']")) {
            //For some imagestack we have used width & heiht auto so we use coverParent element here to get width & height
            let coverParent = parent.querySelector("[id*='coverParent']");
            let styleNode = window.getComputedStyle(coverParent);
            let changedW = false;
            let changedH = false;
            if (coverParent.style.width.includes("%") || styleNode.width.includes("%")) {
                let percentage = parseFloat(coverParent.style.width.includes("%") ? coverParent.style.width : styleNode.width);
                let parentW = window.getComputedStyle(parent).width;
                if (parentW.includes("px") && !isNaN(percentage)) {
                    width = parseFloat(parentW) * (percentage / 100);
                    changedW = true;
                }
            }
            if (changedW == false) width = parseFloat(styleNode.width);

            if (coverParent.style.height.includes("%") || styleNode.height.includes("%")) {
                let percentage = parseFloat(coverParent.style.height.includes("%") ? coverParent.style.height : styleNode.height);
                let parentH = window.getComputedStyle(parent).height;
                if (parentH.includes("px") && !isNaN(percentage)) {
                    height = parseFloat(parentH) * (percentage / 100);
                    changedH = true;
                }
            }
            if (changedH == false) height = parseFloat(styleNode.height);
        }
        if (!element.hasAttribute("updateposition") || (element.hasAttribute("updateposition") && element.getAttribute("updateposition") != "false")) {
            element.setAttribute("data-width", parseFloat(width));
            element.setAttribute("data-height", parseFloat(height));
            let rect = this.getOffsetRectByParent(mainParent, parent);
            element.setAttribute("data-x", rect.left);
            element.setAttribute("data-y", rect.top);
            if (element.dataset.csstext && element.dataset.csstext != "") {
            } else this.updateImageReSize(width, height, element);
        }
    }
};

// Check and extract pattern for Text Flip and Text Typewritter Unique words.
SpecialGraphicsUtils.prototype.extractUniquePattern = function (arrRows) {
    var arrMainData = [];
    var arrObjData = [];
    for (var t = 0; t < arrRows.length; t++) {
        var textData = arrRows[t].trim();
        var splitData = textData == "" ? [] : textData.split(/\s+/);
        arrMainData.push(splitData);
    }
    for (var j = 0; j < arrMainData.length; j++) {
        var singleNode = arrMainData[j];
        var objNode = new Object();
        for (var k = 0; k < singleNode.length; k++) {
            if (objNode[singleNode[k]] == null)
                objNode[singleNode[k]] = {
                    rows: [],
                };
            objNode[singleNode[k]].rows.push(k);
        }
        arrObjData.push(objNode);
    }

    var hasFailPattern = false;
    var hasIdentialSentence = false;
    var hasSameTextLength = false;
    var matchCount = 0;
    for (var l = 0; l < arrObjData.length; l++) {
        var ns = arrObjData[l];
        var n = arrMainData[l];
        var os = arrObjData[l + 1] ? arrObjData[l + 1] : arrObjData[0];
        var currentMatchCount = 0;
        for (var i in ns) {
            if (ns[i].rows.length == 1 && typeof os[i] != "undefined" && os[i].rows.length == 1 && this.checkPatternItems(arrObjData, i)) {
                currentMatchCount = currentMatchCount + 1;
                hasSameTextLength = hasSameTextLength || os[i].rows[0] != ns[i].rows[0];
                n[ns[i].rows[0]] = {
                    text: n[ns[i].rows[0]],
                    row: os[i].rows[0],
                };
            }
        }

        if (l > 0 && !hasFailPattern) {
            hasFailPattern = matchCount != currentMatchCount;
        }
        matchCount = currentMatchCount;
    }
    hasIdentialSentence = arrObjData.length == 1 || arrMainData[0].length == matchCount;

    return {
        hasSameTextLength: hasSameTextLength,
        hasProperPatten: !hasFailPattern,
        hasIdentialSentence: hasIdentialSentence,
        patternData: arrMainData,
    };
};

//Checking pattern for unique words finding method
SpecialGraphicsUtils.prototype.checkPatternItems = function (arrObjData, value) {
    for (let i = 0; i < arrObjData.length; i++) {
        let arrlocal = arrObjData[i];
        if (!arrlocal[value]) return false;
    }
    return true;
};

//If Device Imagestack data is not there create a default data here
SpecialGraphicsUtils.prototype.getDefaultDeviceData = function (metaData) {
    let obj = {};
    obj.sgdevicemodel = "iphone";
    obj.sgorientation = "portrait";
    obj.sgalignment = "right";
    if (metaData.deviceTypeFromMenu == "imageindesktop" || metaData.deviceNameFromMenu.includes("-desktop")) {
        obj.sgdevicemodel = "desktop";
        if (metaData.deviceNameFromMenu.includes("-desktopcrt")) obj.sgdevicemodel = "desktopcrt";
        obj.sgorientation = "landscape";
        obj.sgalignment = "right";
    } else if (metaData.deviceTypeFromMenu == "imageinlaptop" || metaData.deviceNameFromMenu.includes("-laptop") || metaData.deviceNameFromMenu.includes("-windowslaptop")) {
        obj.sgdevicemodel = "laptop";
        if (metaData.deviceNameFromMenu.includes("-windowslaptop")) obj.sgdevicemodel = "windowslaptop";
        obj.sgorientation = "landscape";
        obj.sgalignment = "right";
    } else if (metaData.deviceTypeFromMenu == "imageintv" || metaData.deviceNameFromMenu.includes("-tv") || metaData.deviceNameFromMenu.includes("-retrotv")) {
        obj.sgdevicemodel = "tv";
        obj.sgorientation = "landscape";
        if (metaData.deviceNameFromMenu.includes("-retrotv")) {
            obj.sgdevicemodel = "retrotv";
            obj.sgorientation = "portrait";
        }
        obj.sgalignment = "right";
    } else if (metaData.deviceNameFromMenu.includes("-watch") || metaData.deviceNameFromMenu.includes("-galaxywatch")) {
        obj.sgdevicemodel = "watch";
        if (metaData.deviceNameFromMenu.includes("-galaxywatch")) obj.sgdevicemodel = "galaxywatch";
        obj.sgorientation = "landscape";
        obj.sgalignment = "right";
    } else if (metaData.deviceTypeFromMenu == "imageintablet" || metaData.deviceNameFromMenu.includes("-tablet") || metaData.deviceNameFromMenu.includes("-androidtablet")) {
        obj.sgdevicemodel = "tablet";
        if (metaData.deviceNameFromMenu.includes("-androidtablet")) obj.sgdevicemodel = "androidtablet";
        if (metaData.deviceNameFromMenu.includes("-tablet") && metaData.deviceNameFromMenu.includes("zoom")) obj.sgdevicemodel = "tabletzoom";
        if (metaData.deviceNameFromMenu.includes("-androidtablet") && metaData.deviceNameFromMenu.includes("zoom")) obj.sgdevicemodel = "androidtabletzoom";
        obj.sgorientation = "portrait";
        obj.sgalignment = "right";
        if (metaData.deviceNameFromMenu == "tabletzoom") obj.sgdevicemodel = "tabletzoom";
        if (metaData.deviceNameFromMenu == "androidtabletzoom") obj.sgdevicemodel = "androidtabletzoom";
    } else {
        if (metaData.deviceNameFromMenu.includes("-android")) obj.sgdevicemodel = "googlephone";
        if (metaData.deviceNameFromMenu.includes("-android") && metaData.deviceNameFromMenu.includes("zoom")) obj.sgdevicemodel = "googlephonezoom";
        if (metaData.deviceNameFromMenu.includes("-android") && metaData.deviceNameFromMenu.includes("hand")) obj.sgdevicemodel = "googlephoneinhand";
        if (metaData.deviceNameFromMenu.includes("-phone")) obj.sgdevicemodel = "iphone";
        if (metaData.deviceNameFromMenu.includes("-phone") && metaData.deviceNameFromMenu.includes("zoom")) obj.sgdevicemodel = "iphonezoom";
        if (metaData.deviceNameFromMenu.includes("-phone") && metaData.deviceNameFromMenu.includes("hand")) obj.sgdevicemodel = "iphoneinhand";
        if (metaData.deviceNameFromMenu.includes("-samsungphone")) obj.sgdevicemodel = "samsungphone";
        if (metaData.deviceNameFromMenu.includes("-samsungphonelandscape")) obj.sgdevicemodel = "samsungphonelandscape";
        if (metaData.deviceNameFromMenu.includes("-samsungphone") && metaData.deviceNameFromMenu.includes("zoom")) obj.sgdevicemodel = "samsungphonezoom";
        if (metaData.deviceNameFromMenu.includes("-samsungphone") && metaData.deviceNameFromMenu.includes("hand")) obj.sgdevicemodel = "samsungphoneinhand";

        if (metaData.deviceNameFromMenu == "phonezoom") obj.sgdevicemodel = "iphonezoom";
        if (metaData.deviceNameFromMenu == "phoneinhand") obj.sgdevicemodel = "iphoneinhand";
    }
    return obj;
};

//Set opacity attribute for animation for all animating nodes
SpecialGraphicsUtils.prototype.setOpacityAttribute = function (element, parent = null) {
    try {
        if (element) {
            let opacity = window.getComputedStyle(element).opacity;
            if (parent) element = parent;
            if (opacity != 1 && opacity != "1") element.setAttribute("data-customopacity", opacity);
            else element.removeAttribute("data-customopacity");
        }
    } catch (error) {}
};

SpecialGraphicsUtils.prototype.updateFontData = function (element, parent) {};

SpecialGraphicsUtils.prototype.updateColorClassName = function (stylename, mainParent, classType = null) {
    let arrTitleBg = [
        "simplecssthingstodostyle1",
        "simplecssthanksstyle2",
        "simplecssreferencestyle2",
        "simplecsssectionillustrationstyle1",
        "simplecsssectionimagestyle1",
        "simplecsssectionillustrationstyle2",
        "minimalistcsssocialstyle2",
        "minimalistcssthanksstyle2",
        "elegantcsseventstyle1",
        "elegantcssthanksstyle2",
        "elegantcsssectionimagestyle1",
        "elegantcsssectiontitlestyle1",
        "elegantcssannualreportstyle2",
        "elegantcssquoteauthnamebased",
        "elegantcsstitlestyle2",
        "boldcsssocialstyle1",
        "boldcssreferencestyle2",
        "boldcsssectionillustrationstyle1",
        "boldcsslogostyle2",
        "minimalistcssagenda",
    ];
    let arrSubtitleBg = ["simplecssannualreportstyle1", "simplecsssocialstyle1", "classiccssthingstodostyle1", "classiccssthingstodostyle2", "classiccsssectionimagestyle1", "classiccssreferencestyle2", "classiccsssocialstyle2"];

    let arrTitleNodes = mainParent.querySelectorAll("[id='sgTitleNode']");
    let arrSubTitleNodes = mainParent.querySelectorAll("[id='sgSubTitleNode']");
    let arrTitleLabelNodes = mainParent.querySelectorAll("[id='sgTitleLabelNode']");
    let arrTextElement = mainParent.querySelectorAll("[id='textElement']");

    stylename = stylename.replace(" ", "").replace(" ", "");
    if (arrTitleBg.includes(stylename) || classType == "titleColorBg") {
        this.updateColorClassNameInner(arrTitleNodes, "titleColorBg");
        this.updateColorClassNameInner(arrSubTitleNodes, "titleColorBg");
        this.updateColorClassNameInner(arrTitleLabelNodes, "titleColorBg");
        let coverShape = mainParent.querySelector("[id='covershape']");
        if (coverShape && !classType && !stylename.includes("elegantcss")) coverShape.style.setProperty("background-color", "rgba(var(--label-color-rgb),1)", "important");
        for (let a = 0; a < arrTextElement.length; a++) {
            arrTextElement[a].removeAttribute("data-bg-color");
            arrTextElement[a].setAttribute("data-bg-color", "titleColorBg");
        }
    } else if (arrSubtitleBg.includes(stylename) || classType == "subtitleColorBg") {
        this.updateColorClassNameInner(arrTitleNodes, "subtitleColorBg");
        this.updateColorClassNameInner(arrSubTitleNodes, "subtitleColorBg");
        this.updateColorClassNameInner(arrTitleLabelNodes, "subtitleColorBg");
        let coverShape = mainParent.querySelector("[id='covershape']");
        if (coverShape && !classType && !stylename.includes("elegantcss")) coverShape.style.setProperty("background-color", "rgba(var(--title-color-rgb),1)", "important");
        for (let a = 0; a < arrTextElement.length; a++) {
            arrTextElement[a].removeAttribute("data-bg-color");
            arrTextElement[a].setAttribute("data-bg-color", "subtitleColorBg");
        }
    }
};
SpecialGraphicsUtils.prototype.updateColorClassNameInner = function (arrData, className) {
    for (let a = 0; a < arrData.length; a++) {
        arrData[a].classList.remove("titleColorBg");
        arrData[a].classList.remove("subtitleColorBg");
        arrData[a].classList.remove("transparentBg");
        arrData[a].classList.add(className);
    }
};

// Computes the matrix3d that maps src points to dst. its for angular images angle find.
SpecialGraphicsUtils.prototype.computeTransform = function (src, dst) {
    // src and dst should have length 4 each
    var count = 4;
    var a = []; // (2*count) x 8 matrix
    var b = []; // (2*count) vector

    for (var i = 0; i < 2 * count; ++i) {
        a.push([0, 0, 0, 0, 0, 0, 0, 0]);
        b.push(0);
    }

    for (var i = 0; i < count; ++i) {
        var j = i + count;
        a[i][0] = a[j][3] = src[i][0];
        a[i][1] = a[j][4] = src[i][1];
        a[i][2] = a[j][5] = 1;
        a[i][3] = a[i][4] = a[i][5] = a[j][0] = a[j][1] = a[j][2] = 0;
        a[i][6] = -src[i][0] * dst[i][0];
        a[i][7] = -src[i][1] * dst[i][0];
        a[j][6] = -src[i][0] * dst[i][1];
        a[j][7] = -src[i][1] * dst[i][1];
        b[i] = dst[i][0];
        b[j] = dst[i][1];
    }

    var x = numeric.solve(a, b);
    // matrix3d is homogeneous coords in column major!
    // the z coordinate is unused
    var m = [x[0], x[3], 0, x[6], x[1], x[4], 0, x[7], 0, 0, 1, 0, x[2], x[5], 0, 1];
    var transform = "matrix3d(";
    for (var i = 0; i < m.length - 1; ++i) {
        transform += m[i] + ", ";
    }
    transform += m[15] + ")";
    return transform;
};

// Generate random string  - UUID
SpecialGraphicsUtils.prototype.generateRandomStringCSS = function (length = 5) {
    var text = "";
    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    for (var i = 0; i < length; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
    return text;
};

SpecialGraphicsUtils.prototype.isJson = function (str) {
    //Checking the string is valid json or not
    try {
        JSON.parse(str);
    } catch (e) {
        return false;
    }
    return true;
};
SpecialGraphicsUtils.prototype.socialIconsPropertyApplyFromMood = function (socialiconsData, iconNode, assetParent) {
    // if (socialiconsData && iconNode) {
    //     let shape = socialiconsData.shape;
    //     let style = socialiconsData.style;
    //     let iconColor = socialiconsData.iconcolor;
    //     let iconsize = socialiconsData.iconsize;
    //     let outline = socialiconsData.outline;
    //     let fillcolor = socialiconsData.fillcolor;
    //     let radius = socialiconsData.radius;
    //     // //Applying Style props
    //     // if (iconColor && assetParent) assetParent.style.setProperty("--socialIconColor", "var(--" + iconColor + "-color)");
    //     // if (outline) {
    //     //     iconNode.style.backgroundColor = "unset";
    //     //     iconNode.style.background = "unset";
    //     //     iconNode.style.border = outline;
    //     // }
    //     // if (fillcolor) iconNode.style.backgroundColor = fillcolor;
    //     // if (style == "none") {
    //     //     iconNode.style.background = "unset";
    //     //     iconNode.style.backgroundColor = "unset";
    //     //     iconNode.style.border = "unset";
    //     // }
    //     if (radius) iconNode.style.borderRadius = radius + (radius.includes("px") || radius.includes("%") ? "" : "px");
    //     if (iconsize && iconNode.getElementsByTagName("svg").length > 0) {
    //         let svgNode = iconNode.getElementsByTagName("svg")[0];
    //         svgNode.style.width = iconsize + (iconsize.includes("px") || iconsize.includes("%") ? "" : "px");
    //         svgNode.style.height = iconsize + (iconsize.includes("px") || iconsize.includes("%") ? "" : "px");
    //     }
    //     // //Applying gradient
    //     // if (style.includes("outlinegradient")) {
    //     //     iconNode.style.border = "double " + style.replace("outlinegradient", "") + " transparent";
    //     //     if (fillcolor) {
    //     //         let color = fillcolor.includes("var") ? fillcolor : "var(--" + fillcolor + "-color)";
    //     //         iconNode.style.backgroundImage = "linear-gradient(" + color + ", " + color + "), radial-gradient(circle at bottom right, var(--item6-color), var(--item1-color))";
    //     //     } else iconNode.style.backgroundImage = "linear-gradient(var(--inner-color), var(--inner-color)), radial-gradient(circle at bottom right, var(--item6-color), var(--item1-color))";
    //     //     iconNode.style.backgroundOrigin = "border-box";
    //     //     iconNode.style.backgroundClip = "content-box, border-box";
    //     // }
    //     // if (style.includes("solidgradient")) {
    //     //     iconNode.style.backgroundColor = "unset";
    //     //     iconNode.style.background = "linear-gradient(to right bottom, var(--item1-color), var(--item6-color))";
    //     // }
    // }
};
SpecialGraphicsUtils.prototype.getSeqMoodStyle = function (moodData, index) {
    try {
        if (index) index = index + "";
        if (index && index.includes("#")) index = index.replace("#", "");
        let strContent = index;
        if (moodData && (moodData.sequenceprefix || moodData.sequencesuffix)) {
            let prefix = this.setSeqStyle(moodData.sequenceprefix.style, index, true);
            let suffix = this.setSeqStyle(moodData.sequencesuffix.style, index, true);
            let mainStyle = moodData.sequencemain && moodData.sequencemain.style;
            let mainContent = mainStyle && (mainStyle == "abc" || mainStyle == "ABC") ? this.getABCStyle(index - 1, mainStyle == "ABC") : index;
            strContent = prefix + mainContent + suffix;
        }
        return strContent;
    } catch (error) {
        return index;
    }
};
SpecialGraphicsUtils.prototype.setSeqStyle = function (style, index, filterStyle = false) {
    let strContent = "";
    if (style == "0" && index < 10) strContent = style + (filterStyle ? "" : index);
    else if (style == "abc" || style == "ABC") strContent = this.getABCStyle(index - 1, style == "ABC");
    else if (style != "0") strContent = style + (filterStyle ? "" : index);
    return strContent;
};
SpecialGraphicsUtils.prototype.getABCStyle = function (index, isUpperCase) {
    let strAlphabet = "abcdefghijklmnopqrstuvwxyz";
    let arrAbc = isUpperCase ? strAlphabet.toUpperCase().split("") : strAlphabet.split("");
    return arrAbc[index];
};
SpecialGraphicsUtils.prototype.isOnlyTitle = function (assetParent, checkLogo = true) {
    let isOnlyTitleVisible = false;
    if (assetParent) {
        let presenterVisible = true;
        let presenterParent = assetParent.querySelector("[id='presenterParent']");
        if ((presenterParent && presenterParent.style.display == "none") || !presenterParent) presenterVisible = false;

        let customerVisible = true;
        let customerParent = assetParent.querySelector("[id='customerParent']");
        if ((customerParent && customerParent.style.display == "none") || !customerParent) customerVisible = false;

        let logoVisible = true;
        let logoContentParent = assetParent.querySelector("[id='logoContentParent']");
        if ((logoContentParent && logoContentParent.style.display == "none") || !logoContentParent) logoVisible = false;

        let venueVisible = true;
        let sgVenueParent = assetParent.querySelector("[id='sgVenueParent']");
        if ((sgVenueParent && sgVenueParent.style.display == "none") || !sgVenueParent) venueVisible = false;

        let yearVisible = true;
        let covernumber = assetParent.querySelector("[id='covernumber']");
        if ((covernumber && covernumber.style.display == "none") || !covernumber) yearVisible = false;

        let contactVisible = true;
        let contactParent = assetParent.querySelector("[id='contactParent']");
        if ((contactParent && contactParent.style.display == "none") || !contactParent) contactVisible = false;

        let referenceVisible = true;
        let referenceParent = assetParent.querySelector("[id='referenceParent']");
        if ((referenceParent && referenceParent.style.display == "none") || !referenceParent) referenceVisible = false;

        let socialVisible = true;
        let customLinkIconParent = assetParent.querySelector("[id='customLinkIconParent']");
        if ((customLinkIconParent && customLinkIconParent.style.display == "none") || !customLinkIconParent) socialVisible = false;

        let authNameVisible = true;
        let sgAuthorNameNode = assetParent.querySelector("[id='sgAuthorNameNode']");
        if ((sgAuthorNameNode && sgAuthorNameNode.style.display == "none") || !sgAuthorNameNode) authNameVisible = false;

        let authDesigiantionVisible = true;
        let sgAuthorDesignationNode = assetParent.querySelector("[id='sgAuthorDesignationNode']");
        if ((sgAuthorDesignationNode && sgAuthorDesignationNode.style.display == "none") || !sgAuthorDesignationNode) authDesigiantionVisible = false;

        let authImageVisible = true;
        let authorContentParent = assetParent.querySelector("[id='authorContentParent']");
        if ((authorContentParent && authorContentParent.style.display == "none") || !authorContentParent) authImageVisible = false;

        let speakerVisible = true;
        let speakerParent = assetParent.querySelector("[id='speakerParent']");
        if ((speakerParent && speakerParent.style.display == "none") || !speakerParent) speakerVisible = false;

        let socialIconVisible = true;
        let ctaSocialParent = assetParent.querySelector("[id='ctaSocialParent']");
        if ((ctaSocialParent && ctaSocialParent.style.display == "none") || !ctaSocialParent) socialIconVisible = false;

        if (
            authImageVisible == false &&
            authDesigiantionVisible == false &&
            authNameVisible == false &&
            presenterVisible == false &&
            customerVisible == false &&
            venueVisible == false &&
            contactVisible == false &&
            referenceVisible == false &&
            socialVisible == false &&
            socialIconVisible == false &&
            speakerVisible == false &&
            yearVisible == false
        )
            isOnlyTitleVisible = true;
    }
    return isOnlyTitleVisible;
};

SpecialGraphicsUtils.prototype.buildDomContentArray = function (domContent) {
    let arrContentGroup = [];
    let sgDomDataNodes = domContent ? domContent.querySelector("[id='AESpecialGraphics']").children : null;
    if (sgDomDataNodes && sgDomDataNodes.length > 0 && sgDomDataNodes[0].children.length > 0) {
        for (let n1 = 0; n1 < sgDomDataNodes.length; n1++) {
            let childNodeCount = sgDomDataNodes[n1].children;
            let objDomContent = {};
            for (let c1 = 0; c1 < childNodeCount.length; c1++) {
                let nodeName = childNodeCount[c1].nodeName.toLowerCase();
                let nodeDatavalue = !!childNodeCount[c1].getAttribute("data-html")
                    ? childNodeCount[c1].getAttribute("data-html")
                    : !!childNodeCount[c1].getAttribute("data-text")
                    ? childNodeCount[c1].getAttribute("data-text")
                    : !!childNodeCount[c1].getAttribute("data-src")
                    ? childNodeCount[c1].getAttribute("data-src")
                    : "";
                if (nodeDatavalue && nodeDatavalue.includes(".pdf")) nodeDatavalue = "assets/projectresources/genericassets/placeholderimages/coverimage.jpg";
                if (childNodeCount[c1].hasAttribute("data-src") && childNodeCount[c1].getAttribute("data-src").includes("pdf")) childNodeCount[c1].setAttribute("data-src", nodeDatavalue);
                objDomContent[nodeName] = nodeDatavalue;
                let tagName = childNodeCount[c1].tagName.toLowerCase();
                !!childNodeCount[c1].getAttribute("data-csstext") ? (objDomContent[tagName + "style"] = childNodeCount[c1].getAttribute("data-csstext")) : "";
                !!childNodeCount[c1].getAttribute("data-logoimagesize") ? (objDomContent[tagName + "size"] = childNodeCount[c1].getAttribute("data-logoimagesize")) : "";
                if (tagName == "presenterlogoimage" && childNodeCount[c1].getAttribute("data-presenterlogodata")) {
                    //presenter Logo image aspect changes - logo type changes
                    try {
                        let arrValues = childNodeCount[c1].getAttribute("data-presenterlogodata").split(",");
                        let logotype = childNodeCount[c1].getAttribute("data-presenterlogotype") ? childNodeCount[c1].getAttribute("data-presenterlogotype") : "";
                        let finalURL = "";
                        arrValues.forEach((element) => {
                            if (element.split("___")[0].toUpperCase() == logotype.toUpperCase()) finalURL = element.split("___")[1];
                        });
                        if (finalURL != "") objDomContent[nodeName] = finalURL;
                    } catch (error) {
                        console.log("SG - Error on buildDomContentArray - error = " + error);
                    }
                }
                if (tagName == "customerlogoimage" && childNodeCount[c1].getAttribute("data-customerlogodata")) {
                    //Customer Logo image aspect changes - logo type changes
                    try {
                        let arrValues = childNodeCount[c1].getAttribute("data-customerlogodata").split(",");
                        let logotype = childNodeCount[c1].getAttribute("data-customerlogotype") ? childNodeCount[c1].getAttribute("data-customerlogotype") : "";
                        let finalURL = "";
                        arrValues.forEach((element) => {
                            if (element.split("___")[0].toUpperCase() == logotype.toUpperCase()) finalURL = element.split("___")[1];
                        });
                        if (finalURL != "") objDomContent[nodeName] = finalURL;
                    } catch (error) {
                        console.log("SG - Error on buildDomContentArray - error = " + error);
                    }
                }
                if (tagName == "logoimage" && childNodeCount[c1].getAttribute("data-logodata")) {
                    try {
                        let arrValues = childNodeCount[c1].getAttribute("data-logodata").split(",");
                        let logotype = childNodeCount[c1].getAttribute("data-logotype") ? childNodeCount[c1].getAttribute("data-logotype") : "";
                        let finalURL = "";
                        arrValues.forEach((element) => {
                            if (element.split("___")[0].toUpperCase() == logotype.toUpperCase()) finalURL = element.split("___")[1];
                        });
                        if (finalURL != "") objDomContent[nodeName] = finalURL;
                    } catch (error) {
                        console.log("SG - Error on buildDomContentArray - error = " + error);
                    }
                }
                !!childNodeCount[c1].getAttribute("data-csstext") ? (objDomContent[tagName + "style"] = childNodeCount[c1].getAttribute("data-csstext")) : "";
                !!childNodeCount[c1].getAttribute("data-logodata") ? (objDomContent[tagName + "data"] = childNodeCount[c1].getAttribute("data-logodata")) : "";
                !!childNodeCount[c1].getAttribute("data-logocontrast") ? (objDomContent[tagName + "contrast"] = childNodeCount[c1].getAttribute("data-logocontrast")) : "";
                !!childNodeCount[c1].getAttribute("data-logoprompt") ? (objDomContent[tagName + "prompt"] = childNodeCount[c1].getAttribute("data-logoprompt")) : "";
                !!childNodeCount[c1].getAttribute("data-customerlogodata") ? (objDomContent[tagName + "data"] = childNodeCount[c1].getAttribute("data-logodata")) : "";
                !!childNodeCount[c1].getAttribute("data-customerlogocontrast") ? (objDomContent[tagName + "contrast"] = childNodeCount[c1].getAttribute("data-logocontrast")) : "";
                !!childNodeCount[c1].getAttribute("data-customerlogoprompt") ? (objDomContent[tagName + "prompt"] = childNodeCount[c1].getAttribute("data-logoprompt")) : "";
                !!childNodeCount[c1].getAttribute("data-presenterlogodata") ? (objDomContent[tagName + "data"] = childNodeCount[c1].getAttribute("data-logodata")) : "";
                !!childNodeCount[c1].getAttribute("data-presenterlogocontrast") ? (objDomContent[tagName + "contrast"] = childNodeCount[c1].getAttribute("data-logocontrast")) : "";
                !!childNodeCount[c1].getAttribute("data-presenterlogoprompt") ? (objDomContent[tagName + "prompt"] = childNodeCount[c1].getAttribute("data-logoprompt")) : "";
                !!childNodeCount[c1].getAttribute("data-imageborder") ? (objDomContent[tagName + "border"] = childNodeCount[c1].getAttribute("data-imageborder")) : "";
                !!childNodeCount[c1].getAttribute("data-navigateurl") ? (objDomContent[tagName + "navigateurl"] = childNodeCount[c1].getAttribute("data-navigateurl")) : "";
                !!childNodeCount[c1].getAttribute("data-textposition") ? (objDomContent[tagName + "textposition"] = childNodeCount[c1].getAttribute("data-textposition")) : "";
                !!childNodeCount[c1].getAttribute("data-lineheight") ? (objDomContent[tagName + "lineheight"] = childNodeCount[c1].getAttribute("data-lineheight")) : "";
                !!childNodeCount[c1].getAttribute("data-letterspacing") ? (objDomContent[tagName + "letterspacing"] = childNodeCount[c1].getAttribute("data-letterspacing")) : "";
                !!childNodeCount[c1].getAttribute("user-font-size") ? (objDomContent[tagName + "-user-font-size"] = childNodeCount[c1].getAttribute("user-font-size")) : "";
                !!childNodeCount[c1].getAttribute("data-listtype") ? (objDomContent[tagName + "listtype"] = childNodeCount[c1].getAttribute("data-listtype")) : "";
                !!childNodeCount[c1].getAttribute("data-opacity") ? (objDomContent[tagName + "opacity"] = childNodeCount[c1].getAttribute("data-opacity")) : "";
                !!childNodeCount[c1].getAttribute("data-texttransform") ? (objDomContent[tagName + "texttransform"] = childNodeCount[c1].getAttribute("data-texttransform")) : "";
                !!childNodeCount[c1].getAttribute("data-textcolor") ? (objDomContent[tagName + "textcolor"] = childNodeCount[c1].getAttribute("data-textcolor")) : "";
                !!childNodeCount[c1].getAttribute("data-textalign") ? (objDomContent[tagName + "textalign"] = childNodeCount[c1].getAttribute("data-textalign")) : "";
                !!childNodeCount[c1].getAttribute("data-textgrayscale") ? (objDomContent[tagName + "textgrayscale"] = childNodeCount[c1].getAttribute("data-textgrayscale")) : "";
                !!childNodeCount[c1].getAttribute("data-placeholdertype") ? (objDomContent[tagName + "type"] = childNodeCount[c1].getAttribute("data-placeholdertype")) : "";
                !!childNodeCount[c1].getAttribute("data-placeholderimagesize") ? (objDomContent[tagName + "size"] = childNodeCount[c1].getAttribute("data-placeholderimagesize")) : "";
                !!childNodeCount[c1].getAttribute("data-placeholderalign") ? (objDomContent[tagName + "align"] = childNodeCount[c1].getAttribute("data-placeholderalign")) : "";
                !!childNodeCount[c1].getAttribute("data-imagesize") ? (objDomContent[tagName + "size"] = childNodeCount[c1].getAttribute("data-imagesize")) : "";
                !!childNodeCount[c1].getAttribute("data-listcontent") ? (objDomContent[tagName + "listcontent"] = childNodeCount[c1].getAttribute("data-listcontent")) : "";
                !!childNodeCount[c1].getAttribute("imagecaption") ? (objDomContent[tagName + "caption"] = childNodeCount[c1].getAttribute("imagecaption")) : "";
                !!childNodeCount[c1].getAttribute("imageoverlayshow") ? (objDomContent[tagName + "overlayshow"] = childNodeCount[c1].getAttribute("imageoverlayshow")) : "";
                !!childNodeCount[c1].getAttribute("imagecaptionshow") ? (objDomContent[tagName + "captionshow"] = childNodeCount[c1].getAttribute("imagecaptionshow")) : "";
                !!childNodeCount[c1].getAttribute("imagecaptionposition") ? (objDomContent[tagName + "captionposition"] = childNodeCount[c1].getAttribute("imagecaptionposition")) : "";
                !!childNodeCount[c1].getAttribute("dragvalue") ? (objDomContent[tagName + "dragvalue"] = childNodeCount[c1].getAttribute("dragvalue")) : "";
                !!childNodeCount[c1].getAttribute("data-rating") ? (objDomContent["rating"] = childNodeCount[c1].getAttribute("data-rating")) : "";
                !!childNodeCount[c1].getAttribute("data-mapurl") ? (objDomContent["mapurl"] = childNodeCount[c1].getAttribute("data-mapurl")) : "";
                !!childNodeCount[c1].getAttribute("data-secondary") ? (objDomContent["secondary"] = childNodeCount[c1].getAttribute("data-secondary")) : "";
                !!childNodeCount[c1].getAttribute("data-primary") ? (objDomContent["primary"] = childNodeCount[c1].getAttribute("data-primary")) : "";
                !!childNodeCount[c1].getAttribute("data-socialtype") ? (objDomContent["socialtype"] = childNodeCount[c1].getAttribute("data-socialtype")) : "";
                !!childNodeCount[c1].getAttribute("imagebleed") ? (objDomContent["imagebleed"] = childNodeCount[c1].getAttribute("imagebleed")) : "";
                !!childNodeCount[c1].getAttribute("coverimagecontrast") ? (objDomContent["coverimagecontrast"] = childNodeCount[c1].getAttribute("coverimagecontrast")) : "";
                !!childNodeCount[c1].getAttribute("data-textsize") ? (objDomContent[tagName + "textsize"] = childNodeCount[c1].getAttribute("data-textsize")) : "";
                !!childNodeCount[c1].getAttribute("data-imageprompt") ? (objDomContent[tagName + "imageprompt"] = childNodeCount[c1].getAttribute("data-imageprompt")) : "";
                !!childNodeCount[c1].getAttribute("imagefillsrc") ? (objDomContent["imagefillsrc"] = childNodeCount[c1].getAttribute("imagefillsrc")) : "";
                !!childNodeCount[c1].getAttribute("needassetupdate") ? (objDomContent[tagName + "needassetupdate"] = childNodeCount[c1].getAttribute("needassetupdate")) : "";
            }
            arrContentGroup.push(objDomContent);
        }
    }
    return arrContentGroup;
};
SpecialGraphicsUtils.prototype.removeAllFontClass = function (element) {
    let arrFontClassNames = ["h1", "h2", "h3", "h4", "h5", "h6", "h7", "h8", "h9", "h10", "h11", "h12", "p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "n1"];
    for (let i = 0; i < arrFontClassNames.length; i++) {
        element.classList.remove(arrFontClassNames[i]);
    }
};
SpecialGraphicsUtils.prototype.getClassNameFromNode = function (targetNode) {
    let className = null;
    if (targetNode && targetNode.classList.length > 0) {
        let classNameList = targetNode.classList;
        let arrFontClassNames = ["h1", "h2", "h3", "h4", "h5", "h6", "h7", "h8", "h9", "h10", "h11", "h12", "p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "n1"];
        for (let i = 0; i < arrFontClassNames.length; i++) {
            if (classNameList.contains(arrFontClassNames[i])) className = arrFontClassNames[i];
            if (classNameList.contains("grandhotel")) className = "h4";
            if (classNameList.contains("bebasneue")) className = "h3";
            if (classNameList.contains("sriracha")) className = "h5";
            if (classNameList.contains("niconne")) className = "h1";
            if (classNameList.contains("worksans")) className = "h1";
        }
    }
    return className;
};
SpecialGraphicsUtils.prototype.checkAndApplyFlipBleed = function (assetParent, sgParent, metaData, props, tagName) {
    if (assetParent && sgParent && metaData && props) {
        let deviceImageParentNode = assetParent.parentElement.querySelector("[id='deviceImageParentNode']");
        if (deviceImageParentNode) return;
        // Flip support check and apply flip
        let contentMainParent = assetParent.querySelector("[id='contentMainParent']");
        let animationDiv = sgParent.parentElement.parentElement;

        let isBleedEnabled = false;
        let isFlipEnabled = false;

        var slideDomContentGroup = animationDiv.querySelector("[id='AESpecialGraphics']");
        if (slideDomContentGroup && slideDomContentGroup.getElementsByTagName("node-0").length > 0) {
            let nodeData = slideDomContentGroup.getElementsByTagName("node-0")[0];
            let nodeDataList = nodeData.getElementsByTagName(tagName ? tagName : props.presetimage ? "presetimage" : "coverimage")[0];
            if (nodeDataList?.hasAttribute("imagebleed")) isBleedEnabled = nodeDataList.getAttribute("imagebleed") == "true";
        }

        let isFlipSupport = metaData?.isFlipSupport && metaData.isFlipSupport == "true" ? true : false;
        let isBleedSupport = metaData?.isBleedSupport && metaData.isBleedSupport == "true" ? true : false;
        if (tagName == "commonbg") isBleedSupport = metaData?.isCommonBgBleedSupport && metaData.isCommonBgBleedSupport == "true" ? true : false;
        let imagePosition = props?.imageposition ? props.imageposition : "";

        let finalShow = animationDiv.hasAttribute("data-ogdata-finalshow_0") ? animationDiv.getAttribute("data-ogdata-finalshow_0") : animationDiv.getAttribute("data-ogdata-finalshow");
        let isFlipEnabledOnFloater = finalShow?.split(",")?.includes("flip");
        if (isFlipEnabledOnFloater && contentMainParent && isFlipSupport) {
            contentMainParent.classList.add("sgFlipChild");

            let childrenCount = contentMainParent.children.length;
            if (childrenCount == 2) {
                contentMainParent.children[0].classList.add("flipChild1");
                contentMainParent.children[1].classList.add("flipChild2");
                isFlipEnabled = true;
            } else {
                for (let a = 0; a < childrenCount; a++) {
                    let count = 0;
                    for (let a = 0; a < childrenCount; a++) {
                        if (contentMainParent.children[a].style.position != "absolute" && count < 2) {
                            contentMainParent.children[count].classList.add("flipChild" + (count + 1));
                            count = count + 1;
                            isFlipEnabled = true;
                        }
                    }
                }
            }
        } else if (contentMainParent) contentMainParent.classList.remove("sgFlipChild");

        if (contentMainParent && imagePosition) {
            if (isFlipEnabled) imagePosition = imagePosition == "left" ? "right" : imagePosition == "right" ? "left" : imagePosition == "top" ? "bottom" : imagePosition == "bottom" ? "top" : "center";
            contentMainParent.setAttribute("data-imagePosition", imagePosition);
        }

        let coverParent = contentMainParent?.querySelector("[id*='coverParent']");
        if (coverParent) coverParent.removeAttribute("data-imagebleed");
        if (isBleedEnabled && contentMainParent && isBleedSupport) {
            contentMainParent.classList.add("sgImageBleedChild");
            if (coverParent) coverParent.setAttribute("data-imagebleed", "true");
            let childrenCount = contentMainParent.children.length;
            if (childrenCount == 2) {
                contentMainParent.children[0].classList.remove("flipChild1");
                contentMainParent.children[1].classList.remove("flipChild2");
                contentMainParent.children[0].classList.add("flipChild1");
                contentMainParent.children[1].classList.add("flipChild2");
            } else {
                for (let a = 0; a < childrenCount; a++) {
                    let count = 0;
                    for (let a = 0; a < childrenCount; a++) {
                        if (contentMainParent.children[a].style.position != "absolute" && count < 2) {
                            contentMainParent.children[count].classList.remove("flipChild" + (count + 1));
                            contentMainParent.children[count].classList.add("flipChild" + (count + 1));
                            count = count + 1;
                        }
                    }
                }
            }
            this.updateCoverImagePositions(contentMainParent);
        } else if (contentMainParent) {
            contentMainParent.classList.remove("sgImageBleedChild");
            this.updateCoverImagePositions(contentMainParent);
        }
    }
};

SpecialGraphicsUtils.prototype.getHeroTextDefaultContent = function (element) {
    if (element && element.classList.contains("retrotext")) return "Let \nType \nTALK";
    if (element && element.classList.contains("gradienttext")) return "NEW \nSEASON \nCOMES EARLIER";
    if (element && element.classList.contains("imagefill")) return "QUIETLY ELEGANT";
    if (element && element.classList.contains("animatedtextfill")) return "BROKEN";
    if (element && element.classList.contains("gradienttext")) return "NEW \nSEASON \nCOMES EARLIER";
    if (element && (element.classList.contains("dashedShadow") || element.classList.contains("outlinewithshadow") || element.classList.contains("outlinefillwithshadow"))) return "NOPE. \nNO FUNNY \nSLOGAN HERE";
};

SpecialGraphicsUtils.prototype.getLogoRatio = function (logoNode) {
    if (logoNode) {
        let _w = logoNode.naturalWidth;
        let _h = logoNode.naturalHeight;
        let ratio = _h / _w;
        let logoPan = "portrait";
        if (ratio >= 1.1) {
            logoPan = "portrait";
        } else if (ratio >= 0.9 && ratio < 1.1) {
            logoPan = "square";
        } else if (ratio >= 0.25 && ratio < 0.9) {
            logoPan = "wide";
        } else if (ratio <= 0.25) {
            logoPan = "extrawide";
        }
        return logoPan;
    }
    return null;
};

SpecialGraphicsUtils.prototype.mutationCallBack = function (mutations, element) {
    // console.log("mutationCallBack");
    for (let mutation of mutations) {
        if (mutation.type === "childList") {
            if (mutation.target.hasAttribute("name") && mutation.target.getAttribute("name").includes("secondaryText")) {
                if (mutation.target.innerHTML == "<br>" && mutation.target.parentElement && mutation.target.parentElement.children.length == 1) mutation.target.innerHTML = "";
                if (mutation.target.childElementCount == 0 && mutation.removedNodes.length > 0) {
                    let removeChild = mutation.removedNodes[0];
                    removeChild.innerText = "";
                    if (removeChild.nodeName == "LI") {
                        mutation.target.appendChild(removeChild);
                        element.setAttribute("data-mutation", "true");
                    }
                }
            } else {
                if (mutation.addedNodes.length > 0) {
                    let addedNode = mutation.addedNodes[0];
                    if (addedNode.nodeName == "DIV" && addedNode.parentElement) {
                        let insertParent = addedNode.parentElement;
                        if (addedNode.innerText == "\n") insertParent.insertBefore(document.createElement("br"), addedNode);
                        insertParent.insertBefore(document.createElement("br"), addedNode);
                        insertParent.replaceChild(document.createTextNode(addedNode.innerText), addedNode);
                        element.setAttribute("data-mutation", "true");
                    }
                }
            }
        }
    }
};

SpecialGraphicsUtils.prototype.removeTextPositionClass = function (targetParentElement) {
    if (targetParentElement) {
        targetParentElement.classList.remove("sgTL");
        targetParentElement.classList.remove("sgTR");
        targetParentElement.classList.remove("sgTM");
        targetParentElement.classList.remove("sgML");
        targetParentElement.classList.remove("sgMR");
        targetParentElement.classList.remove("sgMM");
        targetParentElement.classList.remove("sgBL");
        targetParentElement.classList.remove("sgBR");
        targetParentElement.classList.remove("sgBM");
    }
};
SpecialGraphicsUtils.prototype.getOldPositionClass = function (targetParentElement) {
    let arrClassList = targetParentElement.classList;
    if (arrClassList.contains("sgTL")) return "TL";
    if (arrClassList.contains("sgTR")) return "TR";
    if (arrClassList.contains("sgTM")) return "TM";
    if (arrClassList.contains("sgML")) return "ML";
    if (arrClassList.contains("sgMR")) return "MR";
    if (arrClassList.contains("sgMM")) return "MM";
    if (arrClassList.contains("sgBL")) return "BL";
    if (arrClassList.contains("sgBR")) return "BR";
    if (arrClassList.contains("sgBM")) return "BM";
    return "";
};
SpecialGraphicsUtils.prototype.getPadding = function (element) {
    let objPadding = { paddingLeft: 0, paddingRight: 0, paddingTop: 0, paddingBottom: 0 };
    if (element) {
        let elementStyle = window.getComputedStyle(element);
        objPadding.paddingLeft = elementStyle.paddingLeft;
        objPadding.paddingRight = elementStyle.paddingRight;
        objPadding.paddingTop = elementStyle.paddingTop;
        objPadding.paddingBottom = elementStyle.paddingBottom;
    }
    return objPadding;
};
SpecialGraphicsUtils.prototype.getMargin = function (element) {
    let objmargin = { marginLeft: 0, marginRight: 0, marginTop: 0, marginBottom: 0 };
    if (element) {
        let elementStyle = window.getComputedStyle(element);
        objmargin.marginLeft = elementStyle.marginLeft;
        objmargin.marginRight = elementStyle.marginRight;
        objmargin.marginTop = elementStyle.marginTop;
        objmargin.marginBottom = elementStyle.marginBottom;
    }
    return objmargin;
};
SpecialGraphicsUtils.prototype.assignAttributes = function (node, attrs, unitCheck) {
    for (let i1 in attrs) {
        let ns = i1.substr(0, 4) === "xml:" ? "http://www.w3.org/2000/xmlns/" : i1.substr(0, 6) === "xlink:" ? "http://www.w3.org/1999/xlink" : null;
        try {
            if (ns) {
                node.setAttributeNS(ns, i1, attrs[i1]);
            } else if (!unitCheck && node) {
                node.setAttribute(i1, attrs[i1]);
            }
        } catch (error) {
            console.log(error);
        }
    }
};
SpecialGraphicsUtils.prototype.getRndInteger = function (min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
};
// SpecialGraphicsUtils.prototype.splitMapDetails = function (mapURL) {
//     if (!mapURL) return null;
//     else {
//         let hasMapType = mapURL.includes("&maptype");
//         let lightTheme =
//             "&style=element:geometry|color:0xf5f5f5&style=element:labels.icon|visibility:off&style=element:labels.text.fill|color:0x616161&style=element:labels.text.stroke|color:0xf5f5f5&style=feature:administrative.land_parcel|element:labels.text.fill|color:0xbdbdbd&style=feature:poi|element:geometry|color:0xeeeeee&style=feature:poi|element:labels.text.fill|color:0x757575&style=feature:poi.park|element:geometry|color:0xe5e5e5&style=feature:poi.park|element:labels.text.fill|color:0x9e9e9e&style=feature:road|element:geometry|color:0xffffff&style=feature:road.arterial|element:labels.text.fill|color:0x757575&style=feature:road.highway|element:geometry|color:0xdadada&style=feature:road.highway|element:labels.text.fill|color:0x616161&style=feature:road.local|element:labels.text.fill|color:0x9e9e9e&style=feature:transit.line|element:geometry|color:0xe5e5e5&style=feature:transit.station|element:geometry|color:0xeeeeee&style=feature:water|element:geometry|color:0xc9c9c9&style=feature:water|element:labels.text.fill|color:0x9e9e9e";
//         let darkTheme =
//             "&style=element:geometry|color:0x212121&style=element:labels.icon|visibility:off&style=element:labels.text.fill|color:0x757575&style=element:labels.text.stroke|color:0x212121&style=feature:administrative|element:geometry|color:0x757575&style=feature:administrative.country|element:labels.text.fill|color:0x9e9e9e&style=feature:administrative.land_parcel|visibility:off&style=feature:administrative.locality|element:labels.text.fill|color:0xbdbdbd&style=feature:poi|element:labels.text.fill|color:0x757575&style=feature:poi.park|element:geometry|color:0x181818&style=feature:poi.park|element:labels.text.fill|color:0x616161&style=feature:poi.park|element:labels.text.stroke|color:0x1b1b1b&style=feature:road|element:geometry.fill|color:0x2c2c2c&style=feature:road|element:labels.text.fill|color:0x8a8a8a&style=feature:road.arterial|element:geometry|color:0x373737&style=feature:road.highway|element:geometry|color:0x3c3c3c&style=feature:road.highway.controlled_access|element:geometry|color:0x4e4e4e&style=feature:road.local|element:labels.text.fill|color:0x616161&style=feature:transit|element:labels.text.fill|color:0x757575&style=feature:water|element:geometry|color:0x000000&style=feature:water|element:labels.text.fill|color:0x3d3d3d";
//         let retroTheme =
//             "&style=element:geometry|color:0xebe3cd&style=element:labels.text.fill|color:0x523735&style=element:labels.text.stroke|color:0xf5f1e6&style=feature:administrative|element:geometry.stroke|color:0xc9b2a6&style=feature:administrative.land_parcel|element:geometry.stroke|color:0xdcd2be&style=feature:administrative.land_parcel|element:labels.text.fill|color:0xae9e90&style=feature:landscape.natural|element:geometry|color:0xdfd2ae&style=feature:poi|element:geometry|color:0xdfd2ae&style=feature:poi|element:labels.text.fill|color:0x93817c&style=feature:poi.park|element:geometry.fill|color:0xa5b076&style=feature:poi.park|element:labels.text.fill|color:0x447530&style=feature:road|element:geometry|color:0xf5f1e6&style=feature:road.arterial|element:geometry|color:0xfdfcf8&style=feature:road.highway|element:geometry|color:0xf8c967&style=feature:road.highway|element:geometry.stroke|color:0xe9bc62&style=feature:road.highway.controlled_access|element:geometry|color:0xe98d58&style=feature:road.highway.controlled_access|element:geometry.stroke|color:0xdb8555&style=feature:road.local|element:labels.text.fill|color:0x806b63&style=feature:transit.line|element:geometry|color:0xdfd2ae&style=feature:transit.line|element:labels.text.fill|color:0x8f7d77&style=feature:transit.line|element:labels.text.stroke|color:0xebe3cd&style=feature:transit.station|element:geometry|color:0xdfd2ae&style=feature:water|element:geometry.fill|color:0xb9d3c2&style=feature:water|element:labels.text.fill|color:0x92998d";
//         let mapTag = hasMapType ? "&maptype=" : "&style=";

//         let mapData = {};
//         mapData.baseURL = mapURL.substr(0, mapURL.indexOf("?") + 1);
//         let place = mapURL.substr(mapURL.indexOf("center=") + 7, mapURL.indexOf("&key") - mapURL.indexOf("center=") - 7);
//         mapData.place = decodeURIComponent(place);
//         mapData.key = mapURL.substr(mapURL.indexOf("&key=") + 5, mapURL.indexOf("&size") - mapURL.indexOf("&key=") - 5);
//         mapData.size = mapURL.substr(mapURL.indexOf("&size=") + 6, mapURL.indexOf("&scale") - mapURL.indexOf("&size=") - 6);
//         mapData.scale = mapURL.substr(mapURL.indexOf("&scale=") + 7, mapURL.indexOf("&zoom") - mapURL.indexOf("&scale=") - 7);
//         mapData.zoom = mapURL.substr(mapURL.indexOf("&zoom=") + 6, mapURL.indexOf("&language") - mapURL.indexOf("&zoom=") - 6);
//         mapData.language = mapURL.substr(mapURL.indexOf("&language=") + 10, mapURL.indexOf("&markers") - mapURL.indexOf("&language=") - 10);
//         mapData.marker = mapURL.substr(mapURL.indexOf("&markers="), mapURL.indexOf(mapTag) - mapURL.indexOf("&markers=") - 9);
//         let type = mapURL.substr(mapURL.indexOf(mapTag) + (hasMapType ? mapTag.length : 0), mapURL.length - mapURL.indexOf(mapTag) - (hasMapType ? mapTag.length : 0));
//         mapData.maptype = type == lightTheme ? "light" : type == darkTheme ? "dark" : type == retroTheme ? "retro" : type;
//         console.log(mapData);
//         return mapData;
//     }
// };
SpecialGraphicsUtils.prototype.getMoodBasedVideo = function (objDataToSG) {
    let videoPropFromMood = objDataToSG && objDataToSG.sgMoodsData && objDataToSG.sgMoodsData.presetvideo ? objDataToSG.sgMoodsData.presetvideo : null;
    if (videoPropFromMood && videoPropFromMood["url"]) return videoPropFromMood["url"];
    else return null;
};

SpecialGraphicsUtils.prototype.getImageSizeSML = function (sizeV) {
    if (!sizeV) return sizeV;
    let sizeValue = sizeV == "small" ? 0.2 : sizeV == "medium" ? 0.7 : sizeV == "large" ? 1 : parseFloat(sizeV);
    if (!isNaN(sizeValue) && sizeValue > 0) return sizeValue;
    return 0.7;
};

SpecialGraphicsUtils.prototype.setImageCaptionPosition = function (coverImageParent, currentIndex, sgData, props, tagName = "coverimage") {
    if (!sgData || !sgData || !props) return;
    let captionPosition = sgData[currentIndex] && sgData[currentIndex][tagName + "captionposition"] ? sgData[currentIndex][tagName + "captionposition"] : props.captionposition ? props.captionposition : "bottomleft";
    if (captionPosition && coverImageParent?.querySelector("[id*='imageCaption']")) {
        let imageCaption = coverImageParent.querySelector("[id*='imageCaption']");
        let cls = captionPosition == "topleft" || captionPosition == "captionTL" ? "captionTL" : captionPosition == "topright" || captionPosition == "captionTR" ? "captionTR" : captionPosition == "bottomright" || captionPosition == "captionBR" ? "captionBR" : "captionBL";
        imageCaption.classList.remove("captionTL");
        imageCaption.classList.remove("captionTR");
        imageCaption.classList.remove("captionBL");
        imageCaption.classList.remove("captionBR");
        imageCaption.classList.add(cls);
    }
};

SpecialGraphicsUtils.prototype.getNodeColor = function (objData, name, propColor) {
    if (propColor) {
        if (propColor.includes("var(") || propColor.includes("gradient")) return propColor;
        else return "rgba(var(--" + propColor + "-color-rgb),1)";
    }
    if (objData && objData.theme && objData.theme.textcolormapping) if (objData.theme.textcolormapping[name]) return objData.theme.textcolormapping[name];
    return null;
};
SpecialGraphicsUtils.prototype.getDeviceAssetPath = function (assetName) {
    if (assetName == "iphonezoom") return "iphone";
    if (assetName == "googlephone") return "android";
    if (assetName == "googlephonezoom") return "android";
    if (assetName == "iphoneinhand") return "handinphone";
    if (assetName == "tabletzoom") return "tablet";
    if (assetName == "tv") return "television";
    return assetName;
};
SpecialGraphicsUtils.prototype.applyClassNamesFromString = function (node, className) {
    if (node && className && !className.includes(" ")) {
        node.classList.add(className);
    } else if (node && className && className.split(" ")) {
        let arrClasses = className.split(" ");
        for (let a = 0; a < arrClasses.length; a++) {
            node.classList.add(arrClasses[a].trim());
        }
    }
};
SpecialGraphicsUtils.prototype.updatePaddingMarginInlineStyle = function (nodeParent) {
    if (!nodeParent) return;
    let styleData = window.getComputedStyle(nodeParent);
    nodeParent.style.setProperty("--paddingLeft", styleData.paddingLeft);
    nodeParent.style.setProperty("--paddingRight", styleData.paddingRight);
    nodeParent.style.setProperty("--paddingTop", styleData.paddingTop);
    nodeParent.style.setProperty("--paddingBottom", styleData.paddingBottom);
    nodeParent.style.setProperty("--marginLeft", styleData.marginLeft);
    nodeParent.style.setProperty("--marginRight", styleData.marginRight);
    nodeParent.style.setProperty("--marginTop", styleData.marginTop);
    nodeParent.style.setProperty("--marginBottom", styleData.marginBottom);
};
SpecialGraphicsUtils.prototype.applyContrastToShape = function (element, property) {
    if (property?.contrast && (property.contrast == "true" || property.contrast == true) && element) element.setAttribute("data-supportbgcontrast", "true");
    else if (element) element.removeAttribute("data-supportbgcontrast");
};

SpecialGraphicsUtils.prototype.scrollIntoView = function (parent, child, childWithNonActive, isPrev, scrollRight = false) {
    let childWithNonActiveStyle = window.getComputedStyle(child);
    let reducingValue = childWithNonActiveStyle ? child.offsetHeight + parseFloat(childWithNonActiveStyle.marginTop) + parseFloat(childWithNonActiveStyle.marginBottom) : null;
    if (scrollRight) reducingValue = childWithNonActiveStyle ? child.offsetWidth + parseFloat(childWithNonActiveStyle.marginLeft) + parseFloat(childWithNonActiveStyle.marginRight) : null;

    if (isPrev && reducingValue) this.scrollToSG(parent, -reducingValue, 300, scrollRight);
    else if (!isPrev && reducingValue) this.scrollToSG(parent, reducingValue, 300, scrollRight);
};

SpecialGraphicsUtils.prototype.scrollToSG = function (element, to, duration, scrollRight = false) {
    let start = scrollRight ? element.scrollLeft : element.scrollTop,
        currentTime = 0,
        increment = 50;

    let cntx = this;
    let animateScroll = function () {
        currentTime += increment;

        let val = cntx.easeInOutQuad(currentTime, start, to, duration);
        if (scrollRight) element.scrollLeft = val;
        else element.scrollTop = val;

        if (currentTime < duration) setTimeout(animateScroll, increment);
    };

    animateScroll();
};
// Function for smooth scroll animation with the time duration
SpecialGraphicsUtils.prototype.easeInOutQuad = function (time, startPos, endPos, duration) {
    time /= duration / 2;

    if (time < 1) return (endPos / 2) * time * time + startPos;
    time--;
    return (-endPos / 2) * (time * (time - 2) - 1) + startPos;
};
SpecialGraphicsUtils.prototype.replaceHighlightThings = function (modifiedString) {
    modifiedString = modifiedString.replaceAll("^^", "").replaceAll("~~", "").replaceAll("``", "").replaceAll("__", "").replaceAll("!!", "").replaceAll("**", "").replaceAll("*_", "").replaceAll("[", "").replaceAll("]", "");

    return modifiedString;
};
SpecialGraphicsUtils.prototype.checkAppStaticURLSG = function (imageURL, appStaticURL) {
    if (imageURL?.includes("assets/projectresources/assets/projectresources/")) imageURL = imageURL.replace("assets/projectresources/assets/projectresources/", "assets/projectresources/");
    return imageURL?.startsWith("http") || imageURL?.startsWith(appStaticURL) ? imageURL : appStaticURL + imageURL;
};
SpecialGraphicsUtils.prototype.updateOnDummyDiv = function (mainParent, index = 0, tagName) {
    var slideDomContentGroup = mainParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
    if (slideDomContentGroup && slideDomContentGroup.getElementsByTagName("node-" + index).length > 0) {
        let nodeData = slideDomContentGroup.getElementsByTagName("node-" + index)[0];
        let nodeDataList = nodeData.getElementsByTagName(tagName ? tagName : "coverimage")?.[0];
        if (nodeDataList) {
            nodeDataList.removeAttribute("needassetupdate");
            nodeDataList.removeAttribute(tagName + "needassetupdate");
        }
    }
};
SpecialGraphicsUtils.prototype.getStartIndex = function (currentSlideData, sgParentLocal) {
    let presentParent = currentSlideData ? currentSlideData : sgParentLocal;
    let assetParent = presentParent ? presentParent.querySelector("[id='assetParent0']") : null;
    let sgParent = presentParent ? presentParent.querySelector("[id='specialgraphicsParent']") : sgParentLocal;

    let isNotVisible = assetParent?.style?.display == "none" || assetParent?.style?.opacity == 0 || assetParent?.style?.opacity == "0";
    if (isNotVisible) sgParent.setAttribute("startindex", "1");
    else sgParent.removeAttribute("startindex");

    let localParent = sgParent ? sgParent : sgParentLocal;
    let animationDIV = localParent?.parentElement?.parentElement ? localParent.parentElement.parentElement : null;
    let showIntro = animationDIV.getAttribute("data-ogdata-finalshow_0")?.split(",")?.includes("intro") ? "true" : "false";
    return (isNotVisible || !assetParent) && showIntro != "true" ? 1 : 0;
};

"use strict";

function SpecialgraphicsPropertyUtils(appStaticURL, instance = null) {
    this.specialGraphicsUtils = new window["SpecialGraphicsUtils"]();
    this.moodShapeSvgLoadComplete = this.moodShapeSvgLoadComplete.bind(this);
    this.imageMaskSvgLoadComplete = this.imageMaskSvgLoadComplete.bind(this);
    this.appStaticURL = appStaticURL;
    this.instance = instance;
}

SpecialgraphicsPropertyUtils.prototype.assignBaseProps = function (objProps) {
    if (objProps?.slideWidth) this.slideWidth = objProps.slideWidth;
    if (objProps?.slideHeight) this.slideHeight = objProps.slideHeight;
};

SpecialgraphicsPropertyUtils.prototype.getMoodPadding = function (assetParent) {
    let dummy = document.createElement("div");
    assetParent.appendChild(dummy);
    dummy.style.padding = "var(--mood-padding)";
    let styleNode = window.getComputedStyle(dummy);
    let obj = {};
    obj.top = isNaN(parseFloat(styleNode.paddingTop)) ? 0 : parseFloat(styleNode.paddingTop);
    obj.right = isNaN(parseFloat(styleNode.paddingRight)) ? 0 : parseFloat(styleNode.paddingRight);
    obj.bottom = isNaN(parseFloat(styleNode.paddingBottom)) ? 0 : parseFloat(styleNode.paddingBottom);
    obj.left = isNaN(parseFloat(styleNode.paddingLeft)) ? 0 : parseFloat(styleNode.paddingLeft);
    assetParent.removeChild(dummy);
    return obj;
};

SpecialgraphicsPropertyUtils.prototype.updateProperties = function (assetParent, metaData, arrAssets, index) {
    if (metaData && assetParent) {
        let assetImageParent = assetParent.querySelector("[id='assetImageParent']");
        let textBaseParentNode = assetParent.querySelector("[id='textBaseParentNode']");
        let textParent = assetParent.querySelector("[id='textParent']");
        let textInnerParentNode = assetParent.querySelector("[id='textInnerParentNode']");
        let sgNumberTextNode = assetParent.querySelector("[id='sgNumberTextNode']");
        let textElementParentSG = assetParent.querySelector("[id='textElementParentSG']");
        let deviceImageParentNode = assetParent.parentElement.querySelector("[id='deviceImageParentNode']");

        if (assetParent.classList.contains("introSlide")) {
            //Apply mood padding to intro slide
            let moodPaddingValue = this.getMoodPadding(assetParent);

            assetParent.style.setProperty("--intoTextPadding", moodPaddingValue.top + "px " + moodPaddingValue.right + "px " + moodPaddingValue.bottom + "px " + moodPaddingValue.left + "px");
            textBaseParentNode.style.setProperty("width", "calc(100% - " + (moodPaddingValue.right + moodPaddingValue.left) + "px)", "important");
            textBaseParentNode.style.setProperty("height", "calc(100% - " + (moodPaddingValue.top + moodPaddingValue.bottom) + "px)", "important");
        }
        //Image Properties
        if (metaData.image) {
            let imageProperty = metaData.image;
            this.applyImageProperties(imageProperty, assetParent, index, false);
        }
        //Background image properties
        if (deviceImageParentNode && metaData.bgimage) {
            let property = metaData.bgimage;
            if (property.image1) {
                let imgProperty = property.image1;
                if (imgProperty.position) {
                    let arrPosition = imgProperty.position.split(",");
                    if (arrPosition.length >= 4 && deviceImageParentNode) {
                        deviceImageParentNode.style.setProperty("--bgLeft", arrPosition[0] + this.getSuffixForPositiom(arrPosition[0]));
                        deviceImageParentNode.style.setProperty("--bgTop", arrPosition[1] + this.getSuffixForPositiom(arrPosition[1]));
                        deviceImageParentNode.style.setProperty("--bgWidth", arrPosition[2] + this.getSuffixForPositiom(arrPosition[2]));
                        deviceImageParentNode.style.setProperty("--bgHeight", arrPosition[3] + this.getSuffixForPositiom(arrPosition[3]));
                    }
                }
                if (imgProperty.filter) deviceImageParentNode.style.setProperty("--bgFilter", imgProperty.filter);
                if (imgProperty.blend) deviceImageParentNode.style.setProperty("--bgBlend", imgProperty.blend);
                if (imgProperty.opacity) {
                    deviceImageParentNode.style.setProperty("--bgOpacity", imgProperty.opacity);
                    let bgImageNode = assetImageParent.querySelector("[id='bgImageNode']");
                    if (bgImageNode) this.specialGraphicsUtils.setOpacityAttribute(bgImageNode);
                }
                if (imgProperty.zorder) deviceImageParentNode.style.setProperty("--bgZorder", imgProperty.zorder);
            }
            if (property.image2) {
                let imgProperty = property.image2;
                if (imgProperty.position) {
                    let arrPosition = imgProperty.position.split(",");
                    if (arrPosition.length >= 4 && deviceImageParentNode) {
                        deviceImageParentNode.style.setProperty("--bg2Left", arrPosition[0] + this.getSuffixForPositiom(arrPosition[0]));
                        deviceImageParentNode.style.setProperty("--bg2Top", arrPosition[1] + this.getSuffixForPositiom(arrPosition[1]));
                        deviceImageParentNode.style.setProperty("--bg2Width", arrPosition[2] + this.getSuffixForPositiom(arrPosition[2]));
                        deviceImageParentNode.style.setProperty("--bg2Height", arrPosition[3] + this.getSuffixForPositiom(arrPosition[3]));
                    }
                }
                if (imgProperty.filter) deviceImageParentNode.style.setProperty("--bg2Filter", imgProperty.filter);
                if (imgProperty.blend) deviceImageParentNode.style.setProperty("--bg2Blend", imgProperty.blend);
                if (imgProperty.opacity) {
                    deviceImageParentNode.style.setProperty("--bg2Opacity", imgProperty.opacity);
                    let bgImage2Node = assetImageParent.querySelector("[id='bgImage2Node']");
                    if (bgImage2Node) this.specialGraphicsUtils.setOpacityAttribute(bgImage2Node);
                }
                if (imgProperty.zorder) deviceImageParentNode.style.setProperty("--bg2Zorder", imgProperty.zorder);
            }

            this.updatePerspective(property, deviceImageParentNode);
        }
        //Applying text properties
        this.applyTextProperties(metaData, assetParent, index);
        //Mood shape properties
        this.applyMoodShapeProperties(metaData, assetParent, index);
        //Number Properties
        this.applyNumberProperties(metaData, sgNumberTextNode, assetParent, index);
        this.applyPointImageNodeProperties(metaData, assetParent, index);
        this.applyDuplicateImageProperties(metaData, assetParent, index);
    }
};
SpecialgraphicsPropertyUtils.prototype.commonShapeProperties = function (property, element, assetParent, index) {
    if (!property || !element) return;
    let arrShapesAssets = [];
    arrShapesAssets = this.applyShapeInnerProperties(assetParent, index, property, element, arrShapesAssets, index);
    if (arrShapesAssets.length > 0) {
        if (this.instance && this.instance.arrCommonAssets) {
            let objData = { array: arrShapesAssets, callback: this.moodShapeSvgLoadComplete };
            this.instance.arrCommonAssets.push(objData);
        } else this.loadSvgAssets(arrShapesAssets, this.moodShapeSvgLoadComplete);
    }
};
SpecialgraphicsPropertyUtils.prototype.applyMoodShapeProperties = function (metaData, assetParent, index, isDirectProp = false, isSingleProp = false, singlePropIndex = -1) {
    //Mood shape properties
    if (metaData && (metaData || isDirectProp == true)) {
        let moodshapeData = metaData && metaData.moodshape ? metaData.moodshape : null;
        if (isDirectProp == true) moodshapeData = metaData;
        if (assetParent.classList.contains("introSlide") && metaData && metaData.intro) {
            let textAlignment = window.getComputedStyle(assetParent.querySelector("[id='sgTitleNode']")).textAlign;
            textAlignment = textAlignment == "start" || textAlignment == "left" ? "left" : textAlignment == "end" || textAlignment == "right" ? "right" : "center";
            if (metaData.intro[textAlignment]) moodshapeData = metaData.intro[textAlignment];
        }
        if (moodshapeData) {
            let property = moodshapeData;
            //Covershape 1,2,3 properties
            let arrShapesAssets = [];
            if (isSingleProp == true && singlePropIndex >= 0) {
                let shape = assetParent.querySelector("[id='shape" + singlePropIndex + "']");
                arrShapesAssets = this.applyShapeInnerProperties(assetParent, singlePropIndex, property, shape, arrShapesAssets, 0, "--shape");
            } else
                for (let a = 1; a <= Object.keys(property).length; a++) {
                    if (property["shape" + a]) {
                        let shapeProperty = property["shape" + a];
                        let shape = assetParent.querySelector("[id='covershape" + a + "']");
                        arrShapesAssets = this.applyShapeInnerProperties(assetParent, a, shapeProperty, shape, arrShapesAssets, index, "--covershape");
                    }
                }
            if (arrShapesAssets.length > 0) {
                if (this.instance && this.instance.arrCommonAssets) {
                    let objData = { array: arrShapesAssets, callback: this.moodShapeSvgLoadComplete };
                    this.instance.arrCommonAssets.push(objData);
                } else this.loadSvgAssets(arrShapesAssets, this.moodShapeSvgLoadComplete);
            }
        }
    }
};
SpecialgraphicsPropertyUtils.prototype.applyShapeInnerProperties = function (assetParent, a, shapeProperty, shape, arrShapesAssets, index, propertyName) {
    if (shapeProperty.position && shapeProperty.position.split(",").length == 4) {
        if (propertyName) this.updateShapeProperties(shapeProperty.position, assetParent, a, propertyName);
        else if (shape) {
            let arrShapePos = shapeProperty.position.split(",");
            shape.style.Left = arrShapePos[0] + this.getSuffixForPositiom(arrShapePos[0]);
            shape.style.top = arrShapePos[1] + this.getSuffixForPositiom(arrShapePos[1]);
            shape.style.width = arrShapePos[2] + this.getSuffixForPositiom(arrShapePos[2]);
            shape.style.height = arrShapePos[3] + this.getSuffixForPositiom(arrShapePos[3]);
        }
    }
    if (shapeProperty.radius) {
        if (shapeProperty.radius.includes(",") && shapeProperty.radius.split(",").length == 4) {
            let radiusValue = shapeProperty.radius.split(",");
            if (propertyName) assetParent.style.setProperty(propertyName + a + "Radius", radiusValue[0] + "px " + radiusValue[1] + "px " + radiusValue[2] + "px " + radiusValue[3] + "px");
            else if (shape) shape.style.borderRadius = radiusValue[0] + "px " + radiusValue[1] + "px " + radiusValue[2] + "px " + radiusValue[3] + "px";
        } else {
            if (propertyName) assetParent.style.setProperty(propertyName + a + "Radius", shapeProperty.radius);
            else if (shape) shape.style.borderRadius = shapeProperty.radius;
        }
    }
    if (shapeProperty.zorder) {
        if (propertyName) assetParent.style.setProperty(propertyName + a + "ZOrder", shapeProperty.zorder);
        else if (shape) shape.style.zIndex = shapeProperty.zorder;
    }
    if (shapeProperty.class) this.specialGraphicsUtils.applyClassNamesFromString(shape, shapeProperty.class);
    if (shapeProperty.shadow && shape) shape.style.boxShadow = shapeProperty.shadow;
    if (shapeProperty.positionvalue && shape) shape.style.position = shapeProperty.positionvalue;
    if (shapeProperty.filter && shape) shape.style.filter = shapeProperty.filter;
    if (shapeProperty.border && shape) {
        shape.style.border = shapeProperty.border;
        shape.style.setProperty("box-sizing", "border-box");
    }
    let applyOp = true;
    if (shapeProperty.color) {
        if (shapeProperty.color.includes("gradient") && shape) {
            shape.style.setProperty("background-color", "unset", "important");
            shape.style.setProperty("background", shapeProperty.color, "important");
        } else {
            let op = shapeProperty.opacity != undefined ? shapeProperty.opacity : 1;
            applyOp = false;
            if (propertyName) assetParent.style.setProperty(propertyName + a + "Color", "rgba(var(--" + shapeProperty.color + "-color-rgb)," + op + ")");
            else if (shape) shape.style.backgroundColor = "rgba(var(--" + shapeProperty.color + "-color-rgb)," + op + ")";
        }
    }
    if (shapeProperty.opacity && applyOp) {
        if (propertyName) assetParent.style.setProperty(propertyName + a + "Opacity", shapeProperty.opacity);
        else if (shape) shape.style.opacity = shapeProperty.opacity;
    }
    if (shape) this.specialGraphicsUtils.setOpacityAttribute(shape);
    if (shapeProperty.depends && shape) {
        let dependParent = assetParent.querySelector("[id='" + shapeProperty.depends + "']");
        if (dependParent) {
            shape.parentElement.removeChild(shape);
            dependParent.appendChild(shape);
        }
    }
    if (shapeProperty.mask) {
        let clipPathID = shapeProperty.mask.substr(shapeProperty.mask.lastIndexOf("/") + 1);
        let arrAssets = [];
        arrAssets.push({
            assetImageParent: shape,
            url: shapeProperty.mask,
            type: "SVG",
            index: a,
            parent: assetParent.parentElement,
            clipPathID: clipPathID.replace(".svg", "-clip-path"),
        });

        if (this.instance && this.instance.arrCommonAssets) {
            let objData = { array: arrAssets, callback: this.imageMaskSvgLoadComplete };
            this.instance.arrCommonAssets.push(objData);
        } else this.loadSvgAssets(arrAssets, this.imageMaskSvgLoadComplete);
    }
    if (shapeProperty.type && shapeProperty.type == "svg" && shapeProperty.svgname) {
        var svgPath = shapeProperty.svgname;
        arrShapesAssets.push({
            type: "json",
            url: svgPath,
            id: "coverShapeSvg",
            type: "SVG",
            shapeId: !propertyName && shape ? shape.id : (propertyName == "--shape" ? "shape" : "covershape") + a,
            index: index,
            parent: assetParent.parentElement,
        });
        if (propertyName) assetParent.style.setProperty(propertyName + a + "Color", "unset");
        else if (shape) shape.style.removeProperty("background-color");
        if (shapeProperty.color && shape) {
            shape.classList.add(shapeProperty.color + "-fill");
            shape.classList.add(shapeProperty.color + "-stroke");
        }
    }
    if (shapeProperty.nested && shape.querySelector("[id*='covershapeInner']")) {
        shapeProperty = shapeProperty.nested;
        propertyName = "--covershapeInner";
        shape = shape.querySelector("[id*='covershapeInner']");
        if (shapeProperty.position && shapeProperty.position.split(",").length == 4) this.updateShapeProperties(shapeProperty.position, assetParent, a, propertyName);
        if (shapeProperty.opacity) assetParent.style.setProperty(propertyName + a + "Opacity", shapeProperty.opacity);
        if (shapeProperty.radius) {
            if (shapeProperty.radius.includes(",") && shapeProperty.radius.split(",").length == 4) {
                let radiusValue = shapeProperty.radius.split(",");
                assetParent.style.setProperty(propertyName + a + "Radius", radiusValue[0] + "px " + radiusValue[1] + "px " + radiusValue[2] + "px " + radiusValue[3] + "px");
            } else assetParent.style.setProperty(propertyName + a + "Radius", shapeProperty.radius);
        }
        if (shapeProperty.zorder) assetParent.style.setProperty(propertyName + a + "ZOrder", shapeProperty.zorder);
        if (shapeProperty.shadow && shape) shape.style.boxShadow = shapeProperty.shadow;
        if (shapeProperty.border && shape) {
            shape.style.border = shapeProperty.border;
            shape.style.setProperty("box-sizing", "border-box");
        }
        if (shapeProperty.color) {
            if (shapeProperty.color.includes("gradient") && shape) {
                shape.style.setProperty("background-color", "unset", "important");
                shape.style.setProperty("background", shapeProperty.color, "important");
            } else assetParent.style.setProperty(propertyName + a + "Color", "rgba(var(--" + shapeProperty.color + "-color-rgb),1)");
        }
        if (shape) this.specialGraphicsUtils.setOpacityAttribute(shape);
        if (shapeProperty.type && shapeProperty.type == "svg" && shapeProperty.svgname && shape) {
            var svgPath = shapeProperty.svgname;
            arrShapesAssets.push({ type: "json", url: svgPath, id: "coverShapeSvg", type: "SVG", shapeId: shape.id, index: index, parent: assetParent.parentElement });
            assetParent.style.setProperty(propertyName + a + "Color", "unset");
            if (shapeProperty.color) {
                shape.classList.add(shapeProperty.color + "-fill");
                shape.classList.add(shapeProperty.color + "-stroke");
            }
        }
    }
    this.specialGraphicsUtils.applyContrastToShape(shape, shapeProperty);
    return arrShapesAssets;
};

SpecialgraphicsPropertyUtils.prototype.applyPointImageNodeProperties = function (metaData, assetParent, index) {
    if (metaData.pointimage) {
        let imageProperty = metaData.pointimage;
        let assetParentIndex = parseFloat(assetParent.id.replace("assetParent", ""));
        let imagePosition = Object.keys(imageProperty).length == 1 ? 1 : ((assetParentIndex - 1) % Object.keys(imageProperty).length) + 1;

        let property = imageProperty["image" + imagePosition];
        if (!assetParent.classList.contains("introSlide") && property != null && property != undefined) {
            let assetImageParent = assetParent.querySelector("[id='assetImageParent']");
            let coverimage = assetImageParent.querySelector("[data-target-id='coverimage']");
            if (property.position && assetImageParent) this.updateImagePosition(assetImageParent, property.position);
            if (property.opacity) {
                assetParent.style.setProperty("--coverOpacity", property.opacity);
                if (coverimage) this.specialGraphicsUtils.setOpacityAttribute(coverimage);
            }
            if (property.image) coverimage.src = this.appStaticURL + property.image;
            if (property.shadow) assetParent.style.setProperty("--coverImageShadow", property.shadow);
            let coverImageParent = assetParent.querySelector("[id='coverImageParent']");
            if (property.border) {
                assetParent.style.setProperty("--coverImageBorder", property.border);
                if (coverImageParent) coverImageParent.style.overflow = "unset";
            } else if (coverImageParent) coverImageParent.style.removeProperty("overflow");
            if (property.radius) {
                if (property.radius.includes(",") && property.radius.split(",").length == 4) {
                    let radiusValue = shapePrpropertyoperty.radius.split(",");
                    assetParent.style.setProperty("--coverImageRadius", radiusValue[0] + "px " + radiusValue[1] + "px " + radiusValue[2] + "px " + radiusValue[3] + "px");
                } else assetParent.style.setProperty("--coverImageRadius", property.radius + (property.radius.includes("px") || property.radius.includes("var") || property.radius.includes("%") ? "" : "px"));
            }
            if (property.zorder) assetParent.style.setProperty("--coverImageZorder", property.zorder);
            if (property.filter) assetParent.style.setProperty("--coverImageFilter", property.filter);
            if (property.blend) assetParent.style.setProperty("--coverImageBlend", property.blend);
            this.updatePerspective(property, assetImageParent);
            if (property.mask) {
                let clipPathID = property.mask.substr(property.mask.lastIndexOf("/") + 1);
                let arrAssets = [];
                arrAssets.push({
                    assetImageParent: assetImageParent,
                    url: property.mask,
                    type: "SVG",
                    index: index,
                    parent: assetParent.parentElement,
                    clipPathID: clipPathID.replace(".svg", "-clip-path"),
                });

                if (this.instance && this.instance.arrCommonAssets) {
                    let objData = { array: arrAssets, callback: this.imageMaskSvgLoadComplete };
                    this.instance.arrCommonAssets.push(objData);
                } else this.loadSvgAssets(arrAssets, this.imageMaskSvgLoadComplete);
            }
        }
    }
};
SpecialgraphicsPropertyUtils.prototype.applyNumberProperties = function (metaData, sgNumberTextNode, assetParent, index, isDirect = false) {
    if (sgNumberTextNode && metaData.number) {
        assetParent.style.setProperty("--numberDisplay", "flex");
        let numberProperty = metaData.number;
        let assetParentIndex = parseFloat(assetParent.id.replace("assetParent", ""));
        let numberPosition = Object.keys(numberProperty).length == 1 ? 1 : ((assetParentIndex - 1) % Object.keys(numberProperty).length) + 1;
        let property = numberProperty["number" + numberPosition];
        if (isDirect == true) property = numberProperty;
        if (!assetParent.classList.contains("introSlide") && property != null && property != undefined) {
            let textInnerParentNode = assetParent.querySelector("[id*='textInnerParentNode']");
            if (property.position && property.position.split(",").length == 4) this.updateNumberPositions(property.position, assetParent);
            if (property.zorder) assetParent.style.setProperty("--numberZOrder", property.zorder);
            if (property.opacity) {
                assetParent.style.setProperty("--numberOpacity", property.opacity);
                this.specialGraphicsUtils.setOpacityAttribute(sgNumberTextNode);
            }

            let colorValue = this.instance && this.instance.objDataToSG ? this.specialGraphicsUtils.getNodeColor(this.instance.objDataToSG, "secondary", property.color) : null;
            if (colorValue) {
                sgNumberTextNode.style.removeProperty("color");
                sgNumberTextNode.setAttribute("data-color", colorValue);
                assetParent.style.setProperty("--numberColor", colorValue);
            }
            if (property.prefix) {
                sgNumberTextNode.innerHTML = property.prefix + sgNumberTextNode.innerHTML;
            }
            if (property.suffix) {
                sgNumberTextNode.innerHTML = sgNumberTextNode.innerHTML + property.suffix;
            }
            if (property.bgcolor) {
                if (property.bgcolor.includes("var(") || property.bgcolor.includes("gradient")) assetParent.style.setProperty("--numberBgColor", property.bgcolor);
                else assetParent.style.setProperty("--numberBgColor", "rgba(var(--" + property.bgcolor + "-color-rgb),1)");
            }
            if (property.radius) {
                if (property.radius.includes(",") && property.radius.split(",").length == 4) {
                    let radiusValue = property.radius.split(",");
                    assetParent.style.setProperty("--numberRadius", radiusValue[0] + "px " + radiusValue[1] + "px " + radiusValue[2] + "px " + radiusValue[3] + "px");
                } else assetParent.style.setProperty("--numberRadius", property.radius + (property.radius.includes("px") || property.radius.includes("var") || property.radius.includes("%") ? "" : "px"));
            }
            if (property.fontsize) {
                let fs = property.fontsize + (property.fontsize.includes("px") || property.fontsize.includes("%") ? "" : "px");
                assetParent.style.setProperty("--numberFont", fs);
                if (sgNumberTextNode && sgNumberTextNode.id.includes("sgNumberTextNode")) sgNumberTextNode.style.fontSize = fs;
                let covernumbercontent = assetParent.querySelector("[id='covernumbercontent']");
                if (covernumbercontent) {
                    covernumbercontent.style.removeProperty("font-size");
                    covernumbercontent.setAttribute("defaultsize", property.fontsize.replace("px").replace("%"));
                    let specialGraphicsUtils = new window["SpecialGraphicsUtils"]();
                    this.specialGraphicsUtils.setTextDefaultSize(covernumbercontent);
                    specialGraphicsUtils.doFontFitForCss(covernumbercontent, assetParent);
                }
            }
            if (property.shadow) assetParent.style.setProperty("--numberSahdow", property.shadow);
            if (property.border) assetParent.style.setProperty("--numberBorder", property.border);
            delete property.depends;
            if (property.depends && property.depends == "text" && textInnerParentNode) {
                let numberNode = sgNumberTextNode.parentElement && sgNumberTextNode.parentElement.id.includes("sgNumberTextParent") ? sgNumberTextNode.parentElement : sgNumberTextNode;
                numberNode.parentElement.removeChild(numberNode);
                textInnerParentNode.appendChild(numberNode);
                numberNode.style.position = "relative";
                numberNode.style.left = "unset";
                numberNode.style.right = "unset";
                numberNode.style.top = "unset";
                numberNode.style.bottom = "unset";

                assetParent.style.setProperty("--numberTop", "unset");
                assetParent.style.setProperty("--numberLeft", "unset");
                assetParent.style.setProperty("--numberRight", "unset");
                assetParent.style.setProperty("--numberBottom", "unset");
                let sgTitleNode = assetParent.querySelector("[id='sgTitleNode']");
                let textAlign = sgTitleNode ? window.getComputedStyle(sgTitleNode)["text-align"] : "";
                if (sgTitleNode) {
                    numberNode.style.alignSelf = textAlign == "right" || textAlign == "end" ? "flex-end" : textAlign == "center" ? "center" : "flex-start";
                    numberNode.style.justifyContent = textAlign == "right" || textAlign == "end" ? "flex-end" : textAlign == "center" ? "center" : "flex-start";
                    if (sgNumberTextNode.parentElement && sgNumberTextNode.parentElement.id.includes("sgNumberTextParent")) sgNumberTextNode.style.removeProperty("align-self");
                }
                if (property.align) numberNode.style.order = property.align == "bottom" ? 10 : 0;
            } else if (isDirect == false) {
                let numberNode = sgNumberTextNode.parentElement && sgNumberTextNode.parentElement.id.includes("sgNumberTextParent") ? sgNumberTextNode.parentElement : sgNumberTextNode;
                numberNode.parentElement.removeChild(numberNode);
                assetParent.appendChild(numberNode);
                numberNode.style.position = "absolute";
            }
            let numberNode = sgNumberTextNode.id.includes("sgNumberTextNode") && sgNumberTextNode.parentElement && sgNumberTextNode.parentElement.id.includes("sgNumberTextParent") ? sgNumberTextNode.parentElement : sgNumberTextNode;
            if (property.padding && property.padding.split(",").length == 4) this.updatePadding(property.padding, numberNode, true);
            if (property.margin && property.margin.split(",").length == 4) this.updateMargin(property.margin, numberNode);
            if (property.mask) {
                let clipPathID = property.mask.substr(property.mask.lastIndexOf("/") + 1);
                let arrAssets = [];
                arrAssets.push({
                    assetImageParent: sgNumberTextNode,
                    url: property.mask,
                    type: "SVG",
                    index: index,
                    parent: assetParent.parentElement,
                    clipPathID: clipPathID.replace(".svg", "-clip-path"),
                });

                if (this.instance && this.instance.arrCommonAssets) {
                    let objData = { array: arrAssets, callback: this.imageMaskSvgLoadComplete };
                    this.instance.arrCommonAssets.push(objData);
                } else this.loadSvgAssets(arrAssets, this.imageMaskSvgLoadComplete);
            }
            if (property.globalstyle) {
                assetParent.classList.remove(property.globalstyle);
                assetParent.classList.add(property.globalstyle);
                assetParent.classList.add("clsSingleColorParent");
                assetParent.setAttribute("oldglobalstyle", property.globalstyle);
            } else if (assetParent) assetParent.classList.remove("clsSingleColorParent");
        }
    }
};
SpecialgraphicsPropertyUtils.prototype.updateMargin = function (property, element) {
    let padding = property.split(",");
    element.style.marginTop = padding[0] + this.getSuffixForPositiom(padding[0]);
    element.style.marginRight = padding[1] + this.getSuffixForPositiom(padding[1]);
    element.style.marginBottom = padding[2] + this.getSuffixForPositiom(padding[2]);
    element.style.marginLeft = padding[3] + this.getSuffixForPositiom(padding[3]);
};
SpecialgraphicsPropertyUtils.prototype.updatePadding = function (property, element, reduceParentSize = false) {
    let arrPadding = property.split(",");
    let paddingTop = arrPadding[0] + this.getSuffixForPositiom(arrPadding[0]);
    let paddingRight = arrPadding[1] + this.getSuffixForPositiom(arrPadding[1]);
    let paddingBottom = arrPadding[2] + this.getSuffixForPositiom(arrPadding[2]);
    let paddingLeft = arrPadding[3] + this.getSuffixForPositiom(arrPadding[3]);
    element.style.padding = paddingTop + " " + paddingRight + " " + paddingBottom + " " + paddingLeft;
};

SpecialgraphicsPropertyUtils.prototype.updatePerspective = function (property, element, type = "") {
    if (property[type + "cornerpoints"] && property[type + "sizematrix"]) {
        let arrCornerPoints = property[type + "cornerpoints"].replace(/[`\[\]]/gi, "").split(",");
        let arrSizePoints = property[type + "sizematrix"].replace(/[`\[\]]/gi, "").split(",");

        if (arrCornerPoints[0]?.includes("%")) arrCornerPoints[0] = parseFloat(arrCornerPoints[0]) * (this.slideWidth / 100);
        if (arrCornerPoints[1]?.includes("%")) arrCornerPoints[1] = parseFloat(arrCornerPoints[1]) * (this.slideHeight / 100);
        if (arrCornerPoints[2]?.includes("%")) arrCornerPoints[2] = parseFloat(arrCornerPoints[2]) * (this.slideWidth / 100);
        if (arrCornerPoints[3]?.includes("%")) arrCornerPoints[3] = parseFloat(arrCornerPoints[3]) * (this.slideHeight / 100);
        if (arrCornerPoints[4]?.includes("%")) arrCornerPoints[4] = parseFloat(arrCornerPoints[4]) * (this.slideWidth / 100);
        if (arrCornerPoints[5]?.includes("%")) arrCornerPoints[5] = parseFloat(arrCornerPoints[5]) * (this.slideHeight / 100);
        if (arrCornerPoints[6]?.includes("%")) arrCornerPoints[6] = parseFloat(arrCornerPoints[6]) * (this.slideWidth / 100);
        if (arrCornerPoints[7]?.includes("%")) arrCornerPoints[7] = parseFloat(arrCornerPoints[7]) * (this.slideHeight / 100);

        if (arrSizePoints[0]?.includes("%")) arrSizePoints[0] = parseFloat(arrSizePoints[0]) * (this.slideWidth / 100);
        if (arrSizePoints[1]?.includes("%")) arrSizePoints[1] = parseFloat(arrSizePoints[1]) * (this.slideHeight / 100);
        if (arrSizePoints[2]?.includes("%")) arrSizePoints[2] = parseFloat(arrSizePoints[2]) * (this.slideWidth / 100);
        if (arrSizePoints[3]?.includes("%")) arrSizePoints[3] = parseFloat(arrSizePoints[3]) * (this.slideHeight / 100);
        if (arrSizePoints[4]?.includes("%")) arrSizePoints[4] = parseFloat(arrSizePoints[4]) * (this.slideWidth / 100);
        if (arrSizePoints[5]?.includes("%")) arrSizePoints[5] = parseFloat(arrSizePoints[5]) * (this.slideHeight / 100);
        if (arrSizePoints[6]?.includes("%")) arrSizePoints[6] = parseFloat(arrSizePoints[6]) * (this.slideWidth / 100);
        if (arrSizePoints[7]?.includes("%")) arrSizePoints[7] = parseFloat(arrSizePoints[7]) * (this.slideHeight / 100);

        let cornerPoints = [
            [arrCornerPoints[0], arrCornerPoints[1]],
            [arrCornerPoints[2], arrCornerPoints[3]],
            [arrCornerPoints[4], arrCornerPoints[5]],
            [arrCornerPoints[6], arrCornerPoints[7]],
        ];
        let sizeMatrix = [
            [arrSizePoints[0], arrSizePoints[1]],
            [arrSizePoints[2], arrSizePoints[3]],
            [arrSizePoints[4], arrSizePoints[5]],
            [arrSizePoints[6], arrSizePoints[7]],
        ];
        if (element.querySelector("[id*='coverParent']")) element = element.querySelector("[id*='coverParent']");
        element.style.transformOrigin = "0px 0px 0px";
        element.style.transform = this.specialGraphicsUtils.computeTransform(sizeMatrix, cornerPoints);
    }
};
SpecialgraphicsPropertyUtils.prototype.updateShapeProperties = function (shapePosition, assetParent, index, propertyName = "--covershape") {
    let arrShapePos = shapePosition.split(",");
    assetParent.style.setProperty(propertyName + index + "Left", arrShapePos[0] + this.getSuffixForPositiom(arrShapePos[0]));
    assetParent.style.setProperty(propertyName + index + "Top", arrShapePos[1] + this.getSuffixForPositiom(arrShapePos[1]));
    assetParent.style.setProperty(propertyName + index + "Width", arrShapePos[2] + this.getSuffixForPositiom(arrShapePos[2]));
    assetParent.style.setProperty(propertyName + index + "Height", arrShapePos[3] + this.getSuffixForPositiom(arrShapePos[3]));
    assetParent.style.setProperty(propertyName + index + "Display", "block");
};
SpecialgraphicsPropertyUtils.prototype.updateNumberPositions = function (numberPosition, assetParent) {
    let arrNumPosition = numberPosition.split(",");
    assetParent.style.setProperty("--numberLeft", arrNumPosition[0] + this.getSuffixForPositiom(arrNumPosition[0]));
    assetParent.style.setProperty("--numberTop", arrNumPosition[1] + this.getSuffixForPositiom(arrNumPosition[1]));
    assetParent.style.setProperty("--numberWidth", arrNumPosition[2] + this.getSuffixForPositiom(arrNumPosition[2]));
    assetParent.style.setProperty("--numberHeight", arrNumPosition[3] + this.getSuffixForPositiom(arrNumPosition[3]));
    assetParent.style.setProperty("--numberDisplay", "flex");
};
SpecialgraphicsPropertyUtils.prototype.updateImagePosition = function (element, position, property) {
    let arrPositionValues = position.split(",");
    if (arrPositionValues.length >= 4 && element) {
        element = element.id.includes("duplicateImageParent") && element.parentElement ? element.parentElement : element;
        this.updatePosition(element, position);

        let imageElement = element.querySelector("[data-target-id='coverimage']");
        imageElement = !imageElement ? element.querySelector("[data-target-id='creatorimage']") : imageElement;
        if (imageElement) {
            let ww = arrPositionValues[2].includes("%") ? parseFloat(arrPositionValues[2]) * 12.8 : arrPositionValues[2];
            let hh = arrPositionValues[3].includes("%") ? parseFloat(arrPositionValues[3]) * 7.2 : arrPositionValues[3];
            let newW = window.getComputedStyle(element).width;
            let newH = window.getComputedStyle(element).height;
            if (newW != "" && newW != "none" && newW.includes("px") && !isNaN(parseFloat(newW)) && parseFloat(newW) > 0) ww = parseFloat(newW);
            if (newH != "" && newH != "none" && newH.includes("px") && !isNaN(parseFloat(newH)) && parseFloat(newH) > 0) hh = parseFloat(newH);
            imageElement.setAttribute("data-width", parseFloat(ww));
            imageElement.setAttribute("data-height", parseFloat(hh));
            if (imageElement.hasAttribute("data-csstext")) imageElement.style = imageElement.getAttribute("data-csstext");
            else this.specialGraphicsUtils.updateImageReSize(ww, hh, imageElement);
        }
        // if (element.id.toLowerCase().includes("logoimage") && !element.hasAttribute("data-largewidth")) {
        if (element.id.toLowerCase().includes("logoimage")) {
            if (element.hasAttribute("data-logosizestyle")) {
                let newLargeW = getComputedStyle(element).getPropertyValue("--logoSizeWidth").trim();
                let newLargeH = getComputedStyle(element).getPropertyValue("--logoSizeHeight").trim();
                let updateValue = false;
                let ww = null;
                let hh = null;
                if (newLargeW && newLargeW.includes("%")) {
                    let parentW = element.parentElement.parentElement.style.width;
                    if (parentW == "auto") parentW = element.parentElement.parentElement.style.maxWidth;
                    if (parentW) {
                        let parentStyle = window.getComputedStyle(element.parentElement.parentElement);
                        parentW = parentStyle.width;
                        let parentPadding = parseFloat(parentStyle.paddingLeft) + parseFloat(parentStyle.paddingRight);
                        if (parentPadding > 0) parentW = parseFloat(parentW) - parentPadding + "px";
                        newLargeW = parseFloat(parentW) * (parseFloat(newLargeW) / 100);
                    }
                    updateValue = true;
                }
                if (newLargeH && newLargeH.includes("%")) {
                    let parentH = element.parentElement.parentElement.style.height;
                    if (parentH == "auto") parentH = element.parentElement.parentElement.style.maxHeight;
                    if (parentH) {
                        let parentStyle = window.getComputedStyle(element.parentElement.parentElement);
                        parentH = parentStyle.height;
                        let parentPadding = parseFloat(parentStyle.paddingLeft) + parseFloat(parentStyle.paddingRight);
                        if (parentPadding > 0) parentH = parseFloat(parentH) - parentPadding + "px";
                        newLargeH = parseFloat(parentH) * (parseFloat(newLargeH) / 100);
                    }
                    updateValue = true;
                }
                if (newLargeW && newLargeH) {
                    ww = parseFloat(newLargeW);
                    hh = parseFloat(newLargeH);
                    updateValue = true;
                }
                if (updateValue && ww && hh && !isNaN(ww) && !isNaN(hh)) {
                    element.style.width = parseFloat(ww) + "px";
                    element.style.height = parseFloat(hh) + "px";
                }
            }
            let width = parseFloat(element.style.width);
            if (element.style.width.includes("%")) {
                let parentWidth = parseFloat(window.getComputedStyle(element.parentElement.parentElement).width);
                if (!isNaN(parentWidth) && parentWidth > 0) width = parentWidth * (width / 100);
            }
            let height = parseFloat(element.style.height);
            if (element.style.height.includes("%")) {
                let parentHeight = parseFloat(window.getComputedStyle(element.parentElement.parentElement).height);
                if (!isNaN(parentHeight) && parentHeight > 0) height = parentHeight * (height / 100);
            }
            element.setAttribute("data-largewidth", width);
            element.setAttribute("data-largeheight", height);
            let logoimagesize = property && property.logoimagesize ? property.logoimagesize : "medium";
            // let logoImageSizeValue = logoimagesize == "small" ? 0.4 : logoimagesize == "medium" ? 0.7 : logoimagesize == "large" ? 1 : parseFloat(logoimagesize);
            let logoImageSizeValue = this.specialGraphicsUtils.getImageSizeSML(logoimagesize);
            element.style.width = width * logoImageSizeValue + "px";
            element.style.height = height * logoImageSizeValue + "px";
        }
        if (element.id.toLowerCase().includes("placeholder")) {
            if (element.hasAttribute("data-placeholdersizestyle")) {
                let newLargeW = getComputedStyle(element).getPropertyValue("--logoSizeWidth").trim();
                let newLargeH = getComputedStyle(element).getPropertyValue("--logoSizeHeight").trim();
                let updateValue = false;
                let ww = null;
                let hh = null;
                if (newLargeW && newLargeW.includes("%")) {
                    let parentW = element.parentElement.parentElement.style.width;
                    if (parentW == "auto") parentW = element.parentElement.parentElement.style.maxWidth;
                    if (parentW) {
                        let parentStyle = window.getComputedStyle(element.parentElement.parentElement);
                        parentW = parentStyle.width;
                        let parentPadding = parseFloat(parentStyle.paddingLeft) + parseFloat(parentStyle.paddingRight);
                        if (parentPadding > 0) parentW = parseFloat(parentW) - parentPadding + "px";
                        newLargeW = parseFloat(parentW) * (parseFloat(newLargeW) / 100);
                    }
                    updateValue = true;
                }
                if (newLargeH && newLargeH.includes("%")) {
                    let parentH = element.parentElement.parentElement.style.height;
                    if (parentH == "auto") parentH = element.parentElement.parentElement.style.maxHeight;
                    if (parentH) {
                        let parentStyle = window.getComputedStyle(element.parentElement.parentElement);
                        parentH = parentStyle.height;
                        let parentPadding = parseFloat(parentStyle.paddingLeft) + parseFloat(parentStyle.paddingRight);
                        if (parentPadding > 0) parentH = parseFloat(parentH) - parentPadding + "px";
                        newLargeH = parseFloat(parentH) * (parseFloat(newLargeH) / 100);
                    }
                    updateValue = true;
                }
                if (newLargeW && newLargeH) {
                    ww = parseFloat(newLargeW);
                    hh = parseFloat(newLargeH);
                    updateValue = true;
                }
                if (updateValue && ww && hh && !isNaN(ww) && !isNaN(hh)) {
                    element.style.width = parseFloat(ww) + "px";
                    element.style.height = parseFloat(hh) + "px";
                }
            }
            let width = parseFloat(element.style.width);
            if (element.style.width.includes("%")) {
                let parentWidth = parseFloat(window.getComputedStyle(element.parentElement.parentElement).width);
                if (!isNaN(parentWidth) && parentWidth > 0) width = parentWidth * (width / 100);
            }
            let height = parseFloat(element.style.height);
            if (element.style.height.includes("%")) {
                let parentHeight = parseFloat(window.getComputedStyle(element.parentElement.parentElement).height);
                if (!isNaN(parentHeight) && parentHeight > 0) height = parentHeight * (height / 100);
            }
            element.setAttribute("data-largewidth", width);
            element.setAttribute("data-largeheight", height);
            let placeholderimagesize = property && property.placeholderimagesize ? property.placeholderimagesize : "medium";
            // let placeholderImageSizeValue = placeholderimagesize == "small" ? 0.4 : placeholderimagesize == "medium" ? 0.7 : placeholderimagesize == "large" ? 1 : parseFloat(placeholderimagesize);
            let placeholderImageSizeValue = this.specialGraphicsUtils.getImageSizeSML(placeholderimagesize);
            element.style.width = width * placeholderImageSizeValue + "px";
            element.style.height = height * placeholderImageSizeValue + "px";
        }
        if (element.id.includes("coverImageParent") && property && property.imagesize && property.resize && property.resize == "enable") {
            let width = parseFloat(element.style.width);
            if (element.style.width.includes("%")) {
                let parentWidth = parseFloat(window.getComputedStyle(element.parentElement).width);
                if (!isNaN(parentWidth) && parentWidth > 0) width = parentWidth * (width / 100);
            }
            let height = parseFloat(element.style.height);
            if (element.style.height.includes("%")) {
                let parentHeight = parseFloat(window.getComputedStyle(element.parentElement).height);
                if (!isNaN(parentHeight) && parentHeight > 0) height = parentHeight * (height / 100);
            }
            element.setAttribute("data-largewidth", width);
            element.setAttribute("data-largeheight", height);
            if (arrPositionValues[3].includes("%")) element.setAttribute("data-oriwidth", arrPositionValues[3]);
            let imagesize = property && property.imagesize ? property.imagesize : "large";
            // let imagesizeValue = imagesize == "small" ? 0.4 : imagesize == "medium" ? 0.7 : imagesize == "large" ? 1 : 1;
            let imagesizeValue = this.specialGraphicsUtils.getImageSizeSML(imagesize);
            element.style.width = width * imagesizeValue + "px";
            element.style.height = height + "px";
        }
    }
};
SpecialgraphicsPropertyUtils.prototype.updatePosition = function (element, position) {
    let arrPosition = position.split(",");
    if (arrPosition.length >= 4 && element) {
        element.style.left = arrPosition[0] + this.getSuffixForPositiom(arrPosition[0]);
        element.style.top = arrPosition[1] + this.getSuffixForPositiom(arrPosition[1]);
        element.style.width = arrPosition[2] + this.getSuffixForPositiom(arrPosition[2]);
        element.style.height = arrPosition[3] + this.getSuffixForPositiom(arrPosition[3]);
        if (element.id.toLowerCase().includes("logoimage")) {
            let width = parseFloat(element.style.width);
            if (element.style.width.includes("%")) {
                let logoParent = element.parentElement.parentElement;
                let parentStyle = window.getComputedStyle(logoParent);
                let parentWidth = parseFloat(parentStyle.width) - parseFloat(parentStyle.paddingLeft) - parseFloat(parentStyle.paddingRight);
                // if (logoParent.style.width.includes("%") && logoParent.parentElement) {
                //     let mainParentWidth = parseFloat(window.getComputedStyle(logoParent).width);
                //     if (!isNaN(mainParentWidth) && mainParentWidth > 0) parentWidth = mainParentWidth * (parseFloat(logoParent.style.width) / 100);
                //     if (isNaN(parentWidth)) parentWidth = mainParentWidth;
                // }
                if (logoParent.style.maxWidth.includes("%") && logoParent.parentElement) {
                    let oldWidth = logoParent.style.width;
                    logoParent.style.width = logoParent.style.maxWidth;
                    let mainParentWidth = parseFloat(window.getComputedStyle(logoParent).width);
                    logoParent.style.width = oldWidth;
                    if (!isNaN(mainParentWidth) && mainParentWidth > 0) parentWidth = mainParentWidth * (parseFloat(logoParent.style.width) / 100);
                    if (isNaN(parentWidth)) parentWidth = mainParentWidth;
                }
                if (!isNaN(parentWidth) && parentWidth > 0) width = parentWidth * (width / 100);
            }
            let height = parseFloat(element.style.height);
            if (element.style.height.includes("%")) {
                let logoParent = element.parentElement.parentElement;
                let parentStyle = window.getComputedStyle(logoParent);
                let parentHeight = parseFloat(parentStyle.height) - parseFloat(parentStyle.paddingTop) - parseFloat(parentStyle.paddingBottom);

                // if (logoParent.style.height.includes("%") && logoParent.parentElement) {
                //     let mainParentHeight = parseFloat(window.getComputedStyle(logoParent).height);
                //     if (!isNaN(mainParentHeight) && mainParentHeight > 0) parentHeight = mainParentHeight * (parseFloat(logoParent.style.width) / 100);
                // }
                if (!isNaN(parentHeight) && parentHeight > 0) height = parentHeight * (height / 100);
            }
            element.setAttribute("data-largewidth", width);
            element.setAttribute("data-largeheight", height);
            element.style.width = width + "px";
            element.style.height = height + "px";
        }
    }
};
SpecialgraphicsPropertyUtils.prototype.getSuffixForPositiom = function (value) {
    if (!value) return "";
    return value.includes("%") || value.includes("px") || value.includes("auto") || value.includes("var") ? "" : "px";
};
SpecialgraphicsPropertyUtils.prototype.updateMaxPosition = function (element, position) {
    let arrPosition = position.split(",");
    if (arrPosition.length >= 4 && element) {
        element.style.left = arrPosition[0] + this.getSuffixForPositiom(arrPosition[0]);
        element.style.top = arrPosition[1] + this.getSuffixForPositiom(arrPosition[1]);
        element.style.width = arrPosition[2] + this.getSuffixForPositiom(arrPosition[2]);
        element.style.maxHeight = arrPosition[3] + this.getSuffixForPositiom(arrPosition[3]);
        // element.style.width = "auto";
        element.style.height = "auto";
    }
};
SpecialgraphicsPropertyUtils.prototype.applyShapesProperties = function (shapesData, assetParent, index, introShapesData = null) {
    //Check shapes data for intro slide
    let textAlignment = window.getComputedStyle(assetParent.querySelector("[id='sgTitleNode']")).textAlign;
    textAlignment = textAlignment == "start" || textAlignment == "left" ? "left" : textAlignment == "end" || textAlignment == "right" ? "right" : "center";
    if (introShapesData && introShapesData[textAlignment]) shapesData = introShapesData[textAlignment];

    let arrAssets = [];
    for (let a = 1; a < 10; a++) {
        let covershape = assetParent.querySelector("[id='covershape" + a + "']");
        let covershapeInner = covershape ? covershape.querySelector("[id*='covershapeInner']") : null;
        if (shapesData && shapesData["shape" + a] && covershape != null && covershape != undefined) {
            let shapeProperty = shapesData["shape" + a];
            covershape.style.position = "absolute";
            covershape.style.display = "block";
            if (!covershapeInner) covershape.innerHTML = "";
            if (shapeProperty.position) {
                let moodShapePosition = shapeProperty.position.split(",");
                covershape.style.left = moodShapePosition[0] + this.getSuffixForPositiom(moodShapePosition[0]);
                covershape.style.top = moodShapePosition[1] + this.getSuffixForPositiom(moodShapePosition[1]);
                covershape.style.width = moodShapePosition[2] + this.getSuffixForPositiom(moodShapePosition[2]);
                covershape.style.height = moodShapePosition[3] + this.getSuffixForPositiom(moodShapePosition[3]);
            }
            if (shapeProperty.opacity) covershape.style.opacity = shapeProperty.opacity;
            if (shapeProperty.border) {
                covershape.style.border = shapeProperty.border;
                covershape.style.setProperty("box-sizing", "border-box");
            }
            if (shapeProperty.color) {
                let colorData = shapeProperty.color;
                if (colorData.includes("gradient")) {
                    covershape.style.setProperty("background-color", "unset", "important");
                    covershape.style.setProperty("background", colorData, "important");
                } else covershape.style.setProperty("background-color", "rgba(var(--" + colorData + "-color-rgb),1)", "important");
            }
            if (shapeProperty.radius) {
                if (shapeProperty.radius.includes(",") && shapeProperty.radius.split(",").length == 4) {
                    let radiusValue = shapeProperty.radius.split(",");
                    covershape.style.borderRadius = radiusValue[0] + "px " + radiusValue[1] + "px " + radiusValue[2] + "px " + radiusValue[3] + "px";
                } else covershape.style.borderRadius = shapeProperty.radius;
            }
            if (shapeProperty.zorder) covershape.style.zIndex = shapeProperty.zorder;
            if (shapeProperty.filter && covershape) covershape.style.filter = shapeProperty.filter;
            if (shapeProperty.type && shapeProperty.type == "svg" && shapeProperty.svgname) {
                var svgPath = shapeProperty.svgname;
                arrAssets.push({ type: "json", url: svgPath, id: "coverShapeSvg", type: "SVG", shapeId: covershape.id, index: index, parent: assetParent.parentElement });
                if (shapeProperty.color) {
                    covershape.classList.add(shapeProperty.color + "-color");
                    covershape.classList.add(shapeProperty.color + "-fill");
                    covershape.style.setProperty("background-color", "unset", "important");
                }
            }
            if (shapeProperty.nested && covershapeInner) {
                shapeProperty = shapeProperty.nested;
                if (shapeProperty.position) {
                    let moodShapePosition = shapeProperty.position.split(",");
                    covershapeInner.style.left = moodShapePosition[0] + this.getSuffixForPositiom(moodShapePosition[0]);
                    covershapeInner.style.top = moodShapePosition[1] + this.getSuffixForPositiom(moodShapePosition[1]);
                    covershapeInner.style.width = moodShapePosition[2] + this.getSuffixForPositiom(moodShapePosition[2]);
                    covershapeInner.style.height = moodShapePosition[3] + this.getSuffixForPositiom(moodShapePosition[3]);
                }
                if (shapeProperty.opacity) covershapeInner.style.opacity = shapeProperty.opacity;
                if (shapeProperty.border) {
                    covershapeInner.style.border = shapeProperty.border;
                    covershapeInner.style.setProperty("box-sizing", "border-box");
                }
                if (shapeProperty.color) {
                    let colorData = shapeProperty.color;
                    if (colorData.includes("gradient")) {
                        covershapeInner.style.setProperty("background-color", "unset", "important");
                        covershapeInner.style.setProperty("background", colorData, "important");
                    } else covershapeInner.style.setProperty("background-color", "rgba(var(--" + colorData + "-color-rgb),1)", "important");
                }
                if (shapeProperty.radius) {
                    if (shapeProperty.radius.includes(",") && shapeProperty.radius.split(",").length == 4) {
                        let radiusValue = shapeProperty.radius.split(",");
                        covershapeInner.style.borderRadius = radiusValue[0] + "px " + radiusValue[1] + "px " + radiusValue[2] + "px " + radiusValue[3] + "px";
                    } else covershapeInner.style.borderRadius = shapeProperty.radius;
                }
                if (shapeProperty.zorder) covershapeInner.style.zIndex = shapeProperty.zorder;
                if (shapeProperty.type && shapeProperty.type == "svg" && shapeProperty.svgname) {
                    var svgPath = shapeProperty.svgname;
                    arrAssets.push({ type: "json", url: svgPath, id: "covershapeInnerSvg", type: "SVG", shapeId: covershapeInner.id, index: index, parent: assetParent.parentElement });
                    if (shapeProperty.color) {
                        covershapeInner.classList.add(shapeProperty.color + "-color");
                        covershapeInner.classList.add(shapeProperty.color + "-fill");
                        covershapeInner.style.setProperty("background-color", "unset", "important");
                    }
                }
            }
            this.specialGraphicsUtils.setOpacityAttribute(covershape);
            if (covershapeInner) this.specialGraphicsUtils.setOpacityAttribute(covershapeInner);
        }
    }
    let sgNumberTextNode = assetParent.querySelector("[id='sgNumberTextNode']");
    if (shapesData && shapesData.number && sgNumberTextNode != null && sgNumberTextNode != undefined) {
        sgNumberTextNode.style.removeProperty("top");
        sgNumberTextNode.style.removeProperty("bottom");
        sgNumberTextNode.style.removeProperty("left");
        sgNumberTextNode.style.removeProperty("right");
        sgNumberTextNode.style.removeProperty("font-size");
        this.applyNumberProperties(shapesData, sgNumberTextNode, assetParent, index);
    } else {
        sgNumberTextNode.style.removeProperty("top");
        sgNumberTextNode.style.removeProperty("bottom");
        sgNumberTextNode.style.removeProperty("left");
        sgNumberTextNode.style.removeProperty("right");
        sgNumberTextNode.style.bottom = "40px";
    }
    if (arrAssets.length > 0) {
        if (this.instance && this.instance.arrCommonAssets) {
            let objData = { array: arrAssets, callback: this.moodShapeSvgLoadComplete };
            this.instance.arrCommonAssets.push(objData);
        } else this.loadSvgAssets(arrAssets);
    }
};
SpecialgraphicsPropertyUtils.prototype.loadSvgAssets = function (arrAssets, callback = null) {
    let assetLoader = new window["SGAssetLoader"]();
    assetLoader
        .loadAssets(arrAssets, this.appStaticURL)
        .then((responseData) => {
            if (callback) callback(arrAssets);
            else this.moodShapeSvgLoadComplete(arrAssets);
        })
        .catch(function (rej) {
            console.log("Downloaded Assets error on property utils");
            console.log(rej);
        });
};
SpecialgraphicsPropertyUtils.prototype.imageMaskSvgLoadComplete = function (arrAssets) {
    if (arrAssets.length > 0) {
        let imageMaskData = arrAssets[0];
        let svg = imageMaskData.data;
        let assetImageParent = imageMaskData.assetImageParent;
        // Generic image mask - clippath
        if (svg) {
            if (imageMaskData.parent.querySelector("[id='maskNode" + imageMaskData.index + "']")) imageMaskData.parent.querySelector("[id='maskNode" + imageMaskData.index + "']").parentElement.removeChild(imageMaskData.parent.querySelector("[id='maskNode" + imageMaskData.index + "']"));
            let svgChild = document.createElement("div");
            svgChild.innerHTML = svg;
            svgChild.id = "maskNode" + imageMaskData.index;
            imageMaskData.parent.appendChild(svgChild);
            svgChild.style.pointerEvents = "none";
            svgChild.style.opacity = "0";
            svgChild.style.userSelect = "false";
            //Applying clippath to image parent
            let coverImageParent = assetImageParent.querySelector("[id*='coverParent']") ? assetImageParent.querySelector("[id*='coverParent']") : assetImageParent;
            coverImageParent.style.clipPath = "url(#" + imageMaskData.clipPathID + ")";
            coverImageParent.style.setProperty("-webkit-clip-path", "url(#" + imageMaskData.clipPathID + ")");
            coverImageParent.setAttribute("svgid", imageMaskData.clipPathID);

            if (svgChild.getElementsByTagName("svg").length > 0 && imageMaskData.url) {
                let svgDOM = svgChild.getElementsByTagName("svg")[0];
                svgDOM.setAttribute("path", imageMaskData.url);
            }

            //Scaling mask to fit into the image
            let doMaskFit = imageMaskData.doMaskFit != null && imageMaskData.doMaskFit != undefined ? imageMaskData.doMaskFit : true;
            let doClipPosition = imageMaskData.doClipPosition != null && imageMaskData.doClipPosition != undefined ? imageMaskData.doClipPosition : null;
            let doImageParentResize = imageMaskData.doImageParentResize != null && imageMaskData.doImageParentResize != undefined ? imageMaskData.doImageParentResize : null;
            doImageParentResize = assetImageParent && assetImageParent.id.includes("commonImageParent");
            let scaleValue = 1;
            if (!doClipPosition && doMaskFit != false && svgChild.getElementsByTagName("svg").length > 0 && assetImageParent.clientHeight > 0) {
                let svgDOM = svgChild.getElementsByTagName("svg")[0];
                svgDOM.style.width = "100%";
                svgDOM.style.height = "100%";
                if (svgDOM && svgDOM.hasAttribute("viewBox")) {
                    let scaleX = parseFloat(assetImageParent.clientHeight) / parseFloat(svgDOM.getAttribute("viewBox").split(" ")[3]);
                    let scaleY = parseFloat(assetImageParent.clientWidth) / parseFloat(svgDOM.getAttribute("viewBox").split(" ")[2]);
                    scaleValue = Math.min(scaleX, scaleY);
                    let clipPathNode = svgDOM.querySelector("clipPath[id='" + imageMaskData.clipPathID + "']");
                    if (clipPathNode) clipPathNode.style.transform = "scale(" + scaleValue + ")";
                }
            }
            if (doClipPosition && svgChild.getElementsByTagName("svg").length > 0) {
                let svgDOM = svgChild.getElementsByTagName("svg")[0];
                let arrPositions = doClipPosition.split(",");
                let scaleX = parseFloat(arrPositions[2]) / parseFloat(svgDOM.getAttribute("viewBox").split(" ")[2]);
                let scaleY = parseFloat(arrPositions[3]) / parseFloat(svgDOM.getAttribute("viewBox").split(" ")[3]);
                scaleValue = Math.min(scaleX, scaleY);
                let clipPathNode = svgDOM.querySelector("clipPath[id='" + imageMaskData.clipPathID + "']");
                let translateX = arrPositions[0];
                let translateY = arrPositions[1];
                if (clipPathNode) clipPathNode.style.transform = "translate(" + translateX + "px," + translateY + "px) scale(" + scaleValue + ")";
            }
            if (doImageParentResize) {
                let clipPathGroupNode = svgChild.querySelector("g[clip-path*='url(#" + imageMaskData.clipPathID + ")']");
                let bbox = clipPathGroupNode ? clipPathGroupNode.getBBox() : { width: 0, height: 0, x: 0, y: 0 };

                if (bbox && bbox.width && imageMaskData.parent.querySelector("[id*='coverParent']")) {
                    let clipPathNode = svgChild.querySelector("clipPath[id='" + imageMaskData.clipPathID + "']");
                    let arrCoverParent = imageMaskData.parent.querySelectorAll("[id*='coverParent']");
                    for (let a = 0; a < arrCoverParent.length; a++) {
                        let coverParent = arrCoverParent[a];
                        let imageNode = coverParent.querySelector("[data-target-id='coverimage']");
                        coverParent.style.position = "absolute";
                        coverParent.style.width = bbox.width * scaleValue + "px";
                        coverParent.style.height = bbox.height * scaleValue + "px";
                        coverParent.style.left = bbox.x * scaleValue + "px";
                        coverParent.style.top = bbox.y * scaleValue + "px";

                        coverParent.style.setProperty("clip-path", "url(#" + imageMaskData.clipPathID + ")");
                        coverParent.style.setProperty("-webkit-clip-path", "url(#" + imageMaskData.clipPathID + ")");
                        coverParent.parentElement.style.removeProperty("-webkit-clip-path");
                        coverParent.parentElement.style.removeProperty("clip-path");

                        let isSafari = this.instance && this.instance.objDataToSG && this.instance.objDataToSG.issafari ? this.instance.objDataToSG.issafari : false;

                        if (clipPathNode) clipPathNode.style.transform = "scale(" + scaleValue + ") translate(" + (parseFloat(bbox.x) / (isSafari ? 2 : 1)) * -1 + "px," + (parseFloat(bbox.y) / (isSafari ? 2 : 1)) * -1 + "px)";

                        // if (a == 0 && clipPathNode) clipPathNode.style.transform = "translate(-" + coverParent.style.left + ",-" + coverParent.style.top + ")";

                        coverParent.parentElement.classList.remove("slideGraphicElementTransformHoverState");
                        coverParent.classList.remove("slideGraphicElementTransformHoverState");
                        coverParent.classList.add("slideGraphicElementTransformHoverState");
                        if (imageNode) {
                            imageNode.setAttribute("data-width", parseFloat(coverParent.style.width));
                            imageNode.setAttribute("data-height", parseFloat(coverParent.style.height));
                            imageNode.setAttribute("data-x", parseFloat(coverParent.style.left));
                            imageNode.setAttribute("data-y", parseFloat(coverParent.style.top));
                            if (imageNode.dataset.csstext && imageNode.dataset.csstext != "" && imageNode.dataset.csstext != "undefined") imageNode.style = imageNode.dataset.csstext;
                            else this.specialGraphicsUtils.updateImageReSize(parseFloat(coverParent.style.width), parseFloat(coverParent.style.height), imageNode);
                        }
                    }
                }
            }
        }
    }
};
SpecialgraphicsPropertyUtils.prototype.moodShapeSvgLoadComplete = function (arrAssets) {
    if (arrAssets.length > 0) {
        for (let i = 0; i < arrAssets.length; i++) {
            let assetParent = arrAssets[i].parent.querySelector("[id='assetParent" + arrAssets[i].index + "']");
            let moodShape = assetParent ? assetParent.querySelector("[id='" + arrAssets[i].shapeId + "']") : null;
            if (moodShape) {
                moodShape.innerHTML = arrAssets[i].data;
                let svgNode = moodShape.getElementsByTagName("svg");
                if (svgNode && svgNode.length > 0) {
                    svgNode[0].style.width = "100%";
                    svgNode[0].style.height = "100%";
                    // && arrAssets[i].url.includes("genericassets/shapes")
                    if (moodShape.getElementsByTagName("image").length > 0 && arrAssets[i].url) {
                        let imageNodes = moodShape.getElementsByTagName("image");
                        for (a = 0; a < imageNodes.length; a++) {
                            if (imageNodes[a].hasAttribute("xlink:href") && !imageNodes[a].getAttribute("xlink:href").includes(this.appStaticURL)) {
                                // let url = arrAssets[i].url.slice(0, arrAssets[i].url.lastIndexOf("/") + 1);
                                imageNodes[a].setAttribute("xlink:href", this.appStaticURL + imageNodes[a].getAttribute("xlink:href"));
                            }
                        }
                    }
                }
            }
        }
    }
};
SpecialgraphicsPropertyUtils.prototype.applyImageProperties = function (imageProperty, assetParent, index, duplicateProperty = null, duplicateImageParent = null, addManySVG = true, directParent) {
    if (imageProperty) {
        let assetImageParent = assetParent.querySelector("[id*='assetImageParent']");
        assetImageParent = !assetImageParent ? assetParent.querySelector("[id*='coverImageParent']") : assetImageParent;
        assetImageParent = directParent ? directParent : duplicateImageParent ? duplicateImageParent : assetImageParent;
        let propName = duplicateImageParent ? "--coverDuplciateImage" : directParent?.id == "coverImageParent1" ? "--cover1" : "--cover";
        propName = duplicateImageParent && (duplicateImageParent.id.includes("presenterImageParent") || duplicateImageParent.id.includes("customerImageParent")) ? "--presenter" : propName;
        propName = duplicateImageParent && duplicateImageParent.id.includes("authorImageParent") ? "--auth" : propName;
        let assetParentIndex = parseFloat(assetParent.id.replace("assetParent", "").replace("carouselParent", ""));
        let imagePosition = Object.keys(imageProperty).length == 1 ? 1 : ((assetParentIndex - 1) % Object.keys(imageProperty).length) + 1;
        imagePosition = Object.keys(imageProperty).length == 2 && imageProperty.globalstyle ? 1 : imagePosition;

        let property = duplicateProperty ? duplicateProperty : imageProperty["image" + imagePosition];
        if (!assetParent.classList.contains("introSlide") && property != null && property != undefined) {
            if (property.position && assetImageParent) this.updateImagePosition(assetImageParent, property.position, property);
            if (property.opacity) {
                assetParent.style.setProperty(propName + "Opacity", property.opacity);
                let coverimage = duplicateImageParent ? duplicateImageParent.querySelector("[data-target-id='coverimageduplicate']") : assetImageParent.querySelector("[data-target-id='coverimage']");
                if (coverimage) this.specialGraphicsUtils.setOpacityAttribute(coverimage);
            }
            let coverImageParent = duplicateImageParent && (duplicateImageParent.id.includes("presenterImageParent") || duplicateImageParent.id.includes("customerImageParent") || duplicateImageParent.id.includes("authorImageParent")) ? duplicateImageParent : assetParent.querySelector("[id*='coverImageParent']");
            let coverParent = coverImageParent?.querySelector("[id*='coverParent']");
            if (property.shadow) {
                assetParent.style.setProperty(propName + "ImageShadow", property.shadow);
                if (coverImageParent && !coverImageParent.id.includes("presenterImage") && !coverImageParent.id.includes("authorImage")) coverImageParent.style.overflow = "unset";
            }
            if (property.borderoption && coverImageParent) {
                let hasBorder = false;
                // Image border enable/disable from mood level
                if (this.instance?.objDataToSG?.fullMoodsData?.image) {
                    let moodImageProps = this.instance.objDataToSG.fullMoodsData.image;
                    if (moodImageProps.borderstyle) {
                    }
                    if (moodImageProps.borderoption == "true") hasBorder = true;
                    if (moodImageProps.borderoption == "false") hasBorder = false;
                }
                // Image border enable/disable check from old data
                hasBorder = property.borderoption == "enable" ? true : hasBorder;

                if (coverParent) coverParent.setAttribute("borderoption", hasBorder ? "true" : "false");
                else coverImageParent.setAttribute("borderoption", hasBorder ? "true" : "false");
            }
            if (coverImageParent && (property.hideimagedeletebutton == "true" || property.hideimagedeletebutton == true)) coverImageParent.setAttribute("hideimagedeletebutton", "true");
            if (coverImageParent && (property.removegrid == "true" || property.removegrid == true)) coverImageParent.setAttribute("removegrid", "true");
            if (coverImageParent && property.gridlayout) coverImageParent.setAttribute("gridlayout", property.gridlayout);

            let gutterEnable = true;
            // Gutter enable/disable from mood level
            if (this.instance?.objDataToSG?.fullMoodsData?.image) {
                let moodImageProps = this.instance.objDataToSG.fullMoodsData.image;
                if (moodImageProps.gutteroption == "true") gutterEnable = true;
                else if (moodImageProps.gutteroption == "false") gutterEnable = false;
            }
            // Gutter enable/disable from menu level
            if (property.gutteroption) gutterEnable = property.gutteroption == "true" ? true : property.gutteroption == "false" ? false : gutterEnable;

            // Applying gutter option
            if (coverParent) coverParent.setAttribute("gutteroption", gutterEnable ? "true" : "false");
            else if (coverImageParent) coverImageParent.setAttribute("gutteroption", gutterEnable ? "true" : "false");

            if (property.imageborder) {
                let innerParent = coverImageParent.querySelector("[id*='coverParent']") ? coverImageParent.querySelector("[id*='coverParent']") : coverImageParent;
                innerParent.style.border = "double " + property.imageborder.replace("gradient", "") + "transparent";
                innerParent.style.backgroundImage = "linear-gradient(rgba(var(--bg-color-rgb),1), rgba(var(--bg-color-rgb),1)), radial-gradient(circle at bottom right, rgba(var(--item6-color-rgb),1), rgba(var(--item1-color-rgb),1))";
                innerParent.style.backgroundOrigin = "border-box";
                innerParent.style.backgroundClip = "content-box, border-box";
            }
            if (property.border) {
                assetParent.style.setProperty(propName + "ImageBorder", property.border);
                if (coverImageParent && !coverImageParent.id.includes("presenterImage") && !coverImageParent.id.includes("authorImage")) coverImageParent.style.overflow = "unset";
            }
            // if (!property.shadow && !property.shadow && coverImageParent) coverImageParent.style.overflow = "hidden";
            if (property.radius) {
                if (property.radius.includes(",") && property.radius.split(",").length == 4) {
                    let radiusValue = property.radius.split(",");
                    assetParent.style.setProperty(propName + "ImageRadius", radiusValue[0] + "px " + radiusValue[1] + "px " + radiusValue[2] + "px " + radiusValue[3] + "px");
                } else assetParent.style.setProperty(propName + "ImageRadius", property.radius + (property.radius.includes("px") || property.radius.includes("var") || property.radius.includes("%") ? "" : "px"));
            }
            if (property.zorder) {
                assetParent.style.setProperty(propName + "ImageZorder", property.zorder);
                if (coverImageParent) coverImageParent.style.removeProperty("z-index");
            }
            if (property.filter) assetParent.style.setProperty(propName + "ImageFilter", property.filter);
            if (property.padding && coverImageParent) this.updatePadding(property.padding, coverImageParent);
            if (property.margin && coverImageParent) this.updateMargin(property.margin, coverImageParent);
            this.specialGraphicsUtils.updatePaddingMarginInlineStyle(coverImageParent);

            if (property.maskshadow) assetParent.style.setProperty(propName + "ParentImageFilter", property.maskshadow);
            if (property.blend) assetParent.style.setProperty(propName + "ImageBlend", property.blend);
            if (property.hposition && coverImageParent && coverImageParent.getElementsByTagName("img").length > 0) {
                let imageNode = coverImageParent.getElementsByTagName("img")[0];
                imageNode.setAttribute("data-imagecropalignment", property.hposition == "left" || property.hposition == "start" ? "left" : property.hposition == "right" || property.hposition == "end" ? "right" : "center");
            }
            if (property.globalstyle && coverImageParent && coverImageParent.id.includes("coverImageParent")) {
                coverImageParent.classList.remove(property.globalstyle);
                coverImageParent.classList.add(property.globalstyle);
                coverImageParent.classList.add("clsSingleColorParent");
            }
            let imageCaption = coverImageParent?.querySelector("[id*='imageCaption']");
            if (imageCaption && (property.captionsupport == "false" || property.captionsupport == false)) {
                coverImageParent.setAttribute("supportcaption", "false ");
                if (coverParent) coverParent.setAttribute("supportcaption", "false ");
                imageCaption.style.display = "none";
                imageCaption.opacity = 0;
                imageCaption.style.width = "0px";
                imageCaption.style.height = "0px";
            }
            if (coverImageParent?.querySelector("[data-nodetype='imageOverlay']")) {
                let overlayNode = coverImageParent.querySelector("[data-nodetype='imageOverlay']");
                if (overlayNode) overlayNode.style.display = "none";

                // Image overlay enable/disable from mood level
                if (this.instance?.objDataToSG?.imageOverlayProps) {
                    let moodImageProps = this.instance.objDataToSG.imageOverlayProps;
                    if (moodImageProps.enable == "false" || moodImageProps.enable == false) overlayNode.style.display = "none";
                    else if (moodImageProps.enable == "true" || moodImageProps.enable == true) overlayNode.style.display = "block";
                }

                if (property.overlayenable != null && property.overlayenable != undefined) overlayNode.style.display = property.overlayenable == "false" || property.overlayenable == false ? "none" : "block";

                if (property.overlaysupport != null && property.overlaysupport != undefined) {
                    let support = property.overlaysupport == false || property.overlaysupport == "false" ? false : true;
                    overlayNode.setAttribute("overlaysupport", support);
                    overlayNode.style.display = support ? "block" : "none";
                }
            }
            if (property.class && coverImageParent?.querySelector("[id*='coverParent']")) this.specialGraphicsUtils.applyClassNamesFromString(coverImageParent.querySelector("[id*='coverParent']"), property.class);
            this.updatePerspective(property, assetImageParent);
            if (property.mask && addManySVG == true) {
                let clipPathID = property.mask.substr(property.mask.lastIndexOf("/") + 1);
                let arrAssets = [];
                arrAssets.push({
                    assetImageParent: assetImageParent,
                    url: property.mask,
                    type: "SVG",
                    index: index,
                    doClipPosition: property.maskposition ? property.maskposition : null,
                    parent: assetParent.parentElement,
                    clipPathID: clipPathID.replace(".svg", "-clip-path"),
                });

                if (this.instance && this.instance.arrCommonAssets) {
                    let objData = { array: arrAssets, callback: this.imageMaskSvgLoadComplete };
                    this.instance.arrCommonAssets.push(objData);
                } else this.loadSvgAssets(arrAssets, this.imageMaskSvgLoadComplete);
            }
        }
    }
};
SpecialgraphicsPropertyUtils.prototype.applyImageBaseProps = function (property, assetParent, imageParent, propName = "", addManySVG = true) {
    if (property) {
        if (property.position && imageParent) this.updateImagePosition(imageParent, property.position, property);
        if (property.shadow) {
            assetParent.style.setProperty(propName + "ImageShadow", property.shadow);
            if (imageParent) imageParent.style.overflow = "unset";
        }
        if (property.width && imageParent) imageParent.style.width = property.width + this.getSuffixForPositiom(property.width);
        if (property.height && imageParent) imageParent.style.height = property.height + this.getSuffixForPositiom(property.height);
        if (property.border) {
            assetParent.style.setProperty(propName + "ImageBorder", property.border);
            if (imageParent) imageParent.style.overflow = "unset";
        }
        if (property.borderoption && imageParent) {
            let coverParent = imageParent.querySelector("[id*='coverParent']");
            if (coverParent) coverParent.setAttribute("borderoption", property.borderoption == "enable" ? "true" : "false");
            else imageParent.setAttribute("borderoption", property.borderoption == "enable" ? "true" : "false");
        }
        if (!property.shadow && !property.shadow && imageParent) imageParent.style.overflow = "hidden";
        if (property.radius) {
            if (property.radius.includes(",") && property.radius.split(",").length == 4) {
                let radiusValue = property.radius.split(",");
                assetParent.style.setProperty(propName + "ImageRadius", radiusValue[0] + "px " + radiusValue[1] + "px " + radiusValue[2] + "px " + radiusValue[3] + "px");
            } else assetParent.style.setProperty(propName + "ImageRadius", property.radius + (property.radius.includes("px") || property.radius.includes("var") || property.radius.includes("%") ? "" : "px"));
        }
        if (property.zorder) {
            assetParent.style.setProperty(propName + "ImageZorder", property.zorder);
            if (imageParent) imageParent.style.removeProperty("z-index");
        }
        if (property.opacity) {
            imageParent.style.opacity = property.opacity;
            this.specialGraphicsUtils.setOpacityAttribute(imageParent);
        }
        if (property.filter) assetParent.style.setProperty(propName + "ImageFilter", property.filter);
        if (property.maskshadow) assetParent.style.setProperty(propName + "ParentImageFilter", property.maskshadow);
        if (property.blend) assetParent.style.setProperty(propName + "ImageBlend", property.blend);
        if (property.margin) this.updateMargin(property.margin, imageParent);
        if (property.padding) this.updatePadding(property.padding, imageParent);
        if (property.hposition && imageParent && imageParent.getElementsByTagName("img").length > 0) {
            let imageNode = imageParent.getElementsByTagName("img")[0];
            imageNode.setAttribute("data-imagecropalignment", property.hposition == "left" || property.hposition == "start" ? "left" : property.hposition == "right" || property.hposition == "end" ? "right" : "center");
        }
        if (property.class && imageParent?.querySelector("[id*='coverParent']")) this.specialGraphicsUtils.applyClassNamesFromString(imageParent.querySelector("[id*='coverParent']"), property.class);
        this.updatePerspective(property, imageParent);
        if (property.mask && addManySVG == true) {
            let clipPathID = property.mask.substr(property.mask.lastIndexOf("/") + 1);
            let arrAssets = [];
            arrAssets.push({
                assetImageParent: imageParent,
                url: property.mask,
                type: "SVG",
                index: index,
                doClipPosition: property.maskposition ? property.maskposition : null,
                parent: assetParent.parentElement,
                clipPathID: clipPathID.replace(".svg", "-clip-path"),
            });

            if (this.instance && this.instance.arrCommonAssets) {
                let objData = { array: arrAssets, callback: this.imageMaskSvgLoadComplete };
                this.instance.arrCommonAssets.push(objData);
            } else this.loadSvgAssets(arrAssets, this.imageMaskSvgLoadComplete);
        }
        let imageElement = imageParent.querySelector("[data-target-id='coverimage']");
        imageElement = !imageElement ? imageParent.querySelector("[data-target-id='logoimage']") : imageElement;
        imageElement = !imageElement ? imageParent.querySelector("[data-target-id='placeholderimage']") : imageElement;
        if (imageElement && window.getComputedStyle(imageParent).width != 0 && window.getComputedStyle(imageParent).height != 0) {
            imageElement.setAttribute("data-width", parseFloat(window.getComputedStyle(imageParent).width));
            imageElement.setAttribute("data-height", parseFloat(window.getComputedStyle(imageParent).height));
            if (imageElement.hasAttribute("data-csstext")) imageElement.style = imageElement.getAttribute("data-csstext");
            else this.specialGraphicsUtils.updateImageReSize(window.getComputedStyle(imageParent).width, window.getComputedStyle(imageParent).height, imageElement);
        }
    }
};
SpecialgraphicsPropertyUtils.prototype.applyDuplicateImageProperties = function (metaData, assetParent, index, isDirectProp = false) {
    let duplicateImageProperty = metaData && metaData.duplicateimage ? metaData.duplicateimage : metaData && metaData ? metaData.duplicateimage : null;
    if (duplicateImageProperty) {
        let coverimage = assetParent.querySelector("[data-target-id='coverimage']");
        let length = isDirectProp == true ? 1 : Object.keys(duplicateImageProperty).length;
        for (let a = 1; a <= length; a++) {
            let property = isDirectProp == true ? duplicateImageProperty : duplicateImageProperty["image" + a];
            if (!assetParent.classList.contains("introSlide") && property != null && property != undefined) {
                if (coverimage) {
                    let duplicatedNode = coverimage.cloneNode(true);
                    duplicatedNode.setAttribute("data-target-id", "coverimageduplicate");
                    duplicatedNode.style.objectFit = "cover";
                    this.specialGraphicsUtils.setOpacityAttribute(duplicatedNode);

                    let duplicateCoverImageParent = document.createElement("div");
                    duplicateCoverImageParent.id = "duplicateCoverImageParent" + a;
                    duplicateCoverImageParent.className = "duplicateCoverImageParent";
                    duplicateCoverImageParent.appendChild(duplicatedNode);
                    duplicateCoverImageParent.style.pointerEvents = "none";
                    assetParent.appendChild(duplicateCoverImageParent);
                    this.specialGraphicsUtils.setOpacityAttribute(duplicateCoverImageParent);

                    let duplicateImageParent = document.createElement("div");
                    duplicateImageParent.id = "duplicateImageParent" + a;
                    duplicateImageParent.className = "duplicateImageParent moodanimation";
                    duplicateImageParent.appendChild(duplicatedNode);
                    duplicateImageParent.setAttribute("data-animation", "duplicateimage");
                    duplicateCoverImageParent.appendChild(duplicateImageParent);
                    this.specialGraphicsUtils.setOpacityAttribute(duplicateImageParent);

                    let addManySVG = Object.keys(duplicateImageProperty).length > 1 ? true : false;
                    addManySVG = index == 1 ? true : addManySVG;
                    this.applyImageProperties(duplicateImageProperty, assetParent, index, property, duplicateImageParent);

                    if (property.position) {
                        this.updateImagePosition(duplicateCoverImageParent, property.position);
                    }
                    let w = window.getComputedStyle(duplicateCoverImageParent).width;
                    let h = window.getComputedStyle(duplicateCoverImageParent).height;
                    w = w == "" || isNaN(parseFloat(w)) ? 0 : w;
                    h = h == "" || isNaN(parseFloat(h)) ? 0 : h;
                    duplicatedNode.setAttribute("data-width", parseFloat(w));
                    duplicatedNode.setAttribute("data-height", parseFloat(h));

                    if (w != 0 && h != 0) this.specialGraphicsUtils.updateImageReSize(parseFloat(w), parseFloat(h), duplicatedNode);
                }
            }
        }
    }
};
SpecialgraphicsPropertyUtils.prototype.applyTextProperties = function (metaData, assetParent, index, directProperty = false, applyIntroProp = false) {
    if (metaData && (metaData || directProperty == true) && assetParent) {
        let textBaseParentNode = assetParent.querySelector("[id*='textBaseParentNode']");
        if (assetParent.id.includes("agendaTitleParent")) textBaseParentNode = assetParent;
        let textParent = assetParent.querySelector("[id='textParent']");
        let textInnerParentNode = assetParent.querySelector("[id='textInnerParentNode']");
        let sgNumberTextNode = assetParent.querySelector("[id='sgNumberTextNode']");
        let textElementParentSG = assetParent.querySelector("[id='textElementParentSG']");
        if (textBaseParentNode && ((metaData && metaData.text) || directProperty == true)) {
            let textProperty = metaData && metaData.text ? metaData.text : null;
            // for (let a = 1; a < 11; a++) {
            let textPosition = textProperty ? (Object.keys(textProperty).length == 1 ? 1 : ((index - 1) % Object.keys(textProperty).length) + 1) : "";
            let property = textProperty ? textProperty["text" + textPosition] : null;
            property = directProperty == true ? (textProperty ? textProperty : metaData) : property;
            if (property != null && property != undefined) {
                if (property.positionvalue) textBaseParentNode.style.position = property.positionvalue;
                if (property.parentvalign) {
                    let parentVAlign = property.parentvalign == "bottom" || property.parentvalign == "end" ? "flex-end" : property.parentvalign == "center" ? "center" : "flex-start";
                    textBaseParentNode.parentElement.style.justifyContent = parentVAlign;
                }
                if (property.parenthalign) {
                    let parentHAlign = property.parenthalign == "right" || property.parenthalign == "end" ? "flex-end" : property.parenthalign == "center" || property.parenthalign == "middle" ? "center" : "flex-start";
                    textBaseParentNode.parentElement.style.alignItems = parentHAlign;
                }
                if (property.align || property.halign) {
                    let alignData = property.halign ? property.halign : property.align;
                    textBaseParentNode.style.setProperty("--textAlign", alignData);
                    let alignValue = alignData == "right" || alignData == "end" ? "flex-end" : alignData == "center" ? "center" : "flex-start";
                    textBaseParentNode.style.setProperty("--textJustifyContent", alignValue);
                }
                if (property.valign) {
                    let alignValue = property.valign == "bottom" || property.valign == "end" ? "flex-end" : property.valign == "center" ? "center" : "flex-start";
                    textBaseParentNode.style.justifyContent = alignValue;
                    assetParent.style.setProperty("--textVAlign", alignValue);
                }
                if (!assetParent.classList.contains("introSlide") || applyIntroProp == true) {
                    let assetParentIndex = parseFloat(assetParent.id.replace("assetParent", ""));
                    textPosition = textProperty ? (Object.keys(textProperty).length == 1 ? 1 : ((assetParentIndex - 1) % Object.keys(textProperty).length) + 1) : "";
                    property = textProperty ? textProperty["text" + textPosition] : null;
                    property = directProperty == true ? (textProperty ? textProperty : metaData) : property;
                    let sgTitleNode = textBaseParentNode.querySelector("[id='sgTitleNode']");
                    let sgSubTitleNode = textBaseParentNode.querySelector("[id='sgSubTitleNode']");
                    let sgTitleLabelNode = textBaseParentNode.querySelector("[id='sgTitleLabelNode']");

                    if (property.zorder) textBaseParentNode.style.setProperty("--textZorder", property.zorder);
                    if (property.titleshadow) sgTitleNode.style.textShadow = property.titleshadow;
                    if (property.position && property.position.split(",").length == 4) {
                        let position = property.position.split(",");
                        textBaseParentNode.style.setProperty("--textParentLeft", position[0] + this.getSuffixForPositiom(position[0]));
                        textBaseParentNode.style.setProperty("--textParentTop", position[1] + this.getSuffixForPositiom(position[1]));
                        textBaseParentNode.style.setProperty("--textParentWidth", position[2] + this.getSuffixForPositiom(position[2]));
                        textBaseParentNode.style.setProperty("--textParentHeight", position[3] + this.getSuffixForPositiom(position[3]));
                        if (position[3] == "auto") textBaseParentNode.style.maxHeight = "300px";
                        else textBaseParentNode.style.removeProperty("max-height");
                        if (position[2] == "auto") textBaseParentNode.style.maxWidth = "100%";
                        else textBaseParentNode.style.removeProperty("max-width");
                        if (position[3].includes("%") && !assetParent.id.includes("agendaTitleParent")) {
                            let oldPH = null;
                            if (textBaseParentNode.parentElement && textBaseParentNode.parentElement.style.height == "auto") {
                                oldPH = textBaseParentNode.parentElement.style.height;
                                textBaseParentNode.parentElement.style.height = textBaseParentNode.parentElement.style.maxHeight;
                            }
                            let dummy = document.createElement("div");
                            dummy.style.position = "absolute";
                            dummy.style.width = "100%";
                            dummy.style.height = position[3];
                            textBaseParentNode.parentElement.appendChild(dummy);
                            let newHeight = window.getComputedStyle(dummy).height;
                            textBaseParentNode.parentElement.removeChild(dummy);
                            if (parseFloat(newHeight) > 0 && newHeight.includes("px")) textBaseParentNode.style.setProperty("--textParentHeight", newHeight);
                            if (oldPH) textBaseParentNode.parentElement.style.height = oldPH;
                        }
                    }
                    let textBgColorDiv = textBaseParentNode.querySelector("[id='textBgColorDiv']");
                    let marginValue = property.padding ? property.padding : property.margin;
                    if (!marginValue) marginValue = "0,0,0,0";
                    if (marginValue && marginValue.split(",").length == 4) {
                        let padding = marginValue.split(",");
                        textBaseParentNode.style.setProperty("--textParentMarginTop", padding[0] + this.getSuffixForPositiom(padding[0]));
                        textBaseParentNode.style.setProperty("--textParentMarginRight", padding[1] + this.getSuffixForPositiom(padding[1]));
                        textBaseParentNode.style.setProperty("--textParentMarginBottom", padding[2] + this.getSuffixForPositiom(padding[2]));
                        textBaseParentNode.style.setProperty("--textParentMarginLeft", padding[3] + this.getSuffixForPositiom(padding[3]));
                        if (textBgColorDiv && !textBgColorDiv.id.includes("deviceBGColor")) {
                            textBgColorDiv.style.padding = padding[0] + (padding[0].includes("var") ? " " : "px ") + padding[1] + (padding[1].includes("var") ? " " : "px ") + padding[2] + (padding[2].includes("var") ? " " : "px ") + padding[3] + (padding[3].includes("var") ? " " : "px");
                        }
                    }
                    if (property.maxheight) {
                        let checkMargin = false;
                        if (property.padding && property.padding.split(",").length == 4) checkMargin = true;
                        let maxH = property.maxheight + this.getSuffixForPositiom(property.maxheight);
                        textBaseParentNode.style.maxHeight = "calc(" + maxH + " - (var(--textParentMarginTop) + var(--textParentMarginBottom)))";

                        let checkHeight = property.maxheight.includes("%") || property.maxheight.includes("calc") ? false : true;
                        if (checkHeight == true && !assetParent.id.includes("agendaTitleParent")) {
                            let heightValue = textBaseParentNode.style.height;
                            if (checkMargin == true) textBaseParentNode.style.height = "calc(" + maxH + " + (var(--textParentMarginTop) + var(--textParentMarginBottom)))";
                            else textBaseParentNode.style.height = maxH;
                            if (textBaseParentNode.parentElement.hasAttribute("fullheight") && maxH.includes("%")) {
                                let heightData = (parseFloat(textBaseParentNode.parentElement.getAttribute("fullheight")) / 100) * parseFloat(maxH);
                                textBaseParentNode.style.maxHeight = heightData + "px";
                            } else {
                                let maxHeightValue = window.getComputedStyle(textBaseParentNode).height;
                                textBaseParentNode.style.maxHeight = maxHeightValue;
                            }
                            textBaseParentNode.style.height = heightValue;
                        }
                    }
                    if (property.maxwidth) textBaseParentNode.style.maxWidth = property.maxwidth + this.getSuffixForPositiom(property.maxheight);

                    if (property.bgfill && property.bgfill == "full" && textInnerParentNode) {
                        textInnerParentNode.style.height = "calc(100% - (var(--textParentMarginTop) + var(--textParentMarginBottom)))";
                        textInnerParentNode.style.maxHeight = "calc(100% - (var(--textParentMarginTop) + var(--textParentMarginBottom)))";
                        textParent.style.height = "100%";
                    }
                    this.updatePerspective(property, textBaseParentNode);
                    // we have to update perspective before bg applying.
                    if (property.bg && (property.bg == "true" || property.bg == true)) {
                        if (property.commonbg && (property.commonbg == "true" || property.commonbg == true)) {
                            let colorDiv = this.checkTextBgForUniqueAssets(assetParent, property.bgposition);
                            if (colorDiv) textBgColorDiv = colorDiv;
                        }
                        if (textBgColorDiv && !textBgColorDiv.id.includes("deviceBGColor")) {
                            textBaseParentNode.style.setProperty("--textBgDisplay", "block");
                            textBgColorDiv.style.display = "block";
                        }
                        let textParent = textBaseParentNode.querySelector("[id='textParent']");
                        if (property.bgopacity) {
                            textBaseParentNode.style.setProperty("--textBgOpacity", property.bgopacity);
                            if (textBgColorDiv) {
                                textBgColorDiv.style.opacity = property.bgopacity;
                                this.specialGraphicsUtils.setOpacityAttribute(textBgColorDiv);
                            }
                        } else {
                            textBaseParentNode.style.setProperty("--textBgOpacity", 1);
                            if (textBgColorDiv) {
                                textBgColorDiv.style.opacity = 1;
                                this.specialGraphicsUtils.setOpacityAttribute(textBgColorDiv);
                            }
                        }
                        if (textBgColorDiv && property.bgcolor) {
                            textBgColorDiv.classList.remove("transparentBg");
                            textBgColorDiv.classList.remove("subtitleColorBg");
                            textBgColorDiv.classList.remove("titleColorBg");
                            textBgColorDiv.classList.remove("textBg");
                            textBgColorDiv.classList.add("textBg");
                            textBgColorDiv.classList.add(property.bgcolor);
                        }
                        if (textBgColorDiv && textParent && !textBgColorDiv.id.includes("deviceBGColor")) {
                            textBgColorDiv.parentElement.removeChild(textBgColorDiv);
                            textParent.appendChild(textBgColorDiv);
                        }
                        if (property.bgshadow && textBgColorDiv) textBgColorDiv.style.boxShadow = property.bgshadow;
                    }
                    if (property.singlecolor) {
                        if (sgTitleNode) {
                            sgTitleNode.style.setProperty("color", property.singlecolor, "important");
                            sgTitleNode.setAttribute("singlecolor", "true");
                            sgTitleNode.setAttribute("fixedcolortext", "true");
                        }
                        if (sgSubTitleNode) sgSubTitleNode.style.setProperty("color", property.singlecolor, "important");
                        if (sgTitleLabelNode) sgTitleLabelNode.style.setProperty("color", property.singlecolor, "important");
                        let textElement = textBaseParentNode.querySelector("[id='textElement']");
                        if (textElement) textElement.style.setProperty("background-color", property.singlecolor, "important");
                        if (sgNumberTextNode) sgNumberTextNode.style.setProperty("color", property.singlecolor, "important");
                    } else if (property.color) this.specialGraphicsUtils.updateColorClassName("none", assetParent, property.color);
                    if (property.titlecustomcolor) sgTitleNode.style.setProperty("color", "rgba(var(--" + property.titlecustomcolor + "-color-rgb),1)", "important");

                    if (sgTitleNode) {
                        if (property.quotetext && property.quotetext == "enable") {
                            sgTitleNode.parentElement.classList.remove("quoteText");
                            sgTitleNode.parentElement.classList.add("quoteText");
                        } else sgTitleNode.parentElement.classList.remove("quoteText");
                        // if (property.prefix) {
                        //     sgTitleNode.parentElement.classList.remove("quoteText");
                        //     sgTitleNode.parentElement.classList.add("quoteText");
                        //     sgTitleNode.parentElement.style.setProperty("--quotePrefix", property.prefix);
                        // }
                        // if (property.suffix) {
                        //     sgTitleNode.parentElement.classList.remove("quoteText");
                        //     sgTitleNode.parentElement.classList.add("quoteText");
                        //     sgTitleNode.parentElement.style.setProperty("--quoteSuffix", property.suffix);
                        // }
                        sgTitleNode.setAttribute("ImagestackPosition", property.lines ? property.lines : "imagestackTop");
                        //Text's contrast support/not property depends on image
                        if (property.contrast && (property.contrast == "true" || property.contrast == true) && sgTitleNode) sgTitleNode.setAttribute("data-supportcontrast", "true");
                        else if (sgTitleNode) sgTitleNode.removeAttribute("data-supportcontrast");
                        //Text's 9 position inline floater
                        if (property.positionchange && (property.positionchange == "true" || property.positionchange == true) && sgTitleNode) {
                            sgTitleNode.setAttribute("data-positionchange", "true");
                            let defaultPos = property.defaulttextposition ? property.defaulttextposition : "sgMM";
                            if (textBaseParentNode) {
                                this.specialGraphicsUtils.removeTextPositionClass(textBaseParentNode.parentElement);
                                textBaseParentNode.parentElement.classList.add(defaultPos);
                            }
                        } else if (sgTitleNode) sgTitleNode.removeAttribute("data-positionchange");
                    }
                    if (sgSubTitleNode) {
                        sgSubTitleNode.setAttribute("ImagestackPosition", property.lines ? property.lines : "imagestackTop");
                        //Text's contrast support/not property depends on image
                        if (property.contrast && (property.contrast == "true" || property.contrast == true)) {
                            sgSubTitleNode.setAttribute("data-supportcontrast", "true");
                            if (sgSubTitleNode.getElementsByTagName("ul").length > 0) sgSubTitleNode.getElementsByTagName("ul")[0].setAttribute("data-supportcontrast", "true");
                        } else {
                            sgSubTitleNode.removeAttribute("data-supportcontrast");
                            if (sgSubTitleNode.getElementsByTagName("ul").length > 0) sgSubTitleNode.getElementsByTagName("ul")[0].removeAttribute("data-supportcontrast");
                        }
                        //Text's 9 position inline floater
                        if (property.positionchange && (property.positionchange == "true" || property.positionchange == true) && sgSubTitleNode) sgSubTitleNode.setAttribute("data-positionchange", "true");
                        else if (sgSubTitleNode) sgSubTitleNode.removeAttribute("data-positionchange");
                    }
                    if (sgTitleLabelNode) {
                        sgTitleLabelNode.setAttribute("ImagestackPosition", property.lines ? property.lines : "imagestackTop");
                        //Text's contrast support/not property depends on image
                        if (property.contrast && (property.contrast == "true" || property.contrast == true)) sgTitleLabelNode.setAttribute("data-supportcontrast", "true");
                        else sgTitleLabelNode.removeAttribute("data-supportcontrast");
                        //Text's 9 position inline floater
                        if (property.positionchange && (property.positionchange == "true" || property.positionchange == true) && sgTitleLabelNode) sgTitleLabelNode.setAttribute("data-positionchange", "true");
                        else if (sgTitleLabelNode) sgTitleLabelNode.removeAttribute("data-positionchange");
                    }
                    if (property.delete) {
                        let arrDelete = property.delete.split(",");
                        for (let a = 0; a < arrDelete.length; a++) {
                            if (arrDelete[a] == "subtitle" && sgSubTitleNode) sgSubTitleNode.parentElement.style.display = "none";
                            if (arrDelete[a] == "label" && sgTitleLabelNode) sgTitleLabelNode.parentElement.style.display = "none";
                            if (arrDelete[a] == "number" && sgNumberTextNode) sgNumberTextNode.style.display = "none";
                            if (arrDelete[a] == "element" && textElementParentSG) textElementParentSG.parentElement.style.display = "none";
                        }
                    } else {
                        if (sgSubTitleNode) sgSubTitleNode.parentElement.style.removeProperty("display");
                        if (sgTitleLabelNode) sgTitleLabelNode.parentElement.style.removeProperty("display");
                        if (sgNumberTextNode) sgNumberTextNode.style.removeProperty("display");
                        if (textElementParentSG) textElementParentSG.parentElement.style.removeProperty("display");
                    }
                }
            }
        }
    }
};
SpecialgraphicsPropertyUtils.prototype.checkTextBgForUniqueAssets = function (assetParent, bgPosition) {
    let textBase = assetParent.querySelector("[id*='textBaseParentNode']");
    let oldDeviceBGColorParent = assetParent.parentElement.querySelector("[id='deviceBGColorParent']");
    let isIntro = assetParent.classList.contains("introSlide") ? true : false;
    if (isIntro == false && !oldDeviceBGColorParent && textBase) {
        let textBaseStyle = window.getComputedStyle(textBase);
        let deviceBGColorParent = document.createElement("div");
        deviceBGColorParent.id = "deviceBGColorParent";
        deviceBGColorParent.className = "moodanimation";
        deviceBGColorParent.style.width = textBaseStyle.width;
        deviceBGColorParent.style.height = textBaseStyle.height;
        deviceBGColorParent.style.top = textBaseStyle.top;
        deviceBGColorParent.style.left = textBaseStyle.left;
        deviceBGColorParent.style.position = "absolute";
        deviceBGColorParent.style.userSelect = "none";
        deviceBGColorParent.style.pointerEvents = "none";
        this.specialGraphicsUtils.setOpacityAttribute(deviceBGColorParent);
        if (bgPosition) {
            let arrBgPosition = bgPosition.split(",");
            deviceBGColorParent.style.left = arrBgPosition[0] + this.getSuffixForPositiom(arrBgPosition[0]);
            deviceBGColorParent.style.top = arrBgPosition[1] + this.getSuffixForPositiom(arrBgPosition[1]);
            deviceBGColorParent.style.width = arrBgPosition[2] + this.getSuffixForPositiom(arrBgPosition[2]);
            deviceBGColorParent.style.height = arrBgPosition[3] + this.getSuffixForPositiom(arrBgPosition[3]);
        }

        let deviceBGColor = document.createElement("div");
        deviceBGColor.id = "deviceBGColor";
        deviceBGColor.className = "textBgColorDiv background-bg-color";
        deviceBGColor.style.width = "100%";
        deviceBGColor.style.maxWidth = "100%";
        deviceBGColor.style.height = "100%";
        deviceBGColor.style.maxHeight = "100%";
        deviceBGColor.style.top = "0px";
        deviceBGColor.style.left = "0px";
        deviceBGColor.style.position = "absolute";
        deviceBGColor.style.transform = textBase.style.transform;
        deviceBGColor.style.transformOrigin = textBase.style.transformOrigin;
        deviceBGColorParent.appendChild(deviceBGColor);
        let deviceImageParentNode = assetParent.parentElement.querySelector("[id='deviceImageParentNode']");
        if (deviceImageParentNode && !deviceImageParentNode.querySelector("[id='deviceBGColorParent']")) deviceImageParentNode.appendChild(deviceBGColorParent);
        else if (!deviceImageParentNode && !assetParent.parentElement.querySelector("[id='deviceBGColorParent']")) assetParent.parentElement.appendChild(deviceBGColorParent);
        return deviceBGColor;
    }
    let oldDeviceBGColor = oldDeviceBGColorParent ? oldDeviceBGColorParent.querySelector("[id='deviceBGColor']") : null;
    return oldDeviceBGColor;
};

"use strict";

function SpecialGraphicsAnimationUtils() {}
SpecialGraphicsAnimationUtils.prototype.doSpecialgraphicsAnimationIS = function(
    sgParent,
    strAnimationType,
    completeCallback,
    isPlayAnimation,
    eventManager,
    index = 0,
    callFunction = "moodsutil",
    isHide = false,
    isImageAnimate = true
) {
    let objAnimation = {};
    objAnimation.parent = sgParent;
    objAnimation.slideID = sgParent.dataset.slideid;
    objAnimation.strAnimationType = strAnimationType;
    objAnimation.moodDelay = 0;
    objAnimation.callback = completeCallback;
    objAnimation.noAnimation = isPlayAnimation == true ? false : true;
    objAnimation.isHide = isHide;
    objAnimation.isImageAnimate = isImageAnimate;
    if (sgParent && sgParent.hasAttribute("isPreview") && sgParent.getAttribute("isPreview") == "true") objAnimation.firstIn = "slidepreview";
    else objAnimation.firstIn = false;
    objAnimation.index = index;
    objAnimation.slide =
        sgParent.parentElement && sgParent.parentElement.parentElement && sgParent.parentElement.parentElement.parentElement && sgParent.parentElement.parentElement.parentElement.parentElement
            ? sgParent.parentElement.parentElement.parentElement.parentElement
            : null;

    eventManager.dispatch(callFunction, objAnimation);
};

"use strict";

function Textstack(sgParent, sgData, moodName = "simplecss", metaData, styleName, isPlayAnimation = true, textElementData, socialiconsData, fontData, objDataToSG) {
    let styleData = {};
    let baseSet = {
        title: "h3",
        subtitle: "p3",
        label: "p2",
        number: "n1",
    };
    baseSet = fontData && fontData.title ? fontData : baseSet;
    styleData.fontData = baseSet;
    this.fontData = JSON.parse(JSON.stringify(baseSet));

    // //Setting all Imagestack Text nodes class names here
    baseSet.titleClass = baseSet.title;
    baseSet.subtitleClass = baseSet.subtitle;
    baseSet.labelClass = baseSet.label;
    baseSet.title = " " + baseSet.title + "  secondary-color ";
    baseSet.subtitle = " " + baseSet.subtitle + " tertiary-color ";
    baseSet.label = " " + baseSet.label + " theme-color ";
    baseSet.number = " " + baseSet.number + " tertiary-color ";

    // //Setting all Textstack nodes prompt text here
    styleData.titlePrompt = "Type an image caption";
    styleData.subTitlePrompt = "A brief explanation about the image you have used";
    styleData.titleLabelPrompt = "Title label here";

    let imagestackPosition = metaData && metaData.imagestackPosition ? metaData.imagestackPosition : "";
    styleData.imagestackPosition = imagestackPosition != "" ? imagestackPosition : "imagestack";

    this.slideContent = objDataToSG && objDataToSG.slide ? objDataToSG.slide : null;

    let svgName = metaData && metaData.svgName ? metaData.svgName : "";
    let arrAssets = [];
    if (svgName && svgName != "") {
        if (svgName.includes(",")) {
            let arrDatas = svgName.split(",");
            for (let ll = 0; ll < arrDatas.length; ll++) {
                let name = arrDatas[ll];
                var svgPath = "textstack/metadata/" + metaData.assetName + "/images/" + name + "/" + name + ".svg";
                arrAssets.push({ type: "json", url: svgPath, id: name, type: "SVG" });
            }
        } else {
            var svgPath = "textstack/metadata/" + metaData.assetName + "/images/" + svgName + "/" + svgName + ".svg";
            arrAssets.push({ type: "json", url: svgPath, id: svgName, type: "SVG" });
        }
    }
    for (let i = 0; i < sgData.length; i++) {
        if (sgData[i].coverimage.includes(".svg")) arrAssets.push({ url: sgData[i].coverimage, id: "svgdata" + i, type: "SVG" });
    }

    if (metaData && metaData.isSVGSupport) styleData.isSVGAsset = metaData.isSVGSupport;
    else styleData.isSVGAsset = "false";

    for (let i = 0; i < sgData.length; i++) {
        if (sgData[i].coverimage.includes(".svg")) arrAssets.push({ url: sgData[i].coverimage, id: "svgdata" + i, type: "SVG" });
        if (styleData.isSVGAsset == "true" && !sgData[i].coverimage.includes(".svg")) arrAssets.push({ url: "genericassets/illustrations/industry_agnostic/breaker_slide/breaker_slide_1.svg", id: "svgdata" + i, type: "SVG" });
    }

    styleData.isSVGAsset = "false";
    if (metaData && metaData.textColor) styleData.textColor = metaData.textColor;
    // if (metaData && metaData[0] && metaData[0].jsonName) {
    //     let jsonURL = "textstack/metadata/" + (metaData[0].assetName ? metaData[0].assetName : metaData[0].jsonName) + "/" + metaData[0].jsonName + ".json";
    //     arrAssets.push({ type: "json", url: jsonURL, id: "textstackanimation", type: "JSON" });
    // }
    if (metaData && metaData.assetName == "herotext") styleData.titleClass = " h4 theme-color ";
    this.specialGraphicsAnimationUtils = new window["SpecialGraphicsAnimationUtils"]();
    // this.callAnimation = new window["titlesubtitleAnimation"]();

    this.metaData = metaData;
    this.isFromLastSlide = this.metaData && this.metaData.isFromLastSlide;
    this.currentNodeIndex = this.isFromLastSlide == true ? sgData.length : 1;

    styleData.styleName = styleName;
    this.isPlayAnimation = isPlayAnimation;
    this.finalAnimationJSON = null;
    if (metaData && metaData.moodAnimation) sgParent.setAttribute("data-customtransition", metaData.moodAnimation);
    else sgParent.setAttribute("data-customtransition", "");

    this.setTargetIndex(0, sgParent);

    SpecialGraphics.call(this, sgParent, sgData, "textstack", styleData, moodName, arrAssets, isPlayAnimation, textElementData, socialiconsData, fontData, objDataToSG);
}

Textstack.prototype = Object.create(SpecialGraphics.prototype);

Textstack.prototype.initSpecialGraphicsCreation = function () {
    if (this.metaData && !this.metaData.bgshape) this.metaData.bgshape = "emptylayoutshape";

    if (this.metaData && this.metaData.bgshape) {
        let props = this.metaData.bgshape;
        if (this.objDataToSG?.layoutshapeoutline && props) props = this.objDataToSG.layoutshapeoutline;
        //Creating bgshape
        if (props && this.slideContent && this.createLayoutShape) this.createLayoutShape("add", props, this.slideContent);
        else if (this.slideContent && this.createLayoutShape) this.createLayoutShape("remove", "", this.slideContent);
    } else if (this.slideContent && this.createLayoutShape) this.createLayoutShape("remove", "", this.slideContent);

    if (this.layoutShapeAddCallback) {
        let slideID = this.slideContent && this.slideContent.id ? this.slideContent.id : null;
        this.layoutShapeAddCallback(slideID);
    }
    SpecialGraphics.prototype.initSpecialGraphicsCreation.call(this);
};

Textstack.prototype.getTargetElement = function (elementID) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    if (assetParent && assetParent.querySelector("[id='" + elementID + "']")) return assetParent.querySelector("[id='" + elementID + "']");
};

Textstack.prototype.assetsLoadComplete = function (arrAssets) {
    SpecialGraphics.prototype.assetsLoadComplete.call(this, arrAssets);
};

Textstack.prototype.specialGraphicsSlideCreationComplete = function (index, removeImage = true) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + index + "']");
    if (assetParent && assetParent.querySelector("[id='coverImageParent']")) {
        let coverImageParent = assetParent.querySelector("[id='coverImageParent']");
        if (coverImageParent && removeImage == true) coverImageParent.style.display = "none";
        let textBase = assetParent.querySelector("[id='textBaseParentNode']");

        if (this.metaData && this.metaData) {
            if (this.metaData.textVPosition && textBase) {
                let textInnerParentNode = textBase.querySelector("[id='textInnerParentNode']");
                let justify = this.metaData.textVPosition == "start" ? "flex-start" : this.metaData.textVPosition == "end" ? "flex-end" : "center";
                textInnerParentNode.style.justifyContent = justify;
            }
            if (this.metaData.textPosition) {
                textBase.querySelector("[id='sgTitleNode']").style.textAlign = this.metaData.textPosition;
                textBase.querySelector("[id='sgSubTitleNode']").style.textAlign = this.metaData.textPosition;
                textBase.querySelector("[id='sgTitleLabelNode']").style.textAlign = this.metaData.textPosition;
                let justify = this.metaData.textPosition == "start" ? "flex-start" : this.metaData.textPosition == "end" ? "flex-end" : "center";
                textBase.querySelector("[id='sgTitleNode']").parentElement.style.justifyContent = justify;
                textBase.querySelector("[id='sgSubTitleNode']").parentElement.style.justifyContent = justify;
                textBase.querySelector("[id='sgTitleLabelNode']").parentElement.style.justifyContent = justify;
            }
            if (this.metaData.textData && textBase) {
                textBase.style.width = this.metaData.textData.split(",")[2] + "%";
                textBase.style.maxWidth = this.metaData.textData.split(",")[2] + "%";
                textBase.style.height = this.metaData.textData.split(",")[3] + "%";
                textBase.style.maxHeight = this.metaData.textData.split(",")[3] + "%";
                if (this.metaData.assetName && this.metaData.assetName == "roadsideadvertisingboard") {
                } else {
                    textBase.style.top = this.metaData.textData.split(",")[1] + "%";
                    textBase.style.left = this.metaData.textData.split(",")[0] + "%";
                }
                // if (this.styleData.styleName.includes("textindevice-style1") || this.styleData.styleName.includes("hanging") || this.styleData.styleName.includes("frameonwall")) {
                //     let deviceBGColorParent = document.createElement("div");
                //     deviceBGColorParent.id = "deviceBGColorParent";
                //     deviceBGColorParent.className = "moodanimation";
                //     deviceBGColorParent.style.width = this.metaData.textData.split(",")[2] + "%";
                //     deviceBGColorParent.style.height = this.metaData.textData.split(",")[3] + "%";
                //     deviceBGColorParent.style.top = textBase.style.top;
                //     deviceBGColorParent.style.left = textBase.style.left;
                //     deviceBGColorParent.style.position = "absolute";
                //     this.specialGraphicsUtils.setOpacityAttribute(deviceBGColorParent);

                //     let deviceBGColor = document.createElement("div");
                //     deviceBGColor.id = "deviceBGColor";
                //     deviceBGColor.className = "textBgColorDiv background-bg-color";
                //     deviceBGColor.style.width = "100%";
                //     deviceBGColor.style.maxWidth = "100%";
                //     deviceBGColor.style.height = "100%";
                //     deviceBGColor.style.maxHeight = "100%";
                //     deviceBGColor.style.top = "0px";
                //     deviceBGColor.style.left = "0px";
                //     deviceBGColor.style.position = "absolute";
                //     deviceBGColorParent.appendChild(deviceBGColor);
                //     let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
                //     if (deviceImageParentNode && !deviceImageParentNode.querySelector("[id='deviceBGColorParent']")) deviceImageParentNode.appendChild(deviceBGColorParent);
                //     if (this.metaData.assetName && this.metaData.assetName == "roadsideadvertisingboard") {
                //         deviceBGColor.style.transform = textBase.style.transform;
                //         deviceBGColor.style.transformOrigin = textBase.style.transformOrigin;
                //     }
                // }
            }
        }
    }
    if (this.styleData.styleName.includes("boldcsstextstackstyle1")) {
        let textInnerParentNode = assetParent.querySelector("[id='textInnerParentNode']");
        let sgNumberTextNode = assetParent.querySelector("[id='sgNumberTextNode']");
        textInnerParentNode.appendChild(sgNumberTextNode);
    }
    // if (this.metaData && this.metaData && this.metaData.assetName && this.metaData.assetName == "roadsideadvertisingboard") {
    //     let textElement = assetParent.querySelector("[id='textElement']");
    //     textElement.classList.remove("customTextPosition");
    //     textElement.classList.add("customTextPosition");
    // }
    SpecialGraphics.prototype.specialGraphicsSlideCreationComplete.call(this);
};

Textstack.prototype.specialGraphicsCreationComplete = function () {
    // let slideDomContentGroup = this.sgParent.parentElement.parentElement.querySelector("[id='AESpecialGraphics']");
    // if (slideDomContentGroup && (this.isPresent != true || this.isWidget == true)) this.changeVariation(slideDomContentGroup);

    if (this.isPresent != true || this.isWidget == true) {
        this.setContentEditableToText();
        this.eventManager.dispatch("positionchangecallback", (this.isFromLastSlide == true ? this.sgData.length : 1) - 1);
    }
    if (this.isPresent != true || this.isWidget == true) {
        let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
        for (let i = 0; i < assetParents.length; i++) {
            this.textElementPositioning(i);
        }
        let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
        // let indexValue = assetParent0.classList.contains("introSlide") && assetParent0.style.display != "none" ? this.currentNodeIndex : 0;
        let variationName = this.sgParent.parentElement.parentElement.hasAttribute("data-variation-name") ? this.sgParent.parentElement.parentElement.getAttribute("data-variation-name") : "";
        if (assetParent0 && assetParent0.classList.contains("introSlide") && variationName.includes("intro")) assetParent0.style.display = "none";
        let indexValue = assetParent0 && assetParent0.classList.contains("introSlide") && assetParent0.style.display != "none" ? this.currentNodeIndex : 0;
        this.floaterNavigation(indexValue);
        this.setTargetIndex();
    }
    SpecialGraphics.prototype.specialGraphicsCreationComplete.call(this);
};

Textstack.prototype.setTargetIndex = function (index = 0, sgParent = null) {
    let localParent = sgParent ? sgParent : this.sgParent;
    let animationDIV = localParent && localParent.parentElement && localParent.parentElement.parentElement ? localParent.parentElement.parentElement : null;
    if (animationDIV && animationDIV.id == "animationDIV") animationDIV.setAttribute("data-target-index", index);
};

Textstack.prototype.changeVariation = function (slideDomContentGroup) {
    let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
    this.updateIntroVisibility();
    for (let i = 0; i < assetParents.length; i++) {
        assetParents[i].style.removeProperty("display");
        // if (!assetParents[i].classList.contains("introSlide")) {
        let subTitleNode = assetParents[i].querySelector("[id='sgSubTitleNode']");
        let oldDisplay = subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "";

        this.specialGraphicsUtils.changeVariation(assetParents[i], slideDomContentGroup, i);

        let titleNode = assetParents[i].querySelector("[id='sgTitleNode']");
        let newDisplay = subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "";
        let isHeroText = titleNode && titleNode.hasAttribute("herotext") && titleNode.getAttribute("herotext") == "true" ? true : false;

        if (isHeroText == false && titleNode && subTitleNode && newDisplay != oldDisplay) {
            let isSubtitleEnabled = window.getComputedStyle(subTitleNode)["display"] == "none" ? false : true;
            titleNode.classList.remove(this.fontData.title);
            titleNode.classList.remove(this.fontData.titleNoSubtitle);
            titleNode.classList.add(isSubtitleEnabled == false ? this.fontData.titleNoSubtitle : this.fontData.title);
            titleNode.style.removeProperty("min-height");
            titleNode.style.removeProperty("max-height");
            titleNode.style.removeProperty("font-size");

            titleNode.setAttribute("defaultsize", parseFloat(window.getComputedStyle(titleNode)["font-size"]));
            if (titleNode.hasAttribute("user-font-size")) {
                this.specialGraphicsUtils.removeAllFontClass(titleNode);
                titleNode.classList.add(titleNode.getAttribute("user-font-size"));
                // titleNode.style.setProperty("font-size", titleNode.getAttribute("user-font-size") + "px", "important");
            }
            this.specialGraphicsUtils.doCheckMaxHeight(titleNode, this.sgParent);
            this.specialGraphicsUtils.doFontFitForCss(titleNode, this.sgParent);
        }
        // } else this.specialGraphicsUtils.changeVariation(assetParents[i], slideDomContentGroup);
        this.textElementPositioning(i);
    }
    this.updatenavFloater();
};

Textstack.prototype.floaterNavigation = function (index) {
    this.currentNodeIndex = this.currentNodeIndex + index;
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    let isHeroText = this.styleData && this.styleData.styleName && this.styleData.styleName == "herotext" ? true : false;

    for (let i = 0; i < this.sgData.length; i++) {
        let currentNode = this.getAssetParent(i);
        if (this.currentNodeIndex - 1 == i && currentNode) {
            currentNode.style.opacity = 1;
            currentNode.style.pointerEvents = "all";
            if (this.isPresent == false && isHeroText == false) currentNode.style.display = "block";
        } else if (currentNode) {
            currentNode.style.opacity = 0;
            currentNode.style.pointerEvents = "none";
            if (this.isPresent == false && isHeroText == false) currentNode.style.display = "none";
        }
        if (this.isPresent == true && currentNode) currentNode.style.removeProperty("display");
        if (deviceImageParentNode) {
            deviceImageParentNode.style.opacity = this.currentNodeIndex - 1 == 0 ? 0 : 1;
            deviceImageParentNode.style.pointerEvents = this.currentNodeIndex - 1 == 0 ? "none" : "auto";
        }
    }
    this.updatenavFloater();
    // this.textElementPositioning(this.currentNodeIndex - 1);
    this.eventManager.dispatch("positionchangecallback", this.currentNodeIndex - 1);
};

Textstack.prototype.updateIntroVisibility = function (moveToStart = false, index = 0) {
    let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
    if (this.sgParent && this.sgParent.parentElement && this.sgParent.parentElement.parentElement && assetParents.length > 0) {
        let animationDIV = this.sgParent.parentElement.parentElement;
        let showIntro = animationDIV.getAttribute("data-ogdata-finalshow_0")?.split(",")?.includes("intro") ? "true" : "false";
        if (showIntro == "false" && assetParents[0].classList.contains("introSlide")) {
            if (animationDIV.hasAttribute("inlinefloaterchange") && animationDIV.getAttribute("inlinefloaterchange") == "true") {
            } else {
                assetParents[0].style.display = "none";
                this.currentNodeIndex = 2;
                this.floaterNavigation(0);
            }
        } else {
            assetParents[0].style.removeProperty("display");
            if (moveToStart == true) {
                this.currentNodeIndex = index;
                this.floaterNavigation(0);
            }
        }
    }
};

Textstack.prototype.onClearAnimation = function () {
    this.currentNodeIndex = this.isFromLastSlide == true ? this.sgData.length : 1;
    this.floaterNavigation(this.currentNodeIndex - 1);
    let currentNode = this.getAssetParent(this.currentNodeIndex - 1);
    this.specialGraphicsAnimationUtils.clearSgAnimation(currentNode);
};

Textstack.prototype.getAssetParent = function (index) {
    return this.sgParent.querySelector("[id='assetParent" + index + "']");
};

Textstack.prototype.showDevice = function (showDevice = true) {
    let deviceImageParentNode = this.sgParent.querySelector("[id='deviceImageParentNode']");
    let deviceBGColorParent = this.sgParent.querySelector("[id='deviceBGColorParent']");
    if (deviceImageParentNode) {
        deviceImageParentNode.style.opacity = showDevice == false ? 0 : 1;
        deviceImageParentNode.style.pointerEvents = showDevice == false ? "none" : "auto";
    }
    if (deviceBGColorParent) deviceBGColorParent.style.opacity = showDevice == false ? 0 : 1;
    if (this.sgParent.querySelector("[id='deviceImageNode']") && showDevice == true) this.sgParent.querySelector("[id='deviceImageNode']").style.removeProperty("opacity");
    if (this.sgParent.querySelector("[id='deviceImageNode1']") && showDevice == true) this.sgParent.querySelector("[id='deviceImageNode1']").style.removeProperty("opacity");
    if (this.sgParent.querySelector("[id='videoElement']") && showDevice == true) this.sgParent.querySelector("[id='videoElement']").style.removeProperty("opacity");
    if (this.sgParent.querySelector("[id='secondaryAssetNode']") && showDevice == true) this.sgParent.querySelector("[id='secondaryAssetNode']").style.removeProperty("opacity");
};

Textstack.prototype.initPresentSG = function (slideContent) {
    let hasEmptyIntro = this.checkIntroAnimation();
    let specialgraphicsParent = slideContent && slideContent.querySelector("[id='specialgraphicsParent']") ? slideContent.querySelector("[id='specialgraphicsParent']") : null;
    if (specialgraphicsParent) specialgraphicsParent.setAttribute("hasemptyintro", hasEmptyIntro);
};

Textstack.prototype.gotoAndStopFirstNode = function (completeCallback, type, slideContent, indexValue = -1) {
    let hasEmptyIntro = this.checkIntroAnimation();
    this.currentNodeIndex = indexValue > -1 ? indexValue : this.isFromLastSlide == true ? this.sgData.length : hasEmptyIntro == true ? 2 : 1;
    if (this.currentNodeIndex == 1) this.showDevice(false);
    this.floaterNavigation(0);
    this.eventManager.dispatch("positionchangecallback", this.currentNodeIndex - 1);

    if (hasEmptyIntro && this.getAssetParent(0)) {
        let assetParent = this.getAssetParent(0);
        assetParent.style.display = "none";
    }
    if (hasEmptyIntro == false && this.getAssetParent(1)) this.getAssetParent(1).setAttribute("playshapeanimation", "false");
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1);
    this.sgParent.removeAttribute("startindex");
};

Textstack.prototype.isHeroText = function () {
    if (this.sgParent && this.sgParent.parentElement && this.sgParent.parentElement.parentElement) {
        let count = this.sgParent.parentElement.parentElement.getAttribute("data-nodecount");
        if (count == "1") return true;
    }
};

Textstack.prototype.checkIntroAnimation = function () {
    if (this.isHeroText() == true && this.sgData.length <= 2) return true;
    let assetParent = this.getAssetParent(0);
    if (assetParent && assetParent.style.display == "none") return true;
    if (assetParent && assetParent.classList.contains("introSlide")) {
        let title = assetParent.querySelector("[id='sgTitleNode']");
        let subTitle = assetParent.querySelector("[id='sgSubTitleNode']");
        let titleLabel = assetParent.querySelector("[id='sgTitleLabelNode']");
        if (title && title.innerText.trim().length == 0 && subTitle && subTitle.innerText.trim().length == 0 && titleLabel && titleLabel.innerText.trim().length == 0) {
            return true;
        }
    }
    return false;
};

Textstack.prototype.hideAnimation = function (completeCallback) {
    if (this.isHeroText() != true) this.updateShowHideInfo(this.currentNodeIndex - 1, false);
    else if (this.currentNodeIndex == 1) this.currentNodeIndex = this.currentNodeIndex + 1;
    if (this.checkIntroAnimation() == true) {
        completeCallback ? completeCallback() : "";
    } else this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1);
};

Textstack.prototype.next = function (completeCallback) {
    this.sgParent.removeAttribute("hasemptyintro");
    this.sgParent.setAttribute("dotransition", "false");
    let oldIndex = this.currentNodeIndex - 1 < 0 ? 0 : this.currentNodeIndex - 1;
    this.currentNodeIndex = this.currentNodeIndex + 1;
    if (this.currentNodeIndex > this.sgData.length) return;
    let isPreview = false;
    if (this.sgParent && this.sgParent.hasAttribute("isPreview") && this.sgParent.getAttribute("isPreview") == "true") isPreview = true;
    //HIDE ANIMATION
    this.updateShowHideInfo(oldIndex, false);
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", null, this.isPlayAnimation, this.eventManager, oldIndex, "moodsutilintermediate");
    //SHOW ANIMATION
    if (this.currentNodeIndex > 1) this.showDevice(true);
    this.updateShowHideInfo(this.currentNodeIndex - 1, true);
    // if (this.checkIntroAnimation() == true) {
    //     completeCallback ? completeCallback() : "";
    // } else
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1, "moodsutilintermediate");
    // if (isPreview == true) {
    //     setTimeout(() => {
    //         completeCallback ? completeCallback() : "";
    //     }, 0);
    // }
};

Textstack.prototype.previous = function (completeCallback) {
    this.sgParent.removeAttribute("hasemptyintro");
    let oldIndex = this.currentNodeIndex - 1 < 0 ? 0 : this.currentNodeIndex - 1;
    this.currentNodeIndex = this.currentNodeIndex - 1;

    let hasEmptyIntro = this.checkIntroAnimation();
    if (hasEmptyIntro == true && this.currentNodeIndex - 1 == 0) return false;

    if (this.currentNodeIndex < 1) return;
    if (this.sgParent.querySelector("[id='assetParent0']").classList.contains("introSlide") && oldIndex == 1) {
        this.sgParent.querySelector("[id='assetParent1']").setAttribute("hashide", "true");
        if (this.sgParent.querySelector("[id='deviceImageNode']")) this.sgParent.querySelector("[id='deviceImageNode']").style.opacity = 1;
        if (this.sgParent.querySelector("[id='deviceImageNode1']")) this.sgParent.querySelector("[id='deviceImageNode1']").style.opacity = 1;
        if (this.sgParent.querySelector("[id='deviceBGColorParent']")) this.sgParent.querySelector("[id='deviceBGColorParent']").style.opacity = 1;
        if (this.sgParent.querySelector("[id='videoElement']")) this.sgParent.querySelector("[id='videoElement']").style.opacity = 1;
        if (this.sgParent.querySelector("[id='secondaryAssetNode']")) this.sgParent.querySelector("[id='secondaryAssetNode']").style.opacity = 1;
    }
    //HIDE ANIMATION
    this.updateShowHideInfo(oldIndex, false);
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "hide", completeCallback, this.isPlayAnimation, this.eventManager, oldIndex, "moodsutilintermediate");
    //SHOW ANIMATION
    this.updateShowHideInfo(this.currentNodeIndex - 1, true);
    // if (this.checkIntroAnimation() == true) {
    //     completeCallback ? completeCallback() : "";
    // } else
    this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1, "moodsutilintermediate");
};

Textstack.prototype.updateShowHideInfo = function (index, isShow = true) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + index + "']");
    assetParent.classList.remove(isShow == true ? "hidesg" : "showsg");
    assetParent.classList.add(isShow == true ? "showsg" : "hidesg");
};

Textstack.prototype.setContentEditableToText = function () {
    let arrTextNodes = this.sgParent.querySelectorAll("[data-textelement='true']");
    for (let i = 0; i < arrTextNodes.length; i++) {
        // arrTextNodes[i].contentEditable = this.isPlayAnimation == false ? true : false;
    }
};

Textstack.prototype.updateImage = function (elementId, src) {};

Textstack.prototype.changeText = function (updatedText, elementId, targetIndex, textType) {
    let assetParent = this.getAssetParent(this.currentNodeIndex - 1);
    if (assetParent && assetParent.querySelector("[id='" + elementId + "']")) {
        let textNode = assetParent.querySelector("[id='" + elementId + "']");
        textNode.setAttribute("data-oldtext", updatedText);
        textNode.setAttribute("data-changetext", "true");
        textNode.innerHTML = updatedText;
        textNode.setAttribute("data-heading", textNode.innerText);
        this.specialGraphicsUtils.doFontFitForCss(textNode);
        setTimeout(() => {
            if (textNode.innerHTML.includes("<br>") || textNode.innerHTML.includes("\n")) textNode.style.whiteSpace = "pre";
            else textNode.style.removeProperty("white-space");
        }, 0);
    }
};
Textstack.prototype.doFontFitFromTextSizeChange = function (element) {
    let isChangingText = !element.hasAttribute("data-changetext") || (element.hasAttribute("data-changetext") && element.getAttribute("data-changetext") != "true") ? false : true;

    if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(element);

    this.specialGraphicsUtils.doCheckMaxHeight(element, this.sgParent);

    if (this.onTextChange && (element.id == "sgTitleNode" || element.id == "sgSubTitleNode") && isChangingText == false) this.onTextChange(element);
    else if (element.onTextChange && (element.id == "sgTitleNode" || element.id == "sgSubTitleNode") && isChangingText == false) element.onTextChange(element);
    else this.specialGraphicsUtils.doFontFitForCss(element, this.sgParent, null, this.textElementPositioning, this);

    let assetParent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    if (assetParent) {
        let textParentElement = assetParent ? assetParent.querySelector("[id='textInnerParentNode']") : null;
        let parentNode = assetParent ? assetParent : textParentElement ? textParentElement.parentElement : null;
        if (element.hasAttribute("data-parentid")) {
            let parentID = element.getAttribute("data-parentid");
            if (assetParent && assetParent.querySelector("[id='" + parentID + "']")) {
                parentNode = assetParent.querySelector("[id='" + parentID + "']");
                textParentElement = parentNode;
            }
        }
        this.textElementPositioning(this.currentNodeIndex - 1);
    }
    if (isChangingText == false) element.removeAttribute("data-changetext");

    if (element.hasAttribute("user-font-size")) {
        let userFont = element.getAttribute("user-font-size");
        let dummyDiv = document.createElement("div");
        dummyDiv.className = userFont;
        dummyDiv.style.position = "absolute";
        element.parentElement.appendChild(dummyDiv);
        let fontSize = window.getComputedStyle(dummyDiv).fontSize;
        if (parseFloat(fontSize) > 0) element.style.setProperty("--fontsizefinal", fontSize);
        element.parentElement.removeChild(dummyDiv);
    } else {
        element.style.removeProperty("--fontsizefinal");
        if (element.hasAttribute("data-customclass")) {
            this.specialGraphicsUtils.removeAllFontClass(element);
            if (!element.classList.contains(element.getAttribute("data-customclass"))) element.classList.add(element.getAttribute("data-customclass"));
        }
    }

    if (element.herotextcallback) element.herotextcallback(element, false);

    //For Hero text we need to check and re apply height based on user select font
    if (element.onTextChangeNode) element.onTextChangeNode(element);
};

Textstack.prototype.updateFloaterOnPreviewEnd = function (index) {
    this.updateIntroVisibility(false, index);
};

Textstack.prototype.updatenavFloater = function () {
    if (this.isPlayAnimation == false && this.isPresent != true) {
        let assetParent0 = this.sgParent.querySelector("[id='assetParent0']");
        if (assetParent0 && assetParent0.classList.contains("introSlide") && this.updateNavFloaterIndex) {
            let isIntroHide = this.sgParent?.parentElement?.parentElement?.getAttribute("data-ogdata-finalhide_0")?.split(",")?.includes("intro");
            let isVisible = isIntroHide ? -1 : 0;

            let variSelected = this.sgParent.parentElement.parentElement.hasAttribute("data-variation-type") ? this.sgParent.parentElement.parentElement.getAttribute("data-variation-type") : false;
            let isIntroEnabled = variSelected && variSelected.split(",").includes("intro") ? true : false;
            if (isIntroEnabled) isVisible = -1;

            let slideID = this.slideContent && this.slideContent.id ? this.slideContent.id : null;
            this.updateNavFloaterIndex(this.currentNodeIndex + isVisible, slideID, isVisible, this.currentNodeIndex - 1 + isVisible);
        }
    }
};
Textstack.prototype.getCurrentIndex = function () {
    return this.currentNodeIndex - 1;
};
Textstack.prototype.startIndex = function (currentSlideData) {
    return this.specialGraphicsUtils.getStartIndex(currentSlideData, this.sgParent);

    // let presentParent = currentSlideData ? currentSlideData : this.sgParent;
    // let assetParent = presentParent ? presentParent.querySelector("[id='assetParent0']") : null;
    // let sgParent = presentParent ? presentParent.querySelector("[id='specialgraphicsParent']") : this.sgParent;

    // let isNotVisible = assetParent?.style?.display == "none" || assetParent?.style?.opacity == 0 || assetParent?.style?.opacity == "0";
    // if (isNotVisible) sgParent.setAttribute("startindex", "1");
    // else sgParent.removeAttribute("startindex");

    // let localParent = sgParent ? sgParent : this.sgParent;
    // let animationDIV = localParent?.parentElement?.parentElement ? localParent.parentElement.parentElement : null;
    // let showIntro = animationDIV?.hasAttribute("data-intro") ? animationDIV.getAttribute("data-intro") : "true";

    // return (isNotVisible || !assetParent) && showIntro != "true" ? 1 : 0;
};

"use strict";

function HeroTextStack(sgParent, sgData, moodName = "simplecss", metaData, styleName, isPlayAnimation = true, textElementData, socialiconsData, fontData, objDataToSG) {
    this.metaData = metaData;
    this.specialGraphicsUtils = new window["SpecialGraphicsUtils"]();
    this.textChange = this.textChange.bind(this);
    this.onTextChange = this.onTextChange.bind(this);
    this.AnimEnd = this.AnimEnd.bind(this);
    this.sgData = sgData;
    this.objDataToSG = objDataToSG;
    Textstack.call(this, sgParent, sgData, moodName, metaData, styleName, isPlayAnimation, textElementData, socialiconsData, fontData, objDataToSG);
}

HeroTextStack.prototype = Object.create(Textstack.prototype);

HeroTextStack.prototype.specialGraphicsSlideCreationComplete = function (index) {
    if (this.isPresent == false) {
        let assetParent = this.sgParent.querySelector("[id='assetParent" + index + "']");
        if (assetParent && assetParent.querySelector("[id='coverImageParent']")) {
            let textInnerParent = assetParent.querySelector("[id='textInnerParentNode']");
            let sgNumberText = assetParent.querySelector("[id='sgNumberTextNode']");
            let sgTitleNode = assetParent.querySelector("[id='sgTitleNode']");
            let sgSubTitleNode = assetParent.querySelector("[id='sgSubTitleNode']");
            let sgTitleLabelNode = assetParent.querySelector("[id='sgTitleLabelNode']");

            if (index != 0) {
                sgSubTitleNode.style.display = "none";
                sgTitleLabelNode.style.display = "none";
                sgSubTitleNode.parentElement.style.display = "none";
                sgTitleLabelNode.parentElement.style.display = "none";
            }

            let specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL);
            specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
            specialgraphicsPropertyUtils.applyTextProperties(this.metaData, assetParent, index);
            if (this.metaData && this.metaData) specialgraphicsPropertyUtils.applyNumberProperties(this.metaData, sgNumberText, assetParent, index);

            if (sgTitleNode) {
                sgTitleNode.setAttribute("ImagestackPosition", "textstack");
                if (index != 0) {
                    sgTitleNode.setAttribute("herotext", "true");
                    sgTitleNode.setAttribute("fixedcolortext", "true");
                }
                sgTitleNode.setAttribute("data-linecount", "3");
                sgTitleNode.herotextcallback = this.onTextChange;
                sgTitleNode.removeAttribute("data-font");
                sgTitleNode.style.removeProperty("max-height");
                sgTitleNode.style.removeProperty("font-size");
                sgTitleNode.style.setProperty("padding", "unset", "important");

                if (index != 0) {
                    let modifiedString = TextHighLightUtils.highlightToString(sgTitleNode.innerHTML);
                    sgTitleNode.innerHTML = modifiedString
                        .replace("^^", "")
                        .replace("^^", "")
                        .replace("~~", "")
                        .replace("~~", "")
                        .replace("``", "")
                        .replace("``", "")
                        .replace("__", "")
                        .replace("__", "")
                        .replace("!!", "")
                        .replace("!!", "")
                        .replace("**", "")
                        .replace("**", "")
                        .replace("*_", "")
                        .replace("*_", "")
                        .replace("[", "")
                        .replace("]", "");
                }
                if (sgTitleNode.hasAttribute("user-font-size")) {
                    let userFont = sgTitleNode.getAttribute("user-font-size");
                    let dummyDiv = document.createElement("div");
                    dummyDiv.className = userFont;
                    dummyDiv.style.position = "absolute";
                    sgTitleNode.parentElement.appendChild(dummyDiv);
                    let fontSize = window.getComputedStyle(dummyDiv).fontSize;
                    if (parseFloat(fontSize) > 0) sgTitleNode.style.setProperty("--fontsizefinal", fontSize);
                    else sgTitleNode.style.removeProperty("--fontsizefinal");
                    sgTitleNode.parentElement.removeChild(dummyDiv);
                } else {
                    sgTitleNode.style.removeProperty("--fontsizefinal");
                    this.specialGraphicsUtils.removeAllFontClass(sgTitleNode);
                    sgTitleNode.classList.add("h1");
                }
                sgTitleNode.setAttribute("data-defaultclass", "h1");
            }
            if (sgSubTitleNode) {
                sgSubTitleNode.setAttribute("ImagestackPosition", "textstack");
                if (index != 0) {
                    sgSubTitleNode.setAttribute("herotext", "true");
                    sgSubTitleNode.setAttribute("fixedcolortext", "true");
                }
                sgSubTitleNode.setAttribute("data-linecount", "3");
                sgSubTitleNode.onTextChange = this.onTextChange;
            }
            if (sgTitleLabelNode) {
                sgTitleLabelNode.setAttribute("ImagestackPosition", "textstack");
                if (index != 0) {
                    sgTitleLabelNode.setAttribute("herotext", "true");
                    sgTitleLabelNode.setAttribute("fixedcolortext", "true");
                }
                sgTitleLabelNode.onTextChange = this.onTextChange;
            }
            textInnerParent.appendChild(sgNumberText);
            let styleName = this.metaData && this.metaData && this.metaData.style ? this.metaData.style : "";
            this.styleName = styleName;
            let fontMapping = this.metaData && this.metaData && this.metaData.fontstylemapping ? this.metaData.fontstylemapping : "";
            if (this.metaData && styleName && assetParent.classList.contains("introSlide") == false) {
                if (styleName == "retrotext") this.specialGraphicsUtils.removeAllFontClass(sgTitleNode);
                sgTitleNode.classList.add(styleName);
            }
            if (this.metaData && styleName && assetParent.classList.contains("introSlide") == false) {
                if (fontMapping != "") {
                    this.specialGraphicsUtils.removeAllFontClass(sgTitleNode);
                    sgTitleNode.classList.add(fontMapping);
                    sgTitleNode.setAttribute("data-defaultclass", fontMapping);
                    sgTitleNode.setAttribute("data-customclass", fontMapping);
                }
                if (sgTitleNode.textContent == "")
                    sgTitleNode.innerText =
                        styleName == "retrotext"
                            ? "Let \nType \nTalk"
                            : styleName == "gradienttext"
                            ? "NEW \nSEASON \nCOMES EARLIER"
                            : styleName == "animatedtextfill"
                            ? "BROKEN"
                            : styleName == "imagefill" || styleName == "layeredtext"
                            ? "Quietly Elegant"
                            : styleName == "dashedShadow" || styleName == "outlinewithshadow" || styleName == "outlinefillwithshadow"
                            ? "NOPE. \nNO FUNNY \nSLOGAN HERE"
                            : "Special Text";
                setTimeout(() => {
                    sgTitleNode.innerHTML = sgTitleNode.innerHTML.replaceAll("\n", "<br>");
                    sgTitleNode.setAttribute("data-heading", sgTitleNode.innerText || sgTitleNode.innerHTML.replaceAll("<br>", "\n"));
                    if (this.styleName == "retrotext" || this.styleName == "dashedShadow") {
                        sgTitleNode.style.removeProperty("white-space");
                        if (sgTitleNode.innerHTML.includes("<br>") || sgTitleNode.innerHTML.includes("\n")) sgTitleNode.style.whiteSpace = "pre-line";
                    }
                    let slideId = this.slideContent ? this.slideContent.id : this.sgParent.parentElement.parentElement.parentElement.id;
                    if (this.updateThumbnail) this.updateThumbnail(slideId);
                }, 0);
                // setTimeout(() => {
                //     if (sgTitleNode.getAttribute("data-heading") == "") {
                //         sgTitleNode.innerHTML = sgTitleNode.innerHTML.replaceAll("\n", "<br>");
                //         sgTitleNode.setAttribute("data-heading", sgTitleNode.innerText);
                //         if (this.styleName == "retrotext" || this.styleName == "dashedShadow") {
                //             sgTitleNode.style.removeProperty("white-space");
                //             if (sgTitleNode.innerHTML.includes("<br>") || sgTitleNode.innerHTML.includes("\n")) sgTitleNode.style.whiteSpace = "pre-line";
                //         }
                //         let slideId = this.slideContent ? this.slideContent.id : this.sgParent.parentElement.parentElement.parentElement.id;
                //         if (this.updateThumbnail) this.updateThumbnail(slideId);
                //     }
                // }, 2500);
                if (this.styleName == "retrotext" || this.styleName == "dashedShadow") {
                    sgTitleNode.style.removeProperty("white-space");
                    setTimeout(() => {
                        if (sgTitleNode.innerHTML.includes("<br>") || sgTitleNode.innerHTML.includes("\n")) sgTitleNode.style.whiteSpace = "pre-line";
                        else sgTitleNode.style.removeProperty("white-space");
                    }, 1000);
                }

                sgTitleNode.setAttribute("defaultsize", window.getComputedStyle(sgTitleNode).fontSize);
                sgTitleNode.setAttribute("minfontsize", "0");

                this.specialGraphicsUtils.doFontFitForCss(sgTitleNode, this.sgParent);

                if (styleName == "gradienttext" || styleName == "dashedShadow" || styleName == "outlinewithshadow" || styleName == "outlinefillwithshadow") {
                    let align = styleName == "retrotext" ? "end" : "start";
                    if (sgSubTitleNode) sgSubTitleNode.parentElement.style.setProperty("--textAlign", align);
                    if (sgTitleLabelNode) {
                        sgTitleLabelNode.parentElement.style.setProperty("--textAlign", align);
                        sgTitleLabelNode.parentElement.style.justifyContent = align == "start" ? "flex-start" : "flex-end";
                    }
                    if (styleName == "dashedShadow" || styleName == "outlinewithshadow") textInnerParent.parentElement.style.justifyContent = "flex-end";
                    if (styleName == "outlinefillwithshadow") textInnerParent.parentElement.style.justifyContent = "flex-end";
                }
            }
            if (styleName == "bordertext" && assetParent.classList.contains("introSlide") == false) {
                sgTitleNode.setAttribute("defaultsize", "100");

                sgSubTitleNode.style.display = "none";
                sgTitleLabelNode.style.display = "none";
                sgTitleNode.textChange = this.textChange;
                sgTitleNode.setAttribute("data-id", index);

                let bgText = sgTitleNode.cloneNode(true);
                bgText.id = "bgtext-" + index;
                bgText.classList.add("bgtext");
                sgTitleNode.parentElement.appendChild(bgText);
            }
            if (styleName == "imagetext" && assetParent.classList.contains("introSlide") == false) {
                sgSubTitleNode.style.display = "none";
                sgTitleLabelNode.style.display = "none";
                sgTitleNode.textChange = this.textChange;
                sgTitleNode.setAttribute("data-id", index);

                let bgImage = document.createElement("img");
                bgImage.src = this.appStaticURL + "textstack/images/nike.png";
                bgImage.className = "bgimage";
                assetParent.appendChild(bgImage);

                let fgImage = document.createElement("img");
                fgImage.src = this.appStaticURL + "textstack/images/nike-hand.png";
                fgImage.className = "fgimage";
                assetParent.appendChild(fgImage);
            }
            if ((styleName == "layertext" || styleName == "layeredtext") && assetParent.classList.contains("introSlide") == false) {
                sgSubTitleNode.style.display = "none";
                sgTitleLabelNode.style.display = "none";
                sgTitleNode.textChange = this.textChange;
                sgTitleNode.setAttribute("data-id", index);
                if (this.getTintColor) {
                    let tintColor = this.getTintColor(6);
                    if (tintColor.length == 6) {
                        let shadowValue =
                            "var(--layeroffset) var(--layeroffset) 0px rgba(var(--item" +
                            tintColor[0] +
                            "-color-rgb),1), calc(var(--layeroffset) * 2) calc(var(--layeroffset) * 2) 0px rgba(var(--item" +
                            tintColor[1] +
                            "-color-rgb),1),calc(var(--layeroffset) * 3) calc(var(--layeroffset) * 3) 0px rgba(var(--item" +
                            tintColor[2] +
                            "-color-rgb),1), calc(var(--layeroffset) * 4) calc(var(--layeroffset) * 4) 0px rgba(var(--item" +
                            tintColor[3] +
                            "-color-rgb),1),calc(var(--layeroffset) * 5) calc(var(--layeroffset) * 5) 0px rgba(var(--item" +
                            tintColor[4] +
                            "-color-rgb),1), calc(var(--layeroffset) * 6) calc(var(--layeroffset) * 6) 0px rgba(var(--item" +
                            tintColor[5] +
                            "-color-rgb),1)";
                        sgTitleNode.style.setProperty("text-shadow", shadowValue, "important");
                    }
                }
            }
            if (styleName == "neontext" && assetParent.classList.contains("introSlide") == false) {
                sgSubTitleNode.style.display = "none";
                sgTitleLabelNode.style.display = "none";
                sgTitleNode.textChange = this.textChange;
                sgTitleNode.setAttribute("data-id", index);

                let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                svg.setAttribute("viewBox", "0 0 960 300");
                sgTitleNode.parentElement.appendChild(svg);

                let symbol = document.createElementNS("http://www.w3.org/2000/svg", "symbol");
                symbol.setAttribute("id", "s-text");
                svg.appendChild(symbol);

                let text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("text-anchor", "middle");
                text.setAttribute("x", "50%");
                text.setAttribute("y", "80%");
                text.setAttribute("id", "bgtext-" + index);
                text.textContent = "Hello world";
                symbol.appendChild(text);

                let group = document.createElementNS("http://www.w3.org/2000/svg", "g");
                group.setAttribute("class", "g-ants");
                svg.appendChild(group);

                for (var i = 0; i < 5; i++) {
                    let use = document.createElementNS("http://www.w3.org/2000/svg", "use");
                    use.setAttribute("class", "text-copy");
                    use.setAttribute("href", "#s-text");
                    group.appendChild(use);
                }
            }
            if (assetParent.classList.contains("introSlide") == false && styleName == "imagefill") {
                let path = this.appStaticURL + "textstack/images/textimagefill.jpg";
                if (this.sgData[index]?.imagefillsrc) path = this.sgData[index].imagefillsrc;
                sgTitleNode.style.backgroundImage = "url(" + path + ")";
                sgTitleNode.style.setProperty("-webkit-text-fill-color", "transparent");
                sgTitleNode.style.setProperty("background-clip", "text");
                sgTitleNode.style.setProperty("-webkit-background-clip", "text");
                sgTitleNode.setAttribute("data-isimagefill", "true");
            }
            if (assetParent.classList.contains("introSlide") == false && styleName == "animatedtextfill") {
                sgTitleNode.style.backgroundImage = "repeating-linear-gradient(135deg, rgba(var(--gradient1-color-rgb),1), rgba(var(--gradient1-color-rgb),1) 80px, rgba(var(--gradient2-color-rgb),1) 80px, rgba(var(--gradient2-color-rgb),1) 163px)";
            }
            if (styleName == "imagefill" || styleName == "dashedShadow" || styleName == "animatedtextfill") sgTitleNode.setAttribute("data-loopanimation", "true");
        }
        // if (this.sgData.length == 1) {
        let sgNumberTextNode = assetParent.querySelector("[id*='sgNumberTextNode']");
        if (sgNumberTextNode) sgNumberTextNode.style.display = "none";
        assetParent.style.setProperty("--numberFont", "0px");
        // }
    }
    setTimeout(() => {
        Textstack.prototype.specialGraphicsSlideCreationComplete.call(this, index);
    }, 0);
};

HeroTextStack.prototype.gotoAndStopFirstNode = function (completeCallback) {
    Textstack.prototype.gotoAndStopFirstNode.call(this, completeCallback);
    let assetParent = this.getAssetParent(this.currentNodeIndex - 1);
    if (this.metaData && this.metaData.style && (this.metaData.style == "imagefill" || this.metaData.style == "animatedtextfill" || this.metaData.style == "dashedShadow" || this.metaData.style == "outlinewithshadow" || this.metaData.style == "outlinefillwithshadow")) {
        let isOnlyHeadingChange = this.metaData.style == "dashedShadow" || this.metaData.style == "outlinewithshadow" || this.metaData.style == "outlinefillwithshadow";
        let arrAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
        for (let a = 0; a < arrAssetParent.length; a++) {
            let assetParent = this.sgParent.querySelector("[id='assetParent" + a + "']");
            if (assetParent && assetParent.classList.contains("introSlide") == false && assetParent.querySelector("[id='sgTitleNode']")) {
                let sgTitleNode = assetParent.querySelector("[id='sgTitleNode']");
                if (sgTitleNode && sgTitleNode.hasAttribute("data-heading") && !sgTitleNode.getAttribute("data-heading") && isOnlyHeadingChange) sgTitleNode.setAttribute("data-heading", sgTitleNode.innerText);
                if (this.metaData.style == "dashedShadow") {
                    sgTitleNode.style.removeProperty("white-space");
                    if (sgTitleNode.innerHTML.includes("<br>") || sgTitleNode.innerHTML.includes("\n")) sgTitleNode.style.whiteSpace = "pre-line";
                }
                if (!isOnlyHeadingChange && this.metaData.style == "imagefill") {
                    let path = this.appStaticURL + "textstack/images/textimagefill.jpg";
                    if (this.sgData[a].imagefillsrc) path = this.sgData[a].imagefillsrc;
                    sgTitleNode.style.backgroundImage = "url(" + path + ")";
                    sgTitleNode.style.setProperty("-webkit-text-fill-color", "transparent", "important");
                    sgTitleNode.style.setProperty("-webkit-background-clip", "text", "important");
                    sgTitleNode.style.setProperty("background-repeat", "repeat");
                    sgTitleNode.style.setProperty("background-position", "0px 0px");
                    sgTitleNode.style.setProperty("background-size", "100% 500px");
                }
                if (!isOnlyHeadingChange) sgTitleNode.addEventListener("animationend", this.AnimEnd);
            }
        }
    }
    if (this.metaData && this.metaData.style && this.metaData.style == "boxborder") {
        assetParent.style.setProperty("--boxborderAnimation", "10s infinite alternate ease-in-out tipsy");
        assetParent.style.setProperty("--boxborderAngle", "translateX(-50%) translateY(-50%) rotate(0deg)");
    }
};
HeroTextStack.prototype.AnimEnd = function (event) {
    if (this.metaData && this.metaData.style && (this.metaData.style == "imagefill" || this.metaData.style == "animatedtextfill")) {
        let arrAssetParent = this.sgParent.querySelectorAll("[id*='assetParent']");
        for (let a = 0; a < arrAssetParent.length; a++) {
            let assetParent = this.sgParent.querySelector("[id='assetParent" + a + "']");
            if (assetParent && assetParent.classList.contains("introSlide") == false) {
                if (assetParent && assetParent.querySelector("[id='sgTitleNode']")) {
                    if (a != this.currentNodeIndex - 1) {
                        let sgTitleNode = assetParent.querySelector("[id='sgTitleNode']");
                        sgTitleNode.style.removeProperty("opacity");
                    }
                }
            }
        }
    }
    event.target.style.removeProperty("animation");
    event.target.style.opacity = 1;
    event.target.removeEventListener("animationend", this.AnimEnd);
};
HeroTextStack.prototype.textChange = function (textNode) {
    if (this.metaData && this.metaData && this.metaData.style == "bordertext") {
        let assetParent = this.sgParent.querySelector("[id='assetParent" + textNode.dataset.id + "']");
        let bgText = assetParent.querySelector("[id='bgtext-" + textNode.dataset.id + "']");
        bgText.innerText = textNode.innerText;
        bgText.style.fontSize = textNode.style.fontSize;
        bgText.style.maxHeight = textNode.style.maxHeight;
    } else if (this.metaData && this.metaData && this.metaData.style == "neontext") {
        let assetParent = this.sgParent.querySelector("[id='assetParent" + textNode.dataset.id + "']");
        let bgText = assetParent.querySelector("[id='bgtext-" + textNode.dataset.id + "']");
        bgText.textContent = textNode.textContent;
    }
};
HeroTextStack.prototype.changeText = function (updatedText, elementId, targetIndex, textType) {
    // Textstack.prototype.changeText.call(this, updatedText, elementId, targetIndex, textType);
    let assetParent = this.getAssetParent(this.currentNodeIndex - 1);
    if (assetParent && assetParent.querySelector("[id='" + elementId + "']")) {
        let textNode = assetParent.querySelector("[id='" + elementId + "']");
        textNode.setAttribute("data-oldtext", updatedText);
        textNode.setAttribute("data-changetext", "true");
        textNode.setAttribute("data-heading", textNode.innerText);
        textNode.innerHTML = updatedText;
        if (this.styleName && (this.styleName == "retrotext" || this.styleName == "dashedShadow")) {
            // setTimeout(() => {
            if (textNode.innerHTML.includes("<br>") || textNode.innerHTML.includes("\n")) textNode.style.whiteSpace = "pre-line";
            else textNode.style.removeProperty("white-space");
            // }, 0);
        } else textNode.style.removeProperty("white-space");
    }

    this.onTextChangeUpdate(elementId);
};
HeroTextStack.prototype.changeVariation = function (slideDomContentGroup) {
    Textstack.prototype.changeVariation.call(this, slideDomContentGroup);
    this.onTextChangeUpdate("sgTitleNode");
};
HeroTextStack.prototype.onTextChange = function (element) {
    if (element && element.id == "sgTitleNode") {
        this.onTextChangeUpdate("sgTitleNode");
    }
};
HeroTextStack.prototype.onTextChangeUpdate = function (elementId) {
    if (elementId == "sgTitleNode") {
        let assetParent = this.getAssetParent(this.currentNodeIndex - 1);
        if (assetParent && assetParent.querySelector("[id='textBaseParentNode']") && assetParent.querySelector("[id='" + elementId + "']")) {
            let textBase = assetParent.querySelector("[id='textBaseParentNode']");
            let targetNode = assetParent.querySelector("[id='" + elementId + "']");
            let sgTitleNode = assetParent.querySelector("[id='sgTitleNode']");
            let sgTitleLabelNode = assetParent.querySelector("[id='sgTitleLabelNode']");
            let subTitleNode = assetParent.querySelector("[id='sgSubTitleNode']");
            let fullHeight = parseFloat(window.getComputedStyle(textBase).height);

            let titleParentStyle = sgTitleNode ? window.getComputedStyle(sgTitleNode.parentElement) : null;
            let titleStyle = sgTitleNode ? window.getComputedStyle(sgTitleNode) : null;
            let hasTitle = (sgTitleNode && sgTitleNode.style.display == "none") || !sgTitleNode ? false : true;
            let titleMargin = titleParentStyle ? parseFloat(titleParentStyle.marginTop) + parseFloat(titleParentStyle.marginBottom) : 0;
            titleMargin = hasTitle ? (titleStyle ? parseFloat(titleStyle.marginTop) + parseFloat(titleStyle.marginBottom) : 0) + titleMargin + parseFloat(titleStyle.height) : 0;

            let labelParentStyle = sgTitleLabelNode ? window.getComputedStyle(sgTitleLabelNode.parentElement) : null;
            let labelStyle = sgTitleLabelNode ? window.getComputedStyle(sgTitleLabelNode) : null;
            let hasLabel = (sgTitleLabelNode && sgTitleLabelNode.style.display == "none") || !sgTitleLabelNode ? false : true;
            let labelMargin = labelParentStyle ? parseFloat(labelParentStyle.marginTop) + parseFloat(labelParentStyle.marginBottom) : 0;
            labelMargin = hasLabel ? (labelStyle ? parseFloat(labelStyle.marginTop) + parseFloat(labelStyle.marginBottom) : 0) + labelMargin + parseFloat(labelStyle.height) : 0;

            let subTitileParentStyle = subTitleNode ? window.getComputedStyle(subTitleNode.parentElement) : null;
            let subTitileStyle = subTitleNode ? window.getComputedStyle(subTitleNode) : null;
            let hasSubtitle = (subTitleNode && subTitleNode.style.display == "none") || !subTitleNode ? false : true;
            let subTitileMargin = subTitileParentStyle ? parseFloat(subTitileParentStyle.marginTop) + parseFloat(subTitileParentStyle.marginBottom) : 0;
            subTitileMargin = hasSubtitle ? (subTitileStyle ? parseFloat(subTitileStyle.marginTop) + parseFloat(subTitileStyle.marginBottom) : 0) + subTitileMargin + parseFloat(subTitileStyle.height) : 0;

            let remainingHeight = fullHeight - (targetNode == sgTitleNode ? labelMargin + subTitileMargin : labelMargin + titleMargin);

            let lineHeight = parseFloat(window.getComputedStyle(targetNode).lineHeight);
            let linesFinal = remainingHeight / lineHeight;
            let offDiff = linesFinal - parseInt(linesFinal);
            linesFinal = offDiff > 0.9 ? parseInt(linesFinal) + 1 : parseInt(linesFinal);

            let heightFinal = linesFinal * lineHeight;
            heightFinal = heightFinal == 0 ? lineHeight : heightFinal;

            targetNode.style.maxHeight = heightFinal + "px";

            if (targetNode.innerHTML.includes("<br>") || targetNode.innerHTML.includes("\n")) targetNode.style.whiteSpace = "pre-line";
            else targetNode.style.removeProperty("white-space");

            // DiagramResizeUtils.commonFontResize(totalTextHeight, textParentHeight, commonRemainingHeight, textNode, textNode.parentElement, this.objDataToSG.fontClassLists, true);
        }
    }
};
HeroTextStack.prototype.getTargetElement = function (elementID) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    if (assetParent && assetParent.querySelector("[id='" + elementID + "']")) return assetParent.querySelector("[id='" + elementID + "']");
};
HeroTextStack.prototype.showHideAddButtons = function (element, parent, returnData = false) {
    if (element.id == "sgTitleNode" || element.id == "sgSubTitleNode" || element.id == "sgTitleLabelNode") {
        let textParent = element.parentElement.parentElement;
        textParent = !textParent ? parent : textParent;
        let subtitleNode = textParent ? textParent.querySelector("[id='sgSubTitleNode']") : null;
        subtitleNode = !subtitleNode && parent ? parent.querySelector("[id='sgSubTitleNode']") : subtitleNode;
        let titleLabelNode = textParent ? textParent.querySelector("[id='sgTitleLabelNode']") : null;
        titleLabelNode = !titleLabelNode && parent ? parent.querySelector("[id='sgTitleLabelNode']") : titleLabelNode;

        let obj = {};
        obj.hasSubtitle = subtitleNode && subtitleNode.style.display == "none" ? false : true;
        obj.hasLabel = titleLabelNode && titleLabelNode.style.display == "none" ? false : true;
        obj.targetNode = element.parentElement;
        obj.isTitleNode = element.id == "sgTitleNode" ? true : false;
        obj.slidetype = this.sgSlideType;
        obj.hasPlaceholder = true;
        obj.hasCtaButton = true;

        if (returnData) return obj;
    }
};

HeroTextStack.prototype.startIndex = function (currentSlideData) {
    let assetParent = this.sgParent.querySelector("[id='assetParent0']");
    let isNotVisible = assetParent?.style?.display == "none" || assetParent?.style?.opacity == 0 || assetParent?.style?.opacity == "0";
    return isNotVisible ? 1 : 0;
};

"use strict";

function FlipText(sgParent, sgData, moodName, metaData, styleName, isPlayAnimation = true, textElementData, icons, fontData = null, objDataToSG) {
    this.sgParent = sgParent;
    this.sgParent.style.opacity = 1;
    this.sgData = sgData;
    this.moodName = moodName;
    this.metaData = metaData;
    this.styleName = styleName;
    this.isPlayAnimation = isPlayAnimation;
    this.currentType = "previous";
    this.objDataToSG = objDataToSG;
    this.specialGraphicsUtils = new window["SpecialGraphicsUtils"]();
    this.assetLoader = new window["SGAssetLoader"]();
    this.eventManager = new window["EventManager"]();
    this.focusCallBack = this.focusCallBack.bind(this);
    this.pasteCallBack = this.pasteCallBack.bind(this);
    this.currentNodeIndex = 1;

    let styleData = {};
    let baseSet = {
        title: "h4",
        titleNoSubtitle: "h3",
        subtitle: "p4",
        label: "p3",
        number: "n1",
        introtitle: "h2",
        introtitleNoSubtitle: "h1",
        introsubtitle: "p3",
        introlabel: "p2",
    };
    baseSet = fontData ? fontData : baseSet;
    styleData.fontData = baseSet;
    this.fontData = JSON.parse(JSON.stringify(baseSet));
    this.slideContent = objDataToSG && objDataToSG.slide ? objDataToSG.slide : null;
    this.oldContent = objDataToSG && objDataToSG.isLoadedSlide ? objDataToSG.isLoadedSlide : null;

    let styleClass = this.sgParent.querySelector("[id='CssAnimStyle']");
    if (!styleClass) {
        let style = document.createElement("style");
        style.id = "CssAnimStyle";
        this.sgParent.appendChild(style);
    }
    this.hasIntro = true;
    this.isFromLastSlide = metaData && metaData.isFromLastSlide;
    if (metaData && metaData.moodAnimation) sgParent.setAttribute("data-customtransition", metaData.moodAnimation);
    else sgParent.setAttribute("data-customtransition", "");
    this.specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL, this);
    this.specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });

    if (this.slideContent) {
        this.slideContent.classList.remove("darkText");
        this.slideContent.classList.remove("lightText");
        this.slideContent.classList.remove("fixedlightText");
        this.slideContent.classList.remove("fixeddarkText");
    }

    SGBaseClass.call(this, sgParent, sgData, moodName, metaData, styleName, isPlayAnimation, textElementData, icons, fontData, "imagestack", styleData, objDataToSG);
}

FlipText.prototype = Object.create(SGBaseClass.prototype);

FlipText.prototype.initSpecialGraphicsCreation = function () {
    try {
        if (!this.oldContent) {
            let startIndex = 0;
            let svgDiv = this.sgParent.parentElement && this.sgParent.parentElement.parentElement ? this.sgParent.parentElement.parentElement : null;
            let specislgraphicsDiv = svgDiv ? svgDiv.querySelector("[id='AESpecialGraphics']") : null;

            this.hasIntro = specislgraphicsDiv ? true : false;
            let flipTextStackParent = this.sgParent.querySelector("[id='flipTextStackParent']");
            if (flipTextStackParent) this.sgParent.removeChild(flipTextStackParent);
            flipTextStackParent = document.createElement("div");
            flipTextStackParent.id = "flipTextStackParent";
            this.setTextType(flipTextStackParent);
            flipTextStackParent.className = "flipTextStackParent clsSingleColorParent";
            this.sgParent.appendChild(flipTextStackParent);

            if (specislgraphicsDiv && specislgraphicsDiv.getElementsByTagName("introdata")) {
                startIndex = 1;
                let introParent = document.createElement("div");
                introParent.id = "introParent";
                this.setTextType(introParent);
                introParent.className = "introParent";
                flipTextStackParent.appendChild(introParent);

                let textInnerParentNode = this.createTextBase(introParent, 0);
                this.createTitleSet(textInnerParentNode, 0);

                let props = this.getIntroProps();
                if (props && props.text) {
                    this.specialgraphicsPropertyUtils.applyTextProperties(props.text, introParent, 0, true, true);
                    if (props.text.padding) this.specialgraphicsPropertyUtils.updatePadding(props.text.padding, introParent);
                    if (props.text.margin) this.specialgraphicsPropertyUtils.updateMargin(props.text.margin, introParent);
                } else {
                    introParent.style.width = "calc(100% - 112px)";
                    introParent.style.height = "calc(100% - 112px)";
                    introParent.style.margin = "56px";
                }
                let textBaseParentNode = textInnerParentNode.parentElement.parentElement;
                textBaseParentNode.style.setProperty("--textParentMarginTop", "0px");
                textBaseParentNode.style.setProperty("--textParentMarginRight", "0px");
                textBaseParentNode.style.setProperty("--textParentMarginBottom", "0px");
                textBaseParentNode.style.setProperty("--textParentMarginLeft", "0px");
            }

            this.sgParent.setAttribute("data-noanimation", "true");
            this.sgParent.classList.add("textstack");
            let textParentMain = this.sgParent.querySelector("[id='flipTextParent']");
            if (textParentMain) textParentMain.parentElement.removeChild(textParentMain);

            this.textParentMain = document.createElement("div");
            this.textParentMain.id = "flipTextParent";
            this.textParentMain.className = "flipTextParent moodanimation";
            this.setTextType(this.textParentMain);
            flipTextStackParent.appendChild(this.textParentMain);

            let textHeader = document.createElement("div");
            textHeader.id = "textHeader";
            let titleFontClass = this.fontData && this.fontData.title ? this.fontData.title : "h3";
            textHeader.className = "textFlipHeaderText " + titleFontClass + " secondary-color";
            this.setTextType(textHeader);
            this.textParentMain.appendChild(textHeader);

            let textFooter = document.createElement("div");
            textFooter.id = "textFooter";
            textFooter.className = "textFlipFooterText " + titleFontClass + " secondary-color";
            this.setTextType(textFooter);

            let flipRoot = document.createElement("div");
            flipRoot.id = "flipRootText";
            flipRoot.className = "flipRootText";

            let props = this.getProps();
            let letterSpacingValue = null;
            let contentPadding = null;
            if (props && props.text) {
                if (props.text.parentpadding) this.specialgraphicsPropertyUtils.updatePadding(props.text.parentpadding, this.textParentMain);
                if (props.text.headerpadding) this.specialgraphicsPropertyUtils.updatePadding(props.text.headerpadding, textHeader);
                if (props.text.footerpadding) this.specialgraphicsPropertyUtils.updatePadding(props.text.footerpadding, textFooter);
                if (props.text.content) {
                    if (props.text.content.padding) contentPadding = props.text.content.padding;
                    if (props.text.content.letterspacing) letterSpacingValue = props.text.content.letterspacing + (props.text.content.letterspacing.includes("px") ? "" : "px");
                }
            }
            if (props && !props.bgshape) props.bgshape = "emptylayoutshape";
            if (this.objDataToSG?.layoutshapeoutline && props) props.bgshape = this.objDataToSG.layoutshapeoutline;

            //Creating bgshape
            if (props?.bgshape && this.slideContent && this.createLayoutShape) this.createLayoutShape("add", props.bgshape, this.slideContent);
            else if (this.slideContent && this.createLayoutShape) this.createLayoutShape("remove", "", this.slideContent);

            if (this.layoutShapeAddCallback) {
                let slideID = this.slideContent && this.slideContent.id ? this.slideContent.id : null;
                this.layoutShapeAddCallback(slideID);
            }
            let arrSentences = [];
            for (let i = 0; i < this.sgData.length - startIndex; i++) {
                let dummyDiv = document.createElement("div");
                dummyDiv.innerHTML = this.sgData[i + 1].title;
                this.sgParent.appendChild(dummyDiv);
                let textValue = dummyDiv.textContent == "" ? "Type a special text" : dummyDiv.textContent;
                arrSentences.push(textValue);
                this.sgParent.removeChild(dummyDiv);

                if (this.sgData.length > 1) {
                    let numberParent = document.createElement("div");
                    numberParent.id = "sgNumberTextParent" + i;
                    let numberglobalstyle = props && props.number && props.number.numberglobalstyle ? props.number.numberglobalstyle : "";
                    numberParent.className = "sgNumberTextParent clsSeqTitleParent moodanimation";
                    this.setTextType(numberParent);
                    this.textParentMain.appendChild(numberParent);
                    this.textParentMain.classList.remove("clsSingleColorParent");
                    if (numberglobalstyle) {
                        this.textParentMain.classList.remove(numberglobalstyle);
                        this.textParentMain.classList.add(numberglobalstyle);
                        this.textParentMain.classList.add("clsSingleColorParent");
                    }

                    let numberText = this.objDataToSG && this.objDataToSG.numberFormat ? this.specialGraphicsUtils.getSeqMoodStyle(this.objDataToSG.numberFormat, i + 1) : i + 1;
                    let slideNo = this.specialGraphicsUtils.createTextElement(numberParent, numberText, "textFlipSlideNo" + i, "textFlipSlideNo n1 clsSeqText", "", false);
                    slideNo.contentEditable = false;
                    numberParent.style.opacity = i == 0 ? 1 : 0;
                    numberParent.appendChild(slideNo);

                    if (props && props.number) {
                        // let numberProp = props.number;
                        this.specialgraphicsPropertyUtils.applyNumberProperties(props, slideNo, this.textParentMain, 0, true);
                        numberParent.style.margin = slideNo.style.margin;
                        slideNo.style.margin = "unset";
                        if (props.number.positionvalue) numberParent.style.setProperty("position", props.number.positionvalue, "important");
                    } else {
                        numberParent.style.right = "0px";
                        numberParent.style.bottom = "0px";
                    }
                }
            }

            let jsonObj = this.specialGraphicsUtils.extractUniquePattern(arrSentences);
            if (!jsonObj.hasProperPatten || jsonObj.hasIdentialSentence) {
                for (let i = 0; i < this.sgData.length - startIndex; i++) {
                    let flipDiv = document.createElement("div");
                    flipDiv.className = "clsFlipDiv";
                    flipDiv.id = "clsFlipDiv" + i;
                    this.setTextType(flipDiv);
                    let flipText = this.getFlipText(this.textParentMain, i);
                    flipText.style.setProperty("z-index", this.sgData.length - i);
                    let modifiedString = TextHighLightUtils.highlightToString(this.sgData[i + 1].title);
                    flipText.innerHTML = modifiedString;
                    flipText.setAttribute("data-oldtext", flipText.innerHTML);
                    flipText.scrollTop = 0;
                    if (i != 0) flipDiv.style.opacity = 0;
                    flipDiv.appendChild(flipText);
                    flipRoot.appendChild(flipDiv);
                    if (letterSpacingValue) flipText.style.letterSpacing = letterSpacingValue;
                    if (contentPadding) {
                        this.specialgraphicsPropertyUtils.updatePadding(contentPadding, flipDiv);
                        // flipText.style.paddingBottom = parseFloat(flipText.style.paddingBottom) > 14 ? "14px" : flipText.style.paddingBottom;
                        // flipText.style.paddingTop = parseFloat(flipText.style.paddingBottom) > 14 ? "14px" : flipText.style.paddingTop;
                        // flipText.style.paddingRight = parseFloat(flipText.style.paddingBottom) > 14 ? "14px" : flipText.style.paddingRight;
                        // flipText.style.paddingLeft = parseFloat(flipText.style.paddingBottom) > 14 ? "14px" : flipText.style.paddingLeft;
                    }
                }
            } else {
                for (let i = 0; i < jsonObj.patternData.length; i++) {
                    let isHeader = true;
                    let arrPattern = jsonObj.patternData[i];
                    for (let j = 0; j < arrPattern.length; j++) {
                        if (arrPattern[j].text) {
                            if (i == 0) {
                                if (isHeader) textHeader.innerHTML = textHeader.innerHTML + " " + arrPattern[j].text;
                                else textFooter.innerHTML = textFooter.innerHTML + " " + arrPattern[j].text;
                            }
                        } else {
                            let flipText = flipRoot.querySelector("div[id=flipText" + i + "]");
                            let flipDiv = flipRoot.querySelector("div[id=clsFlipDiv" + i + "]");
                            if (!flipText) {
                                flipDiv = document.createElement("div");
                                flipDiv.className = "clsFlipDiv";
                                flipDiv.id = "clsFlipDiv" + i;
                                this.setTextType(flipDiv);
                                flipText = this.getFlipText(this.textParentMain, i);
                                flipText.style.setProperty("z-index", this.sgData.length - i);
                                flipText.scrollTop = 0;
                                if (i != 0) flipDiv.style.opacity = 0;
                                flipDiv.appendChild(flipText);
                                flipRoot.appendChild(flipDiv);
                            }
                            if (letterSpacingValue) flipText.style.letterSpacing = letterSpacingValue;
                            if (contentPadding) {
                                this.specialgraphicsPropertyUtils.updatePadding(contentPadding, flipDiv);
                                // flipText.style.paddingBottom = parseFloat(flipText.style.paddingBottom) > 14 ? "14px" : flipText.style.paddingBottom;
                                // flipText.style.paddingTop = parseFloat(flipText.style.paddingBottom) > 14 ? "14px" : flipText.style.paddingTop;
                                // flipText.style.paddingRight = parseFloat(flipText.style.paddingBottom) > 14 ? "14px" : flipText.style.paddingRight;
                                // flipText.style.paddingLeft = parseFloat(flipText.style.paddingBottom) > 14 ? "14px" : flipText.style.paddingLeft;
                            }
                            let modifiedString = TextHighLightUtils.highlightToString(flipText.innerHTML + " " + arrPattern[j]);
                            if (/^\s/.test(modifiedString)) modifiedString = modifiedString.trimStart();
                            flipText.innerHTML = modifiedString;
                            TextHighLightUtils.updateHighlight(flipText, modifiedString);
                            isHeader = false;
                        }
                    }
                }
            }
            if (textHeader.innerHTML == "") textHeader.remove();
            this.textParentMain.appendChild(flipRoot);
            this.textParentMain.appendChild(textFooter);
            if (textFooter.innerHTML == "") textFooter.remove();

            let headerLineHeight = window.getComputedStyle(textHeader).lineHeight;
            let elementPadding = this.specialGraphicsUtils.getPadding(textHeader);
            let newHeight = parseFloat(headerLineHeight) + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom);

            if (textHeader.innerHTML != "") textHeader.style.minHeight = newHeight;
            if (textFooter.innerHTML != "") textFooter.style.minHeight = newHeight;
            if (textHeader.innerHTML != "") textHeader.style.maxHeight = parseFloat(newHeight) * 3 + "px";
            if (textFooter.innerHTML != "") textFooter.style.maxHeight = parseFloat(newHeight) * 3 + "px";

            let flipText = this.textParentMain.querySelector("[id*='flipText']");
            let flipTextLineHeight = flipText ? window.getComputedStyle(flipText).lineHeight : 0;
            let flipTextPadding = flipText ? this.specialGraphicsUtils.getPadding(flipText.parentElement) : 0;
            let flipTextNewHeight = parseFloat(flipTextLineHeight) + parseFloat(flipTextPadding.paddingTop) + parseFloat(flipTextPadding.paddingBottom);
            flipRoot.style.minHeight = flipTextNewHeight + "px";
            flipRoot.style.maxHeight = parseFloat(flipTextNewHeight) * 1 + "px";
            flipRoot.style.setProperty("--flipMaxHeight", parseFloat(flipTextNewHeight) * 1 + "px");

            this.onTextChangeForAllNodes();
        } else {
            this.clearListener(false);
            for (let c = 0; c < this.sgData.length; c++) {
                let assetParent = this.sgParent.querySelector("[id='assetParent" + c + "']");
                assetParent = c == 0 ? this.sgParent.querySelector("[id='introParent']") : assetParent;
                let elements = assetParent ? assetParent.querySelectorAll("[listener='true']") : [];
                for (let a = 0; a < elements.length; a++) {
                    this.setTextFocus(elements[a], false, assetParent, true);
                }
            }
        }
    } catch (error) {
        console.log("SG - error on fliptext init - " + error);
    }
    this.specialGraphicsCreationComplete();
};

//Completion of All slide
FlipText.prototype.specialGraphicsCreationComplete = function () {
    console.log("Render Complete Flip text");
    this.sgParent.style.opacity = 1;
    if (this.completeCallBack && this.completeCallBack.func) {
        this.completeCallBack.func(this.completeCallBack.params);
        this.completeCallBack = null;
    }
    let position = 0;
    this.eventManager.dispatch("positionchangecallback", position);

    if (this.isPresent != true) {
        let introParent = this.sgParent.querySelector("[id='introParent']");
        let indexValue = introParent?.style.opacity == "0" ? 0 : 1;
        this.floaterNavigation(indexValue);
        this.setTargetIndex();
    }
};

FlipText.prototype.setTargetIndex = function (index = 0, sgParent = null) {
    let localParent = sgParent ? sgParent : this.sgParent;
    let animationDIV = localParent && localParent.parentElement && localParent.parentElement.parentElement ? localParent.parentElement.parentElement : null;
    if (animationDIV && animationDIV.id == "animationDIV") animationDIV.setAttribute("data-target-index", index);
};

FlipText.prototype.getFlipText = function (textParentMain, i) {
    let titleFontClass = this.fontData && this.fontData.title ? this.fontData.title : "h3";
    let flipText = this.specialGraphicsUtils.createTextElement(textParentMain, "", "flipText" + i, "textFlipingItem " + titleFontClass + " background-color alter-background-bg-color", "title", false);
    flipText.setAttribute("data-prompt-text", "Type a special text");
    flipText.position = i;
    return flipText;
};

FlipText.prototype.floaterNavigation = function (index) {
    this.currentNodeIndex = this.currentNodeIndex + index;
    this.currentNodeIndex = this.currentNodeIndex < 1 ? 1 : this.currentNodeIndex;
    this.currentNodeIndex = this.currentNodeIndex > this.sgData.length ? this.sgData.length : this.currentNodeIndex;
    let introParent = this.sgParent.querySelector("[id='introParent']");
    let flipTextParent = this.sgParent.querySelector("[id='flipTextParent']");

    if (introParent) {
        introParent.style.opacity = this.currentNodeIndex - 1 == 0 ? 1 : 0;
        if (this.currentNodeIndex - 1 == 0) {
            let title = introParent.querySelector("[id='sgTitleNode']");
            let subtitle = introParent.querySelector("[id='sgSubTitleNode']");
            let titlelabel = introParent.querySelector("[id='sgTitleLabelNode']");
            if (title) title.style.opacity = 1;
            if (subtitle) subtitle.style.opacity = 1;
            if (titlelabel) titlelabel.style.opacity = 1;
        }
    }
    if (introParent) {
        introParent.style.pointerEvents = this.currentNodeIndex - 1 == 0 ? "all" : "none";
        // introParent.style.display = this.currentNodeIndex - 1 == 0 ? "flex" : "none";
        introParent.style.opacity = this.currentNodeIndex - 1 == 0 ? 1 : 0;
        introParent.style.setProperty("--textPointerEvent", this.currentNodeIndex - 1 == 0 ? "auto" : "none");
    }
    if (flipTextParent) flipTextParent.style.opacity = this.currentNodeIndex - 1 == 0 ? 0 : 1;
    if (flipTextParent) flipTextParent.style.pointerEvents = this.currentNodeIndex - 1 == 0 ? "none" : "all";

    for (let i = 0; i < this.sgData.length - 1; i++) {
        let clsFlipDiv = this.sgParent.querySelector("[id='clsFlipDiv" + i + "']");
        let textFlipSlideNo = this.sgParent.querySelector("[id='sgNumberTextParent" + i + "']");
        if (clsFlipDiv && i == this.currentNodeIndex - 2) clsFlipDiv.style.opacity = "1";
        else if (clsFlipDiv) clsFlipDiv.style.opacity = "0";
        if (textFlipSlideNo && i == this.currentNodeIndex - 2) textFlipSlideNo.style.opacity = "1";
        else if (textFlipSlideNo) textFlipSlideNo.style.opacity = "0";
    }
    let isPreview = this.isPreviewMode && this.isPreviewMode == true ? true : false;
    if (isPreview == false) {
        this.updatenavFloater();
        this.eventManager.dispatch("positionchangecallback", this.currentNodeIndex - 1);
    }
};

FlipText.prototype.gotoAndStopFirstNode = function (completeCallback, type, slideContent) {
    if (slideContent) this.sgParent = slideContent.querySelector("[id='specialgraphicsParent']");
    let flipTextStackParent = this.sgParent.querySelector("[id='flipTextStackParent']");
    this.textParentMain = flipTextStackParent.querySelector("[id='flipTextParent']");
    let introParent = flipTextStackParent.querySelector("[id='introParent']");
    let isEmptyIntro = introParent && introParent.style.display == "none";
    this.currentNodeIndex = isEmptyIntro ? 2 : 1;
    introParent.style.opacity = 0;
    this.textParentMain.style.opacity = 0;
    if (this.isPlayAnimation) introParent.style.transition = "opacity 1s 0.5s ease";
    this.eventManager.dispatch("positionchangecallback", 1);
    if (this.isPlayAnimation) this.textParentMain.style.transition = "opacity 1s 0.4s ease";
    setTimeout(() => {
        this.floaterNavigation(0);
        introParent.style.opacity = 1;
    }, 0);
    setTimeout(
        () => {
            completeCallback ? completeCallback() : "";
        },
        this.isPlayAnimation ? 1000 : 0
    );
};

FlipText.prototype.hideAnimation = function (completeCallback) {
    if (this.isPlayAnimation) this.sgParent.style.transition = "opacity 0.8s ease";
    this.sgParent.style.opacity = 0;
    setTimeout(() => {
        completeCallback ? completeCallback() : "";
    }, 800);
};

FlipText.prototype.next = function (completeCallback) {
    this.sgParent.setAttribute("dotransition", "false");
    this.currentType = "next";
    this.currentNodeIndex = this.currentNodeIndex + 1;
    this.clearStyle();
    if (this.currentNodeIndex < 1 || this.currentNodeIndex > this.sgData.length) {
        completeCallback ? completeCallback() : "";
        return;
    }
    let introParent = this.sgParent.querySelector("[id='introParent']");
    if (this.isPlayAnimation) introParent.style.transition = "opacity 1s ease";
    introParent.style.opacity = 0;
    this.textParentMain.style.opacity = 1;
    this.doInAnimation(completeCallback);
};

FlipText.prototype.clearStyle = function () {
    let style = this.sgParent.querySelector("[id='CssAnimStyle']");
    let parent = style.parentElement;
    parent.removeChild(style);

    let style2 = document.createElement("style");
    style2.id = "CssAnimStyle";
    parent.appendChild(style2);
};

FlipText.prototype.doInAnimation = function (callback) {
    if (this.currentNodeIndex - 1 < this.sgData.length) {
        let duration = this.isAnimate ? 0.3 : 0;
        let addingValue = this.currentType == "next" ? 2 : this.currentType == "previous" ? 0 : 0;
        let indexVal = this.currentNodeIndex - 1;
        this.eventManager.dispatch("positionchangecallback", this.currentNodeIndex - 1);

        let style = this.sgParent.querySelector("[id='CssAnimStyle']");
        setTimeout(() => {
            let flipText1 = this.sgParent.querySelector("[id='flipText" + (indexVal - addingValue) + "']");
            let htmlParent = flipText1 ? flipText1.parentElement : null;
            if (htmlParent) {
                htmlParent.style.setProperty("transform-origin", "top");
                style.sheet.insertRule(
                    "@keyframes flipAnimationOut" +
                        (indexVal - addingValue) +
                        " {\
                    0% { transform: rotate3d(1,0,0,0deg) translateY(0px);}\
                    100% { transform: rotate3d(1,0,0,85deg) translateY(-22px);}\
                }"
                );
                duration = this.isAnimate == false ? 0.1 : duration;
                htmlParent.style.animation = "flipAnimationOut" + (indexVal - addingValue) + " " + duration + "s ease-in forwards";
                this.doNumberAnimation(indexVal - addingValue, "out");
            }
        }, 0);
        setTimeout(
            () => {
                let flipText2 = this.sgParent.querySelector("[id='flipText" + (indexVal - 1) + "']");
                let htmlParent2 = flipText2.parentElement;
                htmlParent2.style.opacity = 1;
                htmlParent2.style.setProperty("transform-origin", "bottom");
                style.sheet.insertRule(
                    "@keyframes flipAnimationIn" +
                        (indexVal - 1) +
                        " {\
                            0% { transform: rotate3d(1,0,0,-85deg) translateY(73px)}\
                            100% { transform: rotate3d(1,0,0,0deg); translateY(0px)}\
                        }"
                );
                duration = this.isAnimate == false ? 0.1 : duration;
                htmlParent2.style.animation = "flipAnimationIn" + (indexVal - 1) + ` ${duration}s ease-in forwards`;
                htmlParent2.callback = callback;
                htmlParent2.addEventListener("animationend", this.animationCompleteListener.bind(this), false);
                this.doNumberAnimation(indexVal - 1, "in");
            },
            this.isAnimate == false ? 0.1 : 0
        );
    }
};

//Animation Complete Listener
FlipText.prototype.animationCompleteListener = function (event) {
    let addingValue = this.currentType == "next" ? 2 : this.currentType == "previous" ? 0 : 0;
    let flipText1 = this.sgParent.querySelector("[id='clsFlipDiv" + (this.currentNodeIndex - addingValue - 1) + "']");
    let flipText2 = this.sgParent.querySelector("[id='clsFlipDiv" + (this.currentNodeIndex - 1 - 1) + "']");
    if (flipText1) {
        flipText1.style.opacity = 0;
        flipText1.parentElement.style.animation = null;
    }
    if (flipText2) flipText2.parentElement.style.animation = null;

    let callBack = event.target.callback;
    callBack ? callBack() : "";
    event.target.removeEventListener("animationend", this.animationCompleteListener);
    event.target.callback = null;
};

FlipText.prototype.doNumberAnimation = function (index, type = "in") {
    let slideNo = this.sgParent.querySelector("[id='sgNumberTextParent" + index + "']");
    if (slideNo) {
        let toOpacity = type == "in" ? 1 : 0;
        if (this.isPlayAnimation) slideNo.style.transition = "opacity 1s ease";
        slideNo.style.opacity = toOpacity;
    }
};

FlipText.prototype.previous = function (completeCallback) {
    this.currentType = "previous";
    this.currentNodeIndex = this.currentNodeIndex - 1;
    this.clearStyle();
    if (this.currentNodeIndex < 1 || this.currentNodeIndex > this.sgData.length) return;
    if (this.currentNodeIndex == 1) {
        let introParent = this.sgParent.querySelector("[id='introParent']");
        if (introParent.style.display == "none") return false;
        if (this.isPlayAnimation) {
            introParent.style.transition = "opacity 1s 0.5s ease";
            this.textParentMain.style.transition = "opacity 0.8s ease";
        }
        introParent.style.opacity = 1;
        this.textParentMain.style.opacity = 0;
        completeCallback ? completeCallback() : "";
    } else this.doInAnimation(completeCallback);
};

FlipText.prototype.changeVariation = function (slideDomContentGroup) {
    this.updateIntroVisibility();
    let nodeData = slideDomContentGroup.getElementsByTagName("numbertext")[0];
    for (let i = 0; i < this.sgData.length; i++) {
        let id = "sgNumberTextParent" + i;
        if (!!this.sgParent.querySelector("[id='" + id + "']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
            this.sgParent.querySelector("[id='" + id + "']").style.display = "none";
        } else if (!!this.sgParent.querySelector("[id='" + id + "']")) {
            let display = this.sgParent.querySelector("[id='" + id + "']").hasAttribute("display") ? this.sgParent.querySelector("[id='" + id + "']").getAttribute("display") : "";
            this.sgParent.querySelector("[id='" + id + "']").style.display = display;
        }
    }
    let titleNode = this.sgParent.querySelector("[id='sgTitleNode']");
    let sgTitleLabelNode = this.sgParent.querySelector("[id='sgTitleLabelNode']");
    let subTitleNode = this.sgParent.querySelector("[id='sgSubTitleNode']");

    let oldDisplay = subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "";

    nodeData = slideDomContentGroup.getElementsByTagName("title")[0];
    if (titleNode && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        titleNode.style.display = "none";
        titleNode.parentElement.style.display = "none";
    } else if (titleNode) {
        let display = titleNode.hasAttribute("display") ? titleNode.getAttribute("display") : "";
        titleNode.style.display = display;
        titleNode.parentElement.style.display = display;
    }

    nodeData = slideDomContentGroup.getElementsByTagName("subtitle")[0];
    if (subTitleNode && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        subTitleNode.style.display = "none";
        subTitleNode.parentElement.style.display = "none";
    } else if (subTitleNode) {
        let display = subTitleNode.hasAttribute("display") ? subTitleNode.getAttribute("display") : "";
        subTitleNode.style.display = display;
        subTitleNode.parentElement.style.display = display;
    }

    nodeData = slideDomContentGroup.getElementsByTagName("titlelabel")[0];
    if (sgTitleLabelNode && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        sgTitleLabelNode.style.display = "none";
        sgTitleLabelNode.parentElement.style.display = "none";
    } else if (sgTitleLabelNode) {
        let display = sgTitleLabelNode.hasAttribute("display") ? sgTitleLabelNode.getAttribute("display") : "";
        sgTitleLabelNode.style.display = display;
        sgTitleLabelNode.parentElement.style.display = display;
    }

    let newDisplay = subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "";
    if (titleNode && subTitleNode && newDisplay != oldDisplay && this.fontData.title.length <= 2) {
        let isSubtitleEnabled = window.getComputedStyle(subTitleNode)["display"] == "none" ? false : true;
        let isIntro = true;
        titleNode.classList.remove(this.fontData[(isIntro ? "intro" : "") + "title"]);
        titleNode.classList.remove(this.fontData[(isIntro ? "intro" : "") + "titleNoSubtitle"]);

        this.specialGraphicsUtils.removeAllFontClass(titleNode);

        let fontClass = isSubtitleEnabled == false ? this.fontData[(isIntro ? "intro" : "") + "titleNoSubtitle"] : this.fontData[(isIntro ? "intro" : "") + "title"];
        if (!fontClass) fontClass = isSubtitleEnabled == false ? this.fontData["titleNoSubtitle"] : this.fontData["title"];
        titleNode.classList.add(fontClass);
        titleNode.setAttribute("data-font", fontClass);
        titleNode.style.removeProperty("min-height");
        titleNode.style.removeProperty("max-height");
        titleNode.style.removeProperty("font-size");

        titleNode.setAttribute("defaultsize", parseFloat(window.getComputedStyle(titleNode)["font-size"]));
        if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(titleNode);
        if (titleNode.hasAttribute("user-font-size")) {
            this.specialGraphicsUtils.removeAllFontClass(titleNode);
            titleNode.classList.add(titleNode.getAttribute("user-font-size"));
        }
        this.specialGraphicsUtils.doCheckMaxHeight(titleNode, this.sgParent);
        this.specialGraphicsUtils.doFontFitForCss(titleNode, this.sgParent);
    }
    this.onTextChangeForAllNodes();
    let textInnerParentNode = this.sgParent.querySelector("[id='textInnerParentNode']");
    this.textElementPositioning(this.sgParent, textInnerParentNode, 0);
    this.updatenavFloater();
};

FlipText.prototype.updatenavFloater = function () {
    if (this.isPlayAnimation == false && this.isPresent != true) {
        let assetParent0 = this.sgParent.querySelector("[id='introParent']");
        if (assetParent0 && this.updateNavFloaterIndex) {
            let isIntroHide = this.sgParent?.parentElement?.parentElement?.getAttribute("data-ogdata-finalhide_0")?.split(",")?.includes("intro");
            let isVisible = isIntroHide ? -1 : 0;
            if (assetParent0.hasAttribute("hide") && assetParent0.getAttribute("hide") == "true") isVisible = -1;
            let slideID = this.slideContent && this.slideContent.id ? this.slideContent.id : null;
            this.updateNavFloaterIndex(this.currentNodeIndex + isVisible, slideID, isVisible, this.currentNodeIndex - 1 + isVisible);
        }
    }
};

FlipText.prototype.changeText = function (updatedText, elementId, targetIndex, textType) {
    let textInnerParentNode = this.sgParent.querySelector("[id='textInnerParentNode']");
    this.textElementPositioning(this.sgParent, textInnerParentNode, 0);
};

// //Adding listeners in event manager
// FlipText.prototype.addListener = function (event, callback) {
//     this.eventManager.addListener(event, callback);
// };

// //Removing listeners in event manager
// FlipText.prototype.removeListener = function (event, callback) {
//     this.eventManager.removeListener(event, callback);
// };

// //Clear all the listeners and callbacks - ABORT method
// FlipText.prototype.clearListener = function () {
//     this.eventManager.clear();
//     this.completeCallBack = null;
// };


FlipText.prototype.createTextInnerParentNode = function (id, parent) {
    let textInnerParentNode = document.createElement("div");
    textInnerParentNode.id = id;
    this.setTextType(textInnerParentNode);
    textInnerParentNode.className = id;
    parent.appendChild(textInnerParentNode);
    return textInnerParentNode;
};

// //Paste callback for text elements
// FlipText.prototype.pasteCallBack = function (event) {
//     event.preventDefault();
//     let strUnformattedText = event.clipboardData.getData("text/plain");
//     document.execCommand("insertText", false, strUnformattedText);

//     this.specialGraphicsUtils.doFontFitForCss(event.target, this.sgParent);
// };

// //text focusin//focusout callback
// FlipText.prototype.focusCallBack = function (event) {
//     let element = event.target;
//     if (event.type == "focusout") {
//         let oldText = element.getAttribute("data-heading") ? element.getAttribute("data-heading") : "";
//         if (oldText != element.innerHTML) {
//             element.setAttribute("data-heading", element.innerHTML);
//             this.eventManager.dispatch("textchangecallback", element.innerHTML, element.id);
//         }
//         element.scrollTop = 0;
//         if (element.innerHTML == "" || element.innerHTML == "<br>") element.innerHTML = "";

//         element.style.removeProperty("font-size");
//         this.specialGraphicsUtils.doFontFitForCss(element, this.sgParent, null, this.textElementPositioning, this);
//         if (element.id == "sgTitleLabelNode") element.style.maxHeight = window.getComputedStyle(element).lineHeight;
//     } else if (event.type == "focusin") {
//         element.style.wordBreak = "break-word";
//         element.setAttribute("data-oldtext", element.innerHTML);
//     }
// };

// //Setting up text focus and text paste focus
// FlipText.prototype.setTextFocus = function (textNode, doFontFit = true) {
//     this.eventManager.addEvent(textNode, "focusout", this.focusCallBack);
//     this.eventManager.addEvent(textNode, "focusin", this.focusCallBack);
//     this.eventManager.addEvent(textNode, "paste", this.pasteCallBack);

//     if (doFontFit == true) {
//         this.eventManager.addObserver(this.setTextChangeListner(textNode));
//         textNode.style.removeProperty("font-size");
//         this.specialGraphicsUtils.doFontFitForCss(textNode, this.sgParent);
//     }
// };

// FlipText.prototype.setTextChangeListner = function (element) {
//     if (element) {
//         let config = {
//             subtree: true,
//             characterData: true,
//             childList: true,
//         };
//         let callback = function () {
//             this.specialGraphicsUtils.doFontFitForCss(element, this.sgParent, null, this.textElementPositioning, this);

//             let lh = parseFloat(window.getComputedStyle(element).lineHeight);

//             if (element.id == "sgTitleLabelNode") element.style.maxHeight = lh;
//             else if (element.id == "sgTitleNode") element.style.maxHeight = lh * 2 + "px";
//             else if (element.id == "sgSubTitleNode") element.style.maxHeight = lh * 3 + "px";
//         };
//         let observer = new MutationObserver(callback.bind(this));
//         observer.observe(element, config);
//         return observer;
//     }
// };

FlipText.prototype.onTextChangeForAllNodes = function (sgParent = null) {
    let assetParent = null;
    if (sgParent) assetParent = sgParent.querySelector("[id='introParent']");
    if (!assetParent) assetParent = this.sgParent.querySelector("[id='introParent']");

    let oldDisplay = assetParent?.style?.display == "none" ? "none" : "";
    if (oldDisplay == "none") assetParent.style.display = "flex";

    let textBaseParentNode = assetParent.querySelector("[id*='textBaseParentNode']");
    if (!textBaseParentNode) textBaseParentNode = assetParent;
    if (textBaseParentNode) {
        textBaseParentNode.style.overflow = "hidden";
        let titleNode = textBaseParentNode.querySelector("[id*='sgTitleNode']");
        let subTitleNode = textBaseParentNode.querySelector("[id*='sgSubTitleNode']");
        let sgTitleLabelNode = textBaseParentNode.querySelector("[id*='sgTitleLabelNode']");

        if (sgTitleLabelNode) {
            if (this.removeHighlightFocus) this.removeHighlightFocus(assetParent, sgTitleLabelNode);
            // sgTitleLabelNode.style.maxHeight = window.getComputedStyle(sgTitleLabelNode).lineHeight;
            // sgTitleLabelNode.parentElement.style.maxHeight = window.getComputedStyle(sgTitleLabelNode).lineHeight;
            let elementPadding = this.specialGraphicsUtils.getPadding(sgTitleLabelNode);
            let labelStyle = window.getComputedStyle(sgTitleLabelNode);
            sgTitleLabelNode.style.maxHeight = parseFloat(labelStyle.lineHeight) + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
            sgTitleLabelNode.parentElement.style.maxHeight = sgTitleLabelNode.style.maxHeight;
        }
        if (subTitleNode) {
            if (this.removeHighlightFocus) this.removeHighlightFocus(assetParent, subTitleNode);
            let supportParent = subTitleNode.hasAttribute("data-support") ? true : false;
            subTitleNode.style.removeProperty("max-height");
            subTitleNode.style.setProperty("max-height", "unset", "important");
            if (supportParent != true) subTitleNode.parentElement.style.removeProperty("max-height");
            this.onTextChangeUpdate(subTitleNode, true, assetParent);
        }
        if (titleNode) {
            if (this.removeHighlightFocus) this.removeHighlightFocus(assetParent, titleNode);
            titleNode.style.removeProperty("max-height");
            titleNode.parentElement.style.removeProperty("max-height");
            this.onTextChangeUpdate(titleNode, true, assetParent);
        }
    }
    if (oldDisplay) assetParent.style.display = oldDisplay;
};

FlipText.prototype.onTextChange = function (element) {
    let textNode = element;
    this.onTextChangeUpdate(textNode);
};
FlipText.prototype.onTextChangeUpdate = function (textNode, isStart = false, assetParentNode = null) {
    let assetParent = assetParentNode ? assetParentNode : this.sgParent.querySelector("[id='introParent']");
    let textBaseParentNode = assetParent.querySelector("[id*='textBaseParentNode']");

    if (textBaseParentNode) {
        if (textNode.id.includes("sgTitleLabelNode")) {
            let labelStyle = window.getComputedStyle(textNode);
            let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
            textNode.style.maxHeight = parseFloat(labelStyle.lineHeight) + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
            textNode.parentElement.style.maxHeight = textNode.style.maxHeight;
        } else {
            let removeMaxHeight = this.carouselType && this.carouselType == "onlytitle" ? false : true;
            if (removeMaxHeight) textNode.style.removeProperty("max-height");
            textNode.parentElement.style.removeProperty("max-height");

            let titleNode = textBaseParentNode.querySelector("[id*='sgTitleNode']");
            let subTitleNode = textBaseParentNode.querySelector("[id*='sgSubTitleNode']");
            let sgTitleLabelNode = textBaseParentNode.querySelector("[id*='sgTitleLabelNode']");
            let textInnerParentNode = textBaseParentNode.querySelector("[id*='textInnerParentNode']");
            let sgNumberTextNode = textBaseParentNode.querySelector("[id*='sgNumberTextNode']");

            let numberStyle = sgNumberTextNode ? window.getComputedStyle(sgNumberTextNode) : null;
            let numberMargin = numberStyle ? parseFloat(numberStyle.height == "auto" ? 0 : numberStyle.height) + parseFloat(numberStyle.marginTop) + parseFloat(numberStyle.marginBottom) : 0;
            numberMargin = isNaN(numberMargin) ? 0 : numberMargin;

            let textParentStyle = textInnerParentNode ? window.getComputedStyle(textInnerParentNode.parentElement) : null;
            let textParentMargin = textParentStyle ? parseFloat(textParentStyle.marginTop) + parseFloat(textParentStyle.marginBottom) : 0;

            let innerParentStyle = textInnerParentNode ? window.getComputedStyle(textInnerParentNode) : null;
            let innerParentMargin = innerParentStyle ? parseFloat(innerParentStyle.marginTop) + parseFloat(innerParentStyle.marginBottom) : 0;

            let labelParentStyle = sgTitleLabelNode ? window.getComputedStyle(sgTitleLabelNode.parentElement) : null;
            let labelStyle = sgTitleLabelNode ? window.getComputedStyle(sgTitleLabelNode) : null;
            let hasLabel = (sgTitleLabelNode && sgTitleLabelNode.style.display == "none") || !sgTitleLabelNode ? false : true;
            let labelMargin = labelParentStyle ? parseFloat(labelParentStyle.marginTop) + parseFloat(labelParentStyle.marginBottom) : 0;
            labelMargin = hasLabel ? (labelStyle ? parseFloat(labelStyle.marginTop) + parseFloat(labelStyle.marginBottom) : 0) + labelMargin : 0;

            let subTitileParentStyle = subTitleNode ? window.getComputedStyle(subTitleNode.parentElement) : null;
            let subTitileStyle = subTitleNode ? window.getComputedStyle(subTitleNode) : null;
            let hasSubtitle = (subTitleNode && subTitleNode.style.display == "none") || !subTitleNode ? false : true;
            let subTitileMargin = subTitileParentStyle ? parseFloat(subTitileParentStyle.marginTop) + parseFloat(subTitileParentStyle.marginBottom) : 0;
            subTitileMargin = hasSubtitle ? (subTitileStyle ? parseFloat(subTitileStyle.marginTop) + parseFloat(subTitileStyle.marginBottom) : 0) + subTitileMargin : 0;

            let titileParentStyle = titleNode ? window.getComputedStyle(titleNode.parentElement) : null;
            let titileMargin = titileParentStyle ? parseFloat(titileParentStyle.marginTop) + parseFloat(titileParentStyle.marginBottom) : 0;

            let textBaseHeight = parseFloat(window.getComputedStyle(textBaseParentNode).height);
            if (textBaseParentNode && textBaseParentNode.hasAttribute("fullheight")) textBaseHeight = parseFloat(textBaseParentNode.getAttribute("fullheight"));
            if (window.getComputedStyle(textBaseParentNode).height == "" && textBaseParentNode.style.maxHeight != "" && textBaseParentNode.style.maxHeight.includes("px")) textBaseHeight = parseFloat(textBaseParentNode.style.maxHeight);
            let maxHeight = window.getComputedStyle(textBaseParentNode).maxHeight;
            if (maxHeight == "none") maxHeight = textBaseParentNode.style.maxHeight;
            if (maxHeight != "" && maxHeight != "0px" && !isNaN(parseFloat(maxHeight))) if (maxHeight.includes("px")) textBaseHeight = parseFloat(maxHeight);
            let isCarousel = assetParent && assetParent.id.includes("lytAssetTextParent") ? true : false;
            let isNonNanVal = !isNaN(parseFloat(maxHeight)) || (maxHeight.includes("%") && maxHeight.includes("var")) ? true : false;
            if (maxHeight != "" && maxHeight != "0px" && isNonNanVal && isCarousel == false) {
                if (maxHeight.includes("px")) textBaseHeight = parseFloat(maxHeight);
                else if (maxHeight.includes("%")) {
                    let oldParentHeight = null;
                    if (textBaseParentNode.parentElement && textBaseParentNode.parentElement.style.height == "auto" && textBaseParentNode.parentElement.hasAttribute("fullheight")) {
                        oldParentHeight = textBaseParentNode.parentElement.style.height;
                        textBaseParentNode.parentElement.style.height = textBaseParentNode.parentElement.getAttribute("fullheight");
                    }
                    let oldParentH = textBaseParentNode.style.height;
                    textBaseParentNode.style.height = textBaseParentNode.style.maxHeight;
                    let hh = parseFloat(window.getComputedStyle(textBaseParentNode).height);
                    if (hh > 0 && !isNaN(hh)) textBaseHeight = hh;
                    textBaseParentNode.style.height = oldParentH;
                    if (oldParentHeight) textBaseParentNode.parentElement.style.height = oldParentHeight;
                }
            }
            //removing margin/padding things on total base height
            let textParentHeight =
                textBaseHeight - (isNaN(labelMargin) ? 0 : labelMargin) - (isNaN(subTitileMargin) ? 0 : subTitileMargin) - (isNaN(titileMargin) ? 0 : titileMargin) - (isNaN(innerParentMargin) ? 0 : innerParentMargin) - (isNaN(textParentMargin) ? 0 : textParentMargin) - (isNaN(numberMargin) ? 0 : numberMargin);
            let titleHeight = titleNode?.scrollHeight > 0 ? titleNode.scrollHeight : !titleNode || titleNode?.offsetHeight == 0 ? 0 : titleNode.style.maxHeight != "" && titleNode.style.display != "none" ? parseFloat(titleNode.style.maxHeight) : window.getComputedStyle(titleNode).height;
            let subTitleHeight = subTitleNode?.scrollHeight > 0 ? subTitleNode.scrollHeight : !subTitleNode || subTitleNode?.offsetHeight == 0 ? 0 : subTitleNode.style.maxHeight != "" && subTitleNode.style.display != "none" ? parseFloat(subTitleNode.style.maxHeight) : window.getComputedStyle(subTitleNode).height;
            let lableHeight = !sgTitleLabelNode || sgTitleLabelNode?.offsetHeight == 0 ? 0 : sgTitleLabelNode.style.maxHeight != "" && sgTitleLabelNode.style.display != "none" ? parseFloat(sgTitleLabelNode.style.maxHeight) : window.getComputedStyle(sgTitleLabelNode).height;
            //calculating total current text height
            let totalTextHeight = parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight);

            let lineHeight = window.getComputedStyle(textNode).lineHeight;
            let fontsize = window.getComputedStyle(textNode).fontSize;
            lineHeight = isNaN(parseFloat(lineHeight)) ? parseFloat(fontsize) * 1.2 : parseFloat(lineHeight);
            let noLines = Math.max(textNode.parentElement.offsetHeight / lineHeight, 1);
            let offDifference = noLines - parseInt(noLines);
            let lines = offDifference > 0.9 ? parseInt(noLines) + 1 : parseInt(noLines);

            //If text height increase total height we have doing fit logic
            if (typeof totalTextHeight == "string") totalTextHeight = parseFloat(totalTextHeight);
            if (typeof textParentHeight == "string") textParentHeight = parseFloat(textParentHeight);
            totalTextHeight = totalTextHeight.toFixed(1);
            textParentHeight = textParentHeight.toFixed(1);
            if (typeof totalTextHeight == "string") totalTextHeight = parseFloat(totalTextHeight);
            if (typeof textParentHeight == "string") textParentHeight = parseFloat(textParentHeight);
            let commonRemainingHeight = 0;
            if (totalTextHeight > textParentHeight) {
                // if (isStart == true) {
                //     let extraValues = totalTextHeight - textParentHeight;
                //     if (extraValues >= 0) {
                //         this.loop(lines, lineHeight, textNode, textParentHeight, titleNode, subTitleNode, sgTitleLabelNode);
                //     } else {
                //         textNode.style.removeProperty("max-height");
                //         textNode.parentElement.style.removeProperty("max-height");
                //     }
                // } else {
                let targetNodeHeight = textNode.id.includes("sgTitleNode")
                    ? parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : textNode.id.includes("sgSubTitleNode")
                    ? parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight);
                let remainingHeight = textParentHeight - targetNodeHeight;
                commonRemainingHeight = remainingHeight;
                if (lines == 1) remainingHeight = lineHeight;

                let linesFinal = remainingHeight / lineHeight;
                let offDiff = linesFinal - parseInt(linesFinal);
                linesFinal = offDiff > 0.9 ? parseInt(linesFinal) + 1 : parseInt(linesFinal);

                let heightFinal = linesFinal * lineHeight;
                heightFinal = heightFinal == 0 ? lineHeight : heightFinal;

                if (lines == 1) heightFinal = heightFinal + subTitileMargin;
                textNode.style.maxHeight = heightFinal + "px";
                textNode.style.removeProperty("max-height");
                textNode.parentElement.style.removeProperty("max-height");
                textNode.parentElement.style.maxHeight = heightFinal + "px";
                // }
            } else {
                let targetNodeHeight = textNode.id.includes("sgTitleNode")
                    ? parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : textNode.id.includes("sgSubTitleNode")
                    ? parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight)
                    : parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight);
                let remainingHeight = textParentHeight - targetNodeHeight;

                commonRemainingHeight = remainingHeight;
            }

            DiagramResizeUtils.commonFontResize(totalTextHeight, textParentHeight, commonRemainingHeight, textNode, textNode.parentElement, this.objDataToSG.fontClassLists, true);

            this.onTextUpdate(textNode);
        }
    }
};

FlipText.prototype.loop = function (lines, lineHeight, textNode, textParentHeight, titleNode, subTitleNode, sgTitleLabelNode) {
    //Loop and fitting the text inside max avaiable height
    lines = lines - 1;
    if (lines == 0) return;
    let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
    let newHeight = lines * lineHeight + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom);
    textNode.style.maxHeight = newHeight + "px";
    textNode.parentElement.style.maxHeight = newHeight + "px";

    let titleHeight = !titleNode ? 0 : titleNode.style.maxHeight != "" && titleNode.style.display != "none" ? parseFloat(titleNode.style.maxHeight) : window.getComputedStyle(titleNode).height;
    let subTitleHeight = !subTitleNode ? 0 : subTitleNode.style.maxHeight != "" && subTitleNode.style.display != "none" ? parseFloat(subTitleNode.style.maxHeight) : window.getComputedStyle(subTitleNode).height;
    let lableHeight = !sgTitleLabelNode ? 0 : sgTitleLabelNode.style.maxHeight != "" && sgTitleLabelNode.style.display != "none" ? parseFloat(sgTitleLabelNode.style.maxHeight) : window.getComputedStyle(sgTitleLabelNode).height;
    let totalTextHeight = parseFloat(titleHeight == "auto" || titleHeight == "" ? 0 : titleHeight) + parseFloat(subTitleHeight == "auto" || subTitleHeight == "" ? 0 : subTitleHeight) + parseFloat(lableHeight == "auto" || lableHeight == "" ? 0 : lableHeight);
    if (textParentHeight < totalTextHeight) this.loop(lines, lineHeight, textNode, textParentHeight, titleNode, subTitleNode, sgTitleLabelNode);
};

FlipText.prototype.onTextUpdate = function (textNode) {
    if (textNode.parentElement.offsetHeight <= textNode.offsetHeight) {
        let lineHeight = window.getComputedStyle(textNode).lineHeight;
        let fontsize = window.getComputedStyle(textNode).fontSize;
        lineHeight = isNaN(parseFloat(lineHeight)) ? parseFloat(fontsize) * 1.2 : parseFloat(lineHeight);
        let elementPadding = this.specialGraphicsUtils.getPadding(textNode);
        let noLines = Math.max(textNode.parentElement.offsetHeight / lineHeight, 1);
        let offDifference = noLines - parseInt(noLines);
        let lines = offDifference > 0.9 ? parseInt(noLines) + 1 : parseInt(noLines);
        textNode.style.maxHeight = lines * lineHeight + parseFloat(elementPadding.paddingTop) + parseFloat(elementPadding.paddingBottom) + "px";
        textNode.style.overflow = "hidden";
        textNode.parentElement.style.removeProperty("max-height");
    }
};
FlipText.prototype.getProps = function () {
    //Get slide properties
    let props = null;
    let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData && this.metaData ? this.metaData : null;
    let secondaryProp = null;
    if (metaDataBase && metaDataBase.properties) secondaryProp = metaDataBase.properties;
    if (metaDataBase && metaDataBase.properties) props = metaDataBase.properties;
    let returnVal = props ? props : secondaryProp ? secondaryProp : metaDataBase;
    if (returnVal && ((returnVal.text && returnVal.text.textstyle) || (returnVal.number && returnVal.number.numberstyle) || (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle))) {
        let textPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.textproperties ? this.objDataToSG.sgMoodsData.textproperties : null;
        let numberPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.numberproperties ? this.objDataToSG.sgMoodsData.numberproperties : null;
        let placeholderPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.placeholderimageproperties ? this.objDataToSG.sgMoodsData.placeholderimageproperties : null;

        if (returnVal.text && returnVal.text.textstyle && textPropFromMood && textPropFromMood[returnVal.text.textstyle]) {
            let newValue = textPropFromMood[returnVal.text.textstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.text[key] = newValue[key];
            });
            delete returnVal.text.textstyle;
        }
        if (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle && placeholderPropFromMood && placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle]) {
            let newValue = placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.placeholderimage[key] = newValue[key];
            });
            delete returnVal.placeholderimage.placeholderimagestyle;
        }
        if (returnVal.number && returnVal.number.numberstyle && numberPropFromMood && numberPropFromMood[returnVal.number.numberstyle]) {
            let newValue = numberPropFromMood[returnVal.number.numberstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.number[key] = newValue[key];
            });
            delete returnVal.number.numberstyle;
        }
    }
    return returnVal;
};
FlipText.prototype.getIntroProps = function () {
    //Get intro slide properties
    let props = null;
    let metaDataBase = this.metaData && this.metaData.menuData ? this.metaData.menuData : this.metaData && this.metaData ? this.metaData : null;
    let secondaryProp = null;
    if (metaDataBase && metaDataBase.introproperties) secondaryProp = metaDataBase.introproperties;
    if (metaDataBase && metaDataBase.introproperties) props = metaDataBase.introproperties;
    let returnVal = props ? props : secondaryProp ? secondaryProp : this.getProps();
    if (returnVal && ((returnVal.text && returnVal.text.textstyle) || (returnVal.number && returnVal.number.numberstyle) || (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle))) {
        let textPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.textproperties ? this.objDataToSG.sgMoodsData.textproperties : null;
        let numberPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.numberproperties ? this.objDataToSG.sgMoodsData.numberproperties : null;
        let placeholderPropFromMood = this.objDataToSG && this.objDataToSG.sgMoodsData && this.objDataToSG.sgMoodsData.placeholderimageproperties ? this.objDataToSG.sgMoodsData.placeholderimageproperties : null;

        if (returnVal.text && returnVal.text.textstyle && textPropFromMood && textPropFromMood[returnVal.text.textstyle]) {
            let newValue = textPropFromMood[returnVal.text.textstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.text[key] = newValue[key];
            });
            delete returnVal.text.textstyle;
        }
        if (returnVal.placeholderimage && returnVal.placeholderimage.placeholderimagestyle && placeholderPropFromMood && placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle]) {
            let newValue = placeholderPropFromMood[returnVal.placeholderimage.placeholderimagestyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.placeholderimage[key] = newValue[key];
            });
            delete returnVal.placeholderimage.placeholderimagestyle;
        }
        if (returnVal.number && returnVal.number.numberstyle && numberPropFromMood && numberPropFromMood[returnVal.number.numberstyle]) {
            let newValue = numberPropFromMood[returnVal.number.numberstyle];
            Object.keys(newValue).forEach(function (key) {
                returnVal.number[key] = newValue[key];
            });
            delete returnVal.number.numberstyle;
        }
    }
    return returnVal;
};
FlipText.prototype.updateIntroVisibility = function (moveToStart = false, index = 0) {
    let introParent = this.sgParent.querySelector("[id='introParent']");
    if (this.sgParent && this.sgParent.parentElement && this.sgParent.parentElement.parentElement && introParent) {
        let animationDIV = this.sgParent.parentElement.parentElement;
        let showIntro = animationDIV.getAttribute("data-ogdata-finalshow_0")?.split(",")?.includes("intro") ? "true" : "false";
        if (showIntro == "false") {
            if (animationDIV.hasAttribute("inlinefloaterchange") && animationDIV.getAttribute("inlinefloaterchange") == "true") {
            } else {
                introParent.style.display = "none";
                this.currentNodeIndex = 2;
                this.floaterNavigation(0);
            }
        } else {
            introParent.style.removeProperty("display");
            if (moveToStart == true) {
                this.currentNodeIndex = index;
                this.floaterNavigation(0);
            }
        }
    }
};
FlipText.prototype.updateFloaterOnPreviewEnd = function (index) {
    this.updateIntroVisibility(true, index);
};

FlipText.prototype.getCurrentIndex = function () {
    return this.currentNodeIndex - 1;
};

"use strict";

function Typewritter(sgParent, sgData, moodName, metadata, styleName = "", isPlayAnimation = true, textElementData, socialiconsData, fontData, objDataToSG) {
    this.speedForward = isPlayAnimation ? 70 : 0; //Typing Speed
    this.speedBackspace = isPlayAnimation ? 20 : 0; //Backspace Speed
    this.textArray = [];
    this.specialGraphicsUtils = new window["SpecialGraphicsUtils"]();
    for (let a = 1; a < sgData.length; a++) {
        let dummyDiv = document.createElement("div");
        dummyDiv.style.opacity = 0;
        dummyDiv.style.position = "absolute";
        document.body.appendChild(dummyDiv);
        dummyDiv.innerHTML = sgData[a].title;

        let modifiedString = TextHighLightUtils.highlightToString(dummyDiv.innerHTML);
        dummyDiv.innerHTML = modifiedString;
        dummyDiv.innerText = modifiedString;
        TextHighLightUtils.updateHighlight(dummyDiv, modifiedString);

        let newString = this.specialGraphicsUtils.replaceHighlightThings(sgData[a].title);
        newString = dummyDiv.innerText;
        if (newString == "") newString = "Type a special text";
        newString = newString.substring(0, 75);
        this.textArray.push(newString);
        setTimeout(() => {
            document.body.removeChild(dummyDiv);
        }, 0);
    }
    GenericSpecialgraphics.call(this, sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, fontData, objDataToSG);
}

Typewritter.prototype = Object.create(GenericSpecialgraphics.prototype);

var i = 0;
let a = 0;

Typewritter.prototype.initSpecialGraphicsCreation = function () {
    this.specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL);
    this.specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
    GenericSpecialgraphics.prototype.initSpecialGraphicsCreation.call(this, true, false);
    if (!this.oldContent) {
        if (this.isWidget == false || (this.objDataToSG && this.objDataToSG.menuChange)) {
            let svgDiv = this.sgParent.parentElement && this.sgParent.parentElement.parentElement ? this.sgParent.parentElement.parentElement : null;
            let specislgraphicsDiv = svgDiv ? svgDiv.querySelector("[id='AESpecialGraphics']") : null;

            this.hasIntro = specislgraphicsDiv ? true : false;
            this.hasIntro = true;

            let typewritterParent = this.sgParent.querySelector("[id='typewritterParent']");
            if (typewritterParent) this.sgParent.removeChild(typewritterParent);
            typewritterParent = document.createElement("div");
            typewritterParent.id = "typewritterParent";
            typewritterParent.setAttribute("data-type", "TEXT");
            typewritterParent.setAttribute("data-showselector", "false");
            typewritterParent.className = "typewritterParent clsSingleColorParent";
            this.sgParent.appendChild(typewritterParent);

            let props = this.getProps();
            let parentpadding = props.parentpadding ? props.parentpadding : null;
            if (parentpadding) this.specialgraphicsPropertyUtils.updatePadding(parentpadding, typewritterParent);

            this.sgParent.classList.add("genericspecialgraphics");

            this.textParentMain = this.sgParent.querySelector("[id='typewritterNodeParent']");
            if (this.textParentMain) this.textParentMain.parentElement.removeChild(this.textParentMain);

            this.textParentMain = document.createElement("div");
            this.textParentMain.id = "typewritterNodeParent";
            this.textParentMain.className = "typewritterNodeParent moodanimation";
            this.textParentMain.setAttribute("data-type", "TEXT");
            typewritterParent.appendChild(this.textParentMain);

            let typewritterNode = document.createElement("div");
            typewritterNode.id = "typewritterNode";
            typewritterNode.className = "typewritterNode";
            typewritterNode.setAttribute("data-type", "TEXT");
            this.textParentMain.appendChild(typewritterNode);

            let typewritterCursor = document.createElement("h1");
            typewritterCursor.id = "typewritterCursor";
            let font = this.fontData && this.fontData.title ? this.fontData.title : "h4";
            typewritterCursor.className = "cursor " + font;
            typewritterCursor.setAttribute("data-type", "TEXT");
            typewritterNode.appendChild(typewritterCursor);

            typewritterCursor.style.setProperty("--cursorSize", parseFloat(window.getComputedStyle(typewritterCursor).lineHeight) - 20 + "px");
        }
    } else {
        this.clearListener(false);
        for (let c = 0; c < this.sgData.length; c++) {
            let assetParent = this.sgParent.querySelector("[id='assetParent" + c + "']");
            assetParent = c == 0 ? this.sgParent.querySelector("[id='assetParent0']") : assetParent;
            let elements = assetParent ? assetParent.querySelectorAll("[listener='true']") : [];
            for (let a = 0; a < elements.length; a++) {
                this.setTextFocus(elements[a], false, assetParent, true);
            }
        }
    }
    this.setLogoSizes(this.sgParent.querySelector("[id='assetParent0']"), "logo");
    this.specialGraphicsCreationComplete();
    setTimeout(() => {
        let slideId = this.slideContent ? this.slideContent.id : this.sgParent.parentElement.parentElement.parentElement.id;
        if (this.updateThumbnail) this.updateThumbnail(slideId);
    }, 0);
};

Typewritter.prototype.typeWriter = function (id, ar, type = "show", oldIndex = null, ivalue = null) {
    let element = this.sgParent.querySelector("#" + id);
    if (!element) return null;
    let aString = this.textArray[oldIndex ? oldIndex - 2 : this.currentNodeIndex - 2];
    if (aString == "") aString = "Type a special text";
    let eHeader = element.getElementsByTagName("H1")[0]; //Header element
    eHeader.classList.add("typewritterCursor");
    let that = this;

    i = ivalue != null ? ivalue : i;
    let isBackspacing = type != "show";
    // Determine if animation should be typing or backspacing
    if (!isBackspacing) {
        // If full string hasn't yet been typed out, continue typing
        if (i < aString.length) {
            // If character about to be typed is a pipe, switch to second line and continue.
            // Type header or subheader depending on whether pipe has been detected
            if (i == 0) eHeader.innerText = "";
            eHeader.textContent = eHeader.textContent + aString.charAt(i);

            // let modifiedString = TextHighLightUtils.highlightToString(eHeader.innerHTML);
            // eHeader.innerHTML = modifiedString;
            // eHeader.innerText = modifiedString;
            // TextHighLightUtils.updateHighlight(eHeader, modifiedString);

            i++;
            if (this.speedForward == 0) that.typeWriter(id, this.textArray, type);
            else
                setTimeout(function () {
                    that.typeWriter(id, this.textArray, type);
                }, this.speedForward);
            // If full string has been typed, switch to backspace mode.
        } else if (i == aString.length) {
            // alert("complete");
            return true;
        }
    } else if (type == "hide") {
        // If either the header or the paragraph still has text, continue backspacing
        if (eHeader.textContent.length > 0) {
            // If paragraph still has text, continue erasing, otherwise switch to the header.
            eHeader.textContent = eHeader.textContent.substring(0, eHeader.textContent.length - 1);
            if (this.speedBackspace == 0) that.typeWriter(id, this.textArray, type);
            else
                setTimeout(function () {
                    that.typeWriter(id, this.textArray, type);
                }, this.speedBackspace);

            // If neither head or paragraph still has text, switch to next quote in array and start typing.
        } else {
            i = 0;
            a = (a + 1) % this.textArray.length; //Moves to next position in array, always looping back to 0
            return true;
        }
    }
};

Typewritter.prototype.getFlipText = function (textParentMain, i) {
    let titleFontClass = this.fontData && this.fontData.title ? this.fontData.title : "h3";
    var flipText = this.specialGraphicsUtils.createTextElement(textParentMain, "", "flipText" + i, "textFlipingItem " + titleFontClass + " background-color alter-background-bg-color", "title", false);
    flipText.setAttribute("data-prompt-text", "Type a special text");
    flipText.position = i;
    return flipText;
};

Typewritter.prototype.initForPPTX = function (moveToStart = false, index = 0) {
    let assetParents = this.sgParent.querySelectorAll("[id*='assetParent']");
    if (this.sgParent && this.sgParent.parentElement && this.sgParent.parentElement.parentElement && assetParents.length > 0) {
        let animationDIV = this.sgParent.parentElement.parentElement;
        let showIntro = animationDIV.hasAttribute("data-intro") ? animationDIV.getAttribute("data-intro") : "true";
        if (showIntro == "false" && assetParents[0].classList.contains("introSlide")) {
            if (animationDIV.hasAttribute("inlinefloaterchange") && animationDIV.getAttribute("inlinefloaterchange") == "true") {
            } else {
                assetParents[0].style.display = "none";
                this.currentNodeIndex = 2;
                this.floaterNavigation(0, false);
            }
        } else {
            assetParents[0].style.removeProperty("display");
            if (moveToStart == true) {
                this.currentNodeIndex = index;
                this.floaterNavigation(0);
            }
        }
    }
};

Typewritter.prototype.floaterNavigation = function (index, doAnim = true) {
    if (this.sgParent.querySelector("[id='typewritterParent']")) {
        let oldIndex = this.currentNodeIndex;
        this.currentNodeIndex = this.currentNodeIndex + index;
        this.currentNodeIndex = this.currentNodeIndex < 1 ? 1 : this.currentNodeIndex;
        this.currentNodeIndex = this.currentNodeIndex > this.sgData.length ? this.sgData.length : this.currentNodeIndex;
        let introParent = this.sgParent.querySelector("[id='assetParent0']");
        let typewritterNodeParent = this.sgParent.querySelector("[id='typewritterNodeParent']");

        if (introParent) introParent.style.opacity = this.currentNodeIndex - 1 == 0 ? 1 : 0;
        if (introParent) {
            introParent.style.pointerEvents = this.currentNodeIndex - 1 == 0 ? "all" : "none";
            introParent.style.setProperty("--textPointerEvent", this.currentNodeIndex - 1 == 0 ? "auto" : "none");
        }
        if (typewritterNodeParent) {
            typewritterNodeParent.style.opacity = this.currentNodeIndex - 1 == 0 ? 0 : 1;
            typewritterNodeParent.style.pointerEvents = this.currentNodeIndex - 1 == 0 ? "none" : "all";
        }

        for (let i = 1; i < this.sgData.length; i++) {
            let assetParent = this.sgParent.querySelector("[id='assetParent" + i + "']");
            let textFlipSlideNo = assetParent ? assetParent.querySelector("[id*='sgNumberTextParent']") : null;
            let ctaButtonParent = assetParent ? assetParent.querySelector("[id*='ctaButtonParent']") : null;
            let sgCtaButtonNode = ctaButtonParent ? ctaButtonParent.querySelector("[id*='sgCtaButtonNode']") : null;
            if (textFlipSlideNo && i == this.currentNodeIndex - 1) textFlipSlideNo.style.opacity = "1";
            else if (textFlipSlideNo) textFlipSlideNo.style.opacity = "0";
            if (i == this.currentNodeIndex - 1) {
                if (assetParent) assetParent.style.pointerEvents = "auto";
                if (sgCtaButtonNode) {
                    sgCtaButtonNode.style.opacity = "1";
                    sgCtaButtonNode.style.pointerEvents = "auto";
                    sgCtaButtonNode.style.pointerEvents = "auto";
                }
            } else {
                if (sgCtaButtonNode) {
                    sgCtaButtonNode.style.opacity = "0";
                    sgCtaButtonNode.style.pointerEvents = "none";
                    sgCtaButtonNode.style.pointerEvents = "none";
                }
                if (assetParent) assetParent.style.pointerEvents = "none";
            }
        }

        if ((((index == 1 || index == 0) && this.currentNodeIndex - 1 != 1) || index != 1) && doAnim) this.typeWriter("typewritterNode", this.textArray, "hide", oldIndex);
        else this.sgParent.querySelector("[id='typewritterCursor']").innerHTML = "";
        let time = this.isPlayAnimation ? this.speedForward * this.textArray[a].length + 200 : 100;
        if (this.currentNodeIndex - 1 != 0 && doAnim)
            setTimeout(() => {
                this.typeWriter("typewritterNode", this.textArray, "show", this.currentNodeIndex, 0);
            }, time);
        else if (this.currentNodeIndex - 1 != 0 && !doAnim) {
            this.currentNodeIndex = this.currentNodeIndex - 1;
            this.next(null, false);
        }
        this.updatenavFloater();
        if (this.isPlayAnimation == false) this.eventManager.dispatch("positionchangecallback", this.currentNodeIndex - 1);
    }
};

Typewritter.prototype.gotoAndStopFirstNode = function (completeCallback, type, slideContent) {
    if (slideContent) this.sgParent = slideContent.querySelector("[id='specialgraphicsParent']");
    let typewritterParent = this.sgParent.querySelector("[id='typewritterParent']");
    this.textParentMain = typewritterParent.querySelector("[id='typewritterNodeParent']");

    let hasEmptyIntro = this.checkIntroAnimation();
    this.currentNodeIndex = hasEmptyIntro == true ? 2 : 1;
    this.floaterNavigation(0, false);
    this.eventManager.dispatch("positionchangecallback", this.currentNodeIndex - 1);
    if (!hasEmptyIntro) {
        this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1);
    } else {
        this.currentNodeIndex = this.currentNodeIndex - 1;
        this.next(completeCallback, false);
    }
};

Typewritter.prototype.initPresentSG = function (slideContent) {
    let typewritterNodeParent = slideContent.querySelector("[id='typewritterNodeParent']");
    if (typewritterNodeParent) typewritterNodeParent.style.opacity = 0;

    for (let i = 0; i < this.sgData.length; i++) {
        let assetParent = slideContent.querySelector("[id='assetParent" + i + "']");
        let textFlipSlideNo = assetParent ? assetParent.querySelector("[id*='sgNumberTextParent']") : null;
        let ctaButtonParent = assetParent ? assetParent.querySelector("[id*='sgCtaButtonNode']") : null;
        if (textFlipSlideNo) textFlipSlideNo.style.opacity = "0";
        // if (ctaButtonParent) ctaButtonParent.style.opacity = "0";
    }

    let hasEmptyIntro = this.checkIntroAnimation();
    if (hasEmptyIntro) return false;
    else return true;
};

Typewritter.prototype.hideAnimation = function (completeCallback) {
    this.sgParent.style.transition = "opacity 0.8s ease";
    this.sgParent.style.opacity = 0;
    setTimeout(() => {
        completeCallback ? completeCallback() : "";
    }, 800);
};

Typewritter.prototype.next = function (completeCallback, doHide = true) {
    this.sgParent.setAttribute("dotransition", "false");
    this.currentType = "next";
    let oldIndex = this.currentNodeIndex;
    this.currentNodeIndex = this.currentNodeIndex + 1;

    let introParent = this.sgParent.querySelector("[id='assetParent0']");
    introParent.style.transition = this.isPlayAnimation ? "opacity 1s ease" : "opacity 0s";
    introParent.style.opacity = 0;
    if (!this.textParentMain) this.textParentMain = this.sgParent.querySelector("[id='typewritterNodeParent']");
    this.textParentMain.style.opacity = 1;

    this.doNumberAnimation(oldIndex - 1, "out");

    this.speedForward = this.isPlayAnimation ? 70 : 0; //Typing Speed
    this.speedBackspace = this.isPlayAnimation ? 20 : 0; //Backspace Speed

    let lengthOfText = this.textArray[oldIndex - 2] ? this.textArray[oldIndex - 2].length : 0;
    let time = this.isPlayAnimation && this.currentNodeIndex - 1 != 1 ? this.speedBackspace * lengthOfText : this.currentNodeIndex - 1 == 1 && this.isPlayAnimation ? 500 : 0;
    if (time > 800) {
        this.speedBackspace = 800 / lengthOfText;
        time = this.isPlayAnimation && this.currentNodeIndex - 1 != 1 ? this.speedBackspace * lengthOfText : this.currentNodeIndex - 1 == 1 && this.isPlayAnimation ? 500 : 0;
    }
    if (this.currentNodeIndex - 1 != 1 && doHide) this.typeWriter("typewritterNode", this.textArray, "hide", oldIndex);
    else this.sgParent.querySelector("[id='typewritterCursor']").innerHTML = "";

    if (!this.isPlayAnimation) {
        let lengthOfShowText = this.textArray[this.currentNodeIndex - 2]?.length || 0;
        let showTime = this.isPlayAnimation || this.currentNodeIndex - 1 != 1 ? this.speedForward * lengthOfShowText : 0;
        if (showTime > 3000) {
            this.speedForward = 3000 / lengthOfShowText;
            showTime = this.isPlayAnimation || this.currentNodeIndex - 1 != 1 ? this.speedForward * lengthOfShowText : 0;
        }
        this.typeWriter("typewritterNode", this.textArray, "show", this.currentNodeIndex, 0);
        this.doNumberAnimation(this.currentNodeIndex - 1, "in");
        setTimeout(() => {
            completeCallback ? completeCallback() : "";
        }, showTime);
    } else {
        // console.log("SG - next - hide time - " + time);
        setTimeout(() => {
            let lengthOfShowText = this.textArray[this.currentNodeIndex - 2]?.length || 0;
            let showTime = this.isPlayAnimation || this.currentNodeIndex - 1 != 1 ? this.speedForward * lengthOfShowText : 0;
            if (showTime > 3000) {
                this.speedForward = 3000 / lengthOfShowText;
                showTime = this.isPlayAnimation || this.currentNodeIndex - 1 != 1 ? this.speedForward * lengthOfShowText : 0;
            }
            this.typeWriter("typewritterNode", this.textArray, "show", this.currentNodeIndex, 0);
            this.doNumberAnimation(this.currentNodeIndex - 1, "in");
            // console.log("SG - next - show time - " + showTime);
            setTimeout(() => {
                completeCallback ? completeCallback() : "";
            }, showTime);
        }, time + 200);
    }
};

Typewritter.prototype.previous = function (completeCallback) {
    this.currentType = "previous";
    let oldIndex = this.currentNodeIndex;

    this.currentNodeIndex = this.currentNodeIndex - 1;
    if (this.currentNodeIndex < 1 || this.currentNodeIndex > this.sgData.length) return;
    this.doNumberAnimation(oldIndex - 1, "out");
    this.speedForward = this.isPlayAnimation ? 70 : 0; //Typing Speed
    this.speedBackspace = this.isPlayAnimation ? 20 : 0; //Backspace Speed

    let hasEmptyIntro = this.checkIntroAnimation();
    if (hasEmptyIntro == true && this.currentNodeIndex <= 1) return false;

    if (this.currentNodeIndex - 1 == 0) {
        let introParent = this.sgParent.querySelector("[id='assetParent0']");
        introParent.style.transition = "opacity 1s ease";
        introParent.style.opacity = 1;
        this.textParentMain.style.opacity = 0;
        completeCallback ? completeCallback() : "";
    } else {
        let lengthOfText = this.textArray[oldIndex - 2] ? this.textArray[oldIndex - 2].length : 0;
        let time = this.isPlayAnimation ? this.speedBackspace * lengthOfText : 0;
        if (time > 800) {
            this.speedBackspace = 800 / lengthOfText;
            time = this.isPlayAnimation ? this.speedBackspace * lengthOfText : 0;
        }
        this.typeWriter("typewritterNode", this.textArray, "hide", oldIndex);
        setTimeout(() => {
            let showTime = 0;
            if (this.currentNodeIndex - 1 != 0) {
                let lengthOfShowText = this.textArray[this.currentNodeIndex - 2].length;
                showTime = this.isPlayAnimation || this.currentNodeIndex - 1 != 1 ? this.speedForward * lengthOfShowText : 0;
                if (showTime > 3000) {
                    this.speedForward = 3000 / lengthOfShowText;
                    showTime = this.isPlayAnimation || this.currentNodeIndex - 1 != 1 ? this.speedForward * lengthOfShowText : 0;
                }
                this.typeWriter("typewritterNode", this.textArray, "show", this.currentNodeIndex, 0);
                this.doNumberAnimation(this.currentNodeIndex - 1, "in");
            }
            setTimeout(() => {
                completeCallback ? completeCallback() : "";
            }, showTime);
        }, time + 200);
    }
};

//Animation Complete Listener
Typewritter.prototype.animationCompleteListener = function (event) {
    var addingValue = this.currentType == "next" ? 2 : this.currentType == "previous" ? 0 : 0;
    var flipText1 = this.sgParent.querySelector("[id='clsFlipDiv" + (this.currentNodeIndex - addingValue - 1) + "']");
    var flipText2 = this.sgParent.querySelector("[id='clsFlipDiv" + (this.currentNodeIndex - 1 - 1) + "']");
    if (flipText1) {
        flipText1.style.opacity = 0;
        flipText1.parentElement.style.animation = null;
    }
    if (flipText2) flipText2.parentElement.style.animation = null;

    var callBack = event.target.callback;
    callBack ? callBack() : "";
    event.target.removeEventListener("animationend", this.animationCompleteListener);
    event.target.callback = null;
};

Typewritter.prototype.doNumberAnimation = function (index, type = "in") {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + index + "']");
    let slideNo = assetParent ? assetParent.querySelector("[id*='sgNumberTextParent']") : null;
    let ctaButtonParent = assetParent ? assetParent.querySelector("[id*='sgCtaButtonNode']") : null;
    if (slideNo) {
        let toOpacity = type == "in" ? 1 : 0;
        slideNo.style.transition = "opacity 1s ease";
        slideNo.style.opacity = toOpacity;
    }
    if (ctaButtonParent) {
        let toOpacity = type == "in" ? 1 : 0;
        ctaButtonParent.style.transition = "opacity 1s 0.1s ease";
        ctaButtonParent.style.opacity = toOpacity;
    }
};

Typewritter.prototype.changeVariation = function (slideDomContentGroup) {
    this.updateIntroVisibility();
    let nodeData = slideDomContentGroup.getElementsByTagName("numbertext")[0];
    for (let i = 0; i < this.sgData.length; i++) {
        let assetParent = this.sgParent.querySelector("[id='assetParent" + i + "']");
        let id = "sgNumberTextParent";
        if (assetParent && !!assetParent.querySelector("[id='" + id + "']") && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
            assetParent.querySelector("[id='" + id + "']").style.display = "none";
        } else if (assetParent && !!assetParent.querySelector("[id='" + id + "']")) {
            var display = assetParent.querySelector("[id='" + id + "']").hasAttribute("display") ? assetParent.querySelector("[id='" + id + "']").getAttribute("display") : "";
            assetParent.querySelector("[id='" + id + "']").style.display = display;
        }
    }
    let titleNode = this.sgParent.querySelector("[id='sgTitleNode']");
    let sgTitleLabelNode = this.sgParent.querySelector("[id='sgTitleLabelNode']");
    let subTitleNode = this.sgParent.querySelector("[id='sgSubTitleNode']");

    let oldDisplay = subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "";

    nodeData = slideDomContentGroup.getElementsByTagName("title")[0];
    if (titleNode && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        titleNode.style.display = "none";
        titleNode.parentElement.style.display = "none";
    } else if (titleNode) {
        var display = titleNode.hasAttribute("display") ? titleNode.getAttribute("display") : "";
        titleNode.style.display = display;
        titleNode.parentElement.style.display = display;
    }

    nodeData = slideDomContentGroup.getElementsByTagName("subtitle")[0];
    if (subTitleNode && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        subTitleNode.style.display = "none";
        subTitleNode.parentElement.style.display = "none";
    } else if (subTitleNode) {
        var display = subTitleNode.hasAttribute("display") ? subTitleNode.getAttribute("display") : "";
        subTitleNode.style.display = display;
        subTitleNode.parentElement.style.display = display;
    }

    nodeData = slideDomContentGroup.getElementsByTagName("titlelabel")[0];
    if (sgTitleLabelNode && nodeData && !!nodeData.hasAttribute("data-hide") && nodeData.getAttribute("data-hide") == "true") {
        sgTitleLabelNode.style.display = "none";
        sgTitleLabelNode.parentElement.style.display = "none";
    } else if (sgTitleLabelNode) {
        var display = sgTitleLabelNode.hasAttribute("display") ? sgTitleLabelNode.getAttribute("display") : "";
        sgTitleLabelNode.style.display = display;
        sgTitleLabelNode.parentElement.style.display = display;
    }

    let newDisplay = subTitleNode ? window.getComputedStyle(subTitleNode)["display"] : "";
    if (titleNode && subTitleNode && newDisplay != oldDisplay && this.fontData.title.length <= 2) {
        let isSubtitleEnabled = window.getComputedStyle(subTitleNode)["display"] == "none" ? false : true;
        let isIntro = true;
        titleNode.classList.remove(this.fontData[(isIntro ? "intro" : "") + "title"]);
        titleNode.classList.remove(this.fontData[(isIntro ? "intro" : "") + "titleNoSubtitle"]);

        this.specialGraphicsUtils.removeAllFontClass(titleNode);

        let fontClass = isSubtitleEnabled == false ? this.fontData[(isIntro ? "intro" : "") + "titleNoSubtitle"] : this.fontData[(isIntro ? "intro" : "") + "title"];
        if (!fontClass) fontClass = isSubtitleEnabled == false ? this.fontData["titleNoSubtitle"] : this.fontData["title"];
        titleNode.classList.add(fontClass);
        titleNode.setAttribute("data-font", fontClass);
        titleNode.style.removeProperty("min-height");
        titleNode.style.removeProperty("max-height");
        titleNode.style.removeProperty("font-size");

        titleNode.setAttribute("defaultsize", parseFloat(window.getComputedStyle(titleNode)["font-size"]));
        if (this.fontSizeChangeOnTextChange) this.fontSizeChangeOnTextChange(titleNode);
        if (titleNode.hasAttribute("user-font-size")) {
            this.specialGraphicsUtils.removeAllFontClass(titleNode);
            titleNode.classList.add(titleNode.getAttribute("user-font-size"));
        }
        this.specialGraphicsUtils.doCheckMaxHeight(titleNode, this.sgParent);
        this.specialGraphicsUtils.doFontFitForCss(titleNode, this.sgParent);
    }
    this.onTextChangeForAllNodes();
    let textInnerParentNode = this.sgParent.querySelector("[id='textInnerParentNode']");
    this.textElementPositioning(this.sgParent, textInnerParentNode, 0);
    this.updatenavFloater();
};

"use strict";

function TextFall(sgParent, sgData, moodName, metadata, styleName = "", isPlayAnimation = true, textElementData, socialiconsData, fontData, objDataToSG) {
    if (sgData.length > 3) sgData = sgData.slice(0, 4);
    this.strAssetType = "textfall";
    GenericSpecialgraphics.call(this, sgParent, sgData, moodName, metadata, styleName, isPlayAnimation, textElementData, socialiconsData, fontData, objDataToSG);
}

TextFall.prototype = Object.create(GenericSpecialgraphics.prototype);

TextFall.prototype.initSpecialGraphicsCreation = function () {
    this.specialgraphicsPropertyUtils = new window["SpecialgraphicsPropertyUtils"](this.appStaticURL);
    this.specialgraphicsPropertyUtils.assignBaseProps({ slideWidth: this.slideWidth, slideHeight: this.slideHeight });
    GenericSpecialgraphics.prototype.initSpecialGraphicsCreation.call(this, true, false);
    if (!this.oldContent) {
        if (this.isWidget == false || (this.objDataToSG && this.objDataToSG.menuChange)) {
            let textFallparent = this.sgParent.querySelector("[id='textFallparent']");
            if (textFallparent) this.sgParent.removeChild(textFallparent);
            textFallparent = document.createElement("div");
            textFallparent.id = "textFallparent";
            textFallparent.setAttribute("data-type", "TEXT");
            textFallparent.setAttribute("data-showselector", "false");
            textFallparent.className = "textFallparent clsSingleColorParent";
            this.sgParent.appendChild(textFallparent);

            let textFallTextParent = document.createElement("div");
            textFallTextParent.id = "textFallTextParent";
            textFallTextParent.setAttribute("data-type", "TEXT");
            textFallTextParent.setAttribute("data-showselector", "false");
            textFallTextParent.className = "textFallTextParent";
            textFallparent.appendChild(textFallTextParent);

            let textFallImageParent = document.createElement("div");
            textFallImageParent.id = "textFallImageParent";
            textFallImageParent.setAttribute("data-type", "TEXT");
            textFallImageParent.setAttribute("data-showselector", "false");
            textFallImageParent.className = "textFallImageParent";
            textFallparent.appendChild(textFallImageParent);

            let props = this.getProps();
            if (props?.text?.parentposition) textFallTextParent.style.position = this.specialgraphicsPropertyUtils.updatePosition(textFallTextParent, props.text.parentposition);
            if (props?.imageparentposition) textFallImageParent.style.position = this.specialgraphicsPropertyUtils.updatePosition(textFallImageParent, props.imageparentposition);
            if (props?.nodeparenthalign) textFallparent.style.justifyContent = props.nodeparenthalign == "right" || props.nodeparenthalign == "end" ? "flex-end" : props.nodeparenthalign == "center" || props.nodeparenthalign == "middle" ? "center" : "flex-start";

            for (let a = 1; a < this.sgData.length; a++) {
                let assetParent = this.sgParent.querySelector("[id='assetParent" + a + "']");
                let textFallNode = document.createElement("div");
                textFallNode.id = "textFallNode" + a;
                textFallNode.setAttribute("data-type", "TEXT");
                textFallNode.setAttribute("data-showselector", "false");
                textFallNode.className = "textFallNode";
                textFallNode.style.top = (a - 1) * 33.33 + "%";
                textFallTextParent.appendChild(textFallNode);

                if (assetParent) {
                    let textInnerParentNode = this.createTextBase(textFallNode, 0);
                    this.createTitleSet(textInnerParentNode, a, textFallNode);

                    textInnerParentNode.parentElement.parentElement.style.maxHeight = "100%";
                    let titleNode = textInnerParentNode.querySelector("[id='sgTitleNode']");
                    let sgSubTitleNode = textInnerParentNode.querySelector("[id='sgSubTitleNode']");
                    titleNode.style.setProperty("padding", "unset", "important");
                    if (titleNode) titleNode.setAttribute("fontresize", "false");
                    if (sgSubTitleNode) sgSubTitleNode.setAttribute("fontresize", "false");

                    if (props && props.text) {
                        if (!props.text.padding && !props.text.margin) props.text.padding = "20,20,20,20";
                        this.specialgraphicsPropertyUtils.updatePadding(props.text.padding, textFallNode);
                        if (props.text.margin) this.specialgraphicsPropertyUtils.updateMargin(props.text.margin, textFallNode);
                        if (props.text.valign) {
                            let vAlign = props.text.valign == "bottom" || props.text.valign == "end" ? "flex-end" : props.text.valign == "center" || props.text.valign == "middle" ? "center" : "flex-start";
                            textFallNode.style.alignItems = vAlign;
                        }
                        if (props.text.halign) {
                            let hAlign = props.text.halign == "right" || props.text.halign == "end" ? "flex-end" : props.text.halign == "center" || props.text.halign == "middle" ? "center" : "flex-start";
                            textFallNode.style.justifyContent = hAlign;
                            textFallNode.style.setProperty("--textAlign", hAlign == "flex-end" ? "end" : hAlign == "center" ? "center" : "start");
                            textFallNode.style.setProperty("--textJustifyContent", hAlign);
                        }
                    }
                }

                let textFallImage = document.createElement("img");
                textFallImage.id = "textFallImage" + a;
                textFallImage.setAttribute("data-type", "TEXT");
                textFallImage.setAttribute("data-showselector", "false");
                textFallImage.setAttribute("data-fit", "false");
                textFallImage.className = "textFallImage";
                textFallImage.style.top = (a - 1) * 33.33 + "%";
                textFallImage.src = this.appStaticURL + "imagestack/images/textfall" + a + ".png";
                textFallImageParent.appendChild(textFallImage);
            }
        }
    } else {
        this.clearListener(false);
        for (let c = 0; c < this.sgData.length; c++) {
            let assetParent = this.sgParent.querySelector("[id='textFallNode" + c + "']");
            assetParent = c == 0 ? this.sgParent.querySelector("[id='assetParent0']") : assetParent;
            let elements = assetParent ? assetParent.querySelectorAll("[listener='true']") : [];
            for (let a = 0; a < elements.length; a++) {
                this.setTextFocus(elements[a], false, assetParent, true);
            }
        }
    }
    this.setLogoSizes(this.sgParent.querySelector("[id='assetParent0']"), "logo");
    this.specialGraphicsCreationComplete();
};

TextFall.prototype.floaterNavigation = function (index, doAnim = false) {
    if (this.sgParent.querySelector("[id='textFallparent']")) {
        this.currentNodeIndex = this.currentNodeIndex + index;
        this.currentNodeIndex = this.currentNodeIndex < 1 ? 1 : this.currentNodeIndex;
        this.currentNodeIndex = this.currentNodeIndex > this.sgData.length ? this.sgData.length : this.currentNodeIndex;
        let introParent = this.sgParent.querySelector("[id='assetParent0']");
        let typewritterNodeParent = this.sgParent.querySelector("[id='typewritterNodeParent']");
        let textFallImageParent = this.sgParent.querySelector("[id='textFallImageParent']");

        if (introParent) introParent.style.opacity = this.currentNodeIndex - 1 == 0 ? 1 : 0;
        if (textFallImageParent) textFallImageParent.style.opacity = this.currentNodeIndex - 1 != 0 ? 1 : 0;

        if (introParent) {
            introParent.style.pointerEvents = this.currentNodeIndex - 1 == 0 ? "all" : "none";
            introParent.style.setProperty("--textPointerEvent", this.currentNodeIndex - 1 == 0 ? "auto" : "none");
        }
        if (typewritterNodeParent) {
            typewritterNodeParent.style.opacity = this.currentNodeIndex - 1 == 0 ? 0 : 1;
            typewritterNodeParent.style.pointerEvents = this.currentNodeIndex - 1 == 0 ? "none" : "all";
        }

        for (let i = 0; i < this.sgData.length; i++) {
            let assetParent = this.sgParent.querySelector("[id='assetParent" + i + "']");
            assetParent.style.pointerEvents = i == this.currentNodeIndex - 1 ? "all" : "none";
            let textFlipSlideNo = assetParent ? assetParent.querySelector("[id*='sgNumberTextParent']") : null;
            if (textFlipSlideNo) textFlipSlideNo.style.animation = "none";
            if (doAnim && textFlipSlideNo && this.isPlayAnimation) textFlipSlideNo.style.transition = "opacity 1s ease-in";
            if (textFlipSlideNo && i == this.currentNodeIndex - 1) textFlipSlideNo.style.opacity = 1;
            else if (textFlipSlideNo) textFlipSlideNo.style.opacity = 0;

            let textFallNode = this.sgParent.querySelector("[id='textFallNode" + i + "']");
            let textFallImage = this.sgParent.querySelector("[id='textFallImage" + i + "']");
            if (doAnim && textFallImage && this.isPlayAnimation) textFallImage.style.transition = "opacity 1s ease-in";
            if (textFallNode) {
                if (doAnim && this.isPlayAnimation) textFallNode.style.transition = "opacity 1s ease-in";
                textFallNode.style.setProperty("--textPointerEvent", i == this.currentNodeIndex - 1 ? "auto" : "none");
                textFallNode.style.pointerEvents = i == this.currentNodeIndex - 1 ? "auto" : "none";
                textFallNode.style.opacity = i < this.currentNodeIndex ? 1 : 0;
            }
            if (textFallImage) textFallImage.style.opacity = i < this.currentNodeIndex ? 1 : 0;
        }
        this.updatenavFloater();
        if (this.isPlayAnimation == false) this.eventManager.dispatch("positionchangecallback", this.currentNodeIndex - 1);
    }
};

TextFall.prototype.gotoAndStopFirstNode = function (completeCallback, type, slideContent) {
    let hasEmptyIntro = this.checkIntroAnimation();
    this.currentNodeIndex = hasEmptyIntro == true ? 2 : 1;
    this.floaterNavigation(0, false);
    this.eventManager.dispatch("positionchangecallback", this.currentNodeIndex - 1);
    let textFallparent = this.sgParent.querySelector("[id='textFallparent']");
    if (!hasEmptyIntro) {
        textFallparent.style.opacity = 0;
        this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", completeCallback, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1);
    } else {
        this.currentNodeIndex = this.currentNodeIndex - 1;
        this.specialGraphicsAnimationUtils.doSpecialgraphicsAnimationIS(this.sgParent, "show", null, this.isPlayAnimation, this.eventManager, this.currentNodeIndex - 1);
        this.next(completeCallback, false);
    }
};

TextFall.prototype.initPresentSG = function (slideContent) {
    let textFallparent = slideContent.querySelector("[id='textFallparent']");
    if (textFallparent) textFallparent.style.opacity = 0;
    // let hasEmptyIntro = this.checkIntroAnimation();
    // if (hasEmptyIntro) return false;
    // else return true;
};

TextFall.prototype.hideAnimation = function (completeCallback) {
    if (this.isPlayAnimation) this.sgParent.style.transition = "opacity 0.8s ease";
    this.sgParent.style.opacity = 0;
    setTimeout(() => {
        completeCallback ? completeCallback() : "";
    }, 800);
};

TextFall.prototype.next = function (completeCallback, doHide = true) {
    this.sgParent.setAttribute("dotransition", "false");
    this.currentType = "next";
    this.currentNodeIndex = this.currentNodeIndex + 1;

    let textFallparent = this.sgParent.querySelector("[id='textFallparent']");
    let arrNodes = textFallparent.querySelectorAll("[class*='moodanimation']");
    for (let a = 0; a < arrNodes.length; a++) {
        arrNodes[a].classList.remove("moodanimation");
    }
    let introParent = this.sgParent.querySelector("[id='assetParent0']");
    if (this.isPlayAnimation) {
        introParent.style.transition = "opacity 0.8s ease";
        textFallparent.style.transition = "opacity 1s 0.25s ease";
    }
    introParent.style.opacity = 0;
    textFallparent.style.opacity = 1;

    this.floaterNavigation(0, true);
    let animDuration = this.isPlayAnimation ? 1000 : 0;
    setTimeout(() => {
        completeCallback ? completeCallback() : "";
    }, animDuration);
};

TextFall.prototype.previous = function (completeCallback) {
    this.currentType = "previous";
    let oldIndex = this.currentNodeIndex;
    let textFallparent = this.sgParent.querySelector("[id='textFallparent']");

    this.currentNodeIndex = this.currentNodeIndex - 1;
    if (this.currentNodeIndex < 1 || this.currentNodeIndex > this.sgData.length) return;
    this.floaterNavigation(0, true);
    if (this.currentNodeIndex - 1 == 0) {
        let introParent = this.sgParent.querySelector("[id='assetParent0']");
        if (this.isPlayAnimation) {
            introParent.style.transition = "opacity 1s 0.25s ease";
            textFallparent.style.transition = "opacity 0.8s ease";
        }
        introParent.style.opacity = 1;
        textFallparent.style.opacity = 0;
        completeCallback ? completeCallback() : "";
    } else {
        let animDuration = this.isPlayAnimation ? 1000 : 0;
        setTimeout(() => {
            completeCallback ? completeCallback() : "";
        }, animDuration);
    }
};

TextFall.prototype.getTargetElement = function (elementID) {
    let assetParent = this.sgParent.querySelector("[id='assetParent" + (this.currentNodeIndex - 1) + "']");
    if (this.currentNodeIndex - 1 != 0) assetParent = this.sgParent.querySelector("[id='textFallNode" + (this.currentNodeIndex - 1) + "']");
    if (assetParent && assetParent.querySelector("[id='" + elementID + "']")) return assetParent.querySelector("[id='" + elementID + "']");
};
