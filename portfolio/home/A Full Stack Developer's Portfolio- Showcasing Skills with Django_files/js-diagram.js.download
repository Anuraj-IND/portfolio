/**
 * Author:    Bala Krishnan K.
 * Created:   22.4.2021
 **/
//Latest gulp check 2
"use strict";

function MultiTextComponent(nodeParent, multitextdata, index = 0, eventManager, nodeObj, fontSizeData = {}, manifestUpdater, appStaticURL) {
    this.nodeParent = nodeParent;
    this.quillParent = null;
    this.index = index;
    this.multitextdata = multitextdata;
    this.fontSizeData = fontSizeData;
    this.type = nodeObj.type;
    this.nodeObj = nodeObj;
    if (multitextdata && multitextdata.length > 0 && multitextdata[0].value && multitextdata[0].value != "") this.sampleData = multitextdata[0].value;
    else this.sampleData = "Make your presentations stand out, by letting Presentations.AI do the design work for you - in seconds.";
    this.manifestUpdater = manifestUpdater;
    this.appStaticURL = appStaticURL;
    this.enableQuillFloater = nodeObj.floater && nodeObj.floater == "quill";
    this.objStyleData = {};
    this.eventManager = eventManager;
    this.textHighlightMouseUpEvent = this.textHighlightMouseUpEvent.bind(this);
}

MultiTextComponent.prototype.initCreation = function () {
    this.nodeParent.innerHTML = "";
    let quillParent = document.createElement("div");
    quillParent.className = "quillParent";
    quillParent.id = "quillParent" + DiagramNodeUtils.uuidv4();
    quillParent.setAttribute("data-dck-selector", "true");
    this.nodeParent.appendChild(quillParent);
    this.recreateQuillInstance(this.multitextdata);
    return quillParent;
};

MultiTextComponent.prototype.recreateQuillInstance = function (data, isRecreate = false) {
    let quillParent = this.nodeParent.querySelector("[id*='quillParent']");
    quillParent.id = "quillParent" + DiagramNodeUtils.uuidv4();
    if (isRecreate) this.updateJSONData();
    let arrQlUi = quillParent.querySelectorAll(".ql-ui");
    arrQlUi.forEach((element) => {
        element.innerHTML = "";
    });
    try {
        this.createQuillInstance(quillParent, data, isRecreate);
    } catch (error) {
        console.log(error);
    }
    this.updateStyleProps();
    this.updateEvents();
    // setTimeout(() => {
    //     this.quill.blur();
    // }, 0);
    if (!this.isFocusOutRestrict) {
        setTimeout(() => {
            this.onFocusOut();
        }, 10);
    }
};

MultiTextComponent.prototype.createQuillInstance = function (quillParent, data = null, isRecreate = false) {
    var toolbarOptions = [];
    let arrHeader = [false, "h1", "h2", "h3", "h4", "h5", "h6"];
    arrHeader = this.checkFloaterOption("quillheading-1", arrHeader, toolbarOptions, true);
    arrHeader = this.checkFloaterOption("quillheading-2", arrHeader, toolbarOptions, true);
    let arrHeading = [{ header: arrHeader }];
    this.checkFloaterOption("quillheading", arrHeading, toolbarOptions);

    let arrType = [];
    if (this.type == "bullet") {
        arrType.push({ list: "bullet" });
        arrType.push({ list: "ordered" });
    }
    if (this.type == "ordered") {
        arrType.push({ list: "ordered" });
        arrType.push({ list: "bullet" });
    }
    this.checkFloaterOption("quilltype", arrType, toolbarOptions);

    let arrStyle = ["bold", "italic"];
    arrStyle = this.checkFloaterOption("quillformat-bold", arrStyle, toolbarOptions, true);
    arrStyle = this.checkFloaterOption("quillformat-italic", arrStyle, toolbarOptions, true);
    this.checkFloaterOption("quillformat", arrStyle, toolbarOptions);

    let arrIndent = [{ indent: "-1" }, { indent: "+1" }];
    this.checkFloaterOption("quillindent", arrIndent, toolbarOptions);

    let textProps = null;
    if (isRecreate) {
        textProps = { ...DiagramCreateUtil.getTextProps(quillParent.querySelector("#ql-editor0")) };
    }
    this.quill = new Quill("#" + quillParent.id, {
        // formats: ["bold", "strike", "underline", "color", "background"],
        modules: {
            // toolbar: this.enableQuillFloater ? toolbarOptions : null,
            toolbar: null,
            // "emoji-textarea": true,
            // "emoji-shortname": true,
            clipboard: {
                matchVisual: false,
            },
        },
        placeholder: "Enter Text...",
        // theme: "bubble", // or 'snow'
        // theme: 'snow'
    });
    this.quill.clipboard.addMatcher(Node.ELEMENT_NODE, (node, delta) => {
        let ops = [];
        delta.ops.forEach((op) => {
            if (op.insert && typeof op.insert === "string") {
                let newAttributes = {};
                if (op.attributes != null)
                    Object.keys(op.attributes).forEach((key) => {
                        if (key.includes("header") || key.includes("list") || key.includes("indent")) newAttributes[key] = op.attributes[key];
                    });
                ops.push({
                    insert: op.insert,
                    attributes: newAttributes,
                });
            }
        });
        delta.ops = ops;
        return delta;
    });
    if (this.nodeObj.customicon) this.quill.root.setAttribute("data-customicon", "true");
    this.quill.root.classList.add(Constants.Value.quillDefaultFont);
    this.quill.root.classList.add(Constants.Value.quillDefaultFontColor);
    // DiagramUtils.setColorClass(this.quill.root, this.nodeObj, this.globalMoodData, Constants.Value.secondaryTextColor);
    this.quill.root.classList.add("moodanimation");
    this.quill.root.setAttribute("id", "ql-editor" + this.index);
    this.quill.root.setAttribute("type", "quilltext");
    this.quill.root.setAttribute("data-type", "quilltext");
    // this.quill.root.setAttribute("data-default-event", "true");
    this.quill.root.setAttribute("data-index", this.index);
    this.quill.root.setAttribute("data-format", "none");
    this.quill.root.setAttribute("data-animation", "primarytext");
    // this.quill.root.parentElement.classList.remove("")
    if (data) {
        let arrData = this.setContents(data);
        this.quill.setContents(arrData);
    }
    if (this.multitextdata && this.multitextdata[0] && this.multitextdata[0].quilldelta) DiagramUtils.setTextProps(this.multitextdata[0].quilldelta, this.quill.root);
    else if (textProps) {
        DiagramUtils.setTextProps(textProps, this.quill.root);
        if (textProps.textproperties?.textsize) this.setFontSizeToLi(this.quill.root, textProps.textproperties.textsize);
    }
    setTimeout(() => {
        this.quill?.blur?.();
    }, 0);

    if (window.isFromListType) {
        if (this.type == "bullet") {
            let bulletLi = this.quill.root.querySelectorAll("[data-list='ordered'],[data-list='unchecked'],[data-list='checked']");
            bulletLi.forEach((element) => {
                element.setAttribute("data-list", "bullet");
            });
            if (bulletLi && bulletLi.length > 0) this.quill.format("list", "bullet");
        } else if (this.type == "ordered") {
            let bulletLi = this.quill.root.querySelectorAll("[data-list='bullet'],[data-list='unchecked'],[data-list='checked']");
            bulletLi.forEach((element) => {
                element.setAttribute("data-list", "ordered");
            });
            if (bulletLi && bulletLi.length > 0) this.quill.format("list", "ordered");
        } else if (this.type == "checked") {
            let bulletLi = this.quill.root.querySelectorAll("[data-list='bullet'],[data-list='ordered']");
            bulletLi.forEach((element) => {
                element.setAttribute("data-list", "unchecked");
            });
            if (bulletLi && bulletLi.length > 0) this.quill.format("list", "unchecked");
        } else {
            this.quill.format("list", false);
            let bulletLi = this.quill.root.querySelectorAll("[data-list='bullet'],[data-list='ordered'],[data-list='unchecked'],[data-list='checked']");
            bulletLi.forEach((element) => {
                element.setAttribute("data-list", "plain");
            });
            if (bulletLi && bulletLi.length > 0) this.quill.format("list", "plain");
        }
        window.isFromListType = false;
    }
    let arrPTags = this.quill.root.querySelectorAll("P");
    arrPTags.forEach((element) => {
        if (element.textContent.trim() == "") element.remove();
    });
};

MultiTextComponent.prototype.setFontSizeToLi = function (targetNode, fontSize, isReset = false) {
    if (isReset) targetNode.style.removeProperty("font-size");
    else targetNode.style.fontSize = fontSize;
    Array.from(targetNode?.children)?.forEach((element) => {
        if (element.tagName == "UL" || element.tagName == "OL") {
            Array.from(element?.children)?.forEach((liElement) => {
                if (isReset) liElement.style.removeProperty("font-size");
                else liElement.style.fontSize = "unset";
            });
        }
        //  else {
        //     if (isReset) element.style.removeProperty("font-size");
        //     else element.style.fontSize = "unset";
        // }
    });
};
MultiTextComponent.prototype.checkFloaterOption = function (value, arrHeading, toolbarOptions, isOption) {
    let floateroptionsdisable = this.properties && this.properties.floateroptionsdisable;
    if (floateroptionsdisable) {
        if (floateroptionsdisable.includes(value)) {
            if (isOption) {
                let arrOption = value.split("-");
                if (arrOption && arrOption[1]) {
                    let option = arrOption[1];
                    if (!isNaN(option)) option = parseInt(option);
                    const index = arrHeading.indexOf(option);
                    if (index > -1) {
                        arrHeading.splice(index, 1);
                    }
                }
            } else arrHeading = [];
        }
    }
    if (isOption) {
        return arrHeading;
    } else if (arrHeading && arrHeading.length > 0) {
        toolbarOptions.push(arrHeading);
    }
};

MultiTextComponent.prototype.updateJSONData = function () {
    this.multitextdata = this.getJSONData();
    this.quilldelta = this.quill?.getContents();
    this.quilldelta?.ops?.forEach((element) => {
        if (element?.insert) element.insert = this.trimValue(element.insert);
    });
    if (this.quilldelta) this.quilldelta.textproperties = DiagramCreateUtil.getTextProps(this.quill?.root?.querySelector("#ql-editor0"));
    this.setQuillSingleLine();
};

MultiTextComponent.prototype.performOperation = function (valueObj) {
    switch (valueObj.property) {
        case "emojiselect":
            let qlui = this.quill.root?.querySelector("[id='" + valueObj?.objDetails?.targetID + "']");
            qlui.innerHTML = valueObj.value.emoji;
            break;
        case "fontsize":
            this.quill.format("header", "h" + valueObj.index);
            this.quill.update();
            break;
        case "textlistdecimal":
            this.quill.format("list", "ordered");
            this.quill.update();
            break;
        case "textlistbullet":
            this.quill.format("list", "bullet");
            this.quill.update();
            break;
        case "textlistpara":
            this.quill.format("list", "plain");
            this.quill.update();
            break;
        case "textlistchecked":
            this.quill.format("list", "unchecked");
            this.quill.update();
            break;
        default:
            break;
    }
};

MultiTextComponent.prototype.getTextProps = function (parent = null) {
    let primaryText = parent || this.quill?.root;
    let textproperties = {};
    if (primaryText) {
        let fontStyle = primaryText.style;
        let fontStyleLi = null;
        if (primaryText.getAttribute("data-letterspacing")) textproperties.letterspacing = primaryText.getAttribute("data-letterspacing");
        if (primaryText.getAttribute("data-lineheight")) textproperties.lineheight = primaryText.getAttribute("data-lineheight");
        if (fontStyle?.textTransform && fontStyle?.textTransform != "") textproperties.texttransform = fontStyle.textTransform;
        if (fontStyle?.opacity && fontStyle?.opacity != "") textproperties.textopacity = fontStyle.opacity;
        if (fontStyle?.textAlign && fontStyle?.textAlign != "") textproperties.textalign = fontStyle.textAlign;
        if (fontStyle?.filter && fontStyle?.filter != "") textproperties.textgrayscale = fontStyle.filter?.includes("grayscale");
        if (fontStyleLi?.fontSize && fontStyleLi.fontSize != "") textproperties.textsize = fontStyleLi.fontSize;
        else if (fontStyle?.fontSize && fontStyle.fontSize != "") textproperties.textsize = fontStyle.fontSize;
    }
    return textproperties;
};

MultiTextComponent.prototype.updateEvents = function () {
    if (this.quill) {
        this.quill.off("text-change");
        this.quill.off("selection-change");
        this.quill.on("text-change", this.onTextChange.bind(this));
        this.quill.on("selection-change", this.textHighlightMouseUpEvent.bind(this));
    }
};

MultiTextComponent.prototype.textHighlightMouseUpEvent = function (range, source) {
    // if (range) {
    //     window.enableMultitextFloater = true;
    //     if (range.length == 0) {
    //         // console.log("User cursor is on", range.index);
    //         window.multitextSelect = false;
    //     } else {
    //         var text = this.quill.getText(range.index, range.length);
    //         // console.log("User has highlighted", text);
    //         window.multitextSelect = true;
    //         this.updatePropsCallBack();
    //     }
    // } else {
    //     window.multitextSelect = false;
    //     this.updatePropsCallBack("");
    //     // window.enableMultitextFloater = false;
    //     // console.log("Cursor not in the editor");
    // }

    this.onFocusOut();
    // let opstack = this.quill.root.dataset.opstack ? parseInt(this.quill.root.dataset.opstack) : 1;
    // if (this.quill.history.stack.undo.length > 1 && opstack != this.quill.history.stack.undo.length && !window.isFromQuillUndo) {
    //     this.quill.root.setAttribute("data-opstack", this.quill.history.stack.undo.length);
    //     this.setQuillOperation();
    // }
};

MultiTextComponent.prototype.setQuillOperation = function (oldContent, newContent) {
    this.setQuillOperationHandler?.(this.slideID, oldContent, newContent);
};

MultiTextComponent.prototype.onFocusOut = function () {
    let currentText = this.quill.container.innerHTML;
    // let currentDelta = this.quill.getContents();
    if (this.quill && this.quill.root && this.quill.root.parentNode && this.oldQuillContent != currentText && !this.isFocusOutRestrict) {
        let nodeGroup = this.quill.root.parentNode.offsetParent;
        if (!nodeGroup) return;
        nodeGroup.style.setProperty("--nodeTopMargin", "unset");
        // this.quill.root.scrollTop = 0;
        // this.quill.root.parentNode.scrollTop = 0;
        let minHeight = nodeGroup.offsetHeight;
        let parentHeight = this.nodeParent.parentElement.offsetHeight;
        let topMargin = (parentHeight - minHeight) / 2;
        nodeGroup.style.setProperty("--nodeTopMargin", topMargin + "px");
        this.updatePropsCallBack("");
        // setTimeout(() => {
        if (this.oldQuillContent) this.setQuillOperation(this.oldQuillContent, this.quill.container.innerHTML);
        this.oldQuillContent = this.quill.container.innerHTML;
        // this.oldDelta = this.quill.getContents();
        // }, 0);
    }
    if (this.quill.root.textContent == "") {
        this.quill.root.innerHTML = "<p>" + this.sampleData + "</p>";
    }
    this.setSeqNoToLi();
};

MultiTextComponent.prototype.onTextChange = function (delta, oldDelta, source) {
    this.updateJSONData();
    this.updateStyleProps();
    this.updatePropsCallBack("");
};

MultiTextComponent.prototype.setSeqNo = function (li, index) {
    let qlUi = li.querySelector(".ql-ui");
    index = DiagramUtils.getSeqMoodStyleForQuill(this.globalMoodData.seqnumproperties, index);
    qlUi.setAttribute("data-seqno", index);
};

MultiTextComponent.prototype.setSeqNoToLi = function () {
    let arrOrderedLi = Array.from(this.quill.root.querySelectorAll("li[data-list='ordered']"));
    if (arrOrderedLi && arrOrderedLi.length > 0) {
        let arrBaseLi = Array.from(this.quill.root.querySelectorAll("li[data-list='ordered']:not([class*='ql-indent'])"));
        arrBaseLi.forEach((li, index) => {
            this.setSeqNo(li, index + 1);
        });
        let classes = [];
        for (let index = 0; index < 9; index++) {
            classes.push("ql-indent-" + (index + 1));
        }
        classes.forEach((element, index) => {
            let arrLi = Array.from(this.quill.root.querySelectorAll("li[class='" + element + "']"));
            if (arrLi && arrLi.length > 0) {
                let minusIndex = 0;
                arrLi.forEach((li, liIndex) => {
                    this.setSeqNo(li, liIndex + 1 - minusIndex);
                    if (!li.nextSibling?.className.includes(element)) {
                        minusIndex = liIndex + 1;
                    }
                });
            }
        });
    }
};

MultiTextComponent.prototype.updateStyleProps = function () {
    if (this.quill.root && this.quill.root.parentNode) {
        this.updateHeaderStyle();
        this.setQuillSingleLine();
        this.setSeqNoToLi();
        if (this.nodeObj.customicon) {
            let arrBulletLi = Array.from(this.quill.root.querySelectorAll("li[data-list='bullet']"));
            if (this.multitextdata && this.multitextdata[0]) {
                let arrMatrix = this.multitextdata[0].matrix ? this.multitextdata[0].matrix : this.multitextdata;
                arrMatrix?.forEach((element, index) => {
                    // if (element.subdata && element.subdata == "bullet") {
                    this.createCustomBullet(arrBulletLi[index], index, element);
                    // }
                });
            }
            let arrOtherLi = Array.from(this.quill.root.querySelectorAll("li[data-list='plain'],[data-list='ordered']"));
            arrOtherLi.forEach((element) => {
                element.querySelector(".ql-ui").innerHTML = "";
            });
        }
    }
};

MultiTextComponent.prototype.setQuillSingleLine = function () {
    let li = this.quill?.root?.querySelector("li");
    if (li) {
        let lineHeight = parseFloat(window.getComputedStyle(li)?.lineHeight);
        this.quill.root.parentNode?.style.setProperty("--quillSingleLine", lineHeight + "px");
    }
};

MultiTextComponent.prototype.createCustomBullet = function (element, index, data) {
    if (element) {
        let span = element.querySelector(".ql-ui");
        span.setAttribute("data-type", "quillicon");
        span.setAttribute("name", "quillicon");
        span.setAttribute("data-dck-selector", "true");
        span.setAttribute("id", "quillicon" + index);
        if (span.textContent == "") {
            span.innerHTML = data?.icon ? data.icon : this.nodeObj.customicon;
        }
    }
};

MultiTextComponent.prototype.updateHeaderStyle = function () {
    // if (this.quill.root && this.quill.root.parentElement) {
    let arrQuillFontStyling = Constants.Value.quillFontStyling;
    arrQuillFontStyling.forEach((element, index) => {
        this.quill.root.parentElement.style.setProperty("--headerOption" + (index + 1) + "label", element.label);
        this.quill.root.parentElement.style.setProperty("--headerOption" + (index + 1) + "value", element.value);
        let arrHeader = this.quill.root.querySelectorAll("H" + (index + 1));
        arrHeader.forEach((header) => {
            header.classList.add("clsSecondaryColor");
            header.classList.add(element.data);
            DiagramUtils.setColorClass(header, {}, this.globalMoodData, Constants.Value.primaryTextColor);
        });
    });
    // }
};

MultiTextComponent.prototype.onClickNumberList = function (event) {
    this.quill.format("list", "ordered");
    this.quill.update();
    // this.updateStyle("OL");
};

MultiTextComponent.prototype.onClickBulletList = function (event) {
    this.quill.format("list", "bullet");
    this.quill.update();
    // this.updateStyle("UL");
};

MultiTextComponent.prototype.onClickIndent = function (indentIndex) {
    this.quill.format("indent", indentIndex);
    this.quill.update();
};

MultiTextComponent.prototype.onRemoveFormat = function () {
    this.quill.removeFormat();
    this.quill.update();
};

MultiTextComponent.prototype.updatePropsCallBack = function (id = "ELEMENT_DIV") {
    if (this.updateCallBack && this.updateCallBack.func) {
        // this.updateCallBack.func(this.updateCallBack.params, "ql-editor0");
        this.updateCallBack.func(this.updateCallBack.params, id);
    }
};

MultiTextComponent.prototype.setContents = function (multitextdata, arrData = []) {
    if (!multitextdata) return;
    if (multitextdata[0] && multitextdata[0].quilldelta) {
        multitextdata[0]?.quilldelta?.ops?.forEach((element) => {
            if (element?.insert) element.insert = this.trimValue(element.insert);
        });
        return multitextdata[0].quilldelta.ops;
    } else
        multitextdata.forEach((element, index) => {
            // if (element && element.multitextdata) return multitextdata;
            if (element.quilldelta) {
                element?.quilldelta?.ops?.forEach((quillelement) => {
                    if (quillelement?.insert) quillelement.insert = this.trimValue(quillelement.insert);
                });
                arrData = element.quilldelta.ops;
                // return arrData;
            } else if (element.matrix && element.matrix.length > 0) {
                this.setContents(element.matrix, arrData);
            } else if (element.type == "text" && element.value && element.value.trim() != "") {
                arrData.push({ insert: this.trimValue(element.value) });
                // let header = element.header ? this.getHeaderValue(element.header) : null;
                let header = element.header ? element.header : null;
                let list = element.subdata ? element.subdata : this.type ? (this.type == "checked" ? (index < 3 ? "checked" : "unchecked") : this.type) : null;
                let attributes = { indent: element.indent };
                if (header) attributes.header = header;
                else if (list) attributes.list = list;
                // if ((header || list) && index != multitextdata.length - 1)
                // arrData.push({ insert: index != multitextdata.length - 1 ? "\n" : "", attributes: attributes });
                arrData.push({ insert: "\n", attributes: attributes });
                // else arrData.push({ attributes: attributes });
            }
        });
    return arrData;
};

MultiTextComponent.prototype.getJSONData = function () {
    let multitextdata = [];
    let arrChild = this.nodeParent && this.nodeParent.querySelector(".ql-editor") ? Array.from(this.nodeParent.querySelector(".ql-editor").children) : [];
    arrChild.forEach((element) => {
        if (element.tagName == "OL" || element.tagName == "UL") multitextdata.push(this.getListData(element));
        else if ((element.tagName.includes("H") || element.tagName.includes("P")) && element.textContent && element.textContent.trim() != "") multitextdata.push({ type: "text", value: this.trimValue(element.textContent), header: element.tagName.includes("P") ? false : element.tagName });
        else if (element.textContent && element.textContent.trim() != "") {
            multitextdata.push({ type: "text", value: this.trimValue(element.textContent) });
        }
    });
    return multitextdata;
};

MultiTextComponent.prototype.getListData = function (element) {
    let obj = { type: "text", matrix: [] };
    let arrChild = Array.from(element.children);
    arrChild.forEach((element) => {
        let data = { type: "text", value: this.trimValue(element.textContent), subdata: element.dataset.list, indent: this.getIndentData(element) };
        let customicon = element.querySelector(".ql-ui");
        if (customicon && customicon.textContent != "") {
            data.icon = customicon.textContent;
        }
        obj.matrix.push(data);
    });
    return obj;
};

MultiTextComponent.prototype.trimValue = function (text) {
    if (this.nodeObj?.customicon) return text.replace(/\p{Emoji}/u, "");
    else return text;
};

MultiTextComponent.prototype.getIndentData = function (element) {
    let indent = null;
    if (element.className.includes("indent")) {
        element.classList.forEach((strClass) => {
            if (strClass.includes("indent")) {
                indent = strClass.substr(strClass.length - 1);
                return;
            }
        });
    }
    return indent;
};

MultiTextComponent.prototype.changeLineSpacing = function (value) {
    if (value) {
        this.getQuillParent().setAttribute("data-linespace", value.val);
        let arrChildren = this.quill.root.children && Array.from(this.quill.root.children);
        arrChildren.forEach((element) => {
            element.style.setProperty("line-height", value.val + "em");
        });
    }
};

MultiTextComponent.prototype.changeCharacterSpacing = function (value) {
    if (value) {
        this.getQuillParent().setAttribute("data-characterspace", value.val);
        let arrChildren = this.quill.root.children && Array.from(this.quill.root.children);
        arrChildren.forEach((element) => {
            element.style.setProperty("letter-spacing", value.val / 10 + "px");
        });
    }
};

MultiTextComponent.prototype.getQuillParent = function () {
    return this.nodeParent.querySelector("[id*='quillParent']");
};

/**
 * Author:    Saravanan G
 * Created:   22.04.2019
 *Update
 * (c) Copyright by Gs.
 **/

"use strict";

Constants.Value = {
    //Prompts
    primaryTextPrompt: "Primary Heading",
    primaryTextAuthorPrompt: "Profile name",
    primaryTextTestimonialPrompt: "Name",
    secondaryTextPrompt: "Description of a primary heading",
    secondaryTextAuthorPrompt: "Profile designation",
    holderTextPrompt: "Title",
    holderTextQuotePrompt: "Inspiring quote",
    labelTextPrompt: "Caption",
    subTextPrompt: "Sub heading",
    valueTextPrompt: "$50",
    connectorTextPrompt: "Connector Label",
    commonTextPrompt: "Heading",
    buttonPrompt: "Button",

    //Colour Mapping
    diagramTitleColor: "heading",
    primaryTextColor: "heading",
    secondaryTextColor: "secondary",
    labelTextColor: "label",
    connectorTextColor: "connectorcaption",
    subTextColor: "subtitle",
    holderTextColor: "title",
    valueTextColor: "number",
    sequenceTextColor: "sequence",
    authorNameColor: "name",
    authorDesignationColor: "designation",

    //Max Node count to restrict add option.
    textlists: 12, // For vertical textlists like Bullet, Checked and Numbered.
    diagrams: 6, // For other lists and diagrams.

    // Quill editor dropdown
    quillFontStyling: [
        { label: "headline", data: "h4", fontsize: "18px", fontweight: "600" },
        { label: "title", data: "h5", fontsize: "16px", fontweight: "600" },
        { label: "headinglabel", data: "h8", fontsize: "12px", fontweight: "600" },
        { label: "body", data: "p5", fontsize: "12px", fontweight: "400" },
        { label: "caption", data: "p7", fontsize: "10px", fontweight: "400" },
        //{ label: "caption", data: "p7", fontsize: "12px", fontweight: "400" } // Commented due to quill h6 not taken
    ],
    quillDefaultFont: "p3",
    quillDefaultFontColor: "clsSecondaryColor",

    // Css variables to append as classnames in elements
    arrNodeStyleClass: ["--cardstylenode", "--cardstylegroup"],

    // icon style
    iconStyle: ["fill", "stroke", "glyph", "duotone", "colorfull", "line", "dual", "detailedline", "smoothline", "rounded", "roundfill"],

    // placeholder sizes
    arrSize: { tiny: 0.25, small: 0.4, medium: 0.6, large: 0.8, extralarge: 1 },
    fill: ["tiny", "small", "medium", "large", "extralarge"],
    stroke: ["tiny", "small", "medium", "large", "extralarge"],
    glyph: ["tiny", "small", "medium", "large", "extralarge"],
    duotone: ["tiny", "small", "medium", "large", "extralarge"],
    colorfull: ["tiny", "small", "medium", "large", "extralarge"],
    dual: ["tiny", "small", "medium", "large", "extralarge"],
    detailedline: ["tiny", "small", "medium", "large", "extralarge"],
    smoothline: ["tiny", "small", "medium", "large", "extralarge"],
    rounded: ["tiny", "small", "medium", "large", "extralarge"],
    roundedfill: ["tiny", "small", "medium", "large", "extralarge"],

    // Connector supported classes
    connectorClasses: ["SimpleLinearDiagram-hor", "SimpleLinearConnectorNode-hor", "SimpleLinearRatioDiagram-hor", "SimpleLinearVerticalDiagram-ver", "SimpleLinearGridDiagram-grd", "SimpleLinearVerticalGridDiagram-grd"],

    // Diagram title supported classes
    diagramTitleClasses: ["SimpleLinearDiagram-hor", "SimpleGridDiagram-hor", "SimpleLinearConnectorNode-hor", "SimpleLinearRatioDiagram-hor", "SimpleLinearVerticalDiagram-ver", "SimpleLinearGridDiagram-grd", "SimpleLinearVerticalGridDiagram-grd"],
    diagramTitleNodeClasses: ["CustomDiagramNode", "VerticalDiagramNode"],

    // ConnectorText supported classes
    connectorTextClasses: ["SimpleLinearDiagram-hor"],
    // connectorTextClasses: [],

    // Node/Group BG add animation
    arrGroupBG: ["clsMoodGroupStyle", "clsGroupBackgroundStyle", "clsMoodNodeStyle", "clsNodeBackgroundStyle", "clsIconedgeBorderStyle", "clsMoodBoxedStyle"],

    //circular
    circularRingToggleCategory: "",

    // Floater options (to be given in floateroptionsdisable)

    // Base floater options
    addOption: "addoption",
    edit: "edit",
    changeDevice: "changedevice",

    //List type options
    listType: "content",
    listTypeOptions: "contentoptions",
    contentNone: "graphicnone",
    contentText: "graphictext",
    contentIcon: "graphicicon",
    contentImage: "graphicimage",
    contentSequence: "graphicsequence",
    contentMicroChart: "graphicmicrochart",
    contentNumber: "graphicnumber",
    contentLogo: "graphiclogo",
    contentTextList: "graphictextlist",
    contentNumberedList: "graphicnumberedlist",
    contentIconList: "graphiciconlist",
    contentBulletList: "graphicbulletlist",
    contentCheckList: "graphicchecklist",

    secondaryPlaceholder: "secondaryplaceholder",
    // secondary placeholder options
    secondaryIcon: "graphicsecondaryicon",
    secondaryImage: "graphicsecondaryimage",
    secondaryNumber: "graphicsecondarynumber",
    secondaryLogo: "graphicsecondarylogo",
    secondaryLogoGrid: "graphicsecondarylogolist",

    diagramTitle: "diagramtitle",
    primaryText: "primarytext",
    multicontentHeader: "multicontentheader",
    secondaryText: "secondarytext",
    sequenceText: "sequencetext",
    sequenceTextReverse: "sequencetextreverse",
    sequenceTextStart: "sequencetextstart",
    labelText: "label",
    subText: "subtext",
    quote: "quote",
    button: "button",
    arrange: "arrange",
    greyscale: "greyscale",
    logoContrast: "logocontrast",
    microchart: "microchart",
    authorName: "authorname",
    authorDesignation: "authordes",
    authorImage: "authorimage",

    logoSize: "logosize",
    imageSize: "imagesize",
    iconSize: "iconsize",
    numberSize: "numbersize",
    microchartSize: "microchartsize",

    seperatorLine: "seperatorline",
    connector: "connector",
    connectorLine: "connectorline",
    connectorRight: "arrowright",
    connectorLeft: "arrowleft",
    connectorNone: "arrownone",
    connectorBoth: "arrowboth",
    connectorBackAndForth: "arrowbackandforth",
    connectorPlus: "plus",
    connectorMinus: "minus",
    connectorMultiply: "multiply",
    connectorDivide: "divide",
    connectorEqual: "equal",
    connectorNotEqual: "notequal",
    arrConnectors: ["arrownone", "arrowright", "arrowleft", "arrowboth", "arrowbackandforth", "plus", "minus", "multiply", "divide", "equal", "notequal"],
    animationOption: "animationoption",
    animationOff: "animationoff",
    animateAllAtOnce: "animateallatonce",
    animateOneAtaTime: "animateoneatatime",
    animateOneAfterAnother: "animateoneafteranother",

    // Inline floater options
    inlineFloater: "inlinefloater",
    nodeDelete: "nodedelete",
    nodeCrossout: "crossout",
    nodeSwap: "swap",
    nodeEmphasize: "emphasize",
    nodeHighlight: "highlight",
    nodeHyperlink: "hyperlink",
    delete: "delete",

    secondaryTypeBullet: "bullet",
    secondaryTypeDecimal: "decimal",
    secondaryTypePara: "para",
    secondaryTypeIcon: "iconlist",
    secondaryTypeCheck: "checklist",
    secondaryTypeImage: "imagelist",
    secondaryTypeLogo: "logolist",
    secondaryTypeNumber: "numberlist",

    // View Ids
    titleID: "primaryTextNode",
    subTitleID: "secondaryTextNode",
    listNodeID: "listTextNode",
    numberID: "sequenceTextNode",
    contentID: "diagramContentNode",
    imageNodeID: "imageNode",
    iconNodeID: "iconNode",
    textGroupID: "textGroup",

    arrNodeProps: ["emphasize", "crossout", "ischecked", "highlight", "highlightgraphictype", "highlightgraphicid", "highlightgraphicpath", "highlightstyle", "highlighttext", "highlighttargetbounds", "highlightviewportbounds", "alignment", "navigate-to-slide-on-click", "sublist", "logocontrast", "logostyle", "size"],
    arrTextNode: ["primaryText", "secondaryText", "textNode", "numberNode", "microchartNode", "sequenceText", "secondaryTextItem"],
    arrPropertiesDom: [
        "booldiagramcontent",
        "boolsequencetext",
        "boolsecondarytext",
        "boolprimarytext",
        "booldiagramtitle",
        "boolmicrochart",
        "boolmulticontentheader",
        "boolquote",
        "boolauthorimage",
        "boolauthorname",
        "boolauthordes",
        "boolenablesecplaceholder",
        "boolismultigrid",
        "contenttype",
        "secondarytype",
        "logosize",
        "imagesize",
        "iconsize",
        "microchartsize",
        "numbersize",
        "name",
        "graphicmenuname",
        "graphiclayoutname",
        "connectorstyle",
        "version",
        "boolisbleed",
        "boolisgutter",
        "boolisoverlay",
        "position",
        "booltitleallbold",
    ],
    arrStaticProperties: ["jsonlayoutmeta", "fontmapping", "gridlayout", "connectorposition"],
    arrProperties: {
        // General properties.
        booldiagramcontent: true,
        boolsecondarytext: true,
        boolprimarytext: true,
        booldiagramtitle: false,
        boolmulticontentheader: true,
        boollabel: false,
        boolsubtext: false,
        boolmicrochart: true,
        boolgreyscale: false,
        boolsequencetext: false,
        boolsequencetextreverse: false,
        boolauthorimage: true,
        boolquote: true,
        boolgridimage: true,
        boolauthorname: false,
        boolauthordes: false,
        boolbutton: false,
        boolhasconnector: false,
        boolconnector: false,
        boolconnectortext: false,
        boolseperatorline: false,
        boolenablesecplaceholder: false,
        boolislogofit: false,
        boolisimagefit: false,
        boolcommonnodevisible: true,
        boolismultigrid: false,
        boolmulticolor: false,
        boolisfromai: false,

        contenttype: "text",
        secondarytype: "none",
        logostyle: "logo", // "logo/icon/light/dark/grayscale"
        logosize: "medium",
        bgtype: null,
        imagesize: "medium",
        iconsize: "medium",
        microchartsize: "medium",
        numbersize: "medium",
        valueformat: "actualnumber",
        jsonfontresize: { primaryText: "auto", secondaryText: "auto", authorName: "auto", holderText: "auto", authorDes: "auto" }, // user selection
        jsonfontdefault: { primaryText: null, secondaryText: null, authorName: null, holderText: null, authorDes: null }, // default input from designers
        jsoncenternodefontresize: { holderText: "auto" },
        jsongraphicData: null,
        diagramtype: "vertical",
        fontmapping: "",
        name: "",
        secondaryplaceholder: null,
        jsonfloateroptionsdisable: ["content"],
        jsonsupportedlisttypes: ["bullet", "decimal", "para"],
        jsonsupportedgloballisttypes: null,
        jsonlayoutmeta: [],
        jsonassetCenterShape: null, // Handled internally
        connectorstyle: "arrownone",
        sequencetextstart: 1,
        version: 0,
        minnode: 2,
        maxnode: 6,
        maxlimit: null,
        graphicmenuname: "",
        graphiclayoutname: "",

        // Circular diagram properties
        commonnodesize: 0.3,
        strech: 1,
        dasharrayindex: 0,
        dasharray: 0,
        strokewidthindex: 1,
        strokewidth: 3,
        connectorstart: "none",
        connectorstartindex: 0,
        connectorend: "none",
        connectorendindex: 0,
        connectorgap: 0,
        connectorposition: "middle",

        // Table diagram properties
        iscolumnheader: false,
        isrowheader: false,

        // Timeline diagram properties
        dateformat: "yyyy",

        // Center node properties
        contentholdertype: "iconHolder",
        centernodetype: "icon",
        centerholdertype: "iconHolder",
        nonlinearcontent: "icon",

        //Custom Pyramid diagram properties
        boolisreverse: false,
        boolisflip: false,
        boolislineconnector: false,
        projectionindex: 100,
        topwidth: 100,
        basewidth: 500,

        // Takeaway title properties
        takeawaytitlehoralign: null,

        // Grid properties
        gridlayout: "",
        gridlayoutname: "",
        overlayopacity: null,
        boolisbleed: false,
        boolisgutter: false,
        boolisoverlay: true,
        boolisoverlaysupport: true,
        boolhidegridlayout: false,
        border: "",
        position: "",

        // MultiText properties
        linespace: 0,
        characterspace: 0,
        booltitleallbold: false,
    },
    arrNodePropertiesDom: ["booltextOnly", "boolfixedGroup", "boolfixedNode", "boolfixedSecContent", "boolfixedSecSubContent", "boolfixedContent", "booltitlecomponent", "name", "parentStyle", "centerNodeStyle", "nodeclassName", "nodeposition", "valign", "nodealignment"],
    arrStaticNodeProperties: [
        "jsonimageRatio",
        "jsonsupportedNodes",
        "jsoncommonText",
        "jsoncenterNode",
        "jsonconnector",
        "jsonseperatorline",
        "jsonconnectortext",
        "jsoncontentBG",
        "jsoncheckBG",
        "jsonuncheckBG",
        "jsonquoteShape",
        "jsonemphasisShape",
        "jsonbgsvg",
        "jsongrid",
        "jsonobjClass",
        "boolstockImageChange",
        "arrTextNodes",
        "arrHeight",
        "arrResizeNode",
        "jsonminWidthHeight",
        "strikeOut",
        "fontClass",
        "iconNumberNodeWidth",
        "iconNumberNodeHeight",
    ],
    arrNodeProperties: {
        jsonanimationtype: {},
        jsonimageRatio: {},
        jsonsupportedNodes: [{ name: "titleHolder" }, { name: "subTitleHolder" }],
        jsonassetGroupingId: null,
        jsoniconGroupingId: null,
        jsoncommonText: null,
        jsoncenterNode: null,
        jsonconnector: null,
        jsonconnectortext: null,
        jsonseperatorline: null,
        jsoncontentBG: null,
        jsoncheckBG: null,
        jsonuncheckBG: null,
        jsonquoteShape: null,
        jsonemphasisShape: null,
        jsoncenterShape: null,
        jsonenableContrast: null,
        // jsoncenterShape2: null,
        /*
        "centerShape": { "type": "svg", "id": "chessstep", "value": "genericassets/shapes/", "position": "horizontal,placeholder,center" },
        type : "illustration/svg/lottie"
        placeholdertype : "icon" -> used when icon is given as seperate placeholder in svg.
        singleasset : true -> used when asset naming does not follow the rule of (assetname+2node,assetname+3node) etc
        position[0] = "horizontal/vertical"
        position[1] = "placeholder/connectorpoint/process/alternate/convergediverge"
        position[2] = "top/bottom/left/right/center/topleft/bottomleft/topright/bottomright"
        */
        jsonbgsvg: null,
        jsongrid: null,
        jsonobjClass: null,
        emphasisClass: null,
        booltextOnly: false,
        boolfixedGroup: false,
        boolfixedNode: false,
        boolfixedSecContent: false,
        boolfixedSecSubContent: false,
        boolfixedContent: false,
        booltitlecomponent: false,
        boolstockImageChange: false,

        name: "",
        parentStyle: "",
        globalstyle: "",
        centerNodeStyle: "",
        titleVAlign: "flex-start",
        subTitleVAlign: "flex-start",
        sqNodePositionTop: "calc(100% - 0px)",
        nodeclassName: "PlainDiagramNode",
        nodecontentcolor: null,
        colorAnimationClass: null, // used for color animation
        //please change to boolean value @Krishna
        centernodevisible: "true",
        iconvisible: "true",
        timelineclass: "",
        nodeposition: "alternate",
        nodegap: "20",

        arrResizeNode: [],
        arrTextNodes: ["titleHolder", "subTitleHolder", "textTitleHolder", "authorNameHolder", "authorDesHolder"],
        arrHeight: [1000],
        centernoderatio: 0.2,
        iconsizeratio: 0.15,
        pathoffset: 10,
        iconPadding: 0,
        sqNodePositionLeft: 0,

        contentNodePadding: null,
        secondaryContentNodePadding: null,
        nodeParentPadding: null,
        gap: null,
        valign: null,
        bgColor: null,
        innerColor: null,
        alterColor: null,
        microStyle: null,
        nodeShadow: null,
        nodeBorder: null,
        nodeBorderRadius: null,
        nodeGradient: null,
        nodeRatio: null,
        sqNodePosition: null,
        moodShapePosition: null,
        jsonminWidthHeight: null,
        strikeOut: null,
        fontClass: null,
        iconNumberNodeWidth: null,
        iconNumberNodeHeight: null,
        imagegridtype: null,
        imagegridclass: null,
        nodealignment: null,
        devicealignment: null,
    },

    placeholdersvg:
        '<svg xmlns="http://www.w3.org/2000/svg" id="placeholder" data-name="Layer 1" viewBox="0 0 120 120" width="100%" height="100%"><path id="Shape" d="M60,4.93A55.07,55.07,0,1,1,4.93,60,55.14,55.14,0,0,1,60,4.93M60,1a59,59,0,1,0,59,59A59,59,0,0,0,60,1Z" stroke="none"></path><path id="Shape" d="M49,94.43V57.52a13,13,0,1,1,13,13H55.51l-3.24,13H62A26,26,0,1,0,36.05,57.52V86.94Z" stroke="none" fill-rule="evenodd"></path></svg>',
    placeholderarrowheadsvg:
        '<svg xmlns="http://www.w3.org/2000/svg" width="18.8" height="29.114" viewBox="0 0 18.8 29.114"><path id="crystalcssarrowhead" data-name="crystalcssarrowhead" d="M2310,1148l12.436,12.435L2310,1172.871" transform="translate(-2307.879 -1145.879)" fill="none" stroke="#444444" stroke-width="6"/></svg>',
    placeholder_logopath: "genericassets/placeholderimages/logoplaceholder_landscape.png",
    placeholder_iconpath: "genericassets/icons/placeholder/placeholder.svg",
    placeholder_imagepath: "genericassets/placeholderimages/placeholder.png",
    placeholder_teamimagepath: "genericassets/placeholderimages/teamimage.png",
    placeholder_illustrationpath: "genericassets/images/app/breaker_slide_2.svg",
    placeholder_devicepath: "genericassets/device/modern/iphone.svg",
    URL_IMAGE_ICONS: "getSingleIconOrImage",
    xyplotsvg: `<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" class="fullBackgroundSVG" width="100%" height="100%"><defs><pattern id="svgPattern" width="52" height="50" patternUnits="userSpaceOnUse"><rect width="100%" height="100%" class="clsSVGPattenDefs"/></pattern></defs><rect fill="url(#svgPattern)" class="clsSVGPattenRect"/><rect id="axisLineY" class="clsSVGPattenYAxis"/><rect id="axisLineX" class="clsSVGPattenXAxis"/><rect id="axisLineLeft" class="clsSVGPattenLeftAxis"/><rect id="axisLineBottom" class="clsSVGPattenBottomAxis"/><path id="arrowPlusX" class="clsPathArrow" d="M0 0L15 9.5L0 19V0Z" fill="none"/><path id="arrowMinusX" class="clsPathArrow" d="M0 0L15 9.5L0 19V0Z" fill="none"/><path id="arrowPlusY" class="clsPathArrow" d="M0 0L15 9.5L0 19V0Z" fill="none"/><path id="arrowMinusY" class="clsPathArrow" d="M0 0L15 9.5L0 19V0Z" fill="none"/><path id="arrowLeftY" class="clsPathArrowLeft" d="M0 0L15 9.5L0 19V0Z" fill="none"/><path id="arrowLeftX" class="clsPathArrowLeft" d="M0 0L15 9.5L0 19V0Z" fill="none"/></svg>`,
    // Placeholder svg for connectorpoint load failure.
    trophy6node: `<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="trophy6node-Layer_1" data-name="Layer 1" viewBox="0 0 284 600"><g id="trophy6node-main"><g id="trophy6node-point1"><g id="trophy6node-connector1"><rect id="trophy6node-left1" y="100" width="1" height="1.03" fill="none" stroke="none"/></g></g><g id="trophy6node-point2"><g id="trophy6node-connector2"><rect id="trophy6node-right2" x="283" y="100" width="1" height="1.03" fill="none" stroke="none"/></g></g><g id="trophy6node-point3"><g id="trophy6node-connector3"><rect id="trophy6node-left3" y="299.5" width="1" height="1.03" fill="none" stroke="none"/></g></g><g id="trophy6node-point4"><g id="trophy6node-connector4"><rect id="trophy6node-right4" x="283" y="299.5" width="1" height="1.03" fill="none" stroke="none"/></g></g><g id="trophy6node-point5"><g id="trophy6node-connector5"><rect id="trophy6node-left5" y="499.6" width="0.8" height="0.83" fill="none" stroke="none"/></g></g><g id="trophy6node-point6"><g id="trophy6node-connector6"><rect id="trophy6node-right6" x="283" y="499.5" width="1" height="1.03" fill="none" stroke="none"/></g></g></g></svg>`,
    // Placeholder svg for placeholder type load failure.
    coin6node: `<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="coin6node-Layer_1" data-name="Layer 1" viewBox="0 0 1280 720"><g id="coin6node-main"><g id="coin6node-point1"><g id="coin6node-placeholder"><rect id="coin6node-content1-right-middle" x="64" y="191" width="468" height="132" fill="none" stroke="none"/></g></g><g id="coin6node-point2"><g id="coin6node-placeholder-2" data-name="placeholder"><rect id="coin6node-content2-left-middle" x="740" y="191" width="476" height="132" fill="none" stroke="none"/></g></g><g id="coin6node-point3"><g id="coin6node-placeholder-3" data-name="placeholder"><rect id="coin6node-content3-right-middle" x="64" y="357.5" width="432" height="132" fill="none" stroke="none"/></g></g><g id="coin6node-point4"><g id="coin6node-placeholder-4" data-name="placeholder"><rect id="coin6node-content4-left-middle" x="880" y="357.5" width="336" height="132" fill="none" stroke="none"/></g></g><g id="coin6node-point5"><g id="coin6node-placeholder-5" data-name="placeholder"><rect id="coin6node-content5-right-middle" x="64" y="524" width="340" height="132" fill="none" stroke="none"/></g></g><g id="coin6node-point6"><g id="coin6node-placeholder-6" data-name="placeholder"><rect id="coin6node-content6-left-middle" x="884" y="524" width="332" height="132" fill="none" stroke="none"/></g></g></g></svg>`,
    tableProperties: {
        boolrowheader: false,
        boolcolheader: false,
        boolcolfooter: false,
        boolnumbering: false,
        boolisoverlay: false,
        boolisoverlaysupport: false,
        boolignorefirstrow: false,
        tableresize: "aspect-fill",
        sequencetextstart: 1,
        arrrowhighlightindex: null,
        arrcolhighlightindex: null,
        arrcellhighlightindex: null,
    },
};

function Constants() {
    Object.freeze(Constants.Value);
}

Constants();

/**
 * Author:    Saravanan G
 * Created:   22.04.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function DiagramNodeUtils() {}

DiagramNodeUtils.uuidv4 = function () {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
        var r = (Math.random() * 16) | 0,
            v = c == "x" ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
};

DiagramNodeUtils.createSVGElement = function (nodeName) {
    return document.createElementNS("http://www.w3.org/2000/svg", nodeName);
};

DiagramNodeUtils.assignSVGNodeAttributes = function (node, attributes) {
    for (let attribute in attributes) {
        node.setAttributeNS(null, attribute, attributes[attribute]);
    }
};

DiagramNodeUtils.assignAttributes = function (node, attrs, unitCheck) {
    for (let i1 in attrs) {
        let ns = i1.substr(0, 4) === "xml:" ? "http://www.w3.org/2000/xmlns/" : i1.substr(0, 6) === "xlink:" ? "http://www.w3.org/1999/xlink" : null;
        try {
            if (ns) {
                node.setAttributeNS(ns, i1, attrs[i1]);
            } else if (!unitCheck && node) {
                node.setAttribute(i1, attrs[i1]);
            }
        } catch (error) {
            console.log(error);
        }
    }
};

DiagramNodeUtils.createSVGIconNode = function (className, id, value, index, nodeID) {
    let svgNode = DiagramNodeUtils.createSVGElement("svg");
    if (className) className.includes("accent") ? svgNode.setAttribute("class", "clsAccentfill") : svgNode.setAttribute("class", className);
    svgNode.setAttribute("data-index", index);
    svgNode.setAttribute("class", nodeID);
    svgNode.setAttribute("id", nodeID + DiagramNodeUtils.uuidv4());
    svgNode.setAttribute("data-id", nodeID);
    svgNode.setAttribute("iconid", id);
    svgNode.setAttribute("iconpath", value);
    svgNode.setAttribute("data-nodetype", "iconNode");
    svgNode.setAttribute("data-content-type", "icon");
    return svgNode;
};

DiagramNodeUtils.createSVGDataNode = function (className, id, value, index, nodeID, nodeObj = null) {
    let svgNode = DiagramNodeUtils.createSVGElement("svg");
    let use = DiagramNodeUtils.createSVGElement("use");
    if (className) className.includes("accent") ? use.setAttribute("class", "clsAccentfill") : use.setAttribute("class", className);
    use.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "#" + DiagramNodeUtils.getIconName({ id: id, value: value }));
    use.setAttribute("id", "useNode");
    use.setAttribute("data-id", "useNode");
    use.setAttribute("data-index", index);
    if (nodeObj) {
        DiagramCreateUtil.checkTextContrast(nodeObj, use);
    }
    svgNode.setAttribute("data-index", index);
    svgNode.appendChild(use);
    svgNode.setAttribute("class", nodeID);
    svgNode.setAttribute("id", nodeID + DiagramNodeUtils.uuidv4());
    svgNode.setAttribute("data-id", nodeID);
    svgNode.setAttribute("iconid", id);
    svgNode.setAttribute("iconpath", value);
    svgNode.setAttribute("data-nodetype", "iconNode");
    svgNode.setAttribute("name", "iconNode");
    svgNode.setAttribute("data-content-type", "icon");
    return svgNode;
};

DiagramNodeUtils.createPercentValue = function (computedValue, actualValue) {
    return (actualValue / computedValue) * 100 + "%";
};

DiagramNodeUtils.isAssetInDefs = function (assetId, iconPath, defs) {
    for (let i1 = 0; i1 < defs.children.length; i1++) {
        let defNode = defs.children[i1];
        let uid = iconPath.replaceAll("/", "").replaceAll(".", "").toLowerCase();
        let defIconPath = defNode.getAttribute("iconpath");
        if (defNode.getAttribute("id") == assetId && defNode.getAttribute("uid") == uid && (!defIconPath || defIconPath == iconPath)) return true;
    }
    return false;
};

DiagramNodeUtils.getDocumentDefs = function (nodeParent, localDefs = null) {
    let defName = localDefs == true || nodeParent != document.body ? "svgDefsLocal" : "svgDefs";
    let svgDefs = nodeParent.querySelector("[id='" + defName + "']");
    if (!svgDefs) {
        svgDefs = DiagramNodeUtils.createSVGElement("svg");
        DiagramNodeUtils.assignSVGNodeAttributes(svgDefs, {
            width: 0,
            height: 0,
            id: defName,
        });
        nodeParent.appendChild(svgDefs);
    }
    let defs = svgDefs.querySelector("defs");
    if (!defs) {
        defs = DiagramNodeUtils.createSVGElement("defs");
        svgDefs.appendChild(defs);
    }
    return defs;
};

DiagramNodeUtils.getOffsetLeftTop = function (imageParent, parenttype = "SLIDE") {
    let item = { x: 0, y: 0 };
    let itemParent = imageParent;
    while (itemParent && itemParent.dataset && itemParent.dataset.type != parenttype) {
        item.x = itemParent.offsetLeft + item.x;
        item.y = itemParent.offsetTop + item.y;
        itemParent = itemParent.offsetParent;
    }
    return { x: item.x, y: item.y };
};

DiagramNodeUtils.appenDefs = function (item, nodeParent) {
    if (item != null) {
        let defs = DiagramNodeUtils.getDocumentDefs(nodeParent);
        let name = DiagramNodeUtils.getIconName(item);
        if (!DiagramNodeUtils.isAssetInDefs(name, item.value, defs)) {
            let tempDiv = document.createElement("div");
            tempDiv.innerHTML = item.data;
            let svgDOM = tempDiv.querySelector("svg");
            if (svgDOM) {
                svgDOM.setAttribute("id", name);
                svgDOM.setAttribute("uid", item.value.replaceAll("/", "").replaceAll(".", "").toLowerCase());
                svgDOM.setAttribute("removeonmood", "true");
                svgDOM.setAttribute("iconpath", item.value);
                defs.appendChild(svgDOM);
            }
        }
    }
};

DiagramNodeUtils.getIconStyle = function (item) {
    let arrIconStyle = Constants.Value.iconStyle;
    let iconStyle = null;
    arrIconStyle.forEach((element) => {
        if (item.value && item.value.includes("/" + element + "/") && item.id && !item.id.endsWith("_" + element)) iconStyle = "_" + element;
    });
    return iconStyle;
};

DiagramNodeUtils.getIconName = function (item) {
    if (!item.id) {
        item.id = item.value.substring(item.value.lastIndexOf("/") + 1).split(".")[0];
    }
    return item.id + (item.id != "placeholder" && DiagramNodeUtils.getIconStyle(item) ? DiagramNodeUtils.getIconStyle(item) : "");
};

DiagramNodeUtils.getFontSize = function (name, nodeObj, defaultFontSize, properties) {
    let hasFontResize = properties.fontresize && properties.fontresize[name] && properties.fontresize[name] != "auto";
    let hasFontDefault = properties.fontdefault && properties.fontdefault[name];
    return hasFontResize ? properties.fontresize[name] : hasFontDefault || nodeObj.fontClass || defaultFontSize;
};

DiagramNodeUtils.getOriginalFontSize = function (name, nodeObj, defaultFontSize, properties) {
    let hasFontDefault = properties.fontdefault && properties.fontdefault[name];
    return hasFontDefault || nodeObj.fontClass || defaultFontSize;
};

DiagramNodeUtils.setResizeFont = function (name, nodeObj, defaultFontSize, properties) {
    let hasFontResize = properties.fontresize && properties.fontresize[name] && properties.fontresize[name] != "auto";
    return hasFontResize ? properties.fontresize[name] : nodeObj.fontClass || defaultFontSize;
};

DiagramNodeUtils.getAssertFromDefs = function (assetId, iconpath, defs) {
    for (let i1 = 0; i1 < defs.children.length; i1++) {
        let defNode = defs.children[i1];
        let deficonPath = defNode.getAttribute("iconpath");
        if (defNode.getAttribute("id") == assetId && (!deficonPath || deficonPath == iconpath)) return defNode;
    }
    return null;
};

DiagramNodeUtils.getGapForConnectors = function (nodeProps, nodeCount, diagramParent, properties, isConnectorWidth = false) {
    properties = properties || {};
    let gap = DiagramNodeUtils.getGapForMathSymbols(nodeProps, nodeCount, diagramParent);
    let isLeftAlign = nodeProps?.connector?.alignment == "left" && !isConnectorWidth;
    if (properties.hasconnector && ((properties.connectorstyle && properties.connectorstyle == "arrownone") || isLeftAlign)) return gap;
    let hasConnectorDisabled = properties?.floateroptionsdisable?.includes("connector");
    let hasConnectorTextDisabled = properties?.floateroptionsdisable?.includes("connectortext");
    let hasSeperatorLineDisabled = properties?.floateroptionsdisable?.includes("seperatorline");
    gap =
        !hasConnectorTextDisabled && nodeProps?.connectortext?.mingap && properties.connectortext
            ? nodeProps.connectortext.mingap
            : !hasConnectorDisabled && nodeProps?.connector?.mingap && properties.hasconnector
            ? nodeProps.connector.mingap
            : !hasSeperatorLineDisabled && nodeProps?.seperatorline && properties?.seperatorline && nodeProps?.seperatorline?.mingap
            ? nodeProps.seperatorline.mingap
            : gap;
    return gap;
};

DiagramNodeUtils.getGapForMathSymbols = function (nodeProps, nodeCount, diagramParent) {
    try {
        if (nodeProps?.gap?.toString()?.includes("auto")) {
            let gap = nodeProps.gap.split(",")[0];
            let percentage = nodeProps.gap.split(",")[2] || 15;
            if (gap.includes("%")) gap = (diagramParent.clientWidth * parseInt(gap)) / 100;
            if (nodeCount >= 3) gap = gap - gap * (((nodeCount - 2) * percentage) / 100);
            return gap;
        }
    } catch (error) {
        console.log(error);
    }
    return DiagramPropertyUtils.getDefaultDiagramNodeGap(nodeProps, diagramParent);
};

DiagramNodeUtils.getOverlapGap = function (nodeProps, nodeCount, parentElement) {
    let gap = 0;
    try {
        if (nodeProps?.gap?.toString()?.includes("auto") && nodeProps?.connector?.overlap) {
            gap = JSON.parse(JSON.stringify(nodeProps.gap)).split(",")[0];
            let percentage = nodeProps.gap.split(",")[2] || 15;
            if (gap.includes("%")) gap = (nodeProps.connector.overlap * parseInt(gap)) / 100;
            if (nodeCount >= 3) gap = gap * (((nodeCount - 2) * percentage) / 100);
            else gap = 0;
            return gap;
        }
    } catch (error) {
        console.log(error);
        return 0;
    }
    return DiagramPropertyUtils.getDefaultDiagramNodeGap(nodeProps, parentElement);
};

DiagramNodeUtils.parseCssCustomConnector = function (connectorNode, parentNode, nodeProps, nodeCount, properties) {
    let diagramParent = parentNode.parentElement.parentElement;
    let connectorWidth = DiagramNodeUtils.getGapForConnectors(nodeProps, nodeCount, diagramParent, properties, true);
    let gap = DiagramNodeUtils.getGapForConnectors(nodeProps, nodeCount, diagramParent, properties);
    // let connectorGap = nodeProps?.connector?.gap && (!nodeProps?.connector?.style?.includes("none") || !properties.connectorstyle?.includes("none")) ? nodeProps?.connector?.gap : 0;
    let connectorGap = nodeProps?.connector?.gap && !properties.connectorstyle?.includes("none") ? nodeProps?.connector?.gap : 0;
    let connectorOverlap = nodeProps?.connector?.overlap || 0;
    if (connectorOverlap > 0) {
        connectorOverlap = connectorOverlap - DiagramNodeUtils.getOverlapGap(nodeProps, nodeCount, diagramParent);
    }
    diagramParent.style.setProperty("--connectorGap", connectorGap + "px");
    diagramParent.style.setProperty("--connectorOverlap", connectorOverlap + "px");
    diagramParent.style.setProperty("--connectorWidth", parseFloat(connectorWidth) + parseFloat(connectorOverlap) + "px");
    DiagramNodeUtils.alignCssArrowNode(nodeProps, parentNode, connectorNode, gap, connectorWidth);
};

DiagramNodeUtils.alignCssArrowNode = function (nodeProps, parentNode, connectorNode, gap, connectorWidth) {
    let anchor = nodeProps?.connector?.anchor || "group";
    let nodeName = DiagramNodeUtils.getNodeFromMenuNodeName(anchor);
    let anchorNode = parentNode.querySelector(`[name='${nodeName}']`);
    if (!anchorNode || anchorNode.clientHeight == 0) anchorNode = parentNode.querySelector(`[name='titleHolder']`);
    let anchorGroupBg = parentNode.parentElement.classList.contains("clsGroupBackgroundStyle");
    if (!anchorNode || anchorNode.clientHeight == 0 || anchorGroupBg) {
        anchorNode = parentNode.querySelector(`[name='nodeGroup']`);
        nodeName = "nodeGroup";
    }
    let anchorTop = nodeName == "nodeparent" || nodeName == "nodeGroup" ? 0 : anchorNode.offsetTop;
    parentNode.parentElement.parentElement.style.setProperty("--connectorContentWidth", anchorNode.clientWidth + "px");
    if (nodeProps?.connector?.alignment && nodeProps?.connector?.alignment == "left") parentNode.parentElement.parentElement.style.setProperty("--connectorHorLeft", "calc(100% - " + (parentNode.clientWidth - anchorNode.clientWidth - parseInt(gap) + parseInt(connectorWidth)) / 2 + "px)");
    else {
        let diagramParent = parentNode?.parentElement?.parentElement?.parentElement;
        let isVertical = diagramParent?.getAttribute("data-classname") == "SimpleLinearVerticalDiagram";
        if (isVertical) parentNode.parentElement.parentElement.style.setProperty("--connectorLeft", anchorNode.offsetLeft + anchorNode.clientWidth / 2 - connectorNode.clientHeight / 2 + "px");
        else parentNode.parentElement.parentElement.style.setProperty("--connectorLeft", anchorNode.offsetLeft + anchorNode.clientWidth / 2 - connectorNode.clientWidth / 2 + "px");
    }
    parentNode.parentElement.parentElement.setAttribute("data-connectoralignment", nodeProps?.connector?.alignment);
    let marginTop = "0px";
    let nodeGroup = parentNode.querySelector("[name='nodeGroup']");
    if (nodeGroup) marginTop = window.getComputedStyle(nodeGroup).getPropertyValue("margin-top");
    parentNode.parentElement.parentElement.style.setProperty("--connectorTop", parseFloat(marginTop) + (anchorTop + anchorNode.clientHeight / 2 - connectorNode.clientHeight / 2) + "px");
};

DiagramNodeUtils.createMarker = function (diagramParent, index, moodName, appStaticURL) {
    let marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
    marker.setAttribute("id", "markerCurved" + index);
    marker.setAttribute("markerUnits", "userSpaceOnUse");
    marker.setAttribute("orient", "auto");
    let objAssets = { id: moodName + "arrowhead", value: appStaticURL + "moods/" + moodName + "/" + moodName + "arrowhead.svg" };
    DiagramAssetLoader.oneTimeDownload(objAssets, false, document.body)
        .then((svgData) => {
            DiagramNodeUtils.setSvgMarker(svgData.data, marker, index, diagramParent);
        })
        .catch((error) => {
            console.log("SVG asset load fail - " + error);
            DiagramNodeUtils.setSvgMarker(Constants.Value.placeholderarrowheadsvg, marker, index, diagramParent);
        });

    return marker;
};

DiagramNodeUtils.setSvgMarker = function (data, marker, index, diagramParent) {
    let svg = DiagramUtils.getSVGfromString(data);
    marker.innerHTML = svg.innerHTML;
    let width = svg.getAttribute("viewBox").split(" ")[2];
    let height = svg.getAttribute("viewBox").split(" ")[3];

    marker.setAttribute("markerWidth", width);
    marker.setAttribute("markerHeight", height);
    marker.setAttribute("refX", width / 2);
    marker.setAttribute("refY", height / 2);

    let isFill = marker.firstElementChild.getAttribute("fill") && marker.firstElementChild.getAttribute("fill") != "none";
    marker.firstElementChild.setAttribute("class", "accent" + (index + 1) + (isFill ? "-fill" : "-stroke"));

    let defs = DiagramNodeUtils.getDocumentDefs(diagramParent.parentElement, true);
    let markerLocal = defs.querySelector("[id='markerCurved" + index + "']");
    if (markerLocal) markerLocal.remove();

    defs.appendChild(marker);
};

DiagramNodeUtils.drawCurveConnector = function (svg, radius, start, end, diagramParent, index, moodName, appStaticURL) {
    let largeArcFlag = "0";
    let d = ["M", start.x, start.y, "A", radius, radius, 0, largeArcFlag, 1, end.x, end.y].join(" ");
    let path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("fill", "none");
    path.setAttribute("class", "arrowCurvedPath");
    path.setAttribute("d", d);
    let marker = DiagramNodeUtils.createMarker(diagramParent, index, moodName, appStaticURL);
    path.setAttribute("marker-end", "url(#" + marker.getAttribute("id") + ")");
    svg.appendChild(path);
};

DiagramNodeUtils.calcBoundsDifference = function (attrib, parent, child) {
    return child?.getBoundingClientRect()?.[attrib] - parent?.getBoundingClientRect()?.[attrib];
};

DiagramNodeUtils.getBaseHeight = function (target) {
    if (!target) return;
    let clone = target.cloneNode(true);
    clone.style.height = "auto";
    target.parentElement.appendChild(clone);
    let height = clone.clientHeight;
    target.parentElement.removeChild(clone);
    return height;
    // return target.clientHeight;
};

DiagramNodeUtils.getAssetDimensions = function (svg) {
    let viewBox = svg.getAttribute("viewBox");
    let viewBoxDefault = svg.getAttribute("viewBoxDefault");
    if (viewBox) {
        let vbWidth = Number(viewBox.split(" ")[2]);
        let vmHeight = Number(viewBox.split(" ")[3]);
        return { width: vbWidth, height: vmHeight };
    } else if (viewBoxDefault) {
        let vbWidth = Number(viewBoxDefault.split(" ")[2]);
        let vmHeight = Number(viewBoxDefault.split(" ")[3]);
        return { width: vbWidth, height: vmHeight };
    } else {
        let width = Number(svg.getAttribute("width"));
        let height = Number(svg.getAttribute("height"));
        return { width: width, height: height };
    }
};

DiagramNodeUtils.diagramContentData = function (type, appAssetURL, arrDefaults, index) {
    if (arrDefaults && arrDefaults[type] && arrDefaults[type].length > 0) return arrDefaults[type][index % arrDefaults[type]?.length];

    if (type == "bulleted" || type == "none") {
        return { type: "none", value: "", contenttype: "none" };
    } else if (type == "icon") {
        return { type: "icon", value: "genericassets/icons/placeholder/placeholder.svg", contenttype: "icon", id: "placeholder", dataRef: { name: "placeholder" } };
    } else if (type == "image") {
        return { type: "image", value: appAssetURL + "genericassets/placeholderimages/placeholder.png", contenttype: "image" };
    } else if (type == "teamimage") {
        return { type: "image", value: appAssetURL + "genericassets/placeholderimages/teamimage.png", contenttype: "image" };
    } else if (type == "logo") {
        return { type: "image", value: appAssetURL + "genericassets/placeholderimages/logoplaceholder_landscape.png", contenttype: "logo" };
    } else if (type == "microchart") {
        return { type: "text", value: "70", contenttype: "microchart" };
    } else if (type == "number" || type == "valued") {
        return { type: "text", value: "", contenttype: "number" };
    } else if (type == "button") {
        return { type: "text", value: "", contenttype: "button" };
    } else if (type == "checklist") {
        return { type: "checked", value: index < 3 ? true : false, contenttype: "number" };
    } else if (type == "bulletlist") {
        return { type: "bulletlist", contenttype: "bulletlist" };
    } else {
        return { type: "text", value: "", contenttype: "text" };
    }
};

DiagramNodeUtils.setLogoUrlData = function (targetLogo, arrLogoData) {
    if (!targetLogo) return "";
    let strLogoData = "";
    arrLogoData.forEach((data, index) => {
        strLogoData += data.type + "___" + data.url + (index != arrLogoData.length - 1 ? "," : "");
    });
    targetLogo.removeAttribute("data-logobaseurl");
    targetLogo.setAttribute("data-logodata", strLogoData);
};

DiagramNodeUtils.getLogoStyle = function (node) {
    let nodelogodata = node.parentElement.dataset.logodata;
    let logobaseurl = node.parentElement.dataset.logobaseurl || "";
    let logodata = { logos: [] };
    if (nodelogodata) {
        let arrValues = node.parentElement.dataset.logodata.split(",");
        arrValues.forEach((element) => {
            logodata.logos.push({
                type: element.split("___")[0].toUpperCase(),
                label: "TYPE " + element.split("_")[0].toUpperCase(),
                url: logobaseurl + element.split("___")[1],
            });
        });
        return logodata;
    }
    return null;
};

DiagramNodeUtils.getContentDataFromNode = function (node, contentType, nodeGroup) {
    let data = {};
    let dataRef = {};
    let assetText = node.parentElement.getAttribute("data-node-graphic-text") || "";
    switch (contentType) {
        case "image":
        case "logo":
            dataRef = { imageURL: node.src };
            if (node.dataset.csstext) dataRef.cropStyle = node.dataset.csstext;
            if (node.dataset.style) dataRef.cropData = node.dataset.style;
            let value = node.src || node.getAttribute("xlink:href");
            let logodata = DiagramNodeUtils.getLogoStyle(node);
            data = { type: "image", assetText: assetText, value: value, dataRef: dataRef, contenttype: contentType, logodata: logodata?.logos?.length > 1 ? logodata : null };
            if (contentType == "logo") {
                data.logocontrast = node.parentElement.dataset.logocontrast && node.parentElement.dataset.logocontrast == "true";
                data.link = DiagramUtils.getLinkData(node.parentElement);
                data.scaledHeight = node.parentElement.parentElement.dataset.scaledheight;
            }
            break;
        case "icon":
            let iconid = node.getAttribute("iconid");
            let path = node.getAttribute("iconpath");
            dataRef.name = iconid;
            data = { type: "icon", assetText: assetText, value: path, id: iconid, dataRef: dataRef, contenttype: contentType };
            break;
        case "number":
        case "microchart":
            if (contentType == "microchart" && !node.querySelector("[name='microchartNode']")) {
                node = nodeGroup.querySelector("[name='microchartNode']");
            }
            data = { type: "text", value: node?.textContent == "" && node.getAttribute("data-text") ? node.getAttribute("data-text") : node?.textContent, contenttype: contentType };
            break;
        case "text":
        case "button":
            data = { type: "text", value: node.textContent, contenttype: contentType };
            break;
        case "currency":
            data = { type: "currency", value: node.textContent, contenttype: contentType };
            break;
        case "checklist":
            data = { type: "checked", value: node.dataset.ischecked, contenttype: contentType };
            break;
        default:
            data = { type: "text", value: "", contenttype: contentType };
            break;
    }
    return data;
};

DiagramNodeUtils.updateDetaultData = function (cellData, appAssetURL) {
    if (cellData.type == "icon" && (!cellData.dataRef || cellData.dataRef.id == "")) {
        cellData.dataRef = { name: "placeholder" };
        cellData.value = "genericassets/icons/placeholder/placeholder.svg";
    } else if (cellData.type == "image" && cellData.value == "") {
        cellData.value = appAssetURL + "genericassets/placeholderimages/placeholder.png";
    } else if (cellData.type == "logo" && cellData.value == "") {
        cellData.value = appAssetURL + "genericassets/placeholderimages/logoplaceholder_landscape.png";
    } else if (cellData.type == "microchart" && cellData.value == "") {
        cellData.value = "70";
    } else if ((cellData.type == "text" || cellData.type == "number" || cellData.type == "button") && cellData.value == "") {
        cellData.value = "";
    }
};

DiagramNodeUtils.getOffsetRectByParent = function (parent, element) {
    let styleObj = window.getComputedStyle(element);
    if (parent == element) {
        return { x: element.offsetLeft, y: element.offsetTop, top: element.offsetTop, left: element.offsetLeft, width: parseFloat(styleObj.width), height: parseFloat(styleObj.height) };
    }

    let top = element.offsetTop;
    let left = element.offsetLeft;
    let elementParent = element.parentElement;

    while (parent != elementParent) {
        if (!elementParent) break;
        top = top + elementParent.offsetTop;
        left = left + elementParent.offsetLeft;
        elementParent = elementParent.parentElement;
    }

    return { x: left, y: top, top: top, left: left, width: parseFloat(styleObj.width), height: parseFloat(styleObj.height) };
};

DiagramNodeUtils.getElementRectByOffserParent = function (parent, element) {
    var ploffsetLeft = 0,
        ploffsetTop = 0,
        eloffsetLeft = 0,
        eloffsetTop = 0;
    let parentOffset = calcOffset(ploffsetLeft, ploffsetTop, parent);
    let elementOffset = calcOffset(eloffsetLeft, eloffsetTop, element);

    let top = elementOffset.top - parentOffset.top;
    let left = elementOffset.left - parentOffset.left;

    let styleObj = window.getComputedStyle(element);
    return { x: left, y: top, top: top, left: left, width: parseFloat(styleObj.width), height: parseFloat(styleObj.height) };

    function calcOffset(offsetLeft, offsetTop, el) {
        do {
            offsetLeft += el.offsetLeft || 0;
            offsetTop += el.offsetTop || 0;

            el = el.offsetParent;
        } while (el);
        return { left: offsetLeft, top: offsetTop };
    }
};

DiagramNodeUtils.applyClipPath = function (clipId, diagramParent, diagramContentNode) {
    diagramParent.style.setProperty("--clippath", "url(#" + diagramParent.getAttribute("parent-id") + (clipId || "") + "-clip-path)");
    let svgDOM = diagramParent.querySelector("svg[id='" + (clipId || "") + "']");
    if (!diagramContentNode) return;
    let imageNode = diagramContentNode.querySelector("div[data-node-content-type='image']");
    let useNode = diagramContentNode.querySelector("use[data-use-node-name='usecontentbg']");
    if (imageNode && useNode && svgDOM) {
        let clipPathNode = svgDOM.querySelector("clipPath[id='" + diagramParent.getAttribute("parent-id") + (clipId || "") + "-clip-path']");
        let scaleX = parseFloat(imageNode.clientHeight) / parseFloat(svgDOM.getAttribute("viewBox").split(" ")[3]);
        let scaleY = parseFloat(imageNode.clientWidth) / parseFloat(svgDOM.getAttribute("viewBox").split(" ")[2]);
        let scale = Math.min(scaleX, scaleY);
        let translateX = useNode.getBBox().x;
        let translateY = useNode.getBBox().y;
        clipPathNode.style.transform = "translate(" + translateX + "px," + translateY + "px) scale(" + scale + ")";
    }
};

DiagramNodeUtils.applyNodeStyleClipPath = function (clipId, diagramParent, index, contentNode, defsParent) {
    let additionalId = "";
    let diagramContentNode = contentNode || diagramParent.querySelector("[data-id='diagramContentNode'][data-index='" + index + "']");
    diagramParent.style.setProperty("--clippath", "url(#" + additionalId + (clipId || "") + "-clip-path)");
    let svgDefs = defsParent ? defsParent : document.getElementById("svgDefs");
    if (!diagramContentNode || !svgDefs) return;
    let svgDOM = svgDefs.querySelector("svg[id='" + clipId + "']");
    let imageNode = diagramContentNode.querySelector("div[data-node-content-type='image']");
    let contentBG = diagramContentNode.querySelector("[data-id='contetntBGNode']") || diagramContentNode.querySelector("[data-id='outerBgDiv']") || contentNode;
    if (imageNode && contentBG && svgDOM) {
        let useNode = contentBG.querySelector("use");
        let oldid = svgDOM.getAttribute("oldid");
        let clipPathNode = svgDOM.querySelector("clipPath[id='" + (clipId || "") + "-clip-path']");
        let clipPathPlaceholder = svgDOM.querySelector("[clip-path]");
        if (clipPathPlaceholder) clipPathPlaceholder.setAttribute("clip-path", "url(#" + additionalId + (clipId || "") + "-clip-path)");
        if (!clipPathNode) clipPathNode = svgDOM.querySelector("clipPath[id='" + (oldid ? oldid : clipId || "") + "-clip-path']");
        if (!clipPathNode) return;
        clipPathNode.setAttribute("id", additionalId + (clipId || "") + "-clip-path");

        let height = useNode.getBBox().height;
        let width = useNode.getBBox().width;

        let scaleX1 = parseFloat(width) / parseFloat(svgDOM.getAttribute("viewBox").split(" ")[2]);
        let scaleY1 = parseFloat(height) / parseFloat(svgDOM.getAttribute("viewBox").split(" ")[3]);
        let scaleValue = Math.min(scaleX1, scaleY1);
        clipPathNode.style.transform = "scale(" + scaleValue + ")";
        diagramContentNode.style.display = "flex";
        diagramContentNode.style.alignItems = "center";
        diagramContentNode.style.justifyContent = "center";

        if (height && height > 0) {
            imageNode.parentElement.style.height = height + "px";
        }
        if (width && width > 0) {
            imageNode.parentElement.style.width = width + "px";
        }
        let bbox = clipPathPlaceholder?.getBBox();
        if (bbox) {
            let left = bbox.x * scaleValue;
            let top = bbox.y * scaleValue;
            let scaledWidth = bbox.width * scaleValue;
            let scaledHeight = bbox.height * scaleValue;
            imageNode.style.position = "absolute";
            imageNode.style.left = left + "px";
            imageNode.style.top = top + "px";
            if (width && width > 0) imageNode.style.width = scaledWidth + "px";
            if (height && height > 0) imageNode.style.height = scaledHeight + "px";
            imageNode.style.setProperty("clip-path", "unset", "important");
        }
    }
};

DiagramNodeUtils.applySvgClipPath = function (clipId, diagramParent, index, contentNode, svgDOM, additionalId = "") {
    try {
        let diagramContentNode = contentNode || diagramParent.querySelector("[data-id='diagramContentNode'][data-index='" + index + "']");
        diagramParent.style.setProperty("--clippath", "url(#" + additionalId + (clipId || "") + "-clip-path)");
        if (!diagramContentNode) return;
        let imageNode = diagramContentNode.querySelector("div[data-node-content-type='image']");
        let contentBG = diagramContentNode.querySelector("[data-id='contetntBGNode']") || diagramContentNode.querySelector("[data-id='outerBgDiv']") || contentNode;
        if (imageNode && contentBG && svgDOM) {
            let clipPathNode = svgDOM.querySelector("clipPath[id='" + (clipId || "") + "-clip-path']");
            if (!clipPathNode) return;
            clipPathNode.setAttribute("id", additionalId + (clipId || "") + "-clip-path");
            diagramContentNode.style.display = "flex";
            diagramContentNode.style.alignItems = "center";
            diagramContentNode.style.justifyContent = "center";
            clipPathNode.setAttribute("clipPathUnits", "objectBoundingBox");
            clipPathNode.style.transform = "scale(" + 1 / parseFloat(svgDOM.getAttribute("viewBox").split(" ")[2]) + "," + 1 / parseFloat(svgDOM.getAttribute("viewBox").split(" ")[3]) + ")";
        }
    } catch (error) {
        console.log(error);
    }
};

DiagramNodeUtils.isRectInSideRect = function (parent, element) {
    return DiagramNodeUtils.isRectInSideRectHorizontaly(parent, element) && DiagramNodeUtils.isRectInSideRectVerticaly(parent, element);
};

DiagramNodeUtils.isRectInSideRectHorizontaly = function (parent, element) {
    let rect1 = parent.getBoundingClientRect();
    let rect2 = element.getBoundingClientRect();

    let isOrginInside = rect2.x > rect1.x;
    let isFrameInside = rect1.x + rect1.width > rect2.x + rect2.width;

    return isOrginInside && isFrameInside;
};

DiagramNodeUtils.isRectCenterInSideRectHorizontaly = function (parent, element, direction = "next") {
    let rect1 = parent.getBoundingClientRect();
    let rect2 = element.getBoundingClientRect();

    let isRectInside = rect1.x + rect1.width > rect2.x + rect2.width / 2;

    if (direction != "next") isRectInside = rect1.x < rect2.x + rect2.width / 2;

    return isRectInside;
};

DiagramNodeUtils.isRectInSideRectVerticaly = function (parent, element) {
    let rect1 = parent.getBoundingClientRect();
    let rect2 = element.getBoundingClientRect();

    let isOrginInside = rect2.y > rect1.y;
    let isFrameInside = rect1.y + rect1.height > rect2.y + rect2.height;

    return isOrginInside && isFrameInside;
};

DiagramNodeUtils.isRectCenterInSideRectVerticaly = function (parent, element) {
    let rect1 = parent.getBoundingClientRect();
    let rect2 = element.getBoundingClientRect();

    let isFrameInside = rect1.y + rect1.height > rect2.y + rect2.height / 2;

    return isFrameInside;
};

DiagramNodeUtils.hexToRGB = function (hexColor) {
    if (hexColor.includes("rgb")) {
        let arrRBG = hexColor.replace("rgb(", "").replace("rgba(", "").replace(")", "").split(",");
        return arrRBG
            ? {
                  r: arrRBG[0],
                  g: arrRBG[1],
                  b: arrRBG[2],
              }
            : {};
    } else {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexColor);
        return result
            ? {
                  r: parseInt(result[1], 16),
                  g: parseInt(result[2], 16),
                  b: parseInt(result[3], 16),
              }
            : {};
    }
};

DiagramNodeUtils.saveShapeToLocalDefs = function (diagramParent, assetId) {
    try {
        let localsvgDefs = diagramParent.querySelector("[id='svgDefsLocal']");
        let localSvg = localsvgDefs.querySelector("[id='" + assetId + "']");

        let svgDefs = document.getElementById("svgDefs");
        let svg = svgDefs.querySelector("[id='" + assetId + "']");

        localSvg = localSvg ? localSvg : svg.cloneNode(true);
        let localClip = localSvg.querySelector("[id*='" + assetId + "-clip-path']");
        localClip.setAttribute("id", diagramParent.getAttribute("parent-id") + assetId + "-clip-path");

        localsvgDefs.firstElementChild.appendChild(localSvg);
    } catch (erro) {
        console.log("cant find mood asset in svgDefs error:" + erro);
    }
};

DiagramNodeUtils.fitFontSize = function (elText, strText, maxWidth, maxHeight, fontSize, isMultiLine = true, parentDiv) {
    maxWidth = parseInt(maxWidth);
    maxHeight = parseInt(maxHeight);

    let divDummy = document.createElement("div");
    divDummy.id = "dummyTextCalaulation";
    divDummy.style.position = "absolute";
    divDummy.innerText = strText;

    if (!parentDiv) return fontSize;
    parentDiv.appendChild(divDummy);

    if (elText != null) {
        DiagramNodeUtils.applyTextStyleToDiv(elText, divDummy);
    }
    fontSize = DiagramNodeUtils.fitFontSizeInSingleLine(divDummy, maxWidth, fontSize, maxHeight);
    parentDiv.removeChild(divDummy);

    if (elText != null) elText.style.setProperty("font-size", fontSize + "px");
    if (elText.dataset.minfontsize && fontSize < parseFloat(elText.dataset.minfontsize)) {
        fontSize = parseFloat(elText.dataset.minfontsize);
    }

    return fontSize;
};

DiagramNodeUtils.fitFontSizeInSingleLine = function (div, maxWidth, fontSize, maxHeight) {
    div.style.width = "auto";
    div.style.display = "inline-block";
    div.style.fontSize = fontSize + "px";
    div.style.wordWrap = "unset";

    while (div.clientWidth >= maxWidth) {
        fontSize = fontSize - 1;
        div.style.setProperty("font-size", fontSize + "px");
        if (div.clientWidth < maxWidth || fontSize < 6) {
            fontSize = fontSize < 6 ? 6 : fontSize;
            break;
        }
    }

    while (div.clientHeight >= maxHeight) {
        fontSize = fontSize - 1;
        div.style.setProperty("font-size", fontSize + "px");
        if (div.clientHeight <= maxHeight || fontSize < 6) {
            fontSize = fontSize < 6 ? 6 : fontSize;
            break;
        }
    }

    return fontSize;
};

DiagramNodeUtils.applyTextStyleToDiv = function (textElement, div) {
    let textStyle = window.getComputedStyle(textElement, null);
    div.style.fontFamily = textStyle["fontFamily"] != null ? textStyle["fontFamily"] : "";
    div.style.fontSize = textStyle["fontSize"] != null ? textStyle["fontSize"] : "";
    div.style.fontWeight = textStyle["fontWeight"] != null ? textStyle["fontWeight"] : "";
    div.style.color = textStyle["fill"] != null ? textStyle["fill"] : "black";
    div.style.textTransform = textStyle["text-transform"] != null ? textStyle["text-transform"] : "";
    div.style.letterSpacing = textStyle["letter-spacing"] != null ? textStyle["letter-spacing"] : "";
    div.style.fontStretch = textStyle["font-stretch"] != null ? textStyle["font-stretch"] : "";
    div.style.fontStyle = textStyle["font-style"] != null ? textStyle["font-style"] : "";
    div.style.textShadow = textStyle["text-shadow"] != null ? textStyle["text-shadow"] : "";
    if (textElement.dataset != null && textElement.dataset.lineheight != null) {
        div.style.lineHeight = textElement.dataset.lineheight + "em";
    } else div.style.lineHeight = "1.2em";
};

DiagramNodeUtils.setTextAlign = function (node, textAlign, vertiacalAlign = "center") {
    let textParent = node.querySelector("[class*='textParent']");
    textParent.style.justifyContent = vertiacalAlign;
    if (!textParent) return;
    let title = node.querySelector("[class*='primaryTextNode']");
    let subtitle = node.querySelector("[class*='secondaryTextNode']");

    title.style.textAlign = textAlign;

    let contentAlignment = textAlign == "center" ? "center" : "flex-start";
    contentAlignment = textAlign == "right" ? "flex-end" : contentAlignment;
    subtitle.style.justifyContent = contentAlignment;

    subtitle.className = subtitle.className.replace(" right", "").replace(" left", "").replace(" center", "");
    subtitle.className = subtitle.className + " " + textAlign;
};

DiagramNodeUtils.checkNumberFormat = function (target, parent, mooddata, nodeProps, isConvertOperation = false) {
    try {
        if (target && (target.dataset.id == "numberNode" || target.dataset.type == "value")) {
            let disableCurrencyFormat = parent.getAttribute("data-currencyformat") && parent.getAttribute("data-currencyformat") == "disable" ? false : true;
            if (!disableCurrencyFormat) {
                if (target) target.scrollTop = 0;
                return;
            }
            // let str = target.innerText.replace(/[\s\t/,]+/g, "");
            let str = target.textContent.replace(/[\s\t/,]+/g, "");
            let formatcount = parent.getAttribute("data-currencyformatcount");
            if (!formatcount && parent.children.length > 0) {
                // For takeaway sankar commit
                formatcount = parent.children[0].getAttribute("data-currencyformatcount");
            }
            if (formatcount && parseInt(formatcount)) {
                if (str.length <= parseInt(formatcount)) return;
            }
            let gDataFormatter = eval("new " + "DataFormatUtil" + "()");
            // var regex = new RegExp(",", "gi");
            let charcount = parent.getAttribute("data-charactercount");
            if (!charcount && parent.children.length > 0) {
                // For takeaway sankar commit
                charcount = parent.children[0].getAttribute("data-charactercount");
            }
            if (parseInt(charcount)) {
                str = str.substr(0, parseInt(charcount));
            }
            let objFormatted = gDataFormatter.formatCurrency({ input: str });
            // let restrictConversion = nodeProps && nodeProps.name && nodeProps.name.includes("timeline");
            if (objFormatted && objFormatted.validData == false && str != "") {
                target.setAttribute("data-validdata", false);
            }
            //  target.innerText = "";
            else if (str != "") {
                if (disableCurrencyFormat && objFormatted.value) {
                    DiagramNodeUtils.checkPrefixSuffix(target, objFormatted, mooddata, parseInt(charcount), parent.dataset.valueformat, isConvertOperation);
                } else target.innerText = str;
            }
            if (target) target.scrollTop = 0;
        }
    } catch (error) {
        console.log(error);
    }
};

DiagramNodeUtils.getNumberFormat = function (target) {
    let gDataFormatter = eval("new " + "DataFormatUtil" + "()");
    var regex = new RegExp(",", "gi");
    let str = target.textContent.replace(regex, "").replace(/\s/g, "");
    return gDataFormatter.formatCurrency({ input: str });
};

DiagramNodeUtils.checkPrefixSuffix = function (target, objFormatted, mooddata, count, value = "actualnumber", isConvertOperation = false) {
    mooddata = mooddata.basicgraphics || {};
    let prefixSpecial = null;
    if (mooddata.numberprefix) prefixSpecial = mooddata.numberprefix.special;
    let prefix = DiagramCreateUtil.createSpan("spanPrefix", prefixSpecial);
    let prefixStr = objFormatted.prefix + (objFormatted.currencysymbol ? objFormatted.currencysymbol : "");
    if (prefixStr && prefixStr != "") prefixStr = DiagramUtils.removelinebreaks(prefixStr);
    let prefixObj = DiagramNodeUtils.checkCharCount(prefixStr, count);
    prefix.innerText = value == "currency" ? "$" : value != "percentage" ? prefixObj[0] : "";
    count = count - prefixObj[1];
    prefix.className = mooddata && mooddata.numberprefix ? mooddata.numberprefix.style : "clsSpanPrefix";

    let forceConvertActualNumber = isConvertOperation && value == "actualnumber";
    let textMain = DiagramCreateUtil.createSpan("spanMainText");
    textMain.className = "clSpanMainText";
    let valueSystem = objFormatted.valueSystem != null ? (objFormatted.valueSystem % 1 != 0 ? objFormatted.valueSystem.toFixed(1) : objFormatted.valueSystem) : null;
    textMain.innerText = value == "compactdecimal" && valueSystem ? valueSystem : forceConvertActualNumber && objFormatted.currencyValueNormalized ? objFormatted.currencyValueNormalized : objFormatted.value;
    // textMain.innerText = valueSystem ? valueSystem : forceConvertActualNumber && objFormatted.currencyValueNormalized ? objFormatted.currencyValueNormalized : objFormatted.value;
    textMain.innerText = objFormatted?.input?.startsWith("-") && !textMain.textContent.startsWith("-") && !prefix.textContent.startsWith("-") ? "-" + textMain.textContent : textMain.textContent; // Add minus need to optimize it.
    let mainObj = DiagramNodeUtils.checkCharCount(textMain.textContent, count);
    textMain.innerText = value == "percentage" ? (parseFloat(mainObj[0]) > 100 ? 100 : parseFloat(mainObj[0])) : parseFloat(mainObj[0]).toLocaleString("en-US", { currency: "USD" });
    count = count - mainObj[1];

    let actualNumber = value == "actualnumber" && objFormatted.input.toLowerCase().endsWith(objFormatted.currencySystemShort.toLowerCase());
    // let actualNumber = value == "actualnumber";
    let suffixSpecial = null;
    if (mooddata.numbersuffix) suffixSpecial = mooddata.numbersuffix.special;
    let suffix = DiagramCreateUtil.createSpan("spanSuffix", suffixSpecial);
    suffix.className = mooddata && mooddata.numbersuffix ? mooddata.numbersuffix.style : "clsSpanSuffix";
    let isTypedCurrency = objFormatted.input.includes(objFormatted.value + objFormatted.currencySystem);
    let suffixStr = ((actualNumber || value == "compactdecimal") && !forceConvertActualNumber && objFormatted.currencySystemShort ? objFormatted.currencySystemShort : isTypedCurrency && !forceConvertActualNumber ? objFormatted.currencySystem : "") + objFormatted.suffix;
    if (suffixStr && suffixStr != "") suffixStr = DiagramUtils.removelinebreaks(suffixStr);
    let suffixObj = DiagramNodeUtils.checkCharCount(suffixStr, count);
    suffix.innerText = value == "percentage" ? "%" : value != "currency" ? suffixObj[0] : "";

    target.innerHTML = prefix.outerHTML + textMain.outerHTML + suffix.outerHTML;
    return textMain;
};

DiagramNodeUtils.checkCharCount = function (str, count) {
    if (count == null || count == undefined || isNaN(count)) return [str, count];
    if (count > 0 && str.length > 0) {
        str = str.substr(0, count);
        return [str, str.length];
    } else {
        return [str, 0];
    }
};

DiagramNodeUtils.checkAllNumberCurrencyFormat = function (parent, numberNode) {
    if (numberNode) {
        let gDataFormatter = eval("new " + "DataFormatUtil" + "()");
        var regex = new RegExp(",", "gi");
        let arrItem = Array.from(parent.querySelectorAll("[data-id='numberNode']"));
        arrItem.forEach((element) => {
            let str = element.textContent.replace(regex, "").replace(/\s/g, "");
            if (element.scrollHeight > element.parentElement.clientHeight) {
                let objFormatted = gDataFormatter.formatCurrency({ input: str });
                if (objFormatted && objFormatted.valueSystem && objFormatted.currencySystem) {
                    let strConverted = Math.floor(objFormatted.valueSystem) + objFormatted.currencySystem;
                    element.innerText = strConverted;
                }
            }
        });
    }
};

DiagramNodeUtils.createListNodes = function (target, quoteshape = null, count, prompt = null) {
    let li = document.createElement("li");
    target.appendChild(li);
    // let textNode = document.createElement("div");
    // textNode.innerText = "";
    // textNode.contentEditable = "true";
    li.setAttribute("data-focus-parent", target.dataset.focusParent);
    li.setAttribute("data-type", "secondaryText");
    li.setAttribute("data-index", target.dataset.index);
    // textNode.setAttribute("data-list-index", "0");
    li.setAttribute("data-ignore-general-selector", "1");
    li.setAttribute("data-list-index", count);
    // li.setAttribute("data-list-event", "true");

    li.className = "secondaryTextItemNormal";
    li.setAttribute("id", "secondaryTextItem" + target.dataset.index + (target.children.length - 1));
    li.setAttribute("name", "secondaryTextItem");
    li.setAttribute("data-id", "secondaryTextItem");
    li.setAttribute("data-prompt-text", prompt ? prompt : quoteshape ? Constants.Value.secondaryTextAuthorPrompt : Constants.Value.secondaryTextPrompt);
    // nodeParent.appendChild(textNode);
    // li.appendChild(textNode);
    return li;
};

DiagramNodeUtils.checkAllLetter = function (inputtxt) {
    // var letters = /^[A-Za-z]+$/;
    if (inputtxt.match(/[a-z]/i)) {
        return false;
    } else {
        return true;
    }
};

DiagramNodeUtils.isSafari = function () {
    return (
        /constructor/i.test(window.HTMLElement) ||
        (function (p) {
            return p.toString() === "[object SafariRemoteNotification]";
        })(!window["safari"] || (typeof safari !== "undefined" && safari.pushNotification))
    );
};

DiagramNodeUtils.replaceImagePathInSvgString = function (data, value) {
    let arrMatch = data?.match(/href=(["'])(.*?)\1/g);
    if (arrMatch && arrMatch.length > 0) {
        let mainPath = value.substring(0, value.lastIndexOf("/")) + "/";
        arrMatch.reduce((acc, element) => {
            let skipReplace = acc.includes(element) || element?.includes("#");
            if (!skipReplace) {
                let imagePath = element?.replace("href=", "")?.replaceAll('"', "");
                data = data.replaceAll(imagePath, mainPath + imagePath);
            }
            acc.push(element);
            return acc;
        }, []);
    }
    return data;
};

DiagramNodeUtils.replaceImagePathToNonLinearAssets = function (commonSvg, assetPath, centerShape = null, diagramRenderComplete = null) {
    if (commonSvg) {
        let arrImages = commonSvg.querySelectorAll("image");
        arrImages.forEach((element) => {
            if (centerShape?.imageUrl) {
                element.setAttribute("xlink:href", centerShape?.imageUrl);
            } else {
                assetPath = assetPath.substring(0, assetPath.lastIndexOf("/")) + "/";
                let path = element.getAttribute("xlink:href");
                if (path && path != "") {
                    let assetName = path.substring(path.lastIndexOf("/") + 1);
                    element.setAttribute("xlink:href", assetPath + assetName);
                }
            }
        });
    }
};

DiagramNodeUtils.applyColorToNonLinearAssets = function (commonSvg, svgId, arrTintArray) {
    if (!commonSvg) return;
    let gComon = commonSvg.querySelector("g[id*='" + svgId + "-" + "commonpoint" + "']");
    if (gComon) {
        gComon.setAttribute("class", "secondary-fill");

        let arrgComonShape = gComon.querySelectorAll("g[id*='" + svgId + "-" + "shape" + "']");
        for (let j = 0; j < arrgComonShape.length; j++) {
            let gComonShape = arrgComonShape[j];
            DiagramNodeUtils.assignAttributes(gComonShape, {
                class: "moodanimation",
                "data-animation": "commonplaceholder",
            });
            gComonShape.style.pointerEvents = "none";
        }

        let arrgColorShape = gComon.querySelectorAll("g[id*='" + svgId + "-" + "colorshape" + "']");
        for (let j = 0; j < arrgColorShape.length; j++) {
            let gColorShape = arrgColorShape[j];
            DiagramNodeUtils.assignAttributes(gColorShape, {
                class: "moodanimation",
                "data-animation": "colorshape",
            });
        }

        let arrBgCommon = gComon.querySelectorAll("[id*='" + svgId + "-" + "bgcolor" + "']");
        for (let j = 0; j < arrBgCommon.length; j++) {
            arrBgCommon[j].setAttribute("class", "background-fill");
        }

        let arrItemCommon = gComon.querySelectorAll("[id*='" + svgId + "-" + "themecolor" + "']");
        for (let j = 0; j < arrItemCommon.length; j++) {
            let gThemeChild = arrItemCommon[j];
            // let index = gThemeChild.id.charAt(gThemeChild.id.length - 1);
            // gThemeChild.setAttribute("class", "accent" + index + "-fill");
            gThemeChild.setAttribute("class", "clsAccentfill");
        }
    }

    let svgGroupShapes = Array.from(commonSvg.querySelectorAll("g[id*='" + svgId + "-" + "point" + "']"));

    for (let i = 0; i < svgGroupShapes.length; i++) {
        let shapeGroup = svgGroupShapes[i];
        let index = shapeGroup.id.charAt(shapeGroup.id.length - 1);
        shapeGroup.setAttribute("class", " clsMultiColorParent");
        shapeGroup.setAttribute("name", "nodeNonlinearMainParent");
        shapeGroup.setAttribute("data-index", index - 1);
        // shapeGroup.style.setProperty("--customItemColor", "var(--item" + (arrTintArray && arrTintArray.length > 0 ? arrTintArray[i] : index) + "-color-rgb)");
        DiagramUtils.setCustomItemColor(shapeGroup, arrTintArray, index - 1, index);

        let shapeItem = shapeGroup.querySelector("[id*='shape']");
        let bgItem = shapeGroup.querySelector("[id*='bgcolor']");
        if (bgItem) {
            bgItem.removeAttribute("fill");
            bgItem.setAttribute("class", "background-fill");
        }
        if (shapeItem)
            DiagramNodeUtils.assignAttributes(shapeItem, {
                // class: "moodanimation " + "accent" + index + "-fill",
                class: "moodanimation clsAccentfill",
                "data-animation": "itemshape",
                // "data-animation": "shape"
            });
        let connectorItem = shapeGroup.querySelector("[id*='connectorline']");
        if (connectorItem) {
            DiagramNodeUtils.assignAttributes(connectorItem, {
                // class: "moodanimation accent" + index + "-fill",
                // class: "moodanimation clsAccentfill clsAccentStroke",
                class: "moodanimation clsAccentfill",
                "data-animation": "connectors",
            });
        }
    }
    return commonSvg;
};

DiagramNodeUtils.checkNodesList = function (nodeName, arrNodes) {
    for (let i = 0; i < arrNodes.length; i++) {
        let node = DiagramNodeUtils.getNodeFromMenuNodeName(arrNodes[i]);
        if (node == nodeName) return true;
    }
    return false;
};

DiagramNodeUtils.getNodeFromMenuNodeName = function (nodeName) {
    let properNodeName = "none";
    switch (nodeName) {
        case "node":
            properNodeName = "nodeparent";
            break;
        case "group":
            properNodeName = "nodeGroup";
            break;
        case "secContent":
            properNodeName = "secContentNode";
            break;
        case "content":
            properNodeName = "contentNode";
            break;
        case "primary":
            properNodeName = "titleHolder";
            break;
        case "secondary":
            properNodeName = "subTitleHolder";
            break;
        default:
            break;
    }
    return properNodeName;
};

DiagramNodeUtils.circlePathWithAngle = function (cx, cy, r, deg) {
    var theta = (deg * Math.PI) / 180,
        dx = r * Math.cos(theta),
        dy = -r * Math.sin(theta);
    return "M " + cx + " " + cy + "m " + dx + "," + dy + "a " + r + "," + r + " 0 1,0 " + -2 * dx + "," + -2 * dy + "a " + r + "," + r + " 0 1,0 " + 2 * dx + "," + 2 * dy;
};

DiagramNodeUtils.createRoundedPathString = function (pathCoords, radius = 0) {
    const path = [];
    const curveRadius = radius;

    // Reset indexes, so there are no gaps
    pathCoords = pathCoords.slice();

    for (let i = 0; i < pathCoords.length; i++) {
        // 1. Get current coord and the next two (startpoint, cornerpoint, endpoint) to calculate rounded curve
        const c2Index = i + 1 > pathCoords.length - 1 ? (i + 1) % pathCoords.length : i + 1;
        const c3Index = i + 2 > pathCoords.length - 1 ? (i + 2) % pathCoords.length : i + 2;

        const c1 = pathCoords[i];
        const c2 = pathCoords[c2Index];
        const c3 = pathCoords[c3Index];

        // 2. For each 3 coords, enter two new path commands: Line to start of curve, bezier curve around corner.

        // Calculate curvePoint c1 -> c2
        const c1c2Distance = Math.sqrt(Math.pow(c1.x - c2.x, 2) + Math.pow(c1.y - c2.y, 2));
        const c1c2DistanceRatio = (c1c2Distance - curveRadius) / c1c2Distance;
        const c1c2CurvePoint = [((1 - c1c2DistanceRatio) * c1.x + c1c2DistanceRatio * c2.x).toFixed(1), ((1 - c1c2DistanceRatio) * c1.y + c1c2DistanceRatio * c2.y).toFixed(1)];

        // Calculate curvePoint c2 -> c3
        const c2c3Distance = Math.sqrt(Math.pow(c2.x - c3.x, 2) + Math.pow(c2.y - c3.y, 2));
        const c2c3DistanceRatio = curveRadius / c2c3Distance;
        const c2c3CurvePoint = [((1 - c2c3DistanceRatio) * c2.x + c2c3DistanceRatio * c3.x).toFixed(1), ((1 - c2c3DistanceRatio) * c2.y + c2c3DistanceRatio * c3.y).toFixed(1)];

        // If at last coord of polygon, also save that as starting point
        if (i === pathCoords.length - 1) {
            path.unshift("M" + c2c3CurvePoint.join(","));
        }

        // Line to start of curve (L endcoord)
        path.push("L" + c1c2CurvePoint.join(","));
        // Bezier line around curve (Q controlcoord endcoord)
        path.push("Q" + c2.x + "," + c2.y + "," + c2c3CurvePoint.join(","));
    }
    // Logically connect path to starting point again (shouldn't be necessary as path ends there anyway, but seems cleaner)
    path.push("Z");

    return path.join(" ");
};

DiagramNodeUtils.generateDefaultNodeData = function (rowData, content, arrDefaults, name, index = 0) {
    rowData = rowData || {};
    return {
        content: content,
        seccontent: DiagramNodeUtils.getDefaultSecondary(rowData.secondary, arrDefaults, name, index),
        tertiarycontent: rowData.tertiary,
        primarytext: { type: "text", value: "" },
        secondarytext: { items: [], sublist: rowData.rowtype, seccontent: rowData.seclistcontent },
        author: rowData.author || {},
        number: rowData.number || {},
        label: rowData.label || {},
        subtext: rowData.subtext || {},
        button: rowData.button || {},
        emphasize: rowData.emphasize || "",
        crossout: rowData.crossout || "",
        logocontrast: rowData.logocontrast || false,
        ischecked: rowData.ischecked || false,
        position: rowData.position,
        highlightdata: rowData.highlightdata,
        link: rowData.link,
        extralink: rowData.extralink,
        nodeproperties: { ischecked: content.type == "checked" ? content["value"] : rowData?.nodeproperties?.ischecked, ...rowData?.nodeproperties },
        customconnector: rowData.customconnector,
        customconnectortext: rowData.customconnectortext,
    };
};

DiagramNodeUtils.getDefaultSecondary = function (arrSecondaryData = [], arrDefaults, name = "", index = 0) {
    arrSecondaryData = arrSecondaryData || [];
    let secondaryData = arrSecondaryData.length > 0 ? arrSecondaryData[0] : {};
    if (name.includes("sec-ic")) {
        secondaryData = DiagramNodeUtils.getDefaultType(secondaryData, "icon", arrDefaults, index);
        if (secondaryData) arrSecondaryData[0] = secondaryData;
    } else if (name.includes("sec-img")) {
        secondaryData = DiagramNodeUtils.getDefaultType(secondaryData, "image", arrDefaults, index);
        if (secondaryData) arrSecondaryData[0] = secondaryData;
    } else if (name.includes("sec-lg")) {
        secondaryData = DiagramNodeUtils.getDefaultType(secondaryData, name.includes("team") ? "sociallogo" : "logo", arrDefaults, index);
        if (secondaryData) arrSecondaryData[0] = secondaryData;
    } else if (name.includes("sec-val")) {
        secondaryData = DiagramNodeUtils.getDefaultType(secondaryData, "number", arrDefaults, index);
        if (secondaryData) arrSecondaryData[0] = secondaryData;
    }
    if (arrSecondaryData.length == 0 && secondaryData && Object.keys(secondaryData).length > 0) {
        arrSecondaryData.push(secondaryData);
    }
    return arrSecondaryData;
};

DiagramNodeUtils.getDefaultType = function (secondaryData, type = "icon", arrDefaults, index = 0) {
    let overrideIconData = (secondaryData.contenttype && secondaryData.contenttype != type) || Object.keys(secondaryData).length == 0;
    if (overrideIconData && arrDefaults && arrDefaults[type] && arrDefaults[type].length > 0) return arrDefaults[type][index % arrDefaults[type]?.length];
    else return null;
};

DiagramNodeUtils.updateNodeType = function (outlinetype, properties, isScaleNumberAsset = false) {
    switch (outlinetype) {
        case "bulleted":
            properties.contenttype = "none";
            properties.diagramcontent = false;
            break;
        case "bulletlist":
            properties.contenttype = "bulletlist";
            properties.diagramcontent = false;
            break;
        case "checklist":
            properties.contenttype = "checklist";
            properties.diagramcontent = false;
            break;
        case "numbered":
            properties.contenttype = "sequence";
            if (!isScaleNumberAsset) properties.diagramcontent = false;
            break;
        case "icon":
            properties.contenttype = "icon";
            if (!isScaleNumberAsset) properties.diagramcontent = true;
            break;
        case "image":
            properties.contenttype = "image";
            properties.diagramcontent = true;
            break;
        case "logo":
            properties.contenttype = "logo";
            properties.diagramcontent = true;
            break;
        case "valued":
        case "microchart":
            // if (properties.contenttype != "microchart") properties.contenttype = "number";
            properties.contenttype = "number";
            properties.diagramcontent = true;
            break;
        default:
            break;
    }
};

DiagramNodeUtils.hasContentData = function (cellData, properties, outlineData) {
    return cellData.type == "image" ||
        cellData.type == "icon" ||
        properties.contenttype == "number" ||
        (properties.contenttype == "image" && cellData.type == "image") ||
        properties.contenttype == "logo" ||
        outlineData.subtype == "valued" ||
        outlineData.subtype == "microchart" ||
        outlineData.subtype == "text" ||
        properties.contenttype == "valued"
        ? true
        : false;
};

DiagramNodeUtils.updateNodeSizeForClient = function (diagramData, parantNode, nodeGap) {
    if (diagramData.properties.ismultigrid) {
        let rangeData = [
            [2, 2],
            [3, 4],
            [5, 6],
            [7, 9],
            [10, 12],
            [13, 16],
            [17, 20],
            [21, 25],
            [26, 30],
        ];
        let nodeCount = diagramData.nodes.length;
        let nodeHolder = parantNode.querySelector('div[name="nodesHolder"]');
        for (let i = 0; i < rangeData.length; i++) {
            const element = rangeData[i];
            if (nodeCount >= element[0] && element[1] >= nodeCount) {
                let h = element[1] - (element[0] - 1);
                let w = element[1] / h;
                nodeHolder.style.setProperty("--clientlogowidth", "calc(calc(100% - (" + nodeGap + "px * " + (w - 1) + "))/" + w + ")");
                nodeHolder.style.setProperty("--clientlogoheight", "calc(calc(100% - (" + nodeGap + "px * " + (h - 1) + "))/" + h + ")");
                break;
            }
        }
    }
};

DiagramNodeUtils.formatDate = function (date, format) {
    var month = date.getMonth() + 1;
    var day = date.getDate();
    var year = date.getFullYear();

    // Customize the format based on the parameter
    var formattedDate = format
        .replace("MM", (month < 10 ? "0" : "") + month)
        .replace("DD", (day < 10 ? "0" : "") + day)
        .replace("YYYY", year);

    return formattedDate;
};

function OrigamiUtil(slide, isFirstSlide = false) {
    let divParent = document.createElement("div");
    divParent.id = "origamiDiv";
    divParent.className = "origamiParent";
    divParent.style.top = "0px";
    divParent.style.left = "0px";
    divParent.style.width = "100%";
    divParent.style.height = "100%";
    divParent.style.position = "absolute";
    divParent.style.backgroundColor = "#8080808c";
    divParent.style.zIndex = 1;
    slide.appendChild(divParent);

    let origami = new window["Origami"](divParent);
    origami.isPresent = false;
    origami.origamiData = {};
    origami.initOrigamiCreation();

    let jsonData = window.origamiExporter.exportJSONData(true);
    let index = jsonData.slides.findIndex(slideElement => slideElement.id == slide.id)
    index = isFirstSlide ? 0 : index;
    let arrElement = jsonData.slides[index]["slide-elements"];
    origami.origamiData.nodes = arrElement.map((elementData) => slideDataToOrigamiData(elementData));
    origami.origamiData.nodes.pop();
    origami.createrOrigamiFromData();
}

function createDivWithRect(rect, parent) {
    let divParent = document.createElement("div");
    divParent.className = "subNodes";
    divParent.style.top = rect.y + "px";
    divParent.style.left = rect.x + "px";
    divParent.style.width = rect.width + "px";
    divParent.style.height = rect.height + "px";
    divParent.style.position = "absolute";
    divParent.style.backgroundColor = "#8080808c";
    parent.appendChild(divParent);
};

function getStyleObj(element, type) {
    let styleObj = window.getComputedStyle(element);
    switch (type) {
        case "icon":
            return commonIconStyle(styleObj)
        case "text":
        case "primaryText":
        case "secondaryText":
        case "subtextNode":
        case "authorName":
        case "authouDes":
            return { ...commonDivStyles(styleObj), ...commonFontStyle(styleObj) }
        case "image":
            return { ...commonDivStyles(styleObj), ...commonImageStyle(styleObj) }
        case "group":
            return commonDivStyles(styleObj)
        case "button":
            return { ...commonDivStyles(styleObj), ...commonFontStyle(styleObj) }
        default:
            return commonDivStyles(styleObj)
    }
}

function commonDivStyles(styleObj) {
    return {
        "padding": styleObj.padding,
        "opacity": styleObj.opacity,
        "border-top": styleObj.borderTop,
        "box-shadow": styleObj.boxShadow,
        "text-align": styleObj.textAlign,
        "border-left": styleObj.borderLeft,
        "border-right": styleObj.borderRight,
        "border-bottom": styleObj.borderBottom,
        "border-radius": styleObj.borderRadius,
        "background-color": styleObj.backgroundColor
    }
}

function commonFontStyle(styleObj) {
    return {
        "font": styleObj.font,
        "color": styleObj.color,
        "text-align": styleObj.textAlign,
        "text-shadow": styleObj.textShadow,
        "letter-spacing": styleObj.letterSpacing
    }
}

function commonIconStyle(styleObj) {
    return {
        fill: styleObj.fill
    }
}

function commonImageStyle(styleObj) {
    return {

    }
}

function convertNodeToOrigamiData(node, diagramParent) {
    let nodeData = node.getJSONData();
    let nodeParent = node.parentNode.parentElement;
    let nodeGroup = nodeParent.querySelector("[name='nodeGroup']");
    let groupData = getData(nodeGroup, diagramParent, "group");
    groupData.subNodes = [];

    let contentNode = nodeParent.querySelector("[name='contentNode']");
    if (contentNode && isVisible(contentNode)) {
        let contentData = getData(contentNode, nodeGroup, "icon");
        contentData.content = nodeData.content;
        groupData.subNodes.push(contentData);
    }

    let titleNode = nodeParent.querySelector("[name='titleHolder']");
    if (titleNode && isVisible(titleNode)) {
        let titileData = getData(titleNode.firstElementChild, nodeGroup, "text");
        titileData.content = nodeData.primarytext;
        groupData.subNodes.push(titileData);
    }

    let subtitleNode = nodeParent.querySelector("[name='subTitleHolder']");
    if (subtitleNode && isVisible(subtitleNode)) {
        let subtitileData = getData(subtitleNode.firstElementChild, nodeGroup, "text");
        subtitileData.content = nodeData.secondarytext.items[0];
        groupData.subNodes.push(subtitileData);
    }

    let seqTitleHolder = nodeParent.querySelector("[name='seqTitleHolder']");
    if (seqTitleHolder && isVisible(seqTitleHolder)) {
        let seqTitileData = getData(seqTitleHolder, nodeGroup, "text");
        seqTitileData.content = { type: "text", value: seqTitleHolder.firstElementChild.textContent };
        seqTitileData.style.color = window.getComputedStyle(seqTitleHolder.firstElementChild).color
        groupData.subNodes.push(seqTitileData);
    }

    let subTextHolder = nodeParent.querySelector("[name='subTextHolder']");
    if (subTextHolder && isVisible(subTextHolder)) {
        let subTextData = getData(subTextHolder, nodeGroup, "text");
        subTextData.content = { type: "text", value: subTextHolder.firstElementChild.textContent };
        subTextData.style = { ...subTextData.style, ...commonFontStyle(window.getComputedStyle(subTextHolder.firstElementChild)) }
        groupData.subNodes.push(subTextData);
    }

    let imageGridNode = nodeParent.querySelector("[name='imageGridNode']");
    if (imageGridNode && isVisible(imageGridNode)) {
        let logoNod = imageGridNode.querySelector("[data-nodetype='logoNode']");
        let logoData = getData(logoNod, nodeGroup, "image");
        logoData.content = nodeData.seccontent[0].list[0];
        groupData.subNodes.push(logoData);
    }

    let buttonNode = nodeParent.querySelector("[name='buttonNode']");
    if (buttonNode && isVisible(buttonNode)) {
        let buttonNodeData = getData(buttonNode, nodeGroup, "button");
        buttonNodeData.content = nodeData.button;
        buttonNodeData.rect = DiagramNodeUtils.getElementRectByOffserParent(nodeGroup, buttonNode);
        groupData.subNodes.push(buttonNodeData);
    }

    return groupData;
}

function getData(element, parent, type) {
    let data = {}
    data.format = type.includes("group") ? "origamigroup" : "origaminode";
    data.rect = DiagramNodeUtils.getElementRectByOffserParent(parent, element);//DiagramNodeUtils.getOffsetRectByParent(parent, element);
    data.style = getStyleObj(element, type);
    return data;
}

function isVisible(element) {
    return element.clientHeight != 0 || element.clientWidth != 0;
};

function nodeToOrigami(node, diagramparent) {
    let arrSupportNodes = drawFormat();
    let nodeData = node.getJSONData();
    let nodeParent = node.parentNode.parentElement;
    let nodeGroup = nodeParent.querySelector("[name='nodeGroup']");
    let groupData = getData(nodeGroup, diagramparent, "group");
    groupData.subNodes = [];

    arrSupportNodes.map(function (obj) {
        let name = Object.keys(obj)[0];
        let hasData = obj[name].includes("data");
        let elementNode = nodeParent.querySelector("[name='" + name + "']");
        if (elementNode && isVisible(elementNode)) {
            let elementData = getData(elementNode, nodeGroup, hasData ? elementNode.dataset.contentType || elementNode.dataset.type || "" : "");
            if (hasData) elementData.content = getElementData(elementNode, nodeData, elementNode.dataset.contentType || elementNode.dataset.type);
            groupData.subNodes.push(elementData);
        }
    })

    return groupData;
};

function getElementData(element, nodeData, type) {
    switch (type) {
        case "icon":
        case "image":
        case "logo":
            try {
                if (element.parentElement.parentElement.dataset.componentType == "grid") return nodeData.seccontent[0].list[0]
                if (element.id.includes("author")) {
                    if (type == "image") return nodeData.author.image;
                }
            } catch (error) {
                console.log(error)
            }
            return nodeData.content;
        case "primaryText":
            return nodeData.primarytext;
        case "secondaryText":
            return nodeData.secondarytext.items[0];
        case "sequence":
        case "subtextNode":
            return { value: element.textContent, type: "text" };
        case "text":
            if (element.id.includes("button")) {
                return nodeData.button
            }
        case "authorImageHolder":
            return nodeData.author.image
        case "authorName":
            return nodeData.author.name
        case "authouDes":
            return nodeData.author.designation

    }
}

function drawFormat() {
    return [
        { "contentNode": "draw" },
        { "iconHolder": "draw,data" },
        { "titleHolder": "draw" },
        { "primaryText": "draw,data" },
        { "seqTitleHolder": "draw" },
        { "seqText": "draw,data" },
        { "subTitleHolder": "draw" },
        { "secondaryText": "draw" },
        { "secondaryTextItem": "draw,data" },
        { "subTextHolder": "draw" },
        { "subText": "draw,data" },
        { "imageGridNode": "draw" },
        { "imageHolder": "draw,data" },
        { "buttonTitleHolder": "draw" },
        { "buttonNode": "draw,data" },
        { "authorImageHolder": "draw,data" },
        { "authorNameHolder": "draw" },
        { "authorName": "draw,data" },
        { "authorDesHolder": "draw" },
        { "authorDes": "draw,data" }
    ]
};

function slideDataToOrigamiData(data) {
    let nodeData = {};
    nodeData.format = "origaminode";
    nodeData.className = "DiagramOrigamiNode";
    nodeData.rect = cordToRect(data.coords);
    nodeData.style = data.font ? { ...data.style, ...data.font } : data.style;
    nodeData.content = { type: data.type, value: data[data.type] || undefined, svg: data.svg || undefined, path: data.path || undefined }
    if (data.fontClass) nodeData.fontClass = data.fontClass;
    if (data.isLogo) nodeData.content.isLogo = data.isLogo;

    return nodeData;
    function cordToRect(rectStr) {
        let rect = rectStr.split(" ");
        return { x: rect[0], left: rect[0], y: rect[1], top: rect[1], width: rect[2], height: rect[3] }
    }
};

function Intersection() { }

Intersection.intersectEllipseRectangle = function (c, rx, ry, x, y, width, height, offset = 0) {
    x -= offset / 2
    y -= offset / 2
    width += offset
    height += offset

    let r1 = new Point2D(x, y);
    let r2 = new Point2D(x + width, y + height);
    const min = r1.min(r2);
    const max = r1.max(r2);
    const topRight = new Point2D(max.x, min.y);
    const bottomLeft = new Point2D(min.x, max.y);

    const inter1 = Intersection.intersectEllipseLine(c, rx, ry, min, topRight);
    const inter2 = Intersection.intersectEllipseLine(c, rx, ry, topRight, max);
    const inter3 = Intersection.intersectEllipseLine(c, rx, ry, max, bottomLeft);
    const inter4 = Intersection.intersectEllipseLine(c, rx, ry, bottomLeft, min);

    const result = new IntersectionResult("No Intersection");

    result.appendPoints(inter1.points);
    result.appendPoints(inter2.points);
    result.appendPoints(inter3.points);
    result.appendPoints(inter4.points);

    if (result.points.length > 0) {
        result.status = "Intersection";
    }

    return result;
}

Intersection.intersectEllipseLine = function (c, rx, ry, a1, a2) {
    let result;
    const orign = new Vector2D(a1.x, a1.y);
    const dir = Vector2D.fromPoints(a1, a2);
    const center = new Vector2D(c.x, c.y);
    const diff = orign.subtract(center);
    const mDir = new Vector2D(dir.x / (rx * rx), dir.y / (ry * ry));
    const mDiff = new Vector2D(diff.x / (rx * rx), diff.y / (ry * ry));

    const a = dir.dot(mDir);
    const b = dir.dot(mDiff);
    c = diff.dot(mDiff) - 1.0;
    const d = b * b - a * c;

    if (d < 0) {
        result = new IntersectionResult("Outside");
    }
    else if (d > 0) {
        const root = Math.sqrt(d); // eslint-disable-line no-shadow
        const t_a = (-b - root) / a;
        const t_b = (-b + root) / a;

        if ((t_a < 0 || 1 < t_a) && (t_b < 0 || 1 < t_b)) {
            if ((t_a < 0 && t_b < 0) || (t_a > 1 && t_b > 1)) {
                result = new IntersectionResult("Outside");
            }
            else {
                result = new IntersectionResult("Inside");
            }
        }
        else {
            result = new IntersectionResult("Intersection");
            if (0 <= t_a && t_a <= 1) {
                result.appendPoints(a1.lerp(a2, t_a));
            }
            if (0 <= t_b && t_b <= 1) {
                result.appendPoints(a1.lerp(a2, t_b));
            }
        }
    }
    else {
        const t = -b / a;

        if (0 <= t && t <= 1) {
            result = new IntersectionResult("Intersection");
            result.appendPoints(a1.lerp(a2, t));
        }
        else {
            result = new IntersectionResult("Outside");
        }
    }

    return result;
}

Intersection.intersectCircleEllipse = function (cc, r, ec, rx, ry) {
    rx += 0.01;
    return Intersection.intersectEllipseEllipse(cc, r, r, ec, rx, ry);
}

Intersection.intersectEllipseEllipse = function (c1, rx1, ry1, c2, rx2, ry2) {
    const a = [
        ry1 * ry1, 0, rx1 * rx1, -2 * ry1 * ry1 * c1.x, -2 * rx1 * rx1 * c1.y,
        ry1 * ry1 * c1.x * c1.x + rx1 * rx1 * c1.y * c1.y - rx1 * rx1 * ry1 * ry1
    ];
    const b = [
        ry2 * ry2, 0, rx2 * rx2, -2 * ry2 * ry2 * c2.x, -2 * rx2 * rx2 * c2.y,
        ry2 * ry2 * c2.x * c2.x + rx2 * rx2 * c2.y * c2.y - rx2 * rx2 * ry2 * ry2
    ];

    const yPoly = bezout(a, b);
    const yRoots = yPoly.getRoots();
    const epsilon = 1e-3;
    const norm0 = (a[0] * a[0] + 2 * a[1] * a[1] + a[2] * a[2]) * epsilon;
    const norm1 = (b[0] * b[0] + 2 * b[1] * b[1] + b[2] * b[2]) * epsilon;
    const result = new IntersectionResult("No Intersection");

    for (let y = 0; y < yRoots.length; y++) {
        const xPoly = new Polynomial(
            a[0],
            a[3] + yRoots[y] * a[1],
            a[5] + yRoots[y] * (a[4] + yRoots[y] * a[2])
        );
        const xRoots = xPoly.getRoots();

        for (let x = 0; x < xRoots.length; x++) {
            let tst =
                (a[0] * xRoots[x] + a[1] * yRoots[y] + a[3]) * xRoots[x] +
                (a[2] * yRoots[y] + a[4]) * yRoots[y] + a[5];
            if (Math.abs(tst) < norm0) {
                tst =
                    (b[0] * xRoots[x] + b[1] * yRoots[y] + b[3]) * xRoots[x] +
                    (b[2] * yRoots[y] + b[4]) * yRoots[y] + b[5];
                if (Math.abs(tst) < norm1) {
                    result.appendPoints(new Point2D(xRoots[x], yRoots[y]));
                }
            }
        }
    }

    if (result.points.length > 0) {
        result.status = "Intersection";
    }

    return result;
}

function bezout(e1, e2) {
    const AB = e1[0] * e2[1] - e2[0] * e1[1];
    const AC = e1[0] * e2[2] - e2[0] * e1[2];
    const AD = e1[0] * e2[3] - e2[0] * e1[3];
    const AE = e1[0] * e2[4] - e2[0] * e1[4];
    const AF = e1[0] * e2[5] - e2[0] * e1[5];
    const BC = e1[1] * e2[2] - e2[1] * e1[2];
    const BE = e1[1] * e2[4] - e2[1] * e1[4];
    const BF = e1[1] * e2[5] - e2[1] * e1[5];
    const CD = e1[2] * e2[3] - e2[2] * e1[3];
    const DE = e1[3] * e2[4] - e2[3] * e1[4];
    const DF = e1[3] * e2[5] - e2[3] * e1[5];
    const BFpDE = BF + DE;
    const BEmCD = BE - CD;

    return new Polynomial(
        AB * BC - AC * AC,
        AB * BEmCD + AD * BC - 2 * AC * AE,
        AB * BFpDE + AD * BEmCD - AE * AE - 2 * AC * AF,
        AB * DF + AD * BFpDE - 2 * AE * AF,
        AD * DF - AF * AF
    );
}

function sign(x) {
    return typeof x === "number" ? x ? x < 0 ? -1 : 1 : x === x ? x : NaN : NaN;
}

//############## IntersectionResult function
function IntersectionResult(status) {
    this.points = [];
    this.status = status;
}

IntersectionResult.prototype.appendPoints = function (point) {
    this.points.push(point);
};

//############## Point2D function
function Point2D(x, y) {
    this.x = x;
    this.y = y;
}

Point2D.prototype.min = function (that) {
    return new Point2D(
        Math.min(this.x, that.x),
        Math.min(this.y, that.y)
    );
}

Point2D.prototype.max = function (that) {
    return new Point2D(
        Math.max(this.x, that.x),
        Math.max(this.y, that.y)
    );
}

Point2D.prototype.lerp = function (that, t) {
    const omt = 1.0 - t;

    return new Point2D(
        this.x * omt + that.x * t,
        this.y * omt + that.y * t
    );
}

//############## Polymal function
function Vector2D(x = 0, y = 0) {
    this.x = x;
    this.y = y;
}

Vector2D.fromPoints = function (p1, p2) {
    return new Vector2D(
        p2.x - p1.x,
        p2.y - p1.y
    );
}

Vector2D.prototype.subtract = function (that) {
    return new Vector2D(this.x - that.x, this.y - that.y);
}

Vector2D.prototype.dot = function (that) {
    return this.x * that.x + this.y * that.y;
}

//############## Polymal function
function Polynomial(...coefs) {
    this.coefs = [];

    for (let i = coefs.length - 1; i >= 0; i--) {
        this.coefs.push(coefs[i]);
    }

    this._variable = "t";
    this._s = 0;
}

Polynomial.prototype.getRoots = function () {
    let result;

    this.simplifyEquals();

    switch (this.getDegree()) {
        case 0: result = []; break;
        case 1: result = this.getLinearRoot(); break;
        case 2: result = this.getQuadraticRoots(); break;
        case 3: result = this.getCubicRoots(); break;
        case 4: result = this.getQuarticRoots(); break;
        default:
            result = [];
    }

    return result;
}

Polynomial.prototype.simplifyEquals = function (TOLERANCE = 1e-12) {
    for (let i = this.getDegree(); i >= 0; i--) {
        if (Math.abs(this.coefs[i]) <= TOLERANCE) {
            this.coefs.pop();
        }
        else {
            break;
        }
    }
}

Polynomial.prototype.getDegree = function () {
    return this.coefs.length - 1;
}

Polynomial.prototype.getLinearRoot = function () {
    const result = [];
    const a = this.coefs[1];

    if (a !== 0) {
        result.push(-this.coefs[0] / a);
    }

    return result;
}

Polynomial.prototype.getQuadraticRoots = function () {
    const results = [];

    if (this.getDegree() === 2) {
        const a = this.coefs[2];
        const b = this.coefs[1] / a;
        const c = this.coefs[0] / a;
        const d = b * b - 4 * c;

        if (d > 0) {
            const e = Math.sqrt(d);

            results.push(0.5 * (-b + e));
            results.push(0.5 * (-b - e));
        }
        else if (d === 0) {
            // really two roots with same value, but we only return one
            results.push(0.5 * -b);
        }
        // else imaginary results
    }

    return results;
}

Polynomial.prototype.getCubicRoots = function () {
    const results = [];

    if (this.getDegree() === 3) {
        const c3 = this.coefs[3];
        const c2 = this.coefs[2] / c3;
        const c1 = this.coefs[1] / c3;
        const c0 = this.coefs[0] / c3;

        const a = (3 * c1 - c2 * c2) / 3;
        const b = (2 * c2 * c2 * c2 - 9 * c1 * c2 + 27 * c0) / 27;
        const offset = c2 / 3;
        let discrim = b * b / 4 + a * a * a / 27;
        const halfB = b / 2;

        const ZEROepsilon = this.zeroErrorEstimate();

        if (Math.abs(discrim) <= ZEROepsilon) {
            discrim = 0;
        }

        if (discrim > 0) {
            const e = Math.sqrt(discrim);
            let root; // eslint-disable-line no-shadow

            let tmp = -halfB + e;

            if (tmp >= 0) {
                root = Math.pow(tmp, 1 / 3);
            }
            else {
                root = -Math.pow(-tmp, 1 / 3);
            }

            tmp = -halfB - e;

            if (tmp >= 0) {
                root += Math.pow(tmp, 1 / 3);
            }
            else {
                root -= Math.pow(-tmp, 1 / 3);
            }

            results.push(root - offset);
        }
        else if (discrim < 0) {
            const distance = Math.sqrt(-a / 3);
            const angle = Math.atan2(Math.sqrt(-discrim), -halfB) / 3;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const sqrt3 = Math.sqrt(3);

            results.push(2 * distance * cos - offset);
            results.push(-distance * (cos + sqrt3 * sin) - offset);
            results.push(-distance * (cos - sqrt3 * sin) - offset);
        }
        else {
            let tmp;

            if (halfB >= 0) {
                tmp = -Math.pow(halfB, 1 / 3);
            }
            else {
                tmp = Math.pow(-halfB, 1 / 3);
            }

            results.push(2 * tmp - offset);
            // really should return next root twice, but we return only one
            results.push(-tmp - offset);
        }
    }

    return results;
}

Polynomial.prototype.getQuarticRoots = function () {
    let results = [];
    const n = this.getDegree();

    if (n === 4) {
        const poly = new Polynomial();

        poly.coefs = this.coefs.slice();
        poly.divideEqualsScalar(poly.coefs[n]);

        const ERRF = 1e-15;

        if (Math.abs(poly.coefs[0]) < 10 * ERRF * Math.abs(poly.coefs[3])) {
            poly.coefs[0] = 0;
        }

        const poly_d = poly.getDerivative();
        const derrt = poly_d.getRoots().sort((a, b) => a - b);
        const dery = [];
        const nr = derrt.length - 1;
        const rb = this.bounds();

        const maxabsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));
        const ZEROepsilon = this.zeroErrorEstimate(maxabsX);

        for (let i = 0; i <= nr; i++) {
            dery.push(poly.eval(derrt[i]));
        }

        for (let i = 0; i <= nr; i++) {
            if (Math.abs(dery[i]) < ZEROepsilon) {
                dery[i] = 0;
            }
        }

        let i = 0;
        const dx = Math.max(0.1 * (rb.maxX - rb.minX) / n, ERRF);
        const guesses = [];
        const minmax = [];

        if (nr > -1) {
            if (dery[0] !== 0) {
                if (sign(dery[0]) !== sign(poly.eval(derrt[0] - dx) - dery[0])) {
                    guesses.push(derrt[0] - dx);
                    minmax.push([rb.minX, derrt[0]]);
                }
            }
            else {
                results.push(derrt[0], derrt[0]);
                i++;
            }

            for (; i < nr; i++) {
                if (dery[i + 1] === 0) {
                    results.push(derrt[i + 1], derrt[i + 1]);
                    i++;
                }
                else if (sign(dery[i]) !== sign(dery[i + 1])) {
                    guesses.push((derrt[i] + derrt[i + 1]) / 2);
                    minmax.push([derrt[i], derrt[i + 1]]);
                }
            }
            if (dery[nr] !== 0 && sign(dery[nr]) !== sign(poly.eval(derrt[nr] + dx) - dery[nr])) {
                guesses.push(derrt[nr] + dx);
                minmax.push([derrt[nr], rb.maxX]);
            }
        }

        /**
         *  @param {number} x
         *  @returns {number}
         */
        const f = function (x) {
            return poly.eval(x);
        };

        /**
         *  @param {number} x
         *  @returns {number}
         */
        const df = function (x) {
            return poly_d.eval(x);
        };

        if (guesses.length > 0) {
            for (i = 0; i < guesses.length; i++) {
                guesses[i] = Polynomial.newtonSecantBisection(guesses[i], f, df, 32, minmax[i][0], minmax[i][1]);
            }
        }

        results = results.concat(guesses);
    }

    return results;
}

Polynomial.prototype.zeroErrorEstimate = function (maxAbsX) {
    const poly = this;
    const ERRF = 1e-15;

    if (typeof maxAbsX === "undefined") {
        const rb = poly.bounds();

        maxAbsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));
    }

    if (maxAbsX < 0.001) {
        return 2 * Math.abs(poly.eval(ERRF));
    }

    const n = poly.coefs.length - 1;
    const an = poly.coefs[n];

    return 10 * ERRF * poly.coefs.reduce((m, v, i) => {
        const nm = v / an * Math.pow(maxAbsX, i);
        return nm > m ? nm : m;
    }, 0);
}

Polynomial.prototype.divideEqualsScalar = function (scalar) {
    for (let i = 0; i < this.coefs.length; i++) {
        this.coefs[i] /= scalar;
    }
}

Polynomial.prototype.getDerivative = function () {
    const derivative = new Polynomial();

    for (let i = 1; i < this.coefs.length; i++) {
        derivative.coefs.push(i * this.coefs[i]);
    }

    return derivative;
}

Polynomial.prototype.eval = function (x) {
    if (isNaN(x)) {
        throw new TypeError(`Parameter must be a number. Found '${x}'`);
    }

    let result = 0;

    for (let i = this.coefs.length - 1; i >= 0; i--) {
        result = result * x + this.coefs[i];
    }

    return result;
}

Polynomial.prototype.bounds = function () {
    const urb = this.boundsUpperRealFujiwara();
    const rb = { minX: urb.negX, maxX: urb.posX };

    if (urb.negX === 0 && urb.posX === 0) {
        return rb;
    }

    if (urb.negX === 0) {
        rb.minX = this.boundsLowerRealFujiwara().posX;
    }
    else if (urb.posX === 0) {
        rb.maxX = this.boundsLowerRealFujiwara().negX;
    }

    if (rb.minX > rb.maxX) {
        rb.minX = rb.maxX = 0;
    }

    return rb;
}

Polynomial.prototype.boundsUpperRealFujiwara = function () {
    let a = this.coefs;
    const n = a.length - 1;
    const an = a[n];

    if (an !== 1) {
        a = this.coefs.map(v => v / an);
    }

    const b = a.map((v, i) => {
        return (i < n)
            ? Math.pow(Math.abs((i === 0) ? v / 2 : v), 1 / (n - i))
            : v;
    });

    let coefSelectionFunc;
    const find2Max = function (acc, bi, i) {
        if (coefSelectionFunc(i)) {
            if (acc.max < bi) {
                acc.nearmax = acc.max;
                acc.max = bi;
            }
            else if (acc.nearmax < bi) {
                acc.nearmax = bi;
            }
        }
        return acc;
    };

    coefSelectionFunc = function (i) {
        return i < n && a[i] < 0;
    };

    // eslint-disable-next-line unicorn/no-fn-reference-in-iterator
    const max_nearmax_pos = b.reduce(find2Max, { max: 0, nearmax: 0 });

    coefSelectionFunc = function (i) {
        return i < n && ((n % 2 === i % 2) ? a[i] < 0 : a[i] > 0);
    };

    // eslint-disable-next-line unicorn/no-fn-reference-in-iterator
    const max_nearmax_neg = b.reduce(find2Max, { max: 0, nearmax: 0 });

    return {
        negX: -2 * max_nearmax_neg.max,
        posX: 2 * max_nearmax_pos.max
    };
}

Polynomial.prototype.boundsLowerRealFujiwara = function () {
    const poly = new Polynomial();

    poly.coefs = this.coefs.slice().reverse();

    const res = poly.boundsUpperRealFujiwara();

    res.negX = 1 / res.negX;
    res.posX = 1 / res.posX;

    return res;
}

Polynomial.newtonSecantBisection = function (x0, f, df, max_iterations, min, max) {
    let x, prev_dfx = 0, dfx, prev_x_ef_correction = 0, x_correction, x_new;
    let y, y_atmin, y_atmax;

    x = x0;

    const ACCURACY = 14;
    const min_correction_factor = Math.pow(10, -ACCURACY);
    const isBounded = (typeof min === "number" && typeof max === "number");

    if (isBounded) {
        if (min > max) {
            throw new RangeError("Min must be greater than max");
        }

        y_atmin = f(min);
        y_atmax = f(max);

        if (sign(y_atmin) === sign(y_atmax)) {
            throw new RangeError("Y values of bounds must be of opposite sign");
        }
    }

    const isEnoughCorrection = function () {
        // stop if correction is too small or if correction is in simple loop
        return (Math.abs(x_correction) <= min_correction_factor * Math.abs(x)) ||
            (prev_x_ef_correction === (x - x_correction) - x);
    };

    for (let i = 0; i < max_iterations; i++) {
        dfx = df(x);

        if (dfx === 0) {
            if (prev_dfx === 0) {
                // error
                throw new RangeError("df(x) is zero");
            }
            else {
                // use previous derivation value
                dfx = prev_dfx;
            }
            // or move x a little?
            // dfx = df(x != 0 ? x + x * 1e-15 : 1e-15);
        }

        prev_dfx = dfx;
        y = f(x);
        x_correction = y / dfx;
        x_new = x - x_correction;

        if (isEnoughCorrection()) {
            break;
        }

        if (isBounded) {
            if (sign(y) === sign(y_atmax)) {
                max = x;
                y_atmax = y;
            }
            else if (sign(y) === sign(y_atmin)) {
                min = x;
                y_atmin = y;
            }
            else {
                x = x_new;
                break;
            }

            if ((x_new < min) || (x_new > max)) {
                if (sign(y_atmin) === sign(y_atmax)) {
                    break;
                }

                const RATIO_LIMIT = 50;
                const AIMED_BISECT_OFFSET = 0.25; // [0, 0.5)
                const dy = y_atmax - y_atmin;
                const dx = max - min;

                if (dy === 0) {
                    x_correction = x - (min + dx * 0.5);
                }
                else if (Math.abs(dy / Math.min(y_atmin, y_atmax)) > RATIO_LIMIT) {
                    x_correction = x - (min + dx * (0.5 + (Math.abs(y_atmin) < Math.abs(y_atmax) ? -AIMED_BISECT_OFFSET : AIMED_BISECT_OFFSET)));
                }
                else {
                    x_correction = x - (min - y_atmin / dy * dx);
                }
                x_new = x - x_correction;

                if (isEnoughCorrection()) {
                    break;
                }
            }
        }

        prev_x_ef_correction = x - x_new;
        x = x_new;
    }

    return x;
}
/**
 * Author:    Saravanan G
 * Created:   22.04.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function DiagramResizeUtils() {}

DiagramResizeUtils.updateSvgImageBounds = function (imageNode, imageStyle, objItemDimn) {
    let numScale, numScaleX, numScaleY;
    let numX, numY, numWidth, numHeight;
    let numXPer, numYPer, numWidthPer, numHeightPer;

    let dummyImage = imageNode.cloneNode(true);
    dummyImage.style.cssText = "";
    imageNode.parentElement.appendChild(dummyImage);
    let imageWidth = dummyImage.getBBox().width;
    let imageHeight = dummyImage.getBBox().height;
    imageNode.parentElement.removeChild(dummyImage);
    imageNode.setAttribute("data-imagewidth", imageWidth);
    imageNode.setAttribute("data-imageheight", imageHeight);

    if (!imageWidth || imageWidth == 0) imageWidth = Constants.Value.slideWidth;
    if (!imageHeight || imageHeight == 0) imageHeight = Constants.Value.slideHeight;
    if (objItemDimn && !imageStyle) {
        numScaleX = objItemDimn.width / imageWidth;
        numScaleY = objItemDimn.height / imageHeight;
        numScale = Math.max(numScaleX, numScaleY);
        numWidth = imageWidth * numScale;
        numHeight = imageHeight * numScale;
        numX = (objItemDimn.width - numWidth) / 2;
        numY = (objItemDimn.height - numHeight) / 2;
        numXPer = ((numX / objItemDimn.width) * 100).toFixed(2) + "%";
        numYPer = ((numY / objItemDimn.height) * 100).toFixed(2) + "%";
        numWidthPer = ((numWidth / objItemDimn.width) * 100).toFixed(2) + "%";
        numHeightPer = ((numHeight / objItemDimn.height) * 100).toFixed(2) + "%";
        DiagramNodeUtils.assignAttributes(imageNode, { x: numXPer, y: numYPer, width: numWidthPer, height: numHeightPer });
        DiagramNodeUtils.assignAttributes(imageNode, { "data-imagewidth": imageWidth, "data-imageheight": imageHeight });
        imageNode.style.cssText = "position:absolute;width:" + numWidthPer + ";height:100%" + ";left:" + numXPer + ";top:0" + ";x:" + numXPer + ";y:" + numYPer + ";";
    }
    if (imageStyle && imageStyle.cssText) {
        let newWidth = parseInt(imageNode.getAttribute("data-width"));
        let newHeight = parseInt(imageNode.getAttribute("data-height"));
        imageNode.style.cssText = imageStyle.cssText;
        DiagramNodeUtils.assignAttributes(imageNode, { x: imageStyle.getPropertyValue("left"), y: imageStyle.getPropertyValue("top") });
        let leftPos = Number(imageStyle.getPropertyValue("left").split("%")[0]);
        let topPos = Number(imageStyle.getPropertyValue("top").split("%")[0]);
        numScaleX = newWidth / Number(imageNode.getAttribute("data-imagewidth"));
        numScaleY = newHeight / Number(imageNode.getAttribute("data-imageheight"));
        if (imageStyle.width === "auto") {
            numScale = Math.min(numScaleX, numScaleY);
        } else numScale = Math.max(numScaleX, numScaleY);
        numWidth = Number(imageNode.getAttribute("data-imagewidth")) * numScale;
        numHeight = Number(imageNode.getAttribute("data-imageheight")) * numScale;
        numWidthPer = ((numWidth / newWidth) * 100).toFixed(2) + "%";
        numHeightPer = ((numHeight / newHeight) * 100).toFixed(2) + "%";
        let transformscale = imageStyle.getPropertyValue("transform") ? imageStyle.getPropertyValue("transform").split("(")[1].split(")")[0] : 1;

        numX = (newWidth - numWidth) / 2;
        numY = (newHeight - numHeight) / 2;
        let centerX = numX + (numWidth - numWidth * transformscale) / 2;
        let centerY = numY + (numHeight - numHeight * transformscale) / 2;
        let leftCenterPos = (centerX / (numWidth * transformscale)) * 100;
        let topCenterPos = (centerY / (numHeight * transformscale)) * 100;
        leftPos = (leftPos / transformscale + leftCenterPos).toFixed(2) + "%";
        topPos = (topPos / transformscale + topCenterPos).toFixed(2) + "%";
        DiagramNodeUtils.assignAttributes(imageNode, {
            x: leftPos,
            y: topPos,
        });
        if (imageStyle.height === "auto") {
            imageNode.setAttribute("width", "100%");
            imageNode.setAttribute("height", numHeightPer);
        } else if (imageStyle.width === "auto") {
            imageNode.setAttribute("height", "100%");
            imageNode.setAttribute("width", numWidthPer);
        } else {
            if (imageStyle.width == "") imageNode.setAttribute("width", imageNode.getAttribute("data-imagewidth"));
            else imageNode.setAttribute("width", numWidthPer);
            if (imageStyle.height == "") imageNode.setAttribute("height", imageNode.getAttribute("data-imageheight"));
            else imageNode.setAttribute("height", numHeightPer);
        }
    }
};

DiagramResizeUtils.calculateEmptySpace = function (diagramParent, maxColumns = 2) {
    let maxHeight = diagramParent.parentElement.clientHeight;
    let nodesHolder = diagramParent.querySelector("[name='nodesHolder']");
    let totalHeight = 0;
    let currentColumn = 1;
    let arrThirdColumn = [];
    let arrSecondColumn = [];
    let arrFirstColumn = [];
    let padding = parseInt(getComputedStyle(nodesHolder).gap);

    let allNodes = Array.from(diagramParent.querySelectorAll("[name='nodeMainParent']"));
    if (allNodes && allNodes.length > 0) {
        let nodeItemFirst = allNodes[0];
        let leftfirst = nodeItemFirst.getBoundingClientRect().left;
        allNodes.forEach((element, index) => {
            let leftCurrent = element.getBoundingClientRect().left;
            if (leftfirst != leftCurrent) {
                if (currentColumn == 1) {
                    currentColumn = 2;
                } else if (currentColumn == 2) {
                    currentColumn = 3;
                }
                leftfirst = leftCurrent;
            }
            if (currentColumn == 1) arrFirstColumn.push(element);
            if (currentColumn == 2) arrSecondColumn.push(element);
            if (currentColumn == 3) arrThirdColumn.push(element);
        });
        let firstEmptySpace = 0;
        let secondEmptySpace = 0;
        arrFirstColumn.forEach((element) => {
            totalHeight += element.clientHeight;
        });
        totalHeight += (arrFirstColumn.length - 1) * padding;
        firstEmptySpace = maxHeight - totalHeight;
        if (arrSecondColumn.length > 0) {
            totalHeight += firstEmptySpace;
            let totalSecondaryHeight = 0;
            arrSecondColumn.forEach((element) => {
                totalSecondaryHeight += element.clientHeight;
            });
            totalSecondaryHeight += (arrSecondColumn.length - 1) * padding;
            secondEmptySpace = maxHeight - totalSecondaryHeight;
            totalHeight += totalSecondaryHeight;
        }
        if (arrThirdColumn.length > 0) {
            totalHeight += secondEmptySpace;
            arrThirdColumn.forEach((element) => {
                totalHeight += element.clientHeight;
            });
            totalHeight += (arrThirdColumn.length - 1) * padding;
        }
    }
    let emptySpace = maxHeight * maxColumns - totalHeight;
    // console.log("remaningSpace", emptySpace);
    return emptySpace;
};

DiagramResizeUtils.drawNineScale = function (name, nodeItemParent, count = 1) {
    // let name = nodeData.bgsvg.id;
    let diagramParent = nodeItemParent.parentElement;
    let bgsvgNode = nodeItemParent.querySelector("[data-id='bgsvgparent']");
    let ninescalsSvgNode = bgsvgNode.firstElementChild;
    let viewBox = ninescalsSvgNode.getAttribute("viewboxdefault") || ninescalsSvgNode.getAttribute("viewBoxDefault");
    if (!viewBox) viewBox = ninescalsSvgNode.getAttribute("viewbox");
    let arrViewBox = viewBox.split(" ");

    let layoutgap = 0;
    // let bgX = 0;
    let seperatorgap = 0;
    // let bgNodeAreaHeight = diagramParent.clientHeight / count - seperatorgap;
    let bgNodeAreaHeight = nodeItemParent.clientHeight;
    // let bgY =bgNodeAreaHeight + layoutgap * 0.5;
    let bgWidth = diagramParent.clientWidth;
    let bgHeight = bgNodeAreaHeight - layoutgap;
    // let bgXPer = ((bgX / diagramParent.clientWidth) * 100).toFixed(2) + "%";
    // let bgYPer = ((bgY / diagramParent.clientHeight) * 100).toFixed(2) + "%";
    let bgWidthPer = ((bgWidth / diagramParent.clientWidth) * 100).toFixed(2) + "%";
    let bgHeightPer = ((diagramParent.clientHeight / diagramParent.clientHeight) * 100).toFixed(2) + "%";
    let scale = 1;
    let numWidth = bgWidth;
    let numHeight = bgHeight;
    let numWidthPer = bgWidthPer;
    let numHeightPer = bgHeightPer;

    let numProportionateScaleX = numWidth / arrViewBox[2];
    let numProportionateScaleY = numHeight / arrViewBox[3];
    let numContainerProportionateScaleX = 100 / (numProportionateScaleX * 100);
    let numContainerProportionateScaleY = 100 / (numProportionateScaleY * 100);
    let numProportionateScale = numProportionateScaleY;

    if (ninescalsSvgNode.getElementById(name + "-left")) {
        numContainerProportionateScaleX = numContainerProportionateScaleY;
        scale = numProportionateScale;
    } else if (ninescalsSvgNode.getElementById(name + "-top")) {
        numProportionateScale = numProportionateScaleX;
        numContainerProportionateScaleY = numContainerProportionateScaleX;
        scale = numProportionateScale;
    }
    bgsvgNode.setAttribute("data-scale", scale);
    bgsvgNode.style.transform = "scale(" + scale + "," + scale + ")";
    bgsvgNode.style.transformOrigin = "0px 0px";
    bgsvgNode.dataset.customstartscalex = scale;
    bgsvgNode.dataset.customstartscaley = scale;
    bgsvgNode.dataset.customendscalex = scale;
    bgsvgNode.dataset.customendscaley = scale;
    bgsvgNode.dataset.customsmovex = 0;
    bgsvgNode.dataset.customsmovey = 0;
    bgsvgNode.dataset.customsmoveendx = 0;
    bgsvgNode.dataset.customsmoveendy = 0;
    bgsvgNode.dataset.customorgin = "0px 0px";
    DiagramNodeUtils.assignAttributes(bgsvgNode.firstElementChild, {
        width: numContainerProportionateScaleY * parseFloat(numWidthPer) + "%",
        height: numContainerProportionateScaleX * parseFloat(numHeightPer) + "%",
        // height: numContainerProportionateScaleY * parseFloat(numWidthPer) + "%",
    });
    bgsvgNode.firstElementChild.style.width = numContainerProportionateScaleY * parseFloat(numWidthPer) + "%";
    bgsvgNode.firstElementChild.style.height = numContainerProportionateScaleX * parseFloat(numHeightPer) + "%";
    // bgsvgNode.firstElementChild.style.height = numContainerProportionateScaleY * parseFloat(numWidthPer) + "%";
    DiagramResizeUtils.updateSize(ninescalsSvgNode, numWidth * numContainerProportionateScaleY, numHeight * numContainerProportionateScaleX, name);
    // DiagramResizeUtils.updateSize(ninescalsSvgNode, numWidth * numContainerProportionateScaleY, numWidth * numContainerProportionateScaleY, name);
};

DiagramResizeUtils.findScale = function (bgWidth, bgHeight, svgNode) {
    let viewBox = svgNode.getAttribute("viewboxdefault") || svgNode.getAttribute("viewBoxDefault");
    if (!viewBox) viewBox = svgNode.getAttribute("viewbox") || svgNode.getAttribute("viewBox");
    let arrViewBox = viewBox.split(" ");
    let numWidth = bgWidth;
    let numHeight = bgHeight;
    let numProportionateScaleX = numWidth / arrViewBox[2];
    let numProportionateScaleY = numHeight / arrViewBox[3];
    return Math.max(numProportionateScaleX, numProportionateScaleY);
};

DiagramResizeUtils.updateSize = function (svgAsset, width, height, name) {
    let tlw, trw, blh, tlh, cw, ch, lw, rw, th, bh;
    if (svgAsset.getElementById(name + "-topleft") != null && svgAsset.getElementById(name + "-topleft").parentElement.children.length == 9) {
        tlw = DiagramResizeUtils.getViewBoxValue(svgAsset.getElementById(name + "-topleft"), 2);
        trw = DiagramResizeUtils.getViewBoxValue(svgAsset.getElementById(name + "-topright"), 2);
        blh = DiagramResizeUtils.getViewBoxValue(svgAsset.getElementById(name + "-bottomleft"), 3);
        tlh = DiagramResizeUtils.getViewBoxValue(svgAsset.getElementById(name + "-topleft"), 3);
        cw = width - (tlw + trw);
        ch = height - (blh + tlh);
        let x = cw + tlw;
        let y = ch + tlh;
        cw = cw + 2;
        ch = ch + 2;
        svgAsset.getElementById(name + "-centerUse").setAttribute("height", ch + "px");
        svgAsset.getElementById(name + "-centerUse").setAttribute("width", cw + "px");
        svgAsset.getElementById(name + "-topUse").setAttribute("width", cw + "px");
        svgAsset.getElementById(name + "-bottomUse").setAttribute("width", cw + "px");
        svgAsset.getElementById(name + "-bottomUse").setAttribute("y", y + "px");
        svgAsset.getElementById(name + "-bottomRightUse").setAttribute("x", x + "px");
        svgAsset.getElementById(name + "-leftUse").setAttribute("height", ch + "px");
        svgAsset.getElementById(name + "-rightUse").setAttribute("height", ch + "px");
        svgAsset.getElementById(name + "-rightUse").setAttribute("x", x + "px");
    } else {
        lw = DiagramResizeUtils.getViewBoxValue(svgAsset.getElementById(name + "-left"), 2);
        rw = DiagramResizeUtils.getViewBoxValue(svgAsset.getElementById(name + "-right"), 2);
        th = DiagramResizeUtils.getViewBoxValue(svgAsset.getElementById(name + "-top"), 3);
        bh = DiagramResizeUtils.getViewBoxValue(svgAsset.getElementById(name + "-bottom"), 3);
        cw = width - (lw + rw);
        cw = cw < 0 ? 1 : cw;
        let id = name + "-centerUse";
        let intpad = 2;
        if (cw != NaN && rw != 0) {
            cw += intpad;
            let originalX = svgAsset.getElementById(id).getAttribute("x");
            let dataX = svgAsset.getElementById(id).getAttribute("data-x");
            if (dataX == null) svgAsset.getElementById(id).setAttribute("data-x", originalX);
            else originalX = dataX;
            let x = Number(originalX) - intpad / 2;
            svgAsset.getElementById(id).setAttribute("x", x);
            svgAsset.getElementById(id).setAttribute("width", cw + "px");
        }
        ch = height - (th + bh);
        ch = ch < 0 ? 1 : ch;
        //ch = ch + 5;
        if (ch != NaN && bh != 0) {
            ch += intpad;
            let originalY = svgAsset.getElementById(id).getAttribute("y");
            let dataY = svgAsset.getElementById(id).getAttribute("data-y");
            if (dataY == null) svgAsset.getElementById(id).setAttribute("data-y", originalY);
            else originalY = dataY;
            let y = Number(originalY) - intpad / 2;
            svgAsset.getElementById(id).setAttribute("y", y);
            svgAsset.getElementById(id).setAttribute("height", ch + "px");
        }
    }
};

DiagramResizeUtils.scaleToFit = function (finalWidth, finalHeight, width, height, deviceHolder, scaleToFitWidth = false, slideScale) {
    let scaleX = finalWidth > width ? finalWidth / width : width / finalWidth;
    let scaleY = finalHeight > height ? finalHeight / height : height / finalHeight;
    if (finalHeight < height) {
        scaleY = scaleY > 1 ? 1 / scaleY : scaleY;
    }
    let scaledWidth = deviceHolder.getAttribute("original-width") * scaleY;
    if (scaleToFitWidth) {
        if (finalWidth < width) {
            scaleX = scaleX > 1 ? 1 / scaleX : scaleX;
        }
        let scale = Math.min(scaleX, scaleY);

        deviceHolder.style.transform = "scale(" + scale + ")";
        deviceHolder.parentElement.style.width = deviceHolder.getAttribute("original-width") * scale + "px";
        return scale;
    } else {
        deviceHolder.style.transform = "scale(" + scaleY + ")";
        // deviceHolder.parentElement.style.width = (scaledWidth < width ? width : scaledWidth) + "px";
        deviceHolder.parentElement.style.width = scaledWidth + "px";
        // deviceHolder.parentElement.style.width = deviceHolder.getBoundingClientRect().width / slideScale + "px";
        // deviceHolder.parentElement.style.width = width + "px";
        // deviceHolder.parentElement.style.width = "auto";
        return scaleY;
    }
};

DiagramResizeUtils.calcImageBounds = function (imageHolder, outerDiv, clipId) {
    let clipPathGroupNode = outerDiv.querySelector("g[clip-path*='" + (clipId || "") + "-clip-path)']");
    let bbox = clipPathGroupNode ? clipPathGroupNode.getBBox() : null;
    if (bbox) {
        imageHolder.style.position = "absolute";
        imageHolder.style.width = bbox.width + "px";
        imageHolder.style.height = bbox.height + "px";
        imageHolder.style.left = bbox.x + "px";
        imageHolder.style.top = bbox.y + "px";
        imageHolder.style.setProperty("clip-path", "unset", "important");
    }
};

DiagramResizeUtils.getViewBoxValue = function (element, index) {
    return element != null ? parseFloat(element.getAttribute("viewBox").split(/\s+|,/)[index]) : 0;
};

DiagramResizeUtils.getViewBoxDefaultValue = function (element, index) {
    return element != null ? parseFloat(element.getAttribute("viewBoxDefault").split(/\s+|,/)[index]) : 400;
};

DiagramResizeUtils.getViewBoxRect = function (svg) {
    let viewBoxValues = [];
    viewBoxValues = svg.getAttribute("viewBox").split(/\s+|,/);
    if ((viewBoxValues.length = 4)) {
        return { x: parseFloat(viewBoxValues[0]), y: parseFloat(viewBoxValues[1]), width: parseFloat(viewBoxValues[2]), height: parseFloat(viewBoxValues[3]) };
    }
    let svgRect = svg.getBBox();
    return { x: svgRect.x, y: svgRect.y, width: svgRect.width, height: svgRect.height };
};

DiagramResizeUtils.resizeMultiFont = function (parent, name = "primaryText") {
    let fontBase = "";
    let fontNumber = 0;
    let originalNumber = 0;
    let originalFontClass = "";
    let newFontClass = "";
    let arrPrimaryNodes = parent.querySelectorAll("[name='" + name + "']");
    arrPrimaryNodes.forEach((primaryNode) => {
        // let primaryNode = node.parentNode.querySelector("[name='" + name + "']");
        if (!primaryNode) return;
        fontBase = primaryNode.getAttribute("original-fontbase");
        originalNumber = primaryNode.getAttribute("original-fontnumber");
        originalFontClass = primaryNode.getAttribute("original-fontclass");
        if (arrPrimaryNodes.length > 4) {
            originalNumber = parseInt(originalNumber) + 1;
        }
        newFontClass = primaryNode.getAttribute("new-fontclass");
        if (newFontClass) {
            let number = newFontClass.split("")[1];
            if (number) {
                fontNumber = Math.max(number, fontNumber);
            }
        }
    });

    let finalFontNumber = Math.max(originalNumber, fontNumber);

    arrPrimaryNodes.forEach((primaryNode) => {
        if (!primaryNode) return;
        TextHighLightUtils.removeFontClassName(primaryNode, this.fontClassList);
        primaryNode.classList.add(fontBase + finalFontNumber);
    });
};

DiagramResizeUtils.updateLogoRatio = function (logoNode) {
    let logoParent = logoNode.parentElement;
    if (logoParent && logoParent.dataset.nodeContentType == "logo") {
        let _w = logoNode.dataset.nwidth;
        let _h = logoNode.dataset.nheight;
        let ratio = _h / _w;
        let logoPan = "clsLogoPanProtrait";
        if (ratio >= 1.1) {
            logoPan = "clsLogoPanProtrait";
        } else if (ratio >= 0.9 && ratio < 1.1) {
            logoPan = "clsLogoPanSquare";
        } else if (ratio >= 0.25 && ratio < 0.9) {
            logoPan = "clsLogoPanWide";
        } else if (ratio <= 0.25) {
            logoPan = "clsLogoPanExtraWide";
        }
        logoParent.setAttribute("data-logo-ratio", ratio);
        logoParent.setAttribute("data-logo-pan", logoPan);
        logoParent.parentElement.setAttribute("data-logo-pan", logoPan + "Parent");
        logoParent.setAttribute("data-parent-width", logoParent.parentElement.offsetWidth);
        logoParent.setAttribute("data-parent-height", logoParent.parentElement.offsetHeight);
        logoParent.style.setProperty("--logoParentWidth", logoParent.parentElement.offsetWidth);
        logoParent.style.setProperty("--logoParentHeight", logoParent.parentElement.offsetHeight);
    }
};

DiagramResizeUtils.updateDefaultImageData = function (imageLogoNode, type, callBack, isFromLogoGrid = false) {
    let isCommonNode = imageLogoNode.parentElement?.parentElement && imageLogoNode.parentElement.parentElement.id.includes("centerHolderParent");
    imageLogoNode.addEventListener(
        "load",
        function (e) {
            imageLogoNode.removeEventListener("load", this);
            imageLogoNode.removeEventListener("error", this);
            let targetNode = e.target;
            targetNode.setAttribute("data-nwidth", e.target.naturalWidth);
            targetNode.setAttribute("data-nheight", e.target.naturalHeight);
            targetNode.setAttribute("data-imageloaded", true);
            let isImageGrid = targetNode.parentNode.getAttribute("data-component-type") && targetNode.parentNode.getAttribute("data-component-type") == "grid";
            let holderTypePrimary = targetNode.parentNode.getAttribute("data-holder-type") && targetNode.parentNode.getAttribute("data-holder-type") == "primary";
            if (!isImageGrid && holderTypePrimary && !isCommonNode) DiagramResizeUtils.updateLogoRatio(targetNode);
            CommonImageUtils.updateImageBounds(targetNode, { islogofit: type == "logo", contenttype: type });
            if (callBack) {
                if (isFromLogoGrid) callBack(targetNode);
                else if (callBack && callBack.func) {
                    callBack.func(callBack.params, targetNode.id);
                } else {
                    callBack(targetNode);
                }
            }
        },
        { once: true }
    );
    let isError = false;
    imageLogoNode.addEventListener("error", function (e) {
        console.log("error", e);
        imageLogoNode.removeEventListener("error", this);
        imageLogoNode.removeEventListener("load", this);
        if (!isError) {
            isError = true;
            imageLogoNode.src = appStaticURL + Constants.Value.placeholder_imagepath;
            let targetNode = e.target;
            if (callBack) {
                if (isFromLogoGrid) callBack(targetNode);
                else if (callBack && callBack.func) {
                    callBack.func(callBack.params, targetNode.id);
                } else {
                    callBack(targetNode);
                }
            }
        }
    });
    imageLogoNode.src = imageLogoNode.getAttribute("data-src");
};

DiagramResizeUtils.calculateRowColumnBounds = function (parent) {
    let x = parent.offsetTop;
    let y = parent.offsetLeft;
    if (window.noderow && !window.noderow.includes(x)) window.noderow.push(x);
    if (window.nodecolumn && !window.nodecolumn.includes(y)) {
        if (window.nodecolumn[window.nodecolumn.length - 1] && window.nodecolumn[window.nodecolumn.length - 1] > y) window.nodecolumn.splice(window.nodecolumn.length - 1, 0, y);
        else window.nodecolumn.push(y);
    }
    parent.setAttribute("data-rowOffset", x);
    parent.setAttribute("data-columnOffset", y);
};

DiagramResizeUtils.resetRowColumnBounds = function (arrDiagramNode) {
    window.noderow = [];
    window.nodecolumn = [];
    arrDiagramNode.forEach((element) => {
        DiagramResizeUtils.calculateRowColumnBounds(element.parentNode.parentElement);
    });
};

DiagramResizeUtils.setRowColumnBounds = function (parent) {
    if (window.noderow && window.nodecolumn && (window.noderow.length > 0 || window.nodecolumn.length > 0)) {
        let x = parent.getAttribute("data-rowOffset") || parent.offsetTop;
        let y = parent.getAttribute("data-columnOffset") || parent.offsetLeft;
        if (window.noderow.length == 1) parent.setAttribute("data-singlerow", true);
        else parent.removeAttribute("data-singlerow");
        parent.setAttribute("data-rowtype", window.noderow[0] == x ? "start" : window.noderow[window.noderow.length - 1] == x ? "end" : "middle");
        parent.setAttribute("data-columntype", window.nodecolumn[0] == y ? "start" : window.nodecolumn[window.nodecolumn.length - 1] == y ? "end" : "middle");
    }
};

DiagramResizeUtils.setArrRowColumnBounds = function (arrDiagramNode) {
    arrDiagramNode.forEach((element) => {
        DiagramResizeUtils.setRowColumnBounds(element.parentNode.parentElement);
    });
};

DiagramResizeUtils.calcArrRowColumnBounds = function (arrDiagramNode) {
    arrDiagramNode.forEach((element) => {
        DiagramResizeUtils.calculateRowColumnBounds(element.parentNode.parentElement);
    });
};

DiagramResizeUtils.commonFontResize = function (totalTextHeight, textParentHeight, availableHeight, textNode, textparentNode, fontData = [], applyFontToDivWhenULAvailable = false) {
    if (!fontData || fontData.length == 0) {
        console.log("fontListData is empty... please pass [h1,h2,h3...p1,p2,p3...]");
        return;
    }
    let returnFont = textNode?.getAttribute("original-fontclass") || "";
    if (!textNode || textNode?.offsetHeight == 0 || textNode?.offsetWidth == 0 || textNode?.hasAttribute("user-font-size")) return returnFont;
    let hSeries = fontData.filter((obj) => obj.includes("h"));
    let pSeries = fontData.filter((obj) => obj.includes("p"));

    let ulNode = textNode.getElementsByTagName("ul").length > 0 ? textNode.getElementsByTagName("ul")[0] : null;
    let currentTextFont = DiagramResizeUtils.getClassNameFromNode(ulNode ? ulNode : textNode, fontData);
    if (!currentTextFont && ulNode) {
        currentTextFont = DiagramResizeUtils.getClassNameFromNode(textNode, fontData);
        ulNode.classList.add(currentTextFont);
    }
    // For SG - have to remove class from div and add ul classname here
    if (applyFontToDivWhenULAvailable && ulNode) {
        DiagramResizeUtils.removeFontClassNameFromNode(textNode, fontData);
        textNode.classList.add(currentTextFont);
    }
    returnFont = currentTextFont;
    if (!currentTextFont) return;
    let seriesLength = currentTextFont.includes("h") ? hSeries.length : pSeries.length;
    let remainingHeight = availableHeight ? availableHeight : textParentHeight - totalTextHeight;
    remainingHeight = remainingHeight < 0 ? null : remainingHeight;

    let oldH = textparentNode.style.height;
    let oldMH = textparentNode.style.maxHeight;
    // let oldH = remainingHeight == textparentNode.clientHeight ? remainingHeight + "px" : textparentNode.style.height;
    // let oldMH = remainingHeight == textparentNode.clientHeight ? remainingHeight + "px" : textparentNode.style.maxHeight;
    let oldDisplay = textparentNode.style.display;
    textparentNode.style.maxHeight = remainingHeight ? remainingHeight + "px" : "100%";
    textparentNode.style.height = remainingHeight ? remainingHeight + "px" : "100%";
    textNode.style.maxHeight = "100%";
    textNode.style.height = "auto";
    textparentNode.style.display = "block";
    let sh = ulNode ? ulNode.scrollHeight : textNode.scrollHeight;
    let isMaxContent = applyFontToDivWhenULAvailable ? totalTextHeight > textParentHeight : sh > textNode.parentElement.offsetHeight;

    if (isMaxContent || textNode.scrollWidth > textNode.offsetWidth) {
        //New logic to reduce font
        let currentFont = DiagramResizeUtils.getClassNameFromNode(ulNode ? ulNode : textNode, fontData);
        let currentFontSize = parseInt(currentFont.replace(/[^0-9]/g, ""));
        textNode.classList.remove(currentFont);
        if (ulNode) ulNode.classList.remove(currentFont);
        let newFont = currentFont.replace(currentFontSize, "") + (currentFontSize < seriesLength ? currentFontSize + 1 : currentFontSize);
        // console.log("SG - REDUCE 1  - " + currentFont + " - " + newFont);
        if (ulNode) {
            ulNode.classList.add(newFont);
            if (applyFontToDivWhenULAvailable) textNode.classList.add(newFont);
        } else textNode.classList.add(newFont);
        returnFont = newFont;
        let scrollHeightVal = ulNode ? ulNode.scrollHeight : textNode.scrollHeight;
        if (textparentNode.offsetHeight < scrollHeightVal || textNode.scrollWidth > textNode.offsetWidth) {
            for (let a = 0; a < seriesLength; a++) {
                // console.log("SG - REDUCE Loop " + a);
                if (textparentNode.offsetHeight < scrollHeightVal || textNode.scrollWidth > textNode.offsetWidth) {
                    currentFont = DiagramResizeUtils.getClassNameFromNode(ulNode ? ulNode : textNode, fontData);
                    currentFontSize = parseInt(currentFont.replace(/[^0-9]/g, ""));
                    let newFontCreated = currentFont.replace(currentFontSize, "") + (currentFontSize < seriesLength ? currentFontSize + 1 : currentFontSize);
                    if (newFontCreated == currentFont) a = 100;
                    textNode.classList.remove(newFont);
                    if (ulNode) ulNode.classList.remove(newFont);
                    newFont = newFontCreated;
                    // console.log("SG - REDUCE 2 - " + currentFont + " - " + newFont);
                    if (ulNode) {
                        ulNode.classList.add(newFont);
                        if (applyFontToDivWhenULAvailable) textNode.classList.add(newFont);
                    } else textNode.classList.add(newFont);
                    returnFont = newFont;

                    scrollHeightVal = ulNode ? ulNode.scrollHeight : textNode.scrollHeight;
                    // console.log("SG -  After update DECREASE -  " + scrollHeightVal + " - " + textparentNode.offsetHeight);
                    if (scrollHeightVal < textparentNode.offsetHeight && textNode.scrollWidth <= textNode.offsetWidth) a = 100;
                } else a = 100;
            }
        }
    } else {
        let scrollHeightVal = ulNode ? ulNode.scrollHeight : textNode.scrollHeight;
        // console.log(scrollHeightVal + " - " + textparentNode.offsetHeight);
        if (textparentNode.offsetHeight > scrollHeightVal) {
            let currentFont = DiagramResizeUtils.getClassNameFromNode(ulNode ? ulNode : textNode, fontData);
            let currentFontSize = parseInt(currentFont.replace(/[^0-9]/g, ""));
            textNode.classList.remove(currentFont);
            if (ulNode) ulNode.classList.remove(currentFont);
            let originalFont = textNode.getAttribute("data-font") || textNode.getAttribute("original-fontclass");
            let maxFont = parseInt(originalFont?.replace(/[^0-9]/g, ""));
            let newFont = currentFont.replace(currentFontSize, "") + (currentFontSize > maxFont ? currentFontSize - 1 : currentFontSize);
            // console.log("SG - INCREASE 1 - " + currentFont + " - " + newFont);
            if (ulNode) {
                ulNode.classList.add(newFont);
                if (applyFontToDivWhenULAvailable) textNode.classList.add(newFont);
            } else textNode.classList.add(newFont);
            returnFont = newFont;

            // console.log("SG -  After update INCREASE -  " + scrollHeightVal + " - " + textparentNode.offsetHeight);
            scrollHeightVal = ulNode ? ulNode.scrollHeight : textNode.scrollHeight;
            if (scrollHeightVal > textparentNode.offsetHeight || textNode.scrollWidth > textNode.offsetWidth) {
                // console.log("SG - INCREASE 2 - after apply new font its going out of the area so return to old font");
                textNode.classList.remove(newFont);
                if (ulNode) ulNode.classList.remove(newFont);
                if (ulNode) {
                    ulNode.classList.add(currentFont);
                    if (applyFontToDivWhenULAvailable) textNode.classList.add(currentFont);
                } else textNode.classList.add(currentFont);
                returnFont = currentFont;
            } else if (textparentNode.offsetHeight > scrollHeightVal) {
                for (let a = 0; a < seriesLength; a++) {
                    // console.log("SG - INCREASE Loop " + a);
                    if (textparentNode.offsetHeight > scrollHeightVal || textNode.scrollWidth > textNode.offsetWidth) {
                        currentFont = DiagramResizeUtils.getClassNameFromNode(ulNode ? ulNode : textNode, fontData);
                        currentFontSize = parseInt(currentFont.replace(/[^0-9]/g, ""));
                        let newFontCreated = currentFont.replace(currentFontSize, "") + (currentFontSize > maxFont ? currentFontSize - 1 : currentFontSize);
                        if (currentFont == newFontCreated) a = 100;
                        textNode.classList.remove(newFont);
                        if (ulNode) ulNode.classList.remove(newFont);
                        newFont = newFontCreated;
                        // console.log("SG - INCREASE 3 - " + currentFont + " - " + newFont);
                        if (ulNode) {
                            ulNode.classList.add(newFont);
                            if (applyFontToDivWhenULAvailable) textNode.classList.add(newFont);
                        } else textNode.classList.add(newFont);
                        returnFont = newFont;

                        if (currentFont == newFont) a = 100;
                        scrollHeightVal = ulNode ? ulNode.scrollHeight : textNode.scrollHeight;
                        // console.log("SG -  After update INCREASE -  " + scrollHeightVal + " - " + textparentNode.offsetHeight);
                        if (scrollHeightVal > textparentNode.offsetHeight || textNode.scrollWidth > textNode.offsetWidth) {
                            // console.log("SG -  after apply new font second time its going out of the area so return to old font");
                            textNode.classList.remove(newFont);
                            if (ulNode) ulNode.classList.remove(newFont);
                            if (ulNode) {
                                ulNode.classList.add(newFont);
                                if (applyFontToDivWhenULAvailable) textNode.classList.add(currentFont);
                            } else textNode.classList.add(currentFont);
                            returnFont = currentFont;
                            a = 100;
                        }
                    } else a = 100;
                }
            }
        }
    }
    textparentNode.style.display = oldDisplay;
    textparentNode.style.height = oldH;
    textparentNode.style.maxHeight = oldMH;
    textNode.style.removeProperty("height");
    return returnFont;
};

DiagramResizeUtils.doFontResize = function (textNode, nodeGroup, parentNode, fontClassList, paddingTop = 0, paddingBottom = 0, nodePaddingTop = 0, nodePaddingBottom = 0) {
    let nodeParentMinHeight = nodeGroup.parentElement.style.minHeight;
    nodeGroup.parentElement.style.removeProperty("min-height");
    nodeGroup.parentElement.style.minHeight = "auto";
    // nodeGroup.style.height = "fit-content";
    nodeGroup.style.setProperty("height", "fit-content", "important");
    textNode.parentElement.style.setProperty("min-height", "unset");
    let oldHeightNodesHolder = nodeGroup.parentElement.parentElement.parentElement.parentElement.style.height;
    let oldHeightNodeParentMain = nodeGroup.parentElement.parentElement.parentElement.style.height;
    let oldHeightNodeParent = nodeGroup.parentElement.parentElement.style.height;
    let oldHeightGroup = nodeGroup.parentElement.style.height;
    if (oldHeightGroup == "") nodeGroup.parentElement.style.setProperty("height", "100%", "important");
    if (oldHeightNodeParent == "") nodeGroup.parentElement.parentElement.style.setProperty("height", "100%", "important");
    if (oldHeightNodeParentMain == "") nodeGroup.parentElement.parentElement.parentElement.style.setProperty("height", "100%", "important");
    if (oldHeightNodesHolder == "") nodeGroup.parentElement.parentElement.parentElement.parentElement.style.setProperty("height", "100%", "important");
    nodeGroup.style.minHeight = "auto";
    let parentHeight = parentNode.offsetHeight - (parseFloat(paddingTop) + parseFloat(paddingBottom)) - (parseFloat(nodePaddingTop) + parseFloat(nodePaddingBottom));
    let contentHeight = nodeGroup.offsetHeight - (parseFloat(paddingTop) + parseFloat(paddingBottom));
    // let remaningSpace = parentHeight - Math.abs(contentHeight) + textNode.parentElement.offsetHeight;
    // nodeGroup.style.height = "100%";
    nodeGroup.style.setProperty("height", "100%", "important");
    // This line is written here to fix the issue of font resize in the case of the text is in secContent.
    let remaningSpace = parentHeight - Math.abs(contentHeight) + textNode.parentElement.offsetHeight;

    let fontClass = DiagramResizeUtils.commonFontResize(contentHeight, textNode.parentElement.offsetHeight, remaningSpace, textNode, textNode.parentElement, fontClassList);
    if (fontClass && fontClass != "") {
        textNode.dataset.newfontclass = fontClass;
    }
    nodeGroup.style.removeProperty("height");
    textNode.parentElement.style.removeProperty("min-height");
    if (nodeGroup.parentElement.style.height == "100%" && oldHeightGroup != "100%") nodeGroup.parentElement.style.removeProperty("height");
    if (nodeGroup.parentElement.parentElement.style.height == "100%" && oldHeightNodeParent != "100%") nodeGroup.parentElement.parentElement.style.removeProperty("height");
    if (nodeGroup.parentElement.parentElement.parentElement.style.height == "100%" && oldHeightNodeParentMain != "100%") nodeGroup.parentElement.parentElement.parentElement.style.removeProperty("height");
    if (nodeGroup.parentElement.parentElement.parentElement.parentElement.style.height == "100%" && oldHeightNodesHolder != "100%") nodeGroup.parentElement.parentElement.parentElement.parentElement.style.removeProperty("height");
    nodeGroup.style.removeProperty("min-height");
    nodeGroup.parentElement.style.setProperty("min-height", nodeParentMinHeight);
};

DiagramResizeUtils.getClassNameFromNode = function (targetNode, arrFontClassNames) {
    let className = null;
    if (targetNode && targetNode.classList.length > 0) {
        let classNameList = targetNode.classList;
        for (let i = 0; i < arrFontClassNames.length; i++) {
            if (classNameList.contains(arrFontClassNames[i])) className = arrFontClassNames[i];
            if (classNameList.contains("grandhotel")) className = "h4";
            if (classNameList.contains("bebasneue")) className = "h3";
            if (classNameList.contains("sriracha")) className = "h5";
            if (classNameList.contains("niconne")) className = "h1";
            if (classNameList.contains("worksans")) className = "h1";
        }
    }
    return className;
};

DiagramResizeUtils.removeFontClassNameFromNode = function (targetNode, arrFontClassNames) {
    if (targetNode && targetNode.classList.length > 0 && arrFontClassNames && arrFontClassNames.length > 0) {
        for (let i = 0; i < arrFontClassNames.length; i++) {
            targetNode.classList.remove(arrFontClassNames[i]);
        }
    }
};

DiagramResizeUtils.isAutoFontResize = function (targetNode, fontresize) {
    // let name = targetNode?.getAttribute("name");
    // if (name && fontresize?.[name] == "auto") return true;
    let fontResize = targetNode?.getAttribute("data-fontresize") || "auto";
    if (fontResize == "" || fontResize == "auto") return true;
};

/**
 * Author:    Saravanan G
 * Created:   27.09.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function DiagramCreateUtil() {}

DiagramCreateUtil.prototype.constructor = DiagramCreateUtil;

DiagramCreateUtil.createLabel = function (index, className, name, prompt, value = "", focusParentID = "", contentEditable = true) {
    let labelNode = document.createElement("div");
    labelNode.className = className + " clsTitleText ";
    DiagramNodeUtils.assignAttributes(labelNode, { name: name, "data-prompt-text": prompt, "data-name": "text", "data-index": index });
    if (contentEditable == true) {
        DiagramNodeUtils.assignAttributes(labelNode, {
            tabIndex: index,
            "data-ignore-general-selector": "1",
            "data-focus-parent": focusParentID,
            "data-default-event": true,
            "data-oldtext": value,
            contentEditable: true,
        });
    }
    labelNode.innerText = value;
    // console.log(value);
    return labelNode;
};

DiagramCreateUtil.createSpan = function (strSpanID, special = null) {
    let nodeSpan = document.createElement(special ? special : "span");
    if (nodeSpan && strSpanID && strSpanID != "") {
        nodeSpan.setAttribute("id", strSpanID);
        nodeSpan.setAttribute("contenteditable", true);
    }
    return nodeSpan;
};

DiagramCreateUtil.createShapeNode = function (parentNode, nodeData, nodeName, nodeIndex, appStaticURL, backGround, fillColor) {
    parentNode.setAttribute("data-content-type", "shape");
    let contentParentNode = document.createElement("div");
    contentParentNode.className = "cls" + nodeName;
    parentNode.appendChild(contentParentNode);
    const objAssets = { value: appStaticURL + nodeData.value, id: nodeData.id };
    DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body);
    let svgNode = DiagramNodeUtils.createSVGDataNode(fillColor, nodeData.id, nodeData.value, nodeIndex, "shapeNode");
    contentParentNode.appendChild(svgNode);
    return contentParentNode;
};

DiagramCreateUtil.createIconNode = function (parentNode, nodeData, nodeName, nodeIndex, appStaticURL, backGround, fillColor, holdertype, nodeObj, iconLoadCallback, manifestUpdater) {
    parentNode.setAttribute("data-content-type", "icon");
    let contentParentNode = document.createElement("div");
    DiagramCreateUtil.updateDefaultContentNodeAttribute(contentParentNode, nodeName, nodeData, nodeIndex, holdertype);
    // if (focusParent) contentParentNode.setAttribute("data-focus-parent", focusParent);
    parentNode.appendChild(contentParentNode);
    DiagramCreateUtil.updateContentSwitchData(contentParentNode, nodeObj);
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, contentParentNode);

    let nodeParent = document.createElement("div");
    nodeParent.className = "clsIconBg";
    contentParentNode.appendChild(nodeParent);
    DiagramNodeUtils.assignAttributes(nodeParent, { "data-index": nodeIndex, name: "iconBG", id: "iconBG" + nodeIndex, "data-nodetype": "iconBackground" });
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, nodeParent);
    if (!nodeData.id && nodeData.id == "" && nodeData.value && nodeData.value != "") {
        nodeData.id = nodeData.value.substr(nodeData.value.lastIndexOf("/") + 1).split(".")[0];
    }

    if (backGround) {
        let svgNode = DiagramNodeUtils.createSVGDataNode(fillColor, backGround.id, backGround.value, nodeIndex, "iconBGNode");
        nodeParent.appendChild(svgNode);
        DiagramUtils.addClassesFromMenu(nodeObj.objClass, svgNode);
        const objAssets = { value: appStaticURL + backGround.value, id: backGround.id, type: "icon" };
        DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body)
            .then((svgData) => {
                DiagramCreateUtil.updateManifest(objAssets, manifestUpdater, appStaticURL);
            })
            .catch((error) => {
                console.log("Error in Icon Bg : " + error);
            });
    }
    let placeholderObj = { value: appStaticURL + Constants.Value.placeholder_iconpath, id: "placeholder" };
    if (nodeData.dataRef) {
        placeholderObj = { value: nodeData.value, id: nodeData.id };
    }
    let svgNode = DiagramNodeUtils.createSVGDataNode(fillColor, placeholderObj.id, placeholderObj.value, nodeIndex, "iconNode", nodeObj);
    contentParentNode.appendChild(svgNode);
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, svgNode);
    // commenting this beacuse of finger asset not loaded properly - 5node svg alone
    // if (!nodeData.needAssetUpdate && !nodeData.dataRef) {
    if (!nodeData.needAssetUpdate) {
        const objAssets = { value: DiagramUtils.checkAppStaticUrl(nodeData.value, appStaticURL), id: DiagramNodeUtils.getIconName({ id: nodeData.id, value: nodeData.value }), type: "icon" };
        DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body)
            .then((svgData) => {
                let use = svgNode.querySelector("use");
                use?.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "#" + objAssets.id);
                svgNode.setAttribute("iconid", objAssets.id);
                svgNode.setAttribute("iconpath", objAssets.value);
                DiagramCreateUtil.updateManifest(objAssets, manifestUpdater, appStaticURL);
                iconLoadCallback?.(objAssets);
            })
            .catch((error) => {
                console.log("Error in Icon Defaults : " + error);
            });
    }
    // else {
    //     const objAssets = { value: DiagramUtils.checkAppStaticUrl(nodeData.value, appStaticURL), id: DiagramNodeUtils.getIconName({ id: nodeData.id, value: nodeData.value }), type: "icon" };
    //     DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body)
    //         .then((svgData) => {
    //             DiagramCreateUtil.updateManifest(nodeData, manifestUpdater, appStaticURL);
    //             // iconLoadCallback?.(objAssets);
    //         })
    //         .catch((error) => {
    //             console.log("Error in Icon Defaults : " + error);
    //         });
    // }

    let iconOverlay = document.createElement("div");
    iconOverlay.className = "clsIconOverlay";
    contentParentNode.appendChild(iconOverlay);
    DiagramNodeUtils.assignAttributes(iconOverlay, { "data-index": nodeIndex, name: "iconOverlay", id: "iconOverlay" + nodeIndex, "data-nodetype": "iconOverlay" });
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, iconOverlay);

    return contentParentNode;
};

DiagramCreateUtil.createImageNode = function (parentNode, nodeData, nodeName, nodeIndex, holdertype, selectorList, alignment, focusParent = null, callBack = null, holderObj = {}, appStaticURL = "", isFromLogoGrid = false) {
    const contentType = nodeData ? nodeData.contenttype : "image";
    const isLogo = contentType == "logo";

    const position = DiagramNodeUtils.getOffsetLeftTop(parentNode);
    parentNode.setAttribute("data-content-type", contentType);

    let contentParentNode = document.createElement("div");
    DiagramCreateUtil.updateDefaultContentNodeAttribute(contentParentNode, nodeName, nodeData, nodeIndex, holdertype);

    let disablelogocontrast = holderObj && holderObj.disablelogocontrast;
    let nodeGroup = nodeIndex != null ? parentNode && parentNode.parentElement && parentNode.parentElement.parentElement && parentNode.parentElement.parentElement.querySelector("[id='nodeGroup" + nodeIndex + "']") : null;
    if (focusParent) contentParentNode.setAttribute("data-focus-parent", focusParent);
    if (holderObj.parentColorClass) contentParentNode.classList.add(holderObj.parentColorClass);
    parentNode.appendChild(contentParentNode);
    DiagramUtils.addClassesFromMenu(holderObj.objClass, contentParentNode);
    DiagramCreateUtil.updateContentSwitchData(contentParentNode, holderObj);

    let imageBG = document.createElement("div");
    imageBG.className = "clsImageBG";
    DiagramNodeUtils.assignAttributes(imageBG, { name: contentType + "BG", "data-id": "clsImageBG", "data-nodetype": contentType + "Background" });
    contentParentNode.appendChild(imageBG);
    DiagramUtils.addClassesFromMenu(holderObj.objClass, imageBG);

    let imageNode = document.createElement("img");
    let imageURL = nodeData && nodeData.value && nodeData.value != "" ? nodeData.value : isLogo ? appStaticURL + Constants.Value.placeholder_logopath : appStaticURL + Constants.Value.placeholder_imagepath;
    imageURL = DiagramUtils.checkAppStaticUrl(imageURL, appStaticURL);
    DiagramCreateUtil.checkTextContrast(holderObj, imageNode);
    if (holderObj.contrastimagesource) imageNode.setAttribute("data-contrastimagesource", "true");
    if (holderObj.contrastcontainer) imageNode.setAttribute("data-contrastcontainer", holderObj.contrastcontainer);
    let enableLogoContrast = isLogo && !disablelogocontrast && nodeData.logocontrast != null && nodeData.logocontrast != undefined && (nodeData.logocontrast == true || nodeData.logocontrast == "true");
    DiagramNodeUtils.assignAttributes(imageNode, {
        class: "clsImageNode" + (enableLogoContrast ? " logoBrightnessDiagram" : ""),
        id: contentType + "Node" + DiagramNodeUtils.uuidv4(),
        draggable: false,
        "data-src": imageURL,
        "data-nodetype": isLogo ? "logoNode" : "imageNode",
        "data-focus-parent": "nodeGroup",
        "data-id": contentType + "Node",
        name: contentType + "Node",
        "data-index": nodeIndex,
        "data-imagecropalignment": alignment ? alignment : isLogo ? "bottom" : "center",
        "data-x": position.x,
        "data-y": position.y,
        "data-width": position.width,
        "data-height": position.height,
        "data-content-type": contentType,
    });
    contentParentNode.appendChild(imageNode);
    DiagramUtils.addClassesFromMenu(holderObj.objClass, imageNode);
    if (isLogo) DiagramUtils.setLogoContrast(imageNode, nodeGroup, enableLogoContrast);
    if (nodeData.logodata && nodeData.logodata.logos) DiagramNodeUtils.setLogoUrlData(contentParentNode, nodeData.logodata.logos);

    let imageOverlay = document.createElement("div");
    imageOverlay.className = "clsImageOverlay";
    DiagramNodeUtils.assignAttributes(imageOverlay, {
        contentType: contentType,
        "data-id": "imageOverlay",
        "data-nodetype": contentType + "Overlay",
        name: contentType + "Overlay",
        "data-type": "overlay",
    });
    contentParentNode.appendChild(imageOverlay);
    DiagramUtils.addClassesFromMenu(holderObj.objClass, imageOverlay);

    if (nodeData.dataRef && nodeData.dataRef.cropData && nodeData.dataRef.cropStyle) {
        imageNode.setAttribute("data-style", nodeData.dataRef.cropData);
        imageNode.setAttribute("data-csstext", nodeData.dataRef.cropStyle);
        imageNode.style.cssText = nodeData.dataRef.cropStyle;
    }
    // if (!nodeData.needAssetUpdate && !nodeData.assetTextUpdate)
    DiagramResizeUtils.updateDefaultImageData(imageNode, contentType, callBack, isFromLogoGrid);
    return contentParentNode;
};

DiagramCreateUtil.updateDefaultContentNodeAttribute = function (contentParentNode, nodeName, nodeData, nodeIndex, holdertype) {
    let nodeType = nodeData.contenttype;
    DiagramNodeUtils.assignAttributes(contentParentNode, {
        class: "cls" + nodeName,
        name: nodeName,
        id: nodeName + nodeIndex,
        "data-holder-type": holdertype,
        "data-content-type": nodeType,
        "data-index": nodeIndex,
        "data-type": nodeType,
        "data-node-content-type": nodeType,
        "data-id": "content" + nodeType + "parent",
        "data-nodetype": nodeType + "Holder",
        "data-dck-selector": true,
        "data-node-graphic-text": nodeData.assetText || "",
    });
};

DiagramCreateUtil.updateContentSwitchData = function (contentParentNode, nodeData) {
    if (nodeData.arrSupportedContent) {
        contentParentNode.setAttribute("data-arrsupportedcontent", JSON.stringify(nodeData.arrSupportedContent));
        // contentParentNode.setAttribute("data-arrSupportedContent", nodeData.arrSupportedContent);
    }
};

DiagramCreateUtil.checkDefaultData = function (diagramParent, nodeData, currentType, appStaticURL, arrDefaults, index) {
    let contenttype = nodeData && nodeData.contenttype ? nodeData.contenttype : "";
    let needAssetUpdate = (nodeData && (nodeData.needAssetUpdate || nodeData.assetTextUpdate)) || false;
    let assetText = nodeData?.assetText;
    let nodeValue = (nodeData && nodeData.value) || "";
    if (contenttype != currentType || nodeValue == "") {
        nodeData = DiagramNodeUtils.diagramContentData(currentType, appStaticURL, arrDefaults, index);
        // diagramParent.setAttribute("data-contenttype", currentType);
    }
    nodeData.needAssetUpdate = needAssetUpdate;
    nodeData.assetText = assetText;
    return nodeData;
};

DiagramCreateUtil.createMicroNode = function (parentNode, objMicro = {}) {
    let content = objMicro.content || {};
    let name = objMicro.name || "microChartHolder";
    let holdertype = objMicro.holdertype || "primary";
    let nodeObj = objMicro.nodeObj || {};
    let index = objMicro.index || 0;
    let microchartFontSize = objMicro.microchartFontSize || "n1";
    let microStyle = objMicro.microStyle || "clsGradientMicro";
    let innerStroke = objMicro.innerStroke || "clsAccentStroke";
    let globalMoodData = objMicro.globalMoodData || {};
    let globalStyle = objMicro.globalStyle || "";
    let dataAnimation = objMicro.dataAnimation || "valuetext";
    let diagramParent = objMicro.diagramParent || null;

    parentNode.setAttribute("data-content-type", "microchart");
    let contentParentNode = document.createElement("div");
    contentParentNode.className = "cls" + name + " " + globalStyle;
    DiagramNodeUtils.assignAttributes(contentParentNode, {
        name: name,
        "data-dck-selector": true,
        "data-node-content-type": "microchart",
        "data-content-type": "microchart",
        "data-type": "contentmicrochartparent",
        "data-id": "contentmicrochartparent",
        "data-holder-type": holdertype,
        id: name + index,
        "data-index": index,
    });
    parentNode.appendChild(contentParentNode);
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, contentParentNode);
    let nodeParent = document.createElement("div");
    nodeParent.className = "clsMicroChartBg";
    nodeParent.setAttribute("id", "microChartBG" + index);
    nodeParent.setAttribute("name", "microChartBG");
    nodeParent.setAttribute("data-index", index);
    contentParentNode.appendChild(nodeParent);
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, nodeParent);

    let microParentNode = document.createElement("div");
    microParentNode.className = "clsMicroChartContent clssimpleMicroDashed";
    microParentNode.setAttribute("name", "microchartContent");
    microParentNode.setAttribute("data-index", index);
    contentParentNode.appendChild(microParentNode);
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, microParentNode);
    DiagramCreateUtil.createMicroChartSVG(microStyle, microParentNode);

    let removeMicroNode = nodeObj.removeMicroNode;
    if (!removeMicroNode) {
        let microchartNode = document.createElement("div");
        microchartNode.className = "clsMicroChartNode moodanimation " + microchartFontSize;
        microchartNode.style.fontSize = "48px";
        microchartNode.setAttribute("data-id", "microchartNode");
        microchartNode.setAttribute("data-animation", dataAnimation);
        microchartNode.setAttribute("id", "microchartNode" + index);
        microchartNode.setAttribute("name", "microchartNode");
        microchartNode.setAttribute("data-index", index);
        microchartNode.setAttribute("data-focus-parent", "nodeGroup");
        microchartNode.setAttribute("contentEditable", true);
        contentParentNode.appendChild(microchartNode);
        DiagramUtils.addClassesFromMenu(nodeObj.objClass, microchartNode);
        DiagramCreateUtil.checkTextContrast(nodeObj, microchartNode);
        DiagramCreateUtil.parseMicroChartValue(content.type == "image" || content.type == "icon" || content.value == "" || content.value == null || content.value == undefined ? DiagramUtils.getRndInteger(10, 100) : content.value, microchartNode, contentParentNode, globalMoodData);
        microchartNode.classList.add(microStyle + "Text");
    }

    let microMainCircle = microParentNode.querySelector(".clsMainCircle");
    if (microMainCircle) {
        microMainCircle.classList.add("moodanimation");
        microMainCircle.setAttribute("data-animation", "microchart");
        microMainCircle.setAttribute("data-charttype", "micro");
        if (nodeObj.colorClass) microMainCircle.classList.add(nodeObj.colorClass);
        else microMainCircle.classList.add(innerStroke);
    }

    let microMainCircleBG = microParentNode.querySelector(".clsCircleBG");
    if (microMainCircleBG) {
        microMainCircleBG.classList.add("moodanimation");
        let computedStyle = window.getComputedStyle(microMainCircleBG);
        microMainCircleBG.setAttribute("data-customopacity", computedStyle.opacity);
        microMainCircleBG.setAttribute("data-animation", "microcirclebg");
        microMainCircleBG.setAttribute("id", "clsCircleBG" + index);
        microMainCircleBG.classList.add(innerStroke.includes("inner") ? "clsAlterSecondaryStroke" : "clsTertiaryFill");
        microMainCircleBG.classList.add(innerStroke.includes("inner") ? "clsContrastFill" : "clsTertiaryStroke");
    }
    if (index == 0 && diagramParent && holdertype == "primary") {
        let originalresizewidth = diagramParent.style.getPropertyValue("--originalresizewidth");
        if (!parseInt(originalresizewidth)) {
            diagramParent.style.setProperty("--originalresizewidth", contentParentNode.offsetWidth + "px");
            diagramParent.style.setProperty("--originalresizeheight", contentParentNode.offsetHeight + "px");
        }
    }
};

DiagramCreateUtil.createMicroValueNode = function (contentParentNode, objMicro) {
    let content = objMicro.content || {};
    let nodeObj = objMicro.nodeObj || {};
    let index = objMicro.index || 0;
    let microchartFontSize = objMicro.microchartFontSize || "n1";
    let microStyle = objMicro.microStyle || "clsGradientMicro";
    let globalMoodData = objMicro.globalMoodData || {};
    let dataAnimation = objMicro.dataAnimation || "valuetext";
    let holdertype = objMicro.holdertype || "";
    let microchartNode = document.createElement("div");
    microchartNode.className = "clsMicroChartNode moodanimation " + microchartFontSize;
    microchartNode.style.fontSize = "48px";
    microchartNode.setAttribute("data-id", "microchartNode");
    microchartNode.setAttribute("data-animation", dataAnimation);
    microchartNode.setAttribute("id", "microchartNode" + index);
    microchartNode.setAttribute("name", "microchartNode");
    microchartNode.setAttribute("data-index", index);
    microchartNode.setAttribute("data-focus-parent", "nodeGroup");
    microchartNode.setAttribute("contentEditable", true);
    contentParentNode.appendChild(microchartNode);
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, microchartNode);
    DiagramCreateUtil.parseMicroChartValue(content.type == "image" || content.type == "icon" ? DiagramUtils.getRndInteger(10, 100) : content.value, microchartNode, contentParentNode, globalMoodData);
    microchartNode.classList.add(microStyle + "Text");
};

DiagramCreateUtil.createValueTitle = function (bgDiv, objMicro, properties) {
    let content = objMicro.content || {};
    let name = objMicro.name || "valueTitleHolder";
    let holdertype = objMicro.holdertype || "primary";
    let nodeObj = objMicro.nodeObj || {};
    let index = objMicro.index || 0;
    let numberFontSize = objMicro.numberFontSize || "n1";
    let innerColor = objMicro.innerColor || "clsAccentColor";
    let globalMoodData = objMicro.globalMoodData || {};
    let diagramParent = objMicro.diagramParent || bgDiv;
    let diagramProps = objMicro.diagramProps || {};
    let globalStyle = objMicro.globalStyle || "";
    let dataAnimation = objMicro.dataAnimation || "valuetext";

    let titleHolder = document.createElement("div");
    bgDiv.appendChild(titleHolder);
    DiagramNodeUtils.assignAttributes(titleHolder, {
        class: (name.includes("valueListHolder") ? "clsvalueListHolder " : "clsValueTitleParent ") + " clsAccentColor moodanimation " + globalStyle,
        "data-index": index,
        name: name,
        id: name + index,
        "data-dck-selector": true,
        "data-holder-type": holdertype,
        "data-content-type": "number",
        "data-animation": dataAnimation,
        "data-id": "contentnumberparent",
    });
    let value = content && content.type == "text" ? content.value : "";
    content.contenttype = "number";
    content.value = value;
    const fontClass = properties?.fontresize?.valueText ? properties.fontresize.valueText : nodeObj.fontClass || numberFontSize;
    let titleNode = DiagramCreateUtil.createLabel(index, "clsValueText " + (nodeObj.multilineSupport ? "clsMultilineSupport " : "clsSingleLineRestrict ") + fontClass, "numberNode", Constants.Value.valueTextPrompt, value, "nodeGroup");
    DiagramNodeUtils.assignAttributes(titleNode, { "data-index": index, "data-type": "numberNode", "data-id": "numberNode", id: "numberNode" + index });
    DiagramCreateUtil.updateContentSwitchData(titleNode, nodeObj);

    titleHolder.appendChild(titleNode);
    DiagramUtils.applyTextNodeProperties(titleNode, value, nodeObj, diagramProps, globalMoodData, Constants.Value.valueTextColor, content);
    DiagramNodeUtils.checkNumberFormat(titleNode, diagramParent, globalMoodData, diagramProps);
    // DiagramUtils.restrictMaxLines(titleNode);
    return titleHolder;
};

DiagramCreateUtil.checkTextContrast = function (holderObj, textNode) {
    if (holderObj.supportcontrast != null && holderObj.supportcontrast == false) {
    } else textNode.setAttribute("data-supportcontrast", "true");
};

DiagramCreateUtil.parseMicroChartValue = function (data, microNode, parentNode, globalMoodData) {
    let mainCircle = parentNode.querySelector(".clsMainCircle");
    let textMain = DiagramCreateUtil.createSpan("spanMainText");
    textMain.className = "clSpanMainText";
    microNode.innerText = data;
    let objFormat = DiagramNodeUtils.getNumberFormat(microNode);
    // let defaultValue = DiagramUtils.getRndInteger(1, 100);
    // let valueSystem = objFormat.value != null ? objFormat.value : 0;
    let value = !objFormat.validData ? 0 : objFormat.currencyValueNormalized != null ? Math.abs(objFormat.currencyValueNormalized) : objFormat.value.toLocaleString();
    value = value > 100 ? 100 : value < 0 ? 0 : value == "" || isNaN(value) ? 0 : value;
    textMain.innerText = value;
    parentNode.style.setProperty("--percentageValue", value + "%");
    parentNode.style.setProperty("--percentageData", value);
    if (mainCircle) mainCircle.setAttribute("data-percentageValue", value);
    let mooddata = globalMoodData && globalMoodData.basicgraphics ? globalMoodData.basicgraphics : {};
    let suffixSpecial = null;
    if (mooddata.numbersuffix) suffixSpecial = mooddata.numbersuffix.special;
    let suffix = DiagramCreateUtil.createSpan("spanSuffix", suffixSpecial);
    suffix.className = mooddata && mooddata.numbersuffix ? mooddata.numbersuffix.style : "clsSpanSuffix";
    microNode.innerHTML = textMain.outerHTML + "%";
};

DiagramCreateUtil.parseRatingValue = function (nodeGroup, percent) {
    let nodeItem = nodeGroup.querySelector('[data-id="contentmicrochartparent"]');
    let microText = nodeItem.querySelector('[id="spanMainText"]');
    nodeItem.style.setProperty("--percentageValue", parseFloat(percent) + "%");
    nodeItem.style.setProperty("--percentageData", parseFloat(percent));
    let mainCircle = nodeGroup.querySelector(".clsMainCircle");
    if (mainCircle) mainCircle.setAttribute("data-percentageValue", parseFloat(percent));
    if (microText) microText.innerText = parseFloat(percent);
};

DiagramCreateUtil.createMicroChartSVG = function (microStyle, parentNode) {
    parentNode.className = "clsMicroChartContent " + microStyle;
    let innerHTML = "";
    let uuid = DiagramNodeUtils.uuidv4();

    switch (microStyle) {
        case "clsSemiCircleStrokeDiagram":
            innerHTML = '<svg viewBox="0 0 32 16" height="100%" width="100%">';
            innerHTML +=
                '<defs><linearGradient id="gradmicro" x1="1" y1="1" x2="0"><stop offset=".12" stop-color="rgba(var(--gradient2-color-rgb),1)"/><stop offset=".83" stop-color="rgba(var(--gradient1-color-rgb),1)"/></linearGradient><clipPath id="clipMicro"><path class="clsMainCircleClip"  d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831  a 15.9155 15.9155 0 0 1 0 -31.831" /></clipPath> </defs>';
            // innerHTML += "<path class='clsMainCircle' id='clsMainCircle'  d='" + DiagramCreateUtil.drawConnector( 180, 360,14,{x:0,y:0},{x:parentNode.clientWidth,y:parentNode.clientWidth}) + "'/>";
            // innerHTML += "<path class='clsMainCircleDash' id='clsMainCircleDash'  d='" + DiagramCreateUtil.drawConnector( 180, 360, 14,{x:0,y:0},{x:parentNode.clientWidth,y:parentNode.clientWidth}) + "'/>";
            innerHTML += "<path class='clsMainCircleDash moodanimation' data-animation='microcirclebg' id='clsMainCircleDash'  d='" + DiagramCreateUtil.circlePathWithAngle(16, 16, 14, 14) + "'/>";
            innerHTML += "<path class='clsMainCircle' id='clsMainCircle'  d='" + DiagramCreateUtil.circlePathWithAngle(16, 16, 14, 14) + "'/>";
            innerHTML += "</svg>";
            parentNode.innerHTML = innerHTML;
            let path = parentNode.querySelector("[id='clsMainCircleDash']");
            parentNode.parentElement.style.setProperty("--pathLength", path.getTotalLength());
            break;
        case "clsCircleFillDiagram":
            innerHTML += '<div class="clsMainCircle" id="clsMainCircle"  />';
            parentNode.innerHTML = innerHTML;
            break;
        case "clsLinePieDiagram":
            innerHTML = '<svg viewBox="0 0 32 32" height="100%">';
            innerHTML += '<circle class="clsCircleBG" id="clsCircleBG"   r="16" cx="16" cy="16" fill="transparent" stroke="#FF0000"  stroke-dasharray="101 100" />';
            innerHTML += '<circle class="clsMainCircle"  id="clsMainCircle" r="16" cx="16" cy="16" fill="transparent" stroke="green" stroke-dasharray="10 100" />';
            innerHTML += '<circle  class="clsSlideBG"  r="16" cx="16" cy="16" stroke="#FFFFFF" stroke-dasharray="1" fill="transparent" />';
            innerHTML += "</svg>";
            parentNode.innerHTML = innerHTML;
            break;
        case "clsPieMicroDiagram":
            innerHTML = '<svg viewBox="0 0 32 32" height="100%" width="100%">';
            innerHTML += "<defs>";
            innerHTML += '<clipPath id="' + uuid + '">';
            innerHTML += '<circle  r="16" cx="16" cy="16" />';
            innerHTML += "</clipPath>";
            innerHTML += "</defs>";
            innerHTML += '<g clip-path="url(#' + uuid + ')">';
            //innerHTML += '<circle  class="clsCircleBG" id="clsCircleBG" r="50%" cx="50%" cy="50%" "></circle>';
            innerHTML += '<circle class="clsCircleBG" id="clsCircleBG"   r="16" cx="16" cy="16" fill="transparent" stroke="#0000FF" stroke-width="32" stroke-dasharray="101 100" />';
            innerHTML += '<circle class="clsMainCircle"  id="clsMainCircle" r="16" cx="16" cy="16" fill="transparent" stroke="#FF0000" stroke-width="32" stroke-dasharray="40 100" />';
            //innerHTML += '<circle  fill-opacity= "0" stroke-opacity= "1" class="clsMainCircle"  id="clsMainCircle" r="9px" cx="18px" cy="18px" class="clsMainCircle"> </circle>';
            innerHTML += "</g>";
            innerHTML += "</svg>";
            parentNode.innerHTML = innerHTML;
            break;
        case "clsPieCutMicroDiagram":
            innerHTML = '<svg viewBox="0 0 32 32" height="100%">';
            innerHTML += "<defs>";
            innerHTML += '<clipPath id="' + uuid + '">';
            innerHTML += '<circle  r="16" cx="16" cy="16" />';
            innerHTML += "</clipPath>";
            innerHTML += "</defs>";
            innerHTML += '<g clip-path="url(#' + uuid + ')">';
            //innerHTML += '<circle  class="clsCircleBG" id="clsCircleBG" r="50%" cx="50%" cy="50%" "></circle>';
            innerHTML += '<circle class="clsCircleBG" id="clsCircleBG"   r="6" cx="16" cy="16" fill="transparent" stroke="#0000FF" stroke-width="32" stroke-dasharray="101 100" />';
            innerHTML += '<circle class="clsMainCircle"  id="clsMainCircle" r="16" cx="16" cy="16" fill="transparent" stroke="#FF0000" stroke-width="32" stroke-dasharray="40 100" />';
            //innerHTML += '<circle  fill-opacity= "0" stroke-opacity= "1" class="clsMainCircle"  id="clsMainCircle" r="9px" cx="18px" cy="18px" class="clsMainCircle"> </circle>';
            innerHTML += "</g>";
            innerHTML += "</svg>";
            parentNode.innerHTML = innerHTML;
            break;
        case "clsGradientPieMicroDiagram":
            innerHTML = '<svg viewBox="0 0 32 32" height="100%" width="100%">';
            innerHTML += "<defs>";
            innerHTML += '<linearGradient id="gradmicro"><stop offset=".22" stop-color="rgba(var(--gradient2-color-rgb),1)"></stop><stop offset=".83" stop-color="rgba(var(--gradient1-color-rgb),1)"></stop></linearGradient>';
            innerHTML += "</defs>";
            //innerHTML += '<circle  class="clsCircleBG" id="clsCircleBG" r="50%" cx="50%" cy="50%" "></circle>';
            innerHTML += '<circle class="clsCircleBG" id="clsCircleBG"   r="16" cx="16" cy="16" fill="transparent" stroke="#0000FF" stroke-width="32" stroke-dasharray="101 100" />';
            innerHTML += '<circle class="clsMainCircle"  id="clsMainCircle" r="16" cx="16" cy="16" fill="transparent" stroke="#FF0000" stroke-width="32" stroke-dasharray="40 100" />';
            //innerHTML += '<circle  fill-opacity= "0" stroke-opacity= "1" class="clsMainCircle"  id="clsMainCircle" r="9px" cx="18px" cy="18px" class="clsMainCircle"> </circle>';
            innerHTML += "</svg>";
            parentNode.innerHTML = innerHTML;
            break;
        case "clssimpleMicroSimpleFill":
            parentNode.innerHTML = '<svg><rect class="clsMicroRect"  x=0 y=0   /> <rect class="clsCircleBG" x=0 y=0   /> <rect  x=0 y=0   class="clsMainCircle" />  </svg>';
            break;
        case "clsGradientSimpleFillMicro":
            parentNode.innerHTML =
                '<svg><defs><linearGradient x1="0%" y1="0%" x2="100%" y2="0%" id="gradmicro"><stop offset=".22" stop-color="rgba(var(--gradient1-color-rgb),1)"></stop><stop offset=".83" stop-color="rgba(var(--gradient2-color-rgb),1)"></stop></linearGradient><clipPath id="clipMicro"><path class="clsMainCircleClip"  d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831  a 15.9155 15.9155 0 0 1 0 -31.831" /></clipPath> </defs><rect class="clsMicroRect"  x=0 y=0   /> <rect class="clsCircleBG" x=0 y=0   /> <rect  x=0 y=0   class="clsMainCircle" />  </svg>';
            break;
        case "clsRatingMicro":
            // innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="rating_rounded-Layer_1" width="100%" data-name="Layer 1" width="100%" viewBox="0 0 426 68"><defs><clipPath id="rating_rounded-clip-path"><rect id="rating_rounded-_Clipping_Path_" data-name="&lt;Clipping Path&gt;" x="0.3" y="0.3" width="425.5" height="67.33" fill="none" stroke="none"/></clipPath></defs><g clip-path="url(#rating_rounded-clip-path)"><path id="rating_rounded-clsCircleBG" d="M15.2,67.6a1,1,0,0,1-1.5-1.1c1.9-5.8,6.2-18.7,7.8-23.7.1-.4.1-.7-.3-.9L.8,27.2a1,1,0,0,1,.6-1.8H27.3l8-24.1a1,1,0,0,1,1.9,0L45,24.8a.7.7,0,0,0,.8.6H71a1,1,0,0,1,.6,1.8L51.3,41.8a.9.9,0,0,0-.4,1.1c2.2,6.5,6,18.2,7.8,23.6a1,1,0,0,1-1.5,1.1L36.8,53a.8.8,0,0,0-1.1,0ZM126.1,53a.8.8,0,0,1,1.1,0l20.4,14.6a1,1,0,0,0,1.5-1.1l-7.8-23.6a.9.9,0,0,1,.4-1.1L162,27.2a1,1,0,0,0-.6-1.8H136.2a.7.7,0,0,1-.8-.6h0c-1.8-5.7-6-18-7.8-23.6a1,1,0,0,0-1.9,0l-8,24.2H91.8a1,1,0,0,0-.6,1.8l20.5,14.7c.4.2.4.5.3.9-1.8,5.2-5.8,17.7-7.8,23.7a1,1,0,0,0,1.5,1.1Zm88.4,0a.8.8,0,0,1,1.1,0L236,67.6a1,1,0,0,0,1.5-1.1l-7.7-23.6a.8.8,0,0,1,.3-1.1h0l20.4-14.6a1,1,0,0,0-.6-1.8H224.6a.7.7,0,0,1-.8-.6h0c-1.8-5.7-6-18-7.8-23.6a1,1,0,0,0-1.9,0l-8,24.2H180.2a1,1,0,0,0-.6,1.8l20.5,14.7c.4.2.4.5.3.9-1.7,5.2-5.8,17.7-7.8,23.7a1,1,0,0,0,1.5,1.1Zm89.4,0a.8.8,0,0,1,1.1,0l20.4,14.6a1,1,0,0,0,1.5-1.1l-7.7-23.6a.8.8,0,0,1,.3-1.1h.1l20.3-14.6a1,1,0,0,0-.6-1.8H314c-.4,0-.6-.2-.8-.6-1.8-5.7-6-18-7.8-23.6a1,1,0,0,0-1.9,0l-8,24.2H269.6a1,1,0,0,0-.6,1.8l20.5,14.7c.4.2.4.5.3.9C288.1,48,284,60.5,282,66.4a1,1,0,0,0,1.5,1.1Zm85.4,0a.8.8,0,0,1,1.1,0l20.4,14.6a1,1,0,0,0,1.5-1.1l-7.7-23.6a.8.8,0,0,1,.3-1.1h0l20.4-14.6a1,1,0,0,0-.6-1.8H399.4c-.5,0-.6-.2-.8-.6-1.8-5.7-5.9-18-7.8-23.6a1,1,0,0,0-1.9,0l-8.1,24.2H355a1,1,0,0,0-.6,1.8l20.5,14.7c.4.2.4.5.3.9-1.7,5.2-5.8,17.7-7.8,23.7a1,1,0,0,0,1.5,1.1Z" stroke="none"/><path id="rating_rounded-clsMainCircle" d="M15.2,67.6a1,1,0,0,1-1.5-1.1c1.9-5.8,6.2-18.7,7.8-23.7.1-.4.1-.7-.3-.9L.8,27.2a1,1,0,0,1,.6-1.8H27.3l8-24.1a1,1,0,0,1,1.9,0L45,24.8a.7.7,0,0,0,.8.6H71a1,1,0,0,1,.6,1.8L51.3,41.8a.9.9,0,0,0-.4,1.1c2.2,6.5,6,18.2,7.8,23.6a1,1,0,0,1-1.5,1.1L36.8,53a.8.8,0,0,0-1.1,0ZM126.1,53a.8.8,0,0,1,1.1,0l20.4,14.6a1,1,0,0,0,1.5-1.1l-7.8-23.6a.9.9,0,0,1,.4-1.1L162,27.2a1,1,0,0,0-.6-1.8H136.2a.7.7,0,0,1-.8-.6h0c-1.8-5.7-6-18-7.8-23.6a1,1,0,0,0-1.9,0l-8,24.2H91.8a1,1,0,0,0-.6,1.8l20.5,14.7c.4.2.4.5.3.9-1.8,5.2-5.8,17.7-7.8,23.7a1,1,0,0,0,1.5,1.1Zm88.4,0a.8.8,0,0,1,1.1,0L236,67.6a1,1,0,0,0,1.5-1.1l-7.7-23.6a.8.8,0,0,1,.3-1.1h0l20.4-14.6a1,1,0,0,0-.6-1.8H224.6a.7.7,0,0,1-.8-.6h0c-1.8-5.7-6-18-7.8-23.6a1,1,0,0,0-1.9,0l-8,24.2H180.2a1,1,0,0,0-.6,1.8l20.5,14.7c.4.2.4.5.3.9-1.7,5.2-5.8,17.7-7.8,23.7a1,1,0,0,0,1.5,1.1Zm89.4,0a.8.8,0,0,1,1.1,0l20.4,14.6a1,1,0,0,0,1.5-1.1l-7.7-23.6a.8.8,0,0,1,.3-1.1h.1l20.3-14.6a1,1,0,0,0-.6-1.8H314c-.4,0-.6-.2-.8-.6-1.8-5.7-6-18-7.8-23.6a1,1,0,0,0-1.9,0l-8,24.2H269.6a1,1,0,0,0-.6,1.8l20.5,14.7c.4.2.4.5.3.9C288.1,48,284,60.5,282,66.4a1,1,0,0,0,1.5,1.1Zm85.4,0a.8.8,0,0,1,1.1,0l20.4,14.6a1,1,0,0,0,1.5-1.1l-7.7-23.6a.8.8,0,0,1,.3-1.1h0l20.4-14.6a1,1,0,0,0-.6-1.8H399.4c-.5,0-.6-.2-.8-.6-1.8-5.7-5.9-18-7.8-23.6a1,1,0,0,0-1.9,0l-8.1,24.2H355a1,1,0,0,0-.6,1.8l20.5,14.7c.4.2.4.5.3.9-1.7,5.2-5.8,17.7-7.8,23.7a1,1,0,0,0,1.5,1.1Z" fill="none" stroke="none"/></g></svg>`;
            innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 429 71" width="100%">';
            innerHTML += '<defs><clipPath id="' + uuid + '"><rect class="clsMicroRect" id="clsMicroRect" height="100%"/></clipPath></defs>';
            // innerHTML += '<rect x="0" y="0" width="100%" height="100%" />';
            innerHTML +=
                '<path class="clsCircleBG" id="clsCircleBG" d="M15.7,59.3a3,3,0,0,1-4.6-3.4L17.1,38c.1-.4.1-.7-.3-.9L1.3,26.1a3,3,0,0,1,1.7-5.4H22.8L28.8,2.2a3,3,0,0,1,5.7,0L40.5,20a.7.7,0,0,0,.8.6H60.3a3,3,0,0,1,1.7,5.4L46.8,37a.9.9,0,0,0-.4,1.1l5.9,17.8a3,3,0,0,1-4.6,3.4L32.3,48.2a.8.8,0,0,0-1.1,0ZM121.6,48.2a.8.8,0,0,1,1.1,0l15.4,11a3,3,0,0,0,4.6-3.4l-5.9-17.8a.9.9,0,0,1,.4-1.1l15.3-11a3,3,0,0,0-1.7-5.4h-19a.7.7,0,0,1-.8-.6h0c-1.3-4.2-3.9-11.9-5.9-17.9a3,3,0,0,0-5.7,0l-6.1,18.5H93.5a3,3,0,0,0-1.7,5.4l15.4,11.1c.4.2.4.5.3.9-1.3,3.9-3.9,11.6-5.9,17.9a3,3,0,0,0,4.6,3.4Zm88.4,0a.8.8,0,0,1,1.1,0l15.4,11.1a3,3,0,0,0,4.6-3.4l-5.8-17.8a.8.8,0,0,1,.3-1.1h0l15.3-11a3,3,0,0,0-1.7-5.4h-19a.7.7,0,0,1-.8-.6h0c-1.3-4.2-3.9-11.9-5.9-17.9a3,3,0,0,0-5.7,0l-6.1,18.5H181.9a3,3,0,0,0-1.7,5.4l15.4,11.1c.4.2.4.5.3.9L190,55.9a3,3,0,0,0,4.6,3.4Zm89.4,0a.8.8,0,0,1,1.1,0l15.4,11.1a3,3,0,0,0,4.6-3.4l-5.8-17.8a.8.8,0,0,1,.3-1.1h.1l15.2-11a3,3,0,0,0-1.8-5.4H309.5c-.4,0-.6-.2-.8-.6-1.3-4.2-3.9-11.9-5.9-17.9a3,3,0,0,0-5.7,0L291,20.6H271.3a3,3,0,0,0-1.7,5.4L285,37.1c.4.2.4.5.3.9l-5.8,17.8a3,3,0,0,0,4.6,3.4Zm85.4,0a.8.8,0,0,1,1.1,0l15.4,11.1a3,3,0,0,0,4.6-3.4l-5.8-17.8a.8.8,0,0,1,.3-1.1h0l15.3-11a3,3,0,0,0-1.7-5.4h-19c-.5,0-.6-.2-.8-.6-1.3-4.2-3.9-11.8-5.9-17.8a3,3,0,0,0-5.7,0l-6.1,18.4H356.7a3,3,0,0,0-1.7,5.4l15.4,11.1c.4.2.4.5.3.9l-5.8,17.8a3,3,0,0,0,4.6,3.4Z" fill="green" />';
            innerHTML +=
                '<g clip-path="url(#' +
                uuid +
                ')"><path  class="clsMainCircle"  id="clsMainCircle" d="M15.7,59.3a3,3,0,0,1-4.6-3.4L17.1,38c.1-.4.1-.7-.3-.9L1.3,26.1a3,3,0,0,1,1.7-5.4H22.8L28.8,2.2a3,3,0,0,1,5.7,0L40.5,20a.7.7,0,0,0,.8.6H60.3a3,3,0,0,1,1.7,5.4L46.8,37a.9.9,0,0,0-.4,1.1l5.9,17.8a3,3,0,0,1-4.6,3.4L32.3,48.2a.8.8,0,0,0-1.1,0ZM121.6,48.2a.8.8,0,0,1,1.1,0l15.4,11a3,3,0,0,0,4.6-3.4l-5.9-17.8a.9.9,0,0,1,.4-1.1l15.3-11a3,3,0,0,0-1.7-5.4h-19a.7.7,0,0,1-.8-.6h0c-1.3-4.2-3.9-11.9-5.9-17.9a3,3,0,0,0-5.7,0l-6.1,18.5H93.5a3,3,0,0,0-1.7,5.4l15.4,11.1c.4.2.4.5.3.9-1.3,3.9-3.9,11.6-5.9,17.9a3,3,0,0,0,4.6,3.4Zm88.4,0a.8.8,0,0,1,1.1,0l15.4,11.1a3,3,0,0,0,4.6-3.4l-5.8-17.8a.8.8,0,0,1,.3-1.1h0l15.3-11a3,3,0,0,0-1.7-5.4h-19a.7.7,0,0,1-.8-.6h0c-1.3-4.2-3.9-11.9-5.9-17.9a3,3,0,0,0-5.7,0l-6.1,18.5H181.9a3,3,0,0,0-1.7,5.4l15.4,11.1c.4.2.4.5.3.9L190,55.9a3,3,0,0,0,4.6,3.4Zm89.4,0a.8.8,0,0,1,1.1,0l15.4,11.1a3,3,0,0,0,4.6-3.4l-5.8-17.8a.8.8,0,0,1,.3-1.1h.1l15.2-11a3,3,0,0,0-1.8-5.4H309.5c-.4,0-.6-.2-.8-.6-1.3-4.2-3.9-11.9-5.9-17.9a3,3,0,0,0-5.7,0L291,20.6H271.3a3,3,0,0,0-1.7,5.4L285,37.1c.4.2.4.5.3.9l-5.8,17.8a3,3,0,0,0,4.6,3.4Zm85.4,0a.8.8,0,0,1,1.1,0l15.4,11.1a3,3,0,0,0,4.6-3.4l-5.8-17.8a.8.8,0,0,1,.3-1.1h0l15.3-11a3,3,0,0,0-1.7-5.4h-19c-.5,0-.6-.2-.8-.6-1.3-4.2-3.9-11.8-5.9-17.8a3,3,0,0,0-5.7,0l-6.1,18.4H356.7a3,3,0,0,0-1.7,5.4l15.4,11.1c.4.2.4.5.3.9l-5.8,17.8a3,3,0,0,0,4.6,3.4Z" fill="red" /></g>';
            innerHTML += "</svg>";
            parentNode.innerHTML = innerHTML;
            break;
        case "clsGradientMicro":
            innerHTML = '<svg viewBox="0 0 36 36">';
            innerHTML +=
                '<defs><linearGradient id="gradmicro" x1="1" y1="1" x2="0"><stop offset=".12" stop-color="rgba(var(--gradient2-color-rgb),1)"/><stop offset=".83" stop-color="rgba(var(--gradient1-color-rgb),1)"/></linearGradient><clipPath id="clipMicro"><path class="clsMainCircleClip"  d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831  a 15.9155 15.9155 0 0 1 0 -31.831" /></clipPath> </defs>';
            innerHTML +=
                '<rect class="clsMicroRect"  fill="none" stroke="none" x=0 y=0 width="100%" height="100%" /><path class="clsCircleBG"  d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831  a 15.9155 15.9155 0 0 1 0 -31.831"  /> <path   class="clsMainCircle"  d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831  a 15.9155 15.9155 0 0 1 0 -31.831" /><path class="clsMainCircleDash"  d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831  a 15.9155 15.9155 0 0 1 0 -31.831" /></svg>';
            parentNode.innerHTML = innerHTML;
            break;
        default:
            innerHTML = '<svg viewBox="0 0 36 36">';
            innerHTML += '<defs><clipPath id="clipMicro"><path class="clsMainCircleClip"  d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831  a 15.9155 15.9155 0 0 1 0 -31.831" /></clipPath> </defs>';
            innerHTML +=
                '<rect class="clsMicroRect"  fill="none" stroke="none" x=0 y=0 width="100%" height="100%" /><path class="clsCircleBG"  d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831  a 15.9155 15.9155 0 0 1 0 -31.831"  /> <path   class="clsMainCircle"  d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831  a 15.9155 15.9155 0 0 1 0 -31.831" /><path class="clsMainCircleDash"  d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831  a 15.9155 15.9155 0 0 1 0 -31.831" /></svg>';
            parentNode.innerHTML = innerHTML;
            break;
    }
};

DiagramCreateUtil.drawConnector = function (startAngle, endAngle, radius, start, end) {
    let largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
    return ["M", start.x, start.y, "A", radius, radius, 0, largeArcFlag, 1, end.x, end.y].join(" ");
};

DiagramCreateUtil.regularArcData = function (cx, cy, radius, startDegrees, endDegrees, isCounterClockwise) {
    // let largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";

    // let d = ["M", start.x, start.y, "A", radius, radius, 0, largeArcFlag, 1, end.x, end.y].join(" ");

    var offsetRadians = 0; // -Math.PI/2 for 12 o'clock
    var sweepFlag = isCounterClockwise ? 0 : 1;
    var startRadians = offsetRadians + (startDegrees * Math.PI) / 180;
    var endRadians = offsetRadians + (endDegrees * Math.PI) / 180;
    // var largeArc = (endRadians - startRadians) % (2 * Math.PI) > Math.PI ? 1 : 0;
    var largeArc = (endRadians - startRadians) % (2 * Math.PI) > Math.PI ? 1 : 0;
    var startX = parseInt(cx + radius * Math.cos(startRadians));
    var startY = parseInt(cy + radius * Math.sin(startRadians));
    var endX = parseInt(cx + radius * Math.cos(endRadians));
    var endY = parseInt(cy + radius * Math.sin(endRadians));
    var space = " ";
    var arcData = "";

    arcData += "M" + space + startX + space + startY + space;
    arcData += "A" + space + radius + space + radius + space + offsetRadians + space + largeArc + space + sweepFlag + space + endX + space + endY;
    return arcData;
};

DiagramCreateUtil.circlePathWithAngle = function (cx, cy, rx, ry, deg = 0, isReverse = false, isFlip = false) {
    var theta = (deg * Math.PI) / 180,
        dx = rx * Math.cos(theta),
        dy = -ry * Math.sin(theta);
    // let directionFlag = isReverse ? 0 : 1
    // return `M${cx} ${cy} m${dx},${dy} a${rx},${ry} 0 1,${directionFlag} ${-2 * dx},${-2 * dy}`;
    let clock = `M${cx - rx} ${cy} a${rx},${ry} 0 1,${1} ${2 * dx},${2 * dy}`;
    let anticlock = `M${cx + rx} ${cy} a${rx},${ry} 0 1,${0} ${-2 * dx},${-2 * dy}`;
    let flipClock = `M${cx - rx} ${cy} a${rx},${ry} 0 1,${0} ${-2 * dx},${-2 * dy}`;
    let flipAntiClock = `M${cx + rx} ${cy} a${rx},${ry} 0 1,${1} ${2 * dx},${2 * dy}`;
    return isReverse ? (isFlip ? flipAntiClock : anticlock) : isFlip ? flipClock : clock;
};

DiagramCreateUtil.updateManifest = function (assetData, manifestUpdater, appStaticURL = null) {
    if (manifestUpdater && manifestUpdater.func && manifestUpdater.params) {
        if (appStaticURL && assetData.value.includes(appStaticURL)) assetData.value = assetData.value.substr(appStaticURL.length);
        manifestUpdater.func(manifestUpdater.params, assetData);
    }
};

DiagramCreateUtil.getHolderId = function (elementId, arrIndex) {
    if (elementId.includes("Holder")) return elementId;
    if (elementId.includes("value")) return `valueTitleHolder-${arrIndex[0]},${arrIndex[1]}`;
    if (elementId.includes("textNode")) return `textTitleHolder-${arrIndex[0]},${arrIndex[1]}`;
    if (elementId.includes("checklist")) return `checkListHolder-${arrIndex[0]},${arrIndex[1]}`;
    //"checklistNode-1,1"
};

DiagramCreateUtil.createSpriteElement = function (graphicElement, diagramParent, index) {
    let spriteHolder = graphicElement.querySelector("#spriteHolder" + index);
    let assetelement = graphicElement.querySelector("#spriteElement" + index);
    if (spriteHolder) {
        assetelement.remove();
        spriteHolder.remove();
    }
    spriteHolder = document.createElement("div");
    graphicElement.appendChild(spriteHolder);
    assetelement = document.createElement("div");
    spriteHolder.appendChild(assetelement);
    spriteHolder.className = "piegraphic moodanimation";
    spriteHolder.setAttribute("name", "spriteHolder");
    spriteHolder.dataset.animation = "spriteitem";
    spriteHolder.dataset.id = "spriteHolder";
    spriteHolder.id = "spriteHolder" + index;
    assetelement.className = "graphicimage";
    assetelement.setAttribute("name", "spriteElement");
    assetelement.dataset.id = "spriteElement";
    assetelement.id = "spriteElement" + index;
    return assetelement;
};

DiagramCreateUtil.createDiagramTitleHolder = function (bgDiv, primaryTextData, properties = {}, nodeProps = {}, globalMoodData = {}, diagramTitleFontSize = "h7", nodeObj = {}) {
    let titleHolder = document.createElement("div");
    DiagramNodeUtils.assignAttributes(titleHolder, {
        class: "clsDiagramTitleParent clsGraphicTitleParent moodanimation",
        // "data-animation": "primarytext",
        "data-animation": "takeawaytitle",
        name: "diagramTitleHolder",
        "data-dck-selector": true,
        id: "diagramTitleHolder",
    });
    const value = primaryTextData && primaryTextData.value ? primaryTextData.value : "";
    let fontSize = DiagramNodeUtils.getFontSize("diagramTitle", nodeObj, diagramTitleFontSize, properties);
    let titleNode = DiagramCreateUtil.createLabel(0, "clsDiagramTitle clsGraphicTitle " + fontSize + " " + DiagramCreateUtil.setHighlightClass(nodeObj.colorClass), "diagramTitle", "Enter your title text", value);
    let originalFontSize = DiagramNodeUtils.getOriginalFontSize("diagramTitle", nodeObj, diagramTitleFontSize, properties);
    DiagramNodeUtils.assignAttributes(titleNode, {
        id: "diagramTitle",
        "data-type": "diagramTitle",
        "data-highlight-event": "true",
        // "data-observer": "true",
        "original-fontclass": originalFontSize,
        "original-fontbase": originalFontSize.split("")[0],
        "original-fontnumber": originalFontSize.split("")[1],
        // "data-fontresize": fontSize,
    });
    titleHolder.appendChild(titleNode);
    bgDiv.insertBefore(titleHolder, bgDiv.firstElementChild);
    DiagramUtils.applyTextNodeProperties(titleNode, value, nodeObj, nodeProps, globalMoodData, Constants.Value.diagramTitleColor, primaryTextData);
    // this.observer.observe(titleNode, { childList: true });
    // this.observer.mytargets.push(titleNode);
    return titleHolder;
};

DiagramCreateUtil.createDiagramTitle = function (diagramParent, diagramData, nodeProps, globalMoodData, objStyleData = {}) {
    let diagramTitleSupport = DiagramUtils.isDiagramTitleSupported(diagramParent.dataset.classname, nodeProps.nodeclassName, diagramData.properties.floateroptionsdisable);
    if (diagramTitleSupport && !nodeProps?.centerShape) {
        let titleHolder = diagramParent.querySelector("[name='diagramTitleHolder']");
        if (titleHolder) titleHolder.remove();
        titleHolder = DiagramCreateUtil.createDiagramTitleHolder(diagramParent, diagramData.diagramtitle, diagramData.properties, nodeProps, globalMoodData, objStyleData?.fontSizeData?.diagramtitle);
        DiagramCreateUtil.setDiagramTitleSingleLine(diagramParent);
    }
};

DiagramCreateUtil.getDiagramTitleData = function (parent) {
    let labelText = parent.querySelector("div[name='diagramTitle']");
    if (labelText) {
        return { type: "text", value: labelText.innerHTML && labelText.innerHTML != "" ? TextHighLightUtils.highlightToString(labelText.innerHTML) : "", ...DiagramCreateUtil.getTextProps(labelText) };
    } else {
        return "";
    }
};

DiagramCreateUtil.getTextProps = function (primaryText) {
    // let style = getComputedStyle(primaryText);
    // let fontStyle = style;
    // if (primaryText.firstElementChild) {
    //     fontStyle = getComputedStyle(primaryText.firstElementChild);
    //     primaryText = primaryText.firstElementChild;
    // }
    if (!primaryText) return {};
    let textproperties = {};
    if (primaryText.getAttribute("data-letterspacing")) textproperties.letterspacing = primaryText.getAttribute("data-letterspacing");
    if (primaryText.getAttribute("data-lineheight")) textproperties.lineheight = primaryText.getAttribute("data-lineheight");
    if (primaryText.getAttribute("data-texttransform")) textproperties.texttransform = primaryText.getAttribute("data-texttransform");
    if (primaryText.getAttribute("data-textcolor")) textproperties.textcolor = primaryText.getAttribute("data-textcolor");
    if (primaryText.getAttribute("data-textopacity")) textproperties.textopacity = primaryText.getAttribute("data-textopacity");
    if (primaryText.getAttribute("data-textalign")) textproperties.textalign = primaryText.getAttribute("data-textalign");
    if (primaryText.getAttribute("data-textgrayscale")) textproperties.textgrayscale = primaryText.getAttribute("data-textgrayscale");
    if (primaryText.getAttribute("data-textsize")) textproperties.textsize = primaryText.getAttribute("data-textsize");
    if (primaryText.getAttribute("data-fontbold")) textproperties.fontbold = primaryText.getAttribute("data-fontbold");
    if (primaryText.getAttribute("data-fontitalic")) textproperties.fontitalic = primaryText.getAttribute("data-fontitalic");
    // if (this.properties?.fontresize?.[primaryText.getAttribute("name")]) textproperties.textclassname = this.properties?.fontresize?.[primaryText.getAttribute("name")];
    if (primaryText.dataset.fontresize && primaryText.dataset.fontresize != "") textproperties.textclassname = primaryText.dataset.fontresize;
    return {
        textproperties: textproperties,
    };
};

DiagramCreateUtil.setHighlightClass = function (colorClass) {
    return colorClass ? (colorClass.includes("alter") ? " titleColorBg " : colorClass.includes("secondary") ? " subtitleColorBg " : " transparentBg ") : " transparentBg ";
};

DiagramCreateUtil.setDiagramTitleSingleLine = function (diagramParent) {
    let diagramTitleHolder = diagramParent.querySelector("[name='diagramTitle']");
    let nodesHolder = diagramParent.querySelector("[name='nodesHolder']");
    if (diagramTitleHolder) {
        let diagramTitleStyle = window.getComputedStyle(diagramTitleHolder);
        let lineHeight = parseFloat(diagramTitleStyle?.lineHeight);
        let paddingTop = parseFloat(diagramTitleStyle?.paddingTop) || 0;
        let paddingBottom = parseFloat(diagramTitleStyle?.paddingBottom) || 0;
        diagramParent?.style?.setProperty("--diagramTitleSingleLine", lineHeight + "px");
        diagramParent?.style?.setProperty("--diagramTitleMaxHeight", "unset");
        nodesHolder.style.display = "none";
        let diagramTitleMaxHeight = lineHeight + paddingTop + paddingBottom;
        if (diagramTitleHolder.clientHeight >= lineHeight * 3 + paddingTop + paddingBottom) {
            diagramTitleMaxHeight = lineHeight * 3 + paddingTop + paddingBottom;
        } else if (diagramTitleHolder.clientHeight >= lineHeight * 2 + paddingTop + paddingBottom) {
            diagramTitleMaxHeight = lineHeight * 2 + paddingTop + paddingBottom;
        }
        nodesHolder.style.removeProperty("display");
        diagramParent?.style?.setProperty("--diagramTitleMaxHeight", diagramTitleMaxHeight + "px");
    }
};

/**
 * Author:  Bala Krishnan K.
 **/

"use strict";

function DiagramUtils() {}

DiagramUtils.prototype.constructor = DiagramUtils;

DiagramUtils.createColorClass = function (strValue) {
    let color = "cls";
    let arrSplit = strValue.split("-");
    arrSplit.forEach((element) => {
        color = color + DiagramUtils.capitalize(element);
    });
    return color;
};

DiagramUtils.setColorClass = function (holder, nodeObj, globalMoodsData, colorValue = "", type = "color") {
    if (nodeObj && nodeObj.colorClass) holder.classList.add(DiagramUtils.createColorClass(nodeObj.colorClass));
    else if (globalMoodsData && globalMoodsData.theme && globalMoodsData.theme.textcolormapping && globalMoodsData.theme.textcolormapping[colorValue]) {
        holder.style[type] = globalMoodsData.theme.textcolormapping[colorValue];
    }
};

DiagramUtils.setContentColorClass = function (holder, diagramProps) {
    if (diagramProps.nodecontentcolor) holder.classList.add(DiagramUtils.createColorClass(diagramProps.nodecontentcolor));
};

DiagramUtils.getMultiContentIndex = function (index, position = null) {
    let arrIndex = index.split(",");
    if (position != null) {
        return arrIndex[position];
    } else {
        return arrIndex;
    }
};

DiagramUtils.getDefaultDataForLogoList = function (arrDefaults, diagramProps) {
    let logoListData = DiagramUtils.getObjectFromName(diagramProps.supportedNodes, "logoListHolder");
    if (logoListData && logoListData.componentType) {
        return arrDefaults?.[logoListData.componentType];
    }
    return diagramProps?.name?.includes("team") ? arrDefaults?.sociallogo : arrDefaults?.logo;
};

DiagramUtils.checkDiagramStyle = function (moodStyle, centerShape) {
    let diagramstyle = centerShape.diagramstyle ? centerShape.diagramstyle + "/" : moodStyle.diagramstyle ? moodStyle.diagramstyle + "/" : "solid/";
    return centerShape.value + (centerShape.restrictdiagramstyle || centerShape.value.endsWith(diagramstyle) ? "" : diagramstyle);
};

DiagramUtils.getSvgAssetId = function (centerShape, arrDiagramNode) {
    let isSingleAsset = centerShape.singleasset || false;
    let svgSuffix = !isSingleAsset ? arrDiagramNode.length + "node" : "";
    let svgId = centerShape.id + (centerShape.id.endsWith(svgSuffix) ? "" : svgSuffix);
    return svgId;
};

DiagramUtils.checkAppStaticUrl = function (imageURL, appStaticURL, diagramStyle) {
    return imageURL.startsWith("http") || imageURL.startsWith(appStaticURL) ? imageURL : appStaticURL + imageURL;
};

DiagramUtils.applyTextNodeProperties = function (titleNode, value, nodeObj, diagramProps, globalMoodData, defaultColor, primaryTextData) {
    if (value) {
        titleNode.innerHTML = value;
        TextHighLightUtils.updateHighlight(titleNode, value, titleNode.id);
        titleNode.setAttribute("data-oldtext", titleNode.innerHTML);
    }
    TextHighLightUtils.createHighlightColor?.("", titleNode, globalMoodData);
    DiagramCreateUtil.checkTextContrast(nodeObj, titleNode);
    if (primaryTextData) DiagramUtils.setTextProps(primaryTextData, titleNode);
    DiagramUtils.setContentColorClass(titleNode, diagramProps);
    DiagramUtils.setColorClass(titleNode, nodeObj, globalMoodData, defaultColor);
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, titleNode);
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, titleNode.parentElement);
};

DiagramUtils.setTextProps = function (primaryTextData, titleNode) {
    if (primaryTextData?.textproperties?.lineheight) {
        titleNode.setAttribute("data-lineheight", primaryTextData.textproperties.lineheight);
        titleNode.style.lineHeight = parseFloat(primaryTextData.textproperties.lineheight) + "em";
    }

    if (primaryTextData?.textproperties?.letterspacing) {
        titleNode.setAttribute("data-letterspacing", primaryTextData.textproperties.letterspacing);
        titleNode.style.letterSpacing = parseFloat(primaryTextData.textproperties.letterspacing) + "em";
    }
    if (primaryTextData?.textproperties?.texttransform) {
        titleNode.setAttribute("data-texttransform", primaryTextData.textproperties.texttransform);
        titleNode.style.textTransform = primaryTextData.textproperties.texttransform;
    }
    if (primaryTextData?.textproperties?.textcolor) {
        titleNode.setAttribute("data-textcolor", primaryTextData.textproperties.textcolor);
        titleNode.style.setProperty("color", primaryTextData.textproperties.textcolor, "important");
    }
    if (primaryTextData?.textproperties?.textalign) {
        titleNode.setAttribute("data-textalign", primaryTextData.textproperties.textalign);
        titleNode.style.textAlign = primaryTextData.textproperties.textalign;
    }
    if (primaryTextData?.textproperties?.textgrayscale) {
        titleNode.setAttribute("data-textgrayscale", primaryTextData.textproperties.textgrayscale);
        titleNode.style.filter = "grayscale(1)";
    }
    if (primaryTextData?.textproperties?.fontbold) {
        titleNode.setAttribute("data-fontbold", primaryTextData.textproperties.fontbold);
        titleNode.style.fontWeight = primaryTextData.textproperties.fontbold;
    }
    if (primaryTextData?.textproperties?.fontitalic) {
        titleNode.setAttribute("data-fontitalic", primaryTextData.textproperties.fontitalic);
        titleNode.style.fontStyle = primaryTextData.textproperties.fontitalic;
    }
    if (primaryTextData?.textproperties?.textopacity && primaryTextData?.textproperties?.textopacity != 1) {
        titleNode.setAttribute("data-customopacity", primaryTextData.textproperties.textopacity);
        titleNode.setAttribute("data-textopacity", primaryTextData.textproperties.textopacity);
        titleNode.style.opacity = primaryTextData.textproperties.textopacity;
    }
    if (primaryTextData?.textproperties?.textsize) {
        titleNode.setAttribute("data-textsize", primaryTextData.textproperties.textsize);
        titleNode.style.fontSize = primaryTextData.textproperties.textsize;
    }
};

DiagramUtils.quillToOutlineParser = function (arrMainMatrix) {
    let rowMatrix = [];
    let columnMatrix = [];
    let arrMatrix = [];
    for (let index = 0; index < arrMainMatrix.length; index++) {
        const objDataMain = arrMainMatrix[index];
        if (objDataMain.matrix) {
            arrMatrix = arrMatrix.concat(objDataMain.matrix);
        } else {
            arrMatrix.push(objDataMain);
        }
    }
    for (let i = 0; i < arrMatrix.length; i++) {
        let objData = arrMatrix[i];
        if (objData.indent == null) {
            columnMatrix = [];
            columnMatrix.push({ value: objData.value, type: objData.type || "text", subdata: objData.subdata, icon: objData.icon, header: objData.header });
            rowMatrix.push({ matrix: columnMatrix });
            if (i == arrMatrix.length - 1) columnMatrix = [];
        } else {
            columnMatrix.push({ value: objData.value, type: objData.type || "text", indent: objData.indent, subdata: objData.subdata, icon: objData.icon, header: objData.header });
        }
    }
    if (rowMatrix.length == 0 && columnMatrix.length > 0) rowMatrix.push({ matrix: columnMatrix });
    return rowMatrix;
};

DiagramUtils.outlineToQuillParser = function (rowMatrix) {
    let newRowMatrix = [];
    for (let i = 0; i < rowMatrix.length; i++) {
        let objData = rowMatrix[i];
        let isFirstIndent = true;
        for (let j = 0; j < objData.matrix.length; j++) {
            let item = JSON.parse(JSON.stringify(objData.matrix[j]));
            let contentType = item.hasOwnProperty("contenttype") && item?.contenttype != "primary" && item?.contenttype != "secondary" && item?.contenttype != "text";
            if (!contentType) {
                item.indent = item.indent ? item.indent : isFirstIndent ? null : "1";
                item.subdata = item.subdata;
                item.icon = item.icon;
                item.header = item.header;
                isFirstIndent = false;
                item.multitextdata = true;
                newRowMatrix.push(item);
            }
        }
    }
    return newRowMatrix;
};

DiagramUtils.addClassesFromMenu = function (objClass, parent) {
    if (parent && objClass) {
        let name = parent.getAttribute("name");
        if (name && objClass[name]) {
            let strClasses = objClass[name].trim();
            parent.className = strClasses + " " + parent.className;
        }
    }
};

DiagramUtils.getTextHighlightParentNode = function (slideContent, targetid, targetNode) {
    let slideType = slideContent?.dataset?.slidetype || "";
    if (slideType == "diagram") {
        targetNode = slideContent ? slideContent.querySelector("[id='" + targetid + "']") : null;
        if (targetNode?.nodeName?.toLowerCase() != "div") targetNode = ExportUtils.getParentNodeByName("div", targetNode);
        if (targetNode?.getAttribute("name") == "subTitleHolder") {
            targetNode = targetNode.firstElementChild;
        }
        return targetNode;
    } else return targetNode;
};

DiagramUtils.capitalize = function (strValue) {
    return strValue.charAt(0).toUpperCase() + strValue.slice(1);
};

DiagramUtils.removelinebreaks = function (str) {
    return str.replace(/[\r\n]+/gm, "");
};

DiagramUtils.createRBGColor = function (color, index, opacity) {
    return color.replace(/\s/g, "") == "accent" ? "rgba(var(--item" + (index + 1) + "-color-rgb)," + opacity + ")" : "rgba(var(--" + (color == "background" ? "bg" : "dark") + "-color-rgb)," + opacity + ")";
};

DiagramUtils.createRBGAllColor = function (color, index, opacity) {
    return color.replace(/\s/g, "") == "accent" ? "rgba(var(--" + color + (index + 1) + "-color-rgb)," + opacity + ")" : "rgba(var(--" + color + "-color-rgb)," + opacity + ")";
};

DiagramUtils.getRndInteger = function (min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
};

DiagramUtils.getSVGfromString = function (data) {
    let tempDiv = document.createElement("div");
    tempDiv.innerHTML = data;
    return tempDiv.querySelector("svg");
};

DiagramUtils.extractNumber = function (str) {
    if (str) {
        str = str.toString();
        let num = str && str.replace(/[^0-9]/g, "");
        return num && num != "" ? parseInt(num, 10) : "";
    } else return "";
};

DiagramUtils.getAssetNameFromPath = function (strPath) {
    return strPath != null && strPath != "" ? strPath.substring(strPath.lastIndexOf("/") + 1, strPath.lastIndexOf(".")) : "";
};

DiagramUtils.checkFloaterOption = function (value, floateroptionsdisable) {
    let options = floateroptionsdisable || [];
    return !options.includes(value);
};

DiagramUtils.setCustomItemColor = function (parentNode, arrTintArray, arrIndex, colorIndex, isTakeAway = false) {
    colorIndex = colorIndex > 12 ? colorIndex % 12 : colorIndex;
    let tintIndex = arrTintArray && arrTintArray.length > 0 && arrTintArray[arrIndex] ? arrTintArray[arrIndex] : colorIndex;
    parentNode.classList.add("accent" + tintIndex);
    parentNode.style.setProperty("--customItemColor", "var(--item" + tintIndex + "-color-rgb)", isTakeAway ? "important" : "");
    parentNode.style.setProperty("--customContrastColor", "var(--contrast" + tintIndex + "-rgb)", isTakeAway ? "important" : "");
    parentNode.style.setProperty("--customThemeColor", "var(--theme" + tintIndex + "-color-rgb)", isTakeAway ? "important" : "");
};

DiagramUtils.restrictMaxLines = function (node, maxlines = 1) {
    let lineHeight = parseFloat(window.getComputedStyle(node).lineHeight);
    node.parentElement.style.setProperty("max-height", lineHeight * maxlines + "px");
};

DiagramUtils.addClassNames = function (strClassName, parent) {
    if (strClassName) {
        let arrClass = strClassName.trim().split(" ");
        arrClass.forEach((element) => {
            if (element && element != "") parent.classList.add(element);
        });
    }
};

DiagramUtils.toggleSecondaryPlaceholders = function (properties, property, value = false) {
    // let arrSecHolders = ["enablesecplaceholder", "sequencetext", "button"];
    let arrSecHolders = ["enablesecplaceholder", "button"];
    arrSecHolders.forEach((element) => {
        properties[element] = element == property ? value : false;
    });
    return properties;
};

DiagramUtils.toggleConnectors = function (properties, property, value = false) {
    let arrSecHolders = ["hasconnector", "seperatorline"];
    arrSecHolders.forEach((element) => {
        properties[element] = element == property ? value : false;
    });
    return properties;
};

DiagramUtils.getSeqMoodStyle = function (moodData = {}, properties = {}, seqNumber, index, length = null) {
    try {
        properties.sequencetextstart = properties.sequencetextstart || 1;
        let strContent = index + (properties.sequencetextstart - 1);
        if (length != null && properties.sequencetextreverse) {
            strContent = properties.sequencetextstart - 1 + parseInt(length) - index + 1;
            if (properties.ignorefirstrow) strContent -= 1; // Only for table
        }
        if (moodData?.sequenceprefix || moodData?.sequencesuffix) {
            let prefix = DiagramUtils.setSeqStyle(moodData.sequenceprefix.style, strContent, true);
            let suffix = DiagramUtils.setSeqStyle(moodData.sequencesuffix.style, strContent, true);
            let mainStyle = moodData.sequencemain && moodData.sequencemain.style;
            let mainContent = mainStyle && (mainStyle == "abc" || mainStyle == "ABC") ? DiagramUtils.getABCStyle(strContent - 1, mainStyle == "ABC") : strContent;
            if (properties.ignorefirstrow) mainContent -= 1; // Only for table
            strContent = prefix + mainContent + suffix;
        }
        return strContent;
    } catch (error) {
        return index;
    }
};

DiagramUtils.getSeqMoodStyleForQuill = function (moodData, index) {
    try {
        let strContent = index;
        if (moodData.sequenceprefix || moodData.sequencesuffix) {
            let prefix = DiagramUtils.setSeqStyle(moodData.sequenceprefix.style, strContent, true);
            let suffix = DiagramUtils.setSeqStyle(moodData.sequencesuffix.style, strContent, true);
            let mainStyle = moodData.sequencemain && moodData.sequencemain.style;
            let mainContent = mainStyle && (mainStyle == "abc" || mainStyle == "ABC") ? DiagramUtils.getABCStyle(strContent - 1, mainStyle == "ABC") : strContent;
            strContent = prefix + mainContent + suffix;
        }
        return strContent;
    } catch (error) {
        return index;
    }
};

DiagramUtils.setEnableDisableClassNames = function (diagramParent, property, value, hasEnabledClass = false) {
    if (value) {
        diagramParent.classList.remove("cls" + property + "disable");
        if (hasEnabledClass) diagramParent.classList.add("cls" + property + "enable");
    } else {
        diagramParent.classList.add("cls" + property + "disable");
        if (hasEnabledClass) diagramParent.classList.remove("cls" + property + "enable");
    }
};

DiagramUtils.checkSupportedHolder = function (supportedNodes, property) {
    let strSupportedNodes = JSON.stringify(supportedNodes);
    if (strSupportedNodes.includes(property)) {
        return true;
    }
    return false;
};

DiagramUtils.setSeqStyle = function (style, index, filterStyle = false) {
    let strContent = "";
    if (style == "0" && index < 10) strContent = style + (filterStyle ? "" : index);
    else if (style == "abc" || style == "ABC") strContent = DiagramUtils.getABCStyle(index - 1, style == "ABC");
    else if (style != "0") strContent = style + (filterStyle ? "" : index);
    return strContent;
};

DiagramUtils.getSeperatorObject = function (basicgraphics, className) {
    if (!basicgraphics) return null;
    let seperator = basicgraphics;
    Constants.Value.connectorClasses.forEach((element) => {
        if (element.startsWith(className) && basicgraphics[element.split("-")[1]]) seperator = basicgraphics[element.split("-")[1]];
    });
    return seperator;
};

DiagramUtils.isDiagramTitleSupported = function (className, nodeClassName, floateroptionsdisable) {
    let isDiagramTitleSupported = false;
    Constants.Value.diagramTitleClasses.forEach((element) => {
        if (element.startsWith(className)) isDiagramTitleSupported = true;
    });

    if (isDiagramTitleSupported) {
        isDiagramTitleSupported = false;
        Constants.Value.diagramTitleNodeClasses.forEach((element) => {
            if (element.startsWith(nodeClassName)) isDiagramTitleSupported = true;
        });
    }
    return isDiagramTitleSupported && DiagramUtils.checkFloaterOption("diagramtitle", floateroptionsdisable);
};

DiagramUtils.isConnectorTextSupported = function (className, nodeProps) {
    let isConnectorTextSupported = false;
    Constants.Value.connectorTextClasses.forEach((element) => {
        if (element.startsWith(className) && nodeProps.connectortext) isConnectorTextSupported = true;
    });
    return isConnectorTextSupported;
};

DiagramUtils.isConnectorSupported = function (className, nodeProps) {
    let isConnectorSupported = false;
    Constants.Value.connectorClasses.forEach((element) => {
        if (element.startsWith(className) && nodeProps.connector) isConnectorSupported = true;
    });
    return isConnectorSupported;
};

DiagramUtils.getABCStyle = function (index, isUpperCase) {
    let strAlphabet = "abcdefghijklmnopqrstuvwxyz";
    let arrAbc = isUpperCase ? strAlphabet.toUpperCase().split("") : strAlphabet.split("");
    return arrAbc[index];
};

DiagramUtils.calcSlideScale = function (parent, appmode = "") {
    let slideContainer = parent?.parentElement?.parentElement;
    if (slideContainer) {
        let slideRect = slideContainer.getBoundingClientRect();
        let scale = 1;
        let widgetElement = document.getElementsByClassName("widgetView")?.[0];
        let widgetElementStyle = widgetElement ? window.getComputedStyle(widgetElement) : null;
        let zoom = widgetElementStyle?.zoom;
        if (widgetElement && appmode.toLowerCase() == "present") scale = widgetElementStyle?.transform;
        else scale = window.getComputedStyle(parent.parentElement.parentElement).transform;
        if (scale && scale != "" && scale != "none") {
            return Number(scale.substring(7, scale.indexOf(",")));
        } else if (zoom && zoom != "" && zoom != "none" && slideRect.width == 0) {
            let intScale = zoom;
            intScale = intScale.split("%")[0];
            intScale = intScale ? intScale : 1;
            return intScale;
        } else {
            let slideRect = slideContainer.getBoundingClientRect();
            return Math.min(slideRect.width / Constants.Value.slideWidth, slideRect.height / Constants.Value.slideHeight);
        }
    } else return 1;
};

DiagramUtils.svgPoint = function (svg, element, connector) {
    let connectorBoundingRect = connector?.getBoundingClientRect();
    let x = connectorBoundingRect?.left;
    let y = connectorBoundingRect?.top;
    var pt = svg.createSVGPoint();
    pt.x = x;
    pt.y = y;
    // console.log(pt.matrixTransform(element.getScreenCTM().inverse()));
    return pt.matrixTransform(element.getCTM());
};

DiagramUtils.calcSVGBoundsDifference = function (attrib, parent, child, svg) {
    return DiagramUtils.svgPoint(svg, svg, child)?.[attrib] - DiagramUtils.svgPoint(svg, svg, parent)?.[attrib];
};

DiagramUtils.getSecondaryType = function (type) {
    switch (type) {
        case "bulletlist":
            return "disc";
        case "numberedlist":
            return "decimal";
        case "iconlist":
            return "icon";
        case "checklist":
            return "check";
        case "numberlist":
            return "number";
        case "logolist":
            return "logo";
        case "imagelist":
            return "image";
        case "paragraph":
            return "none";
        default:
            return type;
    }
};

DiagramUtils.getAbsCoordOfElement = function (rect, parent, scale) {
    let boundingRect = rect.getBoundingClientRect();
    let x = Math.abs(DiagramNodeUtils.calcBoundsDifference("x", rect, parent)) / scale;
    let y = Math.abs(DiagramNodeUtils.calcBoundsDifference("y", rect, parent)) / scale;
    let width = boundingRect.width / scale;
    let height = boundingRect.height / scale;
    return { x: x, y: y, width: width, height: height };
};

DiagramUtils.getBBoxCoordOfElement = function (rect, parent, scale) {
    let item = { x: 0, y: 0 };
    let itemParent = rect;
    while (itemParent && itemParent != parent) {
        item.x = itemParent.getBBox().x + item.x;
        item.y = itemParent.getBBox().y + item.y;
        itemParent = itemParent.parentElement;
    }
    return { x: item.x, y: item.y };
};

DiagramUtils.getCoordOfSVG = function (targetX, targetY, rect, inverseMatrixTransform) {
    var x = targetX;
    var y = targetY;

    // Build a vector
    // and multiply it by the inverse transformation matrix
    var vector = math.matrix([x, y, 0, 1]);
    var result = math.multiply(inverseMatrixTransform, vector);
    // This red crosshair shows the clicked position
    // in local coordinates via the values calculated
    // by multiplying by the inverse transformation matrix.
    return { x: result.get([0]), y: result.get([1]) };
};

DiagramUtils.updateResize = function (diagramParent, sizevalue, nodeProps, properties) {
    diagramParent.style.setProperty("--resizeValue", "var(--" + sizevalue + "Size)");
    diagramParent.style.setProperty("--contentResizeMH", "calc(var(--originalresizeheight) * var(--" + sizevalue + "Size))");
    diagramParent.style.setProperty("--minContentSize", "var(--" + sizevalue + "Size)");
};

DiagramUtils.restrictContentOptions = function (arrFloaterDisable, supportedNodes, iconRect) {
    let arrContentOptions = ["graphicimage", "graphiclogo", "graphicicon", "graphicnumber", "graphictext", "graphicsequence"];
    arrFloaterDisable = arrFloaterDisable.filter((x) => !arrContentOptions.includes(x));

    let jsonStr = supportedNodes ? JSON.stringify(supportedNodes) : "";
    if (!jsonStr.includes("image")) arrFloaterDisable.push("graphicimage");
    if (!jsonStr.includes("islogo")) arrFloaterDisable.push("graphiclogo");
    if (!jsonStr.includes("icon") && !iconRect) arrFloaterDisable.push("graphicicon");
    if (!jsonStr.includes("value")) arrFloaterDisable.push("graphicnumber");
    if (!jsonStr.includes("textTitleHolder")) arrFloaterDisable.push("graphictext");
    if (!jsonStr.includes("seqTitleHolder") && !iconRect) arrFloaterDisable.push("graphicsequence");
    return arrFloaterDisable;
};

DiagramUtils.getGraphicTypeForAiSearch = function (properties, type, targetid = null) {
    let menuName = properties?.name;
    let isTeam = menuName && (menuName.includes("team") || targetid?.includes("authorName")) && type == "image";
    let graphicData = properties?.graphicData;
    return graphicData ? graphicData.type : isTeam ? "person" : type;
};

DiagramUtils.searchMultipleAICall = function (arrDiagramNode, type, properties, globalMoodData, searchCallBack, appBaseURL, appStaticURL, searchMultipleAICallback = null, searchFailureCallBack = null) {
    try {
        if (!type || type == "" || type == "none" || type == "text" || type == "number") return;
        let arrSearchText = [];
        let arrIndex = [];
        let iconStyle = (globalMoodData && (type == "illustration" ? globalMoodData.illustrationstyle : globalMoodData.iconstyle)) || "illustrative";
        let searchType = DiagramUtils.getGraphicTypeForAiSearch(properties, type);
        let isQuote = arrDiagramNode[0]?.quoteShape;
        if (isQuote) return;
        arrDiagramNode.forEach((element) => {
            if (element.objData?.content?.needAssetUpdate) {
                element.objData.content.needAssetUpdate = false;
                let designation = searchType == "person" ? element?.objData?.author?.designation?.value : null;
                arrSearchText.push(element?.objData?.content?.assetText + (designation ? "$$" + designation : ""));
                arrIndex.push(element?.index);
            }
        });
        // if (objContentLoad) objContentLoad = { length: arrIndex.length, arrLoadComplete: [] };
        if (arrSearchText.length > 0) {
            AISearchUtils.searchIcon(
                appBaseURL,
                { text: arrSearchText, type: searchType, style: type == "illustration" || type == "icon" ? iconStyle : null, imgtype: searchType != "person" ? "nodes" : null },
                searchMultipleAICallback || DiagramUtils.searchMultipleAICallback,
                {
                    arrDiagramNode: arrDiagramNode,
                    staticURL: appStaticURL,
                    arrIndex,
                    type,
                    searchCallBack,
                    properties,
                },
                searchFailureCallBack
            );
        }
    } catch (error) {
        console.log("Error in Search AI : " + error);
    }
};

DiagramUtils.searchMultipleAICallback = function (objResponse, objParams, searchFailureCallBack) {
    let { arrDiagramNode, staticURL, arrIndex, type, searchCallBack, properties, objContentLoad } = objParams;
    objResponse?.data?.forEach((objData, objIndex) => {
        if (objData.status == 0) {
            let index = arrIndex[objIndex];
            let nodeGroup = arrDiagramNode[index].nodeGroup;
            let nodeData = arrDiagramNode[index]?.objData?.content;
            let content = nodeGroup?.querySelector("[data-holder-type='primary']");
            let assetNode = content?.querySelector("[data-id='logoNode']") || content?.querySelector("[data-id='imageNode']") || content?.querySelector("[data-id='iconNode']");
            if (!assetNode) {
                content = nodeGroup?.querySelector("[name='contentNode']");
                assetNode = content?.querySelector("[data-id='logoNode']") || content?.querySelector("[data-id='imageNode']") || content?.querySelector("[data-id='iconNode']");
            }
            if (assetNode && assetNode.parentElement && nodeData.assetText) {
                // nodeData.needAssetUpdate = false;
                assetNode.parentElement.setAttribute("data-node-graphic-text", nodeData.assetText);
                // let type = assetNode.parentElement.dataset.nodeContentType;
                let updateProps = objIndex == objResponse.data.length - 1;
                type = assetNode?.dataset?.contentType || type;
                DiagramUtils.searchAICallback({ data: [objData] }, { staticURL, contentNode: assetNode, index: index, type, searchCallBack, properties, updateProps });
            }
        } else {
            searchFailureCallBack?.(objData);
        }
    });
    if (arrDiagramNode?.length != objResponse?.data?.length) {
        let remaingLength = arrDiagramNode?.length - objResponse?.data?.length;
        for (let index = 0; index < remaingLength; index++) {
            searchFailureCallBack?.(objResponse);
        }
    }
};

DiagramUtils.searchAIcall = function (type, objData, assetText, properties, globalMoodData, assetNode, index, searchCallBack, appBaseURL, appStaticURL) {
    let iconStyle = (globalMoodData && (type == "illustrations" ? globalMoodData.illustrationstyle : globalMoodData.iconstyle)) || "illustrative";
    let searchType = DiagramUtils.getGraphicTypeForAiSearch(properties, type);
    let designation = searchType == "person" ? objData?.author?.designation?.value : null;
    AISearchUtils.searchIcon(
        appBaseURL,
        {
            text: [assetText.trim() + (designation ? "$$" + designation : "")],
            type: searchType,
            style: type == "illustrations" || type == "icon" ? iconStyle : null,
            imgtype: properties?.graphicData?.imgtype ? properties?.graphicData?.imgtype : searchType != "person" ? "nodes" : null,
        },
        DiagramUtils.searchAICallback,
        { staticURL: appStaticURL, contentNode: assetNode, index, type, searchCallBack, properties }
    );
};

DiagramUtils.searchAICallback = function (objResponse, objParams) {
    let { staticURL, contentNode, index, type, searchCallBack, properties, updateProps = true, objContentLoad } = objParams;
    objResponse = objResponse?.data?.[0];
    let variants = objResponse.variants || objResponse.logos || (objResponse.url ? [{ url: objResponse.url, type: "logo" }] : null);
    if (objResponse.status == 0) {
        if (variants && type == "logo" && variants.length > 0) {
            DiagramNodeUtils.setLogoUrlData(contentNode.parentElement, variants);
            let logoStyle = properties?.logostyle || "logo";
            let defaultLogoStyle = variants[0].type;
            let content = { type: type, value: variants[0].url, searchword: objResponse.searchword || "" };
            variants.forEach((element) => {
                if (element.type == logoStyle && element.url != "") {
                    defaultLogoStyle = logoStyle;
                    content.value = element.url;
                }
            });
            if (!defaultLogoStyle.includes("logo")) content.logocontrast = false;
            if (searchCallBack) searchCallBack(content, type, index, contentNode.parentElement.getAttribute("id"), updateProps);
        } else if (type == "logo" && objResponse.logo && objResponse.logo.url && objResponse.logo.url != "") {
            DiagramNodeUtils.setLogoUrlData(contentNode.parentElement, [objResponse.logo]);
            let content = { type: type, value: objResponse.logo.url, searchword: objResponse.searchword || "" };
            if (searchCallBack) searchCallBack(content, type, index, contentNode.parentElement.getAttribute("id"), updateProps);
        } else if (type == "image" && objResponse.url && objResponse.url != "") {
            let content = { type: type, value: objResponse.url, id: objResponse.icon, searchword: objResponse.searchword || "" };
            if (searchCallBack) searchCallBack(content, type, index, contentNode.getAttribute("id"), updateProps);
        } else if (type == "icon" && objResponse.url && objResponse.url != "") {
            let content = { type: type, value: staticURL + objResponse.url, id: objResponse.icon, searchword: objResponse.searchword || "" };
            if (objResponse.svg) {
                content.data = objResponse.svg;
                DiagramAssetLoader.addSVGtoDefs(content, true, document.body);
                if (searchCallBack) searchCallBack(content, type, index, contentNode.getAttribute("id"), updateProps);
            } else {
                DiagramAssetLoader.oneTimeDownload(content, true, document.body)
                    .then((svgData) => {
                        content = { type: type, value: objResponse.url, id: objResponse.icon };
                        if (searchCallBack) searchCallBack(content, type, index, contentNode.getAttribute("id"), true);
                    })
                    .catch((error) => {
                        console.log("Error in Icon Search : " + error);
                    });
            }
        } else if ((type == "illustration" || type == "illustrations") && objResponse.url && objResponse.url != "") {
            let content = { type: type, value: staticURL + objResponse.url, id: objResponse.icon, searchword: objResponse.searchword || "" };
            if (objResponse.svg) {
                if (searchCallBack) searchCallBack({ data: objResponse.svg });
            } else {
                DiagramAssetLoader.oneTimeDownload(content, true, document.body)
                    .then((svgData) => {
                        if (searchCallBack) searchCallBack(svgData);
                    })
                    .catch((error) => {
                        console.log("Error in Illustration Search : " + error);
                    });
            }
        } else {
            if (searchCallBack) searchCallBack(objResponse);
        }
    }
};

DiagramUtils.checkForPlaceholderImage = function (path) {
    return path.includes("teamimage.png") || path.includes("placeholder.png") || path.includes("logoplaceholder_landscape.png");
};

DiagramUtils.checkForPlaceholderIcon = function (path) {
    return path.includes("placeholder.svg");
};

DiagramUtils.isVerticalListAsset = function (graphicName) {
    return graphicName.includes("ver-num-tx") || graphicName.includes("ver-ckd-tx") || graphicName.includes("ver-bul-tx");
};

DiagramUtils.isLogoAsset = function (name) {
    return name.includes("hor-lg") || name.includes("ver-lg") || name.includes("grd-lg") || name.includes("clientele-lg");
};

DiagramUtils.isTextOnlyAsset = function (name) {
    return name.includes("hor-tx") || name.includes("ver-tx") || name.includes("grd-tx");
};

// For Undo/Redo

DiagramUtils.getOldPropertyValue = function (property, newValueObj, diagramParent, diagramInstance) {
    let valueObj = JSON.parse(JSON.stringify(newValueObj));
    let properties = diagramInstance.diagramData.properties;
    let target = diagramParent.querySelector("[id='" + newValueObj.targetid + "']");
    if (!target && newValueObj?.targetid?.includes("centerHolderParent") && diagramInstance?.bgDeviceDiv) {
        target = diagramInstance.bgDeviceDiv.querySelector("[id='" + newValueObj.targetid + "']");
    }

    let index = newValueObj && newValueObj.hasOwnProperty("index") ? newValueObj.index : (target && target.dataset.index) || null;
    let nodeGroup = index != null ? diagramParent.querySelector("[id='nodeGroup" + index + "']") : null;
    if (!nodeGroup && target && target?.dataset?.id == "centerHolderParent") nodeGroup = target;
    let contentType = newValueObj?.objDetails?.contenttype || "";
    let targetNode = nodeGroup?.querySelector("[name='" + contentType + "']") || nodeGroup?.querySelector("[data-type='" + contentType + "']");
    if (contentType == "microchart") {
        targetNode = nodeGroup?.querySelector("[name='microchartNode']");
    }
    if (!targetNode) targetNode = target;
    targetNode = targetNode || target;
    targetNode = DiagramUtils.validateTargetNode(targetNode);
    let textNodeStyle = targetNode && valueObj?.group?.includes("textproperties") ? window.getComputedStyle(targetNode) : "";
    switch (property) {
        case "DIAGRAM_ANIMATION":
            let oldAnimation = diagramParent.parentElement.dataset.animationtype || "all";
            valueObj.value = DiagramUtils.fullAnimationName(oldAnimation);
            break;
        case "DIAGRAM_SECONDARY_TEXT":
            valueObj.value = properties.secondarytext;
            break;
        case "DIAGRAM_PRIMARY_TEXT":
            valueObj.value = properties.primarytext;
            break;
        case "DIAGRAM_LABEL":
            valueObj.value = properties.label;
            break;
        case "DIAGRAM_SUBTEXT":
            valueObj.value = properties.subtext;
            break;
        case "DIAGRAM_QUOTE":
            valueObj.value = properties.quote;
            break;
        case "basewidth":
        case "topwidth":
            valueObj.value = diagramParent.dataset[property];
            break;
        case "NODE_LINK":
        case "selectedtextlinkurl":
            valueObj.parent = newValueObj.parent;
            valueObj.operation = DiagramUtils.getNodeLinkValues(newValueObj.parent, newValueObj.operation);
            break;
        case "LIST_STYLE":
            let nodeGroup1 = diagramParent.querySelector("[id='nodeGroup" + newValueObj.index + "']");
            let subList = nodeGroup1 ? nodeGroup1.getAttribute("data-sublist") || "none" : "none";
            valueObj.index = newValueObj.index;
            valueObj.property = DiagramUtils.getListStylevalue(subList);
            break;
        case "MULTITEXT_STYLE":
            let format = target.getAttribute("data-format") || "none";
            valueObj.property = format;
            break;
        case "DIAGRAM_SEPARATOR":
            valueObj.value = properties.connectorstyle;
            break;
        case "DIAGRAM_CONNECTOR":
            let customconnector = { style: properties.connectorstyle };
            let connector = diagramInstance.diagramParent.querySelector("[id='connector" + newValueObj.index + "']");
            if (connector && connector.dataset.customconnectorstyle) {
                customconnector.style = connector.dataset.customconnectorstyle;
            }
            valueObj.customconnector = customconnector;
            valueObj.index = newValueObj.index;
            valueObj.targetid = connector.id;
            break;
        case "DIAGRAM_VALUE_FORMAT":
            valueObj.value = properties.valueformat;
            let arrValueText = diagramInstance.diagramParent.querySelectorAll("[name='numberNode']");
            let arrValueOld = [];
            let arrValueNew = [];
            arrValueText.forEach((element) => {
                arrValueOld.push(element.dataset.oldtext || element.innerHTML);
                arrValueNew.push(element.innerHTML);
            });
            valueObj.arrValueOld = arrValueOld;
            valueObj.arrValueNew = arrValueNew;
            break;
        case "DIAGRAM_LOGO_SIZE":
            valueObj.value = properties.logosize;
            break;
        case "DIAGRAM_IMAGE_SIZE":
            valueObj.value = properties.imagesize;
            break;
        case "DIAGRAM_NUMBER_SIZE":
            valueObj.value = properties.numbersize;
            break;
        case "DIAGRAM_ICON_SIZE":
            valueObj.value = properties.iconsize;
            break;
        case "DIAGRAM_SECONDARY_PLACEHOLDER":
            valueObj.value = properties.secondaryplaceholder;
            break;
        case "DIAGRAM_BUTTON":
            valueObj.value = properties.button;
            break;
        case "overlayopacity":
            let oldOpacity = diagramInstance.diagramParent.style.getPropertyValue("--overlaydiagramopacity");
            valueObj.value.val = oldOpacity == "" ? 100 : oldOpacity * 100;
            break;
        case "CHANGE_ICON":
            let elementId = newValueObj.elementId;
            let element = diagramParent.querySelector("[id='" + elementId + "']");
            if (element) {
                let iconNode = element.dataset.id == "iconNode" ? element : elementId.includes("secondaryTextItem") ? element.parentElement.querySelector("[data-id='iconNode']") : element.querySelector("[data-id='iconNode']");
                if (iconNode) {
                    valueObj.id = iconNode.getAttribute("iconid");
                    valueObj.value = iconNode.getAttribute("iconpath");
                    valueObj.index = iconNode.getAttribute("data-index");
                    valueObj.elementId = elementId;
                }
            }
            break;
        case "changeasset":
            if (diagramInstance?.changeAssetOldData) valueObj = diagramInstance?.changeAssetOldData?.(valueObj);
            break;
        case "CHANGE_IMAGE":
            let imageId = newValueObj.target;
            let elementImg = diagramParent.querySelector("[id='" + imageId + "']");
            if (!elementImg && imageId?.includes("centerHolderParent") && diagramInstance?.bgDeviceDiv) {
                elementImg = diagramInstance.bgDeviceDiv.querySelector("[id='" + imageId + "']");
            }
            if (elementImg) {
                let imageNode = elementImg.querySelector("[data-id='" + newValueObj.contentType + "Node']");
                if (imageNode) {
                    valueObj.value = imageNode.getAttribute("src") || imageNode.getAttribute("xlink:href");
                } else if (elementImg.tagName == "image") {
                    valueObj.value = elementImg.getAttribute("xlink:href");
                }
            }
            break;
        case "addnode":
            valueObj.property = "deleteimage";
            break;
        case "deleteimage":
            valueObj.property = "addnode";
            break;
        case "sgchangelogosize":
            let parentElement = target?.parentElement?.parentElement;
            if (!valueObj.dragging) {
                let oldValue = parentElement?.getAttribute("data-logoimagesize") || 0.5;
                oldValue = target.hasAttribute("data-tempvalue") ? target.getAttribute("data-tempvalue") : oldValue;
                valueObj.value = oldValue;
                target.removeAttribute("data-tempvalue");
            } else if (target && !target?.hasAttribute("data-tempvalue")) {
                //While Dragging we have to store starting value before drag..its for undo/redo operation
                let tempValue = parentElement.hasAttribute("data-logoimagesize") ? parentElement.getAttribute("data-logoimagesize") : 0.5;
                target.setAttribute("data-tempvalue", parseFloat(tempValue));
            }
            break;
        case "CHECK_BOX":
            valueObj.ischecked = newValueObj.target.getAttribute("data-ischecked") == "true";
            valueObj.index = newValueObj.index;
            valueObj.target = newValueObj.target;
            break;
        case "NONLINEAR_CONTENT_TYPE":
            if (diagramInstance.diagramData.properties.contenttype) {
                valueObj.value = diagramInstance.diagramParent.dataset.contenttype || "icon"; //{ type: diagramInstance.diagramParent.dataset.contenttype || "icon", selected: "true" };
                valueObj.selected = true;
            }
            break;
        case "DIAGRAM_TYPESWITCH":
            valueObj.value = properties.diagramcontent;
            break;
        case "fontsize":
            let name = targetNode.getAttribute("name") || "";
            let isCenterNode = (targetNode.dataset.focusParent && targetNode.dataset.focusParent.includes("centerHolder")) || false;
            let fontObjKey = isCenterNode ? "centernodefontresize" : "fontresize";
            valueObj.value = properties[fontObjKey]?.[newValueObj?.objDetails?.contenttype] || properties[fontObjKey]?.[name];
            break;
        case "DIAGRAM_NUMBER_START":
            valueObj.value = properties.sequencetextstart;
            break;
        case "commonnodesizechange":
            valueObj.value = diagramParent.dataset.commonnodesize;
            break;
        case "swapnext":
        case "swapprevious":
            valueObj.operation = "swapnext" ? "swapprevious" : "swapnext";
            break;
        case "highlightemphasize":
            let emphasizedNode = diagramParent.querySelector("[data-emphasize='true']");
            if (emphasizedNode) {
                valueObj.targetid = emphasizedNode.id;
                valueObj.value = true;
            } else valueObj.value = false;
            break;
        case "border":
            valueObj.value = properties.border || "none";
            break;
        case "textpositiongrid":
            valueObj.value = properties.position || "MM";
            break;
        case "layoutgriditem":
            valueObj.value.name = properties.gridlayoutname || "";
            break;
        case "contentChange":
            if (newValueObj.targetid.includes("center") && diagramInstance.diagramData.properties.centernodetype) {
                valueObj.value = diagramInstance.diagramParent.dataset.centernodetype || "icon";
            } else if (diagramInstance.diagramData.properties.contenttype) {
                valueObj.value.type = diagramInstance.diagramParent.dataset.contenttype || "icon";
            }
            break;
        case "projection":
            valueObj.value = diagramParent.dataset.hasOwnProperty("projectionindex");
            if (diagramParent.dataset.projectionindex) {
                valueObj.targetid = "iconHolder" + diagramParent.dataset.projectionindex;
            }
            break;
        case "sizechange":
            break;
        case "changesize":
            let nodeGroup2 = diagramParent.querySelector("[id='nodeGroup" + target.dataset.index + "']");
            valueObj.data = nodeGroup2.dataset.size || properties[contentType + "size"];
            break;
        //XY plot
        case "xyplotcontenttype":
        case "changecontentsize":
            let itemIndex = valueObj.index || index || target.dataset.index;
            let xyNodeInstance = diagramInstance?.arrDiagramNode.find((x) => x.parentNode.id == "nodeparent" + itemIndex);
            let jsonData = xyNodeInstance?.getJSONData();
            valueObj.index = itemIndex;
            valueObj.xyNodeData = jsonData;
            break;
        case "xyplot_xyplotstyle":
            valueObj.value = properties.xyplotstyle;
            break;
        // case "addxyplotnode":
        //     valueObj.property = "deletexyplotnode";
        //     break;
        case "xyplotselectedtextlinkurl":
            valueObj = DiagramUtils.getNodeLinkValues(diagramParent, newValueObj);
            break;
        case "deletexyplotnode":
            // valueObj.property = "addxyplotnode";
            let content = diagramParent.querySelector("[id='" + valueObj.targetid + "']");
            if (content) {
                let target = diagramParent.querySelector("[name='nodeparent'][data-index='" + content.dataset.index + "']");
                // valueObj.target = target;
                valueObj.targetInstance = diagramInstance.arrDiagramNode.filter((x) => x.parentNode.id == target.id)[0];
                valueObj.targetInstance.objData = valueObj.targetInstance.getJSONData();
            }
            break;
        case "yaxis":
            valueObj.value = diagramInstance.diagramParent.getAttribute("data-yaxis") == "true";
            break;
        case "xaxis":
            valueObj.value = diagramInstance.diagramParent.getAttribute("data-xaxis") == "true";
            break;
        case "DIAGRAM_TYPE":
            valueObj.value = diagramInstance.diagramParent.getAttribute("data-diagram_type");
            break;
        case "assetextratext":
            let assetNode = target.querySelector("[data-id='logoNode']") || target.querySelector("[data-id='imageNode']") || target.querySelector("[data-id='iconNode']");
            let value = assetNode.parentElement.getAttribute("data-node-graphic-text") || assetNode.getAttribute("iconid");
            valueObj.value.value = value;
            if (!value || value == "") valueObj.value.src = assetNode.getAttribute("src");
            // else if (valueObj.value?.src) valueObj.value.src = null;
            break;
        case "changelogostyle":
        case "inlineDiagramLogoTypeDropdownBtn":
            valueObj.dp.type = target.getAttribute("data-logotype");
            let imagenode = target.querySelector("[data-id='logoNode']");
            valueObj.value = imagenode.getAttribute("src");
            break;
        case "optionchange":
            break;
        case "dasharray":
            valueObj.value.data = diagramParent.dataset.dasharray || 0;
            valueObj.value.index = diagramParent.dataset.dasharrayindex || 0;
            break;
        case "strokewidth":
            valueObj.value.data = diagramParent.dataset.strokewidth || 2;
            valueObj.value.index = diagramParent.dataset.strokewidthindex || 1;
            break;
        case "connectorstart":
            valueObj.value.data = diagramParent.dataset.connectorstart || "none";
            valueObj.value.index = diagramParent.dataset.connectorstartindex || 0;
            break;
        case "connectorend":
            valueObj.value.data = diagramParent.dataset.connectorend || "none";
            valueObj.value.index = diagramParent.dataset.connectorendindex || 0;
            break;
        case "strectchange":
            valueObj.value = diagramParent.dataset.strech;
            break;
        case "textgrayscale":
            valueObj.value = textNodeStyle?.filter?.includes("grayscale(1)") ? true : false;
            break;
        case "textalign":
            valueObj.value = textNodeStyle?.textAlign;
            break;
        case "textopacity":
            if (!valueObj.dragging) {
                let oldValue = targetNode.hasAttribute("data-tempvalue") ? targetNode.getAttribute("data-tempvalue") : textNodeStyle?.opacity;
                valueObj.value = oldValue;
                targetNode.removeAttribute("data-tempvalue");
            } else if (!targetNode.hasAttribute("data-tempvalue")) {
                //While Dragging we have to store starting value before drag..its for undo/redo operation
                targetNode.setAttribute("data-tempvalue", textNodeStyle?.opacity);
            }
            // valueObj.value = textNodeStyle?.opacity;
            break;
        case "texttransform":
        case "textcase":
            valueObj.value = textNodeStyle?.textTransform;
            break;
        case "textsize":
            valueObj.value = textNodeStyle?.fontSize;
            break;
        case "textcolor":
            valueObj.value = textNodeStyle?.color;
            break;
        case "fontsize":
            valueObj.value = targetNode.getAttribute("data-fontresize");
            break;
        case "resettextprops":
            let targetNodeStyle = window.getComputedStyle(targetNode);
            valueObj.textTransform = targetNodeStyle.textTransform ? targetNodeStyle.textTransform : "none";
            valueObj.textColor = targetNodeStyle.textColor ? targetNodeStyle.textColor : "none";
            valueObj.textOpacity = targetNodeStyle.opacity ? targetNodeStyle.opacity : "none";
            valueObj.textAlign = targetNodeStyle.textAlign ? targetNodeStyle.textAlign : "none";
            valueObj.lineHeight = targetNodeStyle.lineHeight ? targetNodeStyle.lineHeight : "none";
            valueObj.letterSpacing = targetNodeStyle.letterSpacing ? targetNodeStyle.letterSpacing : "none";
            valueObj.filter = targetNodeStyle.filter ? targetNodeStyle.filter : "none";
            valueObj.fontSize = targetNodeStyle.fontSize ? targetNodeStyle.fontSize : "none";
            break;
        case "emojiselect":
            valueObj.value = { emoji: targetNode.textContent };
            break;
        case "imagestackselectedindex":
            valueObj.value = diagramInstance.pageIndex;
            break;
        case "DATE_FORMAT":
            valueObj.value = diagramInstance.diagramParent.dataset?.dateformat || "yyyy";
            break;
        default:
            // for boolean operations.
            valueObj.value = !newValueObj.value;
            break;
    }
    return valueObj;
};

DiagramUtils.restrictChangeOperation = function (property, valueObj) {
    return property != "QUILL_OPERATION" && !DiagramUtils.isQuillList(valueObj);
};

DiagramUtils.restrictUndoOperation = function (property, valueObj) {
    return property != "QUILL_OPERATION" && !(DiagramUtils.isQuillList(valueObj) && (property == "fontsize" || property == "LIST_STYLE"));
};

DiagramUtils.isQuillList = function (valueObj) {
    return valueObj?.objDetails?.targetID?.includes("ql-editor") || valueObj?.targetid?.includes("ql-editor") || valueObj?.targetid?.includes("quillicon");
};

DiagramUtils.setOperationProperty = function (property, valueObj, diagramParent, diagramInstance, isFromUndo = false) {
    if (valueObj?.operation?.targetid) {
        valueObj.targetid = valueObj.operation.targetid;
    }
    let target = (diagramInstance.diagramParent || diagramParent).querySelector("[id='" + valueObj.targetid + "']");
    if (!target && valueObj?.targetid?.includes("centerHolderParent") && diagramInstance?.bgDeviceDiv) {
        target = diagramInstance.bgDeviceDiv.querySelector("[id='" + valueObj.targetid + "']");
    }
    let index = valueObj && valueObj.hasOwnProperty("index") ? valueObj.index : (target && target.dataset.index) || null;
    let nodeGroup = index != null ? diagramParent.querySelector("[id='nodeGroup" + index + "']") : null;
    if (!nodeGroup && target && target?.dataset?.id == "centerHolderParent") nodeGroup = target;
    let logoGridIndex = parseInt(valueObj.targetid ? valueObj.targetid.substr(valueObj.targetid.length - 1) : 0) || 0;
    let contentType = valueObj?.objDetails?.contenttype || "";
    let targetNode = nodeGroup?.querySelector("[name='" + contentType + "']") || nodeGroup?.querySelector("[data-type='" + contentType + "']");
    if (contentType == "microchart") {
        targetNode = nodeGroup?.querySelector("[name='microchartNode']");
    }
    if (!targetNode) targetNode = target;
    let isQuillList = DiagramUtils.isQuillList(valueObj);
    if (isQuillList && (property == "fontsize" || property == "LIST_STYLE")) {
        let multiTextBox = diagramInstance?.arrDiagramNode[0]?.multiTextBox;
        if (multiTextBox) {
            multiTextBox.isFocusOutRestrict = true;
            multiTextBox.performOperation(valueObj);
            multiTextBox.isFocusOutRestrict = false;
        }
        return;
    }
    if (property.startsWith("xyplot_")) {
        property = property.replace("xyplot_", "");
        diagramInstance?.updateProperty?.(property, valueObj.value);
        diagramInstance?.initDiagramCreation();
        return;
    }
    if (valueObj.xyNodeData) {
        let itemIndex = valueObj.index || target.dataset.index;
        let xyNodeInstance = diagramInstance?.arrDiagramNode.find((x) => x.parentNode.id == "nodeparent" + itemIndex);
        // let xyNodeInstance = diagramInstance?.arrDiagramNode[itemIndex];
        valueObj.index = itemIndex;
        xyNodeInstance.objData = valueObj.xyNodeData;
        xyNodeInstance.parentNode.parentElement.remove();
        xyNodeInstance.initCreation();
        xyNodeInstance.updateNodeAttributes(itemIndex);
        return;
    }

    switch (property) {
        case "xyplotcontenttype":
            let xyNodeInstance = diagramInstance?.arrDiagramNode[target.dataset.index];
            xyNodeInstance?.changeContentType(valueObj);
            diagramInstance?.updateEvents();
            diagramInstance?.updateJSONData();
            diagramInstance?.updatePropsCallBack(target.id);
            break;
        case "changecontentsize":
            let xyInstance = diagramInstance?.arrDiagramNode[target.dataset.index];
            xyInstance?.changeContentSize(target, valueObj);
            break;
        case "emojiselect":
            diagramInstance?.arrDiagramNode[0]?.multiTextBox?.performOperation(valueObj);
            break;
        case "addmultinode":
            let arrIndex = DiagramUtils.getMultiContentIndex(target.dataset.index);
            if (isFromUndo) {
                diagramInstance.deleteNode(target.dataset.index, target);
            } else {
                diagramInstance.arrDiagramNode[arrIndex[0]].addNode(arrIndex[1]);
            }

            diagramInstance.arrDiagramNode[arrIndex[0]].updateNodeAttributes(arrIndex[0]);
            break;
        case "multicontentswitch":
            if (target) {
                if (target.id.includes("nodeGroup")) target = target?.querySelector("[name='" + contentType + "']") || target?.querySelector("[data-type='" + contentType + "']");
                let arrMultiIndex = DiagramUtils.getMultiContentIndex(target.dataset.index);
                let parentElement = target.parentElement;
                target.remove();
                diagramInstance.arrDiagramNode[arrMultiIndex[0]].arrMultiCellNode[arrMultiIndex[1]].createNodes({ [valueObj.data]: { arrSupportedContent: JSON.parse(target.dataset.arrsupportedcontent) } }, parentElement);
                diagramInstance.arrDiagramNode[arrMultiIndex[0]].updateNodeAttributes(arrMultiIndex[0]);
            }
            break;
        case "changelogocontrast":
            diagramInstance?.changeLogoContrast?.(valueObj, target, nodeGroup, logoGridIndex);
            break;
        case "sgchangelogosize":
            target.parentElement.parentElement.setAttribute("data-logoimagesize", valueObj.value);
            let largeHeight = window.getComputedStyle(target.parentElement).getPropertyValue("--logoheight") || 32;
            diagramInstance.arrDiagramNode[logoGridIndex].gridInstance.changeLogoSizeOnSlider(target, valueObj.value, valueObj.dragging, parseFloat(largeHeight) * 2);
            if (!valueObj.dragging) diagramInstance?.updateTextNodes?.();
            break;
        case "DIAGRAM_ANIMATION":
            let value = valueObj.value;
            var animationType = value.includes("all") ? "all" : value;
            animationType = value.includes("one") ? "one" : animationType;
            animationType = value.includes("off") ? "none" : animationType;
            animationType = value.includes("animateoneafteranother") ? "oaa" : animationType;
            diagramParent.parentElement.setAttribute("data-animationtype", animationType);
            diagramInstance.updateAnimationType();
            break;
        case "DIAGRAM_PRIMARY_TEXT":
            diagramInstance.showHidePrimary(valueObj.value);
            break;
        case "DIAGRAM_TITLE":
            diagramInstance?.showHideDiagramTitle(valueObj.value);
            break;
        case "DIAGRAM_MULTICONTENT_HEADER":
            diagramInstance.showHideMulticontentHeader(valueObj.value);
            break;
        case "DIAGRAM_SECONDARY_TEXT":
            diagramInstance.showHideSecondary(valueObj.value);
            break;
        case "DIAGRAM_LABEL":
            diagramInstance.showHideLabel(valueObj.value);
            break;
        case "DIAGRAM_SUBTEXT":
            diagramInstance.showHideSubtext(valueObj.value);
            break;
        case "DIAGRAM_QUOTE":
            diagramInstance.showHideQuote(valueObj.value);
            break;
        case "basewidth":
            diagramInstance.changeBaseWidth?.(valueObj);
            break;
        case "topwidth":
            diagramInstance.changeTopWidth?.(valueObj);
            break;
        case "DIAGRAM_MICROCHART":
            diagramInstance.showHideMicroChart(valueObj.value);
            break;
        case "DIAGRAM_AUTHORSTYLE_NAME":
            diagramInstance.showHideAuthorStyleName(valueObj.value);
            break;
        case "DIAGRAM_AUTHORSTYLE_DES":
            diagramInstance.showHideAuthorStyleDes(valueObj.value);
            break;
        case "DIAGRAM_AUTHORSTYLE_IMAGE":
            diagramInstance.showHideAuthorStyleImage(valueObj.value);
            break;
        case "DIAGRAM_GRID_IMAGE":
            diagramInstance.showHideGridImage(valueObj.value);
            break;
        case "DIAGRAM_SECONDARY_PLACEHOLDER":
            diagramInstance.showHideSecondaryPlaceholder(valueObj.value);
            break;
        case "DIAGRAM_SECONDARY_PLACEHOLDERSWITCH":
            diagramInstance.showHideSecondaryPlaceholderSwitch(valueObj.value);
            break;
        case "DIAGRAM_BUTTON":
            diagramInstance.showHideButton(valueObj.value);
            break;
        case "NONLINEAR_CONTENT_TYPE":
            if (diagramInstance.contentChange && diagramInstance.nodeProps.nodeclassName.includes("ContentOptionNode")) diagramInstance.contentChange({ value: { type: valueObj.value, selected: true } });
            else if (diagramInstance.showHideOptions) diagramInstance.showHideOptions(valueObj.value);
            break;
        case "DIAGRAM_TYPESWITCH":
            if (diagramInstance.showHideContent) diagramInstance.showHideContent(valueObj);
            break;
        case "NUMBER_SWITCH":
        case "DIAGRAM_NUMBERSWITCH":
            if (diagramInstance.showHideNumber) diagramInstance.showHideNumber(valueObj.value);
            break;
        case "NODE_LINK":
        case "selectedtextlinkurl":
        case "xyplotselectedtextlinkurl":
            diagramInstance?.updateNodeLink?.(valueObj);
            // diagramInstance?.updatePropsCallBack?.(target.id);
            break;
        case "LIST_STYLE":
            let listIndex = valueObj.index;
            switch (valueObj.property) {
                case "textlistbullet":
                    diagramInstance.changeSecondaryType("disc", listIndex);
                    if (diagramInstance.moodData && diagramInstance.moodData.secondarylist && diagramInstance.moodData.secondarylist.bullettype) diagramInstance.changeSecondaryType(diagramInstance.moodData.secondarylist.bullettype, listIndex);
                    break;
                case "textlistdecimal":
                    diagramInstance.changeSecondaryType("decimal", listIndex);
                    break;
                case "textlistpara":
                    diagramInstance.changeSecondaryType("none", listIndex);
                    break;
                case "textlisticon":
                    diagramInstance.changeSecondaryType("icon", listIndex);
                    break;
                case "textlistcheck":
                    diagramInstance.changeSecondaryType("check", listIndex);
                    break;
                case "textlistlogo":
                    diagramInstance.changeSecondaryType("logo", listIndex);
                    break;
                case "textlistimage":
                    diagramInstance.changeSecondaryType("image", listIndex);
                    break;
                case "textlistnumber":
                    diagramInstance.changeSecondaryType("number", listIndex);
                    break;
                default:
                    diagramInstance.changeSecondaryType("none", listIndex);
                    break;
            }
            break;
        case "MULTITEXT_STYLE":
            let multiTextBox = diagramInstance.arrDiagramNode[valueObj.index].multiTextBox;
            target.setAttribute("data-format", valueObj.property);
            if (multiTextBox)
                switch (valueObj.property) {
                    case "multitextbullet":
                        multiTextBox.onClickBulletList();
                        break;
                    case "multitextnumber":
                        multiTextBox.onClickNumberList();
                        break;
                    case "multitextindentplus":
                        multiTextBox.onClickIndent("+1");
                        break;
                    case "multitextindentminus":
                        multiTextBox.onClickIndent("-1");
                        break;
                    default:
                        multiTextBox.onRemoveFormat();
                        break;
                }
            break;
        case "QUILL_OPERATION":
            if (valueObj.hasOwnProperty("value")) {
                let multiTextBox = diagramInstance.arrDiagramNode[0].multiTextBox;
                if (multiTextBox) {
                    if (isFromUndo) {
                        multiTextBox.quill.container.innerHTML = valueObj.oldContent;
                    } else {
                        multiTextBox.quill.container.innerHTML = valueObj.newContent;
                    }
                    multiTextBox.isFocusOutRestrict = true;
                    multiTextBox.recreateQuillInstance(null, true);
                    multiTextBox.isFocusOutRestrict = false;
                }
            }
            break;
        case "titleallbold":
            diagramInstance.diagramData.properties.titleallbold = valueObj.value;
            diagramInstance.diagramParent.setAttribute("data-titleallbold", valueObj.value);
            break;
        case "linespace":
        case "characterspace":
        case "textgrayscale":
        case "textalign":
        case "textopacity":
        case "texttransform":
        case "textcase":
        case "textcolor":
        case "fontbold":
        case "fontitalic":
        case "fontsize":
        case "textsize":
        case "resettextcolor":
        case "resettextprops":
            DiagramUtils.setTextProperties(property, valueObj, targetNode, diagramInstance, isFromUndo);
            break;
        case "DIAGRAM_SEPARATOR_LINE":
            if (diagramInstance.showHideSeperatorLine) diagramInstance.showHideSeperatorLine(valueObj.value);
            break;
        case "DIAGRAM_SEPARATOR":
            if (diagramInstance.changeArrow) diagramInstance.changeArrow(valueObj.value);
            break;
        case "DIAGRAM_SEPARATORSWITCH":
            if (diagramInstance.showHideArrows) diagramInstance.showHideArrows(valueObj.value);
            break;
        case "DIAGRAM_CONNECTOR":
            if (diagramInstance.updateConnector) diagramInstance.updateConnector(valueObj.customconnector, valueObj.index);
            break;
        case "diagramconnectortext":
            if (diagramInstance.showHideConnectorText) diagramInstance.showHideConnectorText(valueObj.value);
            break;
        case "diagramconnectortextposition":
            if (diagramInstance.changeConnectorTextPosition) diagramInstance.changeConnectorTextPosition(valueObj.value);
            break;
        case "DIAGRAM_VALUE_FORMAT":
            diagramInstance?.changeValueFormat?.(valueObj, isFromUndo);
            break;
        case "DIAGRAM_LOGO_SIZE":
            if (diagramInstance.changeLogoSize) diagramInstance.changeLogoSize(valueObj.value);
            break;
        case "DIAGRAM_IMAGE_SIZE":
            if (diagramInstance.changeImageSize) diagramInstance.changeImageSize(valueObj.value);
            break;
        case "DIAGRAM_NUMBER_SIZE":
            if (diagramInstance.changeNumberSize) diagramInstance.changeNumberSize(valueObj.value);
            break;
        case "DIAGRAM_ICON_SIZE":
            if (diagramInstance.changeIconSize) diagramInstance.changeIconSize(valueObj.value);
            break;
        case "DIAGRAM_MICROCHART_SIZE":
            if (diagramInstance.changeMicroChartSize) diagramInstance.changeMicroChartSize(valueObj.value);
            break;
        case "changesize":
            if (diagramInstance.changeInlineSize) diagramInstance.changeInlineSize(valueObj);
            break;
        case "DIAGRAM_NUMBER_START":
            if (diagramInstance.changeNumberStart) diagramInstance.changeNumberStart(valueObj.value);
            break;
        case "DIAGRAM_NUMBER_REVERSESWITCH":
            if (diagramInstance.changeNumberReverse) diagramInstance.changeNumberReverse(valueObj.value);
            break;
        case "CHANGE_ICON":
            let nodeData = {
                type: "text",
                value: valueObj.value,
                id: valueObj.id,
                searchText: valueObj.searchText,
                assetText: valueObj.searchText,
                contenttype: "icon",
            };
            if (nodeGroup && !DiagramUtils.checkForPlaceholderIcon(valueObj.value)) nodeGroup.setAttribute("data-issearchiconloaded", "true");
            diagramInstance.updateNodeData(nodeData, "icon", valueObj.index, valueObj.elementId);
            diagramInstance.updateJSONData(diagramInstance.diagramData.properties);
            break;
        case "CHANGE_IMAGE":
            let nodeDataImg = {
                type: "image",
                value: valueObj.value,
                searchText: valueObj.searchText,
                id: "",
                assetText: valueObj.searchText,
                contenttype: valueObj.contentType,
            };
            if (nodeGroup && !DiagramUtils.checkForPlaceholderImage(valueObj.value)) nodeGroup.setAttribute("data-issearchiconloaded", "true");
            this.updateImage(valueObj.index, nodeDataImg, diagramInstance, valueObj.target, valueObj.componentType, true);
            break;
        case "changeasset":
            diagramInstance?.changeAsset?.(valueObj);
            break;
        case "addnode":
            if (isFromUndo) diagramInstance.arrDiagramNode[logoGridIndex].gridInstance.deleteLogoNode(logoGridIndex, parseInt(target.dataset.imagegridIndex) + 1);
            else diagramInstance.arrDiagramNode[logoGridIndex].gridInstance.addLogoNode(logoGridIndex, target.dataset.imagegridIndex);
            diagramInstance.resetLayout();
            break;
        case "deleteimage":
            if (isFromUndo) diagramInstance.arrDiagramNode[logoGridIndex].gridInstance.addLogoNode(logoGridIndex, valueObj.targetid.match(/\d+/)[0] - 1);
            else diagramInstance.arrDiagramNode[logoGridIndex].gridInstance.deleteLogoNode(logoGridIndex, target.dataset.imagegridIndex);
            diagramInstance.resetLayout();
            break;
        case "CHECK_BOX":
            valueObj.target.setAttribute("data-ischecked", valueObj.ischecked);
            if (valueObj.target.parentElement.parentElement.id.includes("secondaryText")) {
                if (diagramInstance.arrDiagramNode && diagramInstance.arrDiagramNode[valueObj.index]) diagramInstance.arrDiagramNode[valueObj.index].updateSecCheckListNode(valueObj.target);
            } else if (valueObj.hasOwnProperty("index") && valueObj.index.toString().includes(",")) {
                let arrIndex = DiagramUtils.getMultiContentIndex(valueObj.index);
                // diagramInstance.diagramData.nodes[arrIndex[0]].arrMultiCellNode[arrIndex[1]].content.value = valueObj.ischecked;
                if (nodeGroup) nodeGroup.setAttribute("data-ischecked", valueObj.ischecked);
                if (diagramInstance.arrDiagramNode && diagramInstance.arrDiagramNode[arrIndex[0]]) diagramInstance.arrDiagramNode[arrIndex[0]].updateCheckListNode(arrIndex[1]);
                // diagramInstance.updatePropsCallBack();
            } else {
                valueObj.index = parseInt(valueObj.index);
                diagramInstance.diagramData.nodes[valueObj.index].content.value = valueObj.ischecked;
                if (nodeGroup) nodeGroup.setAttribute("data-ischecked", valueObj.ischecked);
                if (diagramInstance.arrDiagramNode && diagramInstance.arrDiagramNode[valueObj.index]) diagramInstance.arrDiagramNode[valueObj.index].updateCheckListNode();
                // diagramInstance.updatePropsCallBack();
            }
            break;
        case "swapnext":
        case "swapprevious":
            if (valueObj.targetid && valueObj.targetid.includes("gridNode")) {
                diagramInstance.arrDiagramNode[logoGridIndex].gridInstance.swapNodes(valueObj, property == "swapnext" ? 1 : -1);
            } else if (diagramInstance.swapNodes) diagramInstance.swapNodes(valueObj, property == "swapnext" ? 1 : -1);
            break;
        case "highlightemphasize":
            if (diagramInstance.emphasize) diagramInstance.emphasize(valueObj);
            break;
        case "crossout":
            if (diagramInstance.crossout) diagramInstance.crossout(valueObj);
            break;
        case "DIAGRAM_GREYSCALE":
            if (diagramInstance.logoGreyScale) diagramInstance.logoGreyScale(valueObj.value);
            break;
        case "stepped":
        case "inverted":
            if (diagramInstance.changeShape) diagramInstance.changeShape(valueObj);
            break;
        case "isfill":
            if (diagramInstance.updateBgColor) diagramInstance.updateBgColor(valueObj);
            break;
        case "start":
        case "common node":
        case "end":
            if (diagramInstance.showHideStartEnd) diagramInstance.showHideStartEnd(valueObj);
            break;
        case "year":
            if (diagramInstance.showHideYear) diagramInstance.showHideYear(valueObj);
            break;
        case "bleed":
            if (diagramInstance.showHideBleed) diagramInstance.showHideBleed(valueObj);
            break;
        case "gutter":
            if (diagramInstance.showHideGutter) diagramInstance.showHideGutter(valueObj);
            break;
        case "overlay":
            if (diagramInstance.showHideOverlay) diagramInstance.showHideOverlay(valueObj);
            break;
        case "overlayopacity":
            let opacity = valueObj.value.val / 100;
            diagramInstance.diagramParent.style.setProperty("--overlaydiagramopacity", opacity);
            diagramInstance.diagramData.properties.overlayopacity = opacity;
            diagramInstance.updateProperties(diagramInstance.diagramData.properties);
            break;
        case "border":
            if (diagramInstance.showHideBorder) diagramInstance.showHideBorder(valueObj);
            break;
        case "textpositiongrid":
            if (diagramInstance.updateTextPosition) diagramInstance.updateTextPosition(valueObj);
            break;
        case "layoutgriditem":
            if (diagramInstance.updateLayoutName) diagramInstance.updateLayoutName(valueObj.value.name);
            break;
        case "contentChange":
            if (diagramInstance.contentChange) diagramInstance.contentChange(valueObj);
            break;
        case "projection":
            if (diagramInstance.projection) diagramInstance.projection(valueObj);
            break;
        case "sizechange":
            if (diagramInstance.sizechange) diagramInstance.sizechange(valueObj);
            break;
        case "commonnodesizechange":
            diagramInstance.commonNodeSizeChange?.(valueObj);
            break;
        //Xyplot
        case "addxyplotnode":
            if (isFromUndo) diagramInstance?.deleteNode?.(diagramInstance.arrDiagramNode?.[diagramInstance?.arrDiagramNode?.length - 1]?.parentNode?.id);
            else diagramInstance?.addNode?.();
            break;
        case "deletexyplotnode":
            if (isFromUndo) {
                if (valueObj.targetInstance) {
                    console.log("remove node");
                    valueObj.targetInstance.initCreation();
                    diagramInstance.arrDiagramNode.push(valueObj.targetInstance);
                    diagramInstance.diagramData.nodes.push(valueObj.targetInstance.objData);
                }
            } else diagramInstance?.deleteNode?.(valueObj.targetid);
            break;
        case "DIAGRAM_TYPE":
            if (diagramInstance.updateProperty) diagramInstance.updateProperty("diagram_type", valueObj);
            break;
        case "DIAGRAM_LOGO_STYLE":
            let nodedata = diagramInstance.diagramData.nodes;
            let type = DiagramUtils.getLogoStyle(diagramInstance.diagramData.properties.logostyle || "logo", valueObj.value);
            diagramInstance.diagramData.properties.logostyle = type;
            diagramInstance.updateProperties(diagramInstance.diagramData.properties);
            nodedata.forEach((element, logoIndex) => {
                if (element?.content?.logodata?.logos) {
                    let logodata = element?.content?.logodata?.logos;
                    // logodata = DiagramUtils.getSampleLogoData();
                    logodata?.forEach((logo) => {
                        if (logo.type && logo.type.toLowerCase() == type) {
                            let targetNode = diagramParent.querySelector("[data-nodetype='logoHolder'][data-index='" + logoIndex + "']");
                            if (targetNode) DiagramUtils.setLogoStyle(targetNode, logo);
                        }
                    });
                }
            });
            break;
        case "changelogostyle":
        case "inlineDiagramLogoTypeDropdownBtn":
            diagramInstance.arrDiagramNode[target.dataset.index]?.gridInstance?.gridimages?.forEach((gridImage, gridIndex) => {
                let logodata = gridImage?.logodata?.logos;
                // logodata = DiagramUtils.getSampleLogoData();
                let nodeInstance = diagramInstance?.arrDiagramNode[target.dataset.index];
                let type = DiagramUtils.getLogoStyle(nodeInstance?.objData?.nodeproperties?.logostyle || "logo", valueObj.value);
                nodeInstance.objData.nodeproperties.logostyle = type;
                nodeInstance?.updateNodeProperties(nodeInstance.objData.nodeproperties);
                logodata?.forEach((logo) => {
                    if (logo.type && logo.type.toLowerCase() == type) {
                        let targetNode = diagramParent.querySelector("[id='imageHolder" + gridIndex + "-gridNode" + target.dataset.index + "']");
                        if (targetNode) DiagramUtils.setLogoStyle(targetNode, logo);
                    }
                });
            });
            break;
        case "optionchange":
            if (diagramInstance.arrangeNodes) diagramInstance.arrangeNodes(valueObj);
            break;
        case "strectchange":
            diagramInstance.updateStrech?.(valueObj);
            break;
        case "circlenodeorder":
            diagramInstance.updateDirection?.(valueObj);
            break;
        case "arcflip":
            diagramInstance.updateFlip?.(valueObj);
            break;
        case "dasharray":
            diagramInstance.updateConnectorDasharray?.(valueObj.value);
            break;
        case "strokewidth":
            diagramInstance.updateConnectorWidth?.(valueObj.value);
            break;
        case "connectorstart":
            diagramInstance.updateConnetorStart?.(valueObj.value);
            break;
        case "connectorend":
            diagramInstance.updateConnetorEnd?.(valueObj.value);
            break;
        case "circleconnectortype":
            diagramInstance.updateConnectorType?.(valueObj);
            break;
        case "imagestackselectedindex":
            diagramInstance.updatePage?.(valueObj);
            break;
        case "DATE_FORMAT":
            diagramInstance.updateDateFormat?.(valueObj);
            break;
    }
    if (isQuillList) {
        diagramInstance?.arrDiagramNode[0]?.multiTextBox?.setQuillSingleLine();
    }
};

DiagramUtils.setTextProperties = function (property, valueObj, targetNode, diagramInstance, isFromUndo = false) {
    targetNode = DiagramUtils.validateTargetNode(targetNode);
    let diagramParent = diagramInstance.diagramParent;
    if (targetNode) {
        switch (property) {
            case "fontbold":
                let fontWeight = valueObj.value ? "bold" : "normal";
                targetNode.style.fontWeight = fontWeight;
                targetNode.setAttribute("data-fontbold", fontWeight);
                break;
            case "fontitalic":
                let fontStyle = valueObj.value ? "italic" : "normal";
                targetNode.style.fontStyle = fontStyle;
                targetNode.setAttribute("data-fontitalic", fontStyle);
                break;
            case "textsize":
                targetNode?.setAttribute("data-textsize", valueObj?.value);
                diagramInstance.updateTextSize?.(valueObj, targetNode);
                break;
            case "fontsize":
                let arrTextNodes = diagramParent?.querySelectorAll("[data-type='" + valueObj?.objDetails?.contenttype + "']");
                arrTextNodes.forEach((element) => {
                    if (element) element.style.removeProperty("font-size");
                });
                if (diagramInstance.textResize) diagramInstance.textResize(valueObj.targetid, valueObj.value, valueObj.objDetails);
                break;
            case "linespace":
                let multiTextBoxComp = diagramInstance.arrDiagramNode[0].multiTextBox;
                diagramInstance.diagramData.properties.linespace = valueObj.value.val;
                diagramInstance.diagramParent.setAttribute("data-linespace", valueObj.value.val);
                if (multiTextBoxComp) multiTextBoxComp.changeLineSpacing(valueObj.value);
                break;
            case "characterspace":
                let multiTextBoxComp1 = diagramInstance.arrDiagramNode[0].multiTextBox;
                diagramInstance.diagramData.properties.characterspace = valueObj.value.val;
                diagramInstance.diagramParent.setAttribute("data-characterspace", valueObj.value.val);
                if (multiTextBoxComp1) multiTextBoxComp1.changeCharacterSpacing(valueObj.value);
                break;
            case "textgrayscale":
                targetNode.style.filter = valueObj.value ? "grayscale(1)" : "unset";
                targetNode.setAttribute("data-textgrayscale", valueObj.value);
                break;
            case "textalign":
                targetNode.style.setProperty("text-align", valueObj.value);
                targetNode.setAttribute("data-textalign", valueObj.value);
                targetNode.style.alignSelf = "unset";
                break;
            case "textopacity":
                targetNode.setAttribute("data-customopacity", valueObj.value);
                targetNode.style.opacity = valueObj.value;
                targetNode.setAttribute("data-textopacity", valueObj.value);
                break;
            case "texttransform":
            case "textcase":
                targetNode.style.textTransform = valueObj.value;
                targetNode.setAttribute("data-texttransform", valueObj.value);
                break;
            case "textcolor":
                targetNode.style.setProperty("color", valueObj.value, "important");
                targetNode.setAttribute("data-textcolor", valueObj.value);
                break;
            case "resettextcolor":
                targetNode.style.removeProperty("color");
                targetNode.removeAttribute("data-textcolor");
                break;
            case "resettextprops":
                if (isFromUndo) {
                    if (valueObj.textTransform != "none") targetNode.style.setProperty("text-transform", valueObj.textTransform);
                    if (valueObj.textColor != "none") targetNode.style.setProperty("color", valueObj.textColor);
                    if (valueObj.textOpacity != "none") targetNode.style.setProperty("opacity", valueObj.textOpacity);
                    if (valueObj.textAlign != "none") targetNode.style.setProperty("text-align", valueObj.textAlign);
                    if (valueObj.lineHeight != "none") targetNode.style.setProperty("line-height", valueObj.lineHeight);
                    if (valueObj.letterSpacing != "none") targetNode.style.setProperty("letter-spacing", valueObj.letterSpacing);
                    if (valueObj.filter != "none") targetNode.style.setProperty("filter", valueObj.filter);
                    if (valueObj.fontSize != "none") targetNode.style.setProperty("font-size", valueObj.fontSize);
                    if (valueObj.fontBold != "none") targetNode.style.setProperty("font-weight", valueObj.fontBold);
                    if (valueObj.fontItalic != "none") targetNode.style.setProperty("font-style", valueObj.fontItalic);
                } else {
                    targetNode.style.removeProperty("text-transform");
                    targetNode.removeAttribute("data-texttransform");
                    targetNode.style.removeProperty("color");
                    targetNode.removeAttribute("data-textcolor");
                    targetNode.style.removeProperty("opacity");
                    targetNode.removeAttribute("data-textopacity");
                    targetNode.style.removeProperty("text-align");
                    targetNode.removeAttribute("data-textalign");
                    targetNode.style.removeProperty("align-items");
                    targetNode.style.removeProperty("line-height");
                    targetNode.removeAttribute("data-linespace");
                    targetNode.style.removeProperty("letter-spacing");
                    targetNode.removeAttribute("data-characterspace");
                    targetNode.style.removeProperty("filter");
                    targetNode.removeAttribute("data-textgrayscale");
                    targetNode.style.removeProperty("font-size");
                    targetNode.removeAttribute("data-textsize");
                    targetNode.removeAttribute("data-fontbold");
                    targetNode.removeAttribute("data-fontitalic");
                    targetNode.style.removeProperty("font-weight");
                    targetNode.style.removeProperty("font-style");
                    let childern = Array.from(targetNode.children);
                    childern?.forEach?.((child) => {
                        child.style.removeProperty("line-height");
                        child.style.removeProperty("letter-spacing");
                    });
                }
                diagramInstance.updateTextNodes();
                diagramInstance.resetLayout();
                break;
            default:
                break;
        }
    }
};

DiagramUtils.getLogoStyle = function (baseStyle, subStyle) {
    let type = "";
    baseStyle = baseStyle.split("_")[0];
    if (subStyle != "logo" && subStyle != "icon") {
        type = baseStyle + "_" + subStyle;
    } else {
        type = subStyle;
    }
    return type;
};

DiagramUtils.getSampleLogoData = function () {
    return [
        {
            type: "logo",
            label: "TYPE LOGO",
            url: "https://cdn.presentations.ai/amplogos/reliance_industries_limited_logo.png",
        },
        {
            type: "logo_light",
            label: "TYPE SYMBOL",
            url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRRX5PzoDfuuZX0uQiNZ4dfCCozeV8K4F_fGw&usqp=CAU",
        },
        {
            type: "logo_dark",
            label: "TYPE SYMBOL",
            url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQyVcDyS3KYrLCRBnhAFM5jKrTsthr0jzPRTw&usqp=CAU",
        },
        {
            type: "logo_grayscale",
            label: "TYPE SYMBOL",
            url: "https://seeklogo.com/images/G/Greyscale-logo-F3AE060DA6-seeklogo.com.gif",
        },
        {
            type: "icon",
            label: "TYPE SYMBOL",
            url: "https://cdn.presentations.ai/amplogos/reliance_industries_limited_symbol.png",
        },
        {
            type: "icon_light",
            label: "TYPE SYMBOL",
            url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSPEINfjJYqm0HjWUAiNg24_WtVB4AlihczEQ&usqp=CAU",
        },
        {
            type: "icon_dark",
            label: "TYPE SYMBOL",
            url: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSPEINfjJYqm0HjWUAiNg24_WtVB4AlihczEQ&usqp=CAU",
        },
        {
            type: "icon_grayscale",
            label: "TYPE SYMBOL",
            url: "https://www.seekpng.com/png/detail/246-2468707_twitter-grey-logo-png.png",
        },
    ];
};

DiagramUtils.setLogoStyle = function (target, logoData) {
    logoData.type = logoData.type.toLowerCase();
    target.setAttribute("data-logotype", logoData.type);
    let imagenode = target.querySelector("[data-id='logoNode']");
    imagenode.setAttribute("data-src", logoData.url);
    DiagramResizeUtils.updateDefaultImageData(imagenode, "logo");
};

DiagramUtils.getSubType = function (contenttype) {
    switch (contenttype) {
        case "none":
            return "bulleted";
        case "sequence":
            return "numbered";
        case "number":
            return "valued";
        default:
            return contenttype;
    }
};

DiagramUtils.getHolderType = function (contenttype) {
    switch (contenttype) {
        case "iconHolder":
            return "icon";
        case "imageHolder":
            return "image";
        case "imageSecHolder":
            return "logo";
        case "valueTitleHolder":
            return "number";
        default:
            return "text";
    }
};

DiagramUtils.animationTypeImMenu = function (animationType) {
    let menuType = "all";
    menuType = animationType == "one" ? "oneattime" : menuType;
    menuType = animationType == "oaa" ? "oneafteranother" : menuType;
    return menuType;
};

DiagramUtils.setLogoContrast = function (logoNode, nodeGroup, value) {
    if (logoNode) {
        if (logoNode.parentElement.dataset.componentType && logoNode.parentElement.dataset.componentType == "grid") return;
        logoNode.classList.add(!value ? "logoBrightnessDiagramUnset" : "logoBrightnessDiagram");
        logoNode.classList.remove(!value ? "logoBrightnessDiagram" : "logoBrightnessDiagramUnset");
        logoNode.parentElement.setAttribute("data-logocontrast", value);
        if (nodeGroup) nodeGroup.setAttribute("data-logocontrast", value);
    }
};

DiagramUtils.setSwapData = function (property, value, oldValue) {
    if (property == "DIAGRAM_VALUE_FORMAT") {
        let _arrTemp = JSON.parse(JSON.stringify(value.arrValueNew));
        value.arrValueNew = JSON.parse(JSON.stringify(value.arrValueOld));
        value.arrValueOld = JSON.parse(JSON.stringify(_arrTemp));
    }
};

DiagramUtils.getListStylevalue = function (value) {
    let objName = "textlistpara";
    switch (value) {
        case "disc":
            objName = "textlistbullet";
            break;
        case "decimal":
            objName = "textlistdecimal";
            break;
        case "none":
            objName = "textlistpara";
            break;
        default:
            objName = "textlistpara";
            break;
    }
    return objName;
};

DiagramUtils.swapArrayElements = function (array, swapIndex1, swapIndex2) {
    var b = array[swapIndex2];
    if (b.index) b.index = swapIndex1;
    array[swapIndex2] = array[swapIndex1];
    if (array[swapIndex2].index) array[swapIndex2].index = swapIndex2;
    array[swapIndex1] = b;
    return array;
};

DiagramUtils.addClassList = function (target, className) {
    let arrClassList = className.split(" ");
    arrClassList.forEach((element) => {
        target.classList.add(element);
    });
};

DiagramUtils.getLinkData = function (element) {
    let linkData = element.getAttribute("data-navigate-to-slide-on-click");
    let linkType = element.getAttribute("data-linktype");
    return linkData && linkType ? { url: linkData, type: linkType } : null;
};

DiagramUtils.updateNodeLink = function (parent, data, nodeParent) {
    let nodeElement = parent.querySelector("[id='" + data.targetid + "']");
    let nodeIndex = nodeElement.dataset.index;
    let nodeGroup = nodeParent ? nodeParent : nodeElement && (nodeElement.dataset.name == "centerHolderParent" || nodeElement.dataset.haslinksupport || nodeElement.id.includes("nodeGroup")) ? nodeElement : parent.querySelector("[id='nodeGroup" + nodeIndex + "']") || nodeElement.parentElement;

    let extraLink = (data.targetid && data.targetid.includes("buttonTitleHolder")) || false;
    if (extraLink) {
        nodeElement.setAttribute("data-linkid", data.targetid);
    }
    if (data.linkSlide) {
        nodeGroup.setAttribute("data-navigate-to-slide-on-click", data.linkSlide);
        nodeGroup.setAttribute("data-linktype", "slide");
    } else if (data.url && data.url != "") {
        let hyperlinkurl = data.url;
        if (!/^(f|ht)tps?:\/\//i.test(hyperlinkurl)) {
            hyperlinkurl = "https://" + hyperlinkurl;
        }
        nodeGroup.setAttribute("data-navigate-to-slide-on-click", hyperlinkurl);
        nodeGroup.setAttribute("data-linktype", "url");
    } else {
        nodeGroup.removeAttribute("data-navigate-to-slide-on-click");
        nodeGroup.removeAttribute("data-linktype");
        nodeGroup.parentElement.removeAttribute("data-navigate-to-slide-on-click");
        nodeGroup.parentElement.removeAttribute("data-linktype");
    }
};

DiagramUtils.getNodeLinkValues = function (parent, data) {
    let operation = { targetid: data.targetid };
    let nodeElement = parent.querySelector("[id='" + data.targetid + "']");
    let nodeIndex = nodeElement.dataset.index;
    let nodeGroup = parent.querySelector("[id='nodeGroup" + nodeIndex + "']") || nodeElement.parentElement;

    let type = nodeGroup.getAttribute("data-linktype");
    let value = nodeGroup.getAttribute("data-navigate-to-slide-on-click");
    if (type) {
        if (type == "slide") {
            operation.linkSlide = value;
        } else {
            operation.url = value;
        }
    }
    return operation;
};

DiagramUtils.updateImage = function (index, nodeData, diagramInstance, strImageCropID, componentType, enableSave = false) {
    let imageURL = nodeData.value;
    let svgHolder = strImageCropID && strImageCropID.includes("centerHolderParent") ? (diagramInstance.bgDeviceDiv ? diagramInstance.bgDeviceDiv : diagramInstance.diagramParent).querySelector("[data-id='illustrationNode']") : null;
    // let svgHolder = strImageCropID && strImageCropID.includes("centerHolderParent") ? (diagramInstance.bgDeviceDiv ? diagramInstance.bgDeviceDiv : diagramInstance.diagramParent) : null;
    if (svgHolder && svgHolder.parentElement.dataset && svgHolder.parentElement.dataset.id == "deviceHolder") {
        // if (svgHolder) {
        diagramInstance.changeImageNode(strImageCropID, index, imageURL);
    } else {
        if (componentType && componentType == "grid") {
            index = strImageCropID.substring(strImageCropID.length - 1);
            let gridIndex = strImageCropID.substring(11, strImageCropID.lastIndexOf("-"));
            if (diagramInstance.gridInstance) diagramInstance.gridInstance.changeImage(strImageCropID, gridIndex, imageURL, nodeData.searchText);
            else diagramInstance.arrDiagramNode[index].gridInstance.changeImageNode(strImageCropID, gridIndex, imageURL, nodeData.searchText);
        } else if (componentType && componentType == "gridsplit") {
            diagramInstance.changeImage(strImageCropID, index, imageURL);
        } else diagramInstance.updateNodeData(nodeData, nodeData.contenttype, index, strImageCropID, enableSave);
    }
    diagramInstance.updateJSONData(diagramInstance.diagramData.properties);
};

DiagramUtils.getObjectFromName = function (subNodes, name) {
    return DiagramUtils.getObject(subNodes, name, "name");
};

DiagramUtils.checkSMLEnable = function (supportedNodes, name) {
    let holderObj = DiagramUtils.getObjectFromName(supportedNodes, name);
    if (holderObj) {
        if (holderObj.hasOwnProperty("holdertype") && holderObj.holdertype == "secondary") {
            return false;
        }
        return true;
    }
};

DiagramUtils.getSMLSizeFromValue = function (value, objSize = Constants.Value.arrSize) {
    value = parseFloat(value);
    // let returnValue = "extralarge";
    let arrSize = Object.keys(objSize);
    for (const index in arrSize) {
        if (value == objSize[arrSize[index]]) {
            return arrSize[index];
        } else if (value < objSize[arrSize[index]]) {
            return index > 0 ? arrSize[index - 1] : arrSize[index];
        }
    }
    // Object.keys(objSize).forEach((element) => {
    //     if (value <= objSize[element]) {
    //         returnValue = element;
    //     }
    // });
    return "extralarge";
};

DiagramUtils.checkSMLSizeFromFloater = function (value, floateroptionsdisable, objSize = []) {
    if (floateroptionsdisable.includes("size" + value)) {
        let arrSize = Object.keys(objSize).reverse();
        for (const index in arrSize) {
            if (!floateroptionsdisable.includes("size" + arrSize[index])) {
                return arrSize[index];
            }
        }
    }
    return value;
};

DiagramUtils.setAutoSizeValue = function (floateroptionsdisable, objSize = [], diagramParent) {
    let autoSize = 1;
    let setAutoSize = false;
    let arrSize = Object.keys(objSize).reverse();
    for (const index in arrSize) {
        if (!floateroptionsdisable.includes("size" + arrSize[index]) && !setAutoSize) {
            autoSize = objSize[arrSize[index]];
            setAutoSize = true;
        }
    }
    diagramParent.style.setProperty("--autoSize", autoSize);
};

DiagramUtils.getSMLValues = function (nodeParentStyle) {
    return {
        tiny: nodeParentStyle.getPropertyValue("--tinySize") || 0.25,
        small: nodeParentStyle.getPropertyValue("--smallSize") || 0.4,
        medium: nodeParentStyle.getPropertyValue("--mediumSize") || 0.6,
        large: nodeParentStyle.getPropertyValue("--largeSize") || 0.8,
        extralarge: nodeParentStyle.getPropertyValue("--extralargeSize") || 1,
    };
};

DiagramUtils.getObject = function (subNodes, name, property = "name") {
    if (!subNodes) return;
    for (let j = 0; j < subNodes.length; j++) {
        let nodeObj = subNodes[j];
        if (nodeObj[property] == name) return nodeObj;
        else if (nodeObj.subNodes) {
            let returnObj = DiagramUtils.getObject(nodeObj.subNodes, name, property);
            if (returnObj && returnObj[property] == name) return returnObj;
        }
    }
};

DiagramUtils.getOldTablePropertyValue = function (property, newValueObj, diagramParent, tableInstance) {
    let valueObj = {};

    //Tableinstance's property related operations
    switch (property) {
        case "row header":
            valueObj = JSON.parse(JSON.stringify(newValueObj));
            valueObj.value = diagramParent.dataset.rowheader;
            return valueObj;
        case "col header":
            valueObj = JSON.parse(JSON.stringify(newValueObj));
            valueObj.value = diagramParent.dataset.colheader;
            return valueObj;
        case "numbering":
            valueObj = JSON.parse(JSON.stringify(newValueObj));
            valueObj.value = diagramParent.dataset.numbering;
            return valueObj;
        case "overlay":
            valueObj = JSON.parse(JSON.stringify(newValueObj));
            valueObj.value = diagramParent.dataset.overlay;
            return valueObj;
        case "ignorefirstrow":
            valueObj = JSON.parse(JSON.stringify(newValueObj));
            valueObj.value = diagramParent.dataset.ignorefirstrow;
            return valueObj;
        case "DIAGRAM_NUMBER_START":
            valueObj = JSON.parse(JSON.stringify(newValueObj));
            valueObj.value = diagramParent.dataset.sequencetextstart;
            return valueObj;
        case "resize":
            valueObj = JSON.parse(JSON.stringify(newValueObj));
            valueObj.value = diagramParent.dataset.tableresize || "aspect-fill";
            return valueObj;
    }

    //Taget id related operations
    let elementId = newValueObj.target || newValueObj.targetid || newValueObj.elementId;
    let target = diagramParent.querySelector("[id='" + elementId + "']");
    let srtIndex = target?.dataset.parentIndex || target?.dataset.index || elementId.split("-")[1];
    let arrIndex = srtIndex?.split(",") || [0];

    if (newValueObj.hasOwnProperty("value") && newValueObj.hasOwnProperty("data")) newValueObj.value = newValueObj.value == "" ? newValueObj.data : newValueObj.value;
    if (arrIndex.length > 1 || elementId.includes("grid")) {
        // cell undo redo
        if (newValueObj.cellindex) arrIndex = newValueObj.cellindex;
        let node = tableInstance.arrTableNode[arrIndex[0]][arrIndex[1]];
        valueObj = JSON.parse(JSON.stringify(newValueObj));
        if (node.nodeData.type == "text" && property == "textchange") {
            let textNode = node.mainParent.querySelector(".clsTextNode");
            if (newValueObj.nodeData) textNode.dataset.oldtext = newValueObj.nodeData.value;
            else node.nodeData.value = textNode.dataset.oldtext;
        }
        // if (node.oldNodeData && target.dataset?.name == "text") node.nodeData = node.oldNodeData;
        let oldData = node.getJSONData(); //node.nodeData;
        valueObj.nodeData = JSON.parse(JSON.stringify(oldData));
        valueObj.cellindex = arrIndex;
    } else if (arrIndex.length == 1) {
        valueObj = JSON.parse(JSON.stringify(newValueObj));
        let oldData = tableInstance.tableData;
        valueObj.tableData = JSON.parse(JSON.stringify(oldData));
    }

    return valueObj;
};

DiagramUtils.setTableOperationProperty = function (property, valueObj, diagramParent, tableInstance) {
    //Tableinstance's property related operations
    switch (property) {
        case "row header":
        case "col header":
            tableInstance.updateHeader?.(valueObj);
            return;
        case "numbering":
            tableInstance.updateNumbering?.(valueObj);
            return;
        case "overlay":
            tableInstance.showHideOverlay?.(valueObj);
            return;
        case "ignorefirstrow":
            tableInstance.igonreFirstRow?.(valueObj);
            return;
        case "DIAGRAM_NUMBER_START":
            tableInstance.updateNumberStart?.(valueObj);
            return;
        case "resize":
            tableInstance.updateResize?.(valueObj);
            return;
    }

    //Taget id related operations
    let id = valueObj.target || valueObj.targetid || valueObj.elementId;
    let target = diagramParent.querySelector("[id='" + id + "']");
    let srtIndex = target?.dataset.parentIndex || target?.dataset.index || id.split("-")[1];
    let arrIndex = srtIndex?.split(",") || [0];
    let nodeInstance = null;
    if (valueObj.hasOwnProperty("value") && valueObj.hasOwnProperty("data")) valueObj.value = valueObj.value == "" ? valueObj.data : valueObj.value;

    if (valueObj.nodeData && (arrIndex.length > 1 || id.includes("grid"))) {
        // cell undo redo operation
        if (valueObj.cellindex) arrIndex = valueObj.cellindex;
        nodeInstance = tableInstance.arrTableNode[arrIndex[0]][arrIndex[1]];
        nodeInstance.changeContentType(valueObj, arrIndex, true);
        return;
    } else if (arrIndex.length == 1 && valueObj.tableData) {
        tableInstance.tableData = JSON.parse(JSON.stringify(valueObj.tableData));
        tableInstance.createSetupTable();
        return;
    }

    nodeInstance = tableInstance.arrTableNode[arrIndex[0]]?.[arrIndex?.[1]];

    if (id?.includes("colOption") || id?.includes("rowOption") || id?.includes("btnAdd")) {
        switch (property) {
            case "ROW_CONTENTCHANGE":
                tableInstance.rowContentChange(valueObj, arrIndex[0]);
                break;
            case "COL_CONTENTCHANGE":
                tableInstance.columnContentChange(valueObj, arrIndex[0]);
                break;
            case "COL_OPTION":
                tableInstance.columnOperation(valueObj, parseInt(arrIndex[0]));
                break;
            case "ROW_OPTION":
                tableInstance.rowOperation(valueObj, parseInt(arrIndex[0]));
                break;
            case "fontsize":
            case "textalignh":
                if (id.includes("colOption")) {
                    tableInstance.arrTableNode.forEach((row) => row[arrIndex[0]].setFontStyle(valueObj));
                } else {
                    tableInstance.arrTableNode[arrIndex[0]].forEach((cell) => cell.setFontStyle(valueObj));
                }
                tableInstance.textStyleOperation?.(valueObj, arrIndex);
                break;
            case "tabledatatype":
                if (id.includes("colOption")) {
                    tableInstance.arrTableNode.forEach((row) => row[arrIndex[0]].changeContentType(valueObj));
                } else {
                    tableInstance.arrTableNode[arrIndex[0]].forEach((cell) => cell.changeContentType(valueObj));
                }
                break;
            case "tabledataformat":
                if (id.includes("colOption")) {
                    tableInstance.arrTableNode.forEach((row) => row[arrIndex[0]].setDataFormat(valueObj));
                } else {
                    tableInstance.arrTableNode[arrIndex[0]].forEach((cell) => cell.setDataFormat(valueObj));
                }
                break;
            case "contenttype":
                tableInstance.changeContentType?.(valueObj, id, arrIndex);
                break;
            case "valueFormat":
                tableInstance.changeValueFormat?.(valueObj, id, arrIndex);
                break;
            case "COL_ADD":
                tableInstance.addColumn(valueObj);
                break;
            case "ROW_ADD":
                tableInstance.addRow(valueObj);
                break;
            case "COL_COPY":
            case "ROW_COPY":
                tableInstance.copy?.(valueObj);
                break;
            case "addcolwithcontent":
                tableInstance.addColWithContent?.(valueObj);
                break;
            case "addrowwithcontent":
                tableInstance.addRowWithContent?.(valueObj);
                break;
            case "nodealign":
                tableInstance.changeNodeAlign?.(valueObj, arrIndex, id);
                break;
            case "fontsize":
            case "textopacity":
            case "textcase":
            case "textalign":
            case "textcolor":
                tableInstance.setFontStyle?.(valueObj, arrIndex, id);
                break;
        }
        return;
    }

    switch (property) {
        case "CHANGE_ICON":
            let nodeData = {
                type: "icon",
                value: valueObj.value,
                id: valueObj.id,
                contenttype: "icon",
            };
            tableInstance.updateNodeData(nodeData, "icon", valueObj.index, valueObj.elementId);
            break;
        case "assetextratext":
            nodeInstance?.updateAssetExtraText?.(valueObj);
            break;
        case "CHANGE_IMAGE":
            let nodeDataImg = {
                type: "image",
                value: valueObj.value,
                id: "",
                contenttype: valueObj.contentType,
            };
            tableInstance.updateNodeData(nodeDataImg, nodeDataImg.contenttype, valueObj.index, valueObj.target);
            break;
        case "CHANGE_GRID_IMAGE":
            let gridIndex = target.dataset?.imagegridIndex || 0;
            nodeInstance.gridInstance?.changeImageNode(valueObj.target, gridIndex, valueObj.value, valueObj.searchText);
            break;
        case "checklist":
            nodeInstance.updateChecklistData(valueObj);
            break;
        case "CHANGE_CONTENT_TYPE":
            nodeInstance.changeContentType(valueObj, arrIndex);
            break;
        case "tabledatatype":
            nodeInstance.changeContentType(valueObj, arrIndex);
            break;
        case "fontcolor":
        case "fontitalic":
        case "fontunderline":
        case "fontsize":
        case "fontbold":
        case "textalignh":
        case "sglineheight":
        case "sgletterspace":
        case "textopacity":
        case "textcase":
        case "textalign":
        case "textcolor":
        case "colorreset":
            nodeInstance?.setFontStyle(valueObj);
            break;
        case "bgcolor":
            nodeInstance.setBgStyle(valueObj);
            break;
        case "tabledataformat":
            nodeInstance.setDataFormat(valueObj);
            break;
        case "seccontent":
            nodeInstance.showHideSecContent(valueObj);
            tableInstance.updateEvents();
            break;
        case "ROW_CONTENTCHANGE":
            tableInstance.rowContentChange(valueObj, arrIndex[0]);
            break;
        case "COL_CONTENTCHANGE":
            tableInstance.columnContentChange(valueObj, arrIndex[0]);
            break;
        case "COL_OPTION":
            tableInstance.columnOperation(valueObj, parseInt(arrIndex[0]));
            break;
        case "ROW_OPTION":
            tableInstance.rowOperation(valueObj, parseInt(arrIndex[0]));
            break;
        case "tablesize":
            tableInstance.resizeOption(valueObj);
            break;
        case "Node style":
            nodeInstance.setNodeStyle?.(valueObj, arrIndex);
            break;
        case "CHECK_BOX":
            nodeInstance.updateCheckListNode?.(valueObj);
            break;
        case "addnode":
            nodeInstance.gridInstance.addLogoNode(`${arrIndex[0]},${arrIndex[1]}`, target.dataset.imagegridIndex);
            nodeInstance.updateNodeAttributes(arrIndex[0], arrIndex[1]);
            break;
        case "deleteimage":
            nodeInstance.gridInstance.deleteLogoNode(`${arrIndex[0]},${arrIndex[1]}`, target.dataset.imagegridIndex);
            nodeInstance.updateNodeAttributes(arrIndex[0], arrIndex[1]);
            break;
        case "swapnext":
        case "swapprevious":
            nodeInstance.updateGridSwap(valueObj, arrIndex);
            break;
        case "prioritychange":
            nodeInstance.changePriority(target);
            break;
        case "mergenext":
        case "mergebottom":
            tableInstance.updateMerge?.(valueObj, arrIndex);
            break;
        case "contenttype":
            nodeInstance.changeContentType?.(valueObj, arrIndex);
            break;
        case "valueFormat":
            nodeInstance.updateValueFormat?.(valueObj, arrIndex);
            break;
        case "textlistdecimal":
        case "textlistbullet":
        case "textlistpara":
            tableInstance.changeSecondaryType?.(valueObj, arrIndex);
            break;
        case "textlist":
            tableInstance.changeSecondaryType?.({ property: valueObj.value }, arrIndex);
            break;
        case "nodealign":
            nodeInstance.changeNodeAlign?.(valueObj);
            break;
        case "imageedit":
            nodeInstance.setImageEditStyle?.(valueObj);
            break;
        case "all":
            nodeInstance.resetAllTextProps?.(valueObj);
            break;
        case "changelogocontrast":
            nodeInstance.updateLogoContrast?.(valueObj, target);
            break;
        case "selectedtextlinkurl":
            DiagramUtils.updateNodeLink(tableInstance.tableParent, valueObj, nodeInstance?.mainParent?.firstElementChild);
            break;
        default:
            break;
    }
};

DiagramUtils.formatNumberWithCommas = function (strInput, strFormat) {
    if (strInput && strInput != "") {
        let strResult = strInput;
        strInput = strInput.replace(/,/g, "");

        if (!isNaN(strInput)) {
            strResult = strInput;
            const numInputValue = parseFloat(strInput);

            switch (strFormat) {
                case "0.0":
                    if (strInput.indexOf(".") === -1) {
                        strResult = strInput + ".00";
                    }
                    break;
                case "0,0":
                    strResult = numInputValue.toLocaleString("en-IN");
                    break;
                case "0,0.0":
                    strResult = numInputValue.toLocaleString("en-IN", { minimumFractionDigits: 2 });
                    break;
                case "000,0":
                    strResult = numInputValue.toLocaleString("en");
                    break;
                case "000,0.0":
                    strResult = numInputValue.toLocaleString("en", { minimumFractionDigits: 2 });
                    break;
            }
        }
        return strResult;
    }
    return strInput;
};

DiagramUtils.formatCurrency = function (strInput, strFormat) {
    if (strInput && strInput != "") {
        let strResult = strInput;
        strInput = strInput.replace(/[^0-9\.-]+/g, "");

        if (!strFormat || strFormat === "") {
            return strInput;
        }
        strInput = strInput.replace(/,/g, "");

        if (!isNaN(strInput)) {
            strResult = strInput;
            let numInputValue = parseFloat(strInput);
            if (strFormat.toLowerCase() != "none") {
                strResult = numInputValue.toLocaleString("en", { minimumFractionDigits: 2, style: "currency", currency: strFormat });
            } else {
                strResult = numInputValue.toLocaleString("en", { minimumFractionDigits: 2 });
            }
        }
        return strResult;
    }
    return strInput;
};

DiagramUtils.formatDate = function (strDate, strFormat, strPreFormat = "") {
    let strResult = strDate;

    if (!strFormat || strFormat === "") {
        strFormat = "MM/DD/YYYY";
    }

    if (strDate && strDate != "") {
        let momentDate = strPreFormat && strPreFormat != "" ? new moment(strDate, strPreFormat) : new moment(strDate, strFormat);
        return momentDate.format(strFormat);
    }

    return strResult;
};

DiagramUtils.formatStrDate = function (strDate, format) {
    try {
        return new Date(strDate).formatSG(format);
    } catch (err) {
        return strDate;
    }
};

DiagramUtils.findCircleLineIntersections = function (circle, line) {
    var a, b, c, d, u1, u2, ret, retP1, retP2, v1, v2;
    v1 = {};
    v2 = {};
    v1.x = line.p2.x - line.p1.x;
    v1.y = line.p2.y - line.p1.y;
    v2.x = line.p1.x - circle.center.x;
    v2.y = line.p1.y - circle.center.y;
    b = v1.x * v2.x + v1.y * v2.y;
    c = 2 * (v1.x * v1.x + v1.y * v1.y);
    b *= -2;
    d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - circle.radius * circle.radius));
    if (isNaN(d)) {
        // no intercept
        return [];
    }
    u1 = (b - d) / c; // these represent the unit distance of point one and two on the line
    u2 = (b + d) / c;
    retP1 = {}; // return points
    retP2 = {};
    ret = []; // return array
    if (u1 <= 1 && u1 >= 0) {
        // add point if on the line segment
        retP1.x = line.p1.x + v1.x * u1;
        retP1.y = line.p1.y + v1.y * u1;
        ret[0] = retP1;
    }
    if (u2 <= 1 && u2 >= 0) {
        // second add point if on the line segment
        retP2.x = line.p1.x + v1.x * u2;
        retP2.y = line.p1.y + v1.y * u2;
        ret[ret.length] = retP2;
    }
    return ret;
};

DiagramUtils.lineIntersectionOnRect = function (width, height, xB, yB, xA, yA, offset = 0) {
    var xI, yI;

    var w = (width + offset) / 2;
    var h = (height + offset) / 2;

    var dx = xA - xB;
    var dy = yA - yB;

    //if A=B return B itself
    if (dx == 0 && dy == 0)
        return {
            x: xB,
            y: yB,
        };

    var tan_phi = h / w;
    var tan_theta = Math.abs(dy / dx);

    //tell me in which quadrant the A point is
    var qx = Math.sign(dx);
    var qy = Math.sign(dy);

    if (tan_theta > tan_phi) {
        xI = xB + (h / tan_theta) * qx;
        yI = yB + h * qy;
    } else {
        xI = xB + w * qx;
        yI = yB + w * tan_theta * qy;
    }

    return {
        x: xI,
        y: yI,
    };
};

DiagramUtils.lineIntersectionOnCircle = function (circle, line, offset = 0) {
    circle.radius += offset;
    var a, b, c, d, u1, u2, ret, retP1, retP2, v1, v2;
    v1 = {};
    v2 = {};
    v1.x = line.p2.x - line.p1.x;
    v1.y = line.p2.y - line.p1.y;
    v2.x = line.p1.x - circle.center.x;
    v2.y = line.p1.y - circle.center.y;
    b = v1.x * v2.x + v1.y * v2.y;
    c = 2 * (v1.x * v1.x + v1.y * v1.y);
    b *= -2;
    d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - circle.radius * circle.radius));
    if (isNaN(d)) {
        // no intercept
        return [];
    }
    u1 = (b - d) / c; // these represent the unit distance of point one and two on the line
    u2 = (b + d) / c;
    retP1 = {}; // return points
    retP2 = {};
    ret = []; // return array
    if (u1 <= 1 && u1 >= 0) {
        // add point if on the line segment
        retP1.x = line.p1.x + v1.x * u1;
        retP1.y = line.p1.y + v1.y * u1;
        ret[0] = retP1;
    }
    if (u2 <= 1 && u2 >= 0) {
        // second add point if on the line segment
        retP2.x = line.p1.x + v1.x * u2;
        retP2.y = line.p1.y + v1.y * u2;
        ret[ret.length] = retP2;
    }
    return ret;
};

DiagramUtils.lineIntersectionOnEllipse = function (ellipseCenterX, ellipseCenterY, rx, ry, lineStartX, lineStartY, lineEndX, lineEndY, gap = 0) {
    const translatedLineStartX = lineStartX - ellipseCenterX;
    const translatedLineStartY = lineStartY - ellipseCenterY;
    const translatedLineEndX = lineEndX - ellipseCenterX;
    const translatedLineEndY = lineEndY - ellipseCenterY;

    // Calculate coefficients for the ellipse equation
    const aSquared = rx * rx;
    const bSquared = ry * ry;

    // Initialize an array to store intersection points
    const intersections = [];

    // Calculate the direction vector of the line segment
    const dirX = translatedLineEndX - translatedLineStartX;
    const dirY = translatedLineEndY - translatedLineStartY;

    // Calculate the coefficients for the quadratic equation
    const A = aSquared * dirY * dirY + bSquared * dirX * dirX;
    const B = 2 * (aSquared * translatedLineStartY * dirY + bSquared * translatedLineStartX * dirX);
    const C = aSquared * translatedLineStartY * translatedLineStartY + bSquared * translatedLineStartX * translatedLineStartX - aSquared * bSquared;

    // Calculate the discriminant for the quadratic equation
    const discriminant = B * B - 4 * A * C;

    if (discriminant >= 0) {
        // Calculate the two possible values of t (parameterization of the line segment)
        const t1 = (-B + Math.sqrt(discriminant)) / (2 * A);
        const t2 = (-B - Math.sqrt(discriminant)) / (2 * A);

        if (t1 >= 0 && t1 <= 1) {
            // Calculate the corresponding intersection point and add it to the array with the gap applied
            const intersectionX1 = translatedLineStartX + t1 * dirX;
            const intersectionY1 = translatedLineStartY + t1 * dirY;
            const gapX1 = (gap * (intersectionX1 - translatedLineStartX)) / Math.sqrt(dirX * dirX + dirY * dirY);
            const gapY1 = (gap * (intersectionY1 - translatedLineStartY)) / Math.sqrt(dirX * dirX + dirY * dirY);
            intersections.push([intersectionX1 + ellipseCenterX + gapX1, intersectionY1 + ellipseCenterY + gapY1]);
        }

        if (t2 >= 0 && t2 <= 1) {
            // Calculate the corresponding intersection point and add it to the array with the gap applied
            const intersectionX2 = translatedLineStartX + t2 * dirX;
            const intersectionY2 = translatedLineStartY + t2 * dirY;
            const gapX2 = (gap * (intersectionX2 - translatedLineStartX)) / Math.sqrt(dirX * dirX + dirY * dirY);
            const gapY2 = (gap * (intersectionY2 - translatedLineStartY)) / Math.sqrt(dirX * dirX + dirY * dirY);
            intersections.push([intersectionX2 + ellipseCenterX + gapX2, intersectionY2 + ellipseCenterY + gapY2]);
        }
    }

    return intersections;
};

DiagramUtils.animate = function (options) {
    var start = performance.now();
    requestAnimationFrame(function animate(time) {
        var timeFraction = (time - start) / options.duration;
        if (timeFraction > 1) timeFraction = 1;
        var progress = options.timing(timeFraction);
        options.draw(progress);
        if (timeFraction < 1) {
            requestAnimationFrame(animate);
        }
    });
};

DiagramUtils.fullAnimationName = function (shortForm) {
    switch (shortForm) {
        case "none":
            return "animationoff";
        case "all":
            return "animateallatonce";
        case "one":
            return "animateoneatatime";
        case "oaa":
            return "animateoneafteranother";
    }
};

DiagramUtils.checkOldTextProperties = function (cellData, properties, type) {
    let hasTextProperties = cellData.textproperties;
    let textproperties = cellData.textproperties || {};
    if (!hasTextProperties) {
        if (cellData.lineheight) textproperties.lineheight = cellData.lineheight;
        if (cellData.letterspacing) textproperties.letterspacing = cellData.letterspacing;
        if (properties?.fontresize?.[type]) textproperties.textclassname = properties?.fontresize?.[type];
    }
    return textproperties;
};

DiagramUtils.removeElementFromArray = function (element, array) {
    const index = array.indexOf(element);
    if (index > -1) {
        array.splice(index, 1);
    }
};

DiagramUtils.getDateFormatInlineData = function (dInstance) {
    let boolYear = dInstance.diagramParent?.dataset?.isyearenable;
    if (boolYear && boolYear == "false") return null;

    let index = getDateFormatIndex(dInstance.diagramParent.dataset.dateformat) || 0;

    let formatData = {
        id: "date-format",
        type: "dropdown",
        index: index,
        dataprovider: [
            { label: "2013", data: "YYYY" },
            { label: "03/14/2013", data: "MM/DD/YYYY" },
            { label: "Mar 14, 2013", data: "MMM DD, YYYY" },
            { label: "March 14, 2013", data: "MMMM DD, YYYY" },
            { label: "14/03/2013", data: "DD/MM/YYYY" },
            { label: "Wednesday, March 14, 2013", data: "dddd, MMMM DD, YYYY" },
        ],
    };

    function getDateFormatIndex(format) {
        let obj = {
            YYYY: 0,
            "MM/DD/YYYY": 1,
            "MMM DD, YYYY": 2,
            "MMMM DD, YYYY": 3,
            "DD/MM/YYYY": 4,
            "dddd, MMMM DD, YYYY": 5,
        };

        return obj[format] || 0;
    }

    return formatData;
};

DiagramUtils.getPriorityTextArray = function (type) {
    switch (type) {
        case "priority":
            return [
                { text: "Low", color: "green" },
                { text: "Medium", color: "yellow" },
                { text: "High", color: "red" },
            ];
        case "useractive":
            return [
                { text: "Online", color: "green" },
                { text: "Inactive", color: "lightgray" },
                { text: "Offline", color: "red" },
            ];
        case "todo":
            return [
                { text: "Not Started", color: "lightgray" },
                { text: "In progress", color: "orange" },
                { text: "Completed", color: "green" },
                { text: "In Review", color: "purple" },
                { text: "On-Hold", color: "yellow" },
                { text: "Cancelled", color: "red" },
            ];
    }
};

// Draw connected path lines normal/curved edges pass array of coords eg) [{x:point1.x,y:point1.y},{x:point2.x,y:point2.y,rounded:true}]
DiagramUtils.createLineOrRoundedPathString = function (pathCoords, radius = 3, isConnect = false) {
    const path = ["M" + pathCoords[0].x + "," + pathCoords[0].y];
    const curveRadius = radius;

    // Reset indexes, so there are no gaps
    pathCoords = pathCoords.slice();

    for (let i = 0; i < pathCoords.length; i++) {
        // 1. Get current coord and the next two (startpoint, cornerpoint, endpoint) to calculate rounded curve
        const c2Index = i + 1 > pathCoords.length - 1 ? (i + 1) % pathCoords.length : i + 1;
        const c3Index = i + 2 > pathCoords.length - 1 ? (i + 2) % pathCoords.length : i + 2;

        const c1 = pathCoords[i];
        const c2 = pathCoords[c2Index];
        const c3 = pathCoords[c3Index];

        // If at last coord of polygon, also save that as starting point
        if (i === pathCoords.length - 1) {
            // path.unshift("M" + c2c3CurvePoint.join(","));
        } else {
            // check if rounded then only apply rounded logic.
            if (c2.rounded) {
                // 2. For each 3 coords, enter two new path commands: Line to start of curve, bezier curve around corner.

                // Calculate curvePoint c1 -> c2
                const c1c2Distance = Math.sqrt(Math.pow(c1.x - c2.x, 2) + Math.pow(c1.y - c2.y, 2));
                const c1c2DistanceRatio = (c1c2Distance - curveRadius) / c1c2Distance;
                const c1c2CurvePoint = [((1 - c1c2DistanceRatio) * c1.x + c1c2DistanceRatio * c2.x).toFixed(1), ((1 - c1c2DistanceRatio) * c1.y + c1c2DistanceRatio * c2.y).toFixed(1)];
                if (c1c2CurvePoint[0] && c1c2CurvePoint[0] == "NaN") c1c2CurvePoint[0] = 0;
                if (c1c2CurvePoint[1] && c1c2CurvePoint[1] == "NaN") c1c2CurvePoint[1] = 0;

                // Calculate curvePoint c2 -> c3
                const c2c3Distance = Math.sqrt(Math.pow(c2.x - c3.x, 2) + Math.pow(c2.y - c3.y, 2));
                const c2c3DistanceRatio = curveRadius / c2c3Distance;
                const c2c3CurvePoint = [((1 - c2c3DistanceRatio) * c2.x + c2c3DistanceRatio * c3.x).toFixed(1), ((1 - c2c3DistanceRatio) * c2.y + c2c3DistanceRatio * c3.y).toFixed(1)];
                if (c2c3CurvePoint[0] && c2c3CurvePoint[0] == "NaN") c2c3CurvePoint[0] = 0;
                if (c2c3CurvePoint[1] && c2c3CurvePoint[1] == "NaN") c2c3CurvePoint[1] = 0;

                // Line to start of curve (L endcoord)
                path.push("L" + c1c2CurvePoint.join(","));
                // Bezier line around curve (Q controlcoord endcoord)
                path.push("Q" + c2.x + "," + c2.y + "," + c2c3CurvePoint.join(","));
            } else {
                path.push("L" + c2.x + "," + c2.y);
            }
        }
    }
    // Logically connect path to starting point again
    if (isConnect) path.push("Z");

    return path.join(" ");
};

DiagramUtils.parseImageSprites = function (graphicElement, jsonData, frameObj, assetURL, assetelement, index, totalNodes, frameId) {
    let frames = jsonData || [];
    let totalfarmes = frames.length - 1;
    let frameIndex = 0;
    if (frameObj.frame) {
        frameIndex = frameObj.frame;
    } else if (frameObj.objFrames?.[totalNodes + "nodes"]) {
        let objFrame = frameObj.objFrames[totalNodes + "nodes"];
        frameIndex = objFrame[index];
    } else {
        let additionalId = totalNodes > 3 ? 2 : 0;
        let remainingNodes = totalNodes - additionalId;
        let remainingFarmes = totalfarmes - additionalId;
        let eachNodeFrames = Math.floor(remainingFarmes / remainingNodes);
        frameIndex = index == 0 ? 0 : index == totalNodes - 1 ? totalfarmes : eachNodeFrames == 0 ? index : eachNodeFrames * index + 1;
        // frameIndex = index == 0 ? 0 : index == totalNodes - 1 ? totalfarmes : parseInt(totalfarmes / totalNodes) * index;
    }
    let frame = frames[frameId != null ? frameId : frameIndex || 0];

    let spriteCoordinates = [];
    for (let i1 = 0; i1 < totalfarmes + 1; i1++) {
        let eachFrame = frames[i1];
        let eachFrameCoordinates = [-eachFrame.x, -eachFrame.y];
        spriteCoordinates.push(eachFrameCoordinates);
    }

    let itemWidth = graphicElement.clientWidth;
    let itemHeight = graphicElement.clientHeight;
    let scaleX = itemWidth / frame.w;
    let scaleY = itemHeight / frame.h;
    let scale = scaleX < scaleY ? scaleX : scaleY;

    let translateX = (itemWidth - frame.w) / 2;
    let translateY = (itemHeight - frame.h) / 2;
    assetelement.dataset.frameindex = frameId == 0 ? 0 : frameId || frameIndex;
    assetelement.dataset.totalframes = frameId == 0 ? 1 : totalfarmes;
    assetelement.dataset.allframes = JSON.stringify(spriteCoordinates);
    assetelement.dataset.assetURL = assetURL;

    assetelement.setAttribute(
        "style",
        "width:" +
            frame.w +
            "px; height:" +
            frame.h +
            "px; min-width:" +
            frame.w +
            "px; min-height:" +
            frame.h +
            "px; background-repeat:no-repeat; background-image:url('" +
            assetURL +
            "'); background-position:" +
            -frame.x +
            "px " +
            -frame.y +
            "px;" +
            "transform: translate(" +
            translateX +
            "px," +
            translateY +
            "px) scale(" +
            scale +
            "," +
            scale +
            ");position: relative"
    );
};

DiagramUtils.getAssetValueBasedOnType = function (assetType, assetValue, moodData, appStaticURL) {
    if (assetValue && assetValue.startsWith("#") && assetValue.endsWith("#")) return assetValue;
    assetValue = assetValue || Constants.Value.placeholder_iconpath;
    let iconStyle = moodData.iconstyle || "illustrative";
    let isIllustration = assetValue.includes("genericassets/illustration");
    if (isIllustration) {
        return assetValue;
    } else if (assetType == "image" || assetType == "logo") {
        return appStaticURL + assetValue;
    } else if (assetType == "icon") {
        if (iconStyle == "illustrative") return "genericassets/icons/" + assetValue.toLowerCase();
        else if (assetValue.includes("harveyballs")) {
            let path = assetValue.includes("genericassets/icons/") ? assetValue : "genericassets/icons/" + assetValue;
            return path;
        }
        if (assetValue.includes("genericassets/icons/")) return assetValue;
        return "genericassets/icons/" + iconStyle + "/" + assetValue;
    } else if (assetType == "text") {
        if (assetValue instanceof Array) return assetValue[0];
        return assetValue;
    } else return assetValue;
};

DiagramUtils.valueInPx = function (value) {
    return parseFloat(value) + "px";
};

DiagramUtils.getChildObjectByName = function (obj, name) {
    for (let key in obj) {
        let child = obj[key];
        if (key == name) return child;
        else if (typeof child === "object") {
            let target = DiagramUtils.getChildObjectByName(child, name);
            if (target) return target;
        }
    }
};

DiagramUtils.validateTargetNode = function (target) {
    if (!target) return target;
    let isCenterNode = (target.dataset.focusParent && target.dataset.focusParent.includes("centerHolder")) || false;
    if (!isCenterNode) return target;
    else {
        return target.parentElement.querySelector("[data-id='numberNode'],[data-id='textNode']");
    }
};

DiagramUtils.lightOrDark = function (color) {
    // Variables for red, green, blue values
    var r, g, b, hsp;

    // Check the format of the color, HEX or RGB?
    if (color.match(/^rgb/)) {
        color = color.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/);
        r = color[1];
        g = color[2];
        b = color[3];
    } else {
        color = +("0x" + color.slice(1).replace(color.length < 5 && /./g, "$&$&"));
        r = color >> 16;
        g = (color >> 8) & 255;
        b = color & 255;
    }

    // HSP (Highly Sensitive Poo) equation from http://alienryderflex.com/hsp.html
    hsp = Math.sqrt(0.299 * (r * r) + 0.587 * (g * g) + 0.114 * (b * b));
    // Using the HSP value, determine whether the color is light or dark
    if (hsp > 127.5) return "light";
    else return "dark";
};

DiagramUtils.getUrlFromSprite = function (diagramParent) {
    if (diagramParent.id != "diagramparent") diagramParent = diagramParent.querySelector("[id='diagramparent']");
    let spriteElement = diagramParent.querySelector("[name='spriteElement']");
    let obj = {};
    if (spriteElement) {
        let url = spriteElement.getAttribute("data-asset-u-r-l");
        var lastSlashIndex = url.lastIndexOf("/");
        var value = url.substring(0, lastSlashIndex + 1);
        var id = url.substring(lastSlashIndex + 1).split(".")[0];
        obj.value = value;
        obj.id = id;
        let emphasisFrame = diagramParent.getAttribute("data-emphasis");
        if (emphasisFrame) {
            spriteElement = diagramParent.querySelector("[id='spriteElement" + emphasisFrame + "']");
            if (spriteElement) obj.emphasisFrame = spriteElement.getAttribute("data-frameindex");
        }
    }
    return obj;
};

DiagramUtils.getUrlFromCenterIcon = function (diagramParent) {
    let centerIcon = diagramParent.querySelector("[id='deviceHolder']");
    if (centerIcon) {
        let svgNode = centerIcon.querySelector("[data-id='svgNode']");
        let url = svgNode.getAttribute("data-iconpath");
        var lastSlashIndex = url.lastIndexOf("/");
        var value = url.substring(0, lastSlashIndex + 1);
        var id = url.substring(lastSlashIndex + 1).split(".")[0];
        return { value: value, id: id };
    }
};

/**
 * Author: Saravanan G.
 **/

"use strict";

function DiagramPropertyUtils() {}

DiagramPropertyUtils.prototype.constructor = DiagramPropertyUtils;

DiagramPropertyUtils.getDefaultDiagramNodeGap = function (nodeProps, diagramParent, properties) {
    if (nodeProps.gap) {
        if (!diagramParent?.dataset?.menugap) diagramParent.setAttribute("data-menugap", nodeProps.gap);
        if (diagramParent?.dataset?.nodecount && diagramParent?.dataset?.menugap?.includes(",") && properties) {
            let arrGap = diagramParent?.dataset?.menugap?.split(",");
            let minNode = properties.minNode ? parseInt(properties.minNode) : 2;
            let nodeCount = parseInt(diagramParent.dataset.nodecount);
            nodeProps.gap = arrGap[nodeCount - minNode] || arrGap[0];
        }
        return nodeProps.gap;
    } else {
        let nodeName = nodeProps && nodeProps.name ? nodeProps.name : "";
        let propName = nodeName.startsWith("ver") ? "--diagramVerNodeGap" : nodeName.startsWith("grd") ? "--diagramGrdNodeGap" : nodeName.startsWith("hor") ? "--diagramHorNodeGap" : null;
        return propName ? window.getComputedStyle(diagramParent).getPropertyValue(propName) : 0;
    }
};

DiagramPropertyUtils.checkPreviousDisableState = function (diagramData, diagramParent, property, cssClass, hasEnabledClass = false) {
    let isDisablePrimary = diagramData?.properties?.floateroptionsdisable?.includes(property);
    let primaryValue = isDisablePrimary ? true : diagramData.properties[property];
    DiagramUtils.setEnableDisableClassNames(diagramParent, cssClass, primaryValue, hasEnabledClass);
};

DiagramPropertyUtils.updateNodePropsFromStyle = function (nodeProps, attribute, diagramParent) {
    let nodeName = nodeProps && nodeProps.name ? nodeProps.name : "";
    let propName = nodeName.startsWith("ver") ? "--diagramVer" + attribute : nodeName.startsWith("grd") ? "--diagramGrd" + attribute : nodeName.startsWith("hor") ? "--diagramHor" + attribute : null;
    if (propName) nodeProps[attribute] = nodeProps[attribute] && nodeProps[attribute] != Constants.Value.arrNodeProperties[attribute] ? nodeProps[attribute] : window.getComputedStyle(diagramParent).getPropertyValue(propName);
};

DiagramPropertyUtils.updateGlobalNodePropsFromStyle = function (nodeProps, attribute, diagramParent, propName = "") {
    nodeProps[attribute] = nodeProps[attribute] && nodeProps[attribute] != Constants.Value.arrNodeProperties[attribute] ? nodeProps[attribute] : window.getComputedStyle(diagramParent).getPropertyValue(propName);
    if (attribute == "nodealignment" && nodeProps.name) {
        let isColumnSplit = nodeProps.name.includes("ver-bul-") || nodeProps.name.includes("ver-num-") || nodeProps.name.includes("ver-ckd-") || nodeProps.name.includes("-agendalist-");
        if (nodeProps[attribute].trim() == "center") nodeProps[attribute] = nodeProps.name.includes("ver") ? (isColumnSplit ? "splitcenterfixed" : "autocenterfixed") : nodeProps.name.includes("hor") ? "auto" : nodeProps[attribute];
        if (nodeProps[attribute].trim() == "left") nodeProps[attribute] = nodeProps.name.includes("ver") ? (isColumnSplit ? "split" : "autoleftalign") : nodeProps.name.includes("hor") ? "" : nodeProps[attribute];
    }
};

DiagramPropertyUtils.resetNodeProperties = function (objData) {
    if (objData) {
        if (objData.nodeproperties) objData.nodeproperties = { highlight: false, emphasis: false, sublist: "none", ischecked: false };
        objData.highlightdata = {};
        objData.link = null;
    }
};

DiagramPropertyUtils.hasSecondaryPlaceholderSupport = function (className) {
    return (
        className &&
        (className.includes("SimpleLinearDiagram") ||
            className.includes("SimpleLinearVerticalDiagram") ||
            className.includes("SvgScale9BgList") ||
            className.includes("SimpleLinearGridDiagram") ||
            className.includes("SimpleLinearCommonNodeBase") ||
            className.includes("SimpleLinearRatioDiagram") ||
            className.includes("SimpleGridDiagram") ||
            className.includes("SimpleLinearVerticalGridDiagram"))
    );
};

DiagramPropertyUtils.getSecondaryFloaterOptions = function (diagramParent, nodeProps, jsonStr, diagramData) {
    let className = diagramParent.getAttribute("data-classname");
    let isSupportedSecondaryPlaceholder = DiagramPropertyUtils.hasSecondaryPlaceholderSupport(className);
    if (!isSupportedSecondaryPlaceholder) return [];
    let isValidSecondarPlaceholder = false;
    let secondaryPlaceholder = diagramData.secondaryplaceholder;
    let arrSecondaryContent = [];
    let hasQuote = nodeProps.quoteShape || nodeProps.name.includes("qt");
    if (diagramData.contenttype != "icon" && !hasQuote && !diagramData.floateroptionsdisable.includes("graphicsecondaryicon")) {
        arrSecondaryContent.push({
            data: "-sec-ic",
            label: "Icon",
            icon: "appicons/ic_icon_graphics",
        });
        if (!isValidSecondarPlaceholder) isValidSecondarPlaceholder = secondaryPlaceholder == "-sec-ic";
    }

    if (diagramData.contenttype != "number" && !diagramData.floateroptionsdisable.includes("graphicsecondarynumber")) {
        arrSecondaryContent.push({
            data: "-sec-val",
            label: "Number",
            icon: "appicons/ic_data_type_number",
        });
        if (!isValidSecondarPlaceholder) isValidSecondarPlaceholder = secondaryPlaceholder == "-sec-val";
    }

    if (diagramData.contenttype != "logo" && !diagramData.floateroptionsdisable.includes("graphicsecondarylogo")) {
        arrSecondaryContent.push({
            data: "-sec-lg",
            label: "Logo",
            icon: "appicons/ic_highlight_circle_outline",
        });
        if (!isValidSecondarPlaceholder) isValidSecondarPlaceholder = secondaryPlaceholder == "-sec-lg";
    }

    if (!diagramData.floateroptionsdisable.includes("graphicsecondarylogolist")) {
        arrSecondaryContent.push({
            data: "-sec-lgrd",
            label: "Logo List",
            icon: "appicons/ic_highlight_circle_outline",
        });
        if (!isValidSecondarPlaceholder) isValidSecondarPlaceholder = secondaryPlaceholder == "-sec-lgrd";
    }

    if (diagramData.contenttype != "image" && !hasQuote && !diagramData.floateroptionsdisable.includes("graphicsecondaryimage")) {
        arrSecondaryContent.push({
            data: "-sec-img",
            label: "Image",
            icon: "appicons/ic_image_rect_outline",
        });
        if (!isValidSecondarPlaceholder) isValidSecondarPlaceholder = secondaryPlaceholder == "-sec-img";
    }
    if (!isValidSecondarPlaceholder && arrSecondaryContent[0]) {
        diagramData.secondaryplaceholder = arrSecondaryContent[0].data;
        diagramParent.setAttribute("data-secondaryplaceholder", diagramData.secondaryplaceholder);
    }

    return arrSecondaryContent;
};

/**
 * Author:    KRISHNA M
 * Created:   FRI 28 FEB 2020
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function DiagramAnimateUtil() {}

DiagramAnimateUtil.prototype.constructor = DiagramAnimateUtil;

DiagramAnimateUtil.updateTitleVisiblity = function (currentSlide, isVisible = true) {
    let titleNode = currentSlide.querySelector("div[id='" + "TITLE" + "']");
    let labelNode = currentSlide.querySelector("div[id='" + "SLIDE_LABEL" + "']");
    let subtitleNode = currentSlide.querySelector("div[id='" + "SUBTITLE" + "']");
    let elementNode = currentSlide.querySelector("div[id='" + "textElement" + "']");

    if (titleNode) {
        isVisible ? titleNode.classList.add("hidetitlesection") : titleNode.classList.remove("hidetitlesection");
    }
    if (labelNode) {
        isVisible ? labelNode.classList.add("hidetitlesection") : labelNode.classList.remove("hidetitlesection");
    }
    if (subtitleNode) {
        isVisible ? subtitleNode.classList.add("hidetitlesection") : subtitleNode.classList.remove("hidetitlesection");
    }
    if (elementNode) {
        isVisible ? elementNode.classList.add("hidetitlesection") : elementNode.classList.remove("hidetitlesection");
    }
};

DiagramAnimateUtil.animationName = function (diagramInstance) {
    let oneattimeanimationtype = diagramInstance.diagramParent.parentElement.dataset.oneattimeanimationtype;
    let type = diagramInstance.diagramParent.parentElement.dataset.animationtype || "one";
    let animationType = "fadein";
    let diagramType = diagramInstance.nodeProps.name.split("-")[0];

    if (diagramType == "hor") {
        animationType = type == "one" && oneattimeanimationtype == "move" ? "horizontalmove" : animationType;
        animationType = type == "oaa" && oneattimeanimationtype == "move" ? "horizontalmove" : animationType;
        animationType = type == "one" && oneattimeanimationtype == "scale" ? "horizontalmove" : animationType;
        animationType = type == "oaa" && oneattimeanimationtype == "scale" ? "horizontalmove" : animationType;
    } else if (diagramType == "ver") {
        animationType = type == "one" && oneattimeanimationtype == "move" ? "verticalmove" : animationType;
        animationType = type == "oaa" && oneattimeanimationtype == "move" ? "verticalmove" : animationType;
    } else if (diagramType == "grd") {
        animationType = type == "one" && oneattimeanimationtype == "move" ? "grid" : animationType;
        animationType = type == "oaa" && oneattimeanimationtype == "move" ? "grid" : animationType;
    }

    if (oneattimeanimationtype && oneattimeanimationtype == "color") animationType = "color";
    // animationType = "grid"
    return animationType;
};

DiagramAnimateUtil.setupAnimation = function (arrDiagramNode, diagramParent, diagramInstance = null, isNotSetup = true) {
    this.dInstance = diagramInstance;
    this.animationFactor = this.dInstance.animationFactor;

    switch (DiagramAnimateUtil.animationName(diagramInstance)) {
        case "fadein":
            DiagramAnimateUtil.setupFadeInAnimation(arrDiagramNode, diagramParent, diagramInstance);
            break;

        case "horizontalmove":
        case "horizontalscale":
        case "fullscreenoaa":
            DiagramAnimateUtil.setUpOneAtTimeForHorizontalMoveAnimation(arrDiagramNode, diagramParent, diagramInstance);
            break;

        case "verticalmove":
        case "verticalscale":
            DiagramAnimateUtil.setUpOneAtTimeForVerticalMoveAnimation(arrDiagramNode, diagramParent, diagramInstance);
            break;

        case "horizontalscale":
            DiagramAnimateUtil.setupHorizontalScaleType(diagramInstance);
            break;

        case "verticalscale":
            DiagramAnimateUtil.setupVerticalScaleType(diagramInstance);
            break;

        case "fullscreenoaa":
            DiagramAnimateUtil.setupFullscreenOneAtTime(diagramInstance);
            break;

        case "grid":
            DiagramAnimateUtil.setUpGridMoveAnimation(arrDiagramNode, diagramParent);
            break;

        case "color":
            DiagramAnimateUtil.setUpColorAnimation(arrDiagramNode, diagramInstance);
            break;

        default:
            DiagramAnimateUtil.setupFadeInAnimation(arrDiagramNode, diagramParent, diagramInstance);
            break;
    }

    let cubicPath = "";
    try {
        cubicPath = diagramInstance.moodData.animationData.show.animation.item.effect;
    } catch (error) {}

    if (diagramParent.parentElement.dataset.oneattimeanimationtype && diagramParent.parentElement.dataset.oneattimeanimationtype != "fadein")
        setTimeout(() => {
            arrDiagramNode.map((node) => {
                let defaultAnimation = "all " + 0.8 * this.animationFactor + "s " + cubicPath;
                let nodeParent = node.getNodeParent().parentElement;
                nodeParent.style.transition = defaultAnimation;
                nodeParent.setAttribute("data-default-animation", defaultAnimation);
            });
        }, 100);
};

DiagramAnimateUtil.animateAfterMoodDelay = function (diagramInstance) {
    switch (DiagramAnimateUtil.animationName(diagramInstance)) {
        case "fadein":
            break;

        case "horizontalmove":
            break;

        case "verticalmove":
            break;

        case "horizontalscale":
            break;

        case "verticalscale":
            break;

        case "fullscreenoaa":
            break;

        case "grid":
            break;

        case "color":
            DiagramAnimateUtil.setUpColorAnimationAfetrMoodDelayIfNeeded(diagramInstance);
            break;

        default:
            break;
    }
};

DiagramAnimateUtil.setUpColorAnimationAfetrMoodDelayIfNeeded = function (diagramInstance) {
    diagramInstance.arrDiagramNode.map((node) => (node.parentNode.parentElement.style.opacity = 1));
};

//Setup related function

DiagramAnimateUtil.setupFadeInAnimation = function (arrDiagramNode, diagramParent, diagramInstance) {
    if (diagramParent.clientWidth != 0) diagramParent.style.setProperty("width", diagramParent.clientWidth + "px", "important");
    let nodesHolder = diagramParent.querySelector("[name='nodesHolder']");
    if (nodesHolder.clientWidth != 0) nodesHolder.style.setProperty("width", diagramParent.clientWidth + "px", "important");

    arrDiagramNode.map((node) => {
        node.getNodeParent().style.opacity = 0;
        let connector = node.getNodeParent().parentElement.querySelector("[name='connectorparent']");
        if (connector) {
            connector.style.opacity = "0";
        }
    });
};

DiagramAnimateUtil.setUpOneAtTimeForHorizontalMoveAnimation = function (arrNodes, parent, diagramInstance) {
    let nodesHolder = parent.querySelector("[name='nodesHolder']");
    parent.style.display = "flex";
    parent.style.justifyContent = "center";
    nodesHolder.style.position = "relative";
    nodesHolder.style.transition = `all ${0.5 * this.animationFactor}s`;

    let animationType = parent.parentElement.dataset.animationtype || "one";
    let nodeGap = 0;
    if (arrNodes[0] && arrNodes[1]) {
        let node1 = arrNodes[0].getNodeParent().parentElement;
        let node2 = arrNodes[1].getNodeParent().parentElement;
        nodeGap = node2.offsetLeft - (node1.offsetLeft + node1.offsetWidth);
        parent.setAttribute("data-nodegap", nodeGap);
        parent.setAttribute("data-dx", node1.offsetLeft);
        parent.setAttribute("data-nodewidth", node1.offsetWidth + "px");
        parent.setAttribute("data-minwidth", window.getComputedStyle(node1).minWidth);
    }

    arrNodes.map((nodeObj, i) => {
        let node = nodeObj.getNodeParent();
        if (node) {
            if (animationType == "one") {
                node.parentElement.style.opacity = 0;
                node.parentElement.style.width = node.parentElement.clientWidth + "px";
                node.parentElement.style.height = node.parentElement.clientHeight + "px";
                node.parentElement.style.position = "absolute";
                if (i > 0) node.parentElement.style.left = parent.clientWidth / 2 + "px";
                else {
                    parent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "hide";
                    DiagramAnimateUtil.setAnimationToNodeItems(diagramInstance, node.parentElement, "hide", false);
                }
            } else {
                node.parentElement.style.opacity = 0;
                let x = parent.clientWidth / 2 - node.parentElement.clientWidth / 2 - parseFloat(parent.dataset.dx) + "px";
                nodesHolder.style.transform = "translateX(" + x + ")";
                parent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "hide";
                DiagramAnimateUtil.setAnimationToNodeItems(diagramInstance, node.parentElement, "hide", false);
            }
        }

        let connector = node.parentElement.querySelector("[name='connectorparent']");
        if (connector) {
            connector.style.opacity = "0";
        }
    });
};

DiagramAnimateUtil.setUpOneAtTimeForVerticalMoveAnimation = function (arrNodes, parent, diagramInstance) {
    let nodesHolder = parent.querySelector("[name='nodesHolder']");
    nodesHolder.style.transition = `all ${0.5 * this.animationFactor}s`;
    nodesHolder.style.setProperty("width", nodesHolder.clientWidth + "px", "important");

    let animationType = parent.parentElement.dataset.animationtype || "one";

    let nodeGap = 0;
    if (arrNodes[0] && arrNodes[1]) {
        let node1 = arrNodes[0].getNodeParent().parentElement;
        let node2 = arrNodes[1].getNodeParent().parentElement;
        nodeGap = node2.offsetTop - (node1.offsetTop + node1.offsetHeight);
        parent.setAttribute("data-nodegap", nodeGap);
        parent.setAttribute("data-dy", node1.offsetTop);
    }

    arrNodes.map((nodeObj, i) => {
        let node = nodeObj.getNodeParent();
        if (node) {
            if (animationType == "one") {
                node.parentElement.style.opacity = 0;
                node.parentElement.style.width = node.parentElement.clientWidth + "px";
                node.parentElement.style.height = node.parentElement.clientHeight + "px";
                node.parentElement.style.position = "absolute";

                if (i > 0) node.parentElement.style.top = parent.clientHeight / 2 + "px";
                else {
                    parent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "hide";
                    DiagramAnimateUtil.setAnimationToNodeItems(diagramInstance, node.parentElement, "hide", false);
                }
            } else {
                node.parentElement.style.opacity = 0;
                let y = parent.clientHeight / 2 - node.parentElement.clientHeight / 2 - parseFloat(parent.dataset.dy) + "px";
                nodesHolder.style.transform = "translateY(" + y + ")";
                parent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "hide";
                DiagramAnimateUtil.setAnimationToNodeItems(diagramInstance, node.parentElement, "hide", false);
            }
        }
    });
};

DiagramAnimateUtil.setUpGridMoveAnimation = function (arrNodes, parent) {
    let animationType = parent.parentElement.dataset.animationtype || "one";
    let nodesHolder = parent.querySelector("[name='nodesHolder']");
    nodesHolder.style.transition = `all ${0.5 * this.animationFactor}s`;

    parent.style.setProperty("width", parent.clientWidth + "px", "important");
    parent.style.setProperty("height", parent.clientHeight + "px", "important");
    nodesHolder.style.setProperty("width", nodesHolder.clientWidth + "px", "important");
    nodesHolder.style.setProperty("height", nodesHolder.clientHeight + "px", "important");

    if (animationType == "one") {
        arrNodes.forEach((node) => {
            let nodeParent = node.parentNode.parentElement;
            nodeParent.setAttribute("data-dx", nodeParent.offsetLeft + "px");
            nodeParent.setAttribute("data-dy", nodeParent.offsetTop + "px");
            nodeParent.setAttribute("data-dwidth", nodeParent.clientWidth + "px");
            nodeParent.setAttribute("data-dheight", nodeParent.clientHeight + "px");
        });
        parent.style.display = "flex";
        parent.style.justifyContent = "center";
        nodesHolder.style.position = "relative";
        nodesHolder.style.justifyContent = "center";
        nodesHolder.style.alignItems = "center";

        let animationType = parent.parentElement.dataset.animationtype || "one";
        arrNodes.map((nodeObj) => {
            let node = nodeObj.getNodeParent();
            if (node) {
                if (animationType == "one") {
                    node.parentElement.style.opacity = 0;
                    node.parentElement.style.width = node.parentElement.clientWidth + "px";
                    node.parentElement.style.height = node.parentElement.clientHeight + "px";
                    node.parentElement.style.position = "absolute";
                    node.parentElement.style.left = parent.clientWidth / 2 + "px";
                    node.parentElement.style.top = parent.clientHeight / 2 - node.parentElement.clientHeight / 2 + "px";
                } else {
                    node.parentElement.style.opacity = 0;
                    let x = parent.clientWidth / 2 - node.parentElement.clientWidth / 2 - parseFloat(parent.dataset.dx) + "px";
                    nodesHolder.style.transform = "translateX(" + x + ")";
                }
            }

            let connector = node.parentElement.querySelector("[name='connectorparent']");
            if (connector) {
                connector.style.opacity = "0";
            }
        });
        return;
    }

    let initialNodeHeight = 0;
    let line = 1;
    let previousNode = arrNodes[0].parentNode.parentElement;

    arrNodes.map((node, i) => {
        let nodeParent = node.parentNode.parentElement;
        if (nodeParent.offsetTop > previousNode.offsetTop) {
            line += 1;
            previousNode = nodeParent;
        } else if (line > 1) {
            nodeParent.setAttribute("data-isgridanimation", true);
            nodeParent.style.transform = "translate(" + nodeParent.clientWidth + "px, 0px)";
        }
        nodeParent.setAttribute("data-lineNumber", line);
        nodeParent.style.opacity = 0;
        if (i == 0) initialNodeHeight = nodeParent.clientHeight;
    });

    nodesHolder.style.transform = "translate(" + parent.clientWidth / 2 + "px, " + (parent.clientHeight / 2 - initialNodeHeight / 2) + "px)";
};

DiagramAnimateUtil.updateGridPosition = (arrNodes, parent, index) => {
    let nodesHolder = parent.querySelector("[name='nodesHolder']");

    let arrXPoint = arrNodes.map((node, i) => {
        let nodeParent = node.parentNode.parentElement;
        let value = nodeParent.offsetLeft + nodeParent.clientWidth;
        return i <= index ? value : 0;
    });

    let arrYPoint = arrNodes.map((node, i) => {
        let nodeParent = node.parentNode.parentElement;
        let value = nodeParent.offsetTop + nodeParent.clientHeight;
        nodeParent.style.opacity = i <= index ? 1 : 0;
        let translateValue = i > index && nodeParent.dataset.isgridanimation ? nodeParent.clientWidth : 0;
        nodeParent.style.transform = "translate(" + translateValue + "px, 0px)";
        return i <= index ? value : 0;
    });

    let maxX = Math.max(...arrXPoint);
    let maxY = Math.max(...arrYPoint);

    let x = parent.clientWidth / 2 - maxX / 2 + "px";
    let y = parent.clientHeight / 2 - maxY / 2 + "px";

    if (index == -1) {
        let initialNodeHeight = arrNodes[0].parentNode.parentElement.clientHeight;
        nodesHolder.style.transform = "translate(" + parent.clientWidth / 2 + "px, " + (parent.clientHeight / 2 - initialNodeHeight / 2) + "px)";
    } else nodesHolder.style.transform = "translate(" + x + ", " + y + ")";
};

DiagramAnimateUtil.setUpColorAnimation = function (arrNodes, diagramInstance) {
    let bg = diagramInstance.nodeProps.bgColor ? "BG" : "";
    let colorEnableClass = diagramInstance.nodeProps.colorAnimationClass ? diagramInstance.nodeProps.colorAnimationClass + "Enable" + bg : "colorAnimationEnable" + bg;
    let colorDisableClass = diagramInstance.nodeProps.colorAnimationClass ? diagramInstance.nodeProps.colorAnimationClass + "Disable" + bg : "colorAnimationDisable" + bg;
    diagramInstance.diagramParent.setAttribute("data-colorenableclass", colorEnableClass);
    diagramInstance.diagramParent.setAttribute("data-colordisableclass", colorDisableClass);
    const { colordisableclass: colorDisable } = diagramInstance.diagramParent.dataset;
    arrNodes.map((node) => {
        node.parentNode.parentElement.style.opacity = 0;
        node.parentNode.parentElement.classList.add(colorDisable);
    });
};

//Navigation related functin

DiagramAnimateUtil.playNext = function (arrNodes, index, parent, currentNode, diagramInstance) {
    let type = parent.parentElement.dataset.animationtype || "one";
    switch (DiagramAnimateUtil.animationName(diagramInstance)) {
        case "fadein":
            return DiagramAnimateUtil.showAnimate(currentNode, arrNodes, type, diagramInstance);

        case "color":
            return DiagramAnimateUtil.showColorAnimate(currentNode, arrNodes, type, diagramInstance);

        case "horizontalmove":
        case "horizontalscale":
        case "fullscreenoaa":
            return DiagramAnimateUtil.updatePositionHorizontalAnimation(arrNodes, index, parent, "next", false, diagramInstance);

        case "verticalmove":
        case "verticalscale":
            return DiagramAnimateUtil.updatePositionVerticalAnimation(arrNodes, index, parent, "next", false, diagramInstance);

        case "horizontalscale":
            return DiagramAnimateUtil.playNextHorizontalScaleType(diagramInstance, index, currentNode);

        case "verticalscale":
            return DiagramAnimateUtil.playNextVerticalScaleType(diagramInstance, index, currentNode);

        case "fullscreenoaa":
            DiagramAnimateUtil.fullScreenOneAtTimeForward(diagramInstance, index, currentNode);
            break;

        case "grid":
            type == "one" ? DiagramAnimateUtil.updatePositionHorizontalAnimation(arrNodes, index, parent, "next", false, diagramInstance) : DiagramAnimateUtil.updateGridPosition(arrNodes, parent, index);
            break;

        default:
            return DiagramAnimateUtil.showAnimate(currentNode, arrNodes, type, diagramInstance); //DiagramAnimateUtil.playNextHorizontalScaleType(diagramInstance, index, currentNode);// DiagramAnimateUtil.fullScreenOneAtTimeForward(diagramInstance, index, currentNode); //
    }

    return 2;
};

DiagramAnimateUtil.playPrevious = function (arrNodes, index, parent, currentNode, isPreviousFromAllNode, diagramInstance) {
    let type = parent.parentElement.dataset.animationtype || "one";
    switch (DiagramAnimateUtil.animationName(diagramInstance)) {
        case "fadein":
            return DiagramAnimateUtil.hideAnimate(currentNode, arrNodes, type);

        case "color":
            return DiagramAnimateUtil.hideColorAnimate(currentNode, arrNodes, type, diagramInstance);

        case "horizontalmove":
        case "horizontalscale":
        case "fullscreenoaa":
            return DiagramAnimateUtil.updatePositionHorizontalAnimation(arrNodes, index, parent, "previous", isPreviousFromAllNode, diagramInstance);

        case "verticalmove":
        case "verticalscale":
            return DiagramAnimateUtil.updatePositionVerticalAnimation(arrNodes, index, parent, "previous", isPreviousFromAllNode, diagramInstance);

        case "horizontalscale":
            return DiagramAnimateUtil.playPreviousHorizontalScaleType(diagramInstance, index, currentNode);

        case "verticalscale":
            return DiagramAnimateUtil.playPreviousVerticalScaleType(diagramInstance, index, currentNode);

        case "fullscreenoaa":
            DiagramAnimateUtil.fullScreenOneAtTimeBackward(diagramInstance, index, currentNode);
            break;

        case "grid":
            return type == "one" ? DiagramAnimateUtil.updatePositionHorizontalAnimation(arrNodes, index, parent, "previous", isPreviousFromAllNode, diagramInstance) : DiagramAnimateUtil.updateGridPosition(arrNodes, parent, index);
            break;

        default:
            return DiagramAnimateUtil.hideAnimate(currentNode, arrNodes, type); //DiagramAnimateUtil.hideAnimate(currentNode, arrNodes, type); //DiagramAnimateUtil.playPreviousHorizontalScaleType(diagramInstance, index, currentNode);
    }
};

DiagramAnimateUtil.showColorAnimate = function (node, arrNodes, animationType, diagramInstance) {
    const { colordisableclass: colorDisable, colorenableclass: colorEnable } = diagramInstance.diagramParent.dataset;

    if (animationType == "one") {
        arrNodes.map((node) => {
            node.parentNode.parentElement.classList.remove(colorDisable);
            node.parentNode.parentElement.classList.remove(colorEnable);
            node.parentNode.parentElement.classList.add(colorDisable);
            node.getNodeParent().style.transition = `all ${0.3 * this.animationFactor}s`;
        });
    }

    if (node) {
        node.parentNode.parentElement.classList.remove(colorDisable);
        node.parentNode.parentElement.classList.add(colorEnable);
    } else {
        arrNodes.map((node) => {
            node.parentNode.parentElement.classList.remove(colorDisable);
            node.parentNode.parentElement.classList.remove(colorEnable);
            node.parentNode.parentElement.classList.add(colorDisable);
        });
    }
    return 0.5 * this.animationFactor;
};

DiagramAnimateUtil.hideColorAnimate = function (node, arrNodes, animationType, diagramInstance) {
    const { colordisableclass: colorDisable, colorenableclass: colorEnable } = diagramInstance.diagramParent.dataset;
    if (animationType == "one") {
        arrNodes.map((node) => {
            node.parentNode.parentElement.classList.remove(colorDisable);
            node.parentNode.parentElement.classList.remove(colorEnable);
            node.parentNode.parentElement.classList.add(colorDisable);
        });
    }

    if (node && animationType != "one") {
        node.parentNode.parentElement.classList.remove(colorEnable);
        node.parentNode.parentElement.classList.add(colorDisable);
    } else if (node) {
        node.parentNode.parentElement.classList.remove(colorDisable);
        node.parentNode.parentElement.classList.remove(colorEnable);
        node.parentNode.parentElement.classList.add(colorEnable);
    }
    return 0.5;
};

DiagramAnimateUtil.showAnimate = function (node, arrNodes, animationType, diagramInstance) {
    if (animationType == "one") {
        arrNodes.map((node) => {
            node.getNodeParent().style.opacity = 0;
            node.getNodeParent().style.transition = `all ${0.3 * this.animationFactor}s`;
            DiagramAnimateUtil.updateConnectorVisiblity(node, 0);
        });
    }

    if (node) {
        node.getNodeParent().style.opacity = 1;
        node.getNodeParent().style.transition = `all ${0.3 * this.animationFactor}s`;
        let index = node.getNodeParent().dataset.index;
        if (animationType != "one") DiagramAnimateUtil.updateConnectorVisiblity(arrNodes[parseInt(index) - 1], 1);
    } else {
        arrNodes.map((node) => {
            node.getNodeParent().style.opacity = 1;
            node.getNodeParent().style.transition = `all ${0.3 * this.animationFactor}s`;
        });
    }
    return 0.5 * this.animationFactor;
};

DiagramAnimateUtil.hideAnimate = function (node, arrNodes, animationType) {
    if (animationType == "one") {
        arrNodes.map((node) => {
            let nodeParent = node.parentNode.parentElement;
            // nodeParent.style.top = nodeParent.parentElement.clientHeight/2 - nodeParent.clientHeight/2 + "px";
            // nodeParent.style.left = nodeParent.parentElement.clientWidth/2 - nodeParent.clientWidth/2 + "px";
            node.getNodeParent().style.opacity = 0;
            DiagramAnimateUtil.updateConnectorVisiblity(node, 0);
        });
    }

    if (node && animationType != "one") {
        node.getNodeParent().style.opacity = 0;
        let index = node.getNodeParent().dataset.index;
        DiagramAnimateUtil.updateConnectorVisiblity(arrNodes[parseInt(index) - 1], 0);
    } else if (node) {
        node.getNodeParent().style.opacity = 1;
    }
    return 0.5;
};

DiagramAnimateUtil.updateAllNodeAnimation = function (animationName, arrNodes, parent, direction, diagramInstance) {
    let type = parent.parentElement.dataset.animationtype || "one";
    switch (DiagramAnimateUtil.animationName(diagramInstance)) {
        case "fadein":
            return DiagramAnimateUtil.updateAllNodeAnimationFadeIn(animationName, arrNodes);

        case "color":
            return DiagramAnimateUtil.updateAllNodeAnimationColor(animationName, arrNodes, diagramInstance);

        case "horizontalmove":
            return type == "one" ? (direction == "previous" ? DiagramAnimateUtil.updateAllNodeAnimationFadeIn(animationName, arrNodes) : DiagramAnimateUtil.updateAllNodeForHorizontalMove(arrNodes, parent)) : DiagramAnimateUtil.updateAllNodeAnimationFadeIn(animationName, arrNodes);

        case "verticalmove":
            return type == "one" ? (direction == "previous" ? DiagramAnimateUtil.updateAllNodeAnimationFadeIn(animationName, arrNodes) : DiagramAnimateUtil.updateAllNodeForVerticalMove(arrNodes, parent)) : DiagramAnimateUtil.updateAllNodeAnimationFadeIn(animationName, arrNodes);

        case "grid":
            return DiagramAnimateUtil.updateAllNodeForGridMove(arrNodes);

        default:
            return DiagramAnimateUtil.updateAllNodeAnimationFadeIn(animationName, arrNodes);
    }
};

DiagramAnimateUtil.updateAllNodeAnimationColor = function (animationName, arrNodes, diagramInstance) {
    const { colordisableclass: colorDisable, colorenableclass: colorEnable } = diagramInstance.diagramParent.dataset;
    arrNodes.map((node) => {
        node.parentNode.parentElement.classList.remove(colorDisable);
        node.parentNode.parentElement.classList.remove(colorEnable);
        // node.parentNode.parentElement.classList.add(animationName == "hide" ? colorDisable : colorEnable);
    });
    return 0;
};

DiagramAnimateUtil.updateAllNodeAnimationFadeIn = function (animationName, arrNodes) {
    arrNodes.map((node) => {
        let nodeParent = node.parentNode.parentElement;
        nodeParent.style.top = nodeParent.dataset.dy;
        nodeParent.style.left = nodeParent.dataset.dx;
        node.getNodeParent().style.opacity = animationName == "hide" ? 0 : 1;
        DiagramAnimateUtil.updateConnectorVisiblity(node, animationName == "hide" ? 0 : 1);
    });
    return 0;
};

DiagramAnimateUtil.updateAllNodeForHorizontalMove = function (arrNodes, parent) {
    arrNodes.map((nodeObj, i) => {
        let node = nodeObj.getNodeParent().parentElement;
        if (node) {
            let gap = parseFloat(parent.dataset.nodegap);
            let leftAnimation = i == arrNodes.length - 1 ? "left " + 0.5 * this.animationFactor + "s" : "left 0s";
            let delay = i != arrNodes.length - 1 ? 0.5 * this.animationFactor + "s" : "0s";
            node.style.transition = leftAnimation + ", opacity " + 0.5 * this.animationFactor + "s " + delay;
            node.style.opacity = 1;

            let previousNodeObj = arrNodes[i - 1];
            if (previousNodeObj) {
                let previousNode = previousNodeObj.getNodeParent().parentElement;
                let x = previousNode.offsetLeft + previousNode.offsetWidth + gap;
                node.style.left = x + "px";
            } else node.style.left = parseFloat(parent.dataset.dx) + "px";

            DiagramAnimateUtil.updateConnectorVisiblity(previousNodeObj, 1);
        }
    });
    return 0;
};

DiagramAnimateUtil.updateAllNodeForVerticalMove = function (arrNodes, parent) {
    arrNodes.map((nodeObj, i) => {
        let node = nodeObj.getNodeParent().parentElement;
        if (node) {
            let gap = parseFloat(parent.dataset.nodegap);
            let topAnimation = i == arrNodes.length - 1 ? "top " + 0.5 * this.animationFactor + "s" : "top 0s";
            let delay = i != arrNodes.length - 1 ? 0.5 * this.animationFactor + "s" : "0s";
            node.style.transition = topAnimation + ", opacity " + 0.5 * this.animationFactor + "s " + delay;
            node.style.opacity = 1;

            let previousNodeObj = arrNodes[i - 1];
            if (previousNodeObj) {
                let previousNode = previousNodeObj.getNodeParent().parentElement;
                let y = previousNode.offsetTop + previousNode.offsetHeight + gap;
                node.style.top = y + "px";
            } else {
                node.style.top = parseFloat(parent.dataset.dy) + "px";
            }
        }
    });
    return 0;
};

DiagramAnimateUtil.updateAllNodeForGridMove = function (arrNodes, parent, isPreviousFromAllNode) {
    if (isPreviousFromAllNode) {
        arrNodes.map((nodeObj, i) => {
            let node = nodeObj.getNodeParent().parentElement;
            if (node) {
                let x = parent.clientWidth / 2 - node.clientWidth / 2; //i != arrNodes.length-1 ? (parent.clientWidth/2) : (parent.clientWidth/2) - node.clientWidth/2;
                node.style.left = x + "px";
                node.style.top = parent.clientHeight / 2 - node.clientHeight / 2 + "px";
                node.style.width = node.dataset.dwidth;
                node.style.height = node.dataset.dheight;
                node.style.opacity = i != arrNodes.length - 1 ? 0 : 1;
            }
        });
    } else {
        arrNodes.map((nodeObj, i) => {
            let node = nodeObj.getNodeParent().parentElement;
            if (node) {
                setTimeout(
                    () => {
                        node.style.left = node.dataset.dx;
                        node.style.top = node.dataset.dy;
                        node.style.width = node.dataset.dwidth;
                        node.style.height = node.dataset.dheight;
                        node.style.opacity = 1;
                        node.style.transition = `all ${0.5 * this.animationFactor}s, opacity ${0.3 * this.animationFactor}s ${0.3 * this.animationFactor}s `;
                    },
                    i != arrNodes.length - 1 ? 200 : 0
                );
            }
        });
    }

    return 0;
};

DiagramAnimateUtil.updatePositionHorizontalAnimation = function (arrNodes, index, parent, direction, isPreviousFromAllNode, diagramInstance) {
    let nodesHolder = parent.querySelector("[name='nodesHolder']");
    let animationType = parent.parentElement.dataset.animationtype || "one";

    if (animationType == "one") {
        arrNodes.map((nodeObj) => {
            let node = nodeObj.getNodeParent();
            let connector = node.parentElement.querySelector("[name='connectorparent']");
            if (connector) {
                connector.style.opacity = "0";
            }
        });
        direction == "next" ? DiagramAnimateUtil.oneAtTimeHorizontalForward(arrNodes, parent, nodesHolder, index, diagramInstance) : DiagramAnimateUtil.oneAtTimeHorizontalBackward(arrNodes, parent, nodesHolder, index, isPreviousFromAllNode);
        return 0.5;
    }

    arrNodes.map((nodeObj, i) => {
        let node = nodeObj.getNodeParent().parentElement;
        let previousNode = arrNodes[i - 1];

        if (index == 0 && direction != "previous") {
            parent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "show";
            DiagramAnimateUtil.setAnimationToNodeItems(diagramInstance, node, "show", true);
        }

        if (i > index) {
            node.style.opacity = 0;
            DiagramAnimateUtil.updateConnectorVisiblity(previousNode, 0);
        } else if (i == index) {
            node.style.opacity = 1;
            let offsetgap = parseFloat(parent.dataset.nodegap) * i;
            let x = parent.clientWidth / 2 - (node.clientWidth * (i + 1) + offsetgap) / 2;
            x = x - parseFloat(parent.dataset.dx);
            nodesHolder.style.transform = "translateX(" + x + "px)";

            DiagramAnimateUtil.updateConnectorVisiblity(previousNode, 1);
        } else {
            node.style.opacity = 1;
            DiagramAnimateUtil.updateConnectorVisiblity(previousNode, 1);
        }
    });
    return 0.5;
};

DiagramAnimateUtil.updateConnectorVisiblity = function (previousNode, visiblity = "1") {
    if (previousNode) {
        let connector = previousNode.getNodeParent().parentElement.querySelector("[name='connectorparent']");
        if (connector) {
            connector.style.opacity = visiblity;
        }
    }
};

DiagramAnimateUtil.oneAtTimeHorizontalForward = function (arrNodes, parent, nodesHolder, index, diagramInstance) {
    nodesHolder.style.width = "100%";
    setTimeout(() => {
        let currentNode = arrNodes[index].getNodeParent().parentElement;
        currentNode.style.left = parent.clientWidth / 2 - currentNode.clientWidth / 2 + "px";
        currentNode.style.top = parent.clientHeight / 2 - currentNode.clientHeight / 2 + "px";
        currentNode.parentElement.style.transition = `all ${0.5 * this.animationFactor}s`;
        currentNode.style.opacity = 1;

        if (index == 0) {
            parent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "show";
            DiagramAnimateUtil.setAnimationToNodeItems(diagramInstance, currentNode, "show", true);
        }
    }, 300);

    let previousNodeObj = arrNodes[index - 1];
    if (previousNodeObj) {
        let previousNode = previousNodeObj.getNodeParent().parentElement;
        let x = parent.clientWidth / 2 - previousNode.clientWidth;
        previousNode.style.left = x + "px";
        previousNode.parentElement.style.transition = `all ${0.5 * this.animationFactor}s`;
        previousNode.style.opacity = 0;
    }
};

DiagramAnimateUtil.oneAtTimeVerticalForward = function (arrNodes, parent, nodesHolder, index, diagramInstance) {
    nodesHolder.style.height = "100%";

    setTimeout(() => {
        let currentNode = arrNodes[index].getNodeParent().parentElement;
        currentNode.style.top = parent.clientHeight / 2 - currentNode.clientHeight / 2 + "px";
        currentNode.style.transition = `all ${0.5 * this.animationFactor}s`;
        currentNode.style.opacity = 1;

        if (index == 0) {
            parent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "show";
            DiagramAnimateUtil.setAnimationToNodeItems(diagramInstance, currentNode, "show", true);
        }
    }, 300);

    let previousNodeObj = arrNodes[index - 1];
    if (previousNodeObj) {
        let previousNode = previousNodeObj.getNodeParent().parentElement;
        let x = parent.clientHeight / 2 - previousNode.clientHeight;
        previousNode.style.top = x + "px";
        previousNode.style.transition = `all ${0.5 * this.animationFactor}s`;
        previousNode.style.opacity = 0;
    }
};

DiagramAnimateUtil.oneAtTimeHorizontalBackward = function (arrNodes, parent, nodesHolder, index, isPreviousFromAllNode, diagramInstance) {
    nodesHolder.style.width = "100%";

    if (isPreviousFromAllNode) {
        arrNodes.map((nodeObj, i) => {
            let node = nodeObj.getNodeParent();
            if (node) {
                if (i != arrNodes.length - 1) {
                    node.parentElement.style.opacity = 0;
                    node.parentElement.style.transition = `all ${0.5 * this.animationFactor}s`;
                }
            }
        });

        setTimeout(() => {
            arrNodes.map((nodeObj, i) => {
                let node = nodeObj.getNodeParent();
                if (node) {
                    if (i != arrNodes.length - 1) {
                        node.parentElement.style.left = parent.clientWidth / 2 - node.parentElement.clientWidth + "px";
                        node.parentElement.style.top = parent.clientHeight / 2 - node.parentElement.clientHeight / 2 + "px";
                    }
                }
            });
            DiagramAnimateUtil.updatePositionHorizontalAnimation(arrNodes, arrNodes.length - 1, parent, "next", diagramInstance);
        }, 300);

        return;
    }

    let outGoingNodeOjb = arrNodes[index + 1];
    if (outGoingNodeOjb) {
        let outGoingNode = outGoingNodeOjb.getNodeParent().parentElement;
        let x = parent.clientWidth / 2 + outGoingNode.clientWidth / 2;
        outGoingNode.style.left = x + "px";
        outGoingNode.style.transition = `all ${0.5 * this.animationFactor}s`;
        outGoingNode.style.opacity = 0;
    }

    setTimeout(() => {
        let incommingNode = arrNodes[index].getNodeParent().parentElement;
        incommingNode.style.left = parent.clientWidth / 2 - incommingNode.clientWidth / 2 + "px";
        incommingNode.style.top = parent.clientHeight / 2 - incommingNode.clientHeight / 2 + "px";
        incommingNode.style.transition = `all ${0.5 * this.animationFactor}s`;
        incommingNode.style.opacity = 1;
    }, 300);
};

DiagramAnimateUtil.oneAtTimeVerticalBackward = function (arrNodes, parent, nodesHolder, index, isPreviousFromAllNode, diagramInstance) {
    nodesHolder.style.height = "100%";

    if (isPreviousFromAllNode) {
        arrNodes.map((nodeObj, i) => {
            let node = nodeObj.getNodeParent();
            if (node) {
                if (i != arrNodes.length - 1) {
                    node.parentElement.style.transition = `all ${0.5 * this.animationFactor}s`;
                    node.parentElement.style.opacity = 0;
                }
            }
        });

        setTimeout(() => {
            arrNodes.map((nodeObj, i) => {
                let node = nodeObj.getNodeParent();
                if (node) {
                    if (i != arrNodes.length - 1) node.parentElement.style.top = parent.clientHeight / 2 - node.parentElement.clientHeight + "px";
                }
            });
            DiagramAnimateUtil.updatePositionVerticalAnimation(arrNodes, arrNodes.length - 1, parent, "next", isPreviousFromAllNode, diagramInstance);
        }, 300);
        return;
    }

    let outGoingNodeOjb = arrNodes[index + 1];
    if (outGoingNodeOjb) {
        let outGoingNode = outGoingNodeOjb.getNodeParent().parentElement;
        let x = parent.clientHeight / 2 + outGoingNode.clientHeight / 2;
        outGoingNode.style.top = x + "px";
        outGoingNode.style.transition = `all ${0.5 * this.animationFactor}s`;
        outGoingNode.style.opacity = 0;
    }

    setTimeout(() => {
        let incommingNode = arrNodes[index].getNodeParent().parentElement;
        incommingNode.style.top = parent.clientHeight / 2 - incommingNode.clientHeight / 2 + "px";
        incommingNode.style.transition = `all ${0.5 * this.animationFactor}s`;
        incommingNode.style.opacity = 1;
    }, 300);
};

DiagramAnimateUtil.updatePositionVerticalAnimation = function (arrNodes, index, parent, direction, isPreviousFromAllNode, diagramInstance) {
    let nodesHolder = parent.querySelector("[name='nodesHolder']");
    nodesHolder.style.height = parseFloat(arrNodes[0].getNodeParent().parentElement.style.height) + "px";
    let animationType = parent.parentElement.dataset.animationtype || "one";

    if (animationType == "one") {
        direction == "next" ? DiagramAnimateUtil.oneAtTimeVerticalForward(arrNodes, parent, nodesHolder, index, diagramInstance) : DiagramAnimateUtil.oneAtTimeVerticalBackward(arrNodes, parent, nodesHolder, index, isPreviousFromAllNode, diagramInstance);
        return 0.5;
    }

    arrNodes.map((nodeObj, i) => {
        let node = nodeObj.getNodeParent().parentElement;

        if (index == 0 && direction != "previous") {
            parent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "show";
            DiagramAnimateUtil.setAnimationToNodeItems(diagramInstance, node, "show", true);
        }

        if (i > index) {
            node.style.opacity = 0;
        } else if (i == index) {
            node.style.opacity = 1;
            let offsetgap = parseFloat(parent.dataset.nodegap) * i;
            let y = parent.clientHeight / 2 - (node.clientHeight * (i + 1) + offsetgap) / 2;
            y = y - parseFloat(parent.dataset.dy);
            nodesHolder.style.transform = "translateY(" + y + "px)";
        } else {
            node.style.opacity = 1;
        }
    });
    return 0.5;
};

//FullScreenOneAtATime

DiagramAnimateUtil.setupHorizontalScaleType = function (diagramInstance) {
    let dummyInstance = DiagramAnimateUtil.createDummyParent(diagramInstance, 1);
    diagramInstance.arrDiagramNode.map(function (node) {
        let nodeParent = node.getNodeParent().parentElement;
        // nodeParent.style.overflow = "hidden";
        nodeParent.style.width = "0px";
        nodeParent.style.setProperty("max-width", "unset", "important");
        nodeParent.style.height = "0px";
        nodeParent.style.position = "absolute";
        nodeParent.removeAttribute("data-animation");
        nodeParent.classList.remove("moodanimation");
        node.getNodeParent().style.opacity = 0;
        DiagramAnimateUtil.updateConnectorVisiblity(node, 0);
    });
    dummyInstance.arrDiagramNode.map(function (dummyNode, i) {
        let dummyNodeParent = dummyNode.getNodeParent().parentElement;
        let node = diagramInstance.arrDiagramNode[i];
        let nodeparent = node.getNodeParent().parentElement;

        nodeparent.style.left = dummyNodeParent.offsetLeft + "px";
        nodeparent.style.top = dummyNodeParent.offsetTop + "px";
        nodeparent.style.width = dummyNodeParent.clientWidth + "px";
        nodeparent.style.height = dummyNodeParent.clientHeight + "px";

        if (i == 0) {
            diagramInstance.animationIndex += 1;
            if (node.getNodeParent().dataset.highlight && node.getNodeParent().dataset.highlight == "true") {
                diagramInstance.isShowHighlight = true;
                diagramInstance.highlightIndex = parseInt(node.getNodeParent().dataset.index);
            }
            node.getNodeParent().style.opacity = 0;
            if (dummyInstance.diagramParent.parentElement) dummyInstance.diagramParent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "hide";

            diagramInstance.diagramParent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "hide";
            DiagramAnimateUtil.setAnimationToNodeItems(diagramInstance, nodeparent, "hide", false);
            node.getNodeParent().style.opacity = 1;
            DiagramAnimateUtil.setSize(nodeparent, dummyNodeParent, true);
            DiagramAnimateUtil.copyStyle(nodeparent.firstElementChild, dummyNodeParent.firstElementChild);
            diagramInstance.diagramParent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "show";
            DiagramAnimateUtil.setAnimationToNodeItems(diagramInstance, nodeparent, "show", true);
            node.getNodeParent().style.opacity = 1;
            node.getNodeParent().parentElement.style.opacity = 1;
        }
    });
};

DiagramAnimateUtil.playNextHorizontalScaleType = function (diagramInstance, index, node) {
    if (diagramInstance.diagramParent.parentElement.dataset.animationtype == "oaa") {
        DiagramAnimateUtil.oneAtTimeHorizontalScaleForward(diagramInstance, index, node);
    }
};

DiagramAnimateUtil.playPreviousHorizontalScaleType = function (diagramInstance, index, node) {
    if (diagramInstance.diagramParent.parentElement.dataset.animationtype == "oaa") {
        DiagramAnimateUtil.oneAtTimeHorizontalScaleBackward(diagramInstance, index, node);
    }
};

DiagramAnimateUtil.oneAtTimeHorizontalScaleForward = function (diagramInstance, index, node) {
    let dummyInstance = DiagramAnimateUtil.createDummyParent(diagramInstance, index + 1);
    setTimeout(() => {
        dummyInstance.arrDiagramNode.map(function (dummyNode, i) {
            let dummyNodeParent = dummyNode.getNodeParent().parentElement;
            let nodeparent = diagramInstance.arrDiagramNode[i].getNodeParent().parentElement;
            nodeparent.style.left = dummyNodeParent.offsetLeft + "px";
            nodeparent.style.top = dummyNodeParent.offsetTop + "px";
            nodeparent.style.width = dummyNodeParent.clientWidth + "px";
            nodeparent.style.height = dummyNodeParent.clientHeight + "px";
            dummyInstance.diagramParent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "hide";
            DiagramAnimateUtil.setSize(nodeparent, dummyNodeParent, true);
            DiagramAnimateUtil.copyStyle(nodeparent, dummyNodeParent);
            DiagramAnimateUtil.updateConnectorVisiblity(diagramInstance.arrDiagramNode[index - 1], 1);
            if (i == index) {
                nodeparent.style.transition = "unset";
                nodeparent.style.setProperty("opacity", 0, "important");
                setTimeout(() => {
                    let defaultAnimation = nodeparent.dataset.defaultAnimation || `all ${0.3 * this.animationFactor}s`;
                    nodeparent.style.transition = defaultAnimation;
                    nodeparent.style.setProperty("opacity", 1, "important");
                }, 300);
            } else {
                nodeparent.style.setProperty("opacity", 1, "important");
            }
        });
        this.removeDummyInstance(dummyInstance, diagramInstance);
    }, 0);

    return;
};

DiagramAnimateUtil.oneAtTimeHorizontalScaleBackward = function (diagramInstance, index, node) {
    diagramInstance.arrDiagramNode.map(function (node) {
        let nodeParent = node.getNodeParent().parentElement;
        // nodeParent.style.overflow = "hidden";
        nodeParent.style.width = "0px";
        nodeParent.style.height = "0px";
        node.getNodeParent().style.opacity = parseInt(nodeParent.dataset.index) > index ? 0 : 1;
    });
    let dummyInstance = DiagramAnimateUtil.createDummyParent(diagramInstance, index + 1);
    setTimeout(() => {
        dummyInstance.arrDiagramNode.map(function (dummyNode, i) {
            let dummyNodeParent = dummyNode.getNodeParent().parentElement;
            let nodeparent = diagramInstance.arrDiagramNode[i].getNodeParent().parentElement;

            nodeparent.style.left = dummyNodeParent.offsetLeft + "px";
            nodeparent.style.top = dummyNodeParent.offsetTop + "px";
            nodeparent.style.width = dummyNodeParent.clientWidth + "px";
            nodeparent.style.height = dummyNodeParent.clientHeight + "px";
            DiagramAnimateUtil.setSize(nodeparent, dummyNodeParent, true);
            DiagramAnimateUtil.copyStyle(nodeparent, dummyNodeParent);
            nodeparent.style.opacity = 1;
            DiagramAnimateUtil.updateConnectorVisiblity(diagramInstance.arrDiagramNode[index], 0);
        });
        this.removeDummyInstance(dummyInstance, diagramInstance);
    }, 0);
};

//FullScreenOneAtTimeVertical

DiagramAnimateUtil.setupVerticalScaleType = function (diagramInstance) {
    let dummyParent = diagramInstance.diagramParent.cloneNode(true);
    diagramInstance.diagramParent.parentElement.appendChild(dummyParent);

    let dummyInstance = new window[diagramClassName](diagramInstance.diagramParent);

    if (diagramInstance.diagramParent.parentElement.dataset.animationtype == "oaa") {
        let nodeHolder = diagramInstance.diagramParent.querySelector("[name='nodesHolder']");
        let contentSize = (nodeHolder.offsetHeight - (1 - 1) * diagramInstance.nodeProps.gap) / 1;
        nodeHolder.style.setProperty("--nodeWidth", "auto");
        nodeHolder.style.setProperty("--nodeHeight", contentSize + "px");

        diagramInstance.arrDiagramNode.map(function (node, i) {
            node.getNodeParent().parentElement.style.opacity = "1";
            if (i > 0) {
                node.getNodeParent().parentElement.style.height = "0px";
                node.getNodeParent().parentElement.style.opacity = "0";
                node.getNodeParent().style.transform = "translateY(" + node.getNodeParent().clientHeight + "px)";
                // node.getNodeParent().style.transition = `all ${0.5*this.animationFactor}s`;
            }
        });
    }
};

DiagramAnimateUtil.playNextVerticalScaleType = function (diagramInstance, index, node) {
    if (diagramInstance.diagramParent.parentElement.dataset.animationtype == "oaa") {
        DiagramAnimateUtil.oneAtTimeVerticalScaleForward(diagramInstance, index, node);
    }
};

DiagramAnimateUtil.playPreviousVerticalScaleType = function (diagramInstance, index, node) {
    if (diagramInstance.diagramParent.parentElement.dataset.animationtype == "oaa") {
        DiagramAnimateUtil.oneAtTimeVerticalScaleBackward(diagramInstance, index, node);
    }
};

DiagramAnimateUtil.oneAtTimeVerticalScaleForward = function (diagramInstance, index, node) {};

DiagramAnimateUtil.oneAtTimeVerticalScaleBackward = function (diagramInstance, index, node) {};

// FullScreen One At a time Animation
DiagramAnimateUtil.setupFullscreenOneAtTime = function (diagramInstance) {
    diagramInstance.arrDiagramNode.map(function (node) {
        DiagramAnimateUtil.removeEmphasize(node);
        DiagramAnimateUtil.updateConnectorVisiblity(node, 0);
    });
    let dummyInstance = DiagramAnimateUtil.createDummyParent(diagramInstance, 0, true);
    let arrNodes = diagramInstance.isReversAnimation ? diagramInstance.arrDiagramNode.reverse() : diagramInstance.arrDiagramNode;
    arrNodes.map((node, i) => {
        let nodeParent = node.getNodeParent().parentElement;
        nodeParent.style.position = "absolute";
        node.getNodeParent().parentElement.style.opacity = 0;
        node.getNodeParent().parentElement.style.setProperty("opacity", 0, "important");

        if (i == 0) {
            if (node.getNodeParent().dataset.highlight && node.getNodeParent().dataset.highlight == "true") {
                diagramInstance.isShowHighlight = true;
                diagramInstance.highlightIndex = parseInt(node.getNodeParent().dataset.index);
            }
        }
    });
    setTimeout(() => {
        DiagramAnimateUtil.layoutHolderWitdth(diagramInstance, dummyInstance);
        let arrDummyNodes = diagramInstance.isReversAnimation ? dummyInstance.arrDiagramNode.reverse() : dummyInstance.arrDiagramNode;
        arrDummyNodes.map((dummyNode, i) => {
            DiagramAnimateUtil.removeEmphasize(dummyNode);
            let dummyNodeParent = dummyNode.getNodeParent().parentElement;
            DiagramAnimateUtil.setDummyNodeForAnimation(dummyNode);
            let nodeparent = arrNodes[i].getNodeParent().parentElement;
            if (dummyInstance.diagramParent.parentElement) dummyInstance.diagramParent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "show";
            DiagramAnimateUtil.copyStyleOneAtTime(nodeparent, dummyNodeParent);
            nodeparent.style.setProperty("opacity", 0, "important");
            nodeparent.style.left = dummyNodeParent.offsetLeft + "px";
            nodeparent.style.top = dummyNodeParent.offsetTop + "px";
            nodeparent.style.width = dummyNodeParent.clientWidth + "px";
            nodeparent.style.height = dummyNodeParent.clientHeight + "px";
            nodeparent.style.position = "absolute";

            diagramInstance.diagramParent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "hide";
            DiagramAnimateUtil.setAnimationToNodeItems(diagramInstance, nodeparent, "hide", false);
            arrNodes[i].getNodeParent().parentElement.style.setProperty("transition", `all ${0.3 * this.animationFactor}s`, "important");
            arrNodes[i].getNodeParent().parentElement.style.opacity = 1;
            arrNodes[i].getNodeParent().parentElement.style.setProperty("opacity", 1, "important");
            diagramInstance.diagramParent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "show";
            DiagramAnimateUtil.setAnimationToNodeItems(diagramInstance, nodeparent, "show", true);
        });
        this.removeDummyInstance(dummyInstance, diagramInstance);
        // diagramInstance.animationIndex += 1;
    }, 0);
};

DiagramAnimateUtil.removeEmphasize = function (node) {
    let nodeParent = node.getNodeParent().parentElement;
    nodeParent.classList.remove("clsEmphasisDisabled");
    nodeParent.classList.remove("clsEmphasisEnabled");
    node.getNodeParent().removeAttribute("data-emphasize");
};

DiagramAnimateUtil.setDummyNodeForAnimation = function (node) {
    let dummyNodeParent = node.getNodeParent().parentElement;
    dummyNodeParent.removeAttribute("data-animation");
    dummyNodeParent.classList.remove("moodanimation");
    node.getNodeParent().style.transition = `all ${0.3 * this.animationFactor}s`;
};

DiagramAnimateUtil.fullScreenOneAtTimeForward = function (diagramInstance, index, node) {
    let dummyInstance = DiagramAnimateUtil.createDummyParent(diagramInstance, index, true);
    let delay = 0;
    let arrNodes = diagramInstance.isReversAnimation ? diagramInstance.arrDiagramNode.reverse() : diagramInstance.arrDiagramNode;
    let previousNode = arrNodes[index - 1];
    if (previousNode) {
        let previousNodeParent = previousNode.getNodeParent().parentElement;
        diagramInstance.diagramParent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "hide";
        DiagramAnimateUtil.setAnimationToNodeItems(diagramInstance, previousNodeParent, "hide", true);
        setTimeout(() => {
            previousNodeParent.style.opacity = 0;
        }, 1000);
        delay = 1000;
    }

    setTimeout(() => {
        DiagramAnimateUtil.layoutHolderWitdth(diagramInstance, dummyInstance);
        let arrDummyNodes = diagramInstance.isReversAnimation ? dummyInstance.arrDiagramNode.reverse() : dummyInstance.arrDiagramNode;
        arrDummyNodes.map((dummyNode, i) => {
            DiagramAnimateUtil.removeEmphasize(dummyNode);
            let dummyNodeParent = dummyNode.getNodeParent().parentElement;
            DiagramAnimateUtil.setDummyNodeForAnimation(dummyNode);
            let nodeparent = arrNodes[index].getNodeParent().parentElement;
            dummyInstance.diagramParent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "show";
            // DiagramAnimateUtil.copyStyle(nodeparent, dummyNodeParent, false);
            DiagramAnimateUtil.copyStyleOneAtTime(nodeparent, dummyNodeParent);
            nodeparent.style.left = dummyNodeParent.offsetLeft + "px";
            nodeparent.style.top = dummyNodeParent.offsetTop + "px";
            nodeparent.style.width = dummyNodeParent.clientWidth + "px";
            nodeparent.style.height = dummyNodeParent.clientHeight + "px";

            arrNodes[index].getNodeParent().parentElement.style.opacity = 1;
            arrNodes[index].getNodeParent().parentElement.style.setProperty("opacity", 1, "important");
            // nodeparent.style.opacity = 1;
            nodeparent.style.position = "absolute";
            diagramInstance.diagramParent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "show";
            DiagramAnimateUtil.setAnimationToNodeItems(diagramInstance, nodeparent, "show", true);
        });
        this.removeDummyInstance(dummyInstance, diagramInstance);
    }, delay);
};

DiagramAnimateUtil.fullScreenOneAtTimeBackward = function (diagramInstance, index, node) {
    let dummyInstance = DiagramAnimateUtil.createDummyParent(diagramInstance, index, true);
    let delay = 0;
    let arrNodes = diagramInstance.isReversAnimation ? diagramInstance.arrDiagramNode.reverse() : diagramInstance.arrDiagramNode;
    let previousNode = arrNodes[index + 1];
    if (previousNode) {
        let previousNodeParent = previousNode.getNodeParent().parentElement;
        diagramInstance.diagramParent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "hide";
        DiagramAnimateUtil.setAnimationToNodeItems(diagramInstance, previousNodeParent, "hide", true);
        delay = 1000;
    }

    setTimeout(() => {
        previousNode.getNodeParent().parentElement.style.opacity = 0;
        previousNode.getNodeParent().parentElement.style.setProperty("opacity", 0, "important");
        DiagramAnimateUtil.layoutHolderWitdth(diagramInstance, dummyInstance);
        let arrDummyNodes = diagramInstance.isReversAnimation ? dummyInstance.arrDiagramNode.reverse() : dummyInstance.arrDiagramNode;
        arrDummyNodes.map((dummyNode, i) => {
            DiagramAnimateUtil.removeEmphasize(dummyNode);
            let dummyNodeParent = dummyNode.getNodeParent().parentElement;
            DiagramAnimateUtil.setDummyNodeForAnimation(dummyNode);
            let nodeparent = arrNodes[index].getNodeParent().parentElement;
            dummyInstance.diagramParent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "show";
            // DiagramAnimateUtil.copyStyle(nodeparent, dummyNodeParent, false);
            DiagramAnimateUtil.copyStyleOneAtTime(nodeparent, dummyNodeParent);
            nodeparent.style.left = dummyNodeParent.offsetLeft + "px";
            nodeparent.style.top = dummyNodeParent.offsetTop + "px";
            nodeparent.style.width = dummyNodeParent.clientWidth + "px";
            nodeparent.style.height = dummyNodeParent.clientHeight + "px";
            arrNodes[index].getNodeParent().parentElement.style.opacity = 1;
            arrNodes[index].getNodeParent().parentElement.style.setProperty("opacity", 1, "important");
            nodeparent.style.position = "absolute";
            diagramInstance.diagramParent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "show";
            DiagramAnimateUtil.setAnimationToNodeItems(diagramInstance, nodeparent, "show", true);
        });
        this.removeDummyInstance(dummyInstance, diagramInstance);
    }, delay);
};

DiagramAnimateUtil.layoutHolderWitdth = function (diagramInstance, dummyInstance) {
    let holder = diagramInstance.diagramParent.querySelector("[name='nodesHolder']");
    let dummyHolder = dummyInstance.diagramParent.querySelector("[name='nodesHolder']");
    if (holder && dummyHolder) {
        holder.style.position = "absolute";
        holder.style.setProperty("width", dummyInstance.diagramParent.clientWidth + "px", "important");
        holder.style.setProperty("height", dummyInstance.diagramParent.clientHeight + "px", "important");
        diagramInstance.diagramParent.style.setProperty("width", dummyInstance.diagramParent.clientWidth + "px", "important");
        diagramInstance.diagramParent.style.setProperty("height", dummyInstance.diagramParent.clientHeight + "px", "important");
    }
};
// Scal type Helper Functions

DiagramAnimateUtil.createDummyParent = function (diagramInstance, nodeCount, isOneAtTime = false) {
    let oldDummyParent = diagramInstance.diagramParent.parentElement.querySelector("[id='dummyParent']");
    if (oldDummyParent) oldDummyParent.parentElement.removeChild(oldDummyParent);

    let dummyParent = diagramInstance.diagramParent.cloneNode(true);
    diagramInstance.diagramParent.parentElement.appendChild(dummyParent);
    dummyParent.id = "dummyParent";
    dummyParent.style.position = "absolute";
    dummyParent.style.opacity = 0;
    dummyParent.style.pointerEvents = "none";

    let className = diagramInstance.diagramParent.dataset.classname || diagramInstance.nodeProps.classname;
    let dummyInstance = new window[className](dummyParent);
    dummyInstance.moodName = diagramInstance.moodName;
    dummyInstance.moodData = diagramInstance.moodData;
    dummyInstance.globalMoodData = diagramInstance.globalMoodData;
    dummyInstance.slideID = diagramInstance.slideID;
    dummyInstance.isWidget = diagramInstance.isWidget;
    dummyInstance.appmode = diagramInstance.appmode;
    dummyInstance.appStaticURL = diagramInstance.appStaticURL;
    dummyInstance.objStyleData = diagramInstance.objStyleData;
    dummyInstance.setSlideScale();
    let properties = diagramInstance.getProperties();
    dummyInstance.getDiagramLayoutProperties(properties);
    dummyInstance.recreateElementData(properties);
    dummyInstance.updateJSONData(properties);

    dummyInstance.arrDiagramNode = diagramInstance.arrDiagramNode.filter(function (node, i) {
        return !isOneAtTime ? i < nodeCount : i == nodeCount;
    });
    dummyInstance.diagramData.nodes = diagramInstance.diagramData.nodes.filter(function (node, i) {
        return !isOneAtTime ? i < nodeCount : i == nodeCount;
    });
    dummyInstance.initDiagramCreation();
    dummyInstance.resetNodeAttributes();
    dummyInstance.titleResizeCallBack = diagramInstance.titleResizeCallBack;
    dummyInstance.updateResizeCallBack(dummyInstance.diagramParent.querySelector("[name='primaryText']"), dummyInstance.diagramData, dummyInstance);
    dummyParent.style.opacity = 0;
    return dummyInstance;
};

DiagramAnimateUtil.removeDummyInstance = function (dummyInstance, diagramInstance) {
    setTimeout(() => {
        if (dummyInstance && dummyInstance.diagramParent.parentElement) {
            dummyInstance.diagramParent.parentElement.removeChild(dummyInstance.diagramParent);
            dummyInstance = null;
        } else {
            let oldDummyParent = diagramInstance.diagramParent.parentElement.querySelector("[id='dummyParent']");
            if (oldDummyParent) oldDummyParent.parentElement.removeChild(oldDummyParent);
        }
    }, 0);
};

DiagramAnimateUtil.copyStyle = function (node, dummyNode, transition = true) {
    DiagramAnimateUtil.setSize(node, dummyNode);
    if (node.classList.contains("moodanimation")) node.style.opacity = "";
    else {
        node.style.opacity = window.getComputedStyle(dummyNode).opacity;
        node.style.transition = `all ${0.3 * this.animationFactor}s`;
    }

    Array.from(node.children).forEach((child, i) => {
        let dummyChild = dummyNode.children[i];
        if (dummyChild) {
            if (child.children.length > 0) DiagramAnimateUtil.copyStyle(child, dummyChild);
            else {
                DiagramAnimateUtil.setSize(child, dummyChild);
                child.style.transition = `all ${0.3 * this.animationFactor}s`;
                if (child.classList.contains("moodanimation")) child.style.opacity = "";
                else {
                    child.style.opacity = window.getComputedStyle(dummyChild).opacity;
                }
            }
        }
    });
};

DiagramAnimateUtil.copyStyleOneAtTime = function (node, dummyNode) {
    // node.style.cssText = window.getComputedStyle(dummyNode).cssText;
    DiagramAnimateUtil.setSize(node, dummyNode);
    if (node.classList.contains("moodanimation")) {
        node.style.setProperty("opacity", "");
    }
    Array.from(node.children).forEach((child, i) => {
        let dummyChild = dummyNode.children[i];
        if (dummyChild) {
            if (child.children.length > 0) DiagramAnimateUtil.copyStyleOneAtTime(child, dummyChild);
            else {
                // child.style.cssText = window.getComputedStyle(dummyChild).cssText;
                DiagramAnimateUtil.setSize(child, dummyChild);
                if (child.classList.contains("moodanimation")) {
                    child.style.setProperty("opacity", "");
                }
            }
        }
    });
};

DiagramAnimateUtil.setSize = function (node, dummyNode, isMainNode = false) {
    if (node.classList.contains("clsPrimaryText")) {
        let dummyNodeStyle = window.getComputedStyle(dummyNode);
        node.style.fontSize = dummyNodeStyle.fontSize;
        node.style.cssText = dummyNodeStyle.cssText;
    }

    if (node.tagName == "IMG") {
        node.style.cssText = dummyNode.style.cssText;
        return;
    }

    // node.style.cssText = window.getComputedStyle(dummyNode).cssText;

    // setTimeout(() => {
    // if (isMainNode) {
    //     node.style.setProperty("left", dummyNode.offsetLeft + "px", "important");
    //     node.style.setProperty("top", dummyNode.offsetTop + "px", "important");
    // }

    // node.style.position = "absolute";
    // node.style.setProperty("left", dummyNode.offsetLeft + "px", "important");
    // node.style.setProperty("top", dummyNode.offsetTop + "px", "important");

    let refHeight = dummyNodeStyle.height;
    let refWidth = dummyNodeStyle.width;
    let refMargin = dummyNodeStyle.margin;

    node.style.setProperty("width", refWidth, "important");
    node.style.setProperty("height", refHeight, "important");
    node.style.setProperty("margin", refMargin, "important");

    node.style.setProperty("min-width", refWidth, "important");
    node.style.setProperty("max-width", refWidth, "important");
    node.style.setProperty("min-height", refHeight, "important");
    node.style.setProperty("max-height", refHeight, "important");
    // }, 0);
};
//mood Animation related function

DiagramAnimateUtil.doCssAnimation = function (parentNode, targetNode, animationName, animationValues, animationDelayValue, strAnimationType, isAnimatable = true) {
    let styleNode;
    let bkStyleNode;

    if (strAnimationType == "show") {
        bkStyleNode = parentNode.querySelector("[id='ShowMoodStyleNodeOne']");
        if (!bkStyleNode) {
            styleNode = document.createElement("style");
            styleNode.id = "ShowMoodStyleNodeOne";
            bkStyleNode = styleNode;
            parentNode.appendChild(bkStyleNode);
        }
    } else {
        bkStyleNode = parentNode.querySelector("[id='HideMoodStyleNodeOne']");
        if (!bkStyleNode) {
            styleNode = document.createElement("style");
            styleNode.id = "HideMoodStyleNodeOne";
            bkStyleNode = styleNode;
            parentNode.appendChild(bkStyleNode);
        }
    }

    animationName = animationName ? DiagramAnimateUtil.randomKey(animationName) + " " : DiagramAnimateUtil.randomKey("defaultAnimation") + " ";
    let duration = animationValues.duration && isAnimatable ? animationValues.duration + "s " : "0s ";
    let delay = animationDelayValue && isAnimatable ? animationDelayValue + "s " : "0s ";
    let effect = animationValues.effect ? animationValues.effect + " " : "ease-in-out ";
    let fillMode = animationValues.fillmode ? "backwards " : "forwards ";

    let targetElementDisplay = window.getComputedStyle(targetNode)["display"];
    if (bkStyleNode && targetNode && targetNode.style.display != "none" && targetElementDisplay != "none" && targetNode.parentNode && targetNode.parentNode.style.display != "none") {
        let keyframeValues = animationValues.keyframe;
        let translateXStart = keyframeValues.transformX && keyframeValues.transformX.length > 0 ? keyframeValues.transformX[0] + "px" : 0;
        let translateYStart = keyframeValues.transformY && keyframeValues.transformY.length > 0 ? keyframeValues.transformY[0] + "px" : 0;
        let translateXEnd = keyframeValues.transformX && keyframeValues.transformX.length > 1 ? keyframeValues.transformX[1] + "px" : 0;
        let translateYEnd = keyframeValues.transformY && keyframeValues.transformY.length > 1 ? keyframeValues.transformY[1] + "px" : 0;
        let translateOriginStart = keyframeValues.transformorigin && keyframeValues.transformorigin.length > 1 ? keyframeValues.transformorigin[0] : "center";
        let translateOriginEnd = keyframeValues.transformorigin && keyframeValues.transformorigin.length > 1 ? keyframeValues.transformorigin[1] : "center";
        translateOriginStart = targetNode.dataset.customorgin ? targetNode.dataset.customorgin : translateOriginStart;
        translateOriginEnd = targetNode.dataset.customorgin ? targetNode.dataset.customorgin : translateOriginEnd;

        let transformboxStart = keyframeValues.transformbox && keyframeValues.transformbox.length > 1 ? keyframeValues.transformbox[0] : "fill-box";
        let transformboxEnd = keyframeValues.transformbox && keyframeValues.transformbox.length > 1 ? keyframeValues.transformbox[1] : "fill-box";
        transformboxStart = targetNode.dataset.customtransformboxstart ? targetNode.dataset.customtransformboxstart : transformboxStart;
        transformboxEnd = targetNode.dataset.customtransformboxend ? targetNode.dataset.customtransformboxend : transformboxEnd;

        let scaleXStart = keyframeValues.scaleX && keyframeValues.scaleX.length > 0 ? keyframeValues.scaleX[0] : 1;
        let scaleYStart = keyframeValues.scaleY && keyframeValues.scaleY.length > 0 ? keyframeValues.scaleY[0] : 1;
        let scaleXEnd = keyframeValues.scaleX && keyframeValues.scaleX.length > 1 ? keyframeValues.scaleX[1] : 1;
        let scaleYEnd = keyframeValues.scaleY && keyframeValues.scaleY.length > 1 ? keyframeValues.scaleY[1] : 1;

        let rotateStart = keyframeValues.rotate && keyframeValues.rotate.length > 1 ? keyframeValues.rotate[0] + "deg" : "0deg";
        let rotateEnd = keyframeValues.rotate && keyframeValues.rotate.length > 1 ? keyframeValues.rotate[1] + "deg" : "0deg";
        rotateStart = targetNode.dataset.customstartrotation ? targetNode.dataset.customstartrotation : rotateStart;
        rotateEnd = targetNode.dataset.customendrotation ? targetNode.dataset.customendrotation : rotateEnd;

        let opacityStart = keyframeValues.opacity && keyframeValues.opacity.length > 0 ? keyframeValues.opacity[0] : "";
        let opacityEnd = keyframeValues.opacity && keyframeValues.opacity.length > 1 ? keyframeValues.opacity[1] : "";

        let widthStart = keyframeValues.width && keyframeValues.width.length > 0 ? keyframeValues.width[0] : "";
        let widthEnd = keyframeValues.width && keyframeValues.width.length > 1 ? keyframeValues.width[1] : "";

        let heightStart = keyframeValues.height && keyframeValues.height.length > 0 ? keyframeValues.height[0] : 1;
        let heightEnd = keyframeValues.height && keyframeValues.height.length > 1 ? keyframeValues.height[1] : 1;
        translateXStart = keyframeValues.moveX && keyframeValues.moveX.length > 0 ? keyframeValues.moveX[0] * 10 + keyframeValues.hormoveX[1] + "px" : translateXStart;
        translateXEnd = keyframeValues.moveX && keyframeValues.moveX.length > 1 ? keyframeValues.moveX[1] * 10 + keyframeValues.hormoveX[0] + "px" : translateXEnd;
        translateYStart = keyframeValues.moveX && keyframeValues.moveX.length > 1 ? keyframeValues.moveY[0] + "px" : translateYStart;

        let strokeStrartDashArray = keyframeValues.dasharray && keyframeValues.dasharray.length > 1 ? keyframeValues.dasharray[0] : null;
        let strokeStrartDashOffset = keyframeValues.dashoffset && keyframeValues.dashoffset.length > 1 ? keyframeValues.dashoffset[0] : null;
        let strokeEndDashArray = keyframeValues.dasharray && keyframeValues.dasharray.length > 1 ? keyframeValues.dasharray[1] : null;
        let strokeEndDashOffset = keyframeValues.dashoffset && keyframeValues.dashoffset.length > 1 ? keyframeValues.dashoffset[1] : null;

        bkStyleNode.innerText +=
            "@keyframes " +
            animationName +
            " {\
                    0% {opacity:" +
            opacityStart +
            ";" +
            "width:" +
            widthStart +
            ";" +
            "height:" +
            heightStart +
            ";" +
            "stroke-dasharray:" +
            strokeStrartDashArray +
            ";" +
            "stroke-dashoffset:" +
            strokeStrartDashOffset +
            ";" +
            "transform-origin:" +
            translateOriginStart +
            ";" +
            // "transform-box:" +
            // transformboxStart +
            // ";" +
            "transform:rotate(" +
            rotateStart +
            ") translate(" +
            translateXStart +
            "," +
            translateYStart +
            ") scale(" +
            scaleXStart +
            "," +
            scaleYStart +
            ")}\
                    100% {opacity:" +
            opacityEnd +
            ";" +
            "width:" +
            widthEnd +
            ";" +
            "height:" +
            heightEnd +
            ";" +
            +"stroke-dasharray:" +
            strokeEndDashArray +
            ";" +
            "stroke-dashoffset:" +
            strokeEndDashOffset +
            ";" +
            "transform-origin:" +
            translateOriginEnd +
            ";" +
            // "transform-box:" +
            // transformboxEnd +
            // ";" +
            "transform:rotate(" +
            rotateEnd +
            ") translate(" +
            translateXEnd +
            "," +
            translateYEnd +
            ") scale(" +
            scaleXEnd +
            "," +
            scaleYEnd +
            ")}\
                }";

        targetNode.style.animation = animationName + duration + effect + fillMode + delay;
    }
};

DiagramAnimateUtil.randomKey = function (name = "animationName") {
    let animationName = name + Math.random().toString(36).slice(-5);
    return animationName;
};

DiagramAnimateUtil.setAnimationToNodeItems = function (diagramInstance, graphicNode, strAnimationType = "show", isAnimatable = true) {
    let parentNode = diagramInstance.diagramParent.parentElement.parentElement;
    let animationData = diagramInstance.moodData.animationData[strAnimationType].animation;
    let graphicAllAnimationValue = animationData["all"];
    // if (graphicAllAnimationValue && graphicAllAnimationValue != "") {
    //     defaultAnimationValue = graphicAllAnimationValue;
    // }
    let keyDelay = 0;
    for (let key in animationData) {
        let animationValues = animationData[key];
        let arrTargetNode = graphicNode.querySelectorAll("[data-animation='" + key + "']");
        if (arrTargetNode && arrTargetNode.length > 0) keyDelay = keyDelay + animationValues.delay;
        for (let i = arrTargetNode.length - 1; i >= 0; i--) {
            // let keyDelay = animationValues.delay;
            let animationName;

            if (strAnimationType == "show") {
                if (arrTargetNode[i].dataset.customopacity) {
                    animationValues.keyframe.opacity[1] = arrTargetNode[i].dataset.customopacity;
                } else {
                    animationValues.keyframe.opacity[1] = 1;
                }
                animationName = key + i + "Show";
            } else {
                if (arrTargetNode[i].dataset.customopacity) {
                    if (arrTargetNode[i].dataset.hidecustomopacity) {
                        arrTargetNode[i].style.opacity = arrTargetNode[i].dataset.customopacity;
                    }
                    animationValues.keyframe.opacity[0] = arrTargetNode[i].dataset.customopacity;
                } else {
                    animationValues.keyframe.opacity[0] = 1;
                }
                animationName = key + i + "Hide";
            }
            if (animationValues.itemdelay != 0) {
                let itemDelay = keyDelay + animationValues.itemdelay * (arrTargetNode.length - i);
                DiagramAnimateUtil.doCssAnimation(parentNode, arrTargetNode[i], animationName, animationValues, itemDelay, strAnimationType, isAnimatable);
            } else {
                DiagramAnimateUtil.doCssAnimation(parentNode, arrTargetNode[i], animationName, animationValues, keyDelay, strAnimationType, isAnimatable);
            }
        }

        // if (arrTargetNode.length > 0) keyDelay += 0.1;
    }
};

DiagramAnimateUtil.setHighlightAnimation = function (parentNode, graphicNode, animationData, strAnimationType = "show", isAnimatable = true) {
    let keyDelay = 0;
    for (let key in animationData) {
        let animationValues = animationData[key];
        let arrTargetNode = graphicNode.querySelectorAll("[data-animation='" + key + "']");
        if (arrTargetNode && arrTargetNode.length > 0) keyDelay = keyDelay + animationValues.delay;
        for (let i = arrTargetNode.length - 1; i >= 0; i--) {
            // let keyDelay = animationValues.delay;
            let animationName;

            if (strAnimationType == "show") {
                if (arrTargetNode[i].dataset.customopacity) {
                    animationValues.keyframe.opacity[1] = arrTargetNode[i].dataset.customopacity;
                } else {
                    animationValues.keyframe.opacity[1] = 1;
                }
                animationName = key + i + "Show";
            } else {
                if (arrTargetNode[i].dataset.customopacity) {
                    if (arrTargetNode[i].dataset.hidecustomopacity) {
                        arrTargetNode[i].style.opacity = arrTargetNode[i].dataset.customopacity;
                    }
                    animationValues.keyframe.opacity[0] = arrTargetNode[i].dataset.customopacity;
                } else {
                    animationValues.keyframe.opacity[0] = 1;
                }
                animationName = key + i + "Hide";
            }
            if (animationValues.itemdelay != 0) {
                let itemDelay = keyDelay + animationValues.itemdelay * (arrTargetNode.length - i);
                DiagramAnimateUtil.doCssAnimation(parentNode, arrTargetNode[i], animationName, animationValues, itemDelay, strAnimationType, isAnimatable);
            } else {
                DiagramAnimateUtil.doCssAnimation(parentNode, arrTargetNode[i], animationName, animationValues, keyDelay, strAnimationType, isAnimatable);
            }
        }
    }
};

/**
 * Author:    Saravanan G
 * Created:   22.04.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function DiagramAssetLoader() {
    this.loadAssetCount = 0;
}

DiagramAssetLoader.arrInLoading = [];

DiagramAssetLoader.prototype.constructor = DiagramAssetLoader;

DiagramAssetLoader.loadAssets = function (diagramParent, arrayAssets, appAssetURL) {
    this.loadCount = 0;
    return new Promise((resolve, reject) => {
        for (let i = 0; i < arrayAssets.length; i++) {
            if (arrayAssets[i] && arrayAssets[i].type == "icon") {
                const strAssetUrl = arrayAssets[i].value;
                let strAssetPrefixURL = appAssetURL;
                strAssetPrefixURL = !!arrayAssets[i].corporateUrl && arrayAssets[i].corporateUrl != "" ? appCorporateURL : strAssetPrefixURL;
                DiagramAssetLoader.downloadAsset(arrayAssets, strAssetPrefixURL + strAssetUrl, i, resolve, reject, diagramParent);
            } else {
                this.loadCount = this.loadCount + 1;
                if (arrayAssets.length == this.loadCount) resolve();
            }
        }
    });
};

DiagramAssetLoader.downloadAsset = function (arrayAssets, assetURL, index, resolve, reject, diagramParent) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", assetURL);
    xhr.onload = (data) => {
        arrayAssets[index].data = data.target.response;
        if (xhr.status == 200) DiagramNodeUtils.appenDefs(arrayAssets[index], diagramParent);
        this.loadCount++;
        if (arrayAssets.length == this.loadCount) resolve();
    };

    xhr.onerror = () => {
        this.loadCount++;
        if (arrayAssets.length == this.loadCount) resolve();
        if (reject) reject(xhr.statusText);
        console.log("File could not be loaded..." + xhr.statusText);
    };
    xhr.send();
};

DiagramAssetLoader.oneAssetTimeDownload = function (resolve, objData, addToDefs = false, defsParent = null, reject = null, isAsync = true) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", objData.value, isAsync);
    xhr.onload = (data) => {
        objData.data = data.target.response;
        if (xhr.status == 200) {
            DiagramAssetLoader.addSVGtoDefs(objData, addToDefs, defsParent);
            resolve(objData);
        } else {
            reject?.(data.target.response);
        }
    };
    xhr.onerror = () => {
        reject?.(xhr.statusText);
        console.log("File could not be loaded..." + xhr.statusText);
    };
    xhr.send();
};

DiagramAssetLoader.addSVGtoDefs = function (objData, addToDefs = false, defsParent = null) {
    let tempDiv = document.createElement("div");
    objData.data = DiagramNodeUtils.replaceImagePathInSvgString(objData.data, objData.value);
    tempDiv.innerHTML = objData.data;
    let svgNode = tempDiv.querySelector("svg");
    if (svgNode) {
        svgNode.setAttribute("width", "100%");
        svgNode.setAttribute("height", "100%");
        svgNode.setAttribute("path", objData.value);
        objData.data = svgNode.outerHTML;
    }
    if (addToDefs && defsParent) {
        DiagramNodeUtils.appenDefs(objData, defsParent);
    }
};

DiagramAssetLoader.oneTimeDownload = function (objData, addToDefs = false, defsParent = null, isAsync = true) {
    return new Promise((resolve, reject) => {
        if (addToDefs && defsParent) {
            let defs = DiagramNodeUtils.getDocumentDefs(defsParent);
            let updateDiagram = DiagramNodeUtils.getAssertFromDefs(objData.id, objData.value, defs);
            if (updateDiagram) {
                //objData.data = updateDiagram.outerHTML;
                let tempDiv = document.createElement("div");
                tempDiv.innerHTML = updateDiagram.outerHTML;
                objData.data = DiagramNodeUtils.replaceImagePathInSvgString(objData.data, objData.value);
                let svgNode = tempDiv?.firstChild;
                if (svgNode) {
                    svgNode.setAttribute("width", "100%");
                    svgNode.setAttribute("height", "100%");
                    svgNode.setAttribute("path", objData.value);
                    // DiagramNodeUtils.replaceImagePathToNonLinearAssets(svgNode, objData.value); // Remove this for image load opacity conflict.
                    objData.data = svgNode.outerHTML;
                }
                resolve(objData);
            } else {
                DiagramAssetLoader.oneAssetTimeDownload(resolve, objData, addToDefs, defsParent, reject, isAsync);
            }
        } else {
            DiagramAssetLoader.oneAssetTimeDownload(resolve, objData, addToDefs, defsParent, reject);
        }
    });
};

DiagramAssetLoader.prototype.loadDiagramAssets = function (diagramParent, arrayAssets, appAssetURL) {
    this.loadAssetCount = 0;
    return new Promise((resolve, reject) => {
        for (let i = 0; i < arrayAssets.length; i++) {
            if (arrayAssets[i] && arrayAssets[i].type == "icon") {
                const strAssetUrl = arrayAssets[i].value;
                let strAssetPrefixURL = appAssetURL;
                strAssetPrefixURL = !!arrayAssets[i].corporateUrl && arrayAssets[i].corporateUrl != "" ? appCorporateURL : strAssetPrefixURL;
                this.downloadDiagramAsset(arrayAssets, strAssetPrefixURL + strAssetUrl, i, resolve, reject, diagramParent);
            } else {
                this.loadAssetCount = this.loadAssetCount + 1;
                if (arrayAssets.length == this.loadAssetCount) resolve();
            }
        }
    });
};

DiagramAssetLoader.prototype.downloadDiagramAsset = function (arrayAssets, assetURL, index, resolve, reject, diagramParent) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", assetURL);
    xhr.onload = (data) => {
        arrayAssets[index].data = data.target.response;
        if (xhr.status == 200) DiagramNodeUtils.appenDefs(arrayAssets[index], diagramParent);
        this.loadAssetCount++;
        if (arrayAssets.length == this.loadAssetCount) resolve();
    };

    xhr.onerror = () => {
        this.loadAssetCount++;
        if (arrayAssets.length == this.loadAssetCount) resolve();
        if (reject) reject(xhr.statusText);
        console.log("File could not be loaded..." + xhr.statusText);
    };

    xhr.send();
};

DiagramAssetLoader.oneTimeSimpleDownload = function (objData, addToDefs = false, defsParent = null) {
    let defs = DiagramNodeUtils.getDocumentDefs(document.body);
    let updateDiagram = DiagramNodeUtils.getAssertFromDefs(objData.id, objData.value, defs);
    if (updateDiagram || DiagramAssetLoader.arrInLoading.includes(DiagramNodeUtils.getIconName(objData))) {
        console.log("Already In Defs or Inloading");
    } else {
        DiagramAssetLoader.arrInLoading.push(DiagramNodeUtils.getIconName(objData));
        const xhr = new XMLHttpRequest();
        xhr.open("GET", objData.value);
        xhr.onload = (data) => {
            if (xhr.status == 200) {
                objData.data = data.target.response;
                DiagramNodeUtils.appenDefs(objData, document.body);
                let index = DiagramAssetLoader.arrInLoading.indexOf(DiagramNodeUtils.getIconName(objData));
                console.log("Loaded" + objData.id);
                if (index !== -1) {
                    DiagramAssetLoader.arrInLoading.splice(index, 1);
                }
            }
        };
        xhr.onerror = () => {
            console.log("File could not be loaded..." + xhr.statusText);
        };
        xhr.send();
    }
};

//used for zoomdiagram

DiagramAssetLoader.loadAssetGroup = function (diagramParent, arrayAssets, appAssetURL) {
    let arrPromises = arrayAssets.map((asset) => {
        return new Promise((resolve, reject) => {
            const strAssetUrl = asset.value;
            let strAssetPrefixURL = appAssetURL;
            strAssetPrefixURL = !!asset.corporateUrl && asset.corporateUrl != "" ? appCorporateURL : strAssetPrefixURL;
            DiagramAssetLoader.downloadGroupAsset(asset, strAssetPrefixURL + strAssetUrl, resolve, reject, diagramParent);
        });
    });

    return Promise.all(arrPromises);
};

DiagramAssetLoader.downloadGroupAsset = function (asset, assetURL, resolve, reject, diagramParent) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", assetURL);
    xhr.onload = (data) => {
        asset.data = data.target.response;
        if (xhr.status == 200) DiagramNodeUtils.appenDefs(asset, diagramParent);
        resolve();
    };

    xhr.onerror = () => {
        if (reject) reject(xhr.statusText);
        console.log("File could not be loaded..." + xhr.statusText);
    };
    xhr.send();
};

/**
 * Author:    Saravanan G
 * Created:   22.04.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function DiagramEventManager() {
    this.events = [];
    this.observers = [];
    this.eventListeners = [];
}

DiagramEventManager.prototype.constructor = DiagramEventManager;

DiagramEventManager.prototype.addListener = function (event, callback) {
    if (typeof callback !== "function") {
        console.log(`The listener callback must be a function, the given type is ${typeof callback}`);
        return false;
    }
    if (typeof event !== "string") {
        console.log(`The event name must be a string, the given type is ${typeof event}`);
        return false;
    }
    if (this.eventListeners[event] === undefined) {
        this.eventListeners[event] = {
            listeners: [],
        };
    }
    this.eventListeners[event].listeners.push(callback);
};

DiagramEventManager.prototype.removeListener = function (event, callback) {
    if (this.eventListeners[event] === undefined) {
        console.log(`This event: ${event} does not exist`);
        return false;
    }

    this.eventListeners[event].listeners = this.eventListeners[event].listeners.filter((listener) => {
        return listener.toString() !== callback.toString();
    });
};

DiagramEventManager.prototype.dispatch = function (event, details) {
    if (this.eventListeners[event] === undefined) {
        console.log(`This event: ${event} does not exist`);
        return false;
    }
    this.eventListeners[event].listeners.forEach((listener) => {
        listener(details);
    });
};

DiagramEventManager.prototype.addEvent = function (noddeItem, eventName, invokeMethod) {
    try {
        //noddeItem.addEventListener(eventName, invokeMethod);
        if (eventName == "paste" || eventName == "mousedown") {
            noddeItem.removeEventListener(eventName, invokeMethod);
            $(noddeItem).off(eventName);
        }
        $(noddeItem).on(eventName, invokeMethod);
        this.events.push({ noddeItem: noddeItem, eventName: eventName, invokeMethod: invokeMethod });
    } catch (error) {
        console.log(error);
    }
};

DiagramEventManager.prototype.removeEvent = function (noddeItem, eventName) {
    for (let i = 0; i < this.events.length; i++) {
        let event = this.events[i];
        if (event.noddeItem.id == noddeItem.id && event.eventName == eventName) {
            try {
                event.noddeItem.removeEventListener(event.eventName, event.invokeMethod);
                $(event.noddeItem).off(event.eventName);
            } catch (error) {
                console.log(error);
            }
            this.events.splice(i, 1);
        }
    }
};

DiagramEventManager.prototype.clear = function () {
    // console.log("clearcalled");
    for (let i = 0; i < this.events.length; i++) {
        try {
            let event = this.events[i];
            let noddeItem = event.noddeItem;
            noddeItem.removeEventListener(event.eventName, event.invokeMethod);
            $(noddeItem).off();
        } catch (error) {
            console.log(error);
        }
    }

    while (this.observers.length > 0) {
        if (this.observers[0]) this.observers[0].disconnect();
        this.observers.splice(0, 1);
    }
    this.events = [];
    this.eventListeners = [];
};

DiagramEventManager.prototype.addObserver = function (observer) {
    this.observers.push(observer);
};

DiagramEventManager.prototype.removeObserver = function (observer) {
    if (observer) observer.disconnect();
};

/**
 * Author:    Saravanan G
 * Created:   02.06.2021
 *
 * (c) Copyright by Gs.
 **/
//Blocked Recursive Image Composition
"use strict";

function AspectLayoutManagerUtil() {
    this.treeMemo = new Map();
    this.partMemo = new Map();
}

AspectLayoutManagerUtil.prototype.constructor = AspectLayoutManagerUtil;

AspectLayoutManagerUtil.prototype.clear = function () {
    this.treeMemo = new Map();
    this.partMemo = new Map();
};

AspectLayoutManagerUtil.prototype.cartesianProduct = function (arrays) {
    if (arrays.length == 0) return [[]];
    let subProduct = this.cartesianProduct(arrays.slice(1));
    return arrays[0].map((v) => subProduct.map((arr) => [v].concat(arr))).reduce((l, r) => l.concat(r), []);
};

AspectLayoutManagerUtil.prototype.partitionTrees = function (n) {
    if (n === 1) {
        return [1];
    }
    if (!this.treeMemo.has(n)) {
        if (n >= 8) {
            let l = Math.floor(n / 2);
            let r = n - l;
            this.treeMemo.set(n, this.cartesianProduct([this.partitionTrees(l), this.partitionTrees(r)]));
        } else {
            this.treeMemo.set(
                n,
                this.partitions(n)
                    .slice(1)
                    .map((partition) => this.cartesianProduct(partition.map((k) => this.partitionTrees(k))))
                    .reduce((l, r) => l.concat(r), [])
            );
        }
    }
    return this.treeMemo.get(n);
};

AspectLayoutManagerUtil.prototype.partitions = function (n) {
    if (n == 1) {
        return [[1]];
    }
    if (!this.partMemo.has(n)) {
        let res = [[n]];
        for (let ii = 1; ii < n; ii++) {
            for (let part of this.partitions(n - ii)) {
                res.push([ii].concat(part));
            }
        }
        this.partMemo.set(n, res);
    }
    return this.partMemo.get(n);
};

AspectLayoutManagerUtil.prototype.beside = function (subs) {
    let zs = subs.map((x) => 1 / x.h);
    let sum = zs.reduce((l, r) => l + r, 0);
    zs = zs.map((z) => z / sum);

    let l = 0;
    let xs = [];
    for (let z of zs) {
        xs.push(l);
        l += z;
    }
    return {
        h: 1 / sum,
        zs: subs.map((sub, ii) => sub.zs.map((z) => z * zs[ii])).reduce((l, r) => l.concat(r), []),
        xs: subs.map((sub, ii) => sub.xs.map((x) => x * zs[ii] + xs[ii])).reduce((l, r) => l.concat(r), []),
        ys: subs.map((sub, ii) => sub.ys.map((y) => y * zs[ii])).reduce((l, r) => l.concat(r), []),
    };
};

AspectLayoutManagerUtil.prototype.above = function (subs) {
    let ys = [];
    let h = 0;
    for (let sub of subs) {
        ys.push(h);
        h += sub.h;
    }
    return {
        h: subs.reduce((l, r) => l + r.h, 0),
        zs: subs.map((sub) => sub.zs).reduce((l, r) => l.concat(r), []),
        xs: subs.map((sub) => sub.xs).reduce((l, r) => l.concat(r), []),
        ys: subs.map((sub, ii) => sub.ys.map((y) => y + ys[ii])).reduce((l, r) => l.concat(r), []),
    };
};

AspectLayoutManagerUtil.prototype.scorePartitionTree = function (hs, H, tree) {
    let n = 0;

    function go(f1, f2, t) {
        if (Array.isArray(t)) {
            return f1(t.map((ch) => go(f2, f1, ch)));
        } else {
            return {
                h: hs[n++],
                zs: [1],
                xs: [0],
                ys: [0],
            };
        }
    }
    let horizontal = this.fitToWindow(H, go(this.beside, this.above, tree));
    n = 0;
    let vertical = this.fitToWindow(H, go(this.above, this.beside, tree));
    return [this.score(hs, horizontal), this.score(hs, vertical)];
};

AspectLayoutManagerUtil.prototype.fitToWindow = function (H, layout) {
    let dx = 0,
        dy = 0,
        scale = 1;
    if (H < layout.h) {
        scale = H / layout.h;
        dx = 0.5 * (1 - scale);
    } else {
        dy = 0.5 * (H - layout.h);
    }
    return {
        h: H,
        zs: layout.zs.map((z) => z * scale),
        xs: layout.xs.map((x) => x * scale + dx),
        ys: layout.ys.map((y) => y * scale + dy),
        letterboxing: dx + dy,
    };
};

AspectLayoutManagerUtil.prototype.score = function (hs, layout) {
    let areas = layout.zs.map((z, ii) => z * Math.sqrt(hs[ii]));
    let avgArea = areas.reduce((l, r) => l + r, 0) / areas.length;
    let avgDiff = areas.reduce((l, r) => l + Math.pow(r - avgArea, 2), 0) / areas.length;
    return Object.assign(layout, { score: 1 * Math.pow(layout.letterboxing, 2) + avgDiff });
};

// input:
//  - W: overall width of viewport in pixels, e.g. 400
//  - H: overall height of viewport in pixels, e.g. 600
//  - hs: aspect ratios of pictures (height/width), e.g. [1, 1.5, 1.33, 0.4]
// output:
//  - list of layouts in order from best to worst
//  - each layout has a list {x,y,w,h} for each image
AspectLayoutManagerUtil.prototype.tileImages = function (W, H, hs) {
    let pations = this.partitionTrees(hs.length);
    let scorparts = pations.map((tree) => this.scorePartitionTree(hs, H / W, tree));
    let layouts = scorparts.reduce((l, r) => l.concat(r), []);
    layouts.sort((l, r) => l.score - r.score);
    return layouts.map((layout) =>
        layout.zs.map((z, ii) => ({
            x: layout.xs[ii] * W,
            y: layout.ys[ii] * W,
            w: z * W,
            h: z * hs[ii] * W,
        }))
    );
};

/**
 * Author:    Saravanan G
 * Created:   02.06.2021
 *
 * (c) Copyright by Gs.
 **/
//Blocked Recursive Image Composition
"use strict";

function GridLayoutManagerUtil() {}

GridLayoutManagerUtil.layouts = [
    {
        one1: {
            rows: 1,
            cols: 1,
            cells: [[0, 0, 1, 1]],
            autoSplit: true,
        },
    },
    {
        two1: {
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
            ],
            autoSplit: true,
        },
        two2: {
            cols: 1,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [0, 1, 1, 1],
            ],
            autoSplit: true,
        },
        two3: {
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 2, 1],
                [2, 0, 1, 1],
            ],
            autoSplit: true,
        },
        two4: {
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 2, 1],
            ],
            autoSplit: true,
        },
        two5: {
            cols: 1,
            rows: 2,
            cells: [
                [0, 0, 1, 0.8],
                [0, 0.8, 1, 1.2],
            ],
            autoSplit: true,
        },
        two6: {
            cols: 1,
            rows: 2,
            cells: [
                [0, 0, 1, 1.2],
                [0, 1.2, 1, 0.8],
            ],
            autoSplit: true,
        },
        two7: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [1, 0.25, 1, 0.75],
            ],
            autoSplit: true,
        },
        two8: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0.25, 1, 0.75],
                [1, 0, 1, 1],
            ],
            autoSplit: true,
        },
        two8Small: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0.1, 1, 0.9],
                [1, 0, 1, 1],
            ],
            autoSplit: true,
        },

        two9Small: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [1, 0.1, 1, 0.9],
            ],
            autoSplit: true,
        },
        two10: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0.1, 0.45, 0.4, 0.45],
                [1.2, 0, 0.8, 1],
            ],
            autoSplit: true,
        },
        two11: {
            hide: true,
            cols: 1,
            rows: 2,
            cells: [
                [0.25, 0, 0.75, 1],
                [0, 1, 0.75, 1],
            ],
            autoSplit: true,
        },

        two12: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 0.6, 1],
                [1.4, 0, 0.6, 1],
            ],
            autoSplit: true,
        },
        two13: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [2, 0, 1, 1],
            ],
            autoSplit: true,
        },
        two14: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0.1, 1.5, 0.9],
                [0.6, 0, 1.5, 0.9],
            ],
            autoSplit: true,
        },
        two15: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [1.21, 0, 1.79, 0.56],
                [0, 0.54, 1.25, 0.46],
            ],
            autoSplit: true,
        },
        two16: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.08, 1, 0.84],
                [1.8, 0.08, 1.2, 0.4],
            ],
        },
        two17: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 0.98, 0.8],
                [1.02, 0.6, 0.98, 0.4],
            ],
        },
        two18: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0.15, 1.2, 0.66],
                [1.3, 0.04, 0.7, 0.43],
            ],
        },
        two19: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0.18, 0.38, 1.417, 0.82],
                [1.9, 0.1, 0.85, 0.5],
            ],
        },
        two20: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0.2, 0, 1.8, 0.9],
                [0, 0.3, 1.4, 0.7],
            ],
        },
        two21: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1.3, 0.5],
                [0.75, 0.5, 1.25, 0.5],
            ],
        },
        two22: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [1.9, 0.05, 0.8, 0.48],
                [0.7, 0.7, 0.34, 0.2],
            ],
        },
        two23: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.14, 1.13, 0.36],
                [0, 0.51, 2.7, 0.36],
            ],
        },
        two24: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0.9, 0, 1.1, 0.44],
                [0, 0.43, 1.4, 0.55],
            ],
        },
        two25: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1, 0.85],
                [1, 0.15, 1, 0.85],
            ],
        },
        two26: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [1.21, 0, 1.78, 0.5],
                [0, 0.52, 1.55, 0.48],
            ],
        },
        two27: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [1.65, 0.32, 1.35, 0.68],
                [0, 0.65, 1.6, 0.35],
            ],
        },
        two28: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 3, 0.54],
                [0, 0.55, 3, 0.44],
            ],
        },
        two29: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 3, 0.56],
                [0, 0.56, 3, 0.46],
            ],
        },
        two30: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [2.1, 0, 0.8, 0.48],
                [1.8, 0.51, 0.7, 4],
            ],
        },
        two31: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 3, 0.615],
                [0, 0.615, 3, 0.615],
            ],
        },
        two32: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 3, 0.5],
                [0, 0.5, 3, 0.5],
            ],
        },
        two33: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 1, 1, 0.5],
                [1, 1, 1, 0.5],
            ],
        },
        two34: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 2, 0.5],
                [1, 0.5, 1, 0.5],
            ],
        },
        two35: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0.95, 0.07, 0.65, 0.57],
                [1.46, 0.53, 0.45, 0.4],
            ],
        },
        two36: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0.02, 0.4, 1.02, 0.6],
                [0.98, 0, 1.04, 0.616],
            ],
        },
        two37: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1.025, 1],
                [1, 0, 1.025, 1],
            ],
        },
        two38: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1, 0.6],
                [1, 0.4, 1, 0.6],
            ],
        },
        two39: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1.16, 1],
                [1.16, 0.49, 0.94, 0.51],
            ],
        },
        two40: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
            ],
        },
        two41: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0.1, 0.16, 1.025, 0.67],
                [1.38, 0.02, 0.5, 0.97],
            ],
        },
        two42: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
            ],
        },
        two43: {
            hide: true,
            cols: 1,
            rows: 1,
            cells: [
                [0, 0, 1, 0.6],
                [0, 0.6, 1, 0.4],
            ],
        },
        two44: {
            hide: true,
            cols: 1,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [0, 0, 1, 1],
            ],
        },
        two45: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1, 1],

                [1, 0, 0.8, 1],
            ],
        },
        two46: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0.5, 0.5, 0.6],
                [1.3, 0, 0.7, 1],
            ],
        },
        two47: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0, 0, 0.9, 0.9],
                [0.7, 0.5, 1.4, 1.4],
            ],
            autoSplit: true,
        },
        two48: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0, 1, 1.6, 1],
                [1.15, 0, 0.85, 2],
            ],
            autoSplit: true,
        },
        two49: {
            hide: true,
            cols: 4,
            rows: 5,
            cells: [
                [2.2, 0, 1.35, 1.5],
                [1, 3.5, 1.35, 1.5],
            ],
        },
        two50: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0.35, 0.8, 0.413],
                [0.8, 0, 1.2, 1],
            ],
            autoSplit: true,
        },
        two51: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1.3, 0.65],
                [1.07, 0.55, 0.93, 0.45],
            ],
        },
        two52: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0.45, 0.9, 0.55],
                [0.9, 0, 1.1, 0.9],
            ],
            autoSplit: true,
        },
        two53: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0.22, 0, 0.91, 1.15],

                [0.72, 0.2, 1.26, 1.8],
            ],
        },
        two54: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1, 0.85],
                [1, 0.15, 1, 0.85],
            ],
        },
        two55: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0.75, 0.8, 0.3],

                [0.8, 0, 1.1, 1],
            ],
        },
        two56: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0.1, 0.3, 0.6, 0.7],
                [1.3, 0, 0.6, 0.7],
            ],
        },
    },
    {
        three1: {
            cols: 2,
            rows: 2,
            cells: [
                [0, 0, 1, 2],
                [1, 0, 1, 1],
                [1, 1, 1, 1],
            ],
        },
        three2: {
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
            ],
        },
        three3: {
            cols: 2,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 0, 1, 2],
            ],
        },
        three4: {
            cols: 2,
            rows: 2,
            cells: [
                [0, 0, 2, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
            ],
        },

        three5: {
            cols: 2,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [0, 1, 2, 1],
            ],
        },
        three6: {
            cols: 1,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [0, 1, 1, 1],
                [0, 2, 1, 1],
            ],
        },
        three7: {
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 0.75, 1],
                [0.75, 0, 1.5, 1],
                [2.25, 0, 0.75, 1],
            ],
        },
        three8: {
            cols: 1,
            rows: 3,
            cells: [
                [0, 0, 1, 0.75],
                [0, 0.75, 1, 1.5],
                [0, 2.25, 1, 0.75],
            ],
        },

        three9: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [1, 0.2, 1, 0.8],
                [2, 0.4, 1, 0.6],
            ],
        },
        three9Small: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [1, 0.1, 1, 0.9],
                [2, 0.2, 1, 0.8],
            ],
        },
        three10: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.4, 1, 0.6],
                [1, 0.2, 1, 0.8],
                [2, 0, 1, 1],
            ],
        },
        three10Small: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.2, 1, 0.8],
                [1, 0.1, 1, 0.9],
                [2, 0, 1, 1],
            ],
        },
        three11: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.5, 0.8, 0.5],
                [1.1, 0, 0.8, 0.5],
                [2.2, 0.3, 0.8, 0.5],
            ],
            autoSplit: true,
        },
        three12: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.42, 1, 0.5],
                [1, 0, 1, 1],
                [2, 0.08, 1, 0.84],
            ],
        },
        three13: {
            hide: true,
            cols: 4,
            rows: 1,
            cells: [
                [0, 0.15, 1.24, 0.66],
                [1.36, 0.04, 0.7, 0.43],
                [3.5, 0.71, 0.4, 0.17],
            ],
        },
        three14: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0.18, 0.15, 1.23, 0.7],
                [1.84, 0.1, 0.85, 0.5],
                [2.7, 0.7, 0.37, 0.22],
            ],
        },
        three15: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [1.9, 0.45, 0.8, 0.48],
                [0.6, 0.07, 0.5, 0.3],
                [0.7, 0.67, 0.34, 0.2],
            ],
        },
        three16: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.14, 1.13, 0.36],
                [0, 0.51, 2.3, 0.36],
                [2, 0.2, 2.14, 0.65],
            ],
        },
        three17: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0.9, 0, 1.1, 0.44],
                [0, 0.43, 1.4, 0.55],
                [1.4, 0.43, 0.6, 0.24],
            ],
        },

        three18: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0, 0.3, 0.9, 1.4],
                [1.15, 0, 0.85, 1.1],
                [0.9, 1.1, 0.85, 0.9],
            ],
        },

        three19: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0.7, 0, 0.8, 1],
                [0, 1, 0.86, 1],
                [1.09, 1, 0.91, 1],
            ],
        },
        three20: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0, 0, 1, 0.6],
                [0, 0.6, 1, 1.1],
                [1, 0.2, 1, 1.8],
            ],
        },
        three21: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.5, 1.05, 0.5],
                [1.1, 0, 1.05, 0.5],
                [2.2, 0.2, 0.8, 0.5],
            ],
        },
        three22: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0.3, 0, 1.5, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 0.8],
            ],
        },
        three23: {
            cols: 1,
            rows: 1,
            cells: [
                [0, 0, 1, 0.5],
                [0, 0.5, 0.33, 0.5],
                [0.33, 0.5, 0.67, 0.5],
            ],
        },
        three24: {
            hide: true,
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 1, 0.8],
                [0, 0.8, 1, 1.2],
                [2, 0, 1, 2],
            ],
        },
        three25: {
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 3, 0.6],
                [0, 0.6, 1.5, 0.4],
                [1.5, 0.6, 1.5, 0.4],
            ],
        },
        three26: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0, 0, 0.7, 1],
                [0.7, 0.2, 1, 1.1],
                [0.4, 1.3, 1.6, 0.7],
            ],
        },

        three27: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 1, 1, 0.5],
                [1, 1, 1, 0.5],
                [2, 1, 1, 0.5],
            ],
        },
        three28: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 1.5, 0.615],
                [1.5, 0, 1.5, 0.615],
                [0, 0.615, 3, 0.615],
            ],
        },
        three29: {
            hide: true,

            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 2, 0.5],
                [2, 0, 1, 0.5],
                [1.5, 0.5, 1.5, 0.5],
            ],
        },
        three30: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0.95, 0.07, 0.65, 0.57],
                [1.46, 0.53, 0.45, 0.4],
                [1, 0.63, 0.35, 0.305],
            ],
        },
        three31: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.6, 1.04, 0.4],
                [0.98, 0.4, 1.04, 0.6],
                [1.96, 0, 1.04, 0.63],
            ],
        },
        three32: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.6, 0.85, 0.4],
                [0.85, 0.6, 0.85, 0.4],

                [1.7, 0, 1.3, 1],
            ],
        },
        three33: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 1.555, 0.349],
                [0, 0.653, 1.55, 0.35],
                [1.47, 0.326, 1.55, 0.675],
            ],
        },
        three34: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 0.915, 1],
                [0.912, 0.37, 0.7, 0.63],
                [1.612, 0.6, 1.4, 0.4],
            ],
        },
        three35: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 0.85, 1],
                [0.85, 0, 1.3, 1],
                [2.15, 0, 0.85, 1],
            ],
        },
        three36: {
            hide: true,
            cols: 1,
            rows: 3,
            cells: [
                [0.25, 0, 1.75, 2.2],
                [0, 1.2, 0.57, 1.8],
                [0.6, 2, 0.35, 0.8],
            ],
        },
        three37: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1.3, 0.65],
                [0, 0.64, 0.73, 0.36],
                [1.07, 0.55, 0.93, 0.45],
            ],
        },
        three38: {
            hide: true,
            cols: 1,
            rows: 1,
            cells: [
                [0, 0, 1, 0.6],
                [0, 0.6, 0.5, 0.4],
                [0.5, 0.6, 0.5, 0.4],
            ],
        },
        three39: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0, 0, 1, 0.9],

                [0.6, 1, 1.4, 1],
                [1, 0, 0.75, 1.4],
            ],
        },
        three40: {
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 1.6, 1],
                [1.6, 0, 0.6, 1],
                [2.2, 0, 0.6, 1],
            ],
        },
        three41: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0, 1, 0.8, 1],
                [0.9, 0.3, 1.1, 1.4],
                [0.4, 0, 0.85, 0.8],
            ],
        },
        three42: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.15, 0.9, 0.7],

                [0.9, 0, 1.2, 1],
                [2.1, 0.15, 0.9, 0.7],
            ],
        },
        three43: {
            hide: true,
            cols: 3,
            rows: 2,
            cells: [
                [0, 0.5, 1.75, 0.7],
                [1, 1, 2, 1],
                [2.25, 0, 0.75, 1.3],
            ],
        },
        three44: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0, 0, 1, 1.3],
                [1, 0, 1, 1],
                [1, 1, 1, 1],
            ],
        },
        three45: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0.35, 0.85, 0.75, 1],
                [1.15, 0.65, 1, 1],
                [0.1, -0.2, 1.2, 1.15],
            ],
        },
        three46: {
            hide: true,
            cols: 3,
            rows: 2,
            cells: [
                [0, 0.9, 1, 1.1],
                [0.9, 0.9, 1.2, 1.1],
                [1.75, 0, 1.25, 2],
            ],
        },
        three47: {
            hide: true,
            cols: 4,
            rows: 5,
            cells: [
                [2.8, 0, 1.25, 1.5],
                [2, 3.8, 1.35, 1.2],
                [0, 1.25, 0.75, 2.5],
            ],
        },
        three48: {
            cols: 1,
            rows: 1,
            cells: [
                [0, 0, 1, 0.55],
                [0, 0.55, 0.7, 0.45],
                [0.7, 0.55, 0.3, 0.45],
            ],
        },
        three49: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 0.85, 0.4],
                [0.85, 0, 0.85, 0.4],

                [1.7, 0, 1.3, 1],
            ],
        },
        three50: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1.1, 0.35],
                [0.34, 0.34, 0.76, 0.65],
                [1.1, 0.2, 0.9, 0.7],
            ],
            autoSplit: true,
        },
        three51: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.32, 1, 0.68],
                [1, 0, 1, 1],
                [2, 0, 1, 0.7],
            ],
        },
        three52: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0.22, 0, 0.91, 1.15],
                [0, 1.15, 0.86, 0.85],
                [0.72, 0.2, 1.26, 1.8],
            ],
        },
        three54: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.75, 0.8, 0.3],
                [0.8, 0.7, 0.8, 0.45],
                [1.6, 0, 1.4, 1],
            ],
        },
        three53: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0, 0, 1, 0.6],
                [0, 0.6, 1, 1.1],
                [1, 0.2, 1, 1.8],
            ],
        },

        three55: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.25, 1, 0.75],
                [1, 0, 1, 1],
                [2, 0.35, 1, 0.65],
            ],
        },
        three56: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0, 0, 1, 0.9],
                [0.7, 0.9, 1.3, 1.1],
                [1, 0, 0.85, 1.2],
            ],
        },
        three57: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.3, 0.8, 0.7],
                [1.1, 0, 0.8, 0.7],
                [2.05, 0.1, 0.8, 0.8],
            ],
            autoSplit: true,
        },
        three58: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0.1, 0.47, 0.4, 0.45],
                [0.96, 0, 0.25, 0.3],
                [1.2, 0, 0.8, 1],
            ],
            autoSplit: true,
        },
    },
    {
        four1: {
            cols: 2,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
            ],
        },
        four2: {
            cols: 2,
            rows: 3,
            cells: [
                [0, 0, 1, 3],
                [1, 0, 1, 1],
                [1, 1, 1, 1],
                [1, 2, 1, 1],
            ],
        },
        four3: {
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 2, 1],
                [2, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 2, 1],
            ],
        },
        four4: {
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 2, 1],
                [0, 1, 2, 1],
                [2, 1, 1, 1],
            ],
        },
        four5: {
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 2, 1],
                [2, 0, 1, 1],
                [0, 1, 2, 1],
                [2, 1, 1, 1],
            ],
        },
        four6: {
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 2, 1],
                [0, 1, 1, 1],
                [1, 1, 2, 1],
            ],
        },
        four7: {
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 3, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
            ],
        },
        four8: {
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [0, 1, 3, 1],
            ],
        },
        four9: {
            cols: 4,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
            ],
        },
        four10: {
            cols: 1,
            rows: 4,
            cells: [
                [0, 0, 1, 1],
                [0, 1, 1, 1],
                [0, 2, 1, 1],
                [0, 3, 1, 1],
            ],
        },
        four11: {
            cols: 2,
            rows: 2,
            cells: [
                [0, 0, 1, 2],
                [1, 0, 0.5, 1],
                [1.5, 0, 0.5, 1],
                [1, 1, 1, 1],
            ],
        },
        four12: {
            cols: 2,
            rows: 2,
            cells: [
                [0, 0, 1.5, 1.4],
                [1.5, 0, 0.5, 0.6],
                [0, 1.4, 1.5, 0.6],
                [1.5, 0.6, 0.5, 1.4],
            ],
        },

        four13: {
            hide: true,
            cols: 4,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [1, 0.14, 1, 0.86],
                [2, 0.27, 1, 0.73],
                [3, 0.4, 1, 0.6],
            ],
        },
        four13Small: {
            hide: true,
            cols: 4,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [1, 0.1, 1, 0.9],
                [2, 0.2, 1, 0.8],
                [3, 0.3, 1, 0.7],
            ],
        },
        four14: {
            hide: true,
            cols: 4,
            rows: 1,
            cells: [
                [0, 0.4, 1, 0.6],
                [1, 0.27, 1, 0.73],
                [2, 0.14, 1, 0.86],
                [3, 0, 1, 1],
            ],
        },
        four14Small: {
            hide: true,
            cols: 4,
            rows: 1,
            cells: [
                [0, 0.22, 1, 0.78],
                [1, 0.15, 1, 0.85],
                [2, 0.05, 1, 0.95],
                [3, 0, 1, 1],
            ],
        },
        four15: {
            hide: true,
            cols: 4,
            rows: 1,
            cells: [
                [0, 0.6, 1, 0.4],
                [2.15, 0.35, 0.8, 0.32],
                [2.5, 0, 1.3, 0.23],
                [3.18, 0.3, 1, 0.6],
            ],
        },
        four16: {
            hide: true,
            cols: 4,
            rows: 1,
            cells: [
                [0, 0.42, 1.32, 0.5],
                [1.34, 0, 1.32, 0.68],
                [2.68, 0.08, 1.32, 0.84],
                [1.35, 0.685, 1.32, 0.315],
            ],
        },
        four17: {
            hide: true,
            cols: 4,
            rows: 1,
            cells: [
                [0, 0.15, 1.24, 0.66],
                [1.36, 0.04, 0.7, 0.43],
                [1.6, 0.58, 0.92, 0.39],
                [3.5, 0.71, 0.4, 0.17],
            ],
        },

        four18: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0.92, 0, 0.65, 1],
                [0, 1.45, 0.35, 0.55],
                [0.36, 1, 0.66, 1],
                [1.25, 1, 0.75, 1],
            ],
        },
        four19: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [1.9, 0.45, 0.8, 0.48],
                [0.6, 0.07, 0.5, 0.3],
                [2.1, 0.23, 0.34, 0.2],
                [0.7, 0.67, 0.34, 0.2],
            ],
        },
        four20: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0.2, 0.2, 0.8, 0.8],
                [1, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 0.8, 0.8],
            ],
        },
        four21: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0, 0, 1, 0.6],
                [0, 0.6, 1, 1.1],
                [1, 0.2, 1, 1.2],
                [1, 1.4, 1, 0.6],
            ],
        },
        four22: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [1.2, 0, 1.78, 0.5],
                [0, 0.52, 1.55, 0.48],
                [1.61, 0.52, 0.9, 0.25],
                [0, 0.21, 1.1, 0.29],
            ],
        },
        four23: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [1, 0.37, 1.2, 0.67],
                [0.2, 0, 2, 0.37],
                [0, 0.37, 1, 0.33],
                [2.2, 0.25, 0.8, 0.27],
            ],
        },
        four24: {
            hide: true,
            cols: 4,
            rows: 1,
            cells: [
                [0, 0.7, 1.65, 0.3],
                [2.35, 0, 1.4, 0.295],
                [1.68, 0.3, 1.25, 0.5],
                [2.96, 0.58, 1.05, 0.35],
            ],
        },
        four25: {
            hide: true,
            cols: 4,
            rows: 1,
            cells: [
                [0, 0, 2.65, 0.54],
                [0, 0.55, 1.3, 0.44],
                [1.33, 0.55, 1.3, 0.44],
                [2.66, 0.55, 1.3, 0.44],
            ],
        },
        four26: {
            hide: true,
            cols: 4,
            rows: 1,
            cells: [
                [0, 0, 2, 0.5],
                [2, 0, 2, 0.5],
                [0, 0.5, 2, 0.5],
                [2, 0.5, 2, 0.5],
            ],
        },
        four27: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [1.3, 0.47, 0.59, 0.27],
                [2.24, 0.54, 0.55, 27],
                [1.3, 0.05, 0.62, 0.3],
                [2.24, 0.06, 0.59, 0.27],
            ],
        },
        four28: {
            hide: true,
            cols: 4,
            rows: 1,
            cells: [
                [0, 0, 2, 0.45],
                [2, 0, 2, 0.725],
                [0, 0.45, 2, 0.725],
                [2, 0.725, 2, 0.45],
            ],
        },
        four29: {
            hide: true,
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 0.9, 1],
                [2.1, 0, 0.9, 1],
                [0, 1, 0.9, 1],
                [2.1, 1, 0.9, 1],
            ],
        },
        four30: {
            hide: true,
            cols: 4,
            rows: 1,
            cells: [
                [0, 0, 2, 0.5],
                [2, 0, 2, 0.5],
                [0, 0.5, 2, 0.5],
                [2, 0.5, 2, 0.5],
            ],
        },
        four31: {
            hide: true,
            cols: 4,
            rows: 1,
            cells: [
                [0, 1, 1, 0.5],
                [1, 1, 1, 0.5],
                [2, 1, 1, 0.5],
                [3, 1, 1, 0.5],
            ],
        },
        four32: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1, 0.6],
                [1, 0, 1, 0.6],
                [0, 0.6, 1, 0.4],
                [1, 0.6, 1, 0.4],
            ],
        },
        four33: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 1.8, 0.5],
                [1.8, 0, 1.2, 0.5],
                [1.3, 0.5, 1, 0.5],
                [2.3, 0.5, 0.7, 0.5],
            ],
        },
        four34: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0.95, 0.07, 0.65, 0.57],
                [1.46, 0.53, 0.45, 0.4],
                [1, 0.63, 0.35, 0.305],
                [1.6, 0.07, 0.25, 0.22],
            ],
        },
        four35: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.6, 1.04, 0.4],
                [0.98, 0.4, 1.04, 0.6],
                [1.964, 0, 1.04, 0.55],
                [1.964, 0.5, 1.04, 0.5],
            ],
        },
        four36: {
            hide: true,
            cols: 4,
            rows: 1,
            cells: [
                [0, 0, 1.25, 1],
                [1, 0, 1.25, 1],
                [2, 0, 1.25, 1],
                [3, 0, 1.25, 1],
            ],
        },
        four37: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0.016, 0, 1.04, 0.675],
                [0.99, 0, 1.04, 0.349],
                [0.99, 0.653, 1.04, 0.35],
                [1.962, 0.326, 1.04, 0.675],
            ],
        },
        four38: {
            cols: 2,
            rows: 2,
            cells: [
                [0, 0, 0.75, 0.9],
                [0.75, 0, 1.25, 0.7],
                [0, 0.9, 0.75, 1.1],
                [0.75, 0.7, 1.25, 1.3],
            ],
        },
        four39: {
            hide: true,
            cols: 4,
            rows: 1,
            cells: [
                [0, 0, 1.22, 1],
                [1.22, 0.37, 0.926, 0.63],
                [2.15, 0.6, 0.926, 0.4],
                [3.08, 0.6, 0.926, 0.4],
            ],
        },
        four40: {
            hide: true,
            cols: 4,
            rows: 1,
            cells: [
                [0, 0, 1.15, 0.4],
                [2.85, 0, 1.15, 0.6],
                [0, 0.4, 1.15, 0.6],
                [2.85, 0.6, 1.15, 0.4],
            ],
        },
        four41: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0.55, 0.74, 0.55],
                [0.7, 0.65, 0.67, 0.36],
                [1.33, 0.65, 0.67, 0.36],
                [0.7, 0, 1.3, 0.678],
            ],
        },
        four42: {
            hide: true,
            cols: 1,
            rows: 4,
            cells: [
                [0.3, 0.6, 0.7, 2.4],
                [0.6, 2.3, 0.35, 1.2],
                [0, 1.8, 0.5, 2.2],
                [0.2, 0, 0.35, 1.4],
            ],
        },
        four43: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 0.5],
                [1, 0.5, 0.5, 0.5],
                [1.5, 0.5, 0.5, 0.5],
            ],
        },
        four44: {
            hide: true,
            cols: 1,
            rows: 1,
            cells: [
                [0, 0, 1, 0.35],
                [0, 0.35, 1, 0.25],
                [0, 0.6, 0.5, 0.4],
                [0.5, 0.6, 0.5, 0.4],

                [0, 0, 1, 0.45],
                [0, 0.45, 1, 0.25],
                [0, 0.7, 0.5, 0.3],
                [0.5, 0.7, 0.5, 0.3],
            ],
        },
        four45: {
            hide: true,
            cols: 1,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [0, 0, 1, 1],
                [0, 0, 1, 0.525],
                [0, 0.475, 1, 0.525],
            ],
        },
        four46: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0, 0.2, 1, 0.9],
                [1, 0, 1, 0.9],
                [0, 1.1, 1, 0.9],
                [1, 0.9, 1, 0.9],
            ],
        },

        four47: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0, 1, 0.8, 1],
                [0.9, 0.3, 0.95, 1.4],
                [0.4, 0, 0.85, 0.8],
                [1.2, 1.4, 0.8, 0.6],
            ],
        },
        four48: {
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 1, 2],
                [1, 0, 1, 2],
                [2, 0, 1, 1],
                [2, 1, 1, 1],
            ],
        },
        four49: {
            hide: true,
            cols: 3,
            rows: 2,
            cells: [
                [0, 1.3, 1, 0.7],
                [1, 0, 1, 1],
                [2, 0, 1, 1.3],
                [1, 1, 1, 1],
            ],
        },
        four50: {
            hide: true,
            cols: 3,
            rows: 2,
            cells: [
                [0.35, -0.55, 1.75, 2.25],
                [2.1, 0.25, 0.95, 0.85],
                [0.75, 0.95, 0.85, 0.85],
                [1.6, 1, 1.5, 1.35],
            ],
        },
        four51: {
            hide: true,
            cols: 3,
            rows: 2,
            cells: [
                [0, 0.9, 1.1, 1.1],
                [0.97, 0.9, 1.2, 1.1],
                [1.85, 0.9, 1.15, 1.1],
                [1.85, 0, 1.15, 0.9],
            ],
        },
        four52: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0.2, 0.3, 0.8, 0.74],
                [1.3, 0.13, 0.7, 0.6],
                [0, 1.1, 0.8, 0.6],
                [1.05, 0.75, 0.8, 0.74],
            ],
        },
        four53: {
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 3, 1],
                [2, 1, 1, 0.5],
                [0, 1, 2, 1],
                [2, 1.5, 1, 0.5],
            ],
        },
        four54: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0, 0.65, 0.4],
                [0.65, 0, 0.65, 0.4],
                [1.3, 0, 0.65, 0.4],

                [2, 0, 1, 1],
            ],
        },
        four55: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1.3, 0.65],
                [0, 0.66, 0.67, 0.33],
                [1, 0.55, 0.93, 0.45],
                [1.39, 0, 0.6, 0.3],
            ],
        },
        four56: {
            cols: 2,
            rows: 2,
            cells: [
                [0.2, 0, 0.85, 0.85],
                [1.1, 0, 0.9, 2],
                [0, 0.2, 0.45, 0.5],
                [0.7, 0.9, 0.8, 1],
            ],
        },
        four57: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.55, 1, 0.45],
                [1, 0, 0.9, 0.35],
                [1, 0.34, 0.9, 0.57],
                [1.9, 0.2, 1.1, 0.7],
            ],
            autoSplit: true,
        },
        four58: {
            cols: 2,
            rows: 2,
            cells: [
                [0, 0, 1, 0.7],
                [1, 0, 1, 1.3],
                [0, 0.7, 1, 1.3],
                [1, 1.3, 1, 0.7],
            ],
        },
    },
    {
        five1: {
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 2, 1],
            ],
        },
        five2: {
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 2, 1],
                [2, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
            ],
        },
        five3: {
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 1, 2],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
            ],
        },
        five4: {
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 0, 1, 2],
                [2, 0, 1, 1],
                [2, 1, 1, 1],
            ],
        },
        five5: {
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 0, 1, 1],
                [1, 1, 1, 1],
                [2, 0, 1, 2],
            ],
        },
        five6: {
            cols: 4,
            rows: 2,
            cells: [
                [0, 0, 4, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
            ],
        },
        five7: {
            cols: 4,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [0, 1, 4, 1],
            ],
        },
        five8: {
            cols: 4,
            rows: 2,
            cells: [
                [0, 0, 2, 2],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
            ],
        },
        five9: {
            cols: 4,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 0, 2, 2],
            ],
        },
        five10: {
            cols: 4,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 0, 2, 2],
                [3, 0, 1, 1],
                [3, 1, 1, 1],
            ],
        },
        five11: {
            cols: 6,
            rows: 2,
            cells: [
                [0, 0, 2, 1],
                [2, 0, 2, 1],
                [4, 0, 2, 1],
                [0, 1, 3, 1],
                [3, 1, 3, 1],
            ],
        },
        five12: {
            cols: 6,
            rows: 2,
            cells: [
                [0, 0, 3, 1],
                [3, 0, 3, 1],
                [0, 1, 2, 1],
                [2, 1, 2, 1],
                [4, 1, 2, 1],
            ],
        },
        five13: {
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 1.5, 1.1],
                [1.5, 0, 1.5, 1.1],
                [0, 1.1, 1, 0.9],
                [1, 1.1, 1, 0.9],
                [2, 1.1, 1, 0.9],
            ],
        },
        five14: {
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 1, 2],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
            ],
        },
        five15: {
            cols: 2,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [0, 1, 2, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
            ],
        },

        five16: {
            hide: true,
            cols: 5,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [1, 0.1, 1, 0.9],
                [2, 0.2, 1, 0.8],
                [3, 0.3, 1, 0.7],
                [4, 0.4, 1, 0.6],
            ],
        },
        five16small: {
            hide: true,
            cols: 5,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [1, 0.1, 1, 0.9],
                [2, 0.2, 1, 0.8],
                [3, 0.3, 1, 0.7],
                [4, 0.4, 1, 0.6],
            ],
        },
        five17: {
            hide: true,
            cols: 5,
            rows: 1,
            cells: [
                [0, 0.4, 1, 0.6],
                [1, 0.3, 1, 0.7],
                [2, 0.2, 1, 0.8],
                [3, 0.1, 1, 0.9],
                [4, 0, 1, 1],
            ],
        },
        five17small: {
            hide: true,
            cols: 5,
            rows: 1,
            cells: [
                [0, 0.4, 1, 0.6],
                [1, 0.3, 1, 0.7],
                [2, 0.2, 1, 0.8],
                [3, 0.1, 1, 0.9],
                [4, 0, 1, 1],
            ],
        },
        five18: {
            cols: 5,
            rows: 1,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],
            ],
        },
        five19: {
            hide: true,
            cols: 3,
            rows: 2,
            cells: [
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
            ],
        },

        five20: {
            hide: true,
            cols: 5,
            rows: 1,
            cells: [
                [0, 0.05, 1, 0.95],
                [1, 0.15, 1, 0.85],
                [2, 0, 1, 1],
                [3, 0.1, 1, 0.9],
                [4, 0.15, 1, 0.85],
            ],
        },
        five21: {
            hide: true,
            cols: 5,
            rows: 5,
            cells: [
                [0.7, 0, 1.4, 1.2],
                [0.4, 3.2, 0.8, 0.85],
                [3.6, 0.2, 0.6, 1.4],
                [3, 4.1, 1.8, 0.9],
                [4.5, 3.4, 0.7, 1.4],
            ],
        },
        five22: {
            hide: true,
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1.04, 0.349],
                [0.98, 0, 1.04, 0.349],
                [0, 0.326, 1.04, 0.349],
                [0, 0.653, 1.04, 0.35],
                [0.98, 0.326, 1.04, 0.675],
            ],
        },
        five23: {
            hide: true,
            cols: 3,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [2, 0, 1, 1],
                [0, 1, 1, 1],
                [2, 1, 1, 1],
                [0, 2, 1, 1],
            ],
        },

        five24: {
            cols: 2,
            rows: 1,
            cells: [
                [0, 0, 1, 0.35],
                [1, 0, 1, 0.25],
                [0, 0.35, 1, 0.65],
                [1, 0.25, 1, 0.6],
                [1, 0.85, 1, 0.15],
            ],
        },
        five25: {
            cols: 3,
            rows: 3,
            cells: [
                [0, 0, 1, 3],
                [1, 0, 1, 3],
                [2, 0, 1, 1],
                [2, 1, 1, 1],
                [2, 2, 1, 1],
            ],
        },
        five26: {
            cols: 2,
            rows: 3,
            cells: [
                [0, -0.25, 1, 1],
                [1, 0, 1, 1.5],
                [0, 0.75, 1, 1.5],
                [1, 1.5, 1, 1.5],
                [0, 2.25, 1, 1],
            ],
        },

        five28: {
            hide: true,
            cols: 5,
            rows: 1,
            cells: [
                [0, 0.1, 1, 0.8],
                [1, 0.1, 1, 0.8],
                [2, 0, 1, 1],
                [3, 0.1, 1, 0.8],
                [4, 0.1, 1, 0.8],
            ],
        },
        five29: {
            hide: true,
            cols: 2,
            rows: 2,
            cells: [
                [0.2, 0.3, 0.8, 0.74],
                [1.3, 0.13, 0.65, 0.45],
                [0, 1.1, 0.8, 0.6],
                [1.05, 0.75, 0.8, 0.74],
                [1.6, 1, 0.6, 0.8],
            ],
        },
    },
    {
        six1: {
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
            ],
        },
        six2: {
            cols: 5,
            rows: 3,
            cells: [
                [0, 0, 5, 2],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
                [3, 2, 1, 1],
                [4, 2, 1, 1],
            ],
        },
        six3: {
            cols: 5,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],
                [0, 1, 5, 2],
            ],
        },
        six4: {
            cols: 5,
            rows: 3,
            cells: [
                [0, 0, 3, 2],
                [3, 0, 2, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
                [3, 1, 2, 2],
            ],
        },
        six5: {
            hide: true,
            cols: 4,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
                [3, 0, 1, 1],
            ],
        },
        six6: {
            cols: 3,
            rows: 3,
            cells: [
                [0, 0, 1, 3],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [1, 2, 2, 1],
            ],
        },
        six7: {
            cols: 4,
            rows: 2,
            cells: [
                [0, 0, 1, 1.25],
                [1, 0, 1, 2],
                [2, 0, 2, 1],
                [0, 1.25, 1, 0.75],
                [2, 1, 0.75, 1],
                [2.75, 1, 1.25, 1],
            ],
        },
        six8: {
            cols: 3,
            rows: 2,
            cells: [
                [0, 0, 1, 0.7],
                [1, 0, 1, 1.3],
                [2, 0, 1, 0.7],
                [0, 0.7, 1, 1.3],
                [1, 1.3, 1, 0.7],
                [2, 0.7, 1, 1.3],
            ],
        },
        six9: {
            cols: 3,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 2, 2],
                [0, 1, 1, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
            ],
        },
        six10: {
            cols: 3,
            rows: 3,
            cells: [
                [0, 0, 2, 2],
                [2, 0, 1, 1],
                [2, 1, 1, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
            ],
        },
        six11: {
            hide: true,
            cols: 3,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [2, 0, 1, 1],
                [0, 1, 1, 1],
                [2, 1, 1, 1],
                [0, 2, 1, 1],
                [2, 2, 1, 1],
            ],
        },
        six12: {
            cols: 4,
            rows: 2,
            cells: [
                [0, 0, 1, 2],
                [1, 0, 1, 2],
                [2, 0, 1, 1],
                [2, 1, 1, 1],
                [3, 0, 1, 1],
                [3, 1, 1, 1],
            ],
        },
        six13: {
            cols: 2,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
            ],
        },
        six14: {
            cols: 2,
            rows: 3,
            cells: [
                [0, -0.25, 1, 1],
                [1, -0.25, 1, 1.5],
                [0, 0.75, 1, 1.2],
                [1, 1.25, 1, 1.2],
                [0, 1.95, 1, 1],
                [1, 2.45, 1, 0.7],
            ],
        },
    },
    {
        seven1: {
            cols: 4,
            rows: 2,
            cells: [
                [0, 0, 1, 2],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 0, 1, 1],
                [3, 1, 1, 1],
            ],
        },
        seven2: {
            cols: 4,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 0, 1, 2],
            ],
        },
        seven3: {
            cols: 4,
            rows: 2,
            cells: [
                [0, 0, 2, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
            ],
        },
        seven4: {
            cols: 4,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 2, 1],
            ],
        },
        seven5: {
            cols: 4,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 2, 1],
                [3, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
            ],
        },
        seven6: {
            cols: 4,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 2, 1],
                [3, 1, 1, 1],
            ],
        },
        seven7: {
            cols: 3,
            rows: 3,
            cells: [
                [0, 0, 1, 3],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
            ],
        },
        seven8: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0.016, 0, 1.04, 0.675],
                [0.99, 0, 1.04, 0.349],
                [1.962, 0, 1.04, 0.349],
                [0.99, 0.326, 1.04, 0.349],
                [0.016, 0.653, 1.04, 0.349],
                [0.99, 0.653, 1.04, 0.35],
                [1.962, 0.326, 1.04, 0.675],
            ],
        },
        seven9: {
            hide: true,
            cols: 3,
            rows: 3,
            cells: [
                [0, 0, 1, 1.3],
                [1, 0, 1, 1.5],
                [2, 0, 1, 0.5],
                [0, 2, 1, 1],
                [1, 1.5, 1, 1.5],
                [2, 0.5, 1, 1.3],
                [2, 1.8, 1, 1.3],
            ],
        },
        seven10: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.45, 1, 0.55],
                [1, 0, 1, 0.15],
                [1, 0.15, 1, 0.63],
                [1, 0.78, 1, 0.22],
                [2, 0, 1, 0.35],
                [2, 0.35, 1, 0.5],
                [2, 0.85, 1, 0.15],
            ],
        },
        seven11: {
            hide: true,
            cols: 3,
            rows: 1,
            cells: [
                [0, 0.45, 1, 0.55],
                [1, 0, 1, 0.15],
                [1, 0.15, 1, 0.33],
                [1, 0.48, 1, 0.52],
                [2, 0, 1, 0.3],
                [2, 0.3, 1, 0.45],
                [2, 0.75, 1, 0.25],
            ],
        },
        seven12: {
            cols: 4,
            rows: 3,
            cells: [
                [0, 0, 1, 3],
                [1, 0, 1, 3],
                [2, 0, 1, 1],
                [2, 1, 1, 1],
                [3, 0, 1, 1],
                [3, 1, 1, 1],
                [2, 2, 2, 1],
            ],
        },
        seven13: {
            cols: 4,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
            ],
        },
    },
    {
        eight1: {
            cols: 4,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
            ],
        },
        eight2: {
            hide: true,
            cols: 4,
            rows: 3,
            cells: [
                [3, 0, 1, 1],
                [3, 1, 1, 1],
                [2, 1, 1, 1],
                [1, 1, 1, 1],
                [3, 2, 1, 1],
                [2, 2, 1, 1],
                [1, 2, 1, 1],
                [0, 2, 1, 1],
            ],
        },
        eight3: {
            cols: 3,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [0, 2, 1.5, 1],
                [1.5, 2, 1.5, 1],
            ],
        },
        eight4: {
            hide: true,
            cols: 4,
            rows: 4,
            cells: [
                [1, 0, 1, 1],
                [3, 0, 1, 1],
                [0, 1, 1, 1],
                [2, 1, 1, 1],
                [1, 2, 1, 1],
                [3, 2, 1, 1],
                [0, 3, 1, 1],
                [2, 3, 1, 1],
            ],
        },
    },
    {
        nine1: {
            cols: 3,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
            ],
        },
        nine2: {
            cols: 4,
            rows: 3,
            cells: [
                [0, 0, 2, 2],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
                [3, 2, 1, 1],
            ],
        },
        nine3: {
            cols: 4,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 2, 2],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
                [3, 2, 1, 1],
            ],
        },
        nine4: {
            cols: 4,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 2, 2],
                [3, 0, 1, 1],
                [0, 1, 1, 1],
                [3, 1, 1, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
                [3, 2, 1, 1],
            ],
        },
        nine5: {
            cols: 5,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],
                [0, 1, 1.25, 1],
                [1.25, 1, 1.25, 1],
                [2.5, 1, 1.25, 1],
                [3.75, 1, 1.25, 1],
            ],
        },
    },
    {
        ten1: {
            cols: 5,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
                [4, 1, 1, 1],
            ],
        },
        ten2: {
            cols: 4,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
                [0, 2, 2, 1],
                [2, 2, 2, 1],
            ],
        },
        ten3: {
            cols: 4,
            rows: 3,
            cells: [
                [0, 0, 2, 1],
                [2, 0, 2, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
                [3, 2, 1, 1],
            ],
        },
    },
    {
        eleven1: {
            cols: 4,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
                [0, 2, 2, 1],
                [2, 2, 1, 1],
                [3, 2, 1, 1],
            ],
        },
        eleven2: {
            cols: 6,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],
                [5, 0, 1, 1],
                [0, 1, 1.2, 1],
                [1.2, 1, 1.2, 1],
                [2.4, 1, 1.2, 1],
                [3.6, 1, 1.2, 1],
                [4.8, 1, 1.2, 1],
            ],
        },
        eleven3: {
            cols: 3,
            rows: 4,
            cells: [
                [0, 0, 1, 1],
                [1, 0.15, 1, 1.3],
                [2, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1.3, 1, 1.3],
                [2, 1, 1, 1],
                [0, 2, 1, 1],
                [1, 2.6, 1, 1.3],
                [2, 2, 1, 1],
                [0, 3, 1, 1],
                [2, 3, 1, 1],
            ],
        },
        eleven4: {
            cols: 4,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
            ],
        },
    },
    {
        twelve2: {
            cols: 6,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],
                [5, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
                [4, 1, 1, 1],
                [5, 1, 1, 1],
            ],
        },
        twelve1: {
            cols: 4,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
                [3, 2, 1, 1],
            ],
        },
        twelve3: {
            cols: 3,
            rows: 4,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
                [0, 3, 1, 1],
                [1, 3, 1, 1],
                [2, 3, 1, 1],
            ],
        },
    },
    {
        thirteen1: {
            cols: 7,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],
                [5, 0, 1, 1],
                [6, 0, 1, 1],
                [0, 1, 1.166666666666667, 1],
                [1.166666666666667, 1, 1.166666666666667, 1],
                [2.333333333333333, 1, 1.166666666666667, 1],
                [3.500000000000001, 1, 1.166666666666667, 1],
                [4.666666666666668, 1, 1.166666666666667, 1],
                [5.833333333333335, 1, 1.166666666666667, 1],
            ],
        },
        thirteen2: {
            cols: 5,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],

                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],

                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
                [3, 2, 1, 1],
            ],
        },
    },
    {
        fourteen1: {
            cols: 7,
            rows: 2,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],
                [5, 0, 1, 1],
                [6, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
                [4, 1, 1, 1],
                [5, 1, 1, 1],
                [6, 1, 1, 1],
            ],
        },
        fourteen2: {
            cols: 5,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
                [4, 1, 1, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
                [3, 2, 1, 1],
            ],
        },
    },
    {
        fifteen1: {
            cols: 5,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
                [4, 1, 1, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
                [3, 2, 1, 1],
                [4, 2, 1, 1],
            ],
        },
    },
    {
        sixteen1: {
            cols: 5,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],
                [0, 1, 0.83333, 1],
                [0.83333, 1, 0.83333, 1],
                [1.66666, 1, 0.83333, 1],
                [2.5, 1, 0.83333, 1],
                [3.33333, 1, 0.83333, 1],
                [4.1666, 1, 0.83333, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
                [3, 2, 1, 1],
                [4, 2, 1, 1],
            ],
        },
    },
    {
        seventeen1: {
            cols: 6,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],
                [5, 0, 1, 1],
                [0, 1, 1.2, 1],
                [1.2, 1, 1.2, 1],
                [2.4, 1, 1.2, 1],
                [3.6, 1, 1.2, 1],
                [4.8, 1, 1.2, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
                [3, 2, 1, 1],
                [4, 2, 1, 1],
                [5, 2, 1, 1],
            ],
        },
    },
    {
        eightteen1: {
            cols: 6,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],
                [5, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
                [4, 1, 1, 1],
                [5, 1, 1, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [2, 2, 1, 1],
                [3, 2, 1, 1],
                [4, 2, 1, 1],
                [5, 2, 1, 1],
            ],
        },
    },
    {
        nineteen1: {
            cols: 6,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],
                [5, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
                [4, 1, 1, 1],
                [5, 1, 1, 1],
                [0, 2, 0.8571428571428571, 1],
                [0.8571428571428571, 2, 0.8571428571428571, 1],
                [1.714285714285714, 2, 0.8571428571428571, 1],
                [2.571428571428571, 2, 0.8571428571428571, 1],
                [3.428571428571428, 2, 0.8571428571428571, 1],
                [4.285714285714286, 2, 0.8571428571428571, 1],
                [5.142857142857143, 2, 0.8571428571428571, 1],
            ],
        },
    },
    {
        twenty1: {
            cols: 7,
            rows: 3,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],
                [5, 0, 1, 1],
                [6, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [2, 1, 1, 1],
                [3, 1, 1, 1],
                [4, 1, 1, 1],
                [5, 1, 1, 1],
                [6, 1, 1, 1],
                [0, 2, 1.16, 1],
                [1.16, 2, 1.16, 1],
                [2.3333, 2, 1.16, 1],
                [3.5, 2, 1.16, 1],
                [4.6666, 2, 1.16, 1],
                [5.83333, 2, 1.16, 1],
            ],
        },
    },
    {
        twentytwo1: {
            cols: 7,
            rows: 4,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],
                [5, 0, 1, 1],
                [6, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [5, 1, 1, 1],
                [6, 1, 1, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [5, 2, 1, 1],
                [6, 2, 1, 1],
                [0, 3, 1, 1],
                [1, 3, 1, 1],
                [2, 3, 1, 1],
                [3, 3, 1, 1],
                [4, 3, 1, 1],
                [5, 3, 1, 1],
                [6, 3, 1, 1],
            ],
        },
    },

    {
        twentythree1: {
            cols: 7,
            rows: 4,
            cells: [
                [0, 0, 1, 1],
                [1, 0, 1, 1],
                [2, 0, 1, 1],
                [3, 0, 1, 1],
                [4, 0, 1, 1],
                [5, 0, 1, 1],
                [6, 0, 1, 1],
                [0, 1, 1, 1],
                [1, 1, 1, 1],
                [5, 1, 1, 1],
                [6, 1, 1, 1],
                [0, 2, 1, 1],
                [1, 2, 1, 1],
                [5, 2, 1, 1],
                [6, 2, 1, 1],
                [0, 3, 1, 1],
                [1, 3, 1, 1],
                [2, 3, 1, 1],
                [3, 3, 1, 1],
                [4, 3, 1, 1],
                [5, 3, 1, 1],
                [6, 3, 1, 1],
            ],
        },
    },
];

/**
 * Author:    Saravanan G
 * Created:   02.06.2021
 *
 * (c) Copyright by Gs.
 **/
//Blocked Recursive Image Composition
"use strict";

function SimpleLayoutManager() {
    this.arrImageFinalData = [];
}

SimpleLayoutManager.prototype.constructor = SimpleLayoutManager;

SimpleLayoutManager.prototype.clear = function() {
    this.arrImageFinalData = [];
};

SimpleLayoutManager.prototype.updateLayout = function(nodeparent, diagramLogoParent) {
    let nodeheight = nodeparent.dataset.scaledheight || getComputedStyle(nodeparent).getPropertyValue("--logoheight") || 40;
    let isAutoResize = diagramLogoParent?.getAttribute("data-logoautoresize") == "true";
    if (isAutoResize && diagramLogoParent?.parentElement?.hasAttribute("data-logoimagesize") && this.arrImageFinalData?.length == 1) {
        let scaleValue = diagramLogoParent.parentElement.getAttribute("data-logoimagesize");
        let _w = this.arrImageFinalData[0].width;
        let _h = this.arrImageFinalData[0].height;
        let ratio = _h / _w;

        let updateSize = -1;

        if (ratio >= 1.1) updateSize = 0.85;
        else if (ratio >= 0.9 && ratio < 1.1) updateSize = 0.85;
        else if (ratio >= 0.25 && ratio < 0.9) updateSize = 0.45;
        else if (ratio <= 0.25) updateSize = 0.35;

        if (updateSize > 0) {
            let newValue = nodeheight / scaleValue;
            nodeheight = parseFloat(newValue) * updateSize;
            diagramLogoParent.parentElement.setAttribute("data-logoimagesize", updateSize);
            nodeparent.style.removeProperty("height");
            nodeparent.setAttribute("data-scaledheight", nodeheight);
            nodeparent.style.setProperty("--logoheight", nodeheight + "px");
        }
    }
    let logogap = getComputedStyle(nodeparent).getPropertyValue("--logogap") || "0px";
    this.arrImageFinalData.forEach((item) => {
        this.updateNode(item, nodeheight, logogap);
    });
};

SimpleLayoutManager.prototype.updateNode = function(item, nodeheight, logogap) {
    let imageWidth = item.width;
    let imageHeight = item.height;
    let scale = parseFloat(nodeheight) / imageHeight;
    item.image.parentElement.style.setProperty("width", imageWidth * scale + "px", "important");
    item.image.parentElement.style.setProperty("height", imageHeight * scale + "px", "important");
    // item.image.parentElement.style.setProperty("margin-right", logogap);
    // item.image.parentElement.style.setProperty("margin-bottom", logogap);
    item.image.style.setProperty("object-fit", "contain", "important");
    item.image.style.setProperty("width", "100%");
    item.image.style.setProperty("height", "100%");
};
/**
 * Author:    Saravanan G
 * Created:   02.06.2021
 *
 * (c) Copyright by Gs.
 **/
//Blocked Recursive Image Composition
"use strict";

function GridLayoutManager() {
    this.arrNodeFinalData = [];
}

GridLayoutManager.prototype.constructor = GridLayoutManager;

GridLayoutManager.prototype.clear = function () {
    this.arrNodeFinalData = [];
    this.layoutManagerUtil.clear();
};

GridLayoutManager.prototype.getLayouts = function () {
    return GridLayoutManagerUtil.layouts[this.arrNodeFinalData.length - 1];
};

GridLayoutManager.prototype.updateLayoutByName = function (layoutname, parentNode, gutter) {
    let gap = parseFloat(gutter);
    let layoutW = parentNode.offsetWidth;
    let layoutH = parentNode.offsetHeight;
    let grid = GridLayoutManagerUtil.layouts[this.arrNodeFinalData.length - 1];
    let layout = grid[layoutname];
    if (layout) {
        let colWidth = (layoutW - (layout.cols - 1) * gap) / layout.cols;
        let rowHeight = (layoutH - (layout.rows - 1) * gap) / layout.rows;
        this.applyBaseData(layout, colWidth, rowHeight, gap);
        this.applyLayout();
    }
};

GridLayoutManager.prototype.updateLayout = function (parentNode, gutter, isAnimate = true, properties) {
    let gap = parseFloat(gutter);
    let layoutW = parentNode.offsetWidth;
    let layoutH = parentNode.offsetHeight;
    let storedLayout = properties?.gridlayout || parentNode.parentElement.getAttribute("data-gridlayout") || "";
    let selectedGrid = properties?.gridlayoutname || parentNode.parentElement.getAttribute("data-gridlayoutname") || "";
    let grid = GridLayoutManagerUtil.layouts[this.arrNodeFinalData.length - 1];
    let arrKeys = Object.keys(grid);
    if (storedLayout != "") {
        arrKeys = arrKeys.filter((item) => storedLayout.split(",").includes(item));
        if (!storedLayout.includes(selectedGrid)) selectedGrid = storedLayout.split(",")[0];
    }

    let keyName = arrKeys[0];
    if (storedLayout.length > 0) {
        if (arrKeys.length > 0)
            arrKeys.forEach((element) => {
                if (storedLayout.includes(element)) {
                    keyName = element;
                }
            });
        else keyName = Object.keys(grid)[0];
    }
    let layout = grid[selectedGrid] || grid[keyName];
    let colWidth = (layoutW - (layout.cols - 1) * gap) / layout.cols;
    let rowHeight = (layoutH - (layout.rows - 1) * gap) / layout.rows;
    this.applyBaseData(layout, colWidth, rowHeight, gap);
    this.applyLayout(isAnimate);
    parentNode.parentElement.setAttribute("data-gridlayoutname", selectedGrid != "" ? selectedGrid : keyName);
};

GridLayoutManager.prototype.applyBaseData = function (itemBounds, colWidth, rowHeight, gap) {
    this.arrNodeFinalData.forEach((item, index) => {
        let cell = itemBounds.cells[index];
        let nodeParent = item.parentNode.parentElement;
        nodeParent.setAttribute("data-cx", cell[0] * (colWidth + gap));
        nodeParent.setAttribute("data-cy", cell[1] * (rowHeight + gap));
        nodeParent.setAttribute("data-cw", cell[2] * (colWidth + gap) - gap);
        nodeParent.setAttribute("data-ch", cell[3] * (rowHeight + gap) - gap);
    });
};

GridLayoutManager.prototype.applyLayout = function (isAnimate = true) {
    this.arrNodeFinalData.forEach((item) => {
        let nodeParent = item.parentNode.parentElement;
        nodeParent.style.setProperty("width", nodeParent.dataset.cw + "px", "important");
        nodeParent.style.setProperty("height", nodeParent.dataset.ch + "px", "important");
        nodeParent.style.setProperty("left", nodeParent.dataset.cx + "px", "important");
        nodeParent.style.setProperty("top", nodeParent.dataset.cy + "px", "important");
        if (isAnimate) nodeParent.style.setProperty("transition", "top 0.3s, left 0.3s, width 0.3s, height 0.3s, transform 0.3s");
    });
};

/**
 * Author:    Saravanan G
 * Created:   02.06.2021
 *
 * (c) Copyright by Gs.
 **/
//Blocked Recursive Image Composition
"use strict";

function AspectLayoutManager() {
    this.supportedLayouts = [];
    this.arrImageFinalData = [];
    this.aspectLayoutManagerUtil = new window["AspectLayoutManagerUtil"]();
}

AspectLayoutManager.prototype.constructor = AspectLayoutManager;

AspectLayoutManager.prototype.clear = function () {
    this.arrImageFinalData = [];
    this.aspectLayoutManagerUtil.clear();
};

AspectLayoutManager.prototype.getLayouts = function () {
    return supportedLayouts;
};

AspectLayoutManager.prototype.updateLayout = function (parentNode, width = 800, height = 600, gap = 2) {
    let arrRatio = [];
    let layoutW = width - gap * 2;
    let layoutH = height - gap * 2;
    parentNode.style.width = layoutW;
    parentNode.style.height = layoutH;
    parentNode.classList.add("clsAspectGrid");

    parentNode.style.left = gap; // "fit-content";
    parentNode.style.top = gap; // "fit-content";

    for (let index = 0; index < this.arrImageFinalData.length; index++) {
        const element = this.arrImageFinalData[index];
        arrRatio.push(element.ratio);
    }

    let layouts = this.aspectLayoutManagerUtil.tileImages(layoutW, layoutH, arrRatio);
    layouts = _.slice(layouts, 0, Math.min(8, layouts.length));
    let nodeindex = _.random(layouts.length - 1);

    let itemBounds = _.map(layouts[parseInt(nodeindex)], (rect) => {
        rect.x = rect.x + gap;
        rect.y = rect.y + gap;
        rect.w = rect.w - (gap + gap);
        rect.h = rect.h - (gap + gap);
        return rect;
    });

    this.applyBaseData(itemBounds);
    this.fitToContainer(gap, parentNode, layoutW, layoutH);
    this.applyLayout();
    supportedLayouts = layouts;
};

AspectLayoutManager.prototype.applyBaseData = function (itemBounds) {
    this.arrImageFinalData.forEach((item, index) => {
        let rect = itemBounds[index];
        item.image.parentElement.setAttribute("data-cy", rect.y);
        item.image.parentElement.setAttribute("data-cx", rect.x);
        item.image.parentElement.setAttribute("data-cw", rect.w);
        item.image.parentElement.setAttribute("data-ch", rect.h);
        item.image.parentElement.setAttribute("data-xw", parseInt(rect.x + rect.w));
        item.image.parentElement.setAttribute("data-yh", parseInt(rect.y + rect.h));
        item.image.parentElement.style.setProperty("position", "absolute");
        item.image.style.setProperty("object-fit", "cover", "important");
        item.image.style.setProperty("width", "100%");
        item.image.style.setProperty("height", "100%");
    });
};

AspectLayoutManager.prototype.fitToContainer = function (gap, parentNode, layoutW, layoutH) {
    let firstNode = this.arrImageFinalData[0].image.parentElement;
    if (firstNode.dataset.cx > gap) {
        let extraGap = parseFloat(firstNode.dataset.cx);
        let dataX = '[data-cx="' + extraGap + '"]';
        let xNodes = parentNode.querySelectorAll(dataX);
        let width = parseInt(layoutW - extraGap);
        let dataXW = '[data-xw="' + width + '"]';
        let wNodes = parentNode.querySelectorAll(dataXW);
        xNodes.forEach((element) => {
            let _left = gap + (element.dataset.cx - extraGap);
            let _width = parseFloat(element.dataset.cw) + extraGap - gap;
            element.setAttribute("data-cx", _left);
            element.setAttribute("data-cw", _width);
            element.setAttribute("data-xw", parseInt(_left + _width));
        });

        wNodes.forEach((element) => {
            let _width = parseFloat(element.dataset.cw) + extraGap - gap;
            let _left = element.dataset.cx;
            element.setAttribute("data-cw", _width);
            element.setAttribute("data-xw", parseInt(_left + _width));
        });
    } else if (firstNode.dataset.cy > gap) {
        let extraGap = parseFloat(firstNode.dataset.cy);
        let dataY = '[data-cy="' + extraGap + '"]';
        let yNodes = parentNode.querySelectorAll(dataY);
        let height = parseInt(layoutH - extraGap);
        let dataYH = '[data-yh="' + height + '"]';
        let hNodes = parentNode.querySelectorAll(dataYH);
        yNodes.forEach((element) => {
            let _top = gap + (element.dataset.cy - extraGap);
            let _height = parseFloat(element.dataset.ch) + extraGap - gap;
            element.setAttribute("data-cy", _top);
            element.setAttribute("data-ch", _height);
            element.setAttribute("data-yh", parseInt(_top + _height));
        });

        hNodes.forEach((element) => {
            let _top = element.dataset.cy;
            let _height = parseFloat(element.dataset.ch) + extraGap - gap;
            element.setAttribute("data-ch", _height);
            element.setAttribute("data-yh", parseInt(_top + _height));
        });
    }
};

AspectLayoutManager.prototype.applyLayout = function () {
    this.arrImageFinalData.forEach((item) => {
        item.image.parentElement.style.setProperty("width", item.image.parentElement.dataset.cw + "px", "important");
        item.image.parentElement.style.setProperty("height", item.image.parentElement.dataset.ch + "px", "important");
        item.image.parentElement.style.setProperty("left", item.image.parentElement.dataset.cx + "px", "important");
        item.image.parentElement.style.setProperty("top", item.image.parentElement.dataset.cy + "px", "important");
        item.image.parentElement.style.setProperty("transition", "top 1s, left 1s, width 1s, height 1s, background-color 2s, transform 2s");
    });
};

/**
 * Author:    Saravanan G
 * Created:   22.04.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function Diagram(diagramParent, diagramData = null, diagramType = "vertical", objStyleData = {}, moodData = {}) {
    this.diagramParent = diagramParent;
    this.diagramType = diagramType;
    this.objStyleData = objStyleData;
    this.moodData = moodData;
    this.appStaticURL = "";
    this.appmode = "";
    this.moodName = "";
    this.isWidget = false;
    this.nodeProps = {};
}

Diagram.prototype.getJSONData = function () {
    let arrNodes = this.diagramParent.querySelectorAll("[name='nodeitem']");
    let arrNodeData = [];
    for (let i = 0; i < arrNodes.length; i++) {
        let node = arrNodes[i];
        let nodeData = this.getInnerJSONData(node);
        arrNodeData.push(nodeData);
    }
    return { nodes: arrNodeData, properties: this.getProperties() };
};

Diagram.prototype.getInnerJSONData = function (node) {
    let nodeData = {};
    nodeData.primarytext = this.getPrimaryText(node);
    nodeData.secondarytext = this.getListData(node);
    nodeData.content = this.getContentData(node);
    return nodeData;
};

Diagram.prototype.getPrimaryText = function (nodeParent) {
    let primaryText = nodeParent.querySelector("div[data-id='primaryText']");
    return { type: "text", value: primaryText ? primaryText.innerHTML : "" };
};

Diagram.prototype.getListData = function (nodeParent) {
    let listItems = nodeParent.querySelectorAll("div[name='secondaryTextItem']");
    let listtype = nodeParent.getAttribute("data-sublist") || "none";
    let arrItems = [];
    for (let listItem of listItems) {
        arrItems.push({ type: "text", value: listItem.innerHTML });
    }
    return arrItems.length > 0 ? { sublist: listtype, items: arrItems } : null;
};

Diagram.prototype.getContentData = function (nodeParent) {
    let contentNode = nodeParent.querySelector("[data-id='diagramContentNode']");
    if (contentNode && contentNode.dataset && contentNode.dataset.contentType) {
        let contentType = contentNode.dataset.contentType;
        let node;
        let data = {};
        let dataRef = {};
        node = contentNode.querySelector("[data-id='" + contentType + "Node']");
        switch (contentType) {
            case "image":
            case "logo":
                dataRef = { imageURL: node.src };
                if (node.dataset.csstext) dataRef.cropStyle = node.dataset.csstext;
                if (node.dataset.style) dataRef.cropData = node.dataset.style;
                data = { type: "image", value: node.src, dataRef: dataRef, contenttype: contentType };
                break;
            case "icon":
                // case "bgimage":
                let iconid = node.getAttribute("iconid");
                let path = node.getAttribute("iconpath");
                dataRef.name = iconid;
                data = { type: "icon", value: path, id: iconid, dataRef: dataRef, contenttype: contentType };
                break;
            case "text":
            case "number":
            case "microchart":
                // let strValue = node.innerText.replace("%", "");
                let strValue = node.textContent;
                data = { type: "text", value: strValue, contenttype: contentType };
                break;
            case "text":
                // let strValueText = node.innerHTML.replace("%", "");
                let strValueText = node.innerHTML;
                data = { type: "text", value: strValueText, contenttype: contentType };
                break;
            case "checklist":
                data = { type: "text", value: node.dataset.ischecked, contenttype: contentType };
                break;
            default:
                data = { type: "text", value: "", contenttype: contentType };
                break;
        }
        return data;
    } else {
        return { type: "text", value: "" };
    }
};

Diagram.prototype.getOutlineMatrix = function () {
    let row = [];
    let subtype = "bulleted";
    let tempData = this.getJSONData();
    let arrNodes = tempData ? tempData.nodes : [];
    for (let i = 0; i < arrNodes.length; i++) {
        let column = [];
        let nodeData = arrNodes[i];
        let sublist = false;
        if (nodeData.content && nodeData.content.contenttype != "bulletlist") {
            subtype = subtype == "bulleted" ? "valued" : subtype;
            let cellOBJ = { type: nodeData.content.type, value: nodeData.content.value ? nodeData.content.value : "" };
            if (nodeData.content.contenttype == "image" || nodeData.content.contenttype == "icon") {
                subtype = nodeData.content.contenttype;
                if (nodeData.content.dataRef) {
                    cellOBJ.id = nodeData.content.id;
                    cellOBJ.dataRef = nodeData.content.dataRef;
                }
            }
            column.push(cellOBJ);
        }

        if (nodeData.primarytext) {
            column.push({ type: "text", value: nodeData.primarytext.value });
        }

        if (nodeData.secondarytext) {
            for (let l = 0; l < nodeData.secondarytext.items.length; l++) {
                let item = nodeData.secondarytext.items[l];
                if (item.value != "") column.push({ type: item.type, value: item.value });
            }
            sublist = nodeData.secondarytext.sublist ? nodeData.secondarytext.sublist : column.length > 1 ? "disc" : "none";
        }

        row.push({
            matrix: column,
            sublist: sublist,
        });
    }
    return { subtype: subtype, matrix: row, properties: tempData?.properties || this.getProperties() };
};

Diagram.prototype.isChildEmpty = function () {
    let arrNodes = this.diagramParent.querySelectorAll("[name='nodeparent']");
    if (arrNodes.length == 0) return true;
    return false;
};

Diagram.prototype.isNonLinearAsset = function () {
    return false;
};

Diagram.prototype.setSlideScale = function () {};

Diagram.prototype.setSlideWidthHeight = function (width, height) {
    this.slideWidth = width;
    this.slideHeight = height;
    Constants.Value = { ...Constants.Value, slideWidth: width, slideHeight: height };
};

Diagram.prototype.getProperties = function () {
    return {};
};

Diagram.prototype.getDiagramLayoutProperties = function () {};

Diagram.prototype.updateElements = function () {};

Diagram.prototype.resetNodeAttributes = function () {};

Diagram.prototype.recreateElementData = function () {};

Diagram.prototype.updateJSONData = function () {};

Diagram.prototype.getDummyData = function () {
    return JSON.parse(
        '{"properties":{"moodcontent":"content","ismoodshape":false,"ismoodsequence":false,"diagramcontent":true,"secondarytext":true,"primarytext":true,"greyscale":false,"sequencetext":false,"authorimage":false,"hasconnector":false,"connector":false,"contenttype":"icon","secondarytype":"none","version":"9.2","minnode":"2","maxnode":"6","islogofit":false,"isimagefit":false,"logosize":"large","imagesize":"large","iconsize":"large","numbersize":"large","fontresize":"fontresizeauto","diagramtype":"vertical","fontmapping":"","contentdefault":"none","floateroptionsdisable":["sequencetext","textposition","crossout","fontresize","iconsize","logosize","numbersize","greyscale","swap","arrange","sequencetext","content","emphasize","crossout","fontresize","iconsize","logosize","numbersize","greyscale","swap","arrange","sequencetext","content","emphasize","graphicimage","graphiclogo","graphicnumber","graphictext"],"layoutmeta":{"nodes":{"layout":"diagramUniqueLayout28"}},"connectorstyle":"arrowright","contenttype":"icon","contentholdertype":"iconHolder","centernodetype":"icon","centerholdertype":"iconHolder","projectionindex":"100","graphicname":"process-all-tx-sty-a","graphicmenuname":"process-mnu","graphiclayoutname":"process"},"nodes":[{"primarytext":{"type":"text","value":"","highlight":""},"secondarytext":{"sublist":"none","items":[{"type":"text","value":"","index":0}],"seccontent":[]},"content":{"type":"icon","value":"genericassets/icons/placeholder/placeholder.svg","id":"placeholder","dataRef":{"name":"placeholder"},"contenttype":"icon"},"seccontent":[],"nodeproperties":{"highlight":false,"emphasize":false,"sublist":"none","ischecked":false},"bgimage":null,"arrowData":"","rect":{"x":296,"y":133,"width":272,"height":94,"top":133,"left":296},"position":{"x":"0","y":"0"},"highlightdata":{},"link":"","emphasize":"","extralink":{}},{"primarytext":{"type":"text","value":"","highlight":""},"secondarytext":{"sublist":"none","items":[{"type":"text","value":"","index":0}],"seccontent":[]},"content":{"type":"icon","value":"genericassets/icons/placeholder/placeholder.svg","id":"placeholder","dataRef":{"name":"placeholder"},"contenttype":"icon"},"seccontent":[],"nodeproperties":{"highlight":false,"emphasize":false,"sublist":"none","ischecked":false}},{"primarytext":{"value":""},"secondarytext":{"items":[{"type":"text","value":""}]},"content":{"value":"genericassets/icons/placeholder/placeholder.svg","id":"placeholder","type":"icon","contenttype":"icon"}}]}'
    );
};

Diagram.prototype.diagramRenderComplete = function () {};

Diagram.prototype.resetLayout = function () {};

Diagram.prototype.updateEvents = function () {};

Diagram.prototype.clear = function () {};

Diagram.prototype.abort = function () {};

/**
 * Author:    Saravanan G
 * Created:   3.10.2019
 * Cleanup : Balakrishnan on 24.08.2023
 * (c) Copyright by Gs.
 **/

"use strict";

function PlotDiagram(mainParent, diagramData, diagramType, moodData = {}) {
    this.diagramParent = mainParent;
    this.diagramData = diagramData;
    this.diagramType = diagramType;
    this.moodData = moodData;
    this.eventManagerXY = new window["DiagramEventManager"]();
    this.events = {};
    this.appStaticURL = "";
    this.arrDiagramNode = [];
    this.nodeProps = {};
    this.slideScale = 1;
    this.dragItemIndex = -1;
    this.dragOffset = null;
    this.positionGroup = null;
    this.positionGroupName = ["00", "11", "22", "33"];
    this.positionGroupNameSingle = ["0", "1", "2", "3"];
    this.objStyleData = {};
    this.mouseMoveResetFloater = false;
    this.mouseUpHandler = this.mouseUpHandler.bind(this);
    this.mouseDownHandler = this.mouseDownHandler.bind(this);
    this.mouseMoveHandler = this.mouseMoveHandler.bind(this);
    this.defaultFoucsOut = this.defaultFoucsOut.bind(this);
    this.defaultFoucsIn = this.defaultFoucsIn.bind(this);
    this.diagramPasteHandler = this.diagramPasteHandler.bind(this);
    this.diagramParent.parentElement.className = "clsElementDiv commonallmood moodanimation";
}

PlotDiagram.prototype.initDiagramCreation = function () {
    this.diagramParent.innerHTML = "";
    this.parentNode = this.createXYParent(this.diagramParent, this.diagramType);
    this.arrDiagramNode = [];
    this.createPatternBackGround();
};

PlotDiagram.prototype.createPatternBackGround = function () {
    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsSVGBackground moodanimation";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "svgBackground");
    pattenDiv.setAttribute("data-animation", "gridlines");
    this.parentNode.appendChild(pattenDiv);

    let svgBG = document.createElement("div");
    svgBG.className = "clsPatternBackgound moodanimation";
    svgBG.setAttribute("id", DiagramNodeUtils.uuidv4());
    svgBG.setAttribute("name", "patternBackgound");
    svgBG.setAttribute("data-animation", "gridlines");
    this.parentNode.appendChild(svgBG);

    this.createLabels();

    let nodesHolderDiv = document.createElement("div");
    // let centerNodeStyle = this.nodeProps.centerNodeStyle || "";
    nodesHolderDiv.className = "clsNodesHolderXYPlot ";
    nodesHolderDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    nodesHolderDiv.setAttribute("name", "nodesHolder");
    this.parentNode.appendChild(nodesHolderDiv);
    this.parentNode.style.setProperty("--leftAxisLabelMaxWidth", this.parentNode.clientHeight - 84 - 72 + "px");
    try {
        this.createNodes();
        this.resetNodeAttributes();
        this.updateProperties(this.diagramData.properties);
        let svgData = Constants.Value.xyplotsvg;
        const patternID = DiagramNodeUtils.uuidv4();
        svgData = svgData.replace(/svgPattern/g, patternID);
        svgBG.innerHTML = svgData;
        this.updateEvents();
        this.diagramRenderComplete();
    } catch (error) {
        console.log(error);
        this.diagramRenderComplete();
    }
};

PlotDiagram.prototype.createXYParent = function (parentPlotDiagramNode) {
    let nodeParent = document.createElement("div");
    nodeParent.className = "clsPlotDiagramParent";
    nodeParent.setAttribute("id", DiagramNodeUtils.uuidv4());
    nodeParent.setAttribute("name", "baseParent");
    parentPlotDiagramNode.appendChild(nodeParent);
    return nodeParent;
};

PlotDiagram.prototype.createNodes = function () {
    this.arrDiagramNode = [];
    for (let i = 0; i < this.diagramData?.nodes?.length || 0; i++) {
        let nodeData = this.diagramData?.nodes[i];
        let targetID = 0;
        let targetNode = this.parentNode.querySelector("div[id='" + targetID + "']");
        let nodeItem = new window["PlotDiagramNode"](targetNode, this.diagramData?.properties, nodeData, this.eventManagerXY, i, targetID, this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
        nodeItem.appStaticURL = this.appStaticURL;
        nodeItem.globalMoodData = this.globalMoodData;
        nodeItem.initCreation();
        if (nodeData.content) this.updateManifest(nodeData.content, this.arrDiagramNode?.length);
        this.arrDiagramNode.push(nodeItem);
    }
};
PlotDiagram.prototype.createLabels = function () {
    const arrXYCombain = ["Plus", "Positive", "Minus", "Negative"];

    let refrenceParent = document.createElement("div");
    refrenceParent.className = "clsNodeBlockParent";
    refrenceParent.setAttribute("id", "nodeBlockParent");
    // this.parentNode.appendChild(refrenceParent);
    this.parentNode.insertChildAtIndex(refrenceParent, 2);

    let xyHolder = document.createElement("div");
    xyHolder.className = "clsXYLabelHolder";
    xyHolder.setAttribute("id", "xyHolder");

    let arrLabels = this.diagramData?.axis?.data || arrXYCombain;
    if (arrLabels.length < 4) {
        arrXYCombain.forEach((element, index) => {
            if (!arrLabels[index]) arrLabels.push(element);
        });
    }

    let arrQuadrantLabels = this.diagramData?.axis?.quadrant || arrXYCombain;
    if (arrQuadrantLabels.length < 4) {
        arrXYCombain.forEach((element, index) => {
            if (!arrQuadrantLabels[index]) arrQuadrantLabels.push(element);
        });
    }
    for (let i = 0; i < arrLabels.length; i++) {
        let lblAxis = this.createAxisLabel("clsAxis" + i, arrLabels[i], arrLabels[i], arrLabels[i]);
        xyHolder.appendChild(lblAxis);
        lblAxis.setAttribute("link-id", i);

        let id = i + "" + (i + 1 >= arrLabels.length ? 0 : i + 1);
        let axisNode = document.createElement("div");
        axisNode.className = "cls" + id + " clsNodeBlock clsMultiColorParent accent" + (i + 1);
        axisNode.name = "groupName";
        axisNode.id = i;
        axisNode.setAttribute("main-id", id);
        DiagramUtils.setCustomItemColor(axisNode, null, i, i + 1);
        refrenceParent.appendChild(axisNode);

        let bg = document.createElement("div");
        bg.className = "clsNodeBlockBackground background-node-theme-color ";
        axisNode.appendChild(bg);
    }
    for (let index = 0; index < arrQuadrantLabels.length; index++) {
        let lblAxis = this.createAxisLabel("clsQuadrant" + index, arrQuadrantLabels[index], arrQuadrantLabels[index], arrQuadrantLabels[index], "clsQuadrant");
        xyHolder.appendChild(lblAxis);
        lblAxis.setAttribute("link-id", index);
    }
    let arrHeader = this.diagramData?.axis?.header || ["Common Heading"];
    let headerAxis = this.createAxisLabel("clsHeader" + 0, "headerTitle", arrHeader[0], arrHeader[0], "clsHeader", "h7");
    xyHolder.appendChild(headerAxis);

    this.parentNode.appendChild(xyHolder);
};

PlotDiagram.prototype.createAxisGroup = function (axisParent, intLength) {
    let objMapping = {};
    let pGrounp = intLength == 1 ? this.positionGroupNameSingle : this.positionGroupName;
    for (let i = 0; i < pGrounp.length; i++) {
        let groupName = pGrounp[i];
        let axisNode = document.createElement("div");
        axisNode.className = "cls" + groupName;
        axisNode.name = "groupName";
        axisNode.id = groupName.toLowerCase();
        axisParent.appendChild(axisNode);

        let bg = document.createElement("div");
        bg.className = "clsNodeBlockBackground";
        axisNode.appendChild(bg);

        objMapping[groupName] = axisNode;
    }
    return objMapping;
};

PlotDiagram.prototype.createAxisLabel = function (className, name, prompt, value = "", prefix = "clsAxis", childClass = "p4 clsTertiaryColor") {
    let labelParent = document.createElement("div");
    labelParent.setAttribute("data-animation", name + "label");

    let labelBG = document.createElement("div");
    labelBG.className = prefix + "LabelBG ";
    labelParent.appendChild(labelBG);

    let labelNode = document.createElement("div");
    labelNode.className = prefix + "Edit " + childClass;
    labelNode.setAttribute("id", DiagramNodeUtils.uuidv4());
    labelNode.setAttribute("name", name);
    labelNode.setAttribute("contentEditable", true);
    labelNode.setAttribute("data-default-event", true);
    labelNode.setAttribute("data-prompt-text", prompt || "Axis");
    labelNode.innerHTML = value;
    labelBG.appendChild(labelNode);
    labelParent.className = className + " " + prefix + "Label moodanimation";
    return labelParent;
};

PlotDiagram.prototype.defaultFoucsOut = function (event) {
    let typedText = event.target.dataset && event.target.dataset.oldtext ? event.target.dataset.oldtext : "";
    if (event.target.innerHTML != typedText && this.appmode != "PRESENT") {
        this.eventManagerXY.dispatch("focusout", event.target);
        event.target.dataset.oldtext = event.target.innerHTML;
    }
    // this.resetDragHandles();
};

PlotDiagram.prototype.defaultFoucsIn = function (event) {
    event.target.setAttribute("data-oldtext", event.target.innerHTML);
};

PlotDiagram.prototype.getOutlineMatrix = function () {
    let row = [];
    let subtype = "table";
    let tempData = this.getJSONData();
    let arrNodes = tempData && tempData.nodes ? tempData.nodes : this.diagramData?.nodes || [];
    const properties = this.getProperties();
    let matrix = { plots: arrNodes, axis: this.diagramData.axis || { data: [] } };
    return { subtype: subtype, properties: properties, matrix: matrix, xyplot: true };
};

PlotDiagram.prototype.parseJsonForDefaultContent = function (matrix) {
    matrix.plots.forEach((element) => {
        let nodeproperties = element.nodeproperties;
        let percentx = nodeproperties.x / this.diagramParent.clientWidth;
        let percenty = nodeproperties.y / this.diagramParent.clientHeight;
        nodeproperties.percentx = percentx;
        nodeproperties.percenty = percenty;
    });
    console.log(matrix);
};

PlotDiagram.prototype.initDiagramCreationOutline = function (data) {
    let outlineData = data?.elements?.[0]?.data || data.content;
    data.node = data.node || [1, 12];
    // xyplotstyle:"leftaxis,centeraxis,bothaxis,noaxis"
    let defaultprops = { minnode: data.node[0], maxnode: data.node[1], xyplotstyle: "centeraxis", quadrantlabel: false, axislabel: true, arrowheads: true, xyheader: false, gridbg: false };
    let hasProperties = outlineData?.hasOwnProperty("properties");
    let properties = hasProperties ? { ...defaultprops, ...outlineData?.properties } : defaultprops;
    this.nodeProps.name = data.name;
    this.nodeProps.globalstyle = data.globalstyle;
    this.nodeProps.parentStyle = data.parentStyle;
    let axis = { data: [] };
    let matrix = outlineData?.matrix;
    if (matrix?.plots && matrix?.plots?.length > 0) {
        this.diagramData = { properties: properties, axis: matrix?.axis || axis, nodes: matrix?.plots };
    } else {
        let node = {
            content: { type: "image", value: this.appStaticURL + "genericassets/placeholderimages/logoplaceholder_landscape.png" },
            axis: "",
            y: DiagramUtils.getRndInteger(0, 160),
            x: DiagramUtils.getRndInteger(0, 120),
        };
        if (properties.diagram_type == "icon") {
            node.content.type = "icon";
            node.content.id = "placeholder";
            node.content.dataRef = { name: "placeholder", id: "placeholder" };
            node.content.value = "genericassets/icons/placeholder/placeholder.svg";
        }
        this.diagramData = { properties: properties, axis: [], nodes: [node] };
    }
};

PlotDiagram.prototype.mouseDownHandler = function (event) {
    try {
        // this.dragItemIndex = -1;
        this.dragItemIndex = parseInt(event.target.dataset.index);
        let curentItem = this.arrDiagramNode[this.dragItemIndex]?.parentNode?.parentElement;
        if (!curentItem) return;
        this.dragOffset = [curentItem.offsetLeft - event.clientX / this.slideScale, curentItem.offsetTop - event.clientY / this.slideScale];
        this.diagramParent.removeEventListener("mousemove", this.mouseMoveHandler);
        this.mouseMoveResetFloater = true;
        if (event.target.id.includes("nodeDragHandle")) {
            this.diagramParent.addEventListener("mousemove", this.mouseMoveHandler);
            event.target.style.cursor = "grabbing";
        } else {
            this.resetDragHandles();
            this.enableDragHandle(event.target);
        }
    } catch (error) {
        console.log(error);
    }
};

PlotDiagram.prototype.enableDragHandle = function (target) {
    let index = parseInt(target?.dataset?.index);
    let dragHandle = this.diagramParent.querySelector("div[id='nodeDragHandle" + index + "']");
    if (dragHandle) {
        dragHandle.style.display = "block";
        dragHandle.setAttribute("data-isactive", true);
    }
};

PlotDiagram.prototype.disableDragHandle = function (target) {
    let index = parseInt(target?.dataset?.index);
    let dragHandle = this.diagramParent.querySelector("div[id='nodeDragHandle" + index + "']");
    if (dragHandle) {
        // dragHandle.style.display = "none";
        dragHandle.setAttribute("data-isactive", false);
    }
};

PlotDiagram.prototype.resetDragHandles = function () {
    // if (dragItemIndex >= 0) return;
    let arrDragHandle = this.diagramParent.querySelectorAll("[id*='nodeDragHandle']");
    for (let i = 0; i < arrDragHandle.length; i++) {
        let isactive = arrDragHandle[i].getAttribute("data-isactive") == "true";
        if (!isactive) {
            arrDragHandle[i].setAttribute("data-isactive", false);
            arrDragHandle[i].style.display = "none";
        }
    }
};

PlotDiagram.prototype.mouseUpHandler = function (event) {
    this.diagramParent.removeEventListener("mousemove", this.mouseMoveHandler);
    if (event.target?.name == "groupName") return;
    let nodeBlockParent = this.diagramParent.querySelector("div[name='nodesHolder']");
    try {
        let curentItem = this.arrDiagramNode[this.dragItemIndex]?.parentNode?.parentElement;
        if (!curentItem) return;
        curentItem.style.width = "auto";
        // this.enableDragHandle(event.target);
        let left = parseInt(curentItem.style.left.replace("px", ""));
        let top = parseInt(curentItem.style.top.replace("px", ""));
        let percentx = left / this.diagramParent.clientWidth;
        let percenty = top / this.diagramParent.clientHeight;
        curentItem.setAttribute("data-x", left);
        curentItem.setAttribute("data-y", top);

        curentItem.setAttribute("data-percentx", percentx);
        curentItem.setAttribute("data-percenty", percenty);

        this.diagramData.nodes[this.dragItemIndex].nodeproperties.x = left;
        this.diagramData.nodes[this.dragItemIndex].nodeproperties.y = top;
        this.arrDiagramNode[this.dragItemIndex].objData.nodeproperties.x = left;
        this.arrDiagramNode[this.dragItemIndex].objData.nodeproperties.y = top;

        this.diagramData.nodes[this.dragItemIndex].nodeproperties.percentx = percentx;
        this.diagramData.nodes[this.dragItemIndex].nodeproperties.percenty = percenty;
        this.arrDiagramNode[this.dragItemIndex].objData.nodeproperties.percentx = percentx;
        this.arrDiagramNode[this.dragItemIndex].objData.nodeproperties.percenty = percenty;

        this.eventManagerXY.removeEvent(nodeBlockParent, "mousemove");
        let currentParent = this.getElementInOffset(nodeBlockParent, curentItem);

        let imageNode = curentItem.querySelector("img[data-id='imageNode'],img[data-id='logoNode'],img[data-id='bgimageNode']");
        if (imageNode && imageNode.parentElement && imageNode.parentElement.parentElement) {
            let nodeParent = imageNode.parentElement.parentElement;
            let position = DiagramNodeUtils.getOffsetLeftTop(nodeParent);
            imageNode.setAttribute("data-x", position.x);
            imageNode.setAttribute("data-y", position.y);
        }

        if (currentParent && currentParent == curentItem.parentElement) {
            this.eventManagerXY.dispatch("mouseMoveEnd");
            return;
        }

        this.dragItemIndex = -1;
        this.eventManagerXY.dispatch("mouseMoveEnd");
        // this.updatePropsCallBack(event.target.id);
        if (event.target.id.includes("nodeDragHandle")) {
            event.target.style.cursor = "grab";
        }
        this.disableDragHandle(curentItem);
    } catch (error) {
        console.log(error);
    }
};

PlotDiagram.prototype.mouseMoveHandler = function (event) {
    if (this.dragItemIndex >= 0) {
        // if (this.mouseMoveResetFloater)
        this.eventManagerXY.dispatch("mouseMoveBegin");
        this.mouseMoveResetFloater = false;
        let curentItem = this.arrDiagramNode[this.dragItemIndex]?.parentNode?.parentElement;
        this.enableDragHandle(curentItem);
        if (!curentItem) return;
        curentItem.style.left = event.clientX / this.slideScale + this.dragOffset[0] + "px";
        curentItem.style.top = event.clientY / this.slideScale + this.dragOffset[1] + "px";
        curentItem.style.width = curentItem.offetWidth;
    }
    event.preventDefault();
};

PlotDiagram.prototype.getElementInOffset = function (parentNode, curentItem) {
    for (let j = 0; j < parentNode.children.length; j++) {
        let childNode = parentNode.children[j];
        let parentRect = childNode.getBoundingClientRect();
        let selectedItemRect = curentItem.getBoundingClientRect();
        if (selectedItemRect.top >= parentRect.top && selectedItemRect.left >= parentRect.left && selectedItemRect.left <= parentRect.left + parentRect.width && selectedItemRect.top <= parentRect.top + parentRect.height) {
            return childNode;
        }
    }
};

PlotDiagram.prototype.addMoveEvents = function () {
    this.clearMoveEvents();
    let nodeHolder = this.diagramParent.querySelector("div[name='nodesHolder']");
    if (nodeHolder) {
        nodeHolder.addEventListener("mousedown", this.mouseDownHandler);
        nodeHolder.addEventListener("mouseup", this.mouseUpHandler);
    }
};

PlotDiagram.prototype.clearMoveEvents = function () {
    let nodeHolder = this.diagramParent.querySelector("div[name='nodesHolder']");
    if (nodeHolder) {
        nodeHolder.removeEventListener("mousedown", this.mouseDownHandler);
        nodeHolder.removeEventListener("mouseup", this.mouseUpHandler);
    }
};

PlotDiagram.prototype.addListener = function (event, callback) {
    this.eventManagerXY.addListener(event, callback);
};

PlotDiagram.prototype.removeListener = function (event, callback) {
    this.eventManagerXY.removeListener(event, callback);
};

PlotDiagram.prototype.diagramRenderComplete = function () {
    if (this.completeCallBack && this.completeCallBack.func) {
        this.completeCallBack.func(this.completeCallBack.params);
        this.completeCallBack = null;
    }
    // console.log("Render Complete");
};

PlotDiagram.prototype.slideDimensionChange = function () {
    this.updateJSONData();
    this.initDiagramCreation();
    // let svgPattern = this.parentNode.querySelector("svg[class='fullBackgroundSVG']");
    // if (svgPattern && svgPattern.parentElement) {
    //     svgPattern.parentElement.innerHTML = svgPattern.cloneNode(true).outerHTML;
    // }
};

PlotDiagram.prototype.updateNodeData = function (nodeData, type, index) {
    if (this.arrDiagramNode && this.arrDiagramNode.length > index) {
        this.arrDiagramNode[index].updateContentData(nodeData, type);
    }
};

PlotDiagram.prototype.getCustomProperties = function () {};

PlotDiagram.prototype.getDiagramLayoutProperties = function () {};

PlotDiagram.prototype.setIconSize = function () {};

PlotDiagram.prototype.showHideContent = function () {};

PlotDiagram.prototype.updateProperty = function (property, value) {
    if (property && property != "" && value != undefined && value != null) {
        this.diagramData.properties[property] = value;
        this.updateProperties(this.diagramData.properties);
        this.reflectProperyUpdate(property, value);
    }
};

PlotDiagram.prototype.reflectProperyUpdate = function (property, value) {
    if (property == "contentoptions") {
        for (let i = 0; i < this.arrDiagramNode.length; i++) {
            this.arrDiagramNode[i].objData = this.diagramData.nodes[i];
            this.arrDiagramNode[i].updateProperty(this.diagramData.properties);
        }
        this.updateEvents();
    } else {
        this.updateProperties(this.diagramData?.properties);
    }
};

PlotDiagram.prototype.resetNodeAttributes = function () {
    for (let i = 0; i < this.arrDiagramNode.length; i++) {
        this.arrDiagramNode[i].updateNodeAttributes(i);
    }
};

PlotDiagram.prototype.deleteNode = function (nodeID) {
    this.clearEvents();
    let targetNode = this.diagramParent.querySelector("[id='" + nodeID + "']");
    if (targetNode && targetNode.dataset && targetNode.dataset.index) {
        let targetIndex = parseInt(targetNode.dataset.index);
        if (this.arrDiagramNode.length > targetIndex) {
            this.arrDiagramNode.splice(targetIndex, 1);
            let nodeDelete = this.diagramParent.querySelector("[name='nodeMainParent'][data-index='" + targetIndex + "']");
            if (nodeDelete && nodeDelete.parentElement) {
                nodeDelete.parentElement.removeChild(nodeDelete);
            }
        }

        if (this.diagramData.nodes.length > targetIndex) {
            this.diagramData.nodes.splice(targetIndex, 1);
        }
        this.resetNodeAttributes();
        this.updateElements();
    }
};

PlotDiagram.prototype.addNode = function () {
    let firstNode = this.arrDiagramNode[0];
    let node = JSON.parse(JSON.stringify(firstNode.objData));
    node.nodeproperties.x = DiagramUtils.getRndInteger(0, this.diagramParent.clientWidth * this.slideScale - 200);
    node.nodeproperties.y = DiagramUtils.getRndInteger(0, this.diagramParent.clientHeight * this.slideScale - 50);
    node.primarytext = { type: "", value: "" };
    let targetNode = this.parentNode.querySelector("div[id='" + firstNode.parentID + "']");
    let nodeItem = new window["PlotDiagramNode"](targetNode, this.diagramData.properties, node, this.eventManagerXY, this.arrDiagramNode.length, firstNode.parentID, this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
    nodeItem.appStaticURL = this.appStaticURL;
    nodeItem.globalMoodData = this.globalMoodData;
    nodeItem.initCreation();
    let nodeParent = nodeItem.parentNode.parentElement;
    nodeParent.style.left = node.nodeproperties.x + "px";
    nodeParent.style.top = node.nodeproperties.y + "px";
    nodeParent.setAttribute("data-x", node.nodeproperties.x);
    nodeParent.setAttribute("data-y", node.nodeproperties.y);
    nodeParent.setAttribute("axis", node.axis);
    this.arrDiagramNode.push(nodeItem);
    this.diagramData.nodes.push(node);
    this.updateEvents();
    this.diagramRenderComplete();
    return nodeItem;
};

PlotDiagram.prototype.updateElements = function () {
    this.parentNode = this.diagramParent.querySelector("[name='baseParent']");
    this.clear();
    this.recreateElementData();
    this.updateJSONData();
    this.updateEvents();
};

PlotDiagram.prototype.updateJSONData = function () {
    this.diagramData = this.getJSONData();
};

PlotDiagram.prototype.getOldPropertyValue = function (property, valueObj) {
    return DiagramUtils.getOldPropertyValue(property, valueObj, this.diagramParent, this);
};

PlotDiagram.prototype.setOperationProperty = function (property, valueObj, isFromUndoRedo = false) {
    DiagramUtils.setOperationProperty(property, valueObj, this.diagramParent, this, isFromUndoRedo);
};

PlotDiagram.prototype.updateTextSize = function (valueObj, targetNode) {
    if (targetNode) {
        let isReset = valueObj.value == "auto" || valueObj.value == "reset";
        if (isReset) {
            targetNode.style.removeProperty("font-size");
            if (targetNode?.dataset?.id == "numberNode") {
                targetNode.parentElement.parentElement.style.removeProperty("height");
                targetNode.parentElement.parentElement.style.removeProperty("max-height");
                targetNode.parentElement.style.removeProperty("height");
                targetNode.parentElement.style.removeProperty("max-height");
            } else if (targetNode?.dataset?.id == "microchartNode") {
                targetNode.style.removeProperty("height");
            }
        } else targetNode.style.fontSize = valueObj.value;
        let maxHeight = getComputedStyle(targetNode.parentElement).maxHeight;
        if (maxHeight && parseFloat(maxHeight) < parseFloat(valueObj.value)) targetNode.parentElement.style.maxHeight = valueObj.value;
        if (targetNode?.dataset?.id == "numberNode") {
            targetNode.parentElement.parentElement.style.setProperty("height", valueObj.value, "important");
            targetNode.parentElement.parentElement.style.setProperty("max-height", valueObj.value, "important");
            targetNode.parentElement.style.maxHeight = valueObj.value;
            targetNode.parentElement.style.height = valueObj.value;
        } else if (targetNode?.dataset?.id == "microchartNode") {
            targetNode.style.height = valueObj.value;
        }
    }
};

PlotDiagram.prototype.updateProperties = function (properties) {
    this.diagramParent.setAttribute("data-minnode", properties.minnode);
    this.diagramParent.setAttribute("data-maxnode", properties.maxnode);
    this.diagramParent.setAttribute("data-quadrantlabel", properties.quadrantlabel);
    this.diagramParent.setAttribute("data-axislabel", properties.axislabel);
    this.diagramParent.setAttribute("data-arrowheads", properties.arrowheads);
    this.diagramParent.setAttribute("data-xyplotstyle", properties.xyplotstyle);
    this.diagramParent.setAttribute("data-xyheader", properties.xyheader);
    this.diagramParent.setAttribute("data-gridbg", properties.gridbg);
    // Node Props
    this.diagramParent.setAttribute("data-name", this.nodeProps.name);
};

PlotDiagram.prototype.getProperties = function (defaultproperties = {}) {
    let mainProperties = this.diagramData && this.diagramData.properties ? this.diagramData.properties : defaultproperties;
    mainProperties.axislabel = this.diagramParent.dataset.axislabel === "false" ? false : true;
    mainProperties.quadrantlabel = this.diagramParent.dataset.quadrantlabel === "false" ? false : true;
    mainProperties.arrowheads = this.diagramParent.dataset.arrowheads === "false" ? false : true;
    mainProperties.xyheader = this.diagramParent.dataset.xyheader === "false" ? false : true;
    mainProperties.gridbg = this.diagramParent.dataset.gridbg === "false" ? false : true;
    mainProperties.xyplotstyle = this.diagramParent.dataset.xyplotstyle || "centeraxis";
    mainProperties.minnode = this.diagramParent.dataset.minnode;
    mainProperties.maxnode = this.diagramParent.dataset.maxnode;

    this.nodeProps = {};
    this.nodeProps.name = this.diagramParent.dataset.name;
    this.nodeProps.globalstyle = this.menuData?.globalstyle;
    this.nodeProps.parentStyle = this.menuData?.parentStyle;
    return mainProperties;
};

PlotDiagram.prototype.getJSONData = function (defaultproperties) {
    if (this.arrDiagramNode.length == 0) return this.diagramData;
    let arrNodeData = [];
    for (let i = 0; i < this.arrDiagramNode.length; i++) {
        let nodeData = this.arrDiagramNode[i].getJSONData(this.parentNode);
        arrNodeData.push(nodeData);
    }
    arrNodeData.sort((nodea, nodeab) => parseFloat(nodea.idIndex) - parseFloat(nodeab.idIndex));
    return { properties: this.getProperties(defaultproperties), nodes: arrNodeData, axis: this.getAxisLabels() };
};

PlotDiagram.prototype.getAxisLabels = function () {
    let nodeBlockParent = this.diagramParent.querySelector("div[id='nodeBlockParent']");
    let xyHolder = this.diagramParent.querySelector("div[id='xyHolder']");
    let headerTitle = this.diagramParent.querySelector("div[name='headerTitle']");

    let childNodes = nodeBlockParent.childNodes;
    let data = [];
    let quadrant = [];
    for (let i = 0; i < childNodes.length; i++) {
        let id = childNodes[i].id;
        if (id.length == 1) id = id;
        let xAxis = xyHolder.querySelector("div[class*='clsAxisLabel'][link-id='" + id + "']");
        if (xAxis) data.push(xAxis.innerText);
        let quadrantLabel = xyHolder.querySelector("div[class*='clsQuadrantLabel'][link-id='" + id + "']");
        if (quadrantLabel) quadrant.push(quadrantLabel.innerText);
    }
    return { data: data, header: [headerTitle?.innerText], quadrant: quadrant };
};

PlotDiagram.prototype.updateEvents = function () {
    let arrNodes = this.parentNode.querySelectorAll("[data-default-event='true']");
    for (let j = 0; j < arrNodes.length; j++) {
        this.eventManagerXY.addEvent(arrNodes[j], "focusout", this.defaultFoucsOut);
        this.eventManagerXY.addEvent(arrNodes[j], "focusin", this.defaultFoucsIn);
        this.eventManagerXY.addEvent(arrNodes[j], "paste", this.diagramPasteHandler);
    }
    // For Text Highlight
    let arrHighLightNodes = this.parentNode.querySelectorAll("[data-highlight-event='true']");
    for (let j = 0; j < arrHighLightNodes.length; j++) {
        this.eventManagerXY.addEvent(arrHighLightNodes[j], "mouseup", this.textHighlightMouseUpEvent.bind(this));
    }
    this.addMoveEvents();
};

PlotDiagram.prototype.diagramPasteHandler = function (event) {
    event.preventDefault();
    try {
        let strUnformattedText = (event.clipboardData || event.originalEvent.clipboardData).getData("text/plain");
        document.execCommand("insertText", false, strUnformattedText);
        // this.resetLayout();
        this.updatePropsCallBack();
    } catch (error) {
        console.log("Text Paste Error");
    }
};

PlotDiagram.prototype.textHighlightMouseUpEvent = function (event) {
    event.isTakeAway = this.isTakeAway;
    this.eventManagerXY.dispatch("mouseup", event);
};

PlotDiagram.prototype.recreateElementData = function () {
    let arrNodesItems = this.diagramParent.querySelectorAll("div[name='nodeMainParent']");
    let properties = this.getProperties();
    let intLength = arrNodesItems.length;
    this.arrDiagramNode = [];
    this.arrDiagramNode = [];
    for (let i = 0; i < intLength; i++) {
        let nodeItem = arrNodesItems[i];
        let diagramNode = new window["PlotDiagramNode"](nodeItem.parentElement, properties, null, this.eventManagerXY, i, nodeItem.getAttribute("data-parent-id"), this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
        diagramNode.nodeGroup = nodeItem.querySelector("[name='nodeGroup']");
        diagramNode.parentNode = diagramNode.nodeGroup.parentElement;
        diagramNode.appStaticURL = this.appStaticURL;
        diagramNode.globalMoodData = this.globalMoodData;
        diagramNode.updateNodeAttributes(i);
        diagramNode.objData = diagramNode.getJSONData(this.parentNode);
        nodeItem.style.left = (diagramNode.objData.nodeproperties.x || 0) + "px";
        nodeItem.style.top = (diagramNode.objData.nodeproperties.y || 0) + "px";
        this.arrDiagramNode.push(diagramNode);
    }
};

PlotDiagram.prototype.updateNodeLink = function (valueObj) {
    DiagramUtils.updateNodeLink(this.diagramParent, valueObj);
};

PlotDiagram.prototype.updatePropsCallBack = function (targetid) {
    if (this.updateCallBack && this.updateCallBack.func && !this.isTempSlide) {
        this.updateCallBack.func(this.updateCallBack.params, targetid);
    }
};

PlotDiagram.prototype.clear = function () {
    this.eventManagerXY.clear();
    this.clearMoveEvents();
    this.arrDiagramNode = [];
};

PlotDiagram.prototype.clearEvents = function () {
    this.eventManagerXY.clear();
    this.clearMoveEvents();
    // this.arrDiagramNode = [];
};

PlotDiagram.prototype.abort = function () {
    try {
        this.aborted = true;
        this.clear();
        this.completeCallBack = null;
        this.parentNode.innerHTML = "";
    } catch (error) {
        console.log(error);
    }
};

PlotDiagram.prototype.updateManifest = function (assetData, index) {
    if (this.manifestUpdater && this.manifestUpdater.func && this.manifestUpdater.params) {
        if (assetData.type == "image") {
            assetData.id = "imageNode" + index;
        }
        this.manifestUpdater.func(this.manifestUpdater.params, assetData);
    }
};

PlotDiagram.prototype.initPresent = function (currentSlide, boolNoAnimation = false) {
    if (boolNoAnimation) return { isTitleAnimation: false, isGraphicAnimation: false };
    return { isTitleAnimation: true, isGraphicAnimation: true };
};

/**
 * Author:    Saravanan G
 * Created:   3.10.2019
 *
 * (c) Copyright by Gs.
 **/
// sample commit

"use strict";

function LinearDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    this.diagramParent = diagramParent;
    this.bgDeviceDiv = null;
    this.diagramData = diagramData;
    this.moodData = moodData;
    this.nodeProps = nodeProps;
    this.eventManagerXY = new window["DiagramEventManager"]();
    this.events = {};
    this.appStaticURL = "";
    this.appmode = "";
    this.moodName = "";
    this.arrDiagramNode = [];
    this.slideScale = 1;
    this.objStyleData = {};
    window.arrIconAssets = window.arrIconAssets ? window.arrIconAssets : {};
    window.mainTime = new Date().getTime();
    this.defaultFoucsOut = this.defaultFoucsOut.bind(this);
    this.defaultFoucsIn = this.defaultFoucsIn.bind(this);
    this.defaultCheckBoxEvent = this.defaultCheckBoxEvent.bind(this);
    this.diagramPasteHandler = this.diagramPasteHandler.bind(this);
    this.imageDoubleClickHandler = this.imageDoubleClickHandler.bind(this);
    this.textHighlightMouseUpEvent = this.textHighlightMouseUpEvent.bind(this);
    this.onHoverNode = this.onHoverNode.bind(this);
    this.onHoverOutNode = this.onHoverOutNode.bind(this);
    this.searchIconCallBack = this.searchIconCallBack.bind(this);
    this.updateMaxFontCallBack = this.updateMaxFontCallBack.bind(this);

    this.animationType = "all";
    this.oneTimeAnimationType = "";
    this.isShowAllNode = false;
    this.animationIndex = 0;
    this.highlightIndex = -1;
    this.isShowHighlight = false;
    this.isHideHighlight = false;
    this.oldDirection = "front";
    this.newDirection = "back";
    this.gotoNextSlide = false;
    this.gotoPreviousSlide = false;
    this.oneAtTimeAnimationType = "";
    this.isPreviousFromAllNode = false;
    this.isReversAnimation = true;
    this.isTakeAway = this.diagramParent?.parentElement?.getAttribute("id")?.includes("TEXTBOX");
    this.diagramParent.className = "clsLinerDiagram";
    this.diagramParent.parentElement.className = "clsElementDiv commonallmood ";
    let time = new Date();
    this.id = `create time ${time.getSeconds()}:${time.getMilliseconds().toFixed(3)}`;

    let arrNodes = Array.from(this.diagramParent.querySelectorAll("[name='nodeparent']"));
    if (arrNodes.length < 2) arrNodes.map((node) => node.removeAttribute("data-highlight"));

    Constants.Value = { ...Constants.Value, slideWidth: this.diagramParent.parentElement.clientWidth };
}

LinearDiagram.prototype.initDiagramCreation = function (isDirectInsert = false) {
    this.diagramParent.style.opacity = 0;
    window.mainTime = new Date().getTime();
    this.diagramParent.innerHTML = "";
    this.diagramParent.style.setProperty("--contentResizeMH", "unset");
    this.arrDiagramNode = [];
    window.noderow = [];
    window.nodecolumn = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.createPatternBackGround(isDirectInsert);
    this.updateArrIconAssetsForQuote();
    this.diagramRenderComplete();
    this.addFocus(this.arrDiagramNode.length - 1);
};

LinearDiagram.prototype.updateArrIconAssetsForQuote = function () {
    this.arrDiagramNode.forEach((node) => {
        if (node.quoteShape) {
            if (node.quoteShape.type && node.quoteShape.type == "counting") {
                let id = node.quoteShape.id + (node.index + 1);
                let value = node.quoteShape.path + id + ".svg";
                window.arrIconAssets[id] = value;
            } else window.arrIconAssets[node.quoteShape.id] = node.quoteShape.value;
        }
    });
};

LinearDiagram.prototype.setMoodClassNames = function () {
    if (this.moodName != "") {
        this.diagramParent.parentElement.classList.add("common" + this.moodName);
        this.diagramParent.parentElement.classList.add(this.moodName + "diagram");
    }
    if (this.globalMoodData?.iconstyle) {
        this.diagramParent.setAttribute("data-iconstyle", this.globalMoodData.iconstyle);
    }
    if (this.globalMoodData?.basicgraphics?.diagramstyle) {
        this.diagramParent.setAttribute("data-diagramstyle", this.globalMoodData.basicgraphics.diagramstyle);
    }
    if (this.diagramData && this.diagramData.nodes) this.diagramParent.setAttribute("data-nodecount", this.diagramData.nodes.length);
    this.isTakeAway = this.diagramParent && this.diagramParent.parentElement && this.diagramParent.parentElement.getAttribute("id") == "TEXTBOX_HOLDER";
};

LinearDiagram.prototype.createPatternBackGround = function (isDirectInsert = false) {
    let nodeCount = this.arrDiagramNode && this.arrDiagramNode.length > 0 ? this.arrDiagramNode?.length : this.diagramData?.nodes?.length;
    if (nodeCount) this.diagramParent.setAttribute("data-nodecount", nodeCount);
    this.createElements();
    this.createCommonText();
    this.insertSvgBackground();
    this.checkCenterNodeStyle();
    DiagramCreateUtil.createDiagramTitle(this.diagramParent, this.diagramData, this.nodeProps, this.globalMoodData, this.objStyleData);
    this.updateJSONData();
    this.updateSpecialOperations();
    this.updateEmphasize();
    this.updateFloaterOperations();
    this.updateAnimationType();
    this.checkContentType();
    this.resetHolderWidth();
    // this.updatePropsCallBack();
};

LinearDiagram.prototype.setDiagramSpecficOption = function (obj) {
    let firstNode = this.diagramParent.querySelector("#nodeMainParent0");
    if (!firstNode) return;
    let options = this.diagramData.properties.floateroptionsdisable;
    if (!options) return;

    let gridoption = {};
    if (!options.includes("overlay")) {
        // let hasImageSupport = JSON.stringify(this.nodeProps.supportedNodes).includes("imageHolder");
        let hasImageSupport = false;
        let imageHolder = this.diagramParent.querySelector("[data-nodetype='imageHolder']");
        if (imageHolder && imageHolder.clientHeight != 0 && imageHolder.clientWidth != 0) {
            hasImageSupport = true;
        }
        let isAppScreen = this.diagramParent?.dataset?.nodename?.includes("appscreen");
        let disableOverlaySupport =
            !hasImageSupport || isAppScreen
                ? true
                : this.diagramData.properties.isoverlaysupport != null && this.diagramData.properties.isoverlaysupport != ""
                ? this.diagramData.properties.isoverlaysupport == "false" || this.diagramData.properties.isoverlaysupport == false
                : this.globalMoodData?.imageoverlayproperties?.hasOwnProperty("support") && this.globalMoodData.imageoverlayproperties.support == false;
        if (!disableOverlaySupport) {
            let opacity = getComputedStyle(this.diagramParent).getPropertyValue("--overlaydiagramopacity") || 0.7;
            gridoption.overlay = { isOn: this.diagramData.properties.isoverlay, label: "Overlay", property: "overlay", opacity: opacity * 100 };
        }
    }
    if (Object.keys(gridoption).length > 0) obj.dpcontent.floatdiagramsettings.gridoption = gridoption;
};

LinearDiagram.prototype.playSingleColumnLogoAnimation = function () {
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    if (nodesHolder?.classList?.contains("singleColumnLogoGrid")) {
        setTimeout(() => {
            DiagramUtils.animate({
                duration: 3500,
                timing: function (t) {
                    return t * (2 - t); //Math.pow(timeFraction, 2);
                },
                draw: function (progress) {
                    let scrollHeight = nodesHolder.scrollHeight - nodesHolder.clientHeight;
                    nodesHolder.scrollTop = progress * scrollHeight;
                },
            });
        }, 2500);
    }
};

LinearDiagram.prototype.updateCssAttributes = function () {
    if (this.arrDiagramNode.length > 0 && this.appmode.toLowerCase() != "present") {
        let nodeParent = this.arrDiagramNode[0].parentNode.parentElement;
        let nodeParentStyle = window.getComputedStyle(nodeParent);
        this.arrSMLSize = DiagramUtils.getSMLValues(nodeParentStyle);
        let percentValue = nodeParentStyle.getPropertyValue("--cutomNodeBorderWidthPercent");
        percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
        let sourceNode = this.diagramParent.querySelector("[data-nodetype='iconHolder']");
        if (sourceNode) {
            this.diagramParent.style.setProperty("--customNodeBorderWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
            sourceNode.style.removeProperty("--customNodeBorderWidth");
        }

        let sourceNodeImage = this.diagramParent.querySelector("[data-nodetype='imageHolder']");
        if (sourceNodeImage) {
            this.diagramParent.style.setProperty("--customNodeBorderImageWidth", (sourceNodeImage.offsetWidth / 100) * percentValue + "px");
            sourceNodeImage.style.removeProperty("--customNodeBorderImageWidth");
        }

        let percentValueSeq = nodeParentStyle.getPropertyValue("--cutomNodeBorderSeqWidthPercent");
        percentValueSeq = isNaN(parseInt(percentValueSeq)) ? 4 : parseInt(percentValueSeq);
        let sourceNodeSeq = this.diagramParent.querySelector("[name='seqTitleHolder']");
        if (sourceNodeSeq) {
            this.diagramParent.style.setProperty("--customNodeBorderSeqWidth", (sourceNodeSeq.offsetWidth / 100) * percentValueSeq + "px");
            sourceNodeSeq.style.removeProperty("--customNodeBorderSeqWidth");
        }
        let nodeCalcHeight = nodeParent.clientHeight;
        let nodeCalcWidth = nodeParent.clientWidth;
        this.diagramParent.style.setProperty("--nodeCalcHeight", nodeCalcHeight + "px");
        this.diagramParent.style.setProperty("--nodeCalcWidth", nodeCalcWidth + "px");
        if (this.diagramData?.properties?.overlayopacity) {
            this.diagramParent.style.setProperty("--overlaydiagramopacity", this.diagramData.properties.overlayopacity);
        }
    }
};

LinearDiagram.prototype.insertSvgBackground = function () {
    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsSVGBackground moodanimation";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "svgBackground");
    pattenDiv.setAttribute("data-animation", "svgnodebg");
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    if (nodesHolder) nodesHolder.insertBefore(pattenDiv, nodesHolder.firstElementChild);
};

LinearDiagram.prototype.updateAnimationType = function () {
    let animationType = this.diagramParent.parentElement.dataset.animationtype || "";
    let animationNameInMenu = DiagramUtils.animationTypeImMenu(animationType);
    if (this.nodeProps && this.nodeProps.animationtype && this.nodeProps.animationtype[animationNameInMenu]) {
        this.diagramParent.parentElement.setAttribute("data-oneattimeanimationtype", this.nodeProps.animationtype[animationNameInMenu]);
    } else if (this.globalMoodData.diagramanimationtype) {
        if (this.isNonLinearAsset()) {
            this.diagramParent.parentElement.setAttribute("data-oneattimeanimationtype", this.globalMoodData.diagramanimationtype.nonlinear[animationNameInMenu]);
        } else this.diagramParent.parentElement.setAttribute("data-oneattimeanimationtype", this.globalMoodData.diagramanimationtype.linear[animationNameInMenu]);
    } else this.diagramParent.parentElement.setAttribute("data-oneattimeanimationtype", "");
};

LinearDiagram.prototype.checkCenterNodeStyle = function () {
    let centerNodeStyle = this.nodeProps.centerNodeStyle;
    if (centerNodeStyle) {
        let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
        DiagramUtils.addClassNames(centerNodeStyle, nodesHolder);
    }
};

LinearDiagram.prototype.checkContentType = function () {
    let primaryType = this.diagramParent.querySelector("[data-holder-type='primary']");
    if (primaryType && primaryType.dataset && primaryType.dataset.contentType) {
        this.diagramData.properties.contenttype = primaryType.dataset.contentType;
        this.arrDiagramNode.forEach((element) => {
            if (element.properties) element.properties.contenttype = primaryType.dataset.contentType;
        });
    }
};

LinearDiagram.prototype.createCommonText = function (fontData = null) {
    // if (this.nodeProps.commonText) {
    let commonTitle = this.diagramParent.querySelector("[name='commonTitleHolder']");
    if (commonTitle) commonTitle.remove();
    if (this.nodeProps.commonText || fontData) {
        let alignment = fontData && fontData.alignment ? fontData.alignment : "topbottom";
        this.diagramParent.setAttribute("data-commontitle", "true");
        this.diagramParent.setAttribute("data-commontitlealign", alignment);
        if (alignment == "topbottom") this.diagramParent.style.setProperty("--gridTitleHeight", fontData && fontData.height ? fontData.height : "20%");
        else this.diagramParent.style.setProperty("--gridTitleWidth", fontData && fontData.width ? fontData.width : "20%");
        commonTitle = document.createElement("div");
        commonTitle.className = "clsCommonTextHolder";
        commonTitle.setAttribute("id", DiagramNodeUtils.uuidv4());
        commonTitle.setAttribute("name", "commonTitleHolder");
        commonTitle.setAttribute("data-dck-selector", true);
        this.diagramParent.appendChild(commonTitle);
        let titleNode = DiagramCreateUtil.createLabel(0, "clsCommonText " + fontData && fontData.fontSize ? fontData.fontSize : "h5", "commonText", fontData && fontData.prompt ? fontData.prompt : "Diagram Title");
        titleNode.innerText = fontData && fontData.value ? fontData.value : "";
        commonTitle.appendChild(titleNode);
        titleNode.setAttribute("data-default-event", true);
        this.diagramParent.style.setProperty("flex-direction", alignment == "topbottom" ? "column" : "row");
        this.resetHolderWidth();
    }
};

LinearDiagram.prototype.createNodeInstances = function (nodeCount, pattenDiv) {
    for (let i = 0; i < nodeCount; i++) {
        let nodeItem = new window[this.nodeProps.nodeclassName](pattenDiv, this.diagramData.properties, this.diagramData.nodes[i], this.eventManagerXY, i, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
        this.createNodeInstanceProperties(nodeItem);
        nodeItem.initCreation(this.isGridAsset(this.nodeProps.name) ? false : i == nodeCount - 1);
        if (nodeItem.multiTextBox && i == 0) {
            this.arrDiagramNode.push(nodeItem);
            return;
        }
        this.arrDiagramNode.push(nodeItem);
    }
    let placeholderType = this.nodeProps?.centerShape?.placeholdertype;
    this.objContentLoad = [];
    if (!placeholderType) DiagramUtils.searchMultipleAICall(this.arrDiagramNode, this.diagramData.properties.contenttype, this.diagramData.properties, this.globalMoodData, this.searchIconCallBack, appBaseURL, this.appStaticURL, null, this.searchFailureCallBack.bind(this));
};

// Node level variables
LinearDiagram.prototype.createNodeInstanceProperties = function (nodeItem) {
    nodeItem.moodData = this.moodData;
    nodeItem.moodName = this.moodName;
    nodeItem.updateCallBack = this.updateCallBack;
    nodeItem.imageLoadCallBack = this.imageLoadCallBack.bind(this);
    nodeItem.defaultImageLoadCallBack = this.defaultImageLoadCallBack.bind(this);
    nodeItem.defaultIconLoadCallBack = this.defaultIconLoadCallBack.bind(this);
    nodeItem.fontClassList = this.fontClassList;
    nodeItem.searchIconCallBack = this.searchIconCallBack;
    nodeItem.updateMaxFontCallBack = this.updateMaxFontCallBack;
    nodeItem.bgDeviceDiv = this.bgDeviceDiv;
    nodeItem.animatedSprites = this.animatedSprites;
    nodeItem.arrDefaults = this.arrDefaults;
    nodeItem.globalMoodData = this.globalMoodData;
    nodeItem.arrTintArray = this.arrTintArray;
    nodeItem.manifestUpdater = this.manifestUpdater;
    nodeItem.appStaticURL = this.appStaticURL;
};

LinearDiagram.prototype.isGridAsset = function (name) {
    return name.startsWith("grd");
};

LinearDiagram.prototype.setSlideScale = function () {
    this.slideScale = DiagramUtils.calcSlideScale(this.diagramParent.parentElement.parentElement, this.appmode);
};

LinearDiagram.prototype.setSlideWidthHeight = function (width, height) {
    this.slideWidth = width;
    this.slideHeight = height;
    Constants.Value = { ...Constants.Value, slideWidth: width, slideHeight: height };
};

LinearDiagram.prototype.defaultFoucsIn = function (event) {
    if (event.target.className && event.target.className.includes("clsSingleLineRestrict") && !event.target.id.includes("numberNode")) {
        event.target.innerText = DiagramUtils.removelinebreaks(event.target.textContent);
    }
    event.target.dataset.oldtext = event.target.innerHTML;
};

LinearDiagram.prototype.setSecondaryIconList = function (target, index) {
    let arrChildren = Array.from(target.children);
    arrChildren.forEach((element, liIndex) => {
        this.arrDiagramNode[index].enableSecondarySubContent(element, element.innerHTML, liIndex);
    });
    this.updateEvents();
};

LinearDiagram.prototype.isDifferentText = function (target) {
    let oldHTMLText = target.innerHTML;
    let typedText = target.dataset?.oldtext;
    if (oldHTMLText != typedText && this.appmode.toLowerCase() != "present") {
        return true;
    } else return false;
};

LinearDiagram.prototype.defaultFoucsOut = function (event) {
    let index = event.target.dataset.index;

    if (event.target.id.includes("secondaryText")) {
        if (event.target.firstElementChild && event.target.firstElementChild.innerText.trim() == "") event.target.firstElementChild.innerHTML = "";
        this.setSecondaryIconList(event.target, index);
    }
    if (event.target.className && event.target.className.includes("clsSingleLineRestrict") && !event.target.id.includes("numberNode")) {
        event.target.innerText = DiagramUtils.removelinebreaks(event.target.textContent);
    }

    let oldHTMLText = event.target.innerHTML;

    let typedText = event.target.dataset?.oldtext;
    if (oldHTMLText != typedText && this.appmode.toLowerCase() != "present") {
        if (this.arrDiagramNode && this.arrDiagramNode[index] && this.arrDiagramNode[index].numberToggleStyle) {
            this.arrDiagramNode[index].numberToggleStyle.updateNumberToggleNodeForSign(event.target, this.arrDiagramNode[index].parentNode.parentElement);
        }
        this.eventManagerXY.dispatch("focusout", event.target);
        event.target.dataset.oldtext = event.target.innerHTML;
        if (event.currentTarget?.id?.includes("diagramTitle")) {
            DiagramCreateUtil.setDiagramTitleSingleLine(this.diagramParent);
            this.resetLayout();
            this.updatePropsCallBack();
            return;
        }
        if ((event.target.id.includes("primary") || event.target.id.includes("authorName")) && event.target.innerText != event.target.dataset.oldinnertext) {
            event.target.dataset.oldinnertext = event.target.innerText;
            let targetNode = this.arrDiagramNode[index]?.parentNode?.querySelector("[name='contentNode']");
            let assetNode = targetNode && (targetNode.querySelector("[data-id='logoNode']") || targetNode.querySelector("[data-id='imageNode']") || targetNode.querySelector("[data-id='iconNode']"));
            if (assetNode && assetNode.parentElement) {
                assetNode.parentElement.setAttribute("data-node-graphic-text", event.target.textContent);
                let type = assetNode.parentElement.dataset.nodeContentType;
                if (!this.restrictSearch(event.target)) DiagramUtils.searchAIcall(type, this.arrDiagramNode[index]?.objData, event.target.textContent, this.diagramData.properties, this.globalMoodData, assetNode, index, this.searchIconCallBack, appBaseURL, this.appStaticURL);
            }
        }
        // this.updatePropsCallBack(event.target.id);
        this.updateJSONData();
        this.updateTextNodes(index); // need to discuss
        this.resetImageLogoFrames();
        event.target.scrollTop = 0;
        event.target.parentNode.scrollTop = 0;
        if (event.target.dataset.id == "numberNode") {
            DiagramNodeUtils.checkNumberFormat(event.target, this.diagramParent, this.globalMoodData, this.nodeProps);
            this.checkSMLOverflow();
            this.updatePropsCallBack();
            return;
        }
        this.checkContentType();
        this.updateCssAttributes();
        this.updatePropsCallBack();
    }
};

LinearDiagram.prototype.isFingerCountingAsset = function () {
    return this.nodeProps && this.nodeProps.quoteShape && this.nodeProps.quoteShape.type && this.nodeProps.quoteShape.type == "counting";
};

LinearDiagram.prototype.restrictSearch = function (target) {
    let index = target.dataset.index || 0;
    let nodeItem = this.diagramParent.querySelector("[id='nodeGroup" + index + "']");
    let allowSearch = nodeItem.hasAttribute("data-issearchiconloaded");
    return (this.nodeProps && this.nodeProps.quoteShape) || this.nodeProps?.name?.includes("-qt-") || allowSearch;
};

LinearDiagram.prototype.textHighlightMouseUpEvent = function (event) {
    event.isTakeAway = this.isTakeAway;
    this.eventManagerXY.dispatch("mouseup", event);
};

LinearDiagram.prototype.defaultCheckBoxEvent = function (event) {
    event.preventDefault();
    event.slideID = this.slideID;
    this.eventManagerXY.dispatch("mousedown", event);
};

LinearDiagram.prototype.searchFailureCallBack = function (e) {
    if (!this.objContentLoad) this.objContentLoad = [];
    this.objContentLoad?.push(e);
    if (this.objContentLoad?.length == this.arrDiagramNode.length) {
        this.updatePropsCallBack();
    }
};

LinearDiagram.prototype.imageLoadCallBack = function (target) {
    if (!this.objContentLoad) this.objContentLoad = [];
    this.objContentLoad?.push(target.id);
    if (this.objContentLoad?.length == this.arrDiagramNode.length) {
        this.updatePropsCallBack(target.id);
    }
};

LinearDiagram.prototype.defaultImageLoadCallBack = function (target) {
    if (!this.objDefaultContentLoad) this.objDefaultContentLoad = [];
    this.objDefaultContentLoad?.push(target.id);
    if (this.objDefaultContentLoad?.length == this.arrDiagramNode.length) {
        this.updatePropsCallBack(target.id);
        this.objDefaultContentLoad = null;
    }
};

LinearDiagram.prototype.defaultIconLoadCallBack = function (target) {
    if (!this.objDefaultContentLoad) this.objDefaultContentLoad = [];
    this.objDefaultContentLoad?.push(target.id);
    if (this.objDefaultContentLoad?.length == this.arrDiagramNode.length) {
        this.updatePropsCallBack(target.id);
        this.objDefaultContentLoad = null;
    }
};

LinearDiagram.prototype.searchIconCallBack = function (content, type, index, id) {
    this.updateNodeData(content, type, index, id);
    // this.updatePropsCallBack(id);
    if (type == "icon") {
        let iconName = DiagramNodeUtils.getIconName(content);
        content.id = iconName;
        DiagramCreateUtil.updateManifest(content, this.manifestUpdater, this.appStaticURL);
        this.objContentLoad?.push(content);
    }
    let targetNode = this.diagramParent.querySelector("[id='" + id + "']");
    let nodeGroup = this.diagramParent.querySelector("[name='nodeGroup'][index='" + index + "']");
    if (id.includes("gridNode")) {
        if (targetNode) {
            let gridIndex = targetNode.dataset.index;
            let gridInstance = this.arrDiagramNode[gridIndex].gridInstance;
            gridInstance.changeImageNode(id, targetNode.dataset.imagegridIndex, content.value, content.searchText);
            gridInstance.gridimages = gridInstance.getLogoListData(this.arrDiagramNode[gridIndex].parentNode);
        }
        // this.arrDiagramNode[index].gridInstance.adjustLayout();
    } else {
        if (type == "logo" && content.hasOwnProperty("logocontrast")) {
            let logoNode = targetNode.querySelector("[name='logoNode']") || targetNode;
            let nodeItem = this.arrDiagramNode[index];
            if (nodeItem?.objData?.nodeproperties) {
                nodeItem.objData.nodeproperties.logocontrast = content.logocontrast;
                nodeItem.updateNodeProperties(nodeItem.objData.nodeproperties);
            }
            DiagramUtils.setLogoContrast(logoNode, nodeGroup, content.logocontrast);
        }
    }
    this.updateJSONData();
    // if (updateProps)
    if (this.objContentLoad?.length == this.arrDiagramNode.length) {
        this.updatePropsCallBack(id);
    }
};

LinearDiagram.prototype.updatePropsCallBack = function (targetid) {
    this.updateCssAttributes();
    if (this.updateCallBack && this.updateCallBack.func && !this.isTempSlide) {
        this.updateCallBack.func(this.updateCallBack.params, targetid);
    }
};

LinearDiagram.prototype.updateColorCallBack = function (objDetails) {
    if (this.colorChangeCallBack && this.colorChangeCallBack.func && !this.isTempSlide) {
        this.colorChangeCallBack.func(this.colorChangeCallBack.params, objDetails);
    }
};

LinearDiagram.prototype.updateResizeCallBack = function (targetid, diagramData, instance) {
    if (this.titleResizeCallBack && this.titleResizeCallBack.func) {
        this.titleResizeCallBack.func(targetid, diagramData, instance);
    }
};

LinearDiagram.prototype.updateMaxFontCallBack = function (targetId) {
    if (this.updateFontResizeCallBack && this.updateFontResizeCallBack.func) {
        this.updateFontResizeCallBack.func(this.diagramData, this.diagramParent, targetId);
    }
};

LinearDiagram.prototype.isChildEmpty = function () {
    let arrNodes = this.diagramParent.querySelectorAll("[name='nodeparent']");
    if (arrNodes.length == 0) return true;
    let deviceHolder = this.diagramParent.querySelector("[data-id='deviceHolder']");
    if (deviceHolder && deviceHolder.innerHTML == "") return true;
    return false;
};

LinearDiagram.prototype.diagramPasteHandler = function (event) {
    event.preventDefault();
    try {
        let strUnformattedText = (event.clipboardData || event.originalEvent.clipboardData).getData("text/plain");
        event?.target?.focus();
        document.execCommand("insertText", false, strUnformattedText);
        this.resetLayout();
        this.updatePropsCallBack();
    } catch (error) {
        console.log("Text Paste Error");
    }
};
// Multinode to singlenode
LinearDiagram.prototype.getDiagramSingleNodeData = function (index) {
    let data = this.arrDiagramNode[index].objData;
    let secondaryText = "";
    if (data.secondarytext && data.secondarytext.items)
        data.secondarytext.items.forEach((element) => {
            if (element.value.trim() != "") secondaryText += TextHighLightUtils.highlightToString(element.value) + " ";
        });
    let isDiagramContent = this.diagramData.properties.diagramcontent && data.content;
    return {
        title: TextHighLightUtils.highlightToString(data.primarytext.value ? data.primarytext.value : ""),
        subtitle: secondaryText,
        type: data?.content?.type || "text",
        // type: isDiagramContent ? data.content.type : "text",
        // value: isDiagramContent ? data.content.value : "",
        value: data?.content?.value || "",
        label: "",
        author: data.author,
        isquote: this.nodeProps?.name?.includes("qt"),
        contenttype: data && data.content && data.content.contenttype ? data.content.contenttype : this.diagramData.properties.contenttype,
        // ctabutton: data.content && data.content.contenttype && data.content.contenttype == "button" ? data.content.value : "",
        ctabutton: this.diagramData.properties.button && data.button && data.button.value ? data.button.value : "",
    };
};

LinearDiagram.prototype.getOutlineMatrix = function (isFromZenEditor = false) {
    let row = [];
    let subtype = "bulleted";
    let tempData = this.getJSONData();
    let arrNodes = tempData && tempData.nodes && !isFromZenEditor ? tempData.nodes : this.diagramData?.nodes;
    if (!arrNodes || arrNodes.length == 0) {
        this.recreateElementData();
        if (!this.diagramData) this.diagramData = this.getJSONData();
    }
    const properties = this.getProperties();

    for (let i = 0; i < arrNodes.length; i++) {
        let column = [];
        let nodeData = arrNodes[i];
        let sublist = false;
        if (nodeData.bgimage) {
            column.push({ isbgimage: true, type: nodeData.bgimage.type, dataRef: nodeData.bgimage.dataRef, id: nodeData.bgimage.id, value: nodeData.bgimage.value ? nodeData.bgimage.value : "" });
        }
        if (nodeData.content && properties.diagramcontent && nodeData.content.contenttype && nodeData.content.contenttype != "diagramContentNode") {
            if (subtype == "valued") {
                properties.contenttype = nodeData.content.contenttype;
            }
            subtype = DiagramUtils.getSubType(properties.contenttype);
            // let cellOBJ = { type: nodeData.content.type, value: nodeData.content.value ? nodeData.content.value : "" };
            let cellOBJ = nodeData.content;
            if (nodeData.content.contenttype == "image" || nodeData.content.contenttype == "logo" || nodeData.content.contenttype == "icon") {
                subtype = nodeData.content.contenttype;
                if (nodeData.content.dataRef) {
                    cellOBJ.id = nodeData.content.id;
                    cellOBJ.dataRef = nodeData.content.dataRef;
                }
                cellOBJ.logodata = nodeData.content.logodata;
                cellOBJ.assetText = nodeData.content.assetText || "";
            }
            cellOBJ.contenttype = nodeData.content.contenttype;
            column.push(cellOBJ);
        } else if (properties.sequencetext) {
            subtype = "numbered";
            // properties.contenttype = "sequence";
            // if (this.diagramParent) this.diagramParent.setAttribute("data-contenttype", "sequence");
        }
        if (nodeData.primarytext) {
            // column.push({ type: "text", value: TextHighLightUtils.highlightToString(nodeData.primarytext.value ? nodeData.primarytext.value : "") });
            // column.push({ type: "text", value: nodeData.primarytext.value, lineheight: nodeData.primarytext.lineheight, letterspacing: nodeData.primarytext.letterspacing });
            column.push({ type: "text", value: nodeData.primarytext.value, textproperties: nodeData.primarytext.textproperties });
        }
        if (nodeData.secondarytext && nodeData.secondarytext.items) {
            for (let l = 0; l < nodeData.secondarytext.items.length; l++) {
                let arrItems = nodeData.secondarytext.items[l].value.split("\n");
                arrItems.forEach((value) => {
                    // if (value && value != "") column.push({ type: "text", value: TextHighLightUtils.highlightToString(value), index: i });
                    // if (value && value != "")
                    column.push({
                        type: "text",
                        value: value,
                        index: i,
                        content: nodeData.secondarytext.items[l].content,
                        textproperties: nodeData.secondarytext.textproperties,
                    });
                });
            }
            sublist = nodeData.secondarytext.sublist ? nodeData.secondarytext.sublist : "none";
        }

        // console.log(nodeData.multitextdata);
        this.setNodeData(i, nodeData);

        row.push(this.setRowMatrix(column, nodeData, sublist));
        if (nodeData.multitextdata) {
            row = DiagramUtils.quillToOutlineParser(nodeData.multitextdata);
            // rowData = outlineData.matrix[i];
            // if (column && column[0]) {
            //     column[0].multitextdata = true;
            //     column[0].quilldelta = nodeData.quilldelta;
            // }
        }
    }
    let animationtype = this.diagramParent.parentElement.dataset.animationtype || "all";
    let oneattimeanimationtype = this.diagramParent.parentElement.dataset.oneattimeanimationtype || "fadein";
    let returnData = {
        subtype: subtype,
        properties: properties,
        matrix: row,
        graphictype: "diagram",
        animationdata: { animationtype: animationtype, oneattimeanimationtype: oneattimeanimationtype },
    };
    if (this.centerHolderNode && this.getCenterHolderData) returnData.centerholderdata = this.getCenterHolderData();
    if (this.getProjectionData) returnData.projectiondata = this.getProjectionData();
    if (this.getStartEndData) returnData.startenddata = this.getStartEndData();
    if (tempData.diagramtitle) returnData.diagramtitle = tempData.diagramtitle;
    return returnData;
};

LinearDiagram.prototype.setNodeData = function (i, nodeData) {
    if (this.diagramData.nodes[i]) {
        this.diagramData.nodes[i].label = nodeData.label;
        this.diagramData.nodes[i].subtext = nodeData.subtext;
        this.diagramData.nodes[i].button = nodeData.button;
        this.diagramData.nodes[i].position = nodeData.position;
        this.diagramData.nodes[i].crossout = nodeData.crossout;
        this.diagramData.nodes[i].logocontrast = nodeData.logocontrast;
        this.diagramData.nodes[i].ischecked = nodeData.ischecked;
        this.diagramData.nodes[i].emphasize = nodeData.emphasize || "";
        this.diagramData.nodes[i].highlightdata = nodeData.highlightdata || {};
        this.diagramData.nodes[i].link = nodeData.link || "";
        this.diagramData.nodes[i].extralink = nodeData.extralink || {};
    }
};

LinearDiagram.prototype.setRowMatrix = function (column, nodeData, sublist) {
    let row = {};
    if (column) row.matrix = column;
    if (nodeData.seccontent && nodeData.seccontent.length > 0) row.secondary = nodeData.seccontent;
    if (nodeData.tertiarycontent && nodeData.tertiarycontent.length > 0) row.tertiary = nodeData.tertiarycontent;
    if (nodeData.secondarytext && nodeData.secondarytext.seccontent && nodeData.secondarytext.seccontent.length > 0) row.seclistcontent = nodeData.secondarytext.seccontent;
    if (nodeData.author) row.author = nodeData.author;
    if (nodeData.number) row.number = nodeData.number;
    if (sublist) row.rowtype = sublist;
    if (nodeData.nodeproperties) row.nodeproperties = nodeData.nodeproperties;
    if (nodeData.customconnector) row.customconnector = nodeData.customconnector;
    if (nodeData.customconnectortext) row.customconnectortext = nodeData.customconnectortext;
    if (nodeData.label && nodeData.label != "") row.label = nodeData.label;
    if (nodeData.subtext && nodeData.subtext != "") row.subtext = nodeData.subtext;
    if (nodeData.button && nodeData.button != "") row.button = nodeData.button;
    if (nodeData.emphasize && nodeData.emphasize != "") row.emphasize = nodeData.emphasize;
    if (nodeData.position) row.position = nodeData.position;
    if (nodeData.crossout) row.crossout = nodeData.crossout;
    if (nodeData.logocontrast) row.logocontrast = nodeData.logocontrast;
    if (nodeData.ischecked) row.ischecked = nodeData.ischecked;
    if (nodeData.highlightdata && Object.keys(nodeData.highlightdata).length != 0) row.highlightdata = nodeData.highlightdata;
    if (nodeData.link) row.link = nodeData.link;
    if (nodeData.extralink) row.extralink = nodeData.extralink;
    return row;
};

LinearDiagram.prototype.getHolderObj = function (supportedNodes, name) {
    return DiagramUtils.getObjectFromName(supportedNodes, name);
};

LinearDiagram.prototype.getVisibilityForHolder = function (supportedNodes, holderName, defaultValue = false) {
    let holderObj = DiagramUtils.getObjectFromName(supportedNodes, holderName);
    return holderObj && holderObj.hasOwnProperty("visible") ? holderObj.visible : defaultValue;
};

LinearDiagram.prototype.initDiagramCreationOutline = function (outlineData, data) {
    // let outlinetype = this.isTakeAway ? data.outlinetype : !outlineData?.outlinetype?.includes("list") ? outlineData?.outlinetype : data.outlinetype;
    // let outlinetype = outlineData && outlineData.subtype ? outlineData.subtype : data.outlinetype;
    if (!outlineData) outlineData = {};
    if (!data) data = {};
    let outlinetype = data.outlinetype;
    // if (data?.name?.includes("-all-") && outlineData && outlineData.subtype) {
    //     outlinetype = outlineData.subtype;
    // }
    if (!data.name) {
        console.log("no name for this menu...");
        console.log(data);
        data.name = "";
    }
    // if (data?.extraData?.outlinetype) {
    //     outlinetype = data?.extraData?.outlinetype;
    // }

    window.isFromListType = data?.extraData?.quilltype;

    let moodsData = data.moodsData || this.globalMoodData?.basicgraphics || {};
    let titleHolder = this.getHolderObj(data.supportedNodes, "titleHolder");
    let seperator = DiagramUtils.getSeperatorObject(moodsData, data.classname);
    let enableIcon = data.name.includes("-sec-ic");
    let enableValue = data.name.includes("-sec-val");
    let enableImage = data.name.includes("-sec-img");
    let enableLogoList = data.name.includes("-sec-lgrd");
    let enableLogo = data.name.includes("-sec-lg");
    let enableSequence = this.getVisibilityForHolder(data.supportedNodes, "seqTitleHolder");
    let iconHolderObj = DiagramUtils.getObjectFromName(data.supportedNodes, "iconHolder");
    let valueHolderObj = DiagramUtils.getObjectFromName(data.supportedNodes, "valueTitleHolder");
    let microChartHolderObj = DiagramUtils.getObjectFromName(data.supportedNodes, "microChartHolder");
    let imageHolderObj = DiagramUtils.getObjectFromName(data.supportedNodes, "imageHolder");
    let logoHolderObj = DiagramUtils.getObjectFromName(data.supportedNodes, "imageSecHolder");
    let enableOverlay = this.globalMoodData.imageoverlayproperties?.enable;
    let enableOverlaySupport = this.globalMoodData.imageoverlayproperties?.support && !data?.floateroptionsdisable?.includes("overlay");
    let disableImage = data.floateroptionsdisable && data.floateroptionsdisable.includes("graphicsecondaryimage");
    let disableBulletPoints = data.floateroptionsdisable && data.floateroptionsdisable.includes("bullet");
    let enableConnector = data.hasOwnProperty("connectorvisible") ? data.connectorvisible : seperator.connector || data.connector ? seperator?.connectorvisible : false;
    let enableConnectorText = data.hasOwnProperty("connectortextvisible") ? data.connectortextvisible : seperator.connectortext || data.connectortext ? seperator?.connectortextvisible : false;
    let enableSeperator = data.hasOwnProperty("seperatorlinevisible") ? data.seperatorlinevisible : seperator.seperatorline || data.seperatorline ? seperator?.seperatorlinevisible : false;
    let defaultprops = {
        isfromai: data.isFromAI,
        diagramtitle: false,
        diagramcontent: true,
        sequencetext: enableSequence,
        secondarytext: this.getVisibilityForHolder(data.supportedNodes, "subTitleHolder", true),
        primarytext: this.getVisibilityForHolder(data.supportedNodes, "titleHolder", true),
        label: this.getVisibilityForHolder(data.supportedNodes, "textLabelHolder", false),
        quote: true,
        subtext: this.getVisibilityForHolder(data.supportedNodes, "subtextHolder", false),
        authorname: this.getVisibilityForHolder(data.supportedNodes, "authorNameHolder", true),
        authordes: this.getVisibilityForHolder(data.supportedNodes, "authorDesHolder", true),
        authorimage: this.getVisibilityForHolder(data.supportedNodes, "authorImageHolder", true),
        secondaryplaceholder: data?.name?.includes("-sec-") ? (enableIcon ? "icon" : enableValue ? "number" : enableImage ? "image" : enableLogoList ? "logolist" : enableLogo ? "logo" : null) : null,
        enablesecplaceholder: data?.name?.includes("-sec-") ? (enableIcon ? enableIcon : enableImage && !disableImage ? enableImage : enableLogoList ? enableLogoList : enableLogo ? enableLogo : enableValue ? enableValue : false) : false,
        microchart: this.getVisibilityForHolder(data.supportedNodes, "microChartHolder", true),
        // button: this.getVisibilityForHolder(data.supportedNodes, "buttonTitleHolder", false),
        button: data.name.includes("-sec-btn"),
        contenttype: outlinetype,
        hasconnector: enableConnector,
        connectortext: enableConnectorText,
        seperatorline: !enableConnector && !outlineData?.properties?.hasconnector ? enableSeperator : false,
        connectorstyle: data?.connector?.style || Constants.Value.connectorstyle,
        logosize: (logoHolderObj && logoHolderObj.size) || moodsData.logosize || Constants.Value.logosize,
        iconsize: (iconHolderObj && iconHolderObj.size) || moodsData.iconsize || Constants.Value.iconsize,
        imagesize: (imageHolderObj && imageHolderObj.size) || moodsData.imagesize || Constants.Value.imagesize,
        numbersize: (valueHolderObj && valueHolderObj.size) || moodsData.numbersize || Constants.Value.numbersize,
        microchartsize: (microChartHolderObj && microChartHolderObj.size) || moodsData.microchartsize || Constants.Value.microchartsize,
        valueformat: data.numberformat || "actualnumber",
        isoverlay: data.isoverlayvisible != null ? data.isoverlayvisible : enableOverlay ? enableOverlay : false,
        isoverlaysupport: imageHolderObj ? (data.isoverlaysupport != null ? data.isoverlaysupport : enableOverlaySupport ? enableOverlaySupport : false) : false,
        multicolor: data?.colordata?.multicolor == "true" || outlineData?.properties?.multicolor,
    };

    // Retain design elements on mood change / style change
    if (outlineData?.properties && window.ismoodchange) {
        let arrDesignProperties = ["iconsize", "logosize", "imagesize", "numbersize", "microchartsize", "seperatorline", "isfromai"];
        arrDesignProperties.forEach((element) => {
            if (outlineData.properties.hasOwnProperty(element)) {
                delete outlineData.properties[element];
            }
        });
    }

    // Override properties for explore styles
    // let overrideProperties = !window.ismoodchange && !window.isFromSlideEditor;
    let overrideProperties = !window.isFromSlideEditor && data?.name != outlineData?.properties?.name;
    if (overrideProperties && data?.extraData?.properties) defaultprops = { ...defaultprops, ...data.extraData.properties };
    if ((outlineData.outlinetype == "checklist" || outlineData.outlinetype == "bulletlist") && outlineData.subtype && outlineData.subtype == "bulleted") outlinetype = outlineData.outlinetype;
    let hasProperties = outlineData && outlineData.hasOwnProperty("properties") && Object.keys(outlineData.properties).length != 0;
    let hasContent = true;
    let takeawayProperties = "";
    if (!hasProperties) {
        takeawayProperties = outlineData && outlineData.hasOwnProperty("takeawayproperties") && Object.keys(outlineData.takeawayproperties).length != 0;
    }
    let properties = defaultprops;
    if (hasProperties && !takeawayProperties) {
        properties = {
            ...defaultprops,
            ...outlineData.properties,
            // ...(overrideProperties && data?.extraData?.properties ? data?.extraData?.properties : {}),
        };
    } else if (takeawayProperties) {
        properties = {
            ...defaultprops,
            ...outlineData.takeawayproperties,
            // ...(overrideProperties && data?.extraData?.properties ? data?.extraData?.properties : {}),
        };
    }
    // if (data?.extraData?.properties?.contenttype) defaultprops = properties.contenttype = data?.extraData?.properties?.contenttype;

    let contentOptionNode = data.nodeclassName && data.nodeclassName.includes("ContentOptionNode");
    if (contentOptionNode) {
        //below line is to override default data from menu json
        if (overrideProperties) outlineData.properties = { ...outlineData.properties, ...data?.extraData?.properties };
        outlinetype = outlineData?.properties?.contenttype || outlinetype;
        outlineData.outlinetype = outlinetype;
        if (outlineData?.properties?.centernodetype && !outlineData?.centerholderdata) {
            outlineData.centerholderdata = DiagramNodeUtils.diagramContentData(outlineData.properties.centernodetype, this.appStaticURL, this.arrDefaults, 0);
            LinearDiagram.prototype.setHolderType.call(this, outlinetype, "centerNode");
            defaultprops.centernodetype = outlineData.properties.centernodetype;
            defaultprops.centerholdertype = this.diagramParent.dataset.centerholdertype;
        }
    }
    if (data.isMultiGrid) properties.ismultigrid = data.isMultiGrid;
    let oldContentType = properties.contenttype;
    let nodes = [];
    let hasLogo = true;
    // let isSecondaryEnable = hasProperties && outlineData?.properties?.hasOwnProperty("secondarytext") ? outlineData?.properties?.secondarytext : false;
    // let isSecondaryEnable = false;
    if (outlineData && outlineData.matrix && outlineData.matrix.length > 0) {
        for (let i = 0; i < outlineData.matrix.length; i++) {
            let rowData = outlineData.matrix[i];
            // For Comparision diagram data parsing
            if (rowData.header) {
                rowData.matrix = [...rowData.header, ...rowData.matrix];
            }
            let multiTextObj = this.getHolderObj(data.supportedNodes, "multiTextNode");
            if (!multiTextObj) {
                let cellDataMulti = rowData && rowData.matrix[0];
                if (cellDataMulti && cellDataMulti.multitextdata) {
                    outlineData.matrix = DiagramUtils.quillToOutlineParser(rowData.matrix);
                    rowData = outlineData.matrix[i];
                    // console.log("Quill to normal node parser here....------");
                }
            } else {
                let cellDataMulti = rowData && rowData.matrix[0];
                if ((!cellDataMulti || !cellDataMulti.multitextdata) && i == 0) {
                    rowData.matrix = DiagramUtils.outlineToQuillParser(outlineData.matrix);
                    // console.log("Normal to Quill node parser here....------");
                }
            }
            let contentUpdate = true;
            let contentAdded = false;
            if (contentOptionNode && outlinetype == "image" && outlineData.outlinetype && outlineData.outlinetype != "list" && outlineData.outlinetype != "bulleted") {
                properties.contenttype = outlineData.outlinetype;
                outlinetype = outlineData.outlinetype;
            }
            if (!contentOptionNode && outlinetype == "image" && DiagramUtils.isLogoAsset(data.name)) {
                outlinetype = "logo";
            }
            if (properties.contenttype == "bulletlist" || properties.contenttype == "checklist") outlinetype = properties.contenttype;
            // if (data.classname == "SimpleNonLinearDiagram") outlinetype = hasProperties && outlineData && outlineData.subtype ? outlineData.subtype : outlinetype;
            DiagramNodeUtils.updateNodeType(outlinetype, properties, data.classname == "SvgScale9BgList");

            let content = DiagramNodeUtils.diagramContentData(data.name.includes("-ckd-") ? "checklist" : properties.contenttype, this.appStaticURL, this.arrDefaults, i);
            let defaultContent = null;
            if (this.arrDefaults && this.arrDefaults.content) {
                defaultContent = this.arrDefaults.content[i];
            }

            let node = DiagramNodeUtils.generateDefaultNodeData(rowData, content, this.arrDefaults, data.name, i);
            // Parse chart data to digram data for microchart.
            if (outlineData?.outlinetype && outlineData?.outlinetype?.includes("chart") && rowData && rowData.matrix && rowData.matrix.length > 0) {
                const firstValueObject = rowData.matrix.findLast((obj) => obj?.data?.id?.includes("value"));
                const labelObjects = rowData.matrix.filter((obj) => obj?.data?.id?.includes("label"));

                let arrParsed = firstValueObject ? [firstValueObject, ...labelObjects] : [...labelObjects];
                if (arrParsed.length > 0) {
                    let hasContent = oldContentType == "none" || oldContentType == "sequence" ? false : DiagramNodeUtils.hasContentData(arrParsed[0], properties, outlineData);
                    if (!hasContent && firstValueObject) {
                        arrParsed.remove(firstValueObject);
                    }
                    if (arrParsed && arrParsed.length > 0) rowData.matrix = arrParsed;
                }
            }
            for (let j = 0; j < rowData.matrix.length; j++) {
                let cellData = rowData.matrix[j];
                node.multitextdata = rowData.matrix;
                hasContent = oldContentType == "none" || oldContentType == "sequence" ? false : DiagramNodeUtils.hasContentData(cellData, properties, outlineData);
                if (cellData.isbgimage) {
                    node.bgimage = {
                        type: cellData.type,
                        value: cellData.value,
                        contenttype: cellData.type,
                        dataRef: cellData.dataRef,
                        id: cellData.dataRef ? cellData.dataRef.name : cellData.id || "",
                    };
                } else if (hasContent && contentUpdate) {
                    contentUpdate = false;
                    contentAdded = true;
                    // content = DiagramCreateUtil.checkDefaultData(this.diagramParent, cellData, properties.contenttype, this.appStaticURL);
                    if (defaultContent && cellData.contenttype != defaultContent?.contenttype && defaultContent?.value != "") {
                        node.content = defaultContent;
                    } else {
                        node.content = {
                            ...cellData,
                            type: cellData.type,
                            needAssetUpdate: cellData.needAssetUpdate || cellData.assetTextUpdate || false,
                            value: cellData.type == node?.content?.type ? cellData.value : node?.content.value,
                            // contenttype: this.isNonLinearAsset() ? properties.contenttype : cellData.contenttype || node?.content?.contenttype || cellData.type,
                            contenttype: cellData.contenttype || node?.content?.contenttype || cellData.type,
                            dataRef: cellData.dataRef,
                            id: cellData.dataRef ? cellData.dataRef.name : cellData.id || "",
                        };
                        if (data?.name?.includes("team") && (!node?.content?.value || node?.content?.value == "")) {
                            node.content.value = this.arrDefaults?.team?.[i]?.value;
                        }
                        // Reset Image Edit data on explorestyles
                        if (node.content?.contenttype == "image" && node.content?.dataRef) {
                            if (node.content.dataRef.cropData) node.content.dataRef.cropData = "";
                            if (node.content.dataRef.cropStyle) node.content.dataRef.cropStyle = "";
                        }
                        // set Placeholder for content where ai search is needed.
                        // if (node.content.needAssetUpdate) {
                        //     let objPlaceholder = DiagramNodeUtils.diagramContentData(node.content.contenttype, this.appStaticURL);
                        //     node.content.value = objPlaceholder.value;
                        // }
                        if (cellData.logodata) node.content.logodata = cellData.logodata;
                        if (cellData.assetText) node.content.assetText = cellData.assetText;
                    }
                    if (content.contenttype != cellData.type && rowData.secondary) {
                        let matchedContent = rowData.secondary.find((obj) => obj.contenttype && obj.contenttype == content.contenttype);
                        if (matchedContent) node.content = matchedContent;
                    }

                    if (cellData.type == "icon" && cellData.dataRef) {
                        window.arrIconAssets[cellData.dataRef.name] = cellData.value;
                    }

                    properties.diagramcontent = properties && properties.hasOwnProperty("diagramcontent") ? properties.diagramcontent : true;
                    if (outlinetype == "icon" || outlinetype == "valued" || outlinetype == "image") properties.diagramcontent = true;
                    hasLogo = hasLogo ? cellData.aiType == "companies" || cellData.aiType == "countries" || properties.contenttype == "logo" : false;
                } else if (((j == 0 && !contentAdded) || (contentAdded && j == 1)) && cellData.type != "checked" && cellData.type == "text") {
                    if (titleHolder) node.primarytext = { type: cellData.type, value: cellData.value, textproperties: DiagramUtils.checkOldTextProperties(cellData, properties, "primaryText") };
                    else {
                        node.secondarytext.textproperties = DiagramUtils.checkOldTextProperties(cellData, properties, "secondaryText");
                        // isSecondaryEnable = outlineData?.properties?.secondarytext === false ? false : true;
                        node.secondarytext.items.push({ type: cellData.type, value: cellData.value, index: cellData.index, content: cellData.content });
                    }
                } else if (((j > 0 && !hasContent) || (hasContent && j > 1)) && cellData.type != "checked" && cellData.type == "text") {
                    node.secondarytext.textproperties = cellData.textproperties;
                    // isSecondaryEnable = outlineData?.properties?.secondarytext === false ? false : true;
                    node.secondarytext.items.push({ type: cellData.type, value: cellData.value, index: cellData.index, content: cellData.content });
                }
                if (cellData.type == "checked") contentAdded = true;
            }
            if (rowData.button && rowData.button.value && rowData.button.value != "" && rowData.isFromSingleNode) {
                properties.button = true;
            } else {
                properties.button = data.name.includes("-sec-btn");
            }
            if (rowData?.author?.description && node.secondarytext.items.length == 0) {
                node.secondarytext = rowData.author.description;
            }
            // if (!properties.secondarytype || properties?.secondarytype == "none") {
            //     node.secondarytext.sublist = "none";
            // }
            if (node.secondarytext.items.length == 0) {
                node.secondarytext.items.push({ type: "text", value: "", index: 0 });
                // properties.secondarytext = false;
            } else if (node.secondarytext.items.length > 1 && data.isFromAI && (!node.secondarytext.sublist || node.secondarytext.sublist == "none") && (!properties.secondarytype || properties.secondarytype == "none") && !disableBulletPoints) {
                node.secondarytext.sublist = "disc";
            }
            nodes.push(node);
            if (this.arrDiagramNode && this.arrDiagramNode[i]) this.arrDiagramNode[i].objData = node;
        }
    }
    if (seperator?.connector?.connectorrestrict) {
        // properties.floateroptionsdisable = properties.floateroptionsdisable || [];
        let connectorrestrict = data?.connector?.connectorrestrict ? data?.connector?.connectorrestrict : seperator?.connector?.connectorrestrict;
        data.floateroptionsdisable = [...(data.floateroptionsdisable || []), ...connectorrestrict];
        // data.floateroptionsdisable = properties.floateroptionsdisable;
    }
    // properties.secondarytext = isSecondaryEnable;
    // properties.diagramcontent = data && data.textOnly ? false : outlinetype == "bulleted" || (data.classname != "SvgScale9BgList" && outlinetype == "numbered") ? false : properties.diagramcontent;
    // properties.diagramcontent = data && data.textOnly ? false : outlinetype == "bulleted" ? false : properties.diagramcontent;
    properties.contenttype = hasLogo && hasContent ? "logo" : properties.contenttype;
    let isSeqDisable = data.floateroptionsdisable && data.floateroptionsdisable.includes("sequencetext");
    // properties.sequencetext = outlinetype == "numbered" || outlinetype == "sequence" || ((properties.sequencetext || outlineData.subtype == "numbered") && !isSeqDisable && !properties.diagramcontent);
    properties.sequencetext = outlinetype == "numbered" || outlinetype == "sequence" || ((contentOptionNode ? false : properties.sequencetext || outlineData.subtype == "numbered") && !isSeqDisable);
    properties.secondaryplaceholder = data?.name?.includes("-sec-") ? (enableIcon ? "-sec-ic" : enableValue ? "-sec-val" : enableImage ? "-sec-img" : enableLogoList ? "-sec-lgrd" : enableLogo ? "-sec-lg" : null) : null;
    properties.enablesecplaceholder = data?.name?.includes("-sec-") ? (enableIcon ? enableIcon : enableImage && !disableImage ? enableImage : enableLogoList ? enableLogoList : enableLogo ? enableLogo : enableValue ? enableValue : false) : false;
    this.diagramData = { properties: properties, nodes: nodes, diagramtitle: outlineData.diagramtitle };
    this.centerholderdata = outlineData.centerholderdata;
    this.projectiondata = outlineData.projectiondata;
    this.startenddata = outlineData.startenddata;
    this.updateProperties(properties);
    window.ismoodchange = false;
};

LinearDiagram.prototype.addListener = function (event, callback) {
    this.eventManagerXY.addListener(event, callback);
};

LinearDiagram.prototype.removeListener = function (event, callback) {
    this.eventManagerXY.removeListener(event, callback);
};

LinearDiagram.prototype.diagramRenderComplete = function (isResetLayout = true) {
    this.diagramParent.style.opacity = 1;
    try {
        if (this.appmode.toLowerCase() != "present") {
            // this.updateTextNodes();
            this.resetImageLogoFrames();
            // this.updatePropsCallBack();
        }
    } catch (error) {
        console.log("Error in diagramRenderComplete..", error);
    }
    if (this.completeCallBack && this.completeCallBack.func) {
        this.completeCallBack.func(this.completeCallBack.params);
        // console.log("diagramRenderComplete callback..", this.completeCallBack.params);
    }
    this.updateEvents();
    this.setNodeCount();
};

LinearDiagram.prototype.imageDoubleClickHandler = function (event) {
    let target = event.currentTarget.dataset?.focusParent?.includes("center") ? this.diagramParent.querySelector(`[data-id='${event.currentTarget.dataset.focusParent}']`) : event.currentTarget;
    if (!target) target = event.currentTarget;
    this.eventManagerXY.dispatch("dblclick", target.id, target.dataset.contentType);
};

LinearDiagram.prototype.slideDimensionChange = function () {
    let svgPattern = this.diagramParent.querySelector("svg[class='fullBackgroundSVG']");
    if (svgPattern && svgPattern.parentElement) {
        svgPattern.parentElement.innerHTML = svgPattern.cloneNode(true).outerHTML;
    }
    this.updateMoodProperties();
};

LinearDiagram.prototype.updateNodeData = function (nodeData, type, index, parentId, enableSave) {
    if (this.isCustomSecondaryType(parentId)) {
        let iconListHolder = this.diagramParent.querySelector("[id='" + parentId + "']");
        if (iconListHolder) {
            index = iconListHolder.getAttribute("data-index");
            this.arrDiagramNode[index].updateContentData(nodeData, type, parentId, enableSave);
        }
    } else if (this.arrDiagramNode && this.arrDiagramNode.length > index) {
        this.arrDiagramNode[index].updateContentData(nodeData, type, parentId, enableSave);
    } else if (this.isQuillAsset(parentId)) {
        this.arrDiagramNode[0]?.updateContentData?.(nodeData, type, parentId);
    }
};

LinearDiagram.prototype.isCustomSecondaryType = function (parentId) {
    if (!parentId) return false;
    return parentId.includes("iconListHolder") || parentId.includes("imageListHolder") || parentId.includes("logoListHolder") || parentId.includes("valueListHolder");
};

LinearDiagram.prototype.isQuillAsset = function (parentId) {
    if (!parentId) return false;
    let iconListHolder = this.diagramParent.querySelector("[id='" + parentId + "']");
    return iconListHolder && iconListHolder.parentElement?.classList.contains("ql-ui");
};

LinearDiagram.prototype.getCustomProperties = function () {};

LinearDiagram.prototype.getDiagramLayoutProperties = function () {};

LinearDiagram.prototype.setIconSize = function () {};

LinearDiagram.prototype.checkGreyscaleVisiblily = function () {
    let isVisible = this.diagramData.properties.greyscale;
    if (isVisible) this.diagramParent.classList.add("clsLogoGreyscaleParent");
    else this.diagramParent.classList.remove("clsLogoGreyscaleParent");
};

LinearDiagram.prototype.logoGreyScale = function (isVisible, updateCallBack = true) {
    if (isVisible) {
        this.diagramParent.classList.add("clsLogoGreyscaleParent");
        this.diagramData.properties.greyscale = true;
    } else {
        this.diagramParent.classList.remove("clsLogoGreyscaleParent");
        this.diagramData.properties.greyscale = false;
    }
    this.updateProperties(this.diagramData.properties);
    // if (updateCallBack) {
    //     this.updatePropsCallBack();
    // }
};

LinearDiagram.prototype.allowContentResize = function (previousSize, presentSize, nodeInstance) {
    //check empty space and restrict content size
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    if (nodesHolder) {
        let nodesHolderStyle = getComputedStyle(nodesHolder);
        let nodeGroupHeight = nodesHolderStyle.getPropertyValue("--nodeGroupHeight").trim();
        let diagramParentStyle = getComputedStyle(this.diagramParent);
        let originalResizeHeight = diagramParentStyle.getPropertyValue("--originalresizeheight").trim();
        let previoussize = diagramParentStyle.getPropertyValue("--resizeValue").trim();
        let presentsize = diagramParentStyle.getPropertyValue("--" + presentSize + "Size").trim();
        let diagramParentHeight = this.diagramParent.clientHeight;
        if (nodeGroupHeight) {
            let contentSizePrevious = parseFloat(originalResizeHeight) * parseFloat(previoussize);
            let contentSizePresent = parseFloat(originalResizeHeight) * parseFloat(presentsize);
            let textNodesHeight = parseFloat(nodeGroupHeight) - contentSizePrevious;
            let presentGroupHeight = textNodesHeight + contentSizePresent;
            if (presentGroupHeight > diagramParentHeight) {
                return false;
            }
            let originalResizeWidth = nodesHolderStyle?.getPropertyValue("--originalresizewidth").trim();
            let nodeWidth = nodeInstance?.parentNode?.clientWidth;
            // let contentWidthPrevious = parseFloat(originalResizeWidth) * parseFloat(previoussize);
            let contentWidthPresent = parseFloat(originalResizeWidth) * parseFloat(presentsize);
            if (nodeWidth && contentWidthPresent > nodeWidth) {
                return false;
            }
        }
    }
    return true;
};

LinearDiagram.prototype.changeNumberSize = function (value, updateCallBack = true) {
    if (!value || this.diagramData.properties.contenttype != "number") return;
    let enableSML = DiagramUtils.checkSMLEnable(this.nodeProps.supportedNodes, "valueTitleHolder");
    if (!enableSML) return;
    let oldResizeValue = getComputedStyle(this.diagramParent).getPropertyValue("--resizeValue");
    let oldValue = DiagramUtils.getSMLSizeFromValue(oldResizeValue, this.arrSMLSize);
    let restrictLogoSize = this.diagramData && this.diagramData.properties && this.diagramData.properties.floateroptionsdisable && this.diagramData.properties.floateroptionsdisable.includes("numbersize");
    if (restrictLogoSize) return;
    this.diagramParent.firstElementChild.style.setProperty("--contentWidthMin", "100%");
    this.diagramParent.setAttribute("data-resizenumber", "true");
    this.diagramData.properties.numbersize = value;
    this.diagramParent.style.setProperty("--resizeValue", "var(--" + value + "Size)");
    this.updateProperties(this.diagramData.properties);
    let isRestrict = this.checkSMLOverflow(value == "auto" ? "auto" : oldValue);
    if (isRestrict && value != "auto") {
        if (updateCallBack) {
            this.showAlertEvent?.("Unable to change the size!, The size exceeds container...");
            this.diagramParent.style.setProperty("--contentResizeMH", "calc(var(--originalresizeheight) * var(--" + oldValue + "Size))");
            this.diagramParent.style.setProperty("--resizeValue", "var(--" + oldValue + "Size)");
            this.diagramParent.style.setProperty("--minContentSize", "var(--" + oldValue + "Size)");
        }
    } else if (updateCallBack) {
        this.resetInlineSize();
        this.resetLayout();
        // this.updatePropsCallBack();
    }
    this.diagramParent.firstElementChild.style.setProperty("--contentWidthMin", "auto");
    // setTimeout(() => {
    //     let numberNode = this.diagramParent.querySelector("[data-type='numberNode']");
    //     if (numberNode) {
    //         let lineHeight = getComputedStyle(numberNode)["lineHeight"];
    //         this.diagramParent.style.setProperty("--resizeheightsize", lineHeight);
    //     }
    // }, 0);
};

LinearDiagram.prototype.changeImageSize = function (value, updateCallBack = true) {
    let enableSML = DiagramUtils.checkSMLEnable(this.nodeProps.supportedNodes, "imageHolder");
    if (!enableSML || this.nodeProps.parentStyle.includes("clsresponsiveimage")) return;
    this.changeSize(value, "image", updateCallBack);
};

LinearDiagram.prototype.changeLogoSize = function (value, updateCallBack = true) {
    let enableSML = DiagramUtils.checkSMLEnable(this.nodeProps.supportedNodes, "imageSecHolder");
    if (!enableSML) return;
    this.changeSize(value, "logo", updateCallBack);
};

LinearDiagram.prototype.changeIconSize = function (value, updateCallBack = true) {
    let enableSML = DiagramUtils.checkSMLEnable(this.nodeProps.supportedNodes, "iconHolder");
    if (!enableSML) return;
    this.changeSize(value, "icon", updateCallBack);
};

LinearDiagram.prototype.changeMicroChartSize = function (value, updateCallBack = true) {
    let enableSML = DiagramUtils.checkSMLEnable(this.nodeProps.supportedNodes, "microChartHolder");
    if (!enableSML) return;
    this.changeSize(value, "microchart", updateCallBack, "number");
};

LinearDiagram.prototype.changeSize = function (value, type, updateCallBack = true, contenttype = null) {
    if (!value || this.diagramData.properties.contenttype != (contenttype ? contenttype : type)) return;
    let restrictIconSize = this.diagramData && this.diagramData.properties && this.diagramData.properties.floateroptionsdisable && this.diagramData.properties.floateroptionsdisable.includes(type + "size");
    if (restrictIconSize) return;
    let holderDiv = this.diagramParent.querySelector("[data-holder-type='primary'][data-content-type='" + type + "']");
    if (!holderDiv) return;

    let oldResizeValue = getComputedStyle(this.diagramParent).getPropertyValue("--resizeValue");
    let oldValue = DiagramUtils.getSMLSizeFromValue(oldResizeValue, this.arrSMLSize);
    value = DiagramUtils.checkSMLSizeFromFloater(value, this.diagramData.properties.floateroptionsdisable, this.arrSMLSize);
    DiagramUtils.setAutoSizeValue(this.diagramData.properties.floateroptionsdisable, this.arrSMLSize, this.diagramParent);
    let resizeDimension = "originalresizeheight";
    this.diagramParent.style.setProperty("--contentResizeMH", "calc(var(--" + resizeDimension + ") * var(--" + value + "Size))");
    this.diagramParent.style.setProperty("--resizeValue", "var(--" + value + "Size)");
    this.diagramParent.style.setProperty("--minContentSize", "var(--" + value + "Size)");
    this.diagramParent.setAttribute("data-resize" + type, "true");
    this.diagramParent.setAttribute("data-sizeOveride", "false");
    this.diagramData.properties[type + "size"] = value;
    this.updateProperties(this.diagramData.properties);
    let isRestrict = this.checkSMLOverflow(value == "auto" ? "auto" : oldValue);
    this.resetInlineSize();
    if (isRestrict && value != "auto") {
        if (updateCallBack) {
            this.showAlertEvent?.("Unable to change the size!, The size exceeds container...");
            this.diagramParent.style.setProperty("--contentResizeMH", "calc(var(--" + resizeDimension + ") * var(--" + oldValue + "Size))");
            this.diagramParent.style.setProperty("--resizeValue", "var(--" + oldValue + "Size)");
            this.diagramParent.style.setProperty("--minContentSize", "var(--" + oldValue + "Size)");
        }
    } else if (updateCallBack) {
        this.resetLayout();
        // this.updatePropsCallBack();
    }
};

LinearDiagram.prototype.changeInlineSize = function (objSize) {
    let value = objSize.data;
    let type = objSize.objDetails.contenttype;
    let target = this.diagramParent.querySelector("[id='" + objSize.targetid + "']");
    let nodeInstance = this.arrDiagramNode[target.dataset.index];
    if (!value || this.diagramData.properties.contenttype != type) return;
    let restrictIconSize = this.diagramData && this.diagramData.properties && this.diagramData.properties.floateroptionsdisable && this.diagramData.properties.floateroptionsdisable.includes(type + "size");
    if (restrictIconSize) return;
    this.diagramParent.setAttribute("data-sizeOveride", "true");
    if (!this.allowContentResize(this.diagramData.properties[type + "size"], value, nodeInstance)) {
        this.showAlertEvent?.("Unable to change the size!, The size exceeds container...");
        return;
    }
    nodeInstance.objData.nodeproperties.size = value;
    nodeInstance.updateNodeProperties(nodeInstance.objData.nodeproperties);
    this.setInlineMinSize(type);
    this.resetLayout();
    // this.updatePropsCallBack();
};

LinearDiagram.prototype.reApplyInlineSize = function () {
    let type = this.diagramData.properties.contenttype;
    let restrictIconSize = this.diagramData && this.diagramData.properties && this.diagramData.properties.floateroptionsdisable && this.diagramData.properties.floateroptionsdisable.includes(type + "size");
    if (restrictIconSize) return;
    this.setInlineMinSize(type);
};

LinearDiagram.prototype.setInlineMinSize = function (type) {
    if (this.diagramParent?.dataset?.name?.includes("-mc-")) return;
    let diagramStyle = getComputedStyle(this.diagramParent);
    let maxSize = 0;
    this.arrDiagramNode.forEach((node) => {
        if (node?.objData?.nodeproperties?.size && node?.objData?.nodeproperties?.size != "") {
            let value = node.objData.nodeproperties.size;
            maxSize = Math.max(parseFloat(diagramStyle.getPropertyValue("--" + value + "Size")), maxSize);
            node.parentNode.style.setProperty("--contentResizeMH", "calc(var(--originalresizeheight) * var(--" + value + "Size))");
            node.parentNode.style.setProperty("--resizeValue", "var(--" + value + "Size)");
        }
        // else maxSize = Math.max(parseFloat(diagramStyle.getPropertyValue("--" + this.diagramData.properties[type + "size"] + "Size")), maxSize);
    });
    if (maxSize > 0) this.diagramParent.style.setProperty("--minContentSize", maxSize);
    // console.log("max size : " + maxSize);
};

LinearDiagram.prototype.resetInlineSize = function () {
    this.arrDiagramNode.forEach((node) => {
        node.objData.nodeproperties.size = "";
        node.updateNodeProperties(node.objData.nodeproperties);
        node.parentNode.style.removeProperty("--contentResizeMH");
        node.parentNode.style.removeProperty("--resizeValue");
        node.parentNode.style.removeProperty("--minContentSize");
    });
};

LinearDiagram.prototype.changeValueFormat = function (objValue, isFromUndo = false) {
    let value = objValue.value;
    let arrValueNew = objValue.arrValueNew;
    this.diagramData.properties.valueformat = value;
    this.updateProperties(this.diagramData.properties);
    let arrNumberNodes = this.diagramParent.querySelectorAll("[name='numberNode']");
    arrNumberNodes.forEach((element, index) => {
        if (arrValueNew && arrValueNew.length > 0) {
            element.innerHTML = arrValueNew[index];
        }
        if (!isFromUndo) DiagramNodeUtils.checkNumberFormat(element, this.diagramParent, this.globalMoodData, this.nodeProps, true);
    });
    this.resetLayout();
};

LinearDiagram.prototype.resizeValueText = function (oldValue) {
    let arrValueText = this.diagramParent.querySelectorAll("[name='numberNode']");
    let maxScrollWidth = 0;
    let valueText = arrValueText[0];
    if (!valueText) return false;
    arrValueText.forEach((element) => {
        element.parentElement.style.setProperty("width", "fit-content");
        if (element.scrollWidth > maxScrollWidth) {
            valueText = element;
        }
        maxScrollWidth = Math.max(maxScrollWidth, element.scrollWidth);
    });
    let content = valueText.parentElement.parentElement;
    let computedStyleContent = window.getComputedStyle(content);
    let paddingLeft = parseInt(computedStyleContent.paddingLeft);
    let paddingRight = parseInt(computedStyleContent.paddingRight);
    let paddingTop = parseInt(computedStyleContent.paddingTop);
    let paddingBottom = parseInt(computedStyleContent.paddingBottom);
    let finalWidth = content.clientWidth - paddingLeft - paddingRight;
    let finalHeight = content.clientHeight - paddingTop - paddingBottom;
    function performResizeValueText() {
        if (valueText && maxScrollWidth > parseInt(finalWidth)) {
            this.diagramData.properties[this.diagramData.properties.contenttype + "size"] = oldValue;
            this.updateProperties(this.diagramData.properties);
            this.updatePropsCallBack(valueText.id);
            let arrSize = Object.keys(this.arrSMLSize).reverse();
            for (const key in arrSize) {
                DiagramUtils.updateResize(this.diagramParent, arrSize[key], this.nodeProps, this.diagramData.properties);
                if (valueText.scrollWidth < parseInt(finalWidth)) {
                    return true;
                }
            }
            return true;
        }
        if (valueText && maxScrollWidth < parseInt(finalWidth) && this.diagramData.properties[this.diagramData.properties.contenttype + "size"] == "auto") {
            this.diagramData.properties[this.diagramData.properties.contenttype + "size"] = oldValue;
            this.updateProperties(this.diagramData.properties);
            this.updatePropsCallBack(valueText.id);
            let arrSize = Object.keys(this.arrSMLSize).reverse();
            for (const key in arrSize) {
                DiagramUtils.updateResize(this.diagramParent, arrSize[key], this.nodeProps, this.diagramData.properties);
                if (valueText.scrollWidth < parseInt(finalWidth)) {
                    return true;
                }
            }
            return true;
        }
    }
    let returnResize = performResizeValueText.bind(this)();
    arrValueText.forEach((element) => {
        element.parentElement.style.removeProperty("width");
    });
    return returnResize;
};

LinearDiagram.prototype.showHideOverlay = function (obj) {
    this.diagramData.properties.isoverlay = obj.value;
    this.updateProperties(this.diagramData.properties);
};

LinearDiagram.prototype.showHideContent = function () {
    let previousState = getComputedStyle(this.diagramParent.parentElement).getPropertyValue("--contentdisplay").trim();
    let visible = previousState != "none";
    this.diagramParent.parentElement.style.setProperty("--contentdisplay", visible ? "none" : "block");
    this.diagramParent.setAttribute("data-content", !visible);
    this.diagramData.properties.diagramcontent = !visible;
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

LinearDiagram.prototype.showHideNumber = function (value) {
    let previousState = getComputedStyle(this.diagramParent.parentElement).getPropertyValue("--numberdisplay").trim();
    let visible = previousState == "flex";
    this.diagramParent.parentElement.style.setProperty("--numberdisplay", visible ? "none" : "flex");
    this.diagramData.properties.sequencetext = !visible;
    // let contentType = this.diagramData.properties.contenttype;
    // let size = this.diagramData.properties[contentType + "size"];
    // if (value) {
    //     if (size && (size == "tiny" || size == "small")) {
    //         this.diagramData.properties[contentType + "size"] = "medium";
    //         this.changeSize("medium", contentType, true);
    //     }
    // }
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "sequence", this.diagramData.properties.sequencetext, true);
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

LinearDiagram.prototype.showHideSecondary = function (value) {
    this.diagramData.properties.secondarytext = value;
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "secondary", value, true);
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

LinearDiagram.prototype.showHidePrimary = function (value) {
    this.diagramData.properties.primarytext = value;
    // this.diagramParent.parentElement.style.setProperty("--primarytextdisplay", value ? "flex" : "none");
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "primary", value, true);
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

LinearDiagram.prototype.showHideDiagramTitle = function (value) {
    this.diagramData.properties.diagramtitle = value;
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "diagramtitle", value, true);
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

LinearDiagram.prototype.showHideSecondaryPlaceholder = function (value) {
    this.diagramData.properties.secondaryplaceholder = value;
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

LinearDiagram.prototype.showHideSecondaryPlaceholderSwitch = function (value) {
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, this.diagramData.properties.secondaryplaceholder, value, true);
    if (value) this.showHideButton(false);
    this.diagramData.properties.enablesecplaceholder = value;
    this.updateProperties(this.diagramData.properties);
    // this.updatePropsCallBack();
    this.resetLayout();
};

LinearDiagram.prototype.showHideButton = function (value) {
    // DiagramUtils.toggleSecondaryPlaceholders(this.diagramData.properties,"button",value)
    // this.diagramData.properties.button = value;
    DiagramUtils.toggleSecondaryPlaceholders(this.diagramData.properties, "button", value);
    // this.diagramData.properties.button = value;
    this.updateProperties(this.diagramData.properties);
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "button", value);
    // if (value) this.showHideSecondaryPlaceholderSwitch(false);
    this.resetLayout();
};

LinearDiagram.prototype.showHideMicroChart = function (value) {
    this.diagramData.properties.microchart = value;
    this.updateProperties(this.diagramData.properties);
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "microchart", value);
    this.resetLayout();
};

LinearDiagram.prototype.showHideLabel = function (value) {
    this.diagramData.properties.label = value;
    this.diagramParent.parentElement.style.setProperty("--textlabeldisplay", value ? "flex" : "none");
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "label", value, true);
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

LinearDiagram.prototype.showHideSubtext = function (value) {
    this.diagramData.properties.subtext = value;
    this.diagramParent.parentElement.style.setProperty("--subtextdisplay", value ? "flex" : "none");
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "subtext", value, true);
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

LinearDiagram.prototype.showHideQuote = function (value) {
    this.diagramData.properties.quote = value;
    // this.diagramParent.parentElement.style.setProperty("--subtextdisplay", value ? "flex" : "none");
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "quote", value, true);
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

LinearDiagram.prototype.showHideAuthorStyleName = function (value) {
    this.diagramData.properties.authorname = value;
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "authorname", value, true);
    // DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "authorimage", "authorimage", true);
    this.diagramParent.parentElement.style.setProperty("--authorstylenamedisplay", value ? "flex" : "none");
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

LinearDiagram.prototype.showHideAuthorStyleDes = function (value) {
    this.diagramData.properties.authordes = value;
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "authordes", value, true);
    this.diagramParent.parentElement.style.setProperty("--authorstyledesdisplay", value ? "flex" : "none");
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

LinearDiagram.prototype.showHideAuthorStyleImage = function (value) {
    this.diagramData.properties.authorimage = value;
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "authorimage", value, true);
    this.diagramParent.parentElement.style.setProperty("--authorstyleimagedisplay", value ? "flex" : "none");
    this.updateProperties(this.diagramData.properties);
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "authorimage", value);
    this.resetLayout();
};

LinearDiagram.prototype.changeNumberStart = function (value) {
    this.diagramData.properties.sequencetextstart = value;
    this.updateProperties(this.diagramData.properties);
    this.resetNodeAttributes();
};

LinearDiagram.prototype.changeNumberReverse = function (value) {
    this.diagramData.properties.sequencetextreverse = value;
    this.updateProperties(this.diagramData.properties);
    this.resetNodeAttributes();
};

LinearDiagram.prototype.checkItemVisiblily = function () {
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "textLabelHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "label", "label", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "iconHolder") && this.diagramData?.properties?.name?.includes("qt")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "quote", "quote", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "titleHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "primarytext", "primary", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "subTitleHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "secondarytext", "secondary", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "seqTitleHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "sequencetext", "sequence", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "subtextHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "subtext", "subtext", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "buttonTitleHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "button", "button", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "authorImageHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "authorimage", "authorimage", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "authorNameHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "authorname", "authorname", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "authorDesHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "authordes", "authordes", true);
    if (DiagramUtils.checkFloaterOption("seperatorline", this.diagramData.properties.floateroptionsdisable)) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "seperatorline", "seperatorline", true);
    if (DiagramUtils.checkFloaterOption("connector", this.diagramData.properties.floateroptionsdisable)) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "hasconnector", "connector", true);
    if (DiagramUtils.checkFloaterOption("connectortext", this.diagramData.properties.floateroptionsdisable)) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "connectortext", "connectortext", true);
    let diagramTitleSupport = DiagramUtils.isDiagramTitleSupported(this.diagramParent.dataset.classname, this.nodeProps.nodeclassName, this.diagramData.properties.floateroptionsdisable);
    if (diagramTitleSupport) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "diagramtitle", "diagramtitle", true);
};

LinearDiagram.prototype.checkMicroChartVisible = function () {
    let microChart = this.diagramParent.querySelector("[name='microChartHolder'][data-holder-type='secondary']");
    if (microChart) {
        DiagramUtils.setEnableDisableClassNames(this.diagramParent, "microchart", this.diagramData.properties.microchart);
    } else this.diagramParent.classList.remove("clsmicrochartdisable");
};

LinearDiagram.prototype.resetLayout = function () {
    // let dateNow = new Date().getTime();
    // console.log("Reset Layout Start - " + (new Date().getTime() - dateNow));
    //  console.log("Reset Layout Mid - " + (new Date().getTime() - dateNow));
    this.updateCssAttributes();
    this.resetHolderWidth();
    // this.resetNodeAttributes();
    // this.updateTextNodes();
    //  console.log("Reset Layout End - " + (new Date().getTime() - dateNow));
};

LinearDiagram.prototype.nodeStyleChange = function (index) {
    let nodeInstance = this.arrDiagramNode[index];
    let supportedNodes = [{ name: "contentNode", subNodes: [{ name: "imageHolder", holdertype: "primary" }] }, { name: "titleHolder" }, { name: "subTitleHolder" }];
    let parentStyle = "clsDynamicImage clsLeftAlignment";
    nodeInstance.parentStyle = parentStyle;
    nodeInstance.arrSupportedNodes = supportedNodes;
    let mainParent = nodeInstance.nodeGroup.parentElement.parentElement;
    mainParent.remove();
    nodeInstance.initCreation();
    this.updateEvents();
    this.resetNodeAttributes();
};

LinearDiagram.prototype.updateProperty = function (property, value) {
    if (property && property != "" && value != undefined && value != null) {
        this.diagramData.properties[property] = value;
        this.updateProperties(this.diagramData.properties);
    }
};

LinearDiagram.prototype.getOldPropertyValue = function (property, valueObj) {
    return DiagramUtils.getOldPropertyValue(property, valueObj, this.diagramParent, this);
};

LinearDiagram.prototype.setOperationProperty = function (property, valueObj, isFromUndo = false) {
    DiagramUtils.setOperationProperty(property, valueObj, valueObj.contentType == "BG_IMAGE" && this.bgDeviceDiv ? this.bgDeviceDiv : this.diagramParent, this, isFromUndo);
};

LinearDiagram.prototype.resetNodeAttributes = function () {
    this.setNodeCount();
    this.updateTextNodes();
    if (this.diagramData?.properties?.seperatorline) {
        DiagramResizeUtils.resetRowColumnBounds(this.arrDiagramNode);
        DiagramResizeUtils.setArrRowColumnBounds(this.arrDiagramNode);
    }
    for (let i = 0; i < this.arrDiagramNode.length; i++) {
        if (this.globalMoodData) this.arrDiagramNode[i].globalMoodData = this.globalMoodData;
        if (this.arrTintArray) this.arrDiagramNode[i].arrTintArray = this.arrTintArray;
        this.arrDiagramNode[i].properties = this.diagramData.properties;
        this.arrDiagramNode[i].updateNodeAttributes(i, this.diagramRenderComplete);
        this.arrDiagramNode[i].updateImageLogoFrames();
        if (this.arrDiagramNode[i].parentNode && this.arrDiagramNode[i].parentNode.dataset.highlight == "true") this.setHighlightTargetPoints(this.arrDiagramNode[i].parentNode, this.diagramParent);
    }

    if (this.centerHolderNode) {
        this.centerHolderNode.updateNodeAttributes(0, this.diagramRenderComplete);
    }
};

LinearDiagram.prototype.checkAgendaOverflow = function (gap) {
    if (this.isTempSlide) return;
    if (this.nodeProps && this.nodeProps.nodealignment && this.nodeProps.nodealignment.includes("agenda")) {
        let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
        if (nodesHolder.clientWidth + gap * 2 < nodesHolder.scrollWidth) {
            this.showAlertEvent?.("Content has exceeded the available space. Please reduce the amount of content to fit all elements");
        }
    }
};

LinearDiagram.prototype.setNodeCount = function () {
    let nodeCount = this.diagramParent.dataset.nodecount ? this.diagramParent.dataset.nodecount : this.arrDiagramNode.length;
    if (this.arrDiagramNode && this.arrDiagramNode.length > 0) this.diagramParent.setAttribute("data-nodecount", this.arrDiagramNode.length);
    let minWidthHeight = this.nodeProps && this.nodeProps.minWidthHeight;
    if (minWidthHeight && !this.isTakeAway) {
        let type = this.diagramParent.dataset.graphiclayoutname || this.diagramParent.dataset.name.substr(0, this.diagramParent.dataset.name.indexOf("-"));
        if (typeof minWidthHeight == "string") minWidthHeight = JSON.parse(minWidthHeight);
        if (minWidthHeight[2] && minWidthHeight[2] == "type2") {
            this.diagramParent.style.minWidth = minWidthHeight[0] + "px";
            this.diagramParent.style.minHeight = minWidthHeight[1] + "px";
        } else {
            this.diagramParent.style.minWidth = (type == "hor" ? minWidthHeight[0] * nodeCount : minWidthHeight[0]) + "px";
            this.diagramParent.style.minHeight = (type == "ver" ? minWidthHeight[1] * nodeCount : minWidthHeight[1]) + "px";
        }
        if (minWidthHeight[3] && minWidthHeight[3] == "group") {
            let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
            // nodesHolder.style.setProperty("--nodeGroupHeight", minWidthHeight[1] + "px");
            nodesHolder.setAttribute("data-nodeGroupMinHeight", minWidthHeight[1]);
            nodesHolder.setAttribute("data-nodeGroupMinWidth", minWidthHeight[0]);
            nodesHolder.style.setProperty("--nodeGroupMinWidth", minWidthHeight[0] + "px");
        }
    }

    let nodeParent = this.arrDiagramNode[0]?.parentNode?.parentElement;
    if (nodeParent) {
        let nodeCalcHeight = nodeParent.clientHeight;
        let nodeCalcWidth = nodeParent.clientWidth;
        this.diagramParent.style.setProperty("--nodeCalcHeight", nodeCalcHeight + "px");
        this.diagramParent.style.setProperty("--nodeCalcWidth", nodeCalcWidth + "px");
    }
};

LinearDiagram.prototype.updateTextNodes = function (index) {
    this.arrDiagramNode?.[0]?.updateOnFocusOut();
    this.arrDiagramNode?.forEach((node) => {
        node?.setMaxHeightForLogoList?.();
    });
    DiagramCreateUtil.setDiagramTitleSingleLine(this.diagramParent);
};

LinearDiagram.prototype.lineHeightLetterSpacingChangeOperation = function (objData, targetNode) {
    this.updateTextNodes();
};

LinearDiagram.prototype.resetImageLogoFrames = function () {
    for (let i = 0; i < this.arrDiagramNode.length; i++) {
        this.arrDiagramNode[i].updateImageLogoFrames();
        this.arrDiagramNode[i].updateCheckListNode();
    }
    if (this.centerHolderNode) {
        this.centerHolderNode.updateImageLogoFrames();
    }
};

LinearDiagram.prototype.updateImageBounds = function (image, objData, scale) {
    CommonImageUtils.updateImageBounds(image, objData, scale);
};

LinearDiagram.prototype.deleteNode = function (targetIndex) {
    const jsonStr = this.nodeProps.supportedNodes ? JSON.stringify(this.nodeProps.supportedNodes) : "";
    if (jsonStr.includes("spriteHolder")) {
        this.deleteNodeRedraw(targetIndex);
        return;
    }
    let isConnectorDelete = targetIndex == this.arrDiagramNode.length - 1;
    if (this.arrDiagramNode.length > targetIndex) {
        this.arrDiagramNode.splice(targetIndex, 1);
        let nodeDelete = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + targetIndex + "']");
        if (nodeDelete && nodeDelete.parentElement) {
            // nodeDelete.parentElement.remove();
            nodeDelete.parentElement.parentElement.removeChild(nodeDelete.parentElement);
        }
    }
    if (this.diagramData.nodes.length > targetIndex) {
        this.diagramData.nodes.splice(targetIndex, 1);
    }
    this.diagramSpecificCalculation();
    DiagramNodeUtils.updateNodeSizeForClient(this.diagramData, this.diagramParent, this.nodeGap);
    let index = this.diagramParent.getAttribute("data-emphasis");
    if (index == targetIndex) this.hideEmpahsis();

    this.updateEmphasize();
    // this.resetNodeAttributes();
    this.resetHolderWidth();
    // setTimeout(() => {
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (targetIndex - 1) + "']");
    if (lastDiv && isConnectorDelete) {
        let lastConnector = lastDiv.parentElement.querySelector("[name='connectorparent']");
        if (lastConnector) lastConnector.remove();
        // this.updatePropsCallBack(lastDiv.id);
    }
    this.diagramRenderComplete();
    this.updateJSONData();
    // }, 100);
};

LinearDiagram.prototype.addNode = function (nodeData, index, isFromUndo = false) {
    this.eventManagerXY.clear();
    const jsonStr = this.nodeProps.supportedNodes ? JSON.stringify(this.nodeProps.supportedNodes) : "";
    if (jsonStr.includes("spriteHolder")) {
        this.addNodeRedraw(nodeData, index, isFromUndo);
        return;
    }
    let connectorAdd = index == this.arrDiagramNode.length;
    if (this.diagramData.nodes.length > index) {
        this.diagramData.nodes.splice(index, 0, nodeData);
    } else {
        this.diagramData.nodes.push(nodeData);
    }
    this.diagramParent.setAttribute("data-nodecount", this.diagramData.nodes.length);
    let lastNode = this.arrDiagramNode[this.arrDiagramNode.length - 1];
    if (lastNode && connectorAdd) lastNode.connectorNode = lastNode.createConnectorParent(lastNode.parentNode.parentElement, lastNode.objData.content);
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    let nodeItem = new window[this.nodeProps.nodeclassName](nodesHolder, this.diagramData.properties, nodeData, this.eventManagerXY, this.arrDiagramNode.length, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
    this.createNodeInstanceProperties(nodeItem);
    if (!isFromUndo) DiagramPropertyUtils.resetNodeProperties(nodeItem.objData);
    nodeItem.index = index;
    nodeItem.initCreation(this.isGridAsset(this.nodeProps.name) ? false : connectorAdd);
    if (this.arrDiagramNode.length > index) {
        this.arrDiagramNode.splice(index, 0, nodeItem);
    } else {
        this.arrDiagramNode.push(nodeItem);
    }

    this.diagramSpecificCalculation();
    DiagramNodeUtils.updateNodeSizeForClient(this.diagramData, this.diagramParent, this.nodeGap);
    this.updateEvents();
    this.updateEmphasize();
    this.updateSpecialOperations();
    this.resetHolderWidth();
    // this.resetNodeAttributes();
    this.updateJSONData();
    this.diagramRenderComplete();
    this.addFocus(index);
};

LinearDiagram.prototype.addNodeRedraw = function (nodeData, index) {
    if (this.diagramData.nodes.length > index) {
        this.diagramData.nodes.splice(index, 0, nodeData);
    } else {
        this.diagramData.nodes.push(nodeData);
    }
    this.initDiagramCreation();
};

LinearDiagram.prototype.deleteNodeRedraw = function (targetIndex) {
    if (this.arrDiagramNode.length > targetIndex) {
        this.arrDiagramNode.splice(targetIndex, 1);
        let nodeDelete = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + targetIndex + "']");
        if (nodeDelete && nodeDelete.parentElement) {
            nodeDelete.parentElement.remove();
        }
    }
    if (this.diagramData.nodes.length > targetIndex) {
        this.diagramData.nodes.splice(targetIndex, 1);
    }
    this.initDiagramCreation();
};

LinearDiagram.prototype.isNodeAddable = function () {
    let type1 = this.nodeProps.nodeclassName == "VerticalSplitColumnDiagramNode" || this.nodeProps.name.includes("ver-agenda");
    let type2 = this.nodeProps.nodealignment == "split";
    let type3 = this.nodeProps.nodealignment == "splitcenterfixed";

    if (type1 || type2 || type3) {
        // let maxColumns =  type1 ? 3 : 2;
        // let maxColumns = type3 ? 3 : 2;
        let maxColumns = 3;
        // let emptySpace = this.arrDiagramNode[this.arrDiagramNode.length - 1].calculateEmptySpace("primaryText" + (this.arrDiagramNode.length - 1));
        // let emptySpace = DiagramResizeUtils.calculateEmptySpace(this.diagramParent, this.nodeProps.name.includes("agenda") && !this.nodeProps.nodealignment.includes("agenda") ? 3 : 2);
        let emptySpace = DiagramResizeUtils.calculateEmptySpace(this.diagramParent, maxColumns);
        // if (emptySpace && emptySpace > 90) return true;
        let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
        let nodeHeight = this.diagramParent.querySelector("[id='nodeparent0']").parentElement.clientHeight;
        if (emptySpace && emptySpace > nodeHeight) return true;
        else {
            // alert("Unable to add Node!");
            return false;
        }
    } else return true;
};

LinearDiagram.prototype.updateSpecialOperations = function () {
    // this.diagramParent.setAttribute("data-sizeOveride", "true");
    this.logoGreyScale(this.diagramData.properties.greyscale, false);
    this.toggleVisibility();
    this.updateCssAttributes();
    // setTimeout(() => {
    this.changeLogoSize(this.diagramData.properties.logosize, false);
    this.changeImageSize(this.diagramData.properties.imagesize, false);
    this.changeNumberSize(this.diagramData.properties.numbersize, false);
    this.changeIconSize(this.diagramData.properties.iconsize, false);
    this.changeMicroChartSize(this.diagramData.properties.microchartsize, false);
    // }, 0);
    this.reApplyInlineSize();
};

LinearDiagram.prototype.toggleVisibility = function () {
    this.checkItemVisiblily();
    this.checkGreyscaleVisiblily();
    this.checkMicroChartVisible();
    this.checkConnectorVisible();
    this.checkConnectorTextVisible();
};

LinearDiagram.prototype.addFocus = function (index) {
    if (this.isTempSlide || this.isTakeAway) return;
    let primaryTextNode = this.diagramParent.querySelector("[data-id='primaryText'][data-index='" + index + "']");
    // if (primaryTextNode && this.appmode.toLowerCase() != "present") primaryTextNode.focus();
};

LinearDiagram.prototype.addNodesForDiagram = function (nodeData, index) {
    let lastNode = this.arrDiagramNode[this.arrDiagramNode.length - 1];
    if (lastNode && (lastNode.connector || lastNode.seperatorline)) lastNode.connectorNode = lastNode.createConnectorParent(lastNode.parentNode.parentElement, lastNode.objData.content);
    let firstNode = this.arrDiagramNode[0];
    let node = JSON.parse(JSON.stringify(firstNode.objData));
    DiagramPropertyUtils.resetNodeProperties(node);
    this.diagramData.nodes.push(node);
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    let nodeItem = new window[this.nodeProps.nodeclassName](nodesHolder, this.diagramData.properties, node, this.eventManagerXY, this.arrDiagramNode.length, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
    this.createNodeInstanceProperties(nodeItem);
    nodeItem.index = index;
    nodeItem.initCreation(true);
    this.arrDiagramNode.push(nodeItem);
};

LinearDiagram.prototype.updateEmphasize = function () {
    let index = this.diagramParent.getAttribute("data-emphasis");
    if (index) {
        this.hideEmpahsis();
        this.showEmpahsis(index);
    }
};

LinearDiagram.prototype.showEmpahsis = function (index) {
    this.diagramParent.setAttribute("data-emphasis", index);
    this.diagramParent.style.setProperty("--empha]sis-color", "var(--item" + (parseInt(index) + 1) + "-color)");
    this.diagramParent.style.setProperty("--gradient-emphasis-color", "linear-gradient(-45deg, rgba(var(--item" + (parseInt(index) + 1) + "-color-rgb), 1) 12%, rgba(var(--item" + (parseInt(index) + 2) + "-color-rgb), 1) 83%)");

    let nodeBorder = this.nodeProps.nodeBorder ? this.nodeProps.nodeBorder.split(",") : [];
    let arrNodeData = [];
    if (nodeBorder.length == 4) {
        const nodeData = nodeBorder[3].replace(/\s/g, "");
        arrNodeData = [nodeData];
        const hasMulti = nodeData.includes("[") && nodeData.includes("]");
        if (hasMulti) {
            arrNodeData = nodeData.replace("[", "").replace("]", "").split(":");
        }
    }
    if (this.nodeProps.emphasisShape) {
        let emphasisShape = this.nodeProps.emphasisShape;
        let iconHolder = this.diagramParent.querySelector("[id='iconHolder" + index + "']");
        let spriteHolder = this.diagramParent.querySelector("#spriteHolder" + index);
        if (iconHolder) {
            if (emphasisShape.sprite) {
                setTimeout(() => {
                    this.arrDiagramNode[index].createSpriteElement(iconHolder);
                    this.enableSpriteElement(index, true);
                }, 0);
            } else {
                const objAssets = { value: this.appStaticURL + emphasisShape.value, id: emphasisShape.id, type: "icon" };
                DiagramCreateUtil.updateManifest(objAssets, this.manifestUpdater, this.appStaticURL);
                DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body);
                let useNode = iconHolder.querySelector("[data-id='useNode']");
                if (useNode) useNode.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "#" + emphasisShape.id);
            }
        } else if (spriteHolder && emphasisShape.sprite && emphasisShape.frame && spriteHolder.parentElement) {
            // setTimeout(() => {
            this.arrDiagramNode[index].createSpriteElement(spriteHolder.parentElement, emphasisShape.frame);
            this.updatePropsCallBack(spriteHolder.id);
            // }, 0);
        }
    }

    let hasBorder = arrNodeData.length > 0;

    let nodeBGColorOptions = this.nodeProps.bgColor ? this.nodeProps.bgColor.split(",") : [];
    let strColorOptions = nodeBGColorOptions.length > 0 ? nodeBGColorOptions[0] : "";
    const hasOpacity = nodeBGColorOptions.length > 0 && strColorOptions.includes(":") && strColorOptions.includes("[") && strColorOptions.includes("]");
    if (hasOpacity && nodeBGColorOptions.length > 1) {
        let opacity = isNaN(nodeBGColorOptions[1]) ? "1" : nodeBGColorOptions[1];
        nodeBGColorOptions = strColorOptions.replace("[", "").replace("]", "").split(":");
        nodeBGColorOptions.push(opacity);
    }

    let hasBG = nodeBGColorOptions.length > 1;
    let bgNodeData = nodeBGColorOptions.length > 1 ? nodeBGColorOptions[1].replace(/\s/g, "") : "";
    let nodeName = DiagramNodeUtils.getNodeFromMenuNodeName(bgNodeData);

    let baseEmphasisClass = this.nodeProps.emphasisClass ? this.nodeProps.emphasisClass : "clsEmphasis";
    let empDisabledClass = hasBG ? baseEmphasisClass + "DisabledBG" : baseEmphasisClass + "Disabled";
    let empEnabledClass = hasBG ? baseEmphasisClass + "EnabledBG" : baseEmphasisClass + "Enabled";
    let allNodes = this.diagramParent.querySelectorAll("[name='nodeMainParent']");
    let iconBGNode = this.diagramParent.querySelector("[name='iconBG']");

    for (let i = 0; i < allNodes.length; i++) {
        allNodes[i].classList.add("mood");
        allNodes[i].classList.add(empDisabledClass);
        let bgNode = allNodes[i].querySelector(`[name='${nodeName}']`);
        if (!hasBorder && hasBG && bgNode) {
            let nodebgColor = nodeBGColorOptions[0];
            if (nodebgColor.includes("accent")) {
                bgNode.classList.add("clsEmpAccentBG");
            } else {
                bgNode.classList.add("clsEmpNormalBG");
            }
        } else if (hasBG && bgNode) {
            let nodebgColor = nodeBGColorOptions[0];
            if (nodebgColor.includes("accent")) {
                bgNode.classList.add("clsEmpAccentBorderBG");
            } else {
                bgNode.classList.add("clsEmpNormalBorderBG");
            }
        } else if (bgNode) {
            bgNode.classList.add("clsEmpEmpty");
        }

        if (hasBorder) {
            for (let j = 0; j < arrNodeData.length; j++) {
                let borderNodeName = DiagramNodeUtils.getNodeFromMenuNodeName(arrNodeData[j]);
                let borderNode = allNodes[i].querySelector(`[name='${borderNodeName}']`);
                if (borderNode) borderNode.classList.add("clsEmpBorder");
            }
        }

        if (bgNode && iconBGNode && iconBGNode.offsetWidth > 0 && iconBGNode.offsetHeight > 0) {
            bgNode.classList.add("clsEmpIconColor");
        }

        let seqNode = allNodes[i].querySelector("[name='seqTitleHolder']");
        if (seqNode) {
            let colorValue = window.getComputedStyle(seqNode).getPropertyValue("background-color");
            let arrRBG = colorValue.replace("rgb", "").replace("rgba", "").replace("(", "").replace(")", "").split(",");
            let alophaZero = arrRBG.length == 4 && arrRBG[3] == 0;
            let hasSEQBG = false;
            if (arrRBG.length > 2 && !alophaZero) {
                for (let j = 0; j < arrRBG.length; j++) {
                    if (arrRBG[j] > 0 && arrRBG[j] < 255) {
                        hasSEQBG = true;
                        break;
                    }
                }
            }
            if (hasSEQBG) seqNode.classList.add("clsEmpSeqUpdate");
            else seqNode.classList.add("clsEmpSeqAccentUpdate");
        }

        if (i == index) {
            allNodes[i].classList.remove(empDisabledClass);
            allNodes[i].classList.remove("mood");
            allNodes[i].classList.add("mood");
            allNodes[i].classList.add(empEnabledClass);
            // allNodes[i].firstElementChild.setAttribute("data-emphasize", "true");
            let nodeGroup = allNodes[i].querySelector("[name='nodeGroup']");
            nodeGroup.setAttribute("data-emphasize", "true");
        }
    }
};

LinearDiagram.prototype.enableSpriteElement = function (index, isEnableSprite = true) {
    let spriteHolder = this.diagramParent.querySelector("[id='spriteHolder" + index + "']");
    let iconHolder = this.diagramParent.querySelector("[data-id='iconNode'][data-index='" + index + "']");

    if (iconHolder) iconHolder.style.display = isEnableSprite ? "none" : "block";
    if (spriteHolder && iconHolder) spriteHolder.style.display = isEnableSprite ? "block" : "none";
};

LinearDiagram.prototype.changeAsset = function (obj) {
    if (obj.type == "animatedsprites") {
        this.nodeProps.quoteShape.path = obj.value;
        this.nodeProps.quoteShape.id = obj.id;
        if (obj.emphasisFrame && this.nodeProps?.emphasisShape?.frame) this.nodeProps.emphasisShape.frame = obj.emphasisFrame;
        if (this.menuData) {
            this.menuData.quoteShape = this.nodeProps.quoteShape;
            this.menuData.emphasisShape = this.nodeProps.emphasisShape;
        }
        this.updateNodeProperties();
        this.initDiagramCreation();
        this.updateEvents();
        this.updateEmphasize();
    }
};

LinearDiagram.prototype.changeAssetOldData = function (obj) {
    if (obj.type == "animatedsprites") {
        let objUrl = DiagramUtils.getUrlFromSprite(this.diagramParent);
        obj = { ...obj, ...objUrl };
    } else if (obj.type == "svg") {
        let objUrl = DiagramUtils.getUrlFromCenterIcon(this.diagramParent);
        obj = { ...obj, ...objUrl };
    } else {
        let illustrationtarget = this.diagramParent.querySelector("[id='" + obj.targetid + "']");
        if (illustrationtarget) {
            obj.value = illustrationtarget.getAttribute("lottie-json-path");
        }
    }
    return obj;
};

LinearDiagram.prototype.changeSecondaryType = function (type, index) {
    // this.diagramData.properties.secondarytype = type;
    if (this.arrDiagramNode && this.arrDiagramNode.length > index) {
        this.arrDiagramNode[index].changeSecondaryType(type, index);
        // if (type == "icon") {
        let secondaryText = this.diagramParent.querySelector("[id='secondaryText" + index + "']");
        if (secondaryText) {
            this.arrDiagramNode[index].removeAllSubContent(secondaryText);
            this.setSecondaryIconList(secondaryText, index);
            if (type.includes("image") || type.includes("logo")) {
                this.resetImageLogoFrames();
            }
        }
        // }
    }
    this.updateTextNodes();
    this.updateProperties(this.diagramData.properties);
};

LinearDiagram.prototype.changeNestedList = function (index, element) {
    let recursiveUl = element.cloneNode();
    recursiveUl.innerHTML = "";
    recursiveUl.style.marginLeft = "40px";
    let parentElement = element.children[index - 1];
    let arrElements = Array.from(element.children);
    arrElements.forEach((item, j) => {
        if (index <= j) {
            item.remove();
            recursiveUl.appendChild(item);
        }
    });

    parentElement.appendChild(recursiveUl);
};

LinearDiagram.prototype.updateElements = function () {
    this.eventManagerXY.clear();
    this.clear();
    this.recreateElementData();
    if (!this.diagramData || this.diagramData?.nodes.length == 0) this.updateJSONData();
    this.toggleVisibility();
    this.updateEvents();
    // console.log("update elements", this.arrDiagramNode.length);
    //this.resetHolderWidth();
};

LinearDiagram.prototype.updateJSONData = function () {
    this.diagramData = this.getJSONData();
    // this.centerholderdata = this.getCenterHolderData?.();
};

// Diagram properties Get/Set

LinearDiagram.prototype.updateProperties = function (properties) {
    this.setPropertiesFromConstants(properties, JSON.parse(JSON.stringify(Constants.Value.arrProperties)));
    if (this.nodeProps) this.updateNodeProperties();
};

LinearDiagram.prototype.updateMoodProperties = function () {
    try {
        // if (this.nodeProps.name && this.nodeProps.name != "") {
        if (this.nodeProps) {
            if (this.arrDiagramNode && this.arrDiagramNode.length > 0) this.diagramParent.setAttribute("data-nodecount", this.arrDiagramNode.length);
            this.nodeGap = DiagramPropertyUtils.getDefaultDiagramNodeGap(this.nodeProps, this.diagramParent, this.diagramData && this.diagramData.properties);
            DiagramPropertyUtils.updateNodePropsFromStyle(this.nodeProps, "contentNodePadding", this.diagramParent);
            if (this.isLinearNodeStyles()) {
                DiagramPropertyUtils.updateGlobalNodePropsFromStyle(this.nodeProps, "nodealignment", this.diagramParent, "--graphicHAlign");
            }
            DiagramPropertyUtils.updateGlobalNodePropsFromStyle(this.nodeProps, "valign", this.diagramParent, "--graphicVAlign");
            DiagramPropertyUtils.updateNodePropsFromStyle(this.nodeProps, "nodeParentPadding", this.diagramParent);
            DiagramPropertyUtils.updateNodePropsFromStyle(this.nodeProps, "secondaryContentNodePadding", this.diagramParent);
            DiagramPropertyUtils.updateNodePropsFromStyle(this.nodeProps, "minWidthHeight", this.diagramParent);
            if (this.globalMoodData) {
                let seperatorMoodObj = JSON.parse(JSON.stringify(DiagramUtils.getSeperatorObject(this.globalMoodData.basicgraphics, this.diagramParent.dataset.classname)));
                this.nodeProps.seperatorline = { ...seperatorMoodObj.seperatorline, ...this.nodeProps.seperatorline };
                this.nodeProps.connectortext = { ...seperatorMoodObj.connectortext, ...this.nodeProps.connectortext };
                if (this.nodeProps?.name?.includes("-hierarchy-")) {
                    // seperatorMoodObj.connector.flowloop = null;
                    if (this.nodeProps?.connector?.hierarchy) this.nodeProps.connector.hierarchy = { ...seperatorMoodObj?.connector?.hierarchy, ...this.nodeProps.connector.hierarchy };
                    if (this.nodeProps?.connector?.flowloop) this.nodeProps.connector.flowloop = null;
                }
                if (this.nodeProps?.name?.includes("-flow-")) {
                    // seperatorMoodObj.connector.hierarchy = null;
                    if (this.nodeProps?.connector?.flowloop) this.nodeProps.connector.flowloop = { ...seperatorMoodObj?.connector?.flowloop, ...this.nodeProps.connector.flowloop };
                    if (this.nodeProps?.connector?.hierarchy) this.nodeProps.connector.hierarchy = null;
                }
                this.nodeProps.connector = { ...seperatorMoodObj?.connector, ...this.nodeProps?.connector };
                // if (!this.nodeProps.seperatorline) this.nodeProps.seperatorline = seperatorMoodObj.seperatorline;
                // if (!this.nodeProps.connector) this.nodeProps.connector = seperatorMoodObj.connector;
            }
        }
    } catch (error) {
        console.log(error);
    }
};

LinearDiagram.prototype.isLinearNodeStyles = function () {
    let className = this.diagramParent.dataset.classname;
    return className == "SimpleLinearDiagram" || className == "SimpleLinearVerticalDiagram" || className == "SimpleLinearGridDiagram" || className == "SimpleLinearVerticalGridDiagram";
};

LinearDiagram.prototype.updateNodeProperties = function () {
    // this.diagramParent.setAttribute("data-node-classname", this.nodeProps.className || "PlainDiagramNode");
    this.setPropertiesFromConstants(this.nodeProps, JSON.parse(JSON.stringify(Constants.Value.arrNodeProperties)), "node");
};

LinearDiagram.prototype.getProperties = function (defaultproperties = {}) {
    let mainProperties = this.diagramData && this.diagramData.properties ? this.diagramData.properties : defaultproperties;
    this.getPropertiesFromConstants(mainProperties, JSON.parse(JSON.stringify(Constants.Value.arrProperties)));
    this.getNodeProperties();
    return mainProperties;
};

LinearDiagram.prototype.getNodeProperties = function () {
    if (this.nodeProps == null) this.nodeProps = {};
    this.getPropertiesFromConstants(this.nodeProps, JSON.parse(JSON.stringify(Constants.Value.arrNodeProperties)), "node");
    this.updateMoodProperties();
};

LinearDiagram.prototype.getPropertiesFromConstants = function (mainObj, constArrProperties, extraAttrib = "") {
    let arrPropertiesMenu = extraAttrib == "node" ? Constants.Value.arrStaticNodeProperties : Constants.Value.arrStaticProperties;
    for (var property in constArrProperties) {
        let propValue = this.diagramParent.dataset[extraAttrib + property.toLowerCase()];
        let propertyTrimmed = property.replace("json", "").replace("bool", "");
        if ((propValue == undefined || propValue == null || propValue == "") && arrPropertiesMenu.includes(property) && this.menuData) {
            mainObj[propertyTrimmed] = this.menuData[propertyTrimmed];
        } else {
            if (property.includes("json")) {
                property = propertyTrimmed;
                propValue = this.diagramParent.dataset[extraAttrib + property.toLowerCase()];
                try {
                    mainObj[property] = propValue ? (propValue.includes(",") && !propValue.startsWith("{") ? propValue.split(",") : JSON.parse(propValue)) : constArrProperties["json" + property];
                } catch (error) {
                    mainObj[property] = propValue ? propValue : constArrProperties["json" + property];
                }
            } else if (property.includes("bool")) {
                property = propertyTrimmed;
                propValue = this.diagramParent.dataset[extraAttrib + property.toLowerCase()];
                mainObj[property] = propValue && (propValue == "true" || propValue == true) ? true : false;
            } else if (property.includes("arr")) {
                mainObj[property] = propValue && propValue != "" ? propValue.split(",") : constArrProperties[property];
            } else {
                mainObj[property] = propValue || constArrProperties[property];
            }
        }
    }
};

LinearDiagram.prototype.getPropertiesFromConstantsMenuJson = function (mainObj, data, constArrProperties) {
    for (var property in constArrProperties) {
        let jsonFormat = property.includes("json");
        let boolFormat = property.includes("bool");
        // if (arrMenuOverride.includes(property)) {
        if (Object.keys(constArrProperties).includes(property)) {
            property = jsonFormat || boolFormat ? property.substring(4) : property;
            if (boolFormat) mainObj[property] = data[property] && (data[property] == "true" || data[property] == true) ? true : mainObj[property] || false;
            else mainObj[property] = data[property] || mainObj[property] || constArrProperties[jsonFormat ? "json" + property : property];
        }
    }
};

LinearDiagram.prototype.setPropertiesFromConstants = function (mainObj, constArrProperties, extraAttrib = "") {
    let arrPropertiesDom = extraAttrib == "node" ? Constants.Value.arrNodePropertiesDom : Constants.Value.arrPropertiesDom;
    let arrPropertiesMenu = extraAttrib == "node" ? Constants.Value.arrStaticNodeProperties : Constants.Value.arrStaticProperties;
    for (var property in constArrProperties) {
        if (!arrPropertiesMenu.includes(property)) {
            let setPropertyToDom = arrPropertiesDom.includes(property);
            let jsonFormat = property.includes("json");
            let boolFormat = property.includes("bool");
            property = jsonFormat || boolFormat ? property.substring(4) : property;
            if (jsonFormat) {
                // let value = mainObj[property] ? JSON.stringify(mainObj[property]) : constArrProperties["json" + property];
                let stringValue = mainObj[property] ? JSON.stringify(mainObj[property]) : null;
                let value = mainObj[property] ? (mainObj[property] instanceof Array ? mainObj[property] : stringValue) : null;
                if (setPropertyToDom) {
                    if (mainObj[property] && value != null) this.diagramParent.setAttribute("data-" + extraAttrib + property, value);
                } else if (mainObj[property] && value != null && stringValue != JSON.stringify(constArrProperties["json" + property])) this.diagramParent.setAttribute("data-" + extraAttrib + property, value);
                // if (mainObj[property] && value != null) this.diagramParent.setAttribute("data-" + extraAttrib + property, value);
            } else if (boolFormat) {
                if (setPropertyToDom) {
                    if (mainObj[property]) this.diagramParent.setAttribute("data-" + extraAttrib + property, mainObj[property]);
                    else if (this.diagramParent.hasAttribute("data-" + extraAttrib + property)) this.diagramParent.removeAttribute("data-" + extraAttrib + property);
                } else {
                    if (mainObj[property] != null && mainObj[property] != constArrProperties["bool" + property]) this.diagramParent.setAttribute("data-" + extraAttrib + property, mainObj[property]);
                    else if (this.diagramParent.hasAttribute("data-" + extraAttrib + property)) this.diagramParent.removeAttribute("data-" + extraAttrib + property);
                }
            } else if (mainObj[property]) {
                // let value = mainObj[property] || constArrProperties[property];
                let value = mainObj[property];
                if (setPropertyToDom) {
                    if (value != null && value != "") this.diagramParent.setAttribute("data-" + extraAttrib + property, value);
                    else if (this.diagramParent.hasAttribute("data-" + extraAttrib + property)) this.diagramParent.removeAttribute("data-" + extraAttrib + property);
                } else {
                    if (value != null && value != "" && value.toString() != constArrProperties[property]) this.diagramParent.setAttribute("data-" + extraAttrib + property, value);
                    else if (this.diagramParent.hasAttribute("data-" + extraAttrib + property)) this.diagramParent.removeAttribute("data-" + extraAttrib + property);
                }
            }
        }
    }
};

LinearDiagram.prototype.getDiagramPropertiesFromMenu = function (properties, data) {
    let arrProperties = JSON.parse(JSON.stringify(Constants.Value.arrProperties));
    let arrNodeProperties = JSON.parse(JSON.stringify(Constants.Value.arrNodeProperties));
    properties.floateroptionsdisable = arrProperties.jsonfloateroptionsdisable; // Reset FloaterOption to default
    this.getPropertiesFromConstantsMenuJson(properties, data, arrProperties);
    //node props
    if (this.nodeProps == null) this.nodeProps = {};
    this.nodeProps.iconBG = data.iconBG;
    this.getPropertiesFromConstantsMenuJson(this.nodeProps, data, arrNodeProperties);
    this.updateProperties(properties);
    this.updateMoodProperties();
    this.updateFloaterSettings(this.diagramData.properties);
};

LinearDiagram.prototype.isNonLinearAsset = function () {
    return false;
};

LinearDiagram.prototype.swapNodes = function (objData, swapNodeIndex) {
    let target = this.diagramParent.querySelector("[id='" + objData.targetid + "']");
    if (target) {
        let index = parseInt(target.dataset.index);
        let swapIndex = index + swapNodeIndex;
        let currentTarget = this.diagramParent.querySelector("[id='nodeMainParent" + index + "']");
        let currentConnector = currentTarget.querySelector("[name='connectorparent']");
        let swapTarget = this.diagramParent.querySelector("[id='nodeMainParent" + swapIndex + "']");
        let swapConnector = swapTarget.querySelector("[name='connectorparent']");

        currentTarget.remove();
        currentTarget.setAttribute("id", "nodeMainParent" + swapIndex);
        if (swapConnector) {
            swapConnector.remove();
            currentTarget.appendChild(swapConnector);
        }
        swapTarget.parentElement.insertBefore(currentTarget, swapNodeIndex == 1 ? swapTarget.nextSibling : swapTarget);
        swapTarget.setAttribute("id", "nodeMainParent" + index);
        if (currentConnector) {
            currentConnector.remove();
            swapTarget.appendChild(currentConnector);
        }
        this.arrDiagramNode = DiagramUtils.swapArrayElements(this.arrDiagramNode, index, swapIndex);
        this.resetHolderWidth();
        // this.resetNodeAttributes();
        if (this.checkHighlight) this.checkHighlight(this.diagramParent);
        // this.updatePropsCallBack(objData.targetid);
    }
};

LinearDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    const jsonStr = this.nodeProps.supportedNodes ? JSON.stringify(this.nodeProps.supportedNodes) : "";
    const graphicName = this.nodeProps.name;
    const secText = jsonStr.includes("subTitleHolder");
    const checkList = jsonStr.includes("checkListHolder");
    const isNonLinear = this.isNonLinearAsset();
    const centerNodeAsset = jsonStr.includes("centerNode");
    const isLogoAsset = DiagramUtils.isLogoAsset(this.nodeProps && this.nodeProps.name);
    const isAgenda = graphicName.includes("agenda");
    const isVerticalAsset = graphicName.includes("ver-");
    const isQuote = this.nodeProps.quoteShape || this.nodeProps.name.includes("qt");
    const isIllustration = this.nodeProps.name.includes("ills");
    const restrictClientele = this.nodeProps.name.includes("clientele-");
    const isDevice = this.nodeProps.name.includes("device") || this.diagramParent.dataset.classname == "SimpleLinearDiagramDevice";
    const isMicroChart = this.nodeProps.name.includes("-mc-");
    const isCustomSecondary = mainProperties.secondarytype && mainProperties.secondarytype == "custom";
    const isTeamAsset = this.nodeProps && this.nodeProps.name.includes("-team");
    const isQuillAsset = jsonStr.includes("multiTextNode");
    const restrictCrossOut = isNonLinear || isDevice || DiagramUtils.isVerticalListAsset(graphicName) || jsonStr.includes("textTitleHolder");
    const restrictImageSize = graphicName.includes("pot") || graphicName.includes("sqr") || graphicName.includes("land");
    const restrictConnector = isQuote || isIllustration || isDevice || isMicroChart;
    const restrictArrange = isIllustration || isDevice;
    let arrFloaterDisable = mainProperties.floateroptionsdisable;
    if (!arrFloaterDisable) return;

    try {
        if (!secText) {
            if (!arrFloaterDisable.includes("secondarytext")) arrFloaterDisable.push("secondarytext");
        }
    } catch (error) {}
    // if (checkList) arrFloaterDisable.push("edit");
    if (isMicroChart) arrFloaterDisable.push("ver");
    if (isTeamAsset || isIllustration) arrFloaterDisable.push("content", "contentoptions");
    if (isQuote) arrFloaterDisable.push("content", "contentoptions");
    if (isAgenda) arrFloaterDisable.push("sequencetext", "secondaryplaceholder", "primarytext");
    if (restrictCrossOut) arrFloaterDisable.push("crossout");
    if (restrictImageSize) arrFloaterDisable.push("imagesize");
    if (restrictConnector) arrFloaterDisable.push("connector");
    if (restrictClientele) arrFloaterDisable.push("secondaryplaceholder");
    if (restrictArrange) arrFloaterDisable.push("arrange");
    if (isCustomSecondary) arrFloaterDisable.push("bullet", "decimal", "textpara");
    if (!isLogoAsset) arrFloaterDisable.push("greyscale");
    if (isQuillAsset) arrFloaterDisable.push("addoption", "edit", "connector", "seperatorline", "contentoptions");
    if (isVerticalAsset) arrFloaterDisable.push("arrowboth", "arrowbackandforth", "divide", "equal", "notequal");
    if (isNonLinear) arrFloaterDisable.push("greyscale", "swap", "button", "secondaryplaceholder");

    if (this.nodeProps.name.includes("-img-por") || this.nodeProps.name.includes("-img-sqr") || (this.nodeProps.name.includes("-img-land") && !this.nodeProps.name.includes("grd"))) arrFloaterDisable.push("grd");
    // this.diagramParent.setAttribute("data-floateroptionsdisable", arrFloaterDisable);
    this.diagramParent.setAttribute("data-floateroptionsdisable", arrFloaterDisable);
    this.updateProperties(mainProperties);
};

LinearDiagram.prototype.emphasize = function (emphasizeData) {
    let index = 0;
    let targetid = emphasizeData && emphasizeData.targetid;
    if (targetid) {
        let target = this.diagramParent.querySelector("[id='" + targetid + "']");
        index = target.dataset.index;
    }
    this.hideEmpahsis();
    // for (let i = 0; i < this.arrDiagramNode.length; i++) {
    if (emphasizeData.value && emphasizeData.value == true) this.showEmpahsis(index);
    // }
    // this.updatePropsCallBack(targetid);
};

LinearDiagram.prototype.crossout = function (objData) {
    let targetNode = this.diagramParent.querySelector("[id='" + objData.targetid + "']");
    let diagramContentNode = targetNode.id.includes("Holder") ? targetNode.parentElement : targetNode.querySelector("[data-id='diagramContentNode']");
    let isTextNode = false;
    let anchorPointObj = DiagramUtils.getObject(this.nodeProps.supportedNodes, true, "crossoutAnchor");
    if (anchorPointObj && targetNode) {
        let index = targetNode.dataset.index;
        let contentNode = this.diagramParent.querySelector("[name='" + anchorPointObj.name + "'][data-index='" + index + "']");
        if (contentNode && contentNode.clientHeight > 0) {
            targetNode = contentNode.firstElementChild;
            diagramContentNode = contentNode;
        }
    }
    if (!diagramContentNode || this.diagramData.properties.diagramcontent == false) return;
    let index = diagramContentNode ? diagramContentNode.dataset.index : 0;
    if (targetNode && targetNode.parentElement) {
        let className = isTextNode ? "clsCrossoutTextStyle" : "clsCrossoutStyle";
        let crossOutParent = targetNode.parentElement.querySelector("[name='crossoutParent']");
        // if (targetNode.parentElement.classList.contains(className)) {
        if (crossOutParent) {
            crossOutParent.parentElement.classList.remove(className);
            crossOutParent.remove();
            // targetNode.parentElement.removeAttribute("data-crossout", "true");
            this.arrDiagramNode[index].nodeGroup.removeAttribute("data-crossout");
        } else {
            targetNode.parentElement.classList.add(className);
            // targetNode.parentElement.setAttribute("data-crossout", "true");
            this.arrDiagramNode[index].nodeGroup.setAttribute("data-crossout", "true");
            this.arrDiagramNode[index].createCrossoutDiv(diagramContentNode);
        }
    }
    // this.updatePropsCallBack(objData.targetid);
};

LinearDiagram.prototype.getJSONData = function (defaultproperties) {
    if (this.arrDiagramNode.length == 0 && this.diagramData) return this.diagramData;
    // if (this.arrDiagramNode.length == 0 && !this.diagramData) this.recreateElementData();
    let arrNodeData = [];
    for (let i = 0; i < this.arrDiagramNode.length; i++) {
        let nodeData = this.arrDiagramNode[i].getJSONData(this.diagramParent);
        arrNodeData.push(nodeData);
        this.arrDiagramNode[i].objData = nodeData; // Added to store data in nodeinstance also
    }
    return { properties: this.getProperties(defaultproperties), nodes: arrNodeData, diagramtitle: DiagramCreateUtil.getDiagramTitleData(this.diagramParent) };
};

LinearDiagram.prototype.onHoverOutNode = function (event) {
    this.diagramParent.setAttribute("moverHovered", false);
};

LinearDiagram.prototype.onHoverNode = function (event) {
    this.diagramParent.setAttribute("moverHovered", true);
};

LinearDiagram.prototype.updateEvents = function () {
    this.eventManagerXY.clear();

    if (this.appmode.toLowerCase() == "present") return;

    let arrEventNodes = [];
    // For Connector Text
    let connectorNodes = Array.from(this.diagramParent.querySelectorAll("[name='connectortext']"));
    arrEventNodes = arrEventNodes.concat(connectorNodes);
    // For Diagram Title
    let diagramTitle = this.diagramParent.querySelector("[name='diagramTitle']");
    if (diagramTitle) {
        arrEventNodes.push(diagramTitle);
        this.eventManagerXY.addEvent(diagramTitle, "mouseup", this.textHighlightMouseUpEvent.bind(this));
    }
    // For Center Holder Text
    let centerHolderParent = this.diagramParent.querySelector("[name='centerHolderParent']") || this.bgDeviceDiv?.querySelector("[name='centerHolderParent']");
    if (centerHolderParent) {
        let arrCenterChildNodes = Array.from(centerHolderParent.querySelectorAll("[data-default-event='true']"));
        arrEventNodes = arrEventNodes.concat(arrCenterChildNodes);
        // For Image Node
        let allImgNodes = centerHolderParent.querySelectorAll("img[data-id='imageNode'],img[data-id='logoNode']");

        allImgNodes.forEach((element) => {
            let isLogoList = element.parentElement.dataset.componentType && element.parentElement.dataset.componentType == "grid";
            if (!isLogoList) this.eventManagerXY.addEvent(element.parentElement, "dblclick", this.imageDoubleClickHandler);
        });
    }

    for (let j = 0; j < arrEventNodes.length; j++) {
        this.eventManagerXY.addEvent(arrEventNodes[j], "focusout", this.defaultFoucsOut);
        this.eventManagerXY.addEvent(arrEventNodes[j], "focusin", this.defaultFoucsIn);
        this.eventManagerXY.addEvent(arrEventNodes[j], "paste", this.diagramPasteHandler);
    }

    for (let i = 0; i < this.arrDiagramNode.length; i++) {
        let parentNode = this.arrDiagramNode[i].parentNode;
        this.arrDiagramNode[i].searchIconCallBack = this.searchIconCallBack;
        let arrChildNodes = Array.from(parentNode.querySelectorAll("[data-default-event='true']"));

        // For Text Highlight
        let arrHighLightNodes = parentNode.querySelectorAll("[data-highlight-event='true']");
        for (let j = 0; j < arrHighLightNodes.length; j++) {
            this.eventManagerXY.addEvent(arrHighLightNodes[j], "mouseup", this.textHighlightMouseUpEvent.bind(this));
        }

        // For Hover Nodes in presentation
        let hoverNode = parentNode.querySelector("[name='nodeGroup']");
        this.eventManagerXY.addEvent(hoverNode, "mouseenter", this.onHoverNode);
        this.eventManagerXY.addEvent(hoverNode, "mouseleave", this.onHoverOutNode);

        // For Check List Node
        let checklistNodes = parentNode.querySelectorAll("[data-checkbox-event='true']");
        for (let j = 0; j < checklistNodes.length; j++) {
            this.eventManagerXY.addEvent(checklistNodes[j], "mousedown", this.defaultCheckBoxEvent);
        }

        // let togglelistNode = parentNode.querySelector("[data-toggle-event='true']");
        // if(togglelistNode && this.arrDiagramNode[i].numberToggleStyle){
        //     this.eventManagerXY.addEvent(togglelistNode, "mousedown", this.arrDiagramNode[i].numberToggleStyle.defaultCheckBoxEvent);
        // }

        // For Microchart Node
        let microchartNode = parentNode.querySelectorAll("[data-id='microchartNode']");
        if (microchartNode && microchartNode.length > 0) {
            microchartNode.forEach((element) => {
                this.eventManagerXY.addEvent(element, "focusout", this.arrDiagramNode[i].microChartFoucsOut);
                this.eventManagerXY.addEvent(element, "focusin", this.arrDiagramNode[i].microChartFoucsIn);
            });
        }

        // For Image Node
        let allImgNodes = parentNode.querySelectorAll("img[data-id='imageNode'],img[data-id='logoNode']");

        allImgNodes.forEach((element) => {
            let isLogoList = element.parentElement.dataset.componentType && element.parentElement.dataset.componentType == "grid";
            if (!isLogoList) this.eventManagerXY.addEvent(element.parentElement, "dblclick", this.imageDoubleClickHandler);
        });

        // For Microchart Node
        if (this.nodeProps && this.nodeProps.microStyle && this.nodeProps.microStyle == "clsRatingMicro") {
            let microchartNodeCircle = parentNode.querySelectorAll("[id*='clsCircleBG']");
            if (microchartNodeCircle && microchartNodeCircle.length > 0) {
                microchartNodeCircle.forEach((element) => {
                    this.eventManagerXY.addEvent(element, "click", this.arrDiagramNode[i].microChartClickEvent);
                });
            }
        }

        let allMicroNode = parentNode.querySelectorAll("[data-id='microchartNode']");
        allMicroNode.forEach((element) => {
            this.eventManagerXY.addEvent(element, "keydown", this.arrDiagramNode[i].microChartKeyDown);
        });

        // For all common events
        this.arrDiagramNode[i].observer.disconnect();
        this.arrDiagramNode[i].observer = new MutationObserver(this.arrDiagramNode[i].mutationCallBack);
        this.arrDiagramNode[i].observer.mytargets = [];

        for (let j = 0; j < arrChildNodes.length; j++) {
            this.eventManagerXY.addEvent(arrChildNodes[j], "focusout", this.defaultFoucsOut);
            this.eventManagerXY.addEvent(arrChildNodes[j], "focusout", this.arrDiagramNode[i].onFocusOut);
            this.eventManagerXY.addEvent(arrChildNodes[j], "focusin", this.defaultFoucsIn);
            this.eventManagerXY.addEvent(arrChildNodes[j], "paste", this.diagramPasteHandler);

            if (arrChildNodes[j].getAttribute("data-observer") && arrChildNodes[j].getAttribute("data-observer") == "true") {
                this.arrDiagramNode[i].observer.observe(arrChildNodes[j], { childList: true });
                this.arrDiagramNode[i].observer.mytargets.push(arrChildNodes[j]);
            }
        }
    }
    //update callback listeners
    if (this.focusoutTextEvent) {
        this.addListener("focusout", this.focusoutTextEvent);
    }
    if (this.doubleclickEvent) {
        this.addListener("dblclick", this.doubleclickEvent);
    }
    if (this.mousedownTextEvent) {
        this.addListener("mousedown", this.mousedownTextEvent);
    }
    if (this.mouseupSelectionEvent) {
        this.addListener("mouseup", this.mouseupSelectionEvent);
    }
    if (this.keyupSelectionEvent) {
        this.addListener("keyup", this.keyupSelectionEvent);
    }
    if (this.keypressEvent) {
        this.addListener("keypress", this.keypressEvent);
    }
};

LinearDiagram.prototype.textResize = function (targetid, size, objDetails) {
    let nodeGroup = this.diagramParent.querySelector("[id='" + targetid + "']");
    if (!nodeGroup) nodeGroup = this.diagramParent;
    let target = nodeGroup.querySelector("[name='" + objDetails.contenttype + "']");
    if (!target) target = nodeGroup.querySelector("[data-type*='" + objDetails.contenttype + "']");
    if (!target) target = nodeGroup.querySelector("[id*='" + objDetails.contenttype + "']");
    if (!target && nodeGroup?.dataset?.type == objDetails?.contenttype) target = nodeGroup;
    if (target && target.dataset.type == "secondaryText") {
        target = target.parentElement;
    }
    let isCenterNode = (target.dataset.focusParent && target.dataset.focusParent.includes("centerHolder")) || false;
    if (target && !isCenterNode) {
        this.textResizeForTarget(target.getAttribute("name"), size);
    } else {
        this.commonNodeTextResiz(target, size);
    }
};

LinearDiagram.prototype.textResizeForTarget = function (targetId, size) {
    this.arrDiagramNode.forEach((element) => {
        let multiTextParent = element.parentNode.querySelector("[name='" + targetId + "']");
        if (!multiTextParent) return;
        TextHighLightUtils.removeFontClassName(multiTextParent, this.fontClassList);
        if (size.includes("auto")) multiTextParent.classList.add(multiTextParent.getAttribute("original-fontclass"));
        else multiTextParent.classList.add(size);
        multiTextParent.setAttribute("data-fontresize", size);
        this.diagramData.properties.fontresize[targetId] = size;
        if (element?.properties?.fontresize?.[targetId]) element.properties.fontresize[targetId] = size;
        this.updateProperties(this.diagramData.properties);
        this.diagramParent.setAttribute("data-fontresize-" + targetId.toLowerCase(), size);
        // element.updateOnFocusOut(multiTextParent);
    });
    this.updateTextNodes();
    // this.updatePropsCallBack(targetId);
};

LinearDiagram.prototype.commonNodeTextResiz = function (target, size) {
    if (this.centerNode || this.centerHolderNode) {
        let targetName = target.getAttribute("name");
        if (!target) return;
        TextHighLightUtils.removeFontClassName(target, this.fontClassList);
        if (size.includes("auto")) target.classList.add(target.getAttribute("original-fontclass"));
        else target.classList.add(size);

        target.setAttribute("data-centernodefontresize", size);
        target.setAttribute("data-fontresize", size);

        this.diagramData.properties.centernodefontresize[targetName] = size;
        this.updateProperties(this.diagramData.properties);
        this.diagramParent.setAttribute("data-centernodefontresize-" + targetName.toLowerCase(), size);
        this.updatePropsCallBack(targetName);
        this.centerHolderNode?.updateOnFocusOut?.();
    }
};

LinearDiagram.prototype.recreateElementData = function () {
    this.setMoodClassNames();
    let arrNodesItems = this.diagramParent.querySelectorAll("div[name='nodeparent']");
    this.updateJSONData();
    let properties = this.getProperties();
    let intLength = arrNodesItems.length;
    this.arrDiagramNode = [];
    // this.arrgridimages = [];
    for (let i = 0; i < intLength; i++) {
        let nodeItem = arrNodesItems[i];
        let diagramNode = new window[this.nodeProps.nodeclassName](nodeItem.parentElement.parentElement, properties, null, this.eventManagerXY, i, nodeItem.getAttribute("data-parent-id"), this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
        diagramNode.parentNode = nodeItem;
        diagramNode.nodeGroup = nodeItem.querySelector("[name='nodeGroup']");
        this.createNodeInstanceProperties(diagramNode);
        diagramNode.objData = diagramNode.getJSONData();
        this.recreateAuthorInstance(nodeItem, diagramNode, i);
        this.recreateNumberToggleInstance(nodeItem, diagramNode, i);
        this.recreateImageGridInstance(nodeItem, diagramNode, i);
        if (this.appmode.toLowerCase() != "present") this.recreateMultiTextInstance(nodeItem, diagramNode, i);
        diagramNode.updateNodeAttributes(i, this.diagramRenderComplete);
        this.arrDiagramNode.push(diagramNode);
    }
    this.updateCssAttributes();
    // if (this.nodeProps.supportedNodes) {
    //     let imageHolderObj = DiagramUtils.getObjectFromName(this.nodeProps.supportedNodes, "imageHolder");
    //     if (imageHolderObj && imageHolderObj.hasOwnProperty("imageoverlayproperties")) this.globalMoodData.imageoverlayproperties = imageHolderObj.imageoverlayproperties;
    // }
};

LinearDiagram.prototype.recreateImageGridInstance = function (nodeItem, diagramNode, i) {
    try {
        let imageGridNode = nodeItem.querySelector("[name='imageGridNode']");
        if (imageGridNode) {
            let logoListData = DiagramUtils.getObjectFromName(this.nodeProps.supportedNodes, "logoListHolder");
            diagramNode.gridInstance = new window["SimpleImageGrid"](nodeItem, this.nodeProps, this.appStaticURL, DiagramUtils.getDefaultDataForLogoList(this.arrDefaults, this.nodeProps), logoListData);
            diagramNode.gridInstance.gridimages = diagramNode.gridInstance.getLogoListData(diagramNode.parentNode);
            diagramNode.gridInstance.updateCallBack = diagramNode.updateCallBack;
            diagramNode.gridInstance.completeCallback = diagramNode.updateLogoListLoadCallback.bind(diagramNode);
            diagramNode.gridInstance.focusCallBack = {
                func: diagramNode.updateOnFocusOut.bind(diagramNode),
            };
            if (!logoListData.class) {
                let moodAlign = window.getComputedStyle(this.diagramParent).getPropertyValue("--logogridalignment");
                logoListData.class = moodAlign == "left" ? "clsLinearImageGridNode" : "clsLinearImageGridNodecenter";
            }
            if (logoListData) DiagramUtils.addClassNames(logoListData.class, nodeItem.parentElement);
            // let arrLogoNodes = imageGridNode.querySelectorAll("[name='logoNode']");
            // if (arrLogoNodes?.length > 0) {
            //     arrLogoNodes.forEach((element) => {
            //         DiagramResizeUtils.updateDefaultImageData(element, "logo", diagramNode?.gridInstance?.imageLoadCallBack);
            //     });
            // }
        }
    } catch (error) {
        console.log(error);
    }
};

LinearDiagram.prototype.recreateMultiTextInstance = function (nodeItem, diagramNode, i) {
    try {
        let multiTextNode = nodeItem.querySelector("[id*='quillParent']");
        if (multiTextNode) {
            let multiTextObj = DiagramUtils.getObjectFromName(this.nodeProps.supportedNodes, "multiTextNode");
            diagramNode.multiTextBox = new window["MultiTextComponent"](nodeItem, null, i, this.eventManagerXY, multiTextObj, diagramNode.objStyleData.fontSizeData, this.manifestUpdater, this.appStaticURL);
            diagramNode.multiTextBox.updateCallBack = this.updateCallBack;
            diagramNode.multiTextBox.properties = diagramNode.properties;
            diagramNode.multiTextBox.innerFill = diagramNode.innerFill;
            diagramNode.multiTextBox.slideID = this.slideID;
            diagramNode.multiTextBox.globalMoodData = diagramNode.globalMoodData;
            diagramNode.multiTextBox.recreateQuillInstance(null, true);
            diagramNode.multiTextBox.multitextdata = diagramNode.multiTextBox.getJSONData();
            diagramNode.multiTextBox.focusCallBack = {
                func: diagramNode.updateOnFocusOut.bind(diagramNode),
            };
            diagramNode.multiTextBox.setQuillOperationHandler = this.setQuillOperation;
        }
    } catch (error) {
        console.log(error);
    }
};

LinearDiagram.prototype.recreateAuthorInstance = function (nodeItem, diagramNode, i) {
    try {
        let authorStyle = nodeItem.querySelector("[id*='authorStyle']");
        if (authorStyle) {
            diagramNode.authorStyle = new window["AuthorStyleGroup"](this.nodeProps, {}, i, { authorNameFontSize: diagramNode.authorNameFontSize, authorDesFontSize: diagramNode.authorDesFontSize, globalMoodData: this.globalMoodData }, this.diagramParent, this.appStaticURL, diagramNode.properties);
            diagramNode.objData.author = diagramNode.authorStyle.getAuthorData(diagramNode.parentNode);
            // this.authordata = diagramNode.authorStyle.getAuthorData(nodeItem);
            // diagramNode.authorStyle.nodeData = this.authordata;
        }
    } catch (error) {
        console.log(error);
    }
};

LinearDiagram.prototype.recreateNumberToggleInstance = function (nodeItem, diagramNode, i) {
    try {
        let numberToggleStyle = nodeItem.querySelector("[id*='numberToggleStyle']");
        if (numberToggleStyle) {
            diagramNode.numberToggleStyle = new window["NumberToggleStyleGroup"](this.nodeProps, {}, i, DiagramUtils.getObjectFromName(this.nodeProps.supportedNodes, "numberToggleStyleGroup"), this.appStaticURL);
            diagramNode.objData.number = diagramNode.numberToggleStyle.getNumberToggleData(diagramNode.parentNode);
            // this.numbertoggledata = diagramNode.numberToggleStyle.getNumberToggleData(nodeItem);
            // diagramNode.numberToggleStyle.nodeData = this.numbertoggledata;
        }
    } catch (error) {
        console.log(error);
    }
};

LinearDiagram.prototype.clear = function () {
    this.eventManagerXY.clear();
    // this.arrDiagramNode = [];
};

LinearDiagram.prototype.clearEvents = function () {
    this.eventManagerXY.clear();
};

LinearDiagram.prototype.abort = function () {
    try {
        this.aborted = true;
        this.clear();
        this.completeCallBack = null;
        this.diagramParent.innerHTML = "";
    } catch (error) {
        console.log(error);
    }
};

LinearDiagram.prototype.setupOneAtTimeAnimation = function (animationType = "one", callback) {
    this.setupAnimation(animationType, callback);
};

LinearDiagram.prototype.hideEmpahsis = function () {
    let baseEmphasisClass = this.nodeProps.emphasisClass ? this.nodeProps.emphasisClass : "clsEmphasis";
    this.diagramParent.removeAttribute("data-emphasis");
    let allNodes = this.diagramParent.querySelectorAll("[name='nodeMainParent']");
    for (let i = 0; i < allNodes.length; i++) {
        allNodes[i].classList.remove("mood");
        allNodes[i].classList.remove(baseEmphasisClass + "DisabledBG");
        allNodes[i].classList.remove(baseEmphasisClass + "Disabled");
        allNodes[i].classList.remove(baseEmphasisClass + "EnabledBG");
        allNodes[i].classList.remove(baseEmphasisClass + "Enabled");
        // allNodes[i].firstElementChild.setAttribute("data-emphasize", "false");
        this.arrDiagramNode[i].nodeGroup.setAttribute("data-emphasize", "false");
        if (this.nodeProps.emphasisShape) {
            let id = "";
            if (this.nodeProps.quoteShape?.type == "counting") {
                id = this.nodeProps.quoteShape.id + (i + 1);
            } else {
                id = this.nodeProps.quoteShape.id;
            }
            let iconHolder = allNodes[i].querySelector("[id='iconHolder" + i + "']");
            if (iconHolder) {
                let useNode = iconHolder.querySelector("[data-id='useNode']");
                if (useNode) useNode.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "#" + id);
            }
            if (this.nodeProps.emphasisShape.sprite) {
                this.enableSpriteElement(i, false);
                if (this.nodeProps.emphasisShape.frame != null) {
                    let spriteHolder = this.arrDiagramNode[i].nodeGroup.querySelector("#spriteHolder" + i);
                    if (spriteHolder.parentElement) this.arrDiagramNode[i].createSpriteElement(spriteHolder.parentElement, 0);
                }
            }
        }
    }
};

LinearDiagram.prototype.updateFloaterOperations = function () {
    this.arrDiagramNode.forEach((nodeItem) => {
        let nodeData = nodeItem.objData;
        if (nodeData.emphasize) {
            // nodeItem.parentNode.setAttribute("data-emphasize", nodeData.emphasize);
            nodeItem.nodeGroup.setAttribute("data-emphasize", this.objData.emphasize);
        }
        if (nodeData.crossout) {
            let contentNode = nodeItem.parentNode.querySelector("[data-id='diagramContentNode']");
            if (contentNode) {
                contentNode.setAttribute("data-crossout", this.objData.crossout);
                contentNode.classList.add("clsCrossoutStyle");
            }
            // nodeItem.parentNode.setAttribute("data-crossout", nodeData.crossout);
        }
        if (nodeData.link) {
            nodeItem.parentNode.setAttribute("data-navigate-to-slide-on-click", nodeData.link);
            // nodeItem.parentNode.classList.add("selectedTextHyperlink");
        } else {
            // nodeItem.parentNode.classList.remove("selectedTextHyperlink");
        }
        for (var key in nodeData.highlightdata) {
            nodeItem.parentNode.setAttribute("data-" + key + "", nodeData.highlightdata[key]);
        }
    });
    // let arrEmphasizeNode = this.arrDiagramNode.filter((node) => node.parentNode.dataset.emphasize == "true");
    // let arrEmphasizeNode = this.arrDiagramNode.filter((node) => node.nodeGroup.dataset.emphasize == "true");
    // if (arrEmphasizeNode.length > 0) this.arrDiagramNode[index].showEmphasis(arrEmphasizeNode[0].parentNode.dataset.index);
};

LinearDiagram.prototype.initPresent = function (currentSlide, boolNoAnimation = false) {
    if (boolNoAnimation) return { isTitleAnimation: false, isGraphicAnimation: false };
    this.diagramParent = currentSlide.querySelector("[id='diagramparent']");

    if (this.diagramParent.parentElement.dataset.animationtype && this.diagramParent.parentElement.dataset.animationtype == "none") return { isTitleAnimation: false, isGraphicAnimation: false };

    if (this.diagramParent) this.diagramParent.style.opacity = 0;
    let animationType = this.diagramParent.parentElement.dataset.animationtype;
    this.oneTimeAnimationType = DiagramAnimateUtil.animationName(this); //this.diagramParent.parentElement.dataset.oneattimeanimationtype || "";

    if (animationType != "all") this.diagramParent.classList.add("clsNonHover");

    if (this.oneTimeAnimationType == "horizontalscale" && this.oneTimeAnimationType != "fullscreenoaa") {
        this.arrDiagramNode.map((node, i) => {
            if (i > 0) {
                let nodeParent = node.getNodeParent().parentElement;
                nodeParent.removeAttribute("data-animation");
                nodeParent.classList.remove("moodanimation");
                let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
                arrObj.map((item) => {
                    item.removeAttribute("data-animation");
                    item.classList.remove("moodanimation");
                });
            }
        });
    } else if (animationType != "all" && animationType != "none" && this.oneTimeAnimationType != "fullscreenoaa") {
        this.arrDiagramNode.map((node, i) => {
            if (i > 0) {
                let nodeParent = node.getNodeParent().parentElement;
                nodeParent.removeAttribute("data-animation");
                nodeParent.classList.remove("moodanimation");
                let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
                arrObj.map((item) => {
                    item.removeAttribute("data-animation");
                    item.classList.remove("moodanimation");
                });
            }
        });
    }

    let isGraphicAnimation = animationType == "all" ? true : false;
    return { isTitleAnimation: true, isGraphicAnimation: isGraphicAnimation };
};

LinearDiagram.prototype.setupAnimation = function (animationType = "one", callback) {
    this.animationIndex = -1;
    this.highlightIndex = -1;
    this.animationType = animationType;

    this.diagramParent.parentElement.setAttribute("data-animationtype", this.animationType);
    this.oneAtTimeAnimationType = this.diagramParent.parentElement.dataset.oneattimeanimationtype || "";
    this.animationCompleteCallback = callback;

    this.oneTimeAnimationType = DiagramAnimateUtil.animationName(this); //this.diagramParent.parentElement.dataset.oneattimeanimationtype || "";
    this.isShowAllNode = this.animationType == "one" && this.oneTimeAnimationType != "fullscreenoaa";
    if (animationType != "all") this.diagramParent.classList.add("clsNonHover");

    if (this.oneTimeAnimationType == "horizontalscale" && this.oneTimeAnimationType != "fullscreenoaa") {
        this.arrDiagramNode.map((node, i) => {
            if (i > 0) {
                let nodeParent = node.getNodeParent().parentElement;
                nodeParent.removeAttribute("data-animation");
                nodeParent.classList.remove("moodanimation");
                let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
                arrObj.map((item) => {
                    item.removeAttribute("data-animation");
                    item.classList.remove("moodanimation");
                });
            }
        });
    } else if (animationType != "all" && this.oneTimeAnimationType != "fullscreenoaa") {
        this.arrDiagramNode.map((node, i) => {
            if (i > 0) {
                let nodeParent = node.getNodeParent().parentElement;
                nodeParent.removeAttribute("data-animation");
                nodeParent.classList.remove("moodanimation");
                let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
                arrObj.map((item) => {
                    item.removeAttribute("data-animation");
                    item.classList.remove("moodanimation");
                });
            }
        });
    }

    this.isReversAnimation = this.checkForArrowReverseAnimation();
    let layoutName = this.diagramParent.dataset.graphiclayoutname;
    if (this.isReversAnimation && layoutName && layoutName == "cir") this.arrDiagramNode.reverse();

    let moodAnimationDisable = this.diagramParent.parentElement.dataset.moodanimation;
    this.animationFactor = moodAnimationDisable && moodAnimationDisable == "none" ? 0 : 1;

    DiagramAnimateUtil.setupAnimation(this.arrDiagramNode, this.diagramParent, this, false);

    this.animateAfterMoodDelay();
};

LinearDiagram.prototype.checkForArrowReverseAnimation = function () {
    let leftArrowAnimation = this.diagramData.nodes.every(
        function (node, i) {
            if (node.customconnector) return node.customconnector.style == "arrowleft";
            else if (i == this.diagramData.nodes.length - 1) return true;
            else return false;
        }.bind(this)
    );
    return this.oneTimeAnimationType != "fullscreenoaa" ? leftArrowAnimation : false;
};

LinearDiagram.prototype.animateAfterMoodDelay = function () {
    this.diagramParent.style.transition = `all ${0.3 * this.animationFactor}s`;
    this.diagramParent.style.opacity = 1;
    DiagramAnimateUtil.animateAfterMoodDelay(this);
    let type = this.diagramParent.parentElement.dataset.oneattimeanimationtype;
    if (type == "" || type == "scale" || type == "fadein" || type == "move" || type == "color" || this.animationType == "one") {
        // this.playNext();
        this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    } else if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
};

LinearDiagram.prototype.getConnectorVisibility = function (element) {
    let connectorParent = element.parentNode.parentElement.querySelector("[name='connectorparent']");
    let visibility = false;
    if (connectorParent) visibility = connectorParent.style.display == "flex";
    else visibility = this.diagramData.properties.hasconnector;
    return visibility;
};

LinearDiagram.prototype.recalculateheight = function (showValidateMessage = true) {
    let length = this.arrDiagramNode.length;
    let nodeGap = DiagramNodeUtils.getGapForConnectors(this.nodeProps, length, this.diagramParent, this.diagramData?.properties);
    if (nodeGap) this.diagramParent.style.setProperty("--seperatorMinHeight", nodeGap + "px");
    if (this.nodeProps && this.nodeProps.nodealignment && (this.nodeProps.nodealignment == "autocenterfixed" || this.nodeProps.nodealignment == "autoleftalign")) {
        let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
        if (nodesHolder) nodesHolder.style.gap = nodeGap + "px";
        this.diagramParent.style.setProperty("--nodeParentHeight", this.diagramParent.clientHeight / length - (nodeGap * (length - 1)) / length + "px");
    } else if (this.nodeProps && this.nodeProps.nodealignment && this.nodeProps.nodealignment.includes("staggered")) {
        let maxWidthPercent = this.nodeProps.nodealignment.split(",")[1];
        let remainingWidth = this.diagramParent.clientWidth - this.diagramParent.clientWidth * (maxWidthPercent / 100);
        let portionWidth = remainingWidth / (length - 1);
        this.arrDiagramNode.forEach((element, index) => {
            element.parentNode.parentElement.style.setProperty("max-width", maxWidthPercent + "%", "important");
            element.parentNode.parentElement.style.setProperty("margin-left", portionWidth * index + "px", "important");
        });
    } else if (this.nodeProps && this.nodeProps.nodealignment && this.nodeProps.nodealignment.includes("agenda")) {
        let columnCount = 1;
        this.diagramParent.style.setProperty("--columnWidth", 100 + "%");
        let gap = nodeGap || this.diagramParent.getAttribute("data-nodegap");
        this.diagramParent.style.setProperty("--agendaNodeGap", gap + "px");
        let arrData = [];
        this.arrDiagramNode.forEach((element, index) => {
            if (!arrData.includes(element.parentNode.parentElement.offsetLeft + "Node")) {
                columnCount = columnCount + 1;
                arrData.push(element.parentNode.parentElement.offsetLeft + "Node");
            }
        });
        let maxColumns = 3;
        let setColumnCount = () => {
            let length = arrData.length >= maxColumns ? maxColumns : arrData.length;
            this.diagramParent.style.setProperty("--columnWidth", "calc(1/" + length + "*100% - (1 - 1/" + length + ")*" + gap + "px)");
            this.diagramParent.setAttribute("data-columncount", length);
            this.diagramParent.style.setProperty("--nodeParentHeight", this.diagramParent.clientHeight + "px");
        };
        setColumnCount();
        // Check for text overflow than container width and readjust column count
        let allTextNodes = this.diagramParent.querySelectorAll("[data-name='text']");
        let reAdjustColumnCount = false;
        allTextNodes.forEach((element, index) => {
            if (element.scrollWidth > element.clientWidth) {
                reAdjustColumnCount = true;
            }
        });
        if (reAdjustColumnCount && arrData.length > 1) {
            arrData.pop();
            setColumnCount();
        }
        setTimeout(() => {
            // Hide the overflowed nodes
            this.arrDiagramNode.forEach((element, index) => {
                if (element.parentNode.parentElement.offsetLeft > this.diagramParent.clientWidth) {
                    element.parentNode.parentElement.style.setProperty("visibility", "hidden");
                } else {
                    element.parentNode.parentElement.style.removeProperty("visibility");
                }
            });
            this.updatePropsCallBack();
        }, 0);
    } else if ((this.nodeProps && this.nodeProps.nodealignment && (this.nodeProps.nodealignment.includes("split") || this.nodeProps.nodealignment.includes("auto"))) || (this.nodeProps && this.nodeProps.devicealignment && this.nodeProps.devicealignment == "left"))
        if (this.arrDiagramNode && this.arrDiagramNode.length > 0) {
            let arrIndex = [];
            let padding = nodeGap ? nodeGap : 20;
            let marginLeft = 0;
            this.diagramParent.style.setProperty("--paddingSplit", padding + "px");
            this.diagramParent.style.setProperty("--marginSplit", marginLeft + "px");
            let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
            if (nodesHolder) {
                nodesHolder.style.gap = padding + "px";
            }
            let divideFactor = length <= 3 ? length : length <= 9 ? 3 : 4;
            divideFactor = this.nodeProps.nodealignment && this.nodeProps.nodealignment.includes("auto") ? length : divideFactor;
            let maxHeight = this.nodeProps.nodeclassName == "VerticalSplitColumnDiagramNode" ? this.diagramParent.clientHeight : this.diagramParent.clientHeight / divideFactor - (padding / length) * length;
            this.diagramParent.style.setProperty("--nodeParentHeight", maxHeight + "px");
            let recalcColumn = () => {
                let nodeItemFirst = this.arrDiagramNode[0].parentNode;
                let leftfirst = nodeItemFirst.getBoundingClientRect().left;

                this.arrDiagramNode.forEach((element, index) => {
                    let leftCurrent = element.parentNode.getBoundingClientRect().left;
                    if (leftfirst != leftCurrent) {
                        leftfirst = leftCurrent;
                        arrIndex.push(index);
                    }
                });

                if (arrIndex.length > 0) {
                    let maxColumns = arrIndex.length > 2 ? 2 : arrIndex.length;
                    let centerFixed = 2;
                    let length = maxColumns >= centerFixed ? centerFixed : maxColumns;
                    let maxNodeWidth = this.diagramParent.parentElement.clientWidth / (length + 1);
                    this.diagramParent.style.setProperty("--nodeParentWidth", maxNodeWidth - marginLeft - (padding / length) * length + "px");
                    this.diagramParent.style.setProperty("--nodesHolderMinWidth", "30%");
                    this.diagramParent.style.setProperty("--nodesHolderJustify", "flex-start");
                } else {
                    this.diagramParent.style.setProperty("--nodeParentWidth", "100%");
                    this.diagramParent.style.setProperty("--nodesHolderJustify", "center");
                    this.diagramParent.style.setProperty("--nodesHolderMinWidth", "30%");
                }
            };
            recalcColumn();
            this.updateTextNodes();
            recalcColumn();
        }
    this.checkAgendaOverflow(nodeGap || this.diagramParent.getAttribute("data-nodegap"));
    if (showValidateMessage) {
        this.resetNodeAttributes();
    } else {
        this.updateTextNodes();
    }
};

//Highlight functions

LinearDiagram.prototype.checkHighlight = function (parent) {
    let diagramNodes = parent.querySelectorAll("[name='nodeparent']");
    for (let n = 0; n < diagramNodes.length; n++) {
        if (diagramNodes[n].dataset.highlight == "true") this.setHighlightTargetPoints(diagramNodes[n], parent);
    }
};

LinearDiagram.prototype.setHighlightTargetPoints = function (node, parent) {
    this.setSlideScale();
    let alignment;
    let diagramType = parent.dataset.diagramtype;
    alignment = diagramType == "horizontal" ? "vertical" : "horizontal";

    if (this.setHighlightPosition) {
        let nodeInfo = this.setHighlightPosition(node);
        alignment = nodeInfo.alignment;
    }

    let element;
    let arrHolders = ["iconHolder", "imageHolder", "imageSecHolder", "valueTitleHolder", "seqTitleHolder", "microChartHolder", "textTitleHolder"];
    arrHolders.find((item) => {
        let target = node.querySelector("[name='" + item + "']");
        let bool = target && target.clientHeight != 0 && target.clientWidth != 0;
        if (bool) element = target;
        return bool;
    });
    element = element || node;

    let targetBounds = element.getBoundingClientRect();
    let viewPortBounds = parent.getBoundingClientRect();

    let objStyleData = window.getComputedStyle(parent);
    let objStyleElementData = window.getComputedStyle(element);

    viewPortBounds.x = parseFloat(objStyleData["x"].split("px")[0]);
    viewPortBounds.y = parseFloat(objStyleData["y"].split("px")[0]);
    viewPortBounds.width = parseFloat(objStyleData["width"].split("px")[0]);
    viewPortBounds.height = parseFloat(objStyleData["height"].split("px")[0]);

    const { left, top } = getOffset(element, this.slideScale);
    targetBounds.x = left;
    targetBounds.y = top;
    targetBounds.width = parseFloat(objStyleElementData["width"].split("px")[0]);
    targetBounds.height = parseFloat(objStyleElementData["height"].split("px")[0]);

    if (alignment == "lineargrid") {
        targetBounds.x = node.style.gridColumnStart * 4;
        targetBounds.y = node.style.gridRowStart * 4;
        targetBounds.width = node.style.gridColumnEnd * 4 - targetBounds.x;
        targetBounds.height = node.style.gridRowEnd * 4 - targetBounds.y;
        alignment = "horizontal";
    }

    node.setAttribute("data-highlighttargetbounds", JSON.stringify(targetBounds.toJSON()));
    node.setAttribute("data-highlightviewportbounds", JSON.stringify(viewPortBounds.toJSON()));
    node.setAttribute("data-alignment", alignment);

    function getOffset(element, slideScale) {
        let slide = element.closest("[data-type='SLIDE']");
        const sliderect = slide.getBoundingClientRect();
        const rect = element.getBoundingClientRect();
        if (window.isChromeZoomRequired) slideScale = 1;
        let left = (rect.left - sliderect.left) / slideScale;
        let top = (rect.top - sliderect.top) / slideScale;

        return { left, top };
    }
};

//oneAtTime oneAfterAnother
LinearDiagram.prototype.playNext = function (index) {
    if (this.gotoNextSlide) return false;
    this.animationIndex += 1;
    this.animationIndex = this.animationIndex < 0 ? 0 : this.animationIndex;
    if (this.animationIndex >= this.diagramData.nodes.length) {
        this.animationIndex = this.diagramData.nodes.length - 1;
        if (this.isShowAllNode) {
            this.animationIndex = this.diagramData.nodes.length;
            this.isShowAllNode = false;
            this.isPreviousFromAllNode = this.animationType == "one" && (this.oneAtTimeAnimationType != "fadein" || this.oneAtTimeAnimationType != "");
            let delay = DiagramAnimateUtil.updateAllNodeAnimation("show", this.arrDiagramNode, this.diagramParent, "next", this);
            this.updateAllNodesInOneAtTime("next");
            setTimeout(() => {
                if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
            }, delay * 1000);
            return true;
        }
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        this.gotoNextSlide = true;
        return false;
    }

    this.gotoPreviousSlide = false;
    this.gotoNextSlide = false;
    let node = this.arrDiagramNode[this.animationIndex];
    let completionDelay = DiagramAnimateUtil.playNext(this.arrDiagramNode, this.animationIndex, this.diagramParent, node, this);
    this.animateArrowForward(this.animationIndex);
    if (node.getNodeParent().dataset.highlight && node.getNodeParent().dataset.highlight == "true") {
        this.isShowHighlight = true;
        this.highlightIndex = parseInt(node.getNodeParent().dataset.index);
    }

    setTimeout(() => {
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, completionDelay * 1000);
    return true;
};

LinearDiagram.prototype.playPrevious = function (index) {
    if (this.gotoPreviousSlide) return;
    // if (this.animationIndex <= 0 && this.animationType == "one" && this.oneTimeAnimationType != "fullscreenoaa") {
    //     if (this.animationType == "one" && this.animationIndex == 0) {
    //         this.isShowHighlight = false;
    //         this.animationIndex = -1;
    //         let delay = DiagramAnimateUtil.updateAllNodeAnimation("hide", this.arrDiagramNode, this.diagramParent, "previous", this);
    //         this.updateAllNodesInOneAtTime("previous");
    //         setTimeout(() => {
    //             if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    //         }, delay * 1000);
    //         return true;
    //     }
    //     this.animationIndex = 0;
    //     this.gotoPreviousSlide = true;
    //     return false;
    // } else
    if (this.animationIndex <= 0) {
        this.gotoPreviousSlide = true;
        return false;
    } else if ((this.oneTimeAnimationType == "horizontalscale" || this.oneTimeAnimationType == "fullscreenoaa") && this.animationIndex <= 0) {
        this.gotoPreviousSlide = true;
        return false;
    }

    this.gotoPreviousSlide = false;
    this.gotoNextSlide = false;
    this.animationIndex -= 1;
    this.isShowAllNode = this.animationType == "one" && this.oneTimeAnimationType != "fullscreenoaa";
    let itemindex = this.isShowAllNode ? this.animationIndex : this.animationIndex + 1;

    // if (this.isPreviousFromAllNode) this.animationIndex = this.arrDiagramNode.length-1;
    let node = this.arrDiagramNode[itemindex];
    let completionDelay = DiagramAnimateUtil.playPrevious(this.arrDiagramNode, this.animationIndex, this.diagramParent, node, this.isPreviousFromAllNode, this);
    this.animateArrowBackward(itemindex);
    this.isPreviousFromAllNode = false;
    let highlightNode = this.isShowAllNode ? node : this.arrDiagramNode[itemindex - 1];
    if (highlightNode && highlightNode.getNodeParent().dataset.highlight && highlightNode.getNodeParent().dataset.highlight == "true") {
        this.isShowHighlight = true;
        this.highlightIndex = parseInt(highlightNode.getNodeParent().dataset.index);
    } else {
        this.isShowHighlight = false;
        this.highlightIndex = -1;
    }
    setTimeout(() => {
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, completionDelay * 1000);

    return true;
};

LinearDiagram.prototype.playAllAtOnce = function () {};

LinearDiagram.prototype.playAllAtOnceReverse = function () {};

LinearDiagram.prototype.createExport = function (node, slideID, arrElements) {
    let intCount = this.nodeProps.supportedNodes.length;
    for (let i = 0; i < intCount; i++) {
        let nodeObj = this.nodeProps.supportedNodes[i];
        this.createNodes(nodeObj, node, slideID, arrElements);
        if (nodeObj.subNodes) {
            this.createNestedNodes(nodeObj.subNodes, node, slideID, arrElements);
        }
    }
};

LinearDiagram.prototype.createNestedNodes = function (subNodes, node, slideID, arrElements) {
    for (let j = 0; j < subNodes.length; j++) {
        let nodeObj = subNodes[j];
        this.createNodes(nodeObj, node, slideID, arrElements);
        if (nodeObj.subNodes) {
            this.createNestedNodes(nodeObj.subNodes, node, slideID, arrElements);
        }
    }
};

LinearDiagram.prototype.createNodes = function (nodeObj, nodeParent, slideID, arrElements) {
    let name = nodeObj.name;
    let nodeItem = nodeParent.querySelector("[name='" + name + "']");
    switch (name) {
        case "seqTitleHolder":
        case "titleHolder":
        case "subTitleHolder":
        case "seqTitleHolder":
        case "textTitleHolder":
            let title = nodeParent.querySelector("[name='" + name + "']");
            if (title) {
                let objRect = ExportUtils.getRectValue(title, slideID, name, arrElements);
                let textNode = title.querySelector("[data-name='text']");
                let allSingleSVG = textNode.querySelectorAll("svg");
                if (allSingleSVG && allSingleSVG.length > 0) {
                } else {
                    ExportUtils.addStyleElement(arrElements, ExportUtils.getMetaData(textNode, slideID));
                }
            }
            break;

        case "valueTitleHolder":
            let titleval = nodeParent.querySelector("[name='" + name + "']");
            if (titleval) {
                ExportUtils.getRectValue(titleval, slideID, name, arrElements);
                let textNode = titleval.querySelector("[data-name='text']");
                if (textNode) {
                    let textNodes = textNode.querySelectorAll("span");
                    let svg = textNode.querySelectorAll("svg");

                    if (textNodes.length > 0) {
                        textNodes.forEach((element) => {
                            ExportUtils.addStyleElement(arrElements, ExportUtils.getMetaData(element, slideID));
                        });
                    } else if (!svg || svg.length == 0) {
                        ExportUtils.addStyleElement(arrElements, ExportUtils.getMetaData(textNode, slideID));
                    }
                }
            }
            break;

        case "secContentNode":
            if (nodeItem) {
                ExportUtils.getRectValue(nodeItem, slideID, name, arrElements);
            }
            break;
        case "contentNode":
        case "moodNode":
        case "secSubContentNode":
            ExportUtils.getRectValue(nodeItem, slideID, name, arrElements);

            let contentBackgound = nodeParent.querySelector("[name='contentBackgound']");
            if (contentBackgound) {
                let objRect = ExportUtils.getRectValue(contentBackgound, slideID, "secContentBackgound", arrElements);
                objRect.description = "contentBackgound for " + name;
                if (contentBackgound.parentElement) {
                    let styleData = window.getComputedStyle(contentBackgound.parentElement);
                    if (styleData["border-radius"] && styleData["border-radius"] != "" && styleData["border-radius"] != undefined) {
                        let newradius = parseFloat((styleData["border-radius"] || "0").replace("px", ""));
                        let radius = parseFloat((objRect.style["border-radius"] || "0").replace("px", ""));
                        if (radius == 0 && newradius != 0) {
                            objRect.style["border-radius"] = styleData["border-radius"];
                        }
                    }
                    if (styleData["box-shadow"] && styleData["box-shadow"] != "" && styleData["box-shadow"] != undefined && (!objRect.style["border-radius"] || objRect.style["border-radius"] == "none")) {
                        objRect.style["box-shadow"] = styleData["box-shadow"];
                    }
                }

                let svgBG = contentBackgound.querySelector("svg");
                if (svgBG) {
                    let svgBGData = ExportUtils.getDeviceBG(svgBG, svgBG.parentElement, slideID, "SVG Content BG - Device - Award SVGs");
                    ExportUtils.addStyleElement(arrElements, svgBGData);
                }
            }
            break;
        case "imageHolder":
        case "imageSecHolder":
            if (nodeItem) {
                let image = nodeItem.querySelector("[data-id='imageNode']") || nodeItem.querySelector("[data-id='logoNode']");
                if (image) {
                    ExportUtils.getImageData(arrElements, image, nodeItem, slideID, name);
                }

                let imageOverlay = nodeParent.querySelector("[data-id='imageOverlay']");
                if (imageOverlay) {
                    ExportUtils.getRectValue(imageOverlay, slideID, "imageOverlay", arrElements);
                }
            }

            break;
        case "iconHolder":
            let iconHolder = nodeParent.querySelector("[name='" + name + "']");
            if (iconHolder) {
                ExportUtils.getRectValue(iconHolder, slideID, "IconHolder", arrElements);
                let iconBG = nodeParent.querySelector("[name='iconBG']");
                if (iconBG) {
                    ExportUtils.getRectValue(iconBG, slideID, "IconBG", arrElements);
                }
                let iconNode = iconHolder.querySelector("[data-id='iconNode']");
                let iconData = ExportUtils.getIconData(iconNode, iconNode.parentElement, slideID, name, this.nodeProps.iconPadding);
                ExportUtils.addStyleElement(arrElements, iconData);
            }
            break;
        case "iconSecHolder":
        case "microChartHolder":
        case "shapeHolder":
            let microChartHolder = nodeParent.querySelector("[name='" + name + "']");
            if (microChartHolder) {
                let iconNode = microChartHolder.querySelector("svg");
                let iconData = ExportUtils.getSVGData(iconNode, iconNode.parentElement, slideID, name);
                ExportUtils.addStyleElement(arrElements, iconData);

                let textNode = microChartHolder.querySelector("[data-id='microchartNode']");
                if (textNode) {
                    let textNodes = textNode.querySelectorAll("span");
                    if (textNodes.length > 0) {
                        textNodes.forEach((element) => {
                            ExportUtils.addStyleElement(arrElements, ExportUtils.getMetaData(element, slideID));
                        });
                    } else {
                        ExportUtils.addStyleElement(arrElements, ExportUtils.getMetaData(textNode, slideID));
                    }
                }
            }
        default:
            break;
    }
};

LinearDiagram.prototype.animateArrowForward = function (index) {};

LinearDiagram.prototype.animateArrowBackward = function (index) {};

LinearDiagram.prototype.updateAllNodesInOneAtTime = function (direction = "next") {};

LinearDiagram.prototype.isChildOfParent = function (child, parent) {
    let isParent = false;
    let childParent = child.parentElement;
    try {
        while (childParent != this.diagramParent) {
            if (childParent == parent) {
                isParent = true;
                break;
            }
            if (!childParent || !childParent.parentElement) break;
            childParent = childParent.parentElement;
        }
    } catch (error) {
        console.log(error);
    }

    return isParent;
};

// Inline floater content Option

LinearDiagram.prototype.getSeletion = function (centernodetype, type) {
    let selection = {};
    let selectedContent = centernodetype ? centernodetype : "icon";

    let arrContent = this.nodeProps.supportedNodes.filter((node) => node.name == "contentNode");
    if (type == "centerNode") {
        arrContent = this.nodeProps.centerNode;
    } else if (arrContent.length > 0) {
        arrContent = arrContent[0].subNodes;
        if (this.diagramParent.dataset.contenttype) selectedContent = this.diagramParent.dataset.contenttype;
    } else if (arrContent.length > 0) {
        return selection;
    }
    if (!arrContent) return selection;
    // bulletHolder
    if (type != "centerNode") selection["none"] = { floaterproperty: "none", label: "none", value: selectedContent == "none", visible: true };
    let selectedIndex = 0;
    let arrOption = arrContent.map(function (contentObj, i) {
        let data;
        if (contentObj.name.includes("iconHolder")) {
            data = { data: "icon", label: "Icon", icon: "ic_icon_graphics" };
        } else if (contentObj.name.includes("imageHolder")) {
            data = { data: "image", label: "Image", icon: "ic_image_rect_outline" };
        } else if (contentObj.name.includes("imageSecHolder")) {
            data = { data: "logo", label: "Logo", icon: "ic_logo" };
        } else if (contentObj.name.includes("valueTitleHolder")) {
            data = { data: "number", label: "Number", icon: "ic_data_type_number" };
        } else if (contentObj.name.includes("textTitleHolder")) {
            data = { data: "text", label: "Text", icon: "ic_text" };
        } else if (contentObj.name.includes("seqTitleHolder")) {
            data = { data: "sequence", label: "Sequence", icon: "appicons/ic_icon_graphics.svg" };
        } else if (contentObj.name.includes("checkListHolder")) {
            data = { data: "checklist", label: "Checklist", icon: "ic_checklist" };
        } else if (contentObj.name.includes("bulletHolder")) {
            data = { data: "bulletlist", label: "Bulletlist", icon: "appicons/ic_icon_graphics.svg" };
        }
        selectedIndex = centernodetype == data.data ? i : selectedIndex;
        return data;
    });

    return { options: arrOption, selectedindex: selectedIndex };
};

LinearDiagram.prototype.setHolderType = function (contenttype, holder) {
    let key = holder == "centerNode" ? "data-centerholdertype" : "data-contentholdertype";
    switch (contenttype) {
        case "none":
            this.diagramParent.setAttribute(key, "noneHolder");
            break;
        case "icon":
            this.diagramParent.setAttribute(key, "iconHolder");
            break;
        case "image":
            this.diagramParent.setAttribute(key, "imageHolder");
            break;
        case "logo":
            this.diagramParent.setAttribute(key, "imageSecHolder");
            break;
        case "number":
            this.diagramParent.setAttribute(key, "valueTitleHolder");
            break;
        case "text":
            this.diagramParent.setAttribute(key, "textTitleHolder");
            break;
        case "sequence":
            this.diagramParent.setAttribute(key, "seqTitleHolder");
            break;
        case "checklist":
            this.diagramParent.setAttribute(key, "checkListHolder");
            break;
        case "bulletlist":
            this.diagramParent.setAttribute(key, "bulletHolder");
            break;
        default:
            break;
    }
    this.diagramParent.setAttribute("data-centernodetype", contenttype);
    if (this.diagramData && this.diagramData.properties) this.diagramData.properties.contentholdertype = this.diagramParent.dataset.contentholdertype;
};

LinearDiagram.prototype.contentChange = function (operation) {
    if (operation.targetid && operation.targetid.includes("center")) {
        if (this.diagramParent.dataset.centernodetype && this.diagramParent.dataset.centernodetype == operation.value) return;
        this.diagramParent.setAttribute("data-centernodetype", operation.value);
        this.diagramData.properties.centernodetype = operation.value;
        this.setHolderType(operation.value, "centerNode");
        let centerNode = this.diagramParent.querySelector("[data-id='centerNode']") || this.diagramParent.querySelector("[data-id='centerHolderParent']");
        if (!centerNode) return;
        centerNode.innerHTML = "";
        if (centerNode.dataset.id.includes("centerHolderParent")) {
            let parentElement = centerNode.parentElement;
            centerNode.remove();
            let nodeData = DiagramNodeUtils.diagramContentData(operation.value, this.appStaticURL, this.arrDefaults, 0);
            this.createCenterHolder?.(parentElement, nodeData);
        } else {
            let nodeData = DiagramNodeUtils.diagramContentData(operation.value, this.appStaticURL, this.arrDefaults, 0);
            this.createCenterElements?.(centerNode, nodeData);
        }
        this.updateEvents();
        this.updateNodePosition?.();
    } else {
        this.diagramParent.setAttribute("data-contenttype", operation.value.type);
        this.diagramData.properties.contenttype = operation.value.type;
        let iconHolderObj = DiagramUtils.getObjectFromName(this.nodeProps.supportedNodes, operation.value.type == "logo" ? "imageSecHolder" : operation.value.type + "Holder");
        let moodData = this.globalMoodData?.basicgraphics;
        this.diagramData.properties[operation.value.type + "size"] = iconHolderObj && iconHolderObj.size ? iconHolderObj.size : moodData[operation.value.type + "size"] ? moodData[operation.value.type + "size"] : this.diagramData.properties[operation.value.type + "size"];

        this.setHolderType(operation.value.type, "subNode");

        const nodeCount = this.diagramData.nodes.length;
        let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
        this.arrDiagramNode.map(function (node) {
            nodeHolder.removeChild(node.getNodeParent().parentElement);
        });
        this.arrDiagramNode = [];
        this.createNodeInstances(nodeCount, nodeHolder);
        this.diagramData.properties.contenttype = operation.value.type;
        this.diagramData.properties.diagramcontent = operation.value.type == "none" || operation.value.type == "sequence" ? false : true;
        this.diagramData.properties.sequencetext = operation.value.type == "sequence" ? true : false;
        this.diagramParent.setAttribute("data-contenttype", operation.value.type);
        this.diagramParent.setAttribute("data-sequencetext", this.diagramData.properties.sequencetext);
        this.diagramParent.setAttribute("data-diagramcontent", this.diagramData.properties.diagramcontent);
        this.updateJSONData();
        this.updateSpecialOperations();
        this.updateEmphasize();
        this.slideDimensionChange();
        this.resetNodeAttributes();
        this.updateEvents();
    }
};

// Connectors related codes

LinearDiagram.prototype.showHideArrows = function (value) {
    DiagramUtils.toggleConnectors(this.diagramData.properties, "hasconnector", value);
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "connector", value, true);
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "seperatorline", false, true);
    if (!value) this.showHideConnectorText(false);
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
    // if (this.recalculateWidth) this.recalculateWidth();
};

LinearDiagram.prototype.showHideConnectorText = function (value) {
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "connectortext", value, true);
    this.diagramData.properties.connectortext = value;
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
    // if (this.recalculateWidth) this.recalculateWidth();
};

LinearDiagram.prototype.changeConnectorTextPosition = function (value) {
    value = value.data;
    let arrConnectorText = this.diagramParent.querySelectorAll("[name='connectortext']");
    arrConnectorText.forEach(function (connectorText, index) {
        let position = value && value == "alternate" ? (index % 2 ? "bottom" : "top") : value || "top";
        connectorText.setAttribute("data-position", position);
    });
    this.nodeProps.connectortext.position = value;
    this.updateNodeProperties();
    this.resetLayout();
    // if (this.recalculateWidth) this.recalculateWidth();
};

LinearDiagram.prototype.showHideSeperatorLine = function (value) {
    DiagramUtils.toggleConnectors(this.diagramData.properties, "seperatorline", value);
    this.updateProperties(this.diagramData.properties);
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "seperatorline", value, true);
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "connector", false, true);
    this.resetLayout();
};

LinearDiagram.prototype.redrawPositionConnectors = function (nodeCount) {
    if (this.nodeProps && (this.diagramData.properties.hasconnector || this.diagramData.properties.seperatorline)) {
        let node = this.arrDiagramNode[0];
        let connectorNode = this.diagramParent.querySelector("[id='connector0']");
        if (node && connectorNode) {
            // this.updateTextNodes(); check and remove this
            DiagramNodeUtils.parseCssCustomConnector(connectorNode, node.parentNode.parentElement, this.nodeProps, nodeCount, this.diagramData.properties);
            this.alignArrowOnFocus(0);
        }
    }
};

LinearDiagram.prototype.checkConnectorVisible = function () {
    let className = this.diagramParent.dataset.classname;
    if (!DiagramUtils.isConnectorSupported(className, this.nodeProps)) return;
    let hasConnectorDisabled = this.diagramData.properties && this.diagramData.properties.floateroptionsdisable && this.diagramData.properties.floateroptionsdisable.includes("connector");
    if (this.diagramData.properties.hasconnector && !hasConnectorDisabled) {
        this.diagramParent.classList.remove("clsconnectordisable");
        this.diagramParent.classList.add("clsconnectorenable");
        this.alignArrowOnFocus(0);
    } else {
        this.diagramParent.classList.add("clsconnectordisable");
        this.diagramParent.classList.remove("clsconnectorenable");
    }
};

LinearDiagram.prototype.checkConnectorTextVisible = function () {
    let className = this.diagramParent.dataset.classname;
    if (!DiagramUtils.isConnectorTextSupported(className, this.nodeProps)) return;
    let hasConnectorDisabled = this.diagramData.properties && this.diagramData.properties.floateroptionsdisable && this.diagramData.properties.floateroptionsdisable.includes("connectortext");
    if (this.diagramData.properties.connectortext && !hasConnectorDisabled) {
        this.diagramParent.classList.remove("clsconnectortextdisable");
        this.diagramParent.classList.add("clsconnectortextenable");
        this.alignArrowOnFocus(0);
    } else {
        this.diagramParent.classList.add("clsconnectortextdisable");
        this.diagramParent.classList.remove("clsconnectortextenable");
    }
};

LinearDiagram.prototype.alignArrowOnFocus = function (index) {
    if (this.appmode.toLowerCase() == "present" || index == undefined || index == null) return;
    let hasconnector = this.diagramData.properties.hasconnector;
    if (!hasconnector) return;
    // this.updateTextNodes();
    let parentNode = this.diagramParent.querySelector("[id='nodeparent" + index + "']");
    let connectorNode = this.diagramParent.querySelector("[id='connector0']");
    if (connectorNode && parentNode) {
        let connectorMinGap = DiagramNodeUtils.getGapForConnectors(this.nodeProps, index, this.diagramParent, this.diagramData.properties, true);
        let gap = DiagramNodeUtils.getGapForConnectors(this.nodeProps, index, this.diagramParent, this.diagramData.properties);
        DiagramNodeUtils.alignCssArrowNode(this.nodeProps, parentNode, connectorNode, gap, connectorMinGap);
    }
    let connectorTextNode = this.diagramParent.querySelector("[id='connectortext" + index + "']");
    if (connectorTextNode) {
        // let connectorTextData = this.getCustomConnectorText(i);
        let connectorTextData = connectorTextNode.innerText;
        this.diagramData.nodes[index].customconnectortext = connectorTextData;
        this.arrDiagramNode[index].objData.customconnectortext = connectorTextData;
    }
};

LinearDiagram.prototype.updateConnector = function (connectorData, index) {
    let node = this.arrDiagramNode[index];
    this.diagramData.nodes[index].customconnector = connectorData;
    if (!node.connectorNode) node.connectorNode = this.diagramParent.querySelector("[id='connector" + index + "']");
    node.connectorNode.setAttribute("data-customconnectorstyle", connectorData.style);
    node.connectorNode.setAttribute("class", "nodeconnector moodanimation " + "cls" + connectorData.style);
    DiagramNodeUtils.parseCssCustomConnector(node.connectorNode, node.parentNode.parentElement, this.nodeProps, this.arrDiagramNode.length, this.diagramData.properties);
    this.updatePropsCallBack();
};

LinearDiagram.prototype.changeArrow = function (value) {
    let connectors = this.diagramParent.querySelectorAll("[name='connector']");
    connectors.forEach((element) => {
        element.setAttribute("class", "nodeconnector moodanimation " + "cls" + value);
        element.setAttribute("data-customconnectorstyle", value);
    });
    this.nodeProps.connector.style = value;
    this.diagramData.properties.arrow = null;
    this.diagramData.properties.connectorstyle = value;
    if (value != "arrownone" && this.nodeProps?.connectortext?.position?.includes("inline")) {
        this.changeConnectorTextPosition("top");
    }
    this.diagramParent.setAttribute("data-connectorstyle", value);
    this.arrDiagramNode.forEach((obj, index) => {
        obj.properties.connectorstyle = value;
        obj.objData.customconnector = null;
        this.diagramData.nodes[index].customconnector = null;
    });
    this.resetHolderWidth();
    this.updateTextNodes();
};

LinearDiagram.prototype.updateNodeLink = function (valueObj) {
    DiagramUtils.updateNodeLink(valueObj.parent, valueObj.operation);
};

LinearDiagram.prototype.changeLogoContrast = function (valueObj, target, nodeGroup, logoGridIndex) {
    let logoNode = target.querySelector("[data-id='logoNode']");
    if (target.dataset.componentType && target.dataset.componentType == "grid") {
        this.arrDiagramNode[logoGridIndex]?.gridInstance?.changeLogoGridContrast(logoNode, valueObj.value, target.dataset.imagegridIndex);
    } else {
        DiagramUtils.setLogoContrast(logoNode, nodeGroup, valueObj.value);
    }
};

LinearDiagram.prototype.updateTextSize = function (valueObj, targetNode) {
    if (targetNode) {
        let isReset = valueObj.value == "auto" || valueObj.value == "reset";
        let isQuillAsset = targetNode?.id?.includes("ql-editor");
        if (isQuillAsset) {
            if (isReset) targetNode.style.removeProperty("font-size");
            else targetNode.style.fontSize = valueObj.value;
            Array.from(targetNode?.children)?.forEach((element) => {
                if (element.tagName == "UL" || element.tagName == "OL") {
                    Array.from(element?.children)?.forEach((liElement) => {
                        if (isReset) liElement.style.removeProperty("font-size");
                        else liElement.style.fontSize = "unset";
                    });
                } else {
                    if (isReset) element.style.removeProperty("font-size");
                    else element.style.fontSize = "unset";
                }
            });
        } else {
            if (isReset) {
                targetNode.style.removeProperty("font-size");
                if (targetNode?.dataset?.id == "numberNode") {
                    targetNode.parentElement.parentElement.style.removeProperty("height");
                    targetNode.parentElement.parentElement.style.removeProperty("max-height");
                    targetNode.parentElement.style.removeProperty("height");
                    targetNode.parentElement.style.removeProperty("max-height");
                } else if (targetNode?.dataset?.id == "microchartNode") {
                    targetNode.style.removeProperty("height");
                }
            } else targetNode.style.fontSize = valueObj.value;
            let maxHeight = getComputedStyle(targetNode.parentElement).maxHeight;
            if (maxHeight && parseFloat(maxHeight) < parseFloat(valueObj.value)) targetNode.parentElement.style.maxHeight = valueObj.value;
            if (targetNode?.dataset?.id == "numberNode") {
                targetNode.parentElement.parentElement.style.setProperty("height", valueObj.value, "important");
                targetNode.parentElement.parentElement.style.setProperty("max-height", valueObj.value, "important");
                targetNode.parentElement.style.maxHeight = valueObj.value;
                targetNode.parentElement.style.height = valueObj.value;
            } else if (targetNode?.dataset?.id == "microchartNode") {
                targetNode.style.height = valueObj.value;
            }
        }
        this.updateTextNodes();
        this.resetLayout();
    }
};

/**
 * Author:    Saravanan G
 * Created:   3.10.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function BaseDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    this.diagramParent = diagramParent;
    this.diagramData = diagramData;
    this.moodData = moodData;
    this.nodeProps = nodeProps;
    this.eventManagerXY = new window["DiagramEventManager"]();
    this.appStaticURL = "";
    this.appmode = "";
    this.moodName = "";
    this.arrDiagramNode = [];
    this.slideScale = 1;
    this.objStyleData = {};
    window.arrIconAssets = window.arrIconAssets ? window.arrIconAssets : {};
    this.mainTime = new Date().getTime();
    this.defaultFoucsOut = this.defaultFoucsOut.bind(this);
    this.defaultFoucsIn = this.defaultFoucsIn.bind(this);
    this.defaultCheckBoxEvent = this.defaultCheckBoxEvent.bind(this);
    this.diagramPasteHandler = this.diagramPasteHandler.bind(this);
    this.textHighlightMouseUpEvent = this.textHighlightMouseUpEvent.bind(this);
    this.onHoverNode = this.onHoverNode.bind(this);
    this.onHoverOutNode = this.onHoverOutNode.bind(this);
    this.searchIconCallBack = this.searchIconCallBack.bind(this);

    this.animationType = "all";
    this.oneTimeAnimationType = "";
    this.isShowAllNode = false;
    this.animationIndex = 0;
    this.highlightIndex = -1;
    this.isShowHighlight = false;
    this.isHideHighlight = false;
    this.oldDirection = "front";
    this.newDirection = "back";
    this.gotoNextSlide = false;
    this.gotoPreviousSlide = false;
    this.oneAtTimeAnimationType = "";
    this.isPreviousFromAllNode = false;
    this.isReversAnimation = true;
    this.isTakeAway = false;

    // Default class names to be added.
    this.diagramParent.className = "clsPlainDiagram";
    let globalClassName = this.diagramParent?.parentElement?.getAttribute("data-globalclass");
    if (this.diagramParent.parentElement.className.includes("coverImageParent")) this.diagramParent.parentElement.className = this.diagramParent.parentElement.className + " clsElementDiv commonallmood ";
    else this.diagramParent.parentElement.className = "clsElementDiv commonallmood " + (globalClassName ? globalClassName : "");
}

BaseDiagram.prototype.initDiagramCreation = function (isDirectInsert = false) {
    this.mainTime = new Date().getTime();
    this.diagramParent.innerHTML = "";
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.createPatternBackGround(isDirectInsert);
    this.diagramRenderComplete();
    this.addFocus(this.arrDiagramNode.length - 1);
};

BaseDiagram.prototype.setMoodClassNames = function () {
    if (this.moodName != "") {
        this.diagramParent.parentElement.classList.add("common" + this.moodName);
        this.diagramParent.parentElement.classList.add(this.moodName + "diagram");
    }
    if (this.globalMoodData?.iconstyle) {
        this.diagramParent.setAttribute("data-iconstyle", this.globalMoodData.iconstyle);
    }
    if (this.globalMoodData?.basicgraphics?.diagramstyle) {
        this.diagramParent.setAttribute("data-diagramstyle", this.globalMoodData.basicgraphics.diagramstyle);
    }
    if (this.diagramData && this.diagramData.nodes) this.diagramParent.setAttribute("data-nodecount", this.diagramData.nodes.length);
    this.isTakeAway = this.diagramParent && this.diagramParent.parentElement && this.diagramParent.parentElement.getAttribute("id") == "TEXTBOX_HOLDER";
};

BaseDiagram.prototype.createPatternBackGround = function (isDirectInsert = false) {
    this.createElements();
    // console.log("Temp Time " + (new Date().getTime() - this.mainTime));
    this.createCommonText();
    this.insertSvgBackground();
    this.checkCenterNodeStyle();
    DiagramCreateUtil.createDiagramTitle(this.diagramParent, this.diagramData, this.nodeProps, this.globalMoodData, this.objStyleData);
    this.updateJSONData();
    this.updateSpecialOperations();
    this.updateEmphasize();
    this.updateFloaterOperations();
    // this.updatePropsCallBack();
    this.updateAnimationType();
    this.checkContentType();
    this.resetHolderWidth();
};

BaseDiagram.prototype.updateFloaterOperations = function () {};
BaseDiagram.prototype.resetHolderWidth = function () {
    this.resetNodeAttributes();
};

BaseDiagram.prototype.updateCssAttributes = function () {
    if (this.arrDiagramNode.length > 0 && this.appmode.toLowerCase() != "present") {
        let nodeParent = this.arrDiagramNode[0].parentNode.parentElement;
        let nodeParentStyle = window.getComputedStyle(nodeParent);
        this.arrSMLSize = DiagramUtils.getSMLValues(nodeParentStyle);
        let percentValue = nodeParentStyle.getPropertyValue("--cutomNodeBorderWidthPercent");
        percentValue = isNaN(parseInt(percentValue)) ? 4 : parseInt(percentValue);
        let sourceNode = this.diagramParent.querySelector("[data-nodetype='iconHolder']");
        if (sourceNode) {
            this.diagramParent.style.setProperty("--customNodeBorderWidth", (sourceNode.offsetWidth / 100) * percentValue + "px");
            sourceNode.style.removeProperty("--customNodeBorderWidth");
        }

        let sourceNodeImage = this.diagramParent.querySelector("[data-nodetype='imageHolder']");
        if (sourceNodeImage) {
            this.diagramParent.style.setProperty("--customNodeBorderImageWidth", (sourceNodeImage.offsetWidth / 100) * percentValue + "px");
            sourceNodeImage.style.removeProperty("--customNodeBorderImageWidth");
        }

        let percentValueSeq = nodeParentStyle.getPropertyValue("--cutomNodeBorderSeqWidthPercent");
        percentValueSeq = isNaN(parseInt(percentValueSeq)) ? 4 : parseInt(percentValueSeq);
        let sourceNodeSeq = this.diagramParent.querySelector("[name='seqTitleHolder']");
        if (sourceNodeSeq) {
            this.diagramParent.style.setProperty("--customNodeBorderSeqWidth", (sourceNodeSeq.offsetWidth / 100) * percentValueSeq + "px");
            sourceNodeSeq.style.removeProperty("--customNodeBorderSeqWidth");
        }
        if (this.diagramData?.properties?.overlayopacity) {
            this.diagramParent.style.setProperty("--overlaydiagramopacity", this.diagramData.properties.overlayopacity);
        }
    }
};

BaseDiagram.prototype.insertSvgBackground = function () {
    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsSVGBackground moodanimation";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "svgBackground");
    pattenDiv.setAttribute("data-animation", "svgnodebg");
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    nodesHolder.insertBefore(pattenDiv, nodesHolder.firstElementChild);
};

BaseDiagram.prototype.updateAnimationType = function () {
    let animationType = this.diagramParent.parentElement.dataset.animationtype || "";
    if (this.nodeProps && this.nodeProps.animationtype && this.nodeProps.animationtype[animationType]) {
        this.diagramParent.parentElement.setAttribute("data-oneattimeanimationtype", this.nodeProps.animationtype[animationType]);
    } else this.diagramParent.parentElement.setAttribute("data-oneattimeanimationtype", "");
};

BaseDiagram.prototype.checkCenterNodeStyle = function () {
    let centerNodeStyle = this.nodeProps.centerNodeStyle;
    if (centerNodeStyle) {
        let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
        DiagramUtils.addClassNames(centerNodeStyle, nodesHolder);
    }
};

BaseDiagram.prototype.checkContentType = function () {
    let primaryType = this.diagramParent.querySelector("[data-holder-type='primary']");
    if (primaryType && primaryType.dataset && primaryType.dataset.contentType) {
        this.diagramData.properties.contenttype = primaryType.dataset.contentType;
        this.arrDiagramNode.forEach((element) => {
            if (element.properties) element.properties.contenttype = primaryType.dataset.contentType;
        });
    }
};

BaseDiagram.prototype.createCommonText = function (fontData = null) {
    // if (this.nodeProps.commonText) {
    let commonTitle = this.diagramParent.querySelector("[name='commonTitleHolder']");
    if (commonTitle) commonTitle.remove();
    if (this.nodeProps.commonText || fontData) {
        let alignment = fontData && fontData.alignment ? fontData.alignment : "topbottom";
        this.diagramParent.setAttribute("data-commontitle", "true");
        this.diagramParent.setAttribute("data-commontitlealign", alignment);
        if (alignment == "topbottom") this.diagramParent.style.setProperty("--gridTitleHeight", fontData && fontData.height ? fontData.height : "20%");
        else this.diagramParent.style.setProperty("--gridTitleWidth", fontData && fontData.width ? fontData.width : "20%");
        commonTitle = document.createElement("div");
        commonTitle.className = "clsCommonTextHolder";
        commonTitle.setAttribute("id", DiagramNodeUtils.uuidv4());
        commonTitle.setAttribute("name", "commonTitleHolder");
        commonTitle.setAttribute("data-dck-selector", true);
        this.diagramParent.appendChild(commonTitle);
        let titleNode = DiagramCreateUtil.createLabel(0, "clsCommonText " + fontData && fontData.fontSize ? fontData.fontSize : "h5", "commonText", fontData && fontData.prompt ? fontData.prompt : "Diagram Title");
        titleNode.innerText = fontData && fontData.value ? fontData.value : "";
        commonTitle.appendChild(titleNode);
        titleNode.setAttribute("data-default-event", true);
        this.diagramParent.style.setProperty("flex-direction", alignment == "topbottom" ? "column" : "row");
        this.resetHolderWidth();
    }
};

BaseDiagram.prototype.checkItemVisiblily = function () {
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "textLabelHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "label", "label", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "iconHolder") && this.diagramData?.properties?.name?.includes("qt")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "quote", "quote", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "titleHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "primarytext", "primary", true);
    // if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "type1"))
    DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "multicontentheader", "multicontentheader", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "subTitleHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "secondarytext", "secondary", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "subtextHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "subtext", "subtext", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "seqTitleHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "sequencetext", "sequence", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "buttonTitleHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "button", "button", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "authorImageHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "authorimage", "authorimage", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "authorNameHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "authorname", "authorname", true);
    if (DiagramUtils.checkSupportedHolder(this.nodeProps.supportedNodes, "authorDesHolder")) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "authordes", "authordes", true);
    if (DiagramUtils.checkFloaterOption("seperatorline", this.diagramData.properties.floateroptionsdisable)) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "seperatorline", "seperatorline", true);
    if (DiagramUtils.checkFloaterOption("connector", this.diagramData.properties.floateroptionsdisable)) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "hasconnector", "connector", true);
    let diagramTitleSupport = DiagramUtils.isDiagramTitleSupported(this.diagramParent.dataset.classname, this.nodeProps.nodeclassName, this.diagramData.properties.floateroptionsdisable);
    if (diagramTitleSupport) DiagramPropertyUtils.checkPreviousDisableState(this.diagramData, this.diagramParent, "diagramtitle", "diagramtitle", true);
};

BaseDiagram.prototype.createNodeInstances = function (nodeCount, pattenDiv) {
    for (let i = 0; i < nodeCount; i++) {
        let nodeItem = new window[this.nodeProps.nodeclassName](pattenDiv, this.diagramData.properties, this.diagramData.nodes[i], this.eventManagerXY, i, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
        this.createNodeInstanceProperties(nodeItem);
        nodeItem.initCreation(i == nodeCount - 1);
        this.arrDiagramNode.push(nodeItem);
    }
    this.objContentLoad = [];
    DiagramUtils.searchMultipleAICall(this.arrDiagramNode, this.diagramData.properties.contenttype, this.diagramData.properties, this.globalMoodData, this.searchIconCallBack, appBaseURL, this.appStaticURL, null, this.searchFailureCallBack.bind(this));
};

// Node level variables
BaseDiagram.prototype.createNodeInstanceProperties = function (nodeItem) {
    nodeItem.moodData = this.moodData;
    nodeItem.moodName = this.moodName;
    nodeItem.updateCallBack = this.updateCallBack;
    nodeItem.imageLoadCallBack = this.imageLoadCallBack.bind(this);
    nodeItem.defaultImageLoadCallBack = this.defaultImageLoadCallBack.bind(this);
    nodeItem.defaultIconLoadCallBack = this.defaultIconLoadCallBack.bind(this);
    nodeItem.fontClassList = this.fontClassList;
    nodeItem.searchIconCallBack = this.searchIconCallBack;
    nodeItem.updateMaxFontCallBack = this.updateMaxFontCallBack;
    nodeItem.bgDeviceDiv = this.bgDeviceDiv;
    nodeItem.animatedSprites = this.animatedSprites;
    nodeItem.arrDefaults = this.arrDefaults;
    nodeItem.globalMoodData = this.globalMoodData;
    nodeItem.arrTintArray = this.arrTintArray;
    nodeItem.manifestUpdater = this.manifestUpdater;
    nodeItem.appStaticURL = this.appStaticURL;
};

BaseDiagram.prototype.setSlideScale = function () {
    this.slideScale = DiagramUtils.calcSlideScale(this.diagramParent.parentElement, this.appmode);
};

BaseDiagram.prototype.setSlideWidthHeight = function (width, height) {
    this.slideWidth = width;
    this.slideHeight = height;
    Constants.Value = { ...Constants.Value, slideWidth: width, slideHeight: height };
};

BaseDiagram.prototype.defaultFoucsIn = function (event) {
    if (event.target.className && event.target.className.includes("clsSingleLineRestrict") && !event.target.id.includes("numberNode")) {
        event.target.innerText = DiagramUtils.removelinebreaks(event.target.textContent);
    }
    event.target.dataset.oldtext = event.target.innerHTML;
};

BaseDiagram.prototype.isDifferentText = function (target) {
    let oldHTMLText = target.innerHTML;
    let typedText = target.dataset?.oldtext;
    if (oldHTMLText != typedText && this.appmode.toLowerCase() != "present") {
        return true;
    } else return false;
};

BaseDiagram.prototype.defaultFoucsOut = function (event) {
    let index = event.target.dataset.index;
    if (event.target.id.includes("secondaryText")) {
        if (event.target.firstElementChild && event.target.firstElementChild.innerText.trim() == "") event.target.firstElementChild.innerHTML = "";
    }

    if (event.target.className && event.target.className.includes("clsSingleLineRestrict") && !event.target.id.includes("numberNode")) {
        event.target.innerText = DiagramUtils.removelinebreaks(event.target.textContent);
    }

    let oldHTMLText = event.target.innerHTML;
    let typedText = event.target.dataset?.oldtext;
    if (oldHTMLText != typedText && this.appmode.toLowerCase() != "present") {
        if (this.arrDiagramNode && this.arrDiagramNode[index] && this.arrDiagramNode[index].numberToggleStyle) {
            this.arrDiagramNode[index].numberToggleStyle.updateNumberToggleNodeForSign(event.target, this.arrDiagramNode[index].parentNode.parentElement);
        }
        this.eventManagerXY.dispatch("focusout", event.target);
        event.target.dataset.oldtext = event.target.innerHTML;
        if (event.currentTarget?.id?.includes("diagramTitle")) {
            DiagramCreateUtil.setDiagramTitleSingleLine(this.diagramParent);
            this.resetLayout();
            this.updatePropsCallBack();
            return;
        }
        if ((event.target.id.includes("primary") || event.target.id.includes("authorName")) && event.target.innerText != event.target.dataset.oldinnertext) {
            event.target.dataset.oldinnertext = event.target.innerText;
            let targetNode = this.arrDiagramNode[index]?.parentNode?.querySelector("[name='contentNode']");
            let assetNode = targetNode && (targetNode.querySelector("[data-id='logoNode']") || targetNode.querySelector("[data-id='imageNode']") || targetNode.querySelector("[data-id='iconNode']"));
            if (!assetNode) {
                targetNode = this.arrDiagramNode[index]?.parentNode?.querySelector("[data-holder-type='primary']");
                assetNode = targetNode && (targetNode.querySelector("[data-id='logoNode']") || targetNode.querySelector("[data-id='imageNode']") || targetNode.querySelector("[data-id='iconNode']"));
            }
            if (assetNode && assetNode.parentElement) {
                assetNode.parentElement.setAttribute("data-node-graphic-text", event.target.textContent);
                let type = assetNode.parentElement.dataset.nodeContentType;
                if (!this.restrictSearch()) DiagramUtils.searchAIcall(type, this.arrDiagramNode[index]?.objData, event.target.textContent, this.diagramData.properties, this.globalMoodData, assetNode, index, this.searchIconCallBack, appBaseURL, this.appStaticURL);
            }
        }
        this.updateTextNodes(index); // need to discuss
        this.resetImageLogoFrames();
        this.updateJSONData();
        event.target.scrollTop = 0;
        event.target.parentNode.scrollTop = 0;
        if (event.target.dataset.id == "numberNode") {
            DiagramNodeUtils.checkNumberFormat(event.target, this.diagramParent, this.globalMoodData, this.nodeProps);
            this.updatePropsCallBack();
            return;
        }
        this.checkContentType();
        this.updateCssAttributes();
        this.updatePropsCallBack(event.target.id);
    }
};

BaseDiagram.prototype.restrictSearch = function () {
    return (this.nodeProps && this.nodeProps.quoteShape) || this.nodeProps?.name?.includes("-qt-");
};

BaseDiagram.prototype.updateMoodProperties = function () {
    try {
        // if (this.nodeProps.name && this.nodeProps.name != "") {
        if (this.nodeProps) {
            if (this.arrDiagramNode && this.arrDiagramNode.length > 0) this.diagramParent.setAttribute("data-nodecount", this.arrDiagramNode.length);
            this.nodeGap = DiagramPropertyUtils.getDefaultDiagramNodeGap(this.nodeProps, this.diagramParent, this.diagramData && this.diagramData.properties);
            DiagramPropertyUtils.updateNodePropsFromStyle(this.nodeProps, "contentNodePadding", this.diagramParent);
            // if (this.isLinearNodeStyles()) {
            DiagramPropertyUtils.updateGlobalNodePropsFromStyle(this.nodeProps, "nodealignment", this.diagramParent, "--graphicHAlign");
            // }
            DiagramPropertyUtils.updateGlobalNodePropsFromStyle(this.nodeProps, "valign", this.diagramParent, "--graphicVAlign");
            DiagramPropertyUtils.updateNodePropsFromStyle(this.nodeProps, "nodeParentPadding", this.diagramParent);
            DiagramPropertyUtils.updateNodePropsFromStyle(this.nodeProps, "secondaryContentNodePadding", this.diagramParent);
            if (this.globalMoodData) {
                let seperatorMoodObj = DiagramUtils.getSeperatorObject(this.globalMoodData.basicgraphics, this.diagramParent.dataset.classname);
                if (!this.nodeProps.seperatorline) this.nodeProps.seperatorline = seperatorMoodObj.seperatorline;
                if (!this.nodeProps.connector) this.nodeProps.connector = seperatorMoodObj.connector;
            }
        }
    } catch (error) {
        console.log(error);
    }
};

BaseDiagram.prototype.updateImageRatio = function () {
    if (this.nodeProps.imageRatio && this.nodeProps.imageRatio.type) {
        let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
        const nodeCount = this.diagramData.nodes.length;
        const gap = DiagramNodeUtils.getGapForMathSymbols(this.nodeProps, nodeCount, this.diagramParent);
        const widthPercent = this.nodeProps.imageRatio.value ? this.nodeProps.imageRatio.value : 100;
        const holderWidth = (nodesHolder.offsetWidth - (nodeCount - 1) * gap) / nodeCount;
        const imageHolderWidth = (holderWidth / 100) * widthPercent;
        let percentImageHolderWidth = imageHolderWidth;
        let percentImageHolderHeight = (imageHolderWidth / 16) * 9;
        if (this.nodeProps.imageRatio.type == "sqr") {
            percentImageHolderWidth = imageHolderWidth;
            percentImageHolderHeight = imageHolderWidth;
        } else if (this.nodeProps.imageRatio.type == "pot") {
            percentImageHolderWidth = imageHolderWidth;
            percentImageHolderHeight = (imageHolderWidth / 3) * 4;
        }

        nodesHolder.style.setProperty("--percentWidth", percentImageHolderWidth + "px");
        nodesHolder.style.setProperty("--percentHeight", percentImageHolderHeight + "px");
    }
};

BaseDiagram.prototype.textHighlightMouseUpEvent = function (event) {
    event.isTakeAway = this.isTakeAway;
    this.eventManagerXY.dispatch("mouseup", event);
};

BaseDiagram.prototype.defaultCheckBoxEvent = function (event) {
    event.preventDefault();
    event.slideID = this.slideID;
    this.eventManagerXY.dispatch("mousedown", event);
};

BaseDiagram.prototype.searchFailureCallBack = function (e) {
    if (!this.objContentLoad) this.objContentLoad = [];
    this.objContentLoad?.push(e);
    if (this.objContentLoad?.length == this.arrDiagramNode.length) {
        this.updatePropsCallBack();
    }
};

BaseDiagram.prototype.imageLoadCallBack = function (target) {
    if (!this.objContentLoad) this.objContentLoad = [];
    this.objContentLoad?.push(target);
    if (this.objContentLoad?.length == this.arrDiagramNode.length) {
        this.updatePropsCallBack(target.id);
    }
};

BaseDiagram.prototype.defaultImageLoadCallBack = function (target) {
    if (!this.objDefaultContentLoad) this.objDefaultContentLoad = [];
    this.objDefaultContentLoad?.push(target);
    if (this.objDefaultContentLoad?.length == this.arrDiagramNode.length) {
        this.updatePropsCallBack(target.id);
        this.objDefaultContentLoad = null;
    }
};

BaseDiagram.prototype.defaultIconLoadCallBack = function (target) {
    if (!this.objDefaultContentLoad) this.objDefaultContentLoad = [];
    this.objDefaultContentLoad?.push(target.id);
    if (this.objDefaultContentLoad?.length == this.arrDiagramNode.length) {
        this.updatePropsCallBack(target.id);
        this.objDefaultContentLoad = null;
    }
};

BaseDiagram.prototype.searchIconCallBack = function (content, type, index, id, updateProps = true) {
    this.updateNodeData(content, type, index, id);
    // this.updatePropsCallBack(id);
    if (type == "icon") {
        let iconName = DiagramNodeUtils.getIconName(content);
        content.id = iconName;
        DiagramCreateUtil.updateManifest(content, this.manifestUpdater, this.appStaticURL);
        this.objContentLoad?.push(content);
    }
    let targetNode = this.diagramParent.querySelector("[id='" + id + "']");
    let nodeGroup = this.diagramParent.querySelector("[name='nodeGroup'][index='" + index + "']");
    if (id.includes("gridNode")) {
        if (targetNode) {
            let gridIndex = targetNode.dataset.index;
            let gridInstance = this.arrDiagramNode[gridIndex].gridInstance;
            gridInstance.changeImageNode(id, targetNode.dataset.imagegridIndex, content.value, content.searchText);
            gridInstance.gridimages = gridInstance.getLogoListData(this.arrDiagramNode[gridIndex].parentNode);
        }
        // this.arrDiagramNode[index].gridInstance.adjustLayout();
    } else {
        if (type == "logo" && content.hasOwnProperty("logocontrast")) {
            let logoNode = targetNode.querySelector("[name='logoNode']") || targetNode;
            let nodeItem = this.arrDiagramNode[index];
            if (nodeItem?.objData?.nodeproperties) {
                nodeItem.objData.nodeproperties.logocontrast = content.logocontrast;
                nodeItem.updateNodeProperties(nodeItem.objData.nodeproperties);
            }
            DiagramUtils.setLogoContrast(logoNode, nodeGroup, content.logocontrast);
        }
    }
    this.updateJSONData();
    // if (updateProps)
    if (this.objContentLoad?.length == this.arrDiagramNode.length) {
        this.updatePropsCallBack(id);
    }
};

BaseDiagram.prototype.updatePropsCallBack = function (targetid) {
    this.updateCssAttributes();
    if (this.updateCallBack && this.updateCallBack.func && !this.isTempSlide) {
        this.updateCallBack.func(this.updateCallBack.params, targetid);
    }
};

BaseDiagram.prototype.updateResizeCallBack = function (targetid, diagramData, instance) {
    if (this.titleResizeCallBack && this.titleResizeCallBack.func) {
        this.titleResizeCallBack.func(targetid, diagramData, instance);
    }
};

BaseDiagram.prototype.isChildEmpty = function () {
    let arrNodes = this.diagramParent.querySelectorAll("[name='nodeparent']");
    if (arrNodes.length == 0) return true;
    return false;
};

BaseDiagram.prototype.diagramPasteHandler = function (event) {
    event.preventDefault();
    try {
        let strUnformattedText = (event.clipboardData || event.originalEvent.clipboardData).getData("text/plain");
        document.execCommand("insertText", false, strUnformattedText);
        this.resetLayout();
        this.updatePropsCallBack();
    } catch (error) {
        console.log("Text Paste Error");
    }
};
// Multinode to singlenode
BaseDiagram.prototype.getDiagramSingleNodeData = function (index) {
    let data = this.arrDiagramNode[index].objData;
    let secondaryText = "";
    if (data.secondarytext && data.secondarytext.items)
        data.secondarytext.items.forEach((element) => {
            if (element.value.trim() != "") secondaryText += TextHighLightUtils.highlightToString(element.value) + " ";
        });
    let isDiagramContent = this.diagramData.properties.diagramcontent && data.content;
    return {
        title: TextHighLightUtils.highlightToString(data.primarytext.value ? data.primarytext.value : ""),
        subtitle: secondaryText,
        type: isDiagramContent ? data.content.type : "text",
        value: isDiagramContent ? data.content.value : "",
        label: "",
        // ctabutton: data.content && data.content.contenttype && data.content.contenttype == "button" ? data.content.value : "",
        ctabutton: this.diagramData.properties.button && data.button && data.button.value ? data.button.value : "",
    };
};

BaseDiagram.prototype.getOutlineMatrix = function (isFromZenEditor = false) {
    let row = [];
    let subtype = "bulleted";
    let tempData = this.getJSONData();
    let arrNodes = tempData && tempData.nodes && !isFromZenEditor ? tempData.nodes : this.diagramData?.nodes;
    if (!arrNodes || arrNodes.length == 0) {
        this.recreateElementData();
        if (!this.diagramData) this.diagramData = this.getJSONData();
    }
    const properties = this.getProperties();
    for (let i = 0; i < arrNodes.length; i++) {
        let column = [];
        let nodeData = arrNodes[i];
        let sublist = false;
        if (nodeData.bgimage) {
            column.push({ isbgimage: true, type: nodeData.bgimage.type, dataRef: nodeData.bgimage.dataRef, id: nodeData.bgimage.id, value: nodeData.bgimage.value ? nodeData.bgimage.value : "" });
        }
        if (nodeData.content && properties.diagramcontent && nodeData.content.contenttype && nodeData.content.contenttype != "diagramContentNode") {
            if (subtype == "valued") {
                properties.contenttype = nodeData.content.contenttype;
            }
            subtype = DiagramUtils.getSubType(properties.contenttype);
            let cellOBJ = nodeData.content;
            // let cellOBJ = { type: nodeData.content.type, value: nodeData.content.value ? nodeData.content.value : "" };
            if (nodeData.content.contenttype == "image" || nodeData.content.contenttype == "icon") {
                subtype = nodeData.content.contenttype;
                if (nodeData.content.dataRef) {
                    cellOBJ.id = nodeData.content.id;
                    cellOBJ.dataRef = nodeData.content.dataRef;
                }
            }
            column.push(cellOBJ);
        } else if (properties.sequencetext) {
            subtype = "numbered";
            // properties.contenttype = "sequence";
            // if (this.diagramParent) this.diagramParent.setAttribute("data-contenttype", "sequence");
        }
        if (nodeData.primarytext) {
            column.push({
                type: "text",
                value: TextHighLightUtils.highlightToString(nodeData.primarytext.value ? nodeData.primarytext.value : ""),
                textproperties: nodeData.primarytext.textproperties,
            });
        }
        if (nodeData.secondarytext && nodeData.secondarytext.items) {
            for (let l = 0; l < nodeData.secondarytext.items.length; l++) {
                let arrItems = nodeData.secondarytext.items[l].value.split("\n");
                arrItems.forEach((value) => {
                    // if (value && value != "")
                    column.push({ type: "text", value: TextHighLightUtils.highlightToString(value), index: i, textproperties: nodeData.secondarytext.textproperties });
                });
            }
            sublist = nodeData.secondarytext.sublist ? nodeData.secondarytext.sublist : "none";
        }
        if (nodeData.multitextdata) {
            column = nodeData.multitextdata;
        }
        if (this.diagramData.nodes[i]) {
            this.diagramData.nodes[i].label = nodeData.label;
            this.diagramData.nodes[i].subtext = nodeData.subtext;
            this.diagramData.nodes[i].button = nodeData.button;
            this.diagramData.nodes[i].position = nodeData.position;
            this.diagramData.nodes[i].crossout = nodeData.crossout;
            this.diagramData.nodes[i].logocontrast = nodeData.logocontrast;
            this.diagramData.nodes[i].ischecked = nodeData.ischecked;
            this.diagramData.nodes[i].emphasize = nodeData.emphasize || "";
            this.diagramData.nodes[i].highlightdata = nodeData.highlightdata || {};
            this.diagramData.nodes[i].link = nodeData.link || "";
            this.diagramData.nodes[i].extralink = nodeData.extralink || {};
        }

        row.push(this.setRowMatrix(column, nodeData, sublist));
    }
    let animationtype = this.diagramParent.parentElement.dataset.animationtype || "all";
    let oneattimeanimationtype = this.diagramParent.parentElement.dataset.oneattimeanimationtype || "fadein";
    let returnData = {
        subtype: subtype,
        properties: properties,
        graphictype: "diagram",
        matrix: row,
        animationdata: { animationtype: animationtype, oneattimeanimationtype: oneattimeanimationtype },
    };
    if (this.centerHolderNode && this.getCenterHolderData) returnData.centerholderdata = this.getCenterHolderData();
    if (this.centerHolderNode && this.getProjectionData) returnData.projectiondata = this.getProjectionData();
    if (this.centerHolderNode && this.getStartEndData) returnData.startenddata = this.getStartEndData();
    if (tempData.diagramtitle) returnData.diagramtitle = tempData.diagramtitle;
    return returnData;
};

BaseDiagram.prototype.setRowMatrix = function (column, nodeData, sublist) {
    let row = {};
    if (column) row.matrix = column;
    if (nodeData.seccontent && nodeData.seccontent.length > 0) row.secondary = nodeData.seccontent;
    if (nodeData.tertiarycontent && nodeData.tertiarycontent.length > 0) row.tertiary = nodeData.tertiarycontent;
    if (nodeData.secondarytext && nodeData.secondarytext.seccontent && nodeData.secondarytext.seccontent.length > 0) row.seclistcontent = nodeData.secondarytext.seccontent;
    if (nodeData.author) row.author = nodeData.author;
    if (nodeData.number) row.number = nodeData.number;
    if (sublist) row.rowtype = sublist;
    if (nodeData.nodeproperties) row.nodeproperties = nodeData.nodeproperties;
    if (nodeData.customconnector) row.customconnector = nodeData.customconnector;
    if (nodeData.customconnectortext) row.customconnectortext = nodeData.customconnectortext;
    if (nodeData.label && nodeData.label != "") row.label = nodeData.label;
    if (nodeData.subtext && nodeData.subtext != "") row.subtext = nodeData.subtext;
    if (nodeData.button && nodeData.button != "") row.button = nodeData.button;
    if (nodeData.emphasize && nodeData.emphasize != "") row.emphasize = nodeData.emphasize;
    if (nodeData.position) row.position = nodeData.position;
    if (nodeData.crossout) row.crossout = nodeData.crossout;
    if (nodeData.logocontrast) row.logocontrast = nodeData.logocontrast;
    if (nodeData.ischecked) row.ischecked = nodeData.ischecked;
    if (nodeData.highlightdata && Object.keys(nodeData.highlightdata).length != 0) row.highlightdata = nodeData.highlightdata;
    if (nodeData.link) row.link = nodeData.link;
    if (nodeData.extralink) row.extralink = nodeData.extralink;
    return row;
};

BaseDiagram.prototype.getHolderObj = function (supportedNodes, name) {
    return DiagramUtils.getObjectFromName(supportedNodes, name);
};

BaseDiagram.prototype.getVisibilityForHolder = function (supportedNodes, holderName, defaultValue = false) {
    let holderObj = DiagramUtils.getObjectFromName(supportedNodes, holderName);
    return holderObj && holderObj.hasOwnProperty("visible") ? holderObj.visible : defaultValue;
};

BaseDiagram.prototype.initDiagramCreationOutline = function (outlineData, data) {
    if (!outlineData) outlineData = {};
    if (!data) data = {};
    let outlinetype = data.outlinetype;

    if (!data.name) {
        console.log("no name for this menu...");
        console.log(data);
    }
    // if (data?.extraData?.outlinetype) {
    //     outlinetype = data?.extraData?.outlinetype;
    // }
    // if (data.outlinetype == "numbered" || data.outlinetype == "bulleted") outlinetype = data.outlinetype;
    // let contentOptionNode = data.nodeclassName && data.nodeclassName.includes("ContentOptionNode");
    // if (contentOptionNode) {
    //     outlinetype = outlineData && outlineData.subtype ? outlineData.subtype : data.outlinetype;
    // }
    let moodsData = data.moodsData || this.globalMoodData?.basicgraphics || {};
    let seperator = DiagramUtils.getSeperatorObject(moodsData, data.classname);
    let enableIcon = data.name.includes("-sec-ic");
    let enableValue = data.name.includes("-sec-val");
    let enableImage = data.name.includes("-sec-img");
    let enableLogoList = data.name.includes("-sec-lgrd");
    let enableLogo = data.name.includes("-sec-lg");
    let enableSequence = this.getVisibilityForHolder(data.supportedNodes, "seqTitleHolder");
    let iconHolderObj = DiagramUtils.getObjectFromName(data.supportedNodes, "iconHolder");
    let valueHolderObj = DiagramUtils.getObjectFromName(data.supportedNodes, "valueTitleHolder");
    let imageHolderObj = DiagramUtils.getObjectFromName(data.supportedNodes, "imageHolder");
    let logoHolderObj = DiagramUtils.getObjectFromName(data.supportedNodes, "imageSecHolder");
    let disableImage = data.floateroptionsdisable && data.floateroptionsdisable.includes("graphicsecondaryimage");
    let disableBulletPoints = data.floateroptionsdisable && data.floateroptionsdisable.includes("bullet");
    // if(imageHolderObj && imageHolderObj.hasOwnProperty("imageoverlayproperties")) this.globalMoodData.imageoverlayproperties = imageHolderObj.imageoverlayproperties;
    let enableOverlay = this.globalMoodData.imageoverlayproperties?.enable;
    let enableOverlaySupport = this.globalMoodData.imageoverlayproperties?.support && !data?.floateroptionsdisable?.includes("overlay");
    // if (data.hasOwnProperty("isoverlaysupport")) this.globalMoodData.imageoverlayproperties.support = data.isoverlaysupport;
    let enableConnectorText = data.hasOwnProperty("connectortextvisible") ? data.connectortextvisible : seperator.connectortext || data.connectortext ? seperator?.connectortextvisible : false;
    let enableConnector = data.hasOwnProperty("connectorvisible") ? data.connectorvisible : seperator.connector || data.connector ? seperator?.connectorvisible : false;
    let enableSeperator = data.hasOwnProperty("seperatorlinevisible") ? data.seperatorlinevisible : seperator.seperatorline || data.seperatorline ? seperator?.seperatorlinevisible : false;
    let defaultprops = {
        isfromai: data.isFromAI,
        diagramtitle: false,
        diagramcontent: true,
        sequencetext: enableSequence,
        secondarytext: this.getVisibilityForHolder(data.supportedNodes, "subTitleHolder", true),
        primarytext: this.getVisibilityForHolder(data.supportedNodes, "titleHolder", true),
        label: this.getVisibilityForHolder(data.supportedNodes, "textLabelHolder", false),
        subtext: this.getVisibilityForHolder(data.supportedNodes, "subtextHolder", false),
        authorname: this.getVisibilityForHolder(data.supportedNodes, "authorNameHolder", true),
        authordes: this.getVisibilityForHolder(data.supportedNodes, "authorDesHolder", true),
        authorimage: this.getVisibilityForHolder(data.supportedNodes, "authorImageHolder", true),
        gridimage: this.getVisibilityForHolder(data.supportedNodes, "imageHolder", true),
        secondaryplaceholder: data?.name?.includes("-sec-") ? (enableIcon ? "icon" : enableValue ? "number" : enableImage ? "image" : enableLogoList ? "logolist" : enableLogo ? "logo" : null) : null,
        enablesecplaceholder: data?.name?.includes("-sec-") ? (enableIcon ? enableIcon : enableImage && !disableImage ? enableImage : enableLogoList ? enableLogoList : enableLogo ? enableLogo : enableValue ? enableValue : false) : false,
        microchart: this.getVisibilityForHolder(data.supportedNodes, "microChartHolder", true),
        button: this.getVisibilityForHolder(data.supportedNodes, "buttonTitleHolder", false),
        contenttype: outlinetype,
        hasconnector: enableConnector,
        connectortext: enableConnectorText,
        seperatorline: !enableConnector && !outlineData?.properties?.hasconnector ? enableSeperator : false,
        connectorstyle: data?.connector?.style || Constants.Value.connectorstyle,
        logosize: (logoHolderObj && logoHolderObj.size) || moodsData.logosize || Constants.Value.logosize,
        iconsize: (iconHolderObj && iconHolderObj.size) || moodsData.iconsize || Constants.Value.iconsize,
        imagesize: (imageHolderObj && imageHolderObj.size) || moodsData.imagesize || Constants.Value.imagesize,
        numbersize: (valueHolderObj && valueHolderObj.size) || moodsData.numbersize || Constants.Value.numbersize,
        isbleed: data.isbleedvisible != null ? data.isbleedvisible : false,
        isgutter: data.isguttervisible != null ? data.isguttervisible : false,
        isoverlay: data.isoverlayvisible != null ? data.isoverlayvisible : enableOverlay ? enableOverlay : false,
        isoverlaysupport: data.isoverlaysupport != null ? data.isoverlaysupport : enableOverlaySupport ? enableOverlaySupport : false,
        border: data.bordervisible || "",
        position: data.positionvisible || moodsData.textposition || "",
        ismultigrid: data.isMultiGrid != null ? data.isMultiGrid : false,
        valueformat: data.numberformat || "actualnumber",
        multicolor: data?.colordata?.multicolor == "true" || outlineData?.properties?.multicolor,
    };

    // Retain design elements on mood change / style change
    if (outlineData?.properties) {
        let arrDesignProperties = ["iconsize", "logosize", "imagesize", "numbersize", "microchartsize", "seperatorline", "isfromai"];
        arrDesignProperties.forEach((element) => {
            if (outlineData.properties.hasOwnProperty(element)) {
                delete outlineData.properties[element];
            }
        });
    }
    // let overrideProperties = !window.ismoodchange && !window.isFromSlideEditor;
    let overrideProperties = !window.isFromSlideEditor && data?.name != outlineData?.properties?.name;

    if (overrideProperties && data?.extraData?.properties) defaultprops = { ...defaultprops, ...data.extraData.properties };

    if ((outlineData.outlinetype == "checklist" || outlineData.outlinetype == "bulletlist") && outlineData.subtype && outlineData.subtype == "bulleted") outlinetype = outlineData.outlinetype;
    let hasProperties = outlineData && outlineData.hasOwnProperty("properties") && Object.keys(outlineData.properties).length != 0;
    // let properties = hasProperties ? outlineData.properties : defaultprops;
    let hasContent = true;
    let takeawayProperties = "";
    if (!hasProperties) {
        takeawayProperties = outlineData && outlineData.hasOwnProperty("takeawayproperties") && Object.keys(outlineData.takeawayproperties).length != 0;
    }
    // let properties = hasProperties ? outlineData.properties : takeawayProperties ? outlineData.takeawayproperties : defaultprops;
    let properties = defaultprops;
    if (hasProperties && !takeawayProperties) {
        properties = {
            ...defaultprops,
            ...outlineData.properties,
        };
    } else if (takeawayProperties) {
        properties = {
            ...defaultprops,
            ...outlineData.takeawayproperties,
        };
    }
    // properties.hasconnector = seperator.connector || data.connector ? properties.hasconnector : false;
    // properties.seperatorline = seperator.seperatorline || data.seperatorline ? properties.seperatorline : false;
    // if (window.ismoodchange) {
    //     let objMoodArrProperties = Object.keys(moodsData);
    //     let objSeperatorArrProperties = Object.keys(seperator);
    //     objMoodArrProperties.forEach((element) => {
    //         if (properties[element]) {
    //             properties[element] = moodsData[element];
    //         }
    //     });
    //     objSeperatorArrProperties.forEach((element) => {
    //         if (element == "seperatorlinevisible" && !properties.hasconnector) {
    //             properties["seperatorline"] = seperator[element];
    //         } else if (properties[element]) {
    //             properties[element] = seperator[element];
    //         }
    //     });
    // }
    let nodes = [];
    let hasLogo = true;
    if (outlineData && outlineData.matrix && outlineData.matrix.length > 0) {
        for (let i = 0; i < outlineData.matrix.length; i++) {
            let rowData = outlineData.matrix[i];
            // For Comparision diagram data parsing
            if (rowData.header) {
                rowData.matrix = [...rowData.header, ...rowData.matrix];
            }
            let multiTextObj = this.getHolderObj(data.supportedNodes, "multiTextNode");
            if (!multiTextObj) {
                let cellDataMulti = rowData && rowData.matrix[0];
                if (cellDataMulti && cellDataMulti.multitextdata) {
                    outlineData.matrix = DiagramUtils.quillToOutlineParser(rowData.matrix);
                    rowData = outlineData.matrix[i];
                    // console.log("Quill to normal node parser here....------");
                }
            } else {
                let cellDataMulti = rowData && rowData.matrix[0];
                if (!cellDataMulti || !cellDataMulti.multitextdata) {
                    rowData.matrix = DiagramUtils.outlineToQuillParser(outlineData.matrix);
                    // console.log("Normal to Quill node parser here....------");
                }
            }
            let contentUpdate = true;
            let contentAdded = false;

            if (properties.contenttype == "bulletlist" || properties.contenttype == "checklist") outlinetype = properties.contenttype;
            DiagramNodeUtils.updateNodeType(outlinetype, properties);
            // let isCheckList = data.name && data.name.includes("ckd");
            // properties.contenttype = isCheckList ? "checklist" : properties.contenttype;

            let content = DiagramNodeUtils.diagramContentData(properties.contenttype, this.appStaticURL, this.arrDefaults, i);
            let defaultContent = null;
            if (this.arrDefaults && this.arrDefaults.content) {
                defaultContent = this.arrDefaults.content[i];
            }
            let node = DiagramNodeUtils.generateDefaultNodeData(rowData, content, this.arrDefaults, data.name, i);

            // Parse chart data to digram data for microchart.
            if (outlineData?.outlinetype && outlineData?.outlinetype?.includes("chart") && rowData && rowData.matrix && rowData.matrix.length > 0) {
                const firstValueObject = rowData.matrix.findLast((obj) => obj?.data?.id?.includes("value"));
                const labelObjects = rowData.matrix.filter((obj) => obj?.data?.id?.includes("label"));
                let arrParsed = firstValueObject ? [firstValueObject, ...labelObjects] : [...labelObjects];
                if (arrParsed.length > 0) {
                    let hasContent = oldContentType == "none" || oldContentType == "sequence" ? false : DiagramNodeUtils.hasContentData(arrParsed[0], properties, outlineData);
                    if (!hasContent && firstValueObject) {
                        arrParsed.remove(firstValueObject);
                    }
                    if (arrParsed && arrParsed.length > 0) rowData.matrix = arrParsed;
                }
            }

            for (let j = 0; j < rowData.matrix.length; j++) {
                let cellData = rowData.matrix[j];
                if (data.titlecomponent) node.multitextdata = cellData;
                hasContent = DiagramNodeUtils.hasContentData(cellData, properties, outlineData);
                if (cellData.isbgimage) {
                    node.bgimage = {
                        type: cellData.type,
                        value: cellData.value,
                        contenttype: cellData.type,
                        dataRef: cellData.dataRef,
                        id: cellData.dataRef ? cellData.dataRef.name : cellData.id || "",
                    };
                } else if (hasContent && contentUpdate) {
                    contentUpdate = false;
                    contentAdded = true;
                    if (defaultContent && cellData.contenttype != defaultContent?.contenttype && defaultContent?.value != "") {
                        node.content = defaultContent;
                    } else {
                        node.content = {
                            ...cellData,
                            type: cellData.type,
                            needAssetUpdate: cellData.needAssetUpdate || cellData.assetTextUpdate || false,
                            value: cellData.value,
                            contenttype: cellData.contenttype || node?.content?.contenttype || cellData.type,
                            dataRef: cellData.dataRef,
                            id: cellData.dataRef ? cellData.dataRef.name : cellData.id || "",
                        };
                        if (cellData.logodata) node.content.logodata = cellData.logodata;
                        if (cellData.assetText) node.content.assetText = cellData.assetText;
                        if (data?.name?.includes("team") && (!node?.content?.value || node?.content?.value == "")) {
                            node.content.value = this.arrDefaults?.team?.[i]?.value;
                        }
                    }

                    // Reset Image Edit data on explorestyles
                    if (node.content?.contenttype == "image" && node.content?.dataRef) {
                        if (node.content.dataRef.cropData) node.content.dataRef.cropData = "";
                        if (node.content.dataRef.cropStyle) node.content.dataRef.cropStyle = "";
                    }

                    if (content.contenttype != cellData.type && rowData.secondary) {
                        let matchedContent = rowData.secondary.find((obj) => obj.contenttype && obj.contenttype == content.contenttype);
                        if (matchedContent) node.content = matchedContent;
                    }

                    if (cellData.type == "icon" && cellData.dataRef) {
                        window.arrIconAssets[cellData.dataRef.name] = cellData.value;
                    }

                    properties.diagramcontent = properties && properties.hasOwnProperty("diagramcontent") ? properties.diagramcontent : true;
                    if (outlinetype == "icon" || outlinetype == "valued" || outlinetype == "image") properties.diagramcontent = true;
                    hasLogo = hasLogo ? cellData.aiType == "companies" || cellData.aiType == "countries" || properties.contenttype == "logo" : false;
                } else if (((j == 0 && !contentAdded) || (contentAdded && j == 1)) && cellData.type != "checked") {
                    node.primarytext = { type: cellData.type, value: cellData.value, textproperties: DiagramUtils.checkOldTextProperties(cellData, properties, "primaryText") };
                } else if (((j > 0 && !hasContent) || (hasContent && j > 1)) && cellData.type != "checked") {
                    node.secondarytext.textproperties = cellData.textproperties;
                    node.secondarytext.items.push({ type: cellData.type, value: cellData.value, index: cellData.index });
                }
                if (cellData.type == "checked") contentAdded = true;
            }
            if (rowData.button && rowData.button.value && rowData.button.value != "" && rowData.isFromSingleNode) {
                properties.button = true;
            }
            if (rowData?.author?.description && node.secondarytext.items.length == 0) {
                node.secondarytext = rowData.author.description;
            }
            if (node.secondarytext.items.length == 0) {
                node.secondarytext.items.push({ type: "text", value: "", index: 0 });
                // properties.secondarytext = false;
            } else if (node.secondarytext.items.length > 1 && data.isFromAI && (!node.secondarytext.sublist || node.secondarytext.sublist == "none") && (!properties.secondarytype || properties.secondarytype == "none") && !disableBulletPoints) {
                node.secondarytext.sublist = "disc";
            }
            nodes.push(node);
            if (this.arrDiagramNode && this.arrDiagramNode[i]) this.arrDiagramNode[i].objData = node;
        }
    }

    // properties.diagramcontent = data && data.textOnly ? false : outlinetype == "bulleted" || outlinetype == "numbered" ? false : properties.diagramcontent;
    properties.contenttype = hasLogo && hasContent ? "logo" : properties.contenttype;
    let isSeqDisable = data.floateroptionsdisable && data.floateroptionsdisable.includes("sequencetext");
    properties.sequencetext = outlinetype == "numbered" || ((properties.sequencetext || outlineData.subtype == "numbered") && !isSeqDisable);
    properties.secondaryplaceholder = data?.name?.includes("-sec-") ? (enableIcon ? "-sec-ic" : enableValue ? "-sec-val" : enableImage ? "-sec-img" : enableLogoList ? "-sec-lgrd" : enableLogo ? "-sec-lg" : null) : null;
    properties.enablesecplaceholder = data?.name?.includes("-sec-") ? (enableIcon ? enableIcon : enableImage && !disableImage ? enableImage : enableLogoList ? enableLogoList : enableLogo ? enableLogo : enableValue ? enableValue : false) : false;
    properties.button = data.name.endsWith("-sec-btn");
    this.diagramData = { properties: properties, nodes: nodes, diagramtitle: outlineData.diagramtitle };
    this.centerholderdata = outlineData.centerholderdata;
    this.projectiondata = outlineData.projectiondata;
    this.startenddata = outlineData.startenddata;
    this.updateProperties(properties);
};

BaseDiagram.prototype.isLogoAsset = function (name) {
    return name.includes("hor-lg") || name.includes("ver-lg") || name.includes("grd-lg") || name.includes("clientele-lg");
};

BaseDiagram.prototype.addListener = function (event, callback) {
    this.eventManagerXY.addListener(event, callback);
};

BaseDiagram.prototype.removeListener = function (event, callback) {
    this.eventManagerXY.removeListener(event, callback);
};

// BaseDiagram.prototype.diagramRenderComplete = function () {
//     console.log("Main Time " + (new Date().getTime() - this.mainTime));
//     if (this.completeCallBack && this.completeCallBack.func) {
//         this.completeCallBack.func(this.completeCallBack.params);
//         this.completeCallBack = null;
//     }
//     this.updateEvents();
//     //console.log("Render Complete");
// };

BaseDiagram.prototype.diagramRenderComplete = function (isResetLayout = true) {
    try {
        if (this.appmode.toLowerCase() != "present") {
            // this.updateTextNodes();
            this.resetImageLogoFrames();
        }
    } catch (error) {
        console.log("Error in diagramRenderComplete", error);
    }
    if (this.completeCallBack && this.completeCallBack.func) {
        this.completeCallBack.func(this.completeCallBack.params);
        // console.log("diagramRenderComplete callback..", this.completeCallBack.params);
    }
    this.updateEvents();
    this.setNodeCount();
};

BaseDiagram.prototype.setNodeCount = function () {
    if (this.arrDiagramNode && this.arrDiagramNode.length > 0) this.diagramParent.setAttribute("data-nodecount", this.arrDiagramNode.length);
    let minWidthHeight = this.nodeProps && this.nodeProps.minWidthHeight;
    if (minWidthHeight && !this.isTakeAway) {
        let type = this.diagramParent.dataset.graphiclayoutname || this.diagramParent.dataset.name.substr(0, this.diagramParent.dataset.name.indexOf("-"));
        if (typeof minWidthHeight == "string") minWidthHeight = JSON.parse(minWidthHeight);
        if (minWidthHeight[2] && minWidthHeight[2] == "type2") {
            this.diagramParent.style.minWidth = minWidthHeight[0] + "px";
            this.diagramParent.style.minHeight = minWidthHeight[1] + "px";
        } else {
            this.diagramParent.style.minWidth = (type == "hor" ? minWidthHeight[0] * this.arrDiagramNode.length : minWidthHeight[0]) + "px";
            this.diagramParent.style.minHeight = (type == "ver" ? minWidthHeight[1] * this.arrDiagramNode.length : minWidthHeight[1]) + "px";
        }
        if (minWidthHeight[3] && minWidthHeight[3] == "group") {
            let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
            nodesHolder.style.setProperty("--nodeGroupHeight", minWidthHeight[1] + "px");
        }
    }
};

BaseDiagram.prototype.slideDimensionChange = function () {
    let svgPattern = this.diagramParent.querySelector("svg[class='fullBackgroundSVG']");
    if (svgPattern && svgPattern.parentElement) {
        svgPattern.parentElement.innerHTML = svgPattern.cloneNode(true).outerHTML;
    }
    this.updateMoodProperties();
};

BaseDiagram.prototype.updateNodeData = function (nodeData, type, index, parentId) {
    if (this.arrDiagramNode && this.arrDiagramNode.length > index) {
        this.arrDiagramNode[index].updateContentData(nodeData, type, parentId);
    }
};

BaseDiagram.prototype.getCustomProperties = function () {};

BaseDiagram.prototype.getDiagramLayoutProperties = function () {};

BaseDiagram.prototype.setIconSize = function () {};

BaseDiagram.prototype.logoGreyScale = function (isVisible, updateCallBack = true) {
    if (isVisible) {
        this.diagramParent.classList.add("clsLogoGreyscaleParent");
        this.diagramData.properties.greyscale = true;
    } else {
        this.diagramParent.classList.remove("clsLogoGreyscaleParent");
        this.diagramData.properties.greyscale = false;
    }
    this.updateProperties(this.diagramData.properties);
    // if (updateCallBack) {
    //     this.updatePropsCallBack();
    // }
};

BaseDiagram.prototype.allowContentResize = function (previousSize, presentSize) {
    //check empty space and restrict content size
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    if (nodesHolder) {
        let nodesHolderStyle = getComputedStyle(nodesHolder);
        let nodeGroupHeight = nodesHolderStyle.getPropertyValue("--nodeGroupHeight").trim();
        let diagramParentStyle = getComputedStyle(this.diagramParent);
        let originalResizeHeight = diagramParentStyle.getPropertyValue("--originalresizeheight").trim();
        let previoussize = diagramParentStyle.getPropertyValue("--resizeValue").trim();
        let presentsize = diagramParentStyle.getPropertyValue("--" + presentSize + "Size").trim();
        let diagramParentHeight = this.diagramParent.clientHeight;
        if (nodeGroupHeight) {
            let contentSizePrevious = parseFloat(originalResizeHeight) * parseFloat(previoussize);
            let contentSizePresent = parseFloat(originalResizeHeight) * parseFloat(presentsize);
            let textNodesHeight = parseFloat(nodeGroupHeight) - contentSizePrevious;
            let presentGroupHeight = textNodesHeight + contentSizePresent;
            if (presentGroupHeight > diagramParentHeight) {
                return false;
            }
        }
    }
    return true;
};

BaseDiagram.prototype.changeNumberSize = function (value, updateCallBack = true) {
    if (!value || this.diagramData.properties.contenttype != "number") return;
    let enableSML = DiagramUtils.checkSMLEnable(this.nodeProps.supportedNodes, "valueTitleHolder");
    if (!enableSML) return;
    let oldResizeValue = getComputedStyle(this.diagramParent).getPropertyValue("--resizeValue");
    let oldValue = DiagramUtils.getSMLSizeFromValue(oldResizeValue, this.arrSMLSize);
    let restrictLogoSize = this.diagramData && this.diagramData.properties && this.diagramData.properties.floateroptionsdisable && this.diagramData.properties.floateroptionsdisable.includes("numbersize");
    if (restrictLogoSize) return;
    this.diagramParent.setAttribute("data-resizenumber", "true");
    this.diagramData.properties.numbersize = value;
    this.diagramParent.style.setProperty("--resizeValue", "var(--" + value + "Size)");
    this.updateProperties(this.diagramData.properties);
    let isRestrict = this.checkSMLOverflow(value == "auto" ? "auto" : oldValue);
    if (isRestrict && value != "auto") {
        if (updateCallBack) {
            this.showAlertEvent?.("Unable to change the size!, The size exceeds container...");
            this.diagramParent.style.setProperty("--contentResizeMH", "calc(var(--originalresizeheight) * var(--" + oldValue + "Size))");
            this.diagramParent.style.setProperty("--resizeValue", "var(--" + oldValue + "Size)");
            this.diagramParent.style.setProperty("--minContentSize", "var(--" + oldValue + "Size)");
        }
    } else if (updateCallBack) {
        this.resetInlineSize();
        this.resetLayout();
        // this.updatePropsCallBack();
    }
};

BaseDiagram.prototype.changeImageSize = function (value, updateCallBack = true) {
    let enableSML = DiagramUtils.checkSMLEnable(this.nodeProps.supportedNodes, "imageHolder");
    if (!enableSML || this.nodeProps.parentStyle.includes("clsresponsiveimage")) return;
    this.changeSize(value, "image", updateCallBack);
};

BaseDiagram.prototype.changeLogoSize = function (value, updateCallBack = true) {
    let enableSML = DiagramUtils.checkSMLEnable(this.nodeProps.supportedNodes, "imageSecHolder");
    if (!enableSML) return;
    this.changeSize(value, "logo", updateCallBack);
};

BaseDiagram.prototype.changeIconSize = function (value, updateCallBack = true) {
    let enableSML = DiagramUtils.checkSMLEnable(this.nodeProps.supportedNodes, "iconHolder");
    if (!enableSML) return;
    this.changeSize(value, "icon", updateCallBack);
};

BaseDiagram.prototype.changeMicroChartSize = function (value, updateCallBack = true) {
    let enableSML = DiagramUtils.checkSMLEnable(this.nodeProps.supportedNodes, "microChartHolder");
    if (!enableSML) return;
    this.changeSize(value, "microchart", updateCallBack, "number");
};

BaseDiagram.prototype.changeSize = function (value, type, updateCallBack = true, contenttype = null) {
    if (!value || this.diagramData.properties.contenttype != (contenttype ? contenttype : type)) return;
    let restrictIconSize = this.diagramData && this.diagramData.properties && this.diagramData.properties.floateroptionsdisable && this.diagramData.properties.floateroptionsdisable.includes(type + "size");
    if (restrictIconSize) return;

    let oldResizeValue = getComputedStyle(this.diagramParent).getPropertyValue("--resizeValue");
    let oldValue = DiagramUtils.getSMLSizeFromValue(oldResizeValue, this.arrSMLSize);
    value = DiagramUtils.checkSMLSizeFromFloater(value, this.diagramData.properties.floateroptionsdisable, this.arrSMLSize);
    DiagramUtils.setAutoSizeValue(this.diagramData.properties.floateroptionsdisable, this.arrSMLSize, this.diagramParent);

    let resizeDimension = "originalresizeheight";
    this.diagramParent.style.setProperty("--contentResizeMH", "calc(var(--" + resizeDimension + ") * var(--" + value + "Size))");
    this.diagramParent.style.setProperty("--resizeValue", "var(--" + value + "Size)");
    this.diagramParent.style.setProperty("--minContentSize", "var(--" + value + "Size)");
    this.diagramParent.setAttribute("data-resize" + type, "true");
    this.diagramParent.setAttribute("data-sizeOveride", "false");
    this.diagramData.properties[type + "size"] = value;
    this.updateProperties(this.diagramData.properties);
    let isRestrict = this.checkSMLOverflow(value == "auto" ? "auto" : oldValue);
    this.resetInlineSize();
    if (isRestrict && value != "auto") {
        if (updateCallBack) {
            this.showAlertEvent?.("Unable to change the size!, The size exceeds container...");
            this.diagramParent.style.setProperty("--contentResizeMH", "calc(var(--" + resizeDimension + ") * var(--" + oldValue + "Size))");
            this.diagramParent.style.setProperty("--resizeValue", "var(--" + oldValue + "Size)");
            this.diagramParent.style.setProperty("--minContentSize", "var(--" + oldValue + "Size)");
        }
    } else if (updateCallBack) {
        this.resetLayout();
        // this.updatePropsCallBack();
    }
};

BaseDiagram.prototype.resetInlineSize = function () {
    this.arrDiagramNode.forEach((node) => {
        node.objData.nodeproperties.size = "";
        node.updateNodeProperties(node.objData.nodeproperties);
        node.parentNode.style.removeProperty("--contentResizeMH");
        node.parentNode.style.removeProperty("--resizeValue");
        node.parentNode.style.removeProperty("--minContentSize");
    });
};

BaseDiagram.prototype.changeInlineSize = function (objSize) {
    let value = objSize.data;
    let type = objSize.objDetails.contenttype;
    let target = this.diagramParent.querySelector("[id='" + objSize.targetid + "']");
    let nodeInstance = this.arrDiagramNode[target.dataset.index];
    if (!value || this.diagramData.properties.contenttype != type) return;
    let restrictIconSize = this.diagramData && this.diagramData.properties && this.diagramData.properties.floateroptionsdisable && this.diagramData.properties.floateroptionsdisable.includes(type + "size");
    if (restrictIconSize) return;
    this.diagramParent.setAttribute("data-sizeOveride", "true");
    if (!this.allowContentResize(this.diagramData.properties[type + "size"], value)) {
        this.showAlertEvent?.("Unable to change the size!, The size exceeds container...");
        return;
    }
    nodeInstance.objData.nodeproperties.size = value;
    nodeInstance.updateNodeProperties(nodeInstance.objData.nodeproperties);
    this.setInlineMinSize(type);
    this.resetLayout();
    // this.updatePropsCallBack();
};

BaseDiagram.prototype.setInlineMinSize = function (type) {
    if (this.diagramParent?.dataset?.name?.includes("-mc-")) return;
    let diagramStyle = getComputedStyle(this.diagramParent);
    let maxSize = 0;
    this.arrDiagramNode.forEach((node) => {
        if (node?.objData?.nodeproperties?.size && node?.objData?.nodeproperties?.size != "") {
            let value = node.objData.nodeproperties.size;
            maxSize = Math.max(parseFloat(diagramStyle.getPropertyValue("--" + value + "Size")), maxSize);
            node.parentNode.style.setProperty("--contentResizeMH", "calc(var(--originalresizeheight) * var(--" + value + "Size))");
            node.parentNode.style.setProperty("--resizeValue", "var(--" + value + "Size)");
        } else maxSize = Math.max(parseFloat(diagramStyle.getPropertyValue("--" + this.diagramData.properties[type + "size"] + "Size")), maxSize);
    });
    this.diagramParent.style.setProperty("--minContentSize", maxSize);
    // console.log("max size : " + maxSize);
};

BaseDiagram.prototype.showHideContent = function () {
    let previousState = getComputedStyle(this.diagramParent.parentElement).getPropertyValue("--contentdisplay").trim();
    let visible = previousState != "none";
    this.diagramParent.parentElement.style.setProperty("--contentdisplay", visible ? "none" : "block");
    this.diagramParent.setAttribute("data-content", !visible);
    this.diagramData.properties.diagramcontent = !visible;
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

BaseDiagram.prototype.showHideNumber = function () {
    let previousState = getComputedStyle(this.diagramParent.parentElement).getPropertyValue("--numberdisplay").trim();
    let visible = previousState == "flex";
    this.diagramParent.parentElement.style.setProperty("--numberdisplay", visible ? "none" : "flex");
    this.diagramData.properties.sequencetext = !visible;
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "sequence", this.diagramData.properties.sequencetext, true);
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

BaseDiagram.prototype.changeValueFormat = function (objValue, isFromUndo = false) {
    let value = objValue.value;
    let arrValueNew = objValue.arrValueNew;
    this.diagramData.properties.valueformat = value;
    this.updateProperties(this.diagramData.properties);
    let arrNumberNodes = this.diagramParent.querySelectorAll("[name='numberNode']");
    arrNumberNodes.forEach((element, index) => {
        if (arrValueNew && arrValueNew.length > 0) {
            element.innerHTML = arrValueNew[index];
        }
        if (!isFromUndo) DiagramNodeUtils.checkNumberFormat(element, this.diagramParent, this.globalMoodData, this.nodeProps, true);
    });
    this.resetLayout();
};

BaseDiagram.prototype.resizeValueText = function (oldValue) {
    let arrValueText = this.diagramParent.querySelectorAll("[name='numberNode']");
    let maxScrollWidth = 0;
    let valueText = arrValueText[0];
    if (!valueText) return false;
    arrValueText.forEach((element) => {
        element.parentElement.style.setProperty("width", "fit-content");
        if (element.scrollWidth > maxScrollWidth) {
            valueText = element;
        }
        maxScrollWidth = Math.max(maxScrollWidth, element.scrollWidth);
    });

    let content = valueText.parentElement.parentElement;
    let computedStyleContent = window.getComputedStyle(content);
    let paddingLeft = parseInt(computedStyleContent.paddingLeft);
    let paddingRight = parseInt(computedStyleContent.paddingRight);
    let finalWidth = content.clientWidth - paddingLeft - paddingRight;

    function performResizeValueText() {
        if (valueText && maxScrollWidth > parseInt(finalWidth)) {
            this.diagramData.properties[this.diagramData.properties.contenttype + "size"] = oldValue;
            this.updateProperties(this.diagramData.properties);
            this.updatePropsCallBack(valueText.id);
            let arrSize = Object.keys(this.arrSMLSize).reverse();
            for (const key in arrSize) {
                DiagramUtils.updateResize(this.diagramParent, arrSize[key], this.nodeProps, this.diagramData.properties);
                if (valueText.scrollWidth < parseInt(finalWidth)) {
                    return true;
                }
            }
            return true;
        }
        if (valueText && maxScrollWidth < parseInt(finalWidth) && this.diagramData.properties[this.diagramData.properties.contenttype + "size"] == "auto") {
            this.diagramData.properties[this.diagramData.properties.contenttype + "size"] = oldValue;
            this.updateProperties(this.diagramData.properties);
            this.updatePropsCallBack(valueText.id);
            let arrSize = Object.keys(this.arrSMLSize).reverse();
            for (const key in arrSize) {
                DiagramUtils.updateResize(this.diagramParent, arrSize[key], this.nodeProps, this.diagramData.properties);
                if (valueText.scrollWidth < parseInt(finalWidth)) {
                    return true;
                }
            }
            return true;
        }
    }
    let returnResize = performResizeValueText.bind(this)();
    arrValueText.forEach((element) => {
        element.parentElement.style.removeProperty("width");
    });
    return returnResize;
};

BaseDiagram.prototype.showHideSecondary = function (value) {
    this.diagramData.properties.secondarytext = value;
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "secondary", this.diagramData.properties.secondarytext, true);
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

BaseDiagram.prototype.showHideMulticontentHeader = function (value) {
    this.diagramData.properties.multicontentheader = value;
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "multicontentheader", value, true);
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

BaseDiagram.prototype.showHidePrimary = function (value) {
    this.diagramData.properties.primarytext = value;
    // this.diagramParent.parentElement.style.setProperty("--primarytextdisplay", value ? "flex" : "none");
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "primary", value, true);
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

BaseDiagram.prototype.showHideDiagramTitle = function (value) {
    this.diagramData.properties.diagramtitle = value;
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "diagramtitle", value, true);
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

BaseDiagram.prototype.showHideSecondaryPlaceholder = function (value) {
    this.diagramData.properties.secondaryplaceholder = value;
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

BaseDiagram.prototype.showHideSecondaryPlaceholderSwitch = function (value) {
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, this.diagramData.properties.secondaryplaceholder, value, true);
    if (value) this.showHideButton(false);
    this.diagramData.properties.enablesecplaceholder = value;
    this.updateProperties(this.diagramData.properties);
    // this.updatePropsCallBack();
    this.resetLayout();
};

BaseDiagram.prototype.showHideArrows = function (value) {
    this.diagramData.properties.hasconnector = value;
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "connector", value, true);
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
    // if (this.recalculateWidth) this.recalculateWidth();
};

BaseDiagram.prototype.showHideButton = function (value) {
    this.diagramData.properties.button = value;
    this.updateProperties(this.diagramData.properties);
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "button", value);
    if (value) this.showHideSecondaryPlaceholderSwitch(false);
    this.resetLayout();
};

BaseDiagram.prototype.showHideMicroChart = function (value) {
    this.diagramData.properties.microchart = value;
    this.updateProperties(this.diagramData.properties);
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "microchart", value);
    this.resetLayout();
};

BaseDiagram.prototype.showHideLabel = function (value) {
    this.diagramData.properties.label = value;
    this.diagramParent.parentElement.style.setProperty("--textlabeldisplay", value ? "flex" : "none");
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "label", value, true);
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

BaseDiagram.prototype.showHideSubtext = function (value) {
    this.diagramData.properties.subtext = value;
    this.diagramParent.parentElement.style.setProperty("--subtextdisplay", value ? "flex" : "none");
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "subtext", value, true);
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

BaseDiagram.prototype.showHideQuote = function (value) {
    this.diagramData.properties.quote = value;
    // this.diagramParent.parentElement.style.setProperty("--subtextdisplay", value ? "flex" : "none");
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "quote", value, true);
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

BaseDiagram.prototype.showHideAuthorStyleName = function (value) {
    this.diagramData.properties.authorname = value;
    this.diagramParent.parentElement.style.setProperty("--authorstylenamedisplay", value ? "flex" : "none");
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

BaseDiagram.prototype.showHideAuthorStyleDes = function (value) {
    this.diagramData.properties.authordes = value;
    this.diagramParent.parentElement.style.setProperty("--authorstyledesdisplay", value ? "flex" : "none");
    this.updateProperties(this.diagramData.properties);
    this.resetLayout();
};

BaseDiagram.prototype.showHideAuthorStyleImage = function (value) {
    this.diagramData.properties.authorimage = value;
    this.diagramParent.parentElement.style.setProperty("--authorstyleimagedisplay", value ? "flex" : "none");
    this.updateProperties(this.diagramData.properties);
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "authorimage", value);
    this.resetLayout();
};

BaseDiagram.prototype.changeNumberStart = function (value) {
    this.diagramData.properties.sequencetextstart = value;
    this.updateProperties(this.diagramData.properties);
    this.resetNodeAttributes();
};

BaseDiagram.prototype.changeNumberReverse = function (value) {
    this.diagramData.properties.sequencetextreverse = value;
    this.updateProperties(this.diagramData.properties);
    this.resetNodeAttributes();
};

BaseDiagram.prototype.checkButtonVisible = function () {
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "button", this.diagramData.properties.button);
};

BaseDiagram.prototype.checkSequenceVisible = function () {
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "sequence", this.diagramData.properties.sequencetext);
};

BaseDiagram.prototype.checkMicroChartVisible = function () {
    let microChart = this.diagramParent.querySelector("[name='microChartHolder'][data-holder-type='secondary']");
    if (microChart) {
        DiagramUtils.setEnableDisableClassNames(this.diagramParent, "microchart", this.diagramData.properties.microchart);
    } else this.diagramParent.classList.remove("clsmicrochartdisable");
};

BaseDiagram.prototype.checkConnectorVisible = function () {};

BaseDiagram.prototype.checkAuthorImageVisible = function () {
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "authorimage", this.diagramData.properties.authorimage);
};

BaseDiagram.prototype.resetLayout = function () {
    this.updateCssAttributes();
    this.resetHolderWidth();
};

BaseDiagram.prototype.nodeStyleChange = function (index) {
    let nodeInstance = this.arrDiagramNode[index];
    let supportedNodes = [{ name: "contentNode", subNodes: [{ name: "imageHolder", holdertype: "primary" }] }, { name: "titleHolder" }, { name: "subTitleHolder" }];
    let parentStyle = "clsDynamicImage clsLeftAlignment";
    nodeInstance.parentStyle = parentStyle;
    nodeInstance.arrSupportedNodes = supportedNodes;
    let mainParent = nodeInstance.nodeGroup.parentElement.parentElement;
    mainParent.remove();
    nodeInstance.initCreation();
    this.updateEvents();
    this.resetNodeAttributes();
};

BaseDiagram.prototype.updateProperty = function (property, value) {
    if (property && property != "" && value != undefined && value != null) {
        this.diagramData.properties[property] = value;
        this.updateProperties(this.diagramData.properties);
    }
};

BaseDiagram.prototype.getOldPropertyValue = function (property, valueObj) {
    return DiagramUtils.getOldPropertyValue(property, valueObj, this.diagramParent, this);
};

BaseDiagram.prototype.setOperationProperty = function (property, valueObj, isFromUndo = false) {
    DiagramUtils.setOperationProperty(property, valueObj, valueObj.contentType == "BG_IMAGE" && this.bgDeviceDiv ? this.bgDeviceDiv : this.diagramParent, this, isFromUndo);
};

BaseDiagram.prototype.resetNodeAttributes = function () {
    this.updateTextNodes();
    if (this.diagramData?.properties?.seperatorline) {
        DiagramResizeUtils.resetRowColumnBounds(this.arrDiagramNode);
        DiagramResizeUtils.setArrRowColumnBounds(this.arrDiagramNode);
    }
    this.diagramParent.setAttribute("data-nodecount", this.arrDiagramNode.length);
    for (let i = 0; i < this.arrDiagramNode.length; i++) {
        if (this.globalMoodData) this.arrDiagramNode[i].globalMoodData = this.globalMoodData;
        this.arrDiagramNode[i].properties = this.diagramData.properties;
        if (this.arrTintArray) this.arrDiagramNode[i].arrTintArray = this.arrTintArray;
        this.arrDiagramNode[i].updateNodeAttributes(i, this.diagramRenderComplete);
        if (this.arrDiagramNode[i].parentNode && this.arrDiagramNode[i].parentNode.dataset.highlight == "true") this.setHighlightTargetPoints(this.arrDiagramNode[i].parentNode, this.diagramParent);
    }
    if (this.centerHolderNode) {
        this.centerHolderNode.updateNodeAttributes(0, this.diagramRenderComplete);
    }
};

BaseDiagram.prototype.updateTextNodes = function (index) {
    this.arrDiagramNode?.[0]?.updateOnFocusOut();
    this.arrDiagramNode?.forEach((node) => {
        node?.setMaxHeightForLogoList?.();
    });
    DiagramCreateUtil.setDiagramTitleSingleLine(this.diagramParent);
};

BaseDiagram.prototype.lineHeightLetterSpacingChangeOperation = function (objData, targetNode) {
    this.updateTextNodes();
};

BaseDiagram.prototype.resetImageLogoFrames = function () {
    for (let i = 0; i < this.arrDiagramNode.length; i++) {
        this.arrDiagramNode[i].updateImageLogoFrames();
    }
    if (this.centerHolderNode) {
        this.centerHolderNode.updateImageLogoFrames();
    }
};

BaseDiagram.prototype.updateImageBounds = function (image, objData, scale) {
    CommonImageUtils.updateImageBounds(image, objData, scale);
};

BaseDiagram.prototype.deleteNode = function (targetIndex) {
    let isConnectorDelete = targetIndex == this.arrDiagramNode.length - 1;
    if (this.arrDiagramNode.length > targetIndex) {
        this.arrDiagramNode.splice(targetIndex, 1);
        let nodeDelete = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + targetIndex + "']");
        if (nodeDelete && nodeDelete.parentElement) {
            // nodeDelete.parentElement.remove();
            nodeDelete.parentElement.parentElement.removeChild(nodeDelete.parentElement);
        }
    }
    if (this.diagramData.nodes.length > targetIndex) {
        this.diagramData.nodes.splice(targetIndex, 1);
    }
    DiagramNodeUtils.updateNodeSizeForClient(this.diagramData, this.diagramParent, this.nodeGap);
    let index = this.diagramParent.getAttribute("data-emphasis");
    if (index == targetIndex) this.hideEmpahsis();

    this.resetHolderWidth();
    this.updateEmphasize();
    this.resetNodeAttributes();
    // setTimeout(() => {
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (targetIndex - 1) + "']");
    if (lastDiv && isConnectorDelete) {
        let lastConnector = lastDiv.parentElement.querySelector("[name='connectorparent']");
        if (lastConnector) lastConnector.remove();
        this.updatePropsCallBack(lastDiv.id);
    }
    this.diagramRenderComplete();
    this.updateJSONData();
    // }, 100);
};

BaseDiagram.prototype.addNode = function (nodeData, index, isFromUndo = false) {
    this.eventManagerXY.clear();
    let connectorAdd = index == this.arrDiagramNode.length;
    if (this.diagramData.nodes.length > index) {
        this.diagramData.nodes.splice(index, 0, nodeData);
    } else {
        this.diagramData.nodes.push(nodeData);
    }
    this.diagramParent.setAttribute("data-nodecount", this.diagramData.nodes.length);
    let lastNode = this.arrDiagramNode[this.arrDiagramNode.length - 1];
    if (connectorAdd && lastNode && this.diagramParent.dataset.classname == "SimpleBaseDiagram") lastNode.connectorNode = lastNode.createConnectorParent(lastNode.parentNode.parentElement, lastNode.objData.content);
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    let nodeItem = new window[this.nodeProps.nodeclassName](nodesHolder, this.diagramData.properties, nodeData, this.eventManagerXY, this.arrDiagramNode.length, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
    this.createNodeInstanceProperties(nodeItem);
    if (!isFromUndo) DiagramPropertyUtils.resetNodeProperties(nodeItem.objData);
    nodeItem.index = index;
    nodeItem.initCreation(this.isGridAsset(this.nodeProps.name) ? false : connectorAdd);
    if (this.arrDiagramNode.length > index) {
        this.arrDiagramNode.splice(index, 0, nodeItem);
    } else {
        this.arrDiagramNode.push(nodeItem);
    }
    DiagramNodeUtils.updateNodeSizeForClient(this.diagramData, this.diagramParent, this.nodeGap);
    this.updateEvents();
    this.updateEmphasize();
    this.updateSpecialOperations();
    this.resetHolderWidth();
    this.updateJSONData();
    this.diagramRenderComplete();
    this.addFocus(index);

    if (this.gridInstance) {
        if (this.nodeProps.imagegridclass) DiagramUtils.addClassNames(this.nodeProps.imagegridclass, this.diagramParent);
    }
};

BaseDiagram.prototype.isGridAsset = function (name) {
    return name.startsWith("grd");
};

BaseDiagram.prototype.isNodeAddable = function () {
    if (this.nodeProps.nodeclassName == "VerticalSplitColumnDiagramNode") {
        let emptySpace = DiagramResizeUtils.calculateEmptySpace(this.diagramParent);
        if (emptySpace && emptySpace > 90) return true;
        else {
            // alert("Unable to add Node!");
            return false;
        }
    } else return true;
};

BaseDiagram.prototype.updateSpecialOperations = function () {
    this.logoGreyScale(this.diagramData.properties.greyscale, false);
    this.toggleVisibility();
    this.updateCssAttributes();
    this.changeLogoSize(this.diagramData.properties.logosize, false);
    this.changeImageSize(this.diagramData.properties.imagesize, false);
    this.changeNumberSize(this.diagramData.properties.numbersize, false);
    this.changeIconSize(this.diagramData.properties.iconsize, false);
};

BaseDiagram.prototype.toggleVisibility = function () {
    this.checkItemVisiblily();
    this.checkMicroChartVisible();
    this.checkConnectorVisible();
};

BaseDiagram.prototype.addFocus = function (index) {
    if (this.isTempSlide || this.isTakeAway) return;
    let primaryTextNode = this.diagramParent.querySelector("[data-id='primaryText'][data-index='" + index + "']");
    // if (primaryTextNode && this.appmode != "present") primaryTextNode.focus();
};

BaseDiagram.prototype.addNodesForDiagram = function (nodeData, index) {
    let lastNode = this.arrDiagramNode[this.arrDiagramNode.length - 1];
    if (lastNode && lastNode.seperator) lastNode.connectorNode = lastNode.createConnectorParent(lastNode.parentNode.parentElement, lastNode.objData.content);
    let firstNode = this.arrDiagramNode[0];
    let node = JSON.parse(JSON.stringify(firstNode.objData));
    node.content = { type: "", value: "", contenttype: "" };
    node.seccontent = [];
    node.tertiarycontent = [];
    node.primarytext = { type: "", value: "" };
    node.secondarytext = { type: "", items: [{ type: "text", value: "" }] };
    DiagramPropertyUtils.resetNodeProperties(node);

    this.diagramData.nodes.push(node);
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    let nodeItem = new window[this.nodeProps.nodeclassName](nodesHolder, this.diagramData.properties, node, this.eventManagerXY, this.arrDiagramNode.length, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
    this.createNodeInstanceProperties(nodeItem);
    nodeItem.initCreation(true);
    this.arrDiagramNode.push(nodeItem);
};

BaseDiagram.prototype.changeSecondaryType = function (type, index) {
    // this.diagramData.properties.secondarytype = type;
    if (this.arrDiagramNode && this.arrDiagramNode.length > index) {
        this.arrDiagramNode[index].changeSecondaryType(type, index);
    }
    this.updateTextNodes();
};

BaseDiagram.prototype.changeNestedList = function (index, element) {
    let recursiveUl = element.cloneNode();
    recursiveUl.innerHTML = "";
    recursiveUl.style.marginLeft = "40px";
    let parentElement = element.children[index - 1];
    let arrElements = Array.from(element.children);
    arrElements.forEach((item, j) => {
        if (index <= j) {
            item.remove();
            recursiveUl.appendChild(item);
        }
    });

    parentElement.appendChild(recursiveUl);
};

BaseDiagram.prototype.updateElements = function () {
    this.eventManagerXY.clear();
    this.clear();
    this.recreateElementData();
    if (!this.diagramData || this.diagramData?.nodes.length == 0) this.updateJSONData();
    this.toggleVisibility();
    this.updateEvents();
    // this.resetHolderWidth();
};

BaseDiagram.prototype.updateJSONData = function () {
    this.diagramData = this.getJSONData();
    // this.centerholderdata = this.getCenterHolderData?.();
};

// Diagram properties Get/Set

BaseDiagram.prototype.updateProperties = function (properties) {
    this.setPropertiesFromConstants(properties, JSON.parse(JSON.stringify(Constants.Value.arrProperties)));
    if (this.nodeProps) this.updateNodeProperties();
};

BaseDiagram.prototype.updateNodeProperties = function () {
    // this.diagramParent.setAttribute("data-node-classname", this.nodeProps.className || "PlainDiagramNode");
    this.setPropertiesFromConstants(this.nodeProps, JSON.parse(JSON.stringify(Constants.Value.arrNodeProperties)), "node");
};

BaseDiagram.prototype.updateNodeLink = function (valueObj) {
    DiagramUtils.updateNodeLink(valueObj.parent, valueObj.operation);
};

BaseDiagram.prototype.changeLogoContrast = function (valueObj, target, nodeGroup, logoGridIndex) {
    let logoNode = target.querySelector("[data-id='logoNode']");
    if (target.dataset.componentType && target.dataset.componentType == "grid") {
        this.arrDiagramNode[logoGridIndex]?.gridInstance?.changeLogoGridContrast(logoNode, valueObj.value, target.dataset.imagegridIndex);
    } else {
        DiagramUtils.setLogoContrast(logoNode, nodeGroup, valueObj.value);
    }
};

BaseDiagram.prototype.getProperties = function (defaultproperties = {}) {
    let mainProperties = this.diagramData && this.diagramData.properties ? this.diagramData.properties : defaultproperties;
    this.getPropertiesFromConstants(mainProperties, JSON.parse(JSON.stringify(Constants.Value.arrProperties)));
    this.getNodeProperties();
    // if (this.isTakeAway) mainProperties.hasconnector = false;
    return mainProperties;
};

BaseDiagram.prototype.getNodeProperties = function () {
    if (this.nodeProps == null) this.nodeProps = {};
    this.getPropertiesFromConstants(this.nodeProps, JSON.parse(JSON.stringify(Constants.Value.arrNodeProperties)), "node");
    this.updateMoodProperties();
};

BaseDiagram.prototype.getPropertiesFromConstants = function (mainObj, constArrProperties, extraAttrib = "") {
    let arrPropertiesMenu = extraAttrib == "node" ? Constants.Value.arrStaticNodeProperties : Constants.Value.arrStaticProperties;
    for (var property in constArrProperties) {
        let propValue = this.diagramParent.dataset[extraAttrib + property.toLowerCase()];
        let propertyTrimmed = property.replace("json", "").replace("bool", "");
        if ((propValue == undefined || propValue == null || propValue == "") && arrPropertiesMenu.includes(property) && this.menuData) {
            mainObj[propertyTrimmed] = this.menuData[propertyTrimmed];
        } else {
            if (property.includes("json")) {
                property = propertyTrimmed;
                propValue = this.diagramParent.dataset[extraAttrib + property.toLowerCase()];
                try {
                    mainObj[property] = propValue ? (propValue.includes(",") && !propValue.startsWith("{") ? propValue.split(",") : JSON.parse(propValue)) : constArrProperties["json" + property];
                } catch (error) {
                    mainObj[property] = propValue ? propValue : constArrProperties["json" + property];
                }
            } else if (property.includes("bool")) {
                property = propertyTrimmed;
                propValue = this.diagramParent.dataset[extraAttrib + property.toLowerCase()];
                mainObj[property] = propValue && (propValue == "true" || propValue == true) ? true : false;
            } else if (property.includes("arr")) {
                mainObj[property] = propValue && propValue != "" ? propValue.split(",") : constArrProperties[property];
            } else {
                mainObj[property] = propValue || constArrProperties[property];
            }
        }
    }
};

BaseDiagram.prototype.getPropertiesFromConstantsMenuJson = function (mainObj, data, constArrProperties) {
    for (var property in constArrProperties) {
        let jsonFormat = property.includes("json");
        let boolFormat = property.includes("bool");
        if (Object.keys(constArrProperties).includes(property)) {
            property = jsonFormat || boolFormat ? property.substring(4) : property;
            if (boolFormat) mainObj[property] = data[property] && (data[property] == "true" || data[property] == true) ? true : mainObj[property] || false;
            else mainObj[property] = data[property] || mainObj[property] || constArrProperties[jsonFormat ? "json" + property : property];
        }
    }
};

BaseDiagram.prototype.setPropertiesFromConstants = function (mainObj, constArrProperties, extraAttrib = "") {
    let arrPropertiesDom = extraAttrib == "node" ? Constants.Value.arrNodePropertiesDom : Constants.Value.arrPropertiesDom;
    let arrPropertiesMenu = extraAttrib == "node" ? Constants.Value.arrStaticNodeProperties : Constants.Value.arrStaticProperties;
    for (var property in constArrProperties) {
        if (!arrPropertiesMenu.includes(property)) {
            let setPropertyToDom = arrPropertiesDom.includes(property);
            let jsonFormat = property.includes("json");
            let boolFormat = property.includes("bool");
            property = jsonFormat || boolFormat ? property.substring(4) : property;
            if (jsonFormat) {
                // let value = mainObj[property] ? JSON.stringify(mainObj[property]) : constArrProperties["json" + property];
                let stringValue = mainObj[property] ? JSON.stringify(mainObj[property]) : null;
                let value = mainObj[property] ? (mainObj[property] instanceof Array ? mainObj[property] : stringValue) : null;
                if (setPropertyToDom) {
                    if (mainObj[property] && value != null) this.diagramParent.setAttribute("data-" + extraAttrib + property, value);
                } else if (mainObj[property] && value != null && stringValue != JSON.stringify(constArrProperties["json" + property])) this.diagramParent.setAttribute("data-" + extraAttrib + property, value);
                // if (mainObj[property] && value != null) this.diagramParent.setAttribute("data-" + extraAttrib + property, value);
            } else if (boolFormat) {
                if (setPropertyToDom) {
                    if (mainObj[property]) this.diagramParent.setAttribute("data-" + extraAttrib + property, mainObj[property]);
                    else if (this.diagramParent.hasAttribute("data-" + extraAttrib + property)) this.diagramParent.removeAttribute("data-" + extraAttrib + property);
                } else {
                    if (mainObj[property] != null && mainObj[property] != constArrProperties["bool" + property]) this.diagramParent.setAttribute("data-" + extraAttrib + property, mainObj[property]);
                    else if (this.diagramParent.hasAttribute("data-" + extraAttrib + property)) this.diagramParent.removeAttribute("data-" + extraAttrib + property);
                }
            } else if (mainObj[property]) {
                // let value = mainObj[property] || constArrProperties[property];
                let value = mainObj[property];
                if (setPropertyToDom) {
                    if (value != null && value != "") this.diagramParent.setAttribute("data-" + extraAttrib + property, value);
                    else if (this.diagramParent.hasAttribute("data-" + extraAttrib + property)) this.diagramParent.removeAttribute("data-" + extraAttrib + property);
                } else {
                    if (value != null && value != "" && value.toString() != constArrProperties[property]) this.diagramParent.setAttribute("data-" + extraAttrib + property, value);
                    else if (this.diagramParent.hasAttribute("data-" + extraAttrib + property)) this.diagramParent.removeAttribute("data-" + extraAttrib + property);
                }
            }
        }
    }
};

BaseDiagram.prototype.getDiagramPropertiesFromMenu = function (properties, data) {
    let arrProperties = JSON.parse(JSON.stringify(Constants.Value.arrProperties));
    let arrNodeProperties = JSON.parse(JSON.stringify(Constants.Value.arrNodeProperties));
    properties.floateroptionsdisable = arrProperties.jsonfloateroptionsdisable; // Reset FloaterOption to default
    this.getPropertiesFromConstantsMenuJson(properties, data, arrProperties);
    //node props
    if (this.nodeProps == null) this.nodeProps = {};
    this.nodeProps.iconBG = data.iconBG;
    this.getPropertiesFromConstantsMenuJson(this.nodeProps, data, arrNodeProperties);
    this.updateProperties(properties);
    this.updateMoodProperties();
    this.updateFloaterSettings(this.diagramData.properties);
};

BaseDiagram.prototype.isNonLinearAsset = function () {
    return false;
};

BaseDiagram.prototype.swapNodes = function (objData, swapNodeIndex) {
    let target = this.diagramParent.querySelector("[id='" + objData.targetid + "']");
    if (target) {
        let index = parseInt(target.dataset.index);
        let swapIndex = index + swapNodeIndex;
        let currentTarget = this.diagramParent.querySelector("[id='nodeMainParent" + index + "']");
        let currentConnector = currentTarget.querySelector("[name='connectorparent']");
        let swapTarget = this.diagramParent.querySelector("[id='nodeMainParent" + swapIndex + "']");
        let swapConnector = swapTarget.querySelector("[name='connectorparent']");

        currentTarget.remove();
        currentTarget.setAttribute("id", "nodeMainParent" + swapIndex);
        if (swapConnector) {
            swapConnector.remove();
            currentTarget.appendChild(swapConnector);
        }
        swapTarget.parentElement.insertBefore(currentTarget, swapNodeIndex == 1 ? swapTarget.nextSibling : swapTarget);
        swapTarget.setAttribute("id", "nodeMainParent" + index);
        if (currentConnector) {
            currentConnector.remove();
            swapTarget.appendChild(currentConnector);
        }
        this.arrDiagramNode = DiagramUtils.swapArrayElements(this.arrDiagramNode, index, swapIndex);
        this.resetHolderWidth();
        if (this.checkHighlight) this.checkHighlight(this.diagramParent);
        // this.updatePropsCallBack(objData.targetid);
    }
};

BaseDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    const jsonStr = this.nodeProps.supportedNodes ? JSON.stringify(this.nodeProps.supportedNodes) : "";
    const graphicName = this.nodeProps.name;
    // const seqNumber = jsonStr.includes("seqTitleHolder");
    const seqNumber = true;
    const secText = jsonStr.includes("subTitleHolder");
    const checkList = jsonStr.includes("checkListHolder");
    const isNonLinear = this.isNonLinearAsset();
    const centerNodeAsset = jsonStr.includes("centerNode");
    const isLogoGrid = this.nodeProps && this.nodeProps.name && this.nodeProps.name.includes("-lgrd");
    const isLogoAsset = this.nodeProps && this.nodeProps.name && (this.nodeProps.name.includes("hor-lg") || this.nodeProps.name.includes("ver-lg") || this.nodeProps.name.includes("grd-lg"));
    const showSeq = (this.nodeProps.name.includes("-ic-") || this.nodeProps.name.includes("-img-") || this.nodeProps.name.includes("-aw-")) && !isNonLinear && !isLogoGrid;
    const isQuote = this.nodeProps.quoteShape || this.nodeProps.name.includes("qt");
    const isIllustration = this.nodeProps.name.includes("ills");
    const isTestimonial = this.nodeProps.name.includes("tes");
    const isDevice = this.nodeProps.name.includes("device") || this.diagramParent.dataset.classname == "SimpleBaseDiagramDevice";
    const isMicroChart = this.nodeProps.microStyle || this.nodeProps.name.includes("-mc-");
    const isCustomSecondary = mainProperties.secondarytype && mainProperties.secondarytype == "custom";
    const isTeamAsset = this.nodeProps && this.nodeProps.name.includes("-team");
    const isNonLinearList = (this.diagramParent.dataset.classname && this.diagramParent.dataset.classname == "SimpleNonBaseDiagram") || (this.diagramParent.dataset.classname && this.diagramParent.dataset.classname == "SvgScale9BgList");

    const restrictCrossOut = isNonLinear || isDevice || graphicName.includes("ver-num-tx") || graphicName.includes("ver-ckd-tx") || graphicName.includes("ver-bul-tx") || jsonStr.includes("textTitleHolder");
    const restrictImageSize = graphicName.includes("pot") || graphicName.includes("sqr") || graphicName.includes("land") || isDevice;
    const restrictConnector = isQuote || isTeamAsset || isIllustration || isDevice || isMicroChart;
    const restrictArrange = isIllustration || isDevice;

    let arrFloaterDisable = mainProperties.floateroptionsdisable;
    if (!arrFloaterDisable) return;
    try {
        if (!secText) {
            if (!arrFloaterDisable.includes("secondarytext")) arrFloaterDisable.push("secondarytext");
        }
    } catch (error) {}
    try {
        if (!seqNumber) {
            if (!arrFloaterDisable.includes("sequencetext")) arrFloaterDisable.push("sequencetext");
        }
    } catch (error) {}
    // if (checkList) arrFloaterDisable.push("edit");
    if (isTeamAsset || isMicroChart) arrFloaterDisable.push("ver");
    if (isTeamAsset || isMicroChart || isIllustration) arrFloaterDisable.push("content", "contentoptions");
    if (isQuote) {
        arrFloaterDisable.push("content", "contentoptions", "iconsize");
        // mainProperties.authorimage = jsonStr.includes("imageHolder");
    }
    if (restrictCrossOut) arrFloaterDisable.push("crossout");
    if (restrictImageSize) arrFloaterDisable.push("imagesize");
    if (restrictConnector) arrFloaterDisable.push("connector");
    if (restrictArrange) arrFloaterDisable.push("arrange");
    if (isCustomSecondary) arrFloaterDisable.push("bullet", "decimal", "textpara");
    if (!isLogoAsset) arrFloaterDisable.push("greyscale");
    if (isNonLinear) {
        arrFloaterDisable.push("fontresize");
        arrFloaterDisable.push("iconsize");
        arrFloaterDisable.push("imagesize");
        arrFloaterDisable.push("logosize");
        arrFloaterDisable.push("numbersize");
        arrFloaterDisable.push("greyscale");
        arrFloaterDisable.push("swap");
        arrFloaterDisable.push("secondaryplaceholder");
    }
    if (isTestimonial) arrFloaterDisable.push("secondaryplaceholder");
    if (this.nodeProps.name.includes("-img-por") || this.nodeProps.name.includes("-img-sqr") || (this.nodeProps.name.includes("-img-land") && !this.nodeProps.name.includes("grd"))) arrFloaterDisable.push("grd");
    this.diagramParent.setAttribute("data-floateroptionsdisable", arrFloaterDisable);
    this.updateProperties(mainProperties);
};

BaseDiagram.prototype.emphasize = function (emphasizeData) {
    let index = 0;
    let targetid = emphasizeData && emphasizeData.targetid;
    if (targetid) {
        let target = this.diagramParent.querySelector("[id='" + targetid + "']");
        index = target.dataset.index;
    }
    this.hideEmpahsis();
    // for (let i = 0; i < this.arrDiagramNode.length; i++) {
    if (emphasizeData.value && emphasizeData.value == true) this.showEmpahsis(index);
    // }
    // this.updatePropsCallBack(targetid);
};

BaseDiagram.prototype.updateEmphasize = function () {
    let index = this.diagramParent.getAttribute("data-emphasis");
    if (index) {
        this.hideEmpahsis();
        this.showEmpahsis(index);
    }
};

BaseDiagram.prototype.hideEmpahsis = function () {
    let baseEmphasisClass = this.nodeProps.emphasisClass ? this.nodeProps.emphasisClass : "clsEmphasis";
    this.diagramParent.removeAttribute("data-emphasis");
    let allNodes = this.diagramParent.querySelectorAll("[name='nodeMainParent']");
    for (let i = 0; i < allNodes.length; i++) {
        allNodes[i].classList.remove("mood");
        allNodes[i].classList.remove(baseEmphasisClass + "DisabledBG");
        allNodes[i].classList.remove(baseEmphasisClass + "Disabled");
        allNodes[i].classList.remove(baseEmphasisClass + "EnabledBG");
        allNodes[i].classList.remove(baseEmphasisClass + "Enabled");
        // allNodes[i].firstElementChild.setAttribute("data-emphasize", "false");
        this.arrDiagramNode[i].nodeGroup.setAttribute("data-emphasize", "false");
    }
};

BaseDiagram.prototype.showEmpahsis = function (index) {
    this.diagramParent.setAttribute("data-emphasis", index);
    this.diagramParent.style.setProperty("--emphasis-color", "var(--item" + (parseInt(index) + 1) + "-color)");
    this.diagramParent.style.setProperty("--gradient-emphasis-color", "linear-gradient(-45deg, rgba(var(--item" + (parseInt(index) + 1) + "-color-rgb), 1) 12%, rgba(var(--item" + (parseInt(index) + 2) + "-color-rgb), 1) 83%)");

    let nodeBorder = this.nodeProps.nodeBorder ? this.nodeProps.nodeBorder.split(",") : [];
    let arrNodeData = [];
    if (nodeBorder.length == 4) {
        const nodeData = nodeBorder[3].replace(/\s/g, "");
        arrNodeData = [nodeData];
        const hasMulti = nodeData.includes("[") && nodeData.includes("]");
        if (hasMulti) {
            arrNodeData = nodeData.replace("[", "").replace("]", "").split(":");
        }
    }

    let hasBorder = arrNodeData.length > 0;

    let nodeBGColorOptions = this.nodeProps.bgColor ? this.nodeProps.bgColor.split(",") : [];
    let strColorOptions = nodeBGColorOptions.length > 0 ? nodeBGColorOptions[0] : "";
    const hasOpacity = nodeBGColorOptions.length > 0 && strColorOptions.includes(":") && strColorOptions.includes("[") && strColorOptions.includes("]");
    if (hasOpacity && nodeBGColorOptions.length > 1) {
        let opacity = isNaN(nodeBGColorOptions[1]) ? "1" : nodeBGColorOptions[1];
        nodeBGColorOptions = strColorOptions.replace("[", "").replace("]", "").split(":");
        nodeBGColorOptions.push(opacity);
    }

    let hasBG = nodeBGColorOptions.length > 1;
    let bgNodeData = nodeBGColorOptions.length > 1 ? nodeBGColorOptions[1].replace(/\s/g, "") : "";
    let nodeName = DiagramNodeUtils.getNodeFromMenuNodeName(bgNodeData);

    let baseEmphasisClass = this.nodeProps.emphasisClass ? this.nodeProps.emphasisClass : "clsEmphasis";
    let empDisabledClass = hasBG ? baseEmphasisClass + "DisabledBG" : baseEmphasisClass + "Disabled";
    let empEnabledClass = hasBG ? baseEmphasisClass + "EnabledBG" : baseEmphasisClass + "Enabled";
    let allNodes = this.diagramParent.querySelectorAll("[name='nodeMainParent']");
    let iconBGNode = this.diagramParent.querySelector("[name='iconBG']");

    for (let i = 0; i < allNodes.length; i++) {
        allNodes[i].classList.add("mood");
        allNodes[i].classList.add(empDisabledClass);
        let bgNode = allNodes[i].querySelector(`[name='${nodeName}']`);
        if (!hasBorder && hasBG && bgNode) {
            let nodebgColor = nodeBGColorOptions[0];
            if (nodebgColor.includes("accent")) {
                bgNode.classList.add("clsEmpAccentBG");
            } else {
                bgNode.classList.add("clsEmpNormalBG");
            }
        } else if (hasBG && bgNode) {
            let nodebgColor = nodeBGColorOptions[0];
            if (nodebgColor.includes("accent")) {
                bgNode.classList.add("clsEmpAccentBorderBG");
            } else {
                bgNode.classList.add("clsEmpNormalBorderBG");
            }
        } else if (bgNode) {
            bgNode.classList.add("clsEmpEmpty");
        }

        if (hasBorder) {
            for (let j = 0; j < arrNodeData.length; j++) {
                let borderNodeName = DiagramNodeUtils.getNodeFromMenuNodeName(arrNodeData[j]);
                let borderNode = allNodes[i].querySelector(`[name='${borderNodeName}']`);
                if (borderNode) borderNode.classList.add("clsEmpBorder");
            }
        }

        if (bgNode && iconBGNode && iconBGNode.offsetWidth > 0 && iconBGNode.offsetHeight > 0) {
            bgNode.classList.add("clsEmpIconColor");
        }

        let seqNode = allNodes[i].querySelector("[name='seqTitleHolder']");
        if (seqNode) {
            let colorValue = window.getComputedStyle(seqNode).getPropertyValue("background-color");
            let arrRBG = colorValue.replace("rgb", "").replace("rgba", "").replace("(", "").replace(")", "").split(",");
            let alophaZero = arrRBG.length == 4 && arrRBG[3] == 0;
            let hasSEQBG = false;
            if (arrRBG.length > 2 && !alophaZero) {
                for (let j = 0; j < arrRBG.length; j++) {
                    if (arrRBG[j] > 0 && arrRBG[j] < 255) {
                        hasSEQBG = true;
                        break;
                    }
                }
            }
            if (hasSEQBG) seqNode.classList.add("clsEmpSeqUpdate");
            else seqNode.classList.add("clsEmpSeqAccentUpdate");
        }

        if (i == index) {
            allNodes[i].classList.remove(empDisabledClass);
            allNodes[i].classList.remove("mood");
            allNodes[i].classList.add("mood");
            allNodes[i].classList.add(empEnabledClass);
            // allNodes[i].firstElementChild.setAttribute("data-emphasize", "true");
            let nodeGroup = allNodes[i].querySelector("[name='nodeGroup']");
            nodeGroup.setAttribute("data-emphasize", "true");
        }
    }
};

BaseDiagram.prototype.crossout = function (objData) {
    let targetNode = this.diagramParent.querySelector("[id='" + objData.targetid + "']");
    let diagramContentNode = targetNode.id.includes("Holder") ? targetNode.parentElement : targetNode.querySelector("[data-id='diagramContentNode']");
    let isTextNode = false;
    // if (!diagramContentNode || this.diagramData.properties.diagramcontent == false) {
    //     diagramContentNode = targetNode.querySelector("[data-id='primaryTextNode']") || targetNode;
    //     isTextNode = true;
    // }
    if (!diagramContentNode || this.diagramData.properties.diagramcontent == false) return;
    let index = diagramContentNode ? diagramContentNode.dataset.index : 0;
    if (targetNode && targetNode.parentElement) {
        let className = isTextNode ? "clsCrossoutTextStyle" : "clsCrossoutStyle";
        let crossOutParent = targetNode.parentElement.querySelector("[name='crossoutParent']");
        // if (targetNode.parentElement.classList.contains(className)) {
        if (crossOutParent) {
            crossOutParent.parentElement.classList.remove(className);
            crossOutParent.remove();
            // targetNode.parentElement.removeAttribute("data-crossout", "true");
            this.arrDiagramNode[index].nodeGroup.removeAttribute("data-crossout");
        } else {
            targetNode.parentElement.classList.add(className);
            // targetNode.parentElement.setAttribute("data-crossout", "true");
            this.arrDiagramNode[index].nodeGroup.setAttribute("data-crossout", "true");
            this.arrDiagramNode[index].createCrossoutDiv(diagramContentNode);
        }
    }
    // this.updatePropsCallBack(objData.targetid);
};

BaseDiagram.prototype.getJSONData = function (defaultproperties) {
    if (this.arrDiagramNode.length == 0 && this.diagramData) return this.diagramData;
    // if (this.arrDiagramNode.length == 0 && !this.diagramData) this.recreateElementData();
    let arrNodeData = [];
    for (let i = 0; i < this.arrDiagramNode.length; i++) {
        let nodeData = this.arrDiagramNode[i].getJSONData(this.diagramParent);
        arrNodeData.push(nodeData);
        this.arrDiagramNode[i].objData = nodeData; // Added to store data in nodeinstance also
    }
    return { properties: this.getProperties(defaultproperties), nodes: arrNodeData, diagramtitle: DiagramCreateUtil.getDiagramTitleData(this.diagramParent) };
};

BaseDiagram.prototype.onHoverOutNode = function (event) {
    this.diagramParent.setAttribute("moverHovered", false);
};

BaseDiagram.prototype.onHoverNode = function (event) {
    this.diagramParent.setAttribute("moverHovered", true);
};

BaseDiagram.prototype.updateEvents = function () {
    this.eventManagerXY.clear();

    if (this.appmode.toLowerCase() == "present") return;

    let arrEventNodes = [];
    // For Connector Text
    let connectorNodes = Array.from(this.diagramParent.querySelectorAll("[name='connectortext']"));
    arrEventNodes = arrEventNodes.concat(connectorNodes);
    // For Diagram Title
    let diagramTitle = this.diagramParent.querySelector("[name='diagramTitle']");
    if (diagramTitle) arrEventNodes.push(diagramTitle);
    // For Center Holder Text
    let centerHolderParent = this.diagramParent.querySelector("[name='centerHolderParent']");
    if (centerHolderParent) {
        let arrCenterChildNodes = Array.from(centerHolderParent.querySelectorAll("[data-default-event='true']"));
        arrEventNodes = arrEventNodes.concat(arrCenterChildNodes);
    }

    for (let j = 0; j < arrEventNodes.length; j++) {
        this.eventManagerXY.addEvent(arrEventNodes[j], "focusout", this.defaultFoucsOut);
        this.eventManagerXY.addEvent(arrEventNodes[j], "focusin", this.defaultFoucsIn);
        this.eventManagerXY.addEvent(arrEventNodes[j], "paste", this.diagramPasteHandler);
    }

    for (let i = 0; i < this.arrDiagramNode.length; i++) {
        let parentNode = this.arrDiagramNode[i].parentNode;
        let arrChildNodes = Array.from(parentNode.querySelectorAll("[data-default-event='true']"));

        // For Text Highlight
        let arrHighLightNodes = parentNode.querySelectorAll("[data-highlight-event='true']");
        for (let j = 0; j < arrHighLightNodes.length; j++) {
            this.eventManagerXY.addEvent(arrHighLightNodes[j], "mouseup", this.textHighlightMouseUpEvent.bind(this));
        }

        // For Hover Nodes in presentation
        let hoverNode = parentNode.querySelector("[name='nodeGroup']");
        this.eventManagerXY.addEvent(hoverNode, "mouseenter", this.onHoverNode);
        this.eventManagerXY.addEvent(hoverNode, "mouseleave", this.onHoverOutNode);

        // For Check List Node
        let checklistNodes = parentNode.querySelectorAll("[data-checkbox-event='true']");
        for (let j = 0; j < checklistNodes.length; j++) {
            this.eventManagerXY.addEvent(checklistNodes[j], "mousedown", this.defaultCheckBoxEvent);
        }

        // let togglelistNode = parentNode.querySelector("[data-toggle-event='true']");
        // if(togglelistNode && this.arrDiagramNode[i].numberToggleStyle){
        //     this.eventManagerXY.addEvent(togglelistNode, "mousedown", this.arrDiagramNode[i].numberToggleStyle.defaultCheckBoxEvent);
        // }

        // For Microchart Node
        let microchartNode = parentNode.querySelectorAll("[data-id='microchartNode']");
        if (microchartNode && microchartNode.length > 0) {
            microchartNode.forEach((element) => {
                this.eventManagerXY.addEvent(element, "focusout", this.arrDiagramNode[i].microChartFoucsOut);
                this.eventManagerXY.addEvent(element, "focusin", this.arrDiagramNode[i].microChartFoucsIn);
            });
        }

        // For Microchart Node
        let microchartNodeCircle = parentNode.querySelectorAll("[id*='clsCircleBG']");
        if (microchartNodeCircle && microchartNodeCircle.length > 0) {
            microchartNodeCircle.forEach((element) => {
                this.eventManagerXY.addEvent(element, "click", this.arrDiagramNode[i].microChartClickEvent);
            });
        }

        // For all common events
        for (let j = 0; j < arrChildNodes.length; j++) {
            this.eventManagerXY.addEvent(arrChildNodes[j], "focusout", this.defaultFoucsOut);
            this.eventManagerXY.addEvent(arrChildNodes[j], "focusout", this.arrDiagramNode[i].onFocusOut);
            this.eventManagerXY.addEvent(arrChildNodes[j], "focusin", this.defaultFoucsIn);
            this.eventManagerXY.addEvent(arrChildNodes[j], "paste", this.diagramPasteHandler);
        }
    }
    //update callback listeners
    if (this.focusoutTextEvent) {
        this.addListener("focusout", this.focusoutTextEvent);
    }
    if (this.mousedownTextEvent) {
        this.addListener("mousedown", this.mousedownTextEvent);
    }
    if (this.mouseupSelectionEvent) {
        this.addListener("mouseup", this.mouseupSelectionEvent);
    }
    if (this.keyupSelectionEvent) {
        this.addListener("keyup", this.keyupSelectionEvent);
    }
    if (this.keypressEvent) {
        this.addListener("keypress", this.keypressEvent);
    }
};

BaseDiagram.prototype.textResize = function (targetid, size, objDetails) {
    let nodeGroup = this.diagramParent.querySelector("[id='" + targetid + "']");
    if (!nodeGroup) nodeGroup = this.diagramParent;
    let target = nodeGroup.querySelector("[name='" + objDetails.contenttype + "']");
    if (!target) target = nodeGroup.querySelector("[data-type*='" + objDetails.contenttype + "']");
    if (!target) target = nodeGroup.querySelector("[id*='" + objDetails.contenttype + "']");
    if (!target && nodeGroup?.dataset?.type == objDetails?.contenttype) target = nodeGroup;
    if (target && target.dataset.type == "secondaryText") {
        target = target.parentElement;
    }
    // let textNode = target.querySelector("[name='primaryText']") || target.querySelector("[name='authorName']");
    if (target) {
        this.textResizeForTarget(target.getAttribute("name"), size);
    }
};

BaseDiagram.prototype.textResizeForTarget = function (targetId, size) {
    this.arrDiagramNode.forEach((element) => {
        let multiTextParent = element.parentNode.querySelector("[name='" + targetId + "']");
        if (!multiTextParent) return;
        TextHighLightUtils.removeFontClassName(multiTextParent, this.fontClassList);
        if (size.includes("auto")) multiTextParent.classList.add(multiTextParent.getAttribute("original-fontclass"));
        else multiTextParent.classList.add(size);
        multiTextParent.setAttribute("data-fontresize", size);
        this.diagramData.properties.fontresize[targetId] = size;
        if (element?.properties?.fontresize?.[targetId]) element.properties.fontresize[targetId] = size;
        this.updateProperties(this.diagramData.properties);
        this.diagramParent.setAttribute("data-fontresize-" + targetId.toLowerCase(), size);
        // element.updateOnFocusOut(multiTextParent);
    });
    this.updateTextNodes();
    // this.updatePropsCallBack(targetId);
};

BaseDiagram.prototype.recreateElementData = function () {
    this.setMoodClassNames();
    let arrNodesItems = this.diagramParent.querySelectorAll("div[name='nodeparent']");
    this.updateJSONData();
    let properties = this.getProperties();
    let intLength = arrNodesItems.length;
    this.arrDiagramNode = [];
    for (let i = 0; i < intLength; i++) {
        let nodeItem = arrNodesItems[i];
        let diagramNode = new window[this.nodeProps.nodeclassName](nodeItem.parentElement.parentElement, properties, null, this.eventManagerXY, i, nodeItem.getAttribute("data-parent-id"), this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
        diagramNode.parentNode = nodeItem;
        diagramNode.nodeGroup = nodeItem.querySelector("[name='nodeGroup']");
        this.createNodeInstanceProperties(diagramNode);
        diagramNode.objData = diagramNode.getJSONData();
        this.recreateAuthorInstance(nodeItem, diagramNode, i);
        this.recreateNumberToggleInstance(nodeItem, diagramNode, i);
        this.recreateImageGridInstance(nodeItem, diagramNode, i);
        this.arrDiagramNode.push(diagramNode);
    }
    this.updateCssAttributes();
    // if (this.nodeProps.supportedNodes) {
    //     let imageHolderObj = DiagramUtils.getObjectFromName(this.nodeProps.supportedNodes, "imageHolder");
    //     if (imageHolderObj && imageHolderObj.hasOwnProperty("imageoverlayproperties")) this.globalMoodData.imageoverlayproperties = imageHolderObj.imageoverlayproperties;
    // }
};

BaseDiagram.prototype.recreateImageGridInstance = function (nodeItem, diagramNode, i) {
    try {
        let imageGridNode = nodeItem.querySelector("[name='imageGridNode']");
        if (imageGridNode) {
            diagramNode.gridInstance = new window["SimpleImageGrid"](nodeItem, this.nodeProps, this.appStaticURL, DiagramUtils.getDefaultDataForLogoList(this.arrDefaults, this.nodeProps));
            diagramNode.gridInstance.gridimages = diagramNode.gridInstance.getLogoListData(diagramNode.parentNode);
            diagramNode.gridInstance.updateCallBack = diagramNode.updateCallBack;
            diagramNode.gridInstance.completeCallback = diagramNode.updateLogoListLoadCallback.bind(diagramNode);
            diagramNode.gridInstance.focusCallBack = {
                func: diagramNode.updateOnFocusOut.bind(diagramNode),
            };
            let logoListData = DiagramUtils.getObjectFromName(this.nodeProps.supportedNodes, "logoListHolder");
            // if (logoListData) DiagramUtils.addClassNames(logoListData.class, this.diagramParent);
            if (!logoListData.class) {
                let moodAlign = window.getComputedStyle(this.diagramParent).getPropertyValue("--logogridalignment");
                logoListData.class = moodAlign == "left" ? "clsLinearImageGridNode" : "clsLinearImageGridNodecenter";
            }
            if (logoListData) DiagramUtils.addClassNames(logoListData.class, this.diagramParent);
        }
    } catch (error) {
        console.log(error);
    }
};

BaseDiagram.prototype.recreateAuthorInstance = function (nodeItem, diagramNode, i) {
    try {
        let authorStyle = nodeItem.querySelector("[id*='authorStyle']");
        if (authorStyle) {
            diagramNode.authorStyle = new window["AuthorStyleGroup"](this.nodeProps, {}, i, { authorNameFontSize: diagramNode.authorNameFontSize, authorDesFontSize: diagramNode.authorDesFontSize, globalMoodData: this.globalMoodData }, this.diagramParent, this.appStaticURL);
            diagramNode.objData.author = diagramNode.authorStyle.getAuthorData(diagramNode.parentNode);
        }
    } catch (error) {
        console.log(error);
    }
};

BaseDiagram.prototype.recreateNumberToggleInstance = function (nodeItem, diagramNode, i) {
    try {
        let numberToggleStyle = nodeItem.querySelector("[id*='numberToggleStyle']");
        if (numberToggleStyle) {
            diagramNode.numberToggleStyle = new window["NumberToggleStyleGroup"](this.nodeProps, {}, i, DiagramUtils.getObjectFromName(this.nodeProps.supportedNodes, "numberToggleStyleGroup"), this.appStaticURL);
            diagramNode.objData.number = diagramNode.numberToggleStyle.getNumberToggleData(diagramNode.parentNode);
        }
    } catch (error) {
        console.log(error);
    }
};

BaseDiagram.prototype.clear = function () {
    this.eventManagerXY.clear();
    // this.arrDiagramNode = [];
    this.gridInstance = null;
    // console.log("clear", this.arrDiagramNode.length);
};

BaseDiagram.prototype.abort = function () {
    try {
        this.aborted = true;
        this.clear();
        this.completeCallBack = null;
        this.diagramParent.innerHTML = "";
    } catch (error) {
        console.log(error);
    }
};

BaseDiagram.prototype.recalculateheight = function () {};

BaseDiagram.prototype.isChildOfParent = function (child, parent) {
    let isParent = false;
    let childParent = child.parentElement;

    while (childParent != this.diagramParent) {
        if (childParent == parent) {
            isParent = true;
            break;
        }
        childParent = childParent.parentElement;
    }

    return isParent;
};

// Inline floater content Option

BaseDiagram.prototype.getSeletion = function (centernodetype, type) {
    let selection = {};
    let selectedContent = centernodetype ? centernodetype : "icon";

    let arrContent = this.nodeProps.supportedNodes.filter((node) => node.name == "contentNode");
    if (type == "centerNode") {
        arrContent = this.nodeProps.centerNode;
    } else if (arrContent.length > 0) {
        arrContent = arrContent[0].subNodes;
        if (this.diagramParent.dataset.contenttype) selectedContent = this.diagramParent.dataset.contenttype;
    } else if (arrContent.length > 0) {
        return selection;
    }
    // bulletHolder
    if (type != "centerNode") selection["none"] = { floaterproperty: "none", label: "none", value: selectedContent == "none", visible: true };
    arrContent.map(function (contentObj) {
        if (contentObj.name.includes("iconHolder")) {
            selection["icon"] = { floaterproperty: "icon", label: "icon", value: selectedContent == "icon", visible: true };
        } else if (contentObj.name.includes("imageHolder")) {
            selection["image"] = { floaterproperty: "image", label: "image", value: selectedContent == "image", visible: true };
        } else if (contentObj.name.includes("imageSecHolder")) {
            selection["logo"] = { floaterproperty: "logo", label: "logo", value: selectedContent == "logo", visible: true };
        } else if (contentObj.name.includes("valueTitleHolder")) {
            selection["number"] = { floaterproperty: "number", label: "number", value: selectedContent == "number", visible: true };
        } else if (contentObj.name.includes("textTitleHolder")) {
            selection["text"] = { floaterproperty: "text", label: "text", value: selectedContent == "text", visible: true };
        } else if (contentObj.name.includes("seqTitleHolder")) {
            selection["sequence"] = { floaterproperty: "sequence", label: "sequence", value: selectedContent == "sequence", visible: true };
        } else if (contentObj.name.includes("checkListHolder")) {
            selection["checklist"] = { floaterproperty: "checklist", label: "checklist", value: selectedContent == "checklist", visible: true };
        } else if (contentObj.name.includes("bulletHolder")) {
            selection["bulletlist"] = { floaterproperty: "bulletlist", label: "bulletlist", value: selectedContent == "bulletlist", visible: true };
        }
    });

    return selection;
};

BaseDiagram.prototype.setHolderType = function (contenttype, holder) {
    let key = holder == "centerNode" ? "data-centerholdertype" : "data-contentholdertype";
    switch (contenttype) {
        case "none":
            this.diagramParent.setAttribute(key, "noneHolder");
            break;
        case "icon":
            this.diagramParent.setAttribute(key, "iconHolder");
            break;
        case "image":
            this.diagramParent.setAttribute(key, "imageHolder");
            break;
        case "logo":
            this.diagramParent.setAttribute(key, "imageSecHolder");
            break;
        case "number":
            this.diagramParent.setAttribute(key, "valueTitleHolder");
            break;
        case "text":
            this.diagramParent.setAttribute(key, "textTitleHolder");
            break;
        case "sequence":
            this.diagramParent.setAttribute(key, "seqTitleHolder");
            break;
        case "checklist":
            this.diagramParent.setAttribute(key, "checkListHolder");
            break;
        case "bulletlist":
            this.diagramParent.setAttribute(key, "bulletHolder");
            break;
        default:
            break;
    }
};

BaseDiagram.prototype.contentChange = function (operation) {
    if (operation.targetid && operation.targetid.includes("center")) {
        this.diagramParent.setAttribute("data-centernodetype", operation.value.type);
        this.setHolderType(operation.value.type, "centerNode");

        let centerNode = this.diagramParent.querySelector("[data-id='centerNode']");
        if (!centerNode) return;
        centerNode.innerHTML = "";
        let nodeData = DiagramNodeUtils.diagramContentData(operation.value.type, this.appStaticURL, this.arrDefaults, 0);
        this.createCenterElements(centerNode, nodeData);
        this.updateEvents();
    } else {
        this.diagramParent.setAttribute("data-contenttype", operation.value.type);
        this.diagramData.properties.contenttype = operation.value.type;
        this.setHolderType(operation.value.type, "subNode");

        const nodeCount = this.diagramData.nodes.length;
        let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
        this.arrDiagramNode.map(function (node) {
            nodeHolder.removeChild(node.getNodeParent().parentElement);
        });
        this.arrDiagramNode = [];
        this.createNodeInstances(nodeCount, nodeHolder);
        this.diagramData.properties.contenttype = operation.value.type;
        this.diagramData.properties.diagramcontent = operation.value.type == "none" || operation.value.type == "sequence" ? false : true;
        this.diagramData.properties.sequencetext = operation.value.type == "sequence" ? true : false;
        this.diagramParent.setAttribute("data-contenttype", operation.value.type);
        this.diagramParent.setAttribute("data-sequencetext", this.diagramData.properties.sequencetext);
        this.diagramParent.setAttribute("data-diagramcontent", this.diagramData.properties.diagramcontent);
        this.updateJSONData();
        this.updateSpecialOperations();
        this.updateEmphasize();
        this.slideDimensionChange();
        this.resetNodeAttributes();
        this.updateEvents();
    }
};

BaseDiagram.prototype.updateTextSize = function (valueObj, targetNode) {
    if (targetNode) {
        let isReset = valueObj.value == "auto" || valueObj.value == "reset";
        let isQuillAsset = targetNode?.id?.includes("ql-editor");
        if (isQuillAsset) {
            if (isReset) targetNode.style.removeProperty("font-size");
            else targetNode.style.fontSize = valueObj.value;
            Array.from(targetNode?.children)?.forEach((element) => {
                if (element.tagName == "UL" || element.tagName == "OL") {
                    Array.from(element?.children)?.forEach((liElement) => {
                        if (isReset) liElement.style.removeProperty("font-size");
                        else liElement.style.fontSize = "unset";
                    });
                }
                //  else {
                //     if (isReset) element.style.removeProperty("font-size");
                //     else element.style.fontSize = "unset";
                // }
            });
        } else {
            if (isReset) {
                targetNode.style.removeProperty("font-size");
                if (targetNode?.dataset?.id == "numberNode") {
                    targetNode.parentElement.parentElement.style.removeProperty("height");
                    targetNode.parentElement.parentElement.style.removeProperty("max-height");
                    targetNode.parentElement.style.removeProperty("height");
                    targetNode.parentElement.style.removeProperty("max-height");
                } else if (targetNode?.dataset?.id == "microchartNode") {
                    targetNode.style.removeProperty("height");
                }
            } else targetNode.style.fontSize = valueObj.value;
            let maxHeight = getComputedStyle(targetNode.parentElement).maxHeight;
            if (maxHeight && parseFloat(maxHeight) < parseFloat(valueObj.value)) targetNode.parentElement.style.maxHeight = valueObj.value;
            if (targetNode?.dataset?.id == "numberNode") {
                targetNode.parentElement.parentElement.style.setProperty("height", valueObj.value, "important");
                targetNode.parentElement.parentElement.style.setProperty("max-height", valueObj.value, "important");
                targetNode.parentElement.style.maxHeight = valueObj.value;
                targetNode.parentElement.style.height = valueObj.value;
            } else if (targetNode?.dataset?.id == "microchartNode") {
                targetNode.style.height = valueObj.value;
            }
        }
        this.updateTextNodes();
        this.resetLayout();
    }
};

//Highlight related functionality
BaseDiagram.prototype.checkHighlight = function (parent) {
    let diagramNodes = parent.querySelectorAll("[name='nodeparent']");
    for (let n = 0; n < diagramNodes.length; n++) {
        if (diagramNodes[n].dataset.highlight == "true") this.setHighlightTargetPoints(diagramNodes[n], parent);
    }
};

BaseDiagram.prototype.setHighlightTargetPoints = function (node, parent) {
    let alignment;
    let diagramType = parent.dataset.diagramtype;
    alignment = diagramType == "horizontal" ? "vertical" : "horizontal";

    if (this.setHighlightPosition) {
        let nodeInfo = this.setHighlightPosition(node);
        alignment = nodeInfo.alignment;
    }

    let element = node.querySelector("[name='iconHolder'],[name='imageHolder'],[name='imageSecHolder'],[name='valueTitleHolder'],[name='microChartHolder'],[name='textTitleHolder']");
    element = element ? element : node;

    let targetBounds = element.getBoundingClientRect();
    let viewPortBounds = parent.getBoundingClientRect();
    let itemParent = element;
    let item = element;
    item.x = 0;
    item.y = 0;
    let objStyleData = window.getComputedStyle(parent);
    let objStyleElementData = window.getComputedStyle(element);

    viewPortBounds.x = parseFloat(objStyleData["x"].split("px")[0]);
    viewPortBounds.y = parseFloat(objStyleData["y"].split("px")[0]);
    viewPortBounds.width = parseFloat(objStyleData["width"].split("px")[0]);
    viewPortBounds.height = parseFloat(objStyleData["height"].split("px")[0]);
    targetBounds.width = parseFloat(objStyleElementData["width"].split("px")[0]);
    targetBounds.height = parseFloat(objStyleElementData["height"].split("px")[0]);
    while (itemParent && !itemParent.className.includes("GRAPHIC")) {
        item.x = itemParent.offsetLeft + item.x;
        item.y = itemParent.offsetTop + item.y;
        itemParent = itemParent.offsetParent;
    }
    targetBounds.x = item.x;
    targetBounds.y = item.y;
    if (alignment == "lineargrid") {
        targetBounds.x = node.style.gridColumnStart * 4;
        targetBounds.y = node.style.gridRowStart * 4;
        targetBounds.width = node.style.gridColumnEnd * 4 - targetBounds.x;
        targetBounds.height = node.style.gridRowEnd * 4 - targetBounds.y;
        alignment = "horizontal";
    }
    node.setAttribute("data-highlighttargetbounds", JSON.stringify(targetBounds.toJSON()));
    node.setAttribute("data-highlightviewportbounds", JSON.stringify(viewPortBounds.toJSON()));
    node.setAttribute("data-alignment", alignment);
};
// Animation related function

BaseDiagram.prototype.initPresent = function (currentSlide, boolNoAnimation = false) {
    if (boolNoAnimation) return { isTitleAnimation: false, isGraphicAnimation: false };
    this.diagramParent = currentSlide.querySelector("[id='diagramparent']");

    if (this.diagramParent.parentElement.dataset.animationtype && this.diagramParent.parentElement.dataset.animationtype == "none") return { isTitleAnimation: false, isGraphicAnimation: false };

    if (this.diagramParent) this.diagramParent.style.opacity = 0;
    let animationType = this.diagramParent.parentElement.dataset.animationtype;
    this.oneTimeAnimationType = DiagramAnimateUtil.animationName(this);

    if (animationType != "all") this.diagramParent.classList.add("clsNonHover");

    if (this.oneTimeAnimationType == "horizontalscale" && this.oneTimeAnimationType != "fullscreenoaa") {
        this.arrDiagramNode.map((node, i) => {
            if (i > 0) {
                let nodeParent = node.getNodeParent().parentElement;
                nodeParent.removeAttribute("data-animation");
                nodeParent.classList.remove("moodanimation");
                let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
                arrObj.map((item) => {
                    item.removeAttribute("data-animation");
                    item.classList.remove("moodanimation");
                });
            }
        });
    } else if (animationType != "all" && animationType != "none" && this.oneTimeAnimationType != "fullscreenoaa") {
        this.arrDiagramNode.map((node, i) => {
            if (i > 0) {
                let nodeParent = node.getNodeParent().parentElement;
                nodeParent.removeAttribute("data-animation");
                nodeParent.classList.remove("moodanimation");
                let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
                arrObj.map((item) => {
                    item.removeAttribute("data-animation");
                    item.classList.remove("moodanimation");
                });
            }
        });
    }

    let isGraphicAnimation = animationType == "all" ? true : false;
    return { isTitleAnimation: true, isGraphicAnimation: isGraphicAnimation };
};

BaseDiagram.prototype.setupAnimation = function (animationType = "one", callback) {
    this.animationIndex = -1;
    this.highlightIndex = -1;
    this.animationType = animationType;

    this.diagramParent.parentElement.setAttribute("data-animationtype", this.animationType);
    this.oneAtTimeAnimationType = this.diagramParent.parentElement.dataset.oneattimeanimationtype || "";
    this.animationCompleteCallback = callback;

    this.oneTimeAnimationType = DiagramAnimateUtil.animationName(this);
    this.isShowAllNode = this.animationType == "one" && this.oneTimeAnimationType != "fullscreenoaa";
    if (animationType != "all") this.diagramParent.classList.add("clsNonHover");

    if (this.oneTimeAnimationType == "horizontalscale" && this.oneTimeAnimationType != "fullscreenoaa") {
        this.arrDiagramNode.map((node, i) => {
            if (i > 0) {
                let nodeParent = node.getNodeParent().parentElement;
                nodeParent.removeAttribute("data-animation");
                nodeParent.classList.remove("moodanimation");
                let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
                arrObj.map((item) => {
                    item.removeAttribute("data-animation");
                    item.classList.remove("moodanimation");
                });
            }
        });
    } else if (animationType != "all" && this.oneTimeAnimationType != "fullscreenoaa") {
        this.arrDiagramNode.map((node, i) => {
            if (i > 0) {
                let nodeParent = node.getNodeParent().parentElement;
                nodeParent.removeAttribute("data-animation");
                nodeParent.classList.remove("moodanimation");
                let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
                arrObj.map((item) => {
                    item.removeAttribute("data-animation");
                    item.classList.remove("moodanimation");
                });
            }
        });
    }

    DiagramAnimateUtil.setupAnimation(this.arrDiagramNode, this.diagramParent, this);
    let moodAnimationDisable = this.diagramParent.parentElement.dataset.moodanimation;
    this.animationFactor = moodAnimationDisable && moodAnimationDisable == "none" ? 0 : 1;
    this.diagramParent.style.transition = `all ${0.3 * this.animationFactor}s`;
    this.animateAfterMoodDelay();
};

BaseDiagram.prototype.animateAfterMoodDelay = function () {
    this.diagramParent.style.opacity = 1;
    let type = this.diagramParent.parentElement.dataset.oneattimeanimationtype;
    if (type == "" || type == "scale" || type == "fadein" || type == "move" || type == "color") {
        this.animationCompleteCallback?.fn?.(this.animationCompleteCallback.params);
    } else if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
};

BaseDiagram.prototype.playNext = function (index) {
    if (this.gotoNextSlide) return false;
    this.animationIndex += 1;
    this.animationIndex = this.animationIndex < 0 ? 0 : this.animationIndex;
    if (this.animationIndex >= this.diagramData.nodes.length) {
        this.animationIndex = this.diagramData.nodes.length - 1;
        if (this.isShowAllNode) {
            this.animationIndex = this.diagramData.nodes.length;
            this.isShowAllNode = false;
            this.isPreviousFromAllNode = this.animationType == "one" && (this.oneAtTimeAnimationType != "fadein" || this.oneAtTimeAnimationType != "");
            let delay = DiagramAnimateUtil.updateAllNodeAnimation("show", this.arrDiagramNode, this.diagramParent, "next", this);
            setTimeout(() => {
                if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
            }, delay * 1000);
            return true;
        }
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        this.gotoNextSlide = true;
        return false;
    }

    this.gotoPreviousSlide = false;
    this.gotoNextSlide = false;
    let node = this.arrDiagramNode[this.animationIndex];
    let completionDelay = DiagramAnimateUtil.playNext(this.arrDiagramNode, this.animationIndex, this.diagramParent, node, this);
    // this.animateArrowForward(this.animationIndex);
    if (node.getNodeParent().dataset.highlight && node.getNodeParent().dataset.highlight == "true") {
        this.isShowHighlight = true;
        this.highlightIndex = parseInt(node.getNodeParent().dataset.index);
    }

    setTimeout(() => {
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, completionDelay * 1000);
    return true;
};

BaseDiagram.prototype.playPrevious = function (index) {
    if (this.gotoPreviousSlide) return;
    if (this.animationIndex <= 0) {
        this.gotoPreviousSlide = true;
        return false;
    } else if ((this.oneTimeAnimationType == "horizontalscale" || this.oneTimeAnimationType == "fullscreenoaa") && this.animationIndex <= 0) {
        this.gotoPreviousSlide = true;
        return false;
    }

    this.gotoPreviousSlide = false;
    this.gotoNextSlide = false;
    this.animationIndex -= 1;
    this.isShowAllNode = this.animationType == "one" && this.oneTimeAnimationType != "fullscreenoaa";
    let itemindex = this.isShowAllNode ? this.animationIndex : this.animationIndex + 1;

    let node = this.arrDiagramNode[itemindex];
    let completionDelay = DiagramAnimateUtil.playPrevious(this.arrDiagramNode, this.animationIndex, this.diagramParent, node, this.isPreviousFromAllNode, this);
    // this.animateArrowBackward(itemindex);
    this.isPreviousFromAllNode = false;
    let highlightNode = this.isShowAllNode ? node : this.arrDiagramNode[itemindex - 1];
    if (highlightNode && highlightNode.getNodeParent().dataset.highlight && highlightNode.getNodeParent().dataset.highlight == "true") {
        this.isShowHighlight = true;
        this.highlightIndex = parseInt(highlightNode.getNodeParent().dataset.index);
    } else {
        this.isShowHighlight = false;
        this.highlightIndex = -1;
    }
    setTimeout(() => {
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, completionDelay * 1000);

    return true;
};

/**
 * Author:    Saravanan G
 * Created:   3.10.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function SimpleGridDiagram(diagramParent, diagramData, nodeProps, moodData = {}) {
    BaseDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    diagramParent.setAttribute("data-diagramtype", "grid");
    this.simpleGridManager = new window["GridLayoutManager"]();
    this.simpleGridManager.arrNodeFinalData = [];
    diagramParent.className = "clsGridDiagram";
}

SimpleGridDiagram.prototype = Object.create(BaseDiagram.prototype);
SimpleGridDiagram.prototype.constructor = SimpleGridDiagram;

SimpleGridDiagram.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    let centerNodeStyle = this.nodeProps.centerNodeStyle || "";
    pattenDiv.className = "clsNodesHolder clsSimpleGrid " + centerNodeStyle;
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.appendChild(pattenDiv);
    this.updateImageRatio();
    this.createNodeInstances(nodeCount, pattenDiv);
    this.simpleGridManager.arrNodeFinalData = this.arrDiagramNode;
    let gutter = this.nodeProps && this.nodeProps.gap ? this.nodeProps.gap : getComputedStyle(this.diagramParent).getPropertyValue("--image-gutter") || 0;
    if (this.hasSupportedImageFloater()) DiagramUtils.setEnableDisableClassNames(this.diagramParent, "image", this.diagramData.properties.gridimage);
    if (DiagramUtils.checkFloaterOption("border", this.diagramData.properties.floateroptionsdisable)) this.arrDiagramNode.map((node) => node.parentNode.parentElement.setAttribute("data-nodeborder", this.diagramParent.dataset.border));
    this.simpleGridManager.updateLayout(pattenDiv, parseInt(gutter), false, this.diagramData.properties);
    this.createGridOverlay(this.diagramParent);
    this.updateProperties(this.diagramData.properties);
};

SimpleGridDiagram.prototype.createGridOverlay = function (pattenDiv) {
    let supportCommonOverlay = this.menuData?.supportcommonoverlay == true;
    if (supportCommonOverlay) {
        let gridOverlay = document.createElement("div");
        gridOverlay.id = "overlayDiv";
        gridOverlay.style.width = "100%";
        gridOverlay.style.height = "100%";
        gridOverlay.style.top = "0px";
        gridOverlay.style.left = "0px";
        gridOverlay.style.position = "absolute";
        gridOverlay.style.pointerEvents = "none";
        pattenDiv.appendChild(gridOverlay);
        let arrOverlay = pattenDiv.querySelectorAll("[data-nodetype='imageOverlay']");

        let imgHolderNode = pattenDiv.closest("[data-nodetype='imageHolder']");
        // let isSupportOverlay = imgHolderNode?.hasAttribute("data-isoverlaysupport") && imgHolderNode?.getAttribute("data-isoverlaysupport") == "true";
        let isEnabledOverlay = imgHolderNode?.hasAttribute("data-isoverlay") && imgHolderNode?.getAttribute("data-isoverlay") == "true";

        if (pattenDiv.querySelector("[data-nodetype='imageOverlay']")) {
            let innerOverlay = pattenDiv.querySelector("[data-nodetype='imageOverlay']");
            gridOverlay.setAttribute("data-nodetype", "imageOverlay");
            gridOverlay.setAttribute("data-id", "imageOverlay");
            gridOverlay.classList = innerOverlay.classList;
            gridOverlay.style.display = innerOverlay.style.display || !isEnabledOverlay ? "none" : "flex";
            gridOverlay.style.opacity = this.diagramData?.properties?.["overlay-opacity"] || 1;
            if (this.diagramData?.properties?.["overlay-color"]) gridOverlay.style.backgroundColor = this.diagramData?.properties?.["overlay-color"];
            gridOverlay.setAttribute("data-overlay-opacity", gridOverlay.style.opacity);
            gridOverlay.setAttribute("data-overlay-color", gridOverlay.style.backgroundColor);
        }
        // if (!isSupportOverlay) gridOverlay.style.display = "none";
        arrOverlay.forEach((overlay) => {
            overlay.style.display = "none";
        });
    }
};

SimpleGridDiagram.prototype.recreateElementData = function () {
    BaseDiagram.prototype.recreateElementData.call(this);
    this.simpleGridManager.arrNodeFinalData = this.arrDiagramNode;
};

SimpleGridDiagram.prototype.setMoodClassNames = function () {
    BaseDiagram.prototype.setMoodClassNames.call(this);
    if (this.diagramParent?.getAttribute("data-bleed-style-classname") && this.diagramParent?.getAttribute("data-imagebleed") == "true") {
        this.diagramParent?.classList.add(this.diagramParent?.getAttribute("data-bleed-style-classname"));
    }
};

SimpleGridDiagram.prototype.resetImageLogoFrames = function () {
    setTimeout(() => {
        BaseDiagram.prototype.resetImageLogoFrames.call(this);
    }, 300);
};

SimpleGridDiagram.prototype.toggleVisibility = function () {
    BaseDiagram.prototype.toggleVisibility.call(this);
    if (this.hasSupportedImageFloater()) DiagramUtils.setEnableDisableClassNames(this.diagramParent, "image", this.diagramData.properties.gridimage);
};

SimpleGridDiagram.prototype.recalculateWidth = function () {};

SimpleGridDiagram.prototype.resetHolderWidth = function () {
    if (this.arrDiagramNode.length > 0) {
        this.updateImageRatio();
        let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
        nodesHolder.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
        nodesHolder.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
        nodesHolder.style.setProperty("--nodeParentPadding", this.nodeProps.nodeParentPadding);
        this.checkSMLOverflow();
        this.resetNodeAttributes();
    }
};

//Checking content exceeds width means applying node width as content width and height.
SimpleGridDiagram.prototype.checkSMLOverflow = function (oldValue = "auto") {
    let firstNode = this.diagramParent.querySelector("[id='nodeMainParent0']");
    if (!firstNode) return;
    let nodeGroup = firstNode.querySelector("[name='nodeGroup']");
    let content = firstNode.querySelector("[name='contentNode']");
    let computedStyle = window.getComputedStyle(nodeGroup);
    let paddingLeft = parseInt(computedStyle.paddingLeft);
    let paddingRight = parseInt(computedStyle.paddingRight);
    if (paddingLeft == 0 || paddingRight == 0) {
        let computedStyleParent = window.getComputedStyle(nodeGroup.parentElement);
        paddingLeft = parseInt(computedStyleParent.paddingLeft);
        paddingRight = parseInt(computedStyleParent.paddingRight);
    }
    let finalWidth = firstNode.clientWidth - paddingRight - paddingLeft;
    let maxWidth = this.diagramParent.style.getPropertyValue("--originalresizewidth");
    if (this.diagramData.properties.contenttype == "number") {
        this.resizeValueText(oldValue);
    }
    if (firstNode && firstNode.clientWidth > 10 && content && content.clientWidth > parseInt(finalWidth)) {
        this.diagramData.properties[this.diagramData.properties.contenttype + "size"] = oldValue;
        this.updateProperties(this.diagramData.properties);
        this.updatePropsCallBack(content.id);
        let heightValue = finalWidth / parseFloat(maxWidth);
        heightValue = Math.round(heightValue * 100) / 100;
        heightValue = Math.floor(heightValue * 10) / 10;
        let sizevalue = DiagramUtils.getSMLSizeFromValue(heightValue, this.arrSMLSize);
        DiagramUtils.updateResize(this.diagramParent, sizevalue, this.nodeProps, this.diagramData.properties);
        return true;
    }
};

SimpleGridDiagram.prototype.checkConnectorVisible = function () {};

SimpleGridDiagram.prototype.slideDimensionChange = function () {
    this.refreshGridLayout(false);
};

SimpleGridDiagram.prototype.showHideBleed = function (obj) {
    this.diagramData.properties.isbleed = obj.value;
    this.updateProperties(this.diagramData.properties);
    this.refreshGridLayout();
};

SimpleGridDiagram.prototype.showHideGutter = function (obj) {
    this.diagramData.properties.isgutter = obj.value;
    this.updateProperties(this.diagramData.properties);
    this.refreshGridLayout();
};

SimpleGridDiagram.prototype.showHideOverlay = function (obj) {
    this.diagramData.properties.isoverlay = obj.value;
    this.updateProperties(this.diagramData.properties);
};

SimpleGridDiagram.prototype.showHideBorder = function (obj) {
    this.diagramData.properties.border = obj.value;
    this.arrDiagramNode.map((node) => node.parentNode.parentElement.setAttribute("data-nodeborder", obj.value));
    this.updateProperties(this.diagramData.properties);
    this.refreshGridLayout();
};

SimpleGridDiagram.prototype.updateTextPosition = function (obj) {
    this.diagramData.properties.position = obj.value;
    this.updateProperties(this.diagramData.properties);
};

SimpleGridDiagram.prototype.updateLayoutName = function (name) {
    this.diagramData.properties.gridlayoutname = name;
    this.updateProperties(this.diagramData.properties);
    this.updateGridLayout(name);
};

SimpleGridDiagram.prototype.setDiagramSpecficOption = function (obj) {
    this.simpleGridManager.arrNodeFinalData = this.arrDiagramNode;
    let firstNode = this.diagramParent.querySelector("#nodeMainParent0");
    if (!firstNode) return;

    let options = this.diagramData.properties.floateroptionsdisable;
    if (!options) return;

    let gridoption = {};
    let gridListOptions = [
        { data: "none", label: "None" },
        { data: "white", label: "White" },
        { data: "dark", label: "Dark" },
        { data: "theme", label: "Theme" },
    ];
    let selectedIndex = gridListOptions.findIndex((option) => option.data == this.diagramData.properties.border);

    if (!options.includes("bleed")) gridoption.bleed = { isOn: this.diagramData.properties.isbleed, label: "Bleed", property: "bleed" };
    if (!options.includes("gutter")) gridoption.gutter = { isOn: this.diagramData.properties.isgutter, label: "Gutter", property: "gutter" };
    if (!options.includes("overlay")) {
        let hasImageSupport = false;
        let imageHolder = this.diagramParent.querySelector("[data-nodetype='imageHolder']");
        if (imageHolder && imageHolder.clientHeight != 0 && imageHolder.clientWidth != 0) {
            hasImageSupport = true;
        }
        let disableOverlaySupport = !hasImageSupport
            ? true
            : this.diagramData.properties.isoverlaysupport != null && this.diagramData.properties.isoverlaysupport != ""
            ? this.diagramData.properties.isoverlaysupport == "false" || this.diagramData.properties.isoverlaysupport == false
            : this.globalMoodData?.imageoverlayproperties?.hasOwnProperty("support") && this.globalMoodData.imageoverlayproperties.support == false;
        if (!disableOverlaySupport) {
            let opacity = getComputedStyle(this.diagramParent).getPropertyValue("--overlaydiagramopacity") || 0.7;
            gridoption.overlay = { isOn: this.diagramData.properties.isoverlay, label: "Overlay", property: "overlay", opacity: opacity * 100 };
        }
    }
    if (!options.includes("border"))
        gridoption.border = {
            options: gridListOptions,
            label: "Border",
            property: "border",
            selectedindex: selectedIndex >= 0 ? selectedIndex : 0,
        };
    let gridlayout = this.diagramData?.properties?.gridlayout || this.diagramParent.getAttribute("data-gridlayout") || "";

    if (!options.includes("gutter")) {
        let arrlayouts = this.simpleGridManager.getLayouts();
        if (gridlayout != "") {
            let arrKeys = Object.keys(arrlayouts);
            arrKeys = arrKeys.filter((item) => gridlayout.split(",").includes(item));
            gridoption.gridlayout = {};
            arrKeys.forEach((element) => {
                gridoption.gridlayout[element] = arrlayouts[element];
            });
        } else {
            gridoption.gridlayout = arrlayouts;
        }
        // gridoption.gridlayout = Object.assign({}, arrKeys);
    }
    if (Object.keys(gridoption).length > 0) obj.dpcontent.floatdiagramsettings.gridoption = gridoption;
    if (this.hasSupportedImageFloater()) {
        obj.dpcontent.floatdiagramsettings.diagramgridimage = { visible: true, value: this.diagramData.properties.gridimage };
    }
    obj.dpcontent.floatdiagramsettings.linearcontentoptions = null;
    obj.dpcontent.floatdiagramsettings.graphictype = null;
    obj.dpcontent.floatdiagramsettings.diagramplaceholder = null;
};

SimpleGridDiagram.prototype.hasSupportedImageFloater = function () {
    return this.nodeProps && this.nodeProps.name && this.nodeProps.name.includes("-imagegrid") && this.nodeProps.name.includes("-img");
};

SimpleGridDiagram.prototype.showHideGridImage = function (value) {
    this.diagramData.properties.gridimage = value;
    this.updateProperties(this.diagramData.properties);
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "image", value);
    this.resetLayout();
};

SimpleGridDiagram.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    let options = this.diagramData.properties.floateroptionsdisable;
    if (!options) return;

    let layouts = ["TL", "TM", "TR", "ML", "MM", "MR", "BL", "BM", "BR"];
    let selectedIndex = layouts.findIndex((option) => option == this.diagramData.properties.position);
    if (!options.includes("textposition") && elTarget?.dataset?.type != "image") dict.textpositiongrid = { selectedindex: selectedIndex >= 0 ? selectedIndex : 4 };
    //selectedIndex 4 make default position center
    dict.swapnext = null;
    dict.swapprevious = null;
};

SimpleGridDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    let arrFloaterDisable = mainProperties.floateroptionsdisable;
    if (!arrFloaterDisable) return;
    if (!arrFloaterDisable.includes("textposition") && (!mainProperties.position || mainProperties.position == "")) {
        mainProperties.position = "MM";
    }
    BaseDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
};

SimpleGridDiagram.prototype.addNode = function (nodeJSON, index, isFromUndo = false) {
    BaseDiagram.prototype.addNode.call(this, nodeJSON, index, isFromUndo);
    this.arrDiagramNode[index].parentNode.parentElement.setAttribute("data-nodeborder", this.diagramData.properties.border);
    this.clearImageGridOverlay();
    this.refreshGridLayout();
};

// This one not for diagram - Ref - Balakumar
SimpleGridDiagram.prototype.clearImageGridOverlay = function () {
    let supportCommonOverlay = this.menuData?.supportcommonoverlay == true;
    if (supportCommonOverlay) {
        let arrOverlay = this.diagramParent?.querySelectorAll("[data-nodetype='imageOverlay']");
        arrOverlay.forEach((overlay) => {
            if (overlay.id != "overlayDiv") overlay.style.display = "none";
        });
    }
};

SimpleGridDiagram.prototype.deleteNode = function (targetIndex) {
    BaseDiagram.prototype.deleteNode.call(this, targetIndex);
    this.refreshGridLayout();
};

SimpleGridDiagram.prototype.updateGridLayout = function (layoutName) {
    let nodeGap = this.nodeProps && this.nodeProps.gap ? this.nodeProps.gap : getComputedStyle(this.diagramParent).getPropertyValue("--image-gutter") || 0;
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    this.simpleGridManager.updateLayoutByName(layoutName, nodesHolder, parseInt(nodeGap));
    this.resetImageLogoFrames();
};

SimpleGridDiagram.prototype.hideEmpahsis = function () {
    let baseEmphasisClass = this.nodeProps.emphasisClass ? this.nodeProps.emphasisClass : "clsEmphasis";
    this.diagramParent.removeAttribute("data-emphasis");
    let allNodes = this.diagramParent.querySelectorAll("[name='nodeMainParent']");
    for (let i = 0; i < allNodes.length; i++) {
        allNodes[i].classList.remove("mood");
        allNodes[i].classList.remove(baseEmphasisClass + "DisabledBG");
        allNodes[i].classList.remove(baseEmphasisClass + "Disabled");
        allNodes[i].classList.remove(baseEmphasisClass + "EnabledBG");
        allNodes[i].classList.remove(baseEmphasisClass + "Enabled");
        // allNodes[i].firstElementChild.setAttribute("data-emphasize", "false");
        this.arrDiagramNode[i].nodeGroup.setAttribute("data-emphasize", "false");
    }
};

SimpleGridDiagram.prototype.updateEmphasize = function () {
    let index = this.diagramParent.getAttribute("data-emphasis");
    if (index) {
        this.hideEmpahsis();
        this.showEmpahsis(index);
    }
};

SimpleGridDiagram.prototype.showEmpahsis = function (index) {
    this.diagramParent.setAttribute("data-emphasis", index);
    this.diagramParent.style.setProperty("--emphasis-color", "var(--item" + (parseInt(index) + 1) + "-color)");
    this.diagramParent.style.setProperty("--gradient-emphasis-color", "linear-gradient(-45deg, rgba(var(--item" + (parseInt(index) + 1) + "-color-rgb), 1) 12%, rgba(var(--item" + (parseInt(index) + 2) + "-color-rgb), 1) 83%)");

    let nodeBorder = this.nodeProps.nodeBorder ? this.nodeProps.nodeBorder.split(",") : [];
    let arrNodeData = [];
    if (nodeBorder.length == 4) {
        const nodeData = nodeBorder[3].replace(/\s/g, "");
        arrNodeData = [nodeData];
        const hasMulti = nodeData.includes("[") && nodeData.includes("]");
        if (hasMulti) {
            arrNodeData = nodeData.replace("[", "").replace("]", "").split(":");
        }
    }

    let hasBorder = arrNodeData.length > 0;

    let nodeBGColorOptions = this.nodeProps.bgColor ? this.nodeProps.bgColor.split(",") : [];
    let strColorOptions = nodeBGColorOptions.length > 0 ? nodeBGColorOptions[0] : "";
    const hasOpacity = nodeBGColorOptions.length > 0 && strColorOptions.includes(":") && strColorOptions.includes("[") && strColorOptions.includes("]");
    if (hasOpacity && nodeBGColorOptions.length > 1) {
        let opacity = isNaN(nodeBGColorOptions[1]) ? "1" : nodeBGColorOptions[1];
        nodeBGColorOptions = strColorOptions.replace("[", "").replace("]", "").split(":");
        nodeBGColorOptions.push(opacity);
    }

    let hasBG = nodeBGColorOptions.length > 1;
    let bgNodeData = nodeBGColorOptions.length > 1 ? nodeBGColorOptions[1].replace(/\s/g, "") : "";
    let nodeName = DiagramNodeUtils.getNodeFromMenuNodeName(bgNodeData);

    let baseEmphasisClass = this.nodeProps.emphasisClass ? this.nodeProps.emphasisClass : "clsEmphasis";
    let empDisabledClass = hasBG ? baseEmphasisClass + "DisabledBG" : baseEmphasisClass + "Disabled";
    let empEnabledClass = hasBG ? baseEmphasisClass + "EnabledBG" : baseEmphasisClass + "Enabled";
    let allNodes = this.diagramParent.querySelectorAll("[name='nodeMainParent']");
    let iconBGNode = this.diagramParent.querySelector("[name='iconBG']");

    for (let i = 0; i < allNodes.length; i++) {
        allNodes[i].classList.add("mood");
        allNodes[i].classList.add(empDisabledClass);
        let bgNode = allNodes[i].querySelector(`[name='${nodeName}']`);
        if (!hasBorder && hasBG && bgNode) {
            let nodebgColor = nodeBGColorOptions[0];
            if (nodebgColor.includes("accent")) {
                bgNode.classList.add("clsEmpAccentBG");
            } else {
                bgNode.classList.add("clsEmpNormalBG");
            }
        } else if (hasBG && bgNode) {
            let nodebgColor = nodeBGColorOptions[0];
            if (nodebgColor.includes("accent")) {
                bgNode.classList.add("clsEmpAccentBorderBG");
            } else {
                bgNode.classList.add("clsEmpNormalBorderBG");
            }
        } else if (bgNode) {
            bgNode.classList.add("clsEmpEmpty");
        }

        if (hasBorder) {
            for (let j = 0; j < arrNodeData.length; j++) {
                let borderNodeName = DiagramNodeUtils.getNodeFromMenuNodeName(arrNodeData[j]);
                let borderNode = allNodes[i].querySelector(`[name='${borderNodeName}']`);
                if (borderNode) borderNode.classList.add("clsEmpBorder");
            }
        }

        if (bgNode && iconBGNode && iconBGNode.offsetWidth > 0 && iconBGNode.offsetHeight > 0) {
            bgNode.classList.add("clsEmpIconColor");
        }

        let seqNode = allNodes[i].querySelector("[name='seqTitleHolder']");
        if (seqNode) {
            let colorValue = window.getComputedStyle(seqNode).getPropertyValue("background-color");
            let arrRBG = colorValue.replace("rgb", "").replace("rgba", "").replace("(", "").replace(")", "").split(",");
            let alophaZero = arrRBG.length == 4 && arrRBG[3] == 0;
            let hasSEQBG = false;
            if (arrRBG.length > 2 && !alophaZero) {
                for (let j = 0; j < arrRBG.length; j++) {
                    if (arrRBG[j] > 0 && arrRBG[j] < 255) {
                        hasSEQBG = true;
                        break;
                    }
                }
            }
            if (hasSEQBG) seqNode.classList.add("clsEmpSeqUpdate");
            else seqNode.classList.add("clsEmpSeqAccentUpdate");
        }

        if (i == index) {
            allNodes[i].classList.remove(empDisabledClass);
            allNodes[i].classList.remove("mood");
            allNodes[i].classList.add("mood");
            allNodes[i].classList.add(empEnabledClass);
            let nodeGroup = allNodes[i].querySelector("[name='nodeGroup']");
            nodeGroup.setAttribute("data-emphasize", "true");
        }
    }
};

SimpleGridDiagram.prototype.setHighlightPosition = function (node, parent) {
    return { element: node, alignment: "auto" };
};

SimpleGridDiagram.prototype.refreshGridLayout = function (isAnimate = true) {
    if (this.arrDiagramNode.length > 0) {
        this.updateGutter(isAnimate);
        setTimeout(() => {
            this.updateTextNodes();
        }, 500);
    }
};

SimpleGridDiagram.prototype.updateGutter = function (isAnimate = true) {
    let nodeGap = this.nodeProps && this.nodeProps.gap ? this.nodeProps.gap : getComputedStyle(this.diagramParent).getPropertyValue("--image-gutter") || 0;
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    this.simpleGridManager.updateLayout(nodesHolder, parseInt(nodeGap), isAnimate, this.diagramData.properties);
};

/**
 * Author:    Saravanan G
 * Created:   3.10.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function SimpleLinearDiagram(diagramParent, diagramData, nodeProps, moodData = {}) {
    LinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    diagramParent.setAttribute("data-diagramtype", "horizontal");
    this.adjustValue = [0, 40, 40, 40, 90, 130, 150];
}

SimpleLinearDiagram.prototype = Object.create(LinearDiagram.prototype);
SimpleLinearDiagram.prototype.constructor = SimpleLinearDiagram;

SimpleLinearDiagram.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    let centerNodeStyle = this.nodeProps.centerNodeStyle || "";
    pattenDiv.className = "clsNodesHolder " + centerNodeStyle;
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.appendChild(pattenDiv);
    let nodealignment = this.nodeProps.nodealignment;
    this.diagramParent.setAttribute("data-node-alignment", nodealignment);

    let gap = DiagramNodeUtils.getGapForConnectors(this.nodeProps, nodeCount, this.diagramParent, this.diagramData.properties);

    pattenDiv.style.setProperty("--awardContentHeight", 200 - nodeCount > this.adjustValue.length ? this.adjustValue[6] + "px" : this.adjustValue[nodeCount] + "px");
    pattenDiv.style.setProperty("--nodeWidth", "calc(1/" + nodeCount + "*100% - (1 - 1/" + nodeCount + ")*" + gap + "px)");
    pattenDiv.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    pattenDiv.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    pattenDiv.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    pattenDiv.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    pattenDiv.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");

    this.updateImageRatio();

    this.createNodeInstances(nodeCount, pattenDiv);
};

SimpleLinearDiagram.prototype.recalculateWidth = function () {
    this.updateImageRatio();
    // if (this.nodeProps && this.nodeProps.nodealignment && this.nodeProps.nodealignment.includes("auto") && !this.nodeProps.name.includes("clientele")) {
    if (this.nodeProps && this.nodeProps.nodealignment && this.nodeProps.nodealignment.includes("auto")) {
        let maxWidth = 0;
        this.diagramParent.style.setProperty("--nodeParentWidth", "auto");
        let length = this.arrDiagramNode.length;
        let gap = DiagramNodeUtils.getGapForConnectors(this.nodeProps, length, this.diagramParent, this.diagramData.properties);
        this.diagramParent.style.setProperty("--nodeGapConnector", gap + "px");
        this.diagramParent.style.setProperty("--nodeGapAuto", gap + "px");

        this.arrDiagramNode.forEach((element, index) => {
            // if (this.isTakeAway) gap = this.nodeGap ? this.nodeGap + "px" : "0px";
            // let padding = length == index + 1 ? "0px" : gap + "px";
            // element.parentNode.parentElement.style.setProperty("margin-right", padding, "important");
            maxWidth = Math.max(element.parentNode.parentElement.clientWidth, maxWidth);
        });

        this.diagramParent.style.setProperty("--nodeParentWidth", maxWidth + "px");
    } else if (this.nodeProps && this.nodeProps.nodealignment && this.nodeProps.nodealignment.includes("contentstep")) {
        let length = this.arrDiagramNode.length;
        let maxHeightPercent = this.nodeProps.nodealignment.split(",")[1];
        let contentNode = this.diagramParent.querySelector("[name='contentNode']");
        let remainingHeight = contentNode.clientHeight - contentNode.clientHeight * (maxHeightPercent / 100);
        let portionHeight = remainingHeight / (length - 1);
        this.arrDiagramNode.forEach((element, index) => {
            let content = element.parentNode.querySelector("[name='contentNode']");
            // content.style.setProperty("overflow", "hidden", "important");
            // let imageHolder = content.querySelector("[name='imageHolder']");
            if (content) {
                let calcIndex = this.nodeProps.nodealignment.includes("contentstepright") ? index : length - 1 - index;
                element.parentNode.parentElement.style.setProperty("--marginTopContentStep", portionHeight * calcIndex + "px");
                // imageHolder.style.setProperty("margin-top", portionHeight * calcIndex + "px", "important");
                // imageHolder.style.setProperty("max-height", contentNode.clientHeight - portionHeight * calcIndex + "px", "important");
                // content.style.setProperty("min-height",(contentNode.clientHeight - (portionHeight * calcIndex)) + "px", "important");
                // imageHolder.style.setProperty("height", contentNode.clientHeight - portionHeight * calcIndex + "px", "important");
            }
        });
    }
    this.resetNodeAttributes();
};

SimpleLinearDiagram.prototype.updateImageRatio = function () {
    if (this.nodeProps.imageRatio && this.nodeProps.imageRatio.type) {
        let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
        const nodeCount = this.diagramData.nodes.length;
        let gap = DiagramNodeUtils.getGapForConnectors(this.nodeProps, nodeCount, this.diagramParent, this.diagramData.properties);
        const widthPercent = this.nodeProps.imageRatio.value ? this.nodeProps.imageRatio.value : 100;
        const holderWidth = (nodesHolder.offsetWidth - (nodeCount - 1) * gap) / nodeCount;
        const imageHolderWidth = (holderWidth / 100) * widthPercent;
        let percentImageHolderWidth = imageHolderWidth;
        let percentImageHolderHeight = (imageHolderWidth / 16) * 9;
        if (this.nodeProps.imageRatio.type == "sqr") {
            percentImageHolderWidth = imageHolderWidth;
            percentImageHolderHeight = imageHolderWidth;
        } else if (this.nodeProps.imageRatio.type == "pot") {
            percentImageHolderWidth = imageHolderWidth;
            percentImageHolderHeight = (imageHolderWidth / 3) * 4;
        }

        nodesHolder.style.setProperty("--percentWidth", percentImageHolderWidth + "px");
        nodesHolder.style.setProperty("--percentHeight", percentImageHolderHeight + "px");
    }
};

SimpleLinearDiagram.prototype.resetHolderWidth = function () {
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    let nodeCount = this.diagramData.nodes.length;
    let gap = DiagramNodeUtils.getGapForConnectors(this.nodeProps, nodeCount, this.diagramParent, this.diagramData.properties);

    nodesHolder.style.setProperty("--nodeWidth", "calc(1/" + nodeCount + "*100% - (1 - 1/" + nodeCount + ")*" + gap + "px)");
    nodesHolder.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    nodesHolder.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    nodesHolder.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    nodesHolder.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    nodesHolder.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");
    if (this.nodeProps && this.nodeProps.nodealignment && this.nodeProps.nodealignment == "auto") {
        nodesHolder.style.justifyContent = "center";
    }
    this.recalculateWidth();
    this.checkSMLOverflow();
    this.redrawPositionConnectors(0);
};

//Checking content exceeds width means applying node width as content width and height.
SimpleLinearDiagram.prototype.checkSMLOverflow = function (oldValue = "auto") {
    let firstNode = this.diagramParent.querySelector("[id='nodeMainParent0']");
    if (!firstNode) return;
    let nodeGroup = firstNode.querySelector("[name='nodeGroup']");
    let content = firstNode.querySelector("[name='contentNode']");
    let computedStyle = window.getComputedStyle(nodeGroup);
    let paddingLeft = parseInt(computedStyle.paddingLeft);
    let paddingRight = parseInt(computedStyle.paddingRight);
    let finalWidth = firstNode.clientWidth - paddingRight - paddingLeft;
    let maxWidth = this.diagramParent.style.getPropertyValue("--originalresizewidth");
    if (this.diagramData?.properties?.contenttype == "number") {
        this.resizeValueText(oldValue);
    }
    if (firstNode && firstNode.clientWidth > 10 && content && content.clientWidth > parseInt(finalWidth)) {
        this.diagramData.properties[this.diagramData.properties.contenttype + "size"] = oldValue;
        this.updateProperties(this.diagramData.properties);
        this.updatePropsCallBack(content.id);
        let heightValue = finalWidth / parseFloat(maxWidth);
        heightValue = Math.round(heightValue * 100) / 100;
        heightValue = Math.floor(heightValue * 10) / 10;
        let sizevalue = DiagramUtils.getSMLSizeFromValue(heightValue, this.arrSMLSize);
        DiagramUtils.updateResize(this.diagramParent, sizevalue, this.nodeProps, this.diagramData.properties);
        return true;
    }
};

SimpleLinearDiagram.prototype.diagramSpecificCalculation = function () {
    let nodeCount = this.arrDiagramNode.length;
    let pattenDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    pattenDiv.style.setProperty("--awardContentHeight", 200 - (nodeCount > this.adjustValue.length ? this.adjustValue[6] + "px" : this.adjustValue[nodeCount] + "px"));
};

SimpleLinearDiagram.prototype.diagramPasteHandler = function (event) {
    this.recalculateWidth();
    LinearDiagram.prototype.diagramPasteHandler.call(this, event);
    this.alignArrowOnFocus(event.target.dataset.index);
};

SimpleLinearDiagram.prototype.defaultFoucsOut = function (event) {
    let canPerformFocusOut = this.isDifferentText(event.target);
    if (canPerformFocusOut) {
        this.recalculateWidth();
        LinearDiagram.prototype.defaultFoucsOut.call(this, event);
        this.alignArrowOnFocus(event.target.dataset.index);
    }
};

SimpleLinearDiagram.prototype.changeSize = function (value, type, updateCallBack = true, contenttype) {
    LinearDiagram.prototype.changeSize.call(this, value, type, updateCallBack, contenttype);
    // this.alignArrowOnFocus(this.diagramData.nodes.length - 1);
};

SimpleLinearDiagram.prototype.setHighlightPosition = function (node, parent) {
    let nodeParent = node.parentElement;
    let element = nodeParent.querySelector("[data-id='diagramContentNode']");
    if (!element) element = node.querySelector("[data-id='textNode']");

    if (!element || element.clientWidth == 0) element = node;
    return { element: element, alignment: "horizontal" };
};

/**
 * Author:    Saravanan G
 * Created:   3.10.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function SimpleLinearVerticalDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    diagramParent.setAttribute("data-diagramtype", "vertical");
}

SimpleLinearVerticalDiagram.prototype = Object.create(SimpleLinearDiagram.prototype);
SimpleLinearVerticalDiagram.prototype.constructor = SimpleLinearVerticalDiagram;

SimpleLinearVerticalDiagram.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    // pattenDiv.className = "clsNodesHolderVertical";
    let centerNodeStyle = this.nodeProps.centerNodeStyle || "";
    pattenDiv.className = "clsNodesHolderVertical " + centerNodeStyle;
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.appendChild(pattenDiv);
    let nodealignment = this.nodeProps.nodealignment;
    this.diagramParent.setAttribute("data-node-alignment", nodealignment);
    let contentSize = (pattenDiv.offsetHeight - (nodeCount - 1) * this.nodeGap) / nodeCount;

    pattenDiv.style.setProperty("--nodeWidth", "auto");
    pattenDiv.style.setProperty("--nodeHeight", contentSize + "px");
    if (this.nodeProps && this.nodeProps.name && (this.nodeProps.name.startsWith("ver-bul") || this.nodeProps.name.startsWith("ver-num") || this.nodeProps.name.startsWith("ver-ckd"))) {
        pattenDiv.style.setProperty("--contentNodeWidth", "48px");
        pattenDiv.style.setProperty("--contentNodeHeight", "48px");
        this.diagramParent.setAttribute("data-togglelists", "true");
    } else {
        pattenDiv.style.setProperty("--contentNodeWidth", contentSize + "px");
        pattenDiv.style.setProperty("--contentNodeHeight", contentSize + "px");
    }

    pattenDiv.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    pattenDiv.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    pattenDiv.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    pattenDiv.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    pattenDiv.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");

    let circleWidth = (contentSize / 100) * 50;
    pattenDiv.style.setProperty("--circleSize", circleWidth + "px");

    this.createNodeInstances(nodeCount, pattenDiv);
};

SimpleLinearVerticalDiagram.prototype.addNode = function (nodeData, index) {
    let lastNode = this.arrDiagramNode[this.arrDiagramNode.length - 1];
    if (lastNode && lastNode.seperator) lastNode.connectorNode = lastNode.createConnectorParent(lastNode.parentNode.parentElement, lastNode.objData.content);

    if (this.diagramData.nodes.length > index) {
        this.diagramData.nodes.splice(index, 0, nodeData);
    } else {
        this.diagramData.nodes.push(nodeData);
    }
    this.initDiagramCreation();
    this.updateEvents();
    this.recalculateheight();
};

SimpleLinearVerticalDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    let graphicName = this.nodeProps.name || "";
    if (graphicName.includes("ver-num-tx") || graphicName.includes("ver-ckd-tx") || graphicName.includes("ver-bul-tx")) {
        if (mainProperties.floateroptionsdisable) {
            mainProperties.floateroptionsdisable.push("graphiciconlist");
            mainProperties.floateroptionsdisable.push("graphictextlist");
            mainProperties.floateroptionsdisable.push("sequencetext");
        } else mainProperties.floateroptionsdisable = ["graphiciconlist", "graphictextlist", "sequencetext"];
        this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
    }
};

SimpleLinearVerticalDiagram.prototype.deleteNode = function (targetIndex) {
    if (this.arrDiagramNode.length > targetIndex) {
        this.arrDiagramNode.splice(targetIndex, 1);
        let nodeDelete = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + targetIndex + "']");
        if (nodeDelete && nodeDelete.parentElement) {
            nodeDelete.parentElement.remove();
        }
    }
    if (this.diagramData.nodes.length > targetIndex) {
        this.diagramData.nodes.splice(targetIndex, 1);
    }
    if (this.isFingerCountingAsset()) {
        for (let i = 0; i < this.arrDiagramNode.length; i++) {
            let nodeObj = this.arrDiagramNode[i];
            nodeObj.objData.content.id = nodeObj.quoteShape.id + (i + 1);
            nodeObj.objData.content.value = nodeObj.quoteShape.path + nodeObj.objData.content.id + ".svg";
            this.diagramData.nodes[i] = nodeObj.objData;
        }
    }
    this.initDiagramCreation();
    this.updateEvents();
    this.recalculateheight();
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (targetIndex - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
};

SimpleLinearVerticalDiagram.prototype.resetHolderWidth = function () {
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    let nodeCount = this.diagramData.nodes.length;
    let gap = DiagramNodeUtils.getGapForConnectors(this.nodeProps, nodeCount, this.diagramParent, this.diagramData.properties);
    let contentSize = (nodesHolder.offsetHeight - (nodeCount - 1) * gap) / nodeCount;
    nodesHolder.style.setProperty("--nodeHeight", contentSize + "px");
    let nodealignment = this.nodeProps.nodealignment;
    if (nodealignment && nodealignment.includes("split")) {
        nodesHolder.style.setProperty("--contentNodeWidth", "48px");
        nodesHolder.style.setProperty("--contentNodeHeight", "48px");
    } else {
        nodesHolder.style.setProperty("--contentNodeWidth", contentSize + "px");
        nodesHolder.style.setProperty("--contentNodeHeight", contentSize + "px");
    }
    nodesHolder.style.gap = gap + "px";
    nodesHolder.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    nodesHolder.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    nodesHolder.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    nodesHolder.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    nodesHolder.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");
    this.recalculateheight(false);
    this.checkSMLOverflow();
    this.redrawPositionConnectors(0);
    this.resetNodeAttributes();
};

//Checking content exceeds width means applying node width as content width and height.
SimpleLinearVerticalDiagram.prototype.checkSMLOverflow = function (oldValue = "auto") {
    let firstNode = this.diagramParent.querySelector("[id='nodeMainParent0']");
    if (!firstNode) return;
    let nodeGroup = firstNode.querySelector("[name='nodeGroup']");
    let content = firstNode.querySelector("[name='contentNode']");
    let computedStyle = window.getComputedStyle(nodeGroup);
    let paddingTop = parseInt(computedStyle.paddingTop);
    let paddingBottom = parseInt(computedStyle.paddingBottom);
    let finalHeight = firstNode.clientHeight - paddingTop - paddingBottom;
    let maxHeight = this.diagramParent.style.getPropertyValue("--originalresizeheight");
    if (this.diagramData?.properties?.contenttype == "number") {
        this.resizeValueText(oldValue);
    }
    if (firstNode && content && content.clientHeight > parseInt(finalHeight) && this.diagramData.properties[this.diagramData.properties.contenttype + "size"] != "tiny") {
        this.diagramData.properties[this.diagramData.properties.contenttype + "size"] = oldValue;
        this.updateProperties(this.diagramData.properties);
        this.updatePropsCallBack(content.id);
        let heightValue = finalHeight / parseFloat(maxHeight);
        heightValue = Math.floor(heightValue * 10) / 10;
        let sizevalue = DiagramUtils.getSMLSizeFromValue(heightValue, this.arrSMLSize);
        DiagramUtils.updateResize(this.diagramParent, sizevalue, this.nodeProps, this.diagramData.properties);
        return true;
    }
};

SimpleLinearVerticalDiagram.prototype.changeAsset = function (valueObj) {
    if (this.arrDiagramNode[0]?.multiTextBox) {
        let nodeData = {
            type: "icon",
            value: valueObj.value + valueObj.id + ".svg",
            id: valueObj.id,
            contenttype: "icon",
        };
        this.updateNodeData(nodeData, "icon", 0, valueObj.targetid);
        this.updateJSONData(this.diagramData.properties);
        DiagramAssetLoader.oneTimeDownload(nodeData, true, document.body);
        DiagramCreateUtil.updateManifest(nodeData, this.manifestUpdater, this.appStaticURL);
    }
};

SimpleLinearVerticalDiagram.prototype.diagramPasteHandler = function (event) {
    LinearDiagram.prototype.diagramPasteHandler.call(this, event);
    this.recalculateheight();
};

SimpleLinearVerticalDiagram.prototype.defaultFoucsOut = function (event) {
    LinearDiagram.prototype.defaultFoucsOut.call(this, event);
    this.recalculateheight();
};

SimpleLinearVerticalDiagram.prototype.clear = function (event) {
    LinearDiagram.prototype.clear.call(this, event);
};

SimpleLinearVerticalDiagram.prototype.setHighlightPosition = function (node, parent) {
    let nodeParent = node.parentElement;
    let element = nodeParent.querySelector("[data-id='diagramContentNode']");
    if (!element || element.clientWidth == 0) element = node;
    return { element: element, alignment: "vertical" };
};

/**
 * Author:    Saravanan G
 * Created:   3.10.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function SimpleLinearGridDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
}

SimpleLinearGridDiagram.prototype = Object.create(SimpleLinearDiagram.prototype);
SimpleLinearGridDiagram.prototype.constructor = SimpleLinearGridDiagram;

SimpleLinearGridDiagram.prototype.createPatternBackGround = function (isDirectInsert = false) {
    SimpleLinearDiagram.prototype.createPatternBackGround.call(this, isDirectInsert);
    setTimeout(() => {
        window.noderow = [];
        window.nodecolumn = [];
        if (this.diagramData?.properties?.seperatorline) {
            DiagramResizeUtils.calcArrRowColumnBounds(this.arrDiagramNode);
            DiagramResizeUtils.setArrRowColumnBounds(this.arrDiagramNode);
        }
    }, 0);
};

SimpleLinearGridDiagram.prototype.createElements = function () {
    let hasDummyNode = this.diagramData.properties.layoutmeta && this.diagramData.properties.layoutmeta.dummynode;
    const nodeCount = this.diagramData.nodes.length;
    const totalNodeCount = Math.ceil((nodeCount + (hasDummyNode ? 1 : 0)) / 2);

    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsNodesHolderGrid";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.appendChild(pattenDiv);

    this.createNodeInstances(nodeCount, pattenDiv);
    if (hasDummyNode) this.addDummyNode(pattenDiv);

    this.setCalcToNode(pattenDiv, totalNodeCount, nodeCount);
};

SimpleLinearGridDiagram.prototype.resetHolderWidth = function () {
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    const nodeCount = this.diagramData.nodes.length;
    const totalNodeCount = Math.ceil(nodeCount / 2);
    DiagramNodeUtils.updateNodeSizeForClient(this.diagramData, this.diagramParent, this.nodeGap);
    this.setCalcToNode(nodesHolder, totalNodeCount, nodeCount);
    this.checkSMLOverflow();
    this.resetNodeAttributes();
    this.redrawPositionConnectors(0);
};

//Checking content exceeds width means applying node width as content width and height.
SimpleLinearGridDiagram.prototype.checkSMLOverflow = function (oldValue = "auto") {
    // setTimeout(() => {
    let firstNode = this.diagramParent.querySelector("[id='nodeMainParent0']");
    if (!firstNode) return;
    let nodeGroup = firstNode.querySelector("[name='nodeGroup']");
    let content = firstNode.querySelector("[name='contentNode']");
    let computedStyle = window.getComputedStyle(nodeGroup);
    let paddingTop = parseInt(computedStyle.paddingTop);
    let paddingBottom = parseInt(computedStyle.paddingBottom);
    let finalHeight = firstNode.clientHeight - paddingTop - paddingBottom;
    let paddingLeft = parseInt(computedStyle.paddingLeft);
    let paddingRight = parseInt(computedStyle.paddingRight);
    let finalWidth = firstNode.clientWidth - paddingRight - paddingLeft;
    let maxHeight = this.diagramParent.style.getPropertyValue("--originalresizeheight");
    let maxWidth = this.diagramParent.style.getPropertyValue("--originalresizewidth");
    if (this.diagramData?.properties?.contenttype == "number") {
        this.resizeValueText(oldValue);
    }
    if (firstNode && content && content.clientHeight > parseInt(finalHeight) && this.diagramData.properties[this.diagramData.properties.contenttype + "size"] != "tiny") {
        this.diagramData.properties[this.diagramData.properties.contenttype + "size"] = oldValue;
        this.updateProperties(this.diagramData.properties);
        this.updatePropsCallBack(content.id);
        let heightValue = finalHeight / parseFloat(maxHeight);
        heightValue = Math.floor(heightValue * 10) / 10;
        let sizevalue = DiagramUtils.getSMLSizeFromValue(heightValue, this.arrSMLSize);
        DiagramUtils.updateResize(this.diagramParent, sizevalue, this.nodeProps, this.diagramData.properties);
        return true;
    }
    // if (firstNode && nodeGroup && nodeGroup.clientHeight > parseInt(finalHeight) && this.diagramData.properties[this.diagramData.properties.contenttype + "size"] != "tiny") {
    //     this.diagramData.properties[this.diagramData.properties.contenttype + "size"] = oldValue;
    //     this.updateProperties(this.diagramData.properties);
    //     this.updatePropsCallBack(nodeGroup.id);
    //     let heightValue = finalHeight / parseFloat(nodeGroup.clientHeight);
    //     heightValue = Math.floor(heightValue * 10) / 10;
    //     let sizevalue = DiagramUtils.getSMLSizeFromValue(heightValue, this.arrSMLSize);
    //     DiagramUtils.updateResize(this.diagramParent, sizevalue, this.nodeProps, this.diagramData.properties);
    //     return true;
    // }
    if (firstNode && firstNode.clientWidth > 10 && content && content.clientWidth > parseInt(finalWidth) && this.diagramData.properties[this.diagramData.properties.contenttype + "size"] != "tiny") {
        this.diagramData.properties[this.diagramData.properties.contenttype + "size"] = oldValue;
        this.updateProperties(this.diagramData.properties);
        this.updatePropsCallBack(content.id);
        let heightValue = finalWidth / parseFloat(maxWidth);
        heightValue = Math.floor(heightValue * 10) / 10;
        let sizevalue = DiagramUtils.getSMLSizeFromValue(heightValue, this.arrSMLSize);
        DiagramUtils.updateResize(this.diagramParent, sizevalue, this.nodeProps, this.diagramData.properties);
        return true;
    }
    // }, 0);
};

SimpleLinearGridDiagram.prototype.setCalcToNode = function (nodesHolder, totalNodeCount, nodeCount) {
    let gap = DiagramNodeUtils.getGapForConnectors(this.nodeProps, nodeCount, this.diagramParent, this.diagramData.properties);

    nodesHolder.style.setProperty("column-gap", gap + "px");
    nodesHolder.style.setProperty("row-gap", gap + "px");
    nodesHolder.style.setProperty("--nodeWidth", "calc(1/" + totalNodeCount + "*100% - (1 - 1/" + totalNodeCount + ")*" + gap + "px)");
    nodesHolder.style.setProperty("--nodeHeight", "calc(1/" + 2 + "*100% - (1 - 1/" + 2 + ")*" + gap + "px)");
    nodesHolder.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    nodesHolder.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    nodesHolder.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    nodesHolder.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    nodesHolder.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");

    let contentSize = (nodesHolder.offsetHeight - (gap * totalNodeCount - 1)) / totalNodeCount;
    let circleWidth = (contentSize / 100) * 70;
    nodesHolder.style.setProperty("--circleSize", circleWidth + "px");

    this.updateImageRatio();
};

SimpleLinearGridDiagram.prototype.addDummyNode = function (pattenDiv) {
    let nodeParentDummy = document.createElement("div");
    nodeParentDummy.className = "clsNodeParentMain clsNodeParentDummyDiv";
    pattenDiv.appendChild(nodeParentDummy);
};

SimpleLinearGridDiagram.prototype.deleteNode = function (targetIndex) {
    if (this.arrDiagramNode.length > targetIndex) {
        this.arrDiagramNode.splice(targetIndex, 1);
        let nodeDelete = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + targetIndex + "']");
        if (nodeDelete && nodeDelete.parentElement) {
            nodeDelete.parentElement.remove();
        }
    }
    if (this.diagramData.nodes.length > targetIndex) {
        this.diagramData.nodes.splice(targetIndex, 1);
    }
    this.initDiagramCreation();
    this.updateEvents();
    this.resetNodeAttributes();
};

/**
 * Author:    Bala Krishnan K.
 * Created:   20.2.2020
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function SimpleLinearVerticalGridDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearGridDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    diagramParent.setAttribute("data-diagramtype", "vertical");
}

SimpleLinearVerticalGridDiagram.prototype = Object.create(SimpleLinearGridDiagram.prototype);
SimpleLinearVerticalGridDiagram.prototype.constructor = SimpleLinearVerticalGridDiagram;

SimpleLinearVerticalGridDiagram.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    const totalNodeCount = Math.ceil(nodeCount / 2);
    // console.log(totalNodeCount);

    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsNodesHolderVerticalGrid";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.appendChild(pattenDiv);

    let gap = DiagramNodeUtils.getGapForConnectors(this.nodeProps, nodeCount, this.diagramParent, this.diagramData.properties);

    let contentSize = (pattenDiv.offsetHeight - (gap * totalNodeCount - 1)) / totalNodeCount;
    let circleWidth = (contentSize / 100) * 50;

    pattenDiv.style.setProperty("--circleSize", circleWidth + "px");

    this.createNodeInstances(nodeCount, pattenDiv);

    this.setCalcToNode(pattenDiv, totalNodeCount);
};

SimpleLinearVerticalGridDiagram.prototype.resetHolderWidth = function () {
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    const nodeCount = this.diagramData.nodes.length;
    const totalNodeCount = Math.ceil(nodeCount / 2);
    this.setCalcToNode(nodesHolder, totalNodeCount);
    this.checkSMLOverflow();
    this.resetNodeAttributes();
    this.redrawPositionConnectors(0);
};

//Checking content exceeds width means applying node width as content width and height.
SimpleLinearVerticalGridDiagram.prototype.checkSMLOverflow = function (oldValue = "auto") {
    // setTimeout(() => {
    let firstNode = this.diagramParent.querySelector("[id='nodeMainParent0']");
    if (!firstNode) return;
    let nodeGroup = firstNode.querySelector("[name='nodeGroup']");
    let content = firstNode.querySelector("[name='contentNode']");
    let computedStyle = window.getComputedStyle(nodeGroup);
    let paddingTop = parseInt(computedStyle.paddingTop);
    let paddingBottom = parseInt(computedStyle.paddingBottom);
    let finalHeight = firstNode.clientHeight - paddingTop - paddingBottom;
    let maxHeight = this.diagramParent.style.getPropertyValue("--originalresizeheight");
    if (this.diagramData?.properties?.contenttype == "number") {
        this.resizeValueText(oldValue);
    }
    if (firstNode && content && content.clientHeight > parseInt(finalHeight) && this.diagramData.properties[this.diagramData.properties.contenttype + "size"] != "tiny") {
        this.diagramData.properties[this.diagramData.properties.contenttype + "size"] = oldValue;
        this.updateProperties(this.diagramData.properties);
        this.updatePropsCallBack(content.id);
        let heightValue = finalHeight / parseFloat(maxHeight);
        heightValue = Math.floor(heightValue * 10) / 10;
        let sizevalue = DiagramUtils.getSMLSizeFromValue(heightValue, this.arrSMLSize);
        DiagramUtils.updateResize(this.diagramParent, sizevalue, this.nodeProps, this.diagramData.properties);
        return true;
    }
    // }, 0);
};

SimpleLinearVerticalGridDiagram.prototype.setCalcToNode = function (nodesHolder, totalNodeCount) {
    let gap = DiagramNodeUtils.getGapForConnectors(this.nodeProps, totalNodeCount, this.diagramParent, this.diagramData.properties);
    let nodeWidth = "calc(1/" + 2 + "*100% - (1 - 1/" + 2 + ")*" + gap + "px)";
    let nodeHeight = "calc(1/" + totalNodeCount + "*100% - (1 - 1/" + totalNodeCount + ")*" + gap + "px)";
    nodesHolder.style.setProperty("--nodeHeight", nodeHeight);
    nodesHolder.style.setProperty("--nodeWidth", nodeWidth);
    nodesHolder.style.setProperty("column-gap", gap + "px");
    nodesHolder.style.setProperty("row-gap", gap + "px");
    nodesHolder.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    nodesHolder.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    nodesHolder.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    nodesHolder.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    nodesHolder.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");
    nodesHolder.style.setProperty("--contentNodeWidth", nodeHeight);
    nodesHolder.style.setProperty("--contentNodeHeight", "100%");

    this.updateImageRatio();
};

/**
 * Author:    Saravanan G
 * Created:   3.10.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function SimpleLinearTwoLegDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.arrCenterHolderNode = [];
}

SimpleLinearTwoLegDiagram.prototype = Object.create(SimpleLinearDiagram.prototype);
SimpleLinearTwoLegDiagram.prototype.constructor = SimpleLinearDiagram;

SimpleLinearTwoLegDiagram.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsNodesHolderTwoLeg";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.appendChild(pattenDiv);

    pattenDiv.style.setProperty("--nodeWidth", "calc(50% - " + this.nodeGap / 2 + "px)");
    pattenDiv.style.setProperty("--nodeHeight", "auto");
    pattenDiv.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    pattenDiv.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    pattenDiv.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    pattenDiv.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");

    this.createNodeInstances(nodeCount, pattenDiv);

    if (this.nodeProps.centerNode) {
        let connetorHolder = document.createElement("div");
        connetorHolder.className = "clsConnectorHolder";
        connetorHolder.setAttribute("id", "connectorHolder");
        connetorHolder.setAttribute("name", "connectorHolder");
        pattenDiv.appendChild(connetorHolder);
        this.createConnectorNodes(connetorHolder);
    }
};

SimpleLinearTwoLegDiagram.prototype.createConnectorNodes = function (connetorHolder) {
    let count = this.getMaxNodes();
    connetorHolder.innerHTML = "";
    let arrTempObj = JSON.parse(JSON.stringify(this.arrCenterHolderNode));

    this.arrCenterHolderNode = [];
    // let connectortext = this.diagramData.nodes[0].connectortext;
    for (let j = 0; j < count; j++) {
        let objData = arrTempObj && arrTempObj[j] && arrTempObj[j].objData;
        if (this.arrCenterHolderData && this.arrCenterHolderData[j] && !objData) {
            objData = this.arrCenterHolderData[j];
        }
        let centerItem = this.createCenterHolderInstance(connetorHolder, j, objData);
        let centerNode = centerItem.createCenterNode(connetorHolder);
        let holderText = centerNode.querySelector("[name='holderText']");
        if (holderText) {
            holderText.classList.add("clsSingleLineRestrict");
        }
        // centerItem.nodeGroup = this.diagramParent.querySelector("[id='centerHolderParent" + j + "']");
        centerItem.nodeGroup = centerNode;
        centerNode.classList.add("moodanimation");
        centerNode.setAttribute("data-animation", "primarytext");
    }
};

SimpleLinearTwoLegDiagram.prototype.getMaxNodes = function () {
    let firstNodeCount = this.diagramData.nodes[0] && this.diagramData.nodes[0].secondarytext && this.diagramData.nodes[0].secondarytext.items.length;
    let secondNodeCount = this.diagramData.nodes[1] && this.diagramData.nodes[1].secondarytext && this.diagramData.nodes[1].secondarytext.items.length;
    let count = Math.max(firstNodeCount, secondNodeCount);
    return count;
};

SimpleLinearTwoLegDiagram.prototype.createCenterHolderInstance = function (pattenDiv, index, contentData = { id: "", value: "", contenttype: "text", type: "text" }) {
    let centerItem = new window[this.nodeProps.nodeclassName](pattenDiv, {}, contentData, this.eventManagerXY, index, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
    centerItem.moodData = this.moodData;
    centerItem.moodName = this.moodName;
    centerItem.updateCallBack = this.updateCallBack;
    centerItem.searchIconCallBack = this.searchIconCallBack;
    centerItem.bgDeviceDiv = this.bgDeviceDiv;
    centerItem.arrDefaults = this.arrDefaults;
    centerItem.globalMoodData = this.globalMoodData;
    centerItem.arrTintArray = this.arrTintArray;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;
    this.arrCenterHolderNode.push(centerItem);
    return centerItem;
};

SimpleLinearTwoLegDiagram.prototype.recreateElementData = function () {
    SimpleLinearDiagram.prototype.recreateElementData.call(this);
    let connetorHolder = this.diagramParent.querySelector("[name='connectorHolder']");
    if (connetorHolder) {
        for (let j = 0; j < connetorHolder.children.length; j++) {
            // let objData = this.arrCenterHolderNode && this.arrCenterHolderNode[j] && this.arrCenterHolderNode[j].objData;
            let centerItem = this.createCenterHolderInstance(connetorHolder, j, {});
            centerItem.nodeGroup = this.diagramParent.querySelector("[id='centerHolderParent" + j + "']");
            centerItem.objData = centerItem.getJSONData();
        }
    }
    this.updateEvents();
    // this.updatePropsCallBack();
};

SimpleLinearTwoLegDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    LinearDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    // let arrFloaterDisable = mainProperties.floateroptionsdisable;
    // if (!arrFloaterDisable) return;
    // if (!arrFloaterDisable.includes("addoption")) arrFloaterDisable.push("addoption");
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable.push("addoption");
        mainProperties.floateroptionsdisable.push("content");
        mainProperties.floateroptionsdisable.push("contentoptions");
        mainProperties.floateroptionsdisable.push("arrange");
        mainProperties.floateroptionsdisable.push("edit");
        // mainProperties.floateroptionsdisable.push("texthighlight");
    } else mainProperties.floateroptionsdisable = ["addoption", "edit", "content", "contentoptions", "arrange"];
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

SimpleLinearTwoLegDiagram.prototype.getOutlineMatrix = function () {
    let row = [];
    const properties = this.getProperties();
    let jsonData = this.getJSONData();
    let arrNodes = jsonData && jsonData.nodes ? jsonData.nodes : this.diagramData.nodes;
    let arrCenterHolderData = [];
    try {
        // for (let i = 0; i < rowLength; i++) {
        for (let j = 0; j < arrNodes.length; j++) {
            let header = [];
            let column = [];
            let sublist = false;
            let nodeData = arrNodes[j];
            if (nodeData) {
                let headerData = nodeData.primarytext || {};
                headerData.content = nodeData.content;
                header.push(headerData);
                if (nodeData.secondarytext && nodeData.secondarytext.items) {
                    // nodeData.secondarytext.items[i].index = i;
                    for (let i = 0; i < nodeData.secondarytext.items.length; i++) {
                        column.push(nodeData.secondarytext.items[i]);
                    }
                    sublist = nodeData.secondarytext.sublist ? nodeData.secondarytext.sublist : "none";
                    if (column[j]) {
                        column[j].seccontent = nodeData.seccontent;
                        column[j].connectortext = nodeData.connectortext;
                    }
                }
            }
            this.setNodeData(j, nodeData);
            // row.push({ matrix: column });
            let rowObj = this.setRowMatrix(column, nodeData, sublist);
            rowObj.header = header;
            row.push(rowObj);
        }
        if (this.arrCenterHolderNode) {
            this.arrCenterHolderNode.forEach((element) => {
                arrCenterHolderData.push(element.objData);
            });
        }

        // }
    } catch (error) {
        console.log(error, "In Twoleg list outline generation");
    }
    let animationtype = this.diagramParent.parentElement.dataset.animationtype || "all";
    let oneattimeanimationtype = this.diagramParent.parentElement.dataset.oneattimeanimationtype || "fadein";
    return {
        subtype: "table",
        properties: properties,
        matrix: row,
        arrCenterHolderData: arrCenterHolderData,
        animationdata: { animationtype: animationtype, oneattimeanimationtype: oneattimeanimationtype },
    };
};

SimpleLinearTwoLegDiagram.prototype.initDiagramCreationOutline = function (outlineData, data) {
    let enableIcon = this.getVisibilityForHolder(data.supportedNodes, "iconHolder");
    let enableValue = this.getVisibilityForHolder(data.supportedNodes, "valueTitleHolder");
    let enableImage = this.getVisibilityForHolder(data.supportedNodes, "imageHolder");
    let enableLogoList = this.getVisibilityForHolder(data.supportedNodes, "logoListHolder");
    let moodsData = data.moodsData || this.globalMoodData?.basicgraphics || {};
    let iconHolderObj = DiagramUtils.getObjectFromName(data.supportedNodes, "iconHolder");
    let valueHolderObj = DiagramUtils.getObjectFromName(data.supportedNodes, "valueTitleHolder");
    let imageHolderObj = DiagramUtils.getObjectFromName(data.supportedNodes, "imageHolder");
    let logoHolderObj = DiagramUtils.getObjectFromName(data.supportedNodes, "imageSecHolder");

    let defaultprops = {
        diagramcontent: false,
        secondarytext: this.getVisibilityForHolder(data.supportedNodes, "subTitleHolder", true),
        primarytext: this.getVisibilityForHolder(data.supportedNodes, "titleHolder", true),
        label: this.getVisibilityForHolder(data.supportedNodes, "textLabelHolder", false),
        subtext: this.getVisibilityForHolder(data.supportedNodes, "subtextHolder", false),
        authorname: this.getVisibilityForHolder(data.supportedNodes, "authorNameHolder", true),
        authordes: this.getVisibilityForHolder(data.supportedNodes, "authorDesHolder", true),
        authorimage: this.getVisibilityForHolder(data.supportedNodes, "authorImageHolder", true),
        secondaryplaceholder: enableIcon ? "icon" : enableValue ? "number" : enableImage ? "image" : enableLogoList ? "logolist" : null,
        enablesecplaceholder: enableIcon ? enableIcon : enableImage ? enableImage : enableLogoList ? enableLogoList : enableValue ? enableValue : false,
        microchart: this.getVisibilityForHolder(data.supportedNodes, "microChartHolder", true),
        button: this.getVisibilityForHolder(data.supportedNodes, "buttonTitleHolder", false),
        logosize: (logoHolderObj && logoHolderObj.size) || moodsData.logosize || Constants.Value.logosize,
        iconsize: (iconHolderObj && iconHolderObj.size) || moodsData.iconsize || Constants.Value.iconsize,
        imagesize: (imageHolderObj && imageHolderObj.size) || moodsData.imagesize || Constants.Value.imagesize,
        numbersize: (valueHolderObj && valueHolderObj.size) || moodsData.numbersize || Constants.Value.numbersize,
    };

    let hasProperties = outlineData.hasOwnProperty("properties") && Object.keys(outlineData.properties).length > 0;
    let overrideProperties = !window.isFromSlideEditor && data?.name != outlineData?.properties?.name;
    if (overrideProperties && data?.extraData?.properties) defaultprops = { ...defaultprops, ...data.extraData.properties };
    let properties = defaultprops;
    if (hasProperties) {
        properties = {
            ...defaultprops,
            ...outlineData.properties,
        };
    }
    let nodes = [];
    if (outlineData && outlineData.matrix) {
        let rowLength = outlineData.matrix.length;
        for (let i = 0; i < rowLength; i++) {
            let rowItem = outlineData.matrix[i];
            let headerItem = (outlineData.header && outlineData.header[i]) || (rowItem && rowItem.header && rowItem.header[0]);
            // let nodeObj = {};
            let content = DiagramNodeUtils.diagramContentData(properties.contenttype, this.appStaticURL, this.arrDefaults, i);
            let nodeObj = DiagramNodeUtils.generateDefaultNodeData(rowItem, content);
            if (headerItem) {
                nodeObj.primarytext = headerItem;
                if (headerItem.content) {
                    nodeObj.content = headerItem.content;
                }
            }
            if (rowItem.secondary) nodeObj.seccontent = rowItem.secondary;
            if (rowItem) {
                let columnLength = rowItem.matrix.length;
                let arrItems = [];
                for (let i = 0; i < columnLength; i++) {
                    let columnItem = rowItem.matrix[i];
                    if (columnItem.type == "text") arrItems.push(columnItem);
                    if (columnItem.type == "icon" || columnItem.type == "table") nodeObj.content = columnItem;
                }
                nodeObj.secondarytext = { items: arrItems };
            }
            // if (rowItem.highlightdata) nodeObj.highlightdata = rowItem.highlightdata;
            nodes.push(nodeObj);
        }
    }
    properties.sequencetext = data.name.endsWith("-sec-sn");
    this.diagramData = { properties: properties, nodes: nodes };
    this.arrCenterHolderData = outlineData.arrCenterHolderData;
    this.updateProperties(properties);
};

SimpleLinearTwoLegDiagram.prototype.updateNodeData = function (nodeData, type, index, parentId) {
    // if (type.includes("icon") && parentId && parentId.includes("secondaryTextItem")) {
    if (type.includes("icon") && parentId) {
        let parentNode = this.diagramParent.querySelector("[id='" + parentId + "']");
        let iconNode = parentNode.parentElement.querySelector("[data-id='useNode']");
        // iconNode.setAttribute("xlink:href", "#" + nodeData.id);
        if (iconNode) iconNode.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "#" + nodeData.id);
        iconNode.parentElement.setAttribute("iconid", nodeData.id);
        iconNode.parentElement.setAttribute("iconpath", nodeData.value);
        SimpleLinearDiagram.prototype.updateNodeData.call(this, nodeData, type, parentNode.getAttribute("data-index"), parentId);
    } else {
        SimpleLinearDiagram.prototype.updateNodeData.call(this, nodeData, type, index, parentId);
    }
};

SimpleLinearTwoLegDiagram.prototype.defaultFoucsOut = function (event) {
    this.updateJSONData();
    SimpleLinearDiagram.prototype.defaultFoucsOut.call(this, event);
    let connectorHolder = this.diagramParent.querySelector("[name='connectorHolder']");
    if (connectorHolder) {
        this.createConnectorNodes(connectorHolder);
    }
    this.updateEvents();
};

SimpleLinearTwoLegDiagram.prototype.updateJSONData = function () {
    this.diagramData = this.getJSONData();
    this.arrDiagramNode.forEach((node, index) => {
        node.objData = this.diagramData.nodes[index];
    });
    this.getCenterHolderData();
};

SimpleLinearTwoLegDiagram.prototype.getCenterHolderData = function () {
    this.arrCenterHolderNode.forEach((element) => {
        if (element.nodeGroup) {
            let objData = element.getJSONData();
            element.objData = objData;
        }
    });
    return this.arrCenterHolderNode;
};

SimpleLinearTwoLegDiagram.prototype.deleteNode = function (targetIndex) {
    let firstNode = this.diagramData.nodes[0];
    let secNode = this.diagramData.nodes[1];
    if (firstNode.secondarytext.items.length <= 1) return;
    firstNode.secondarytext.items.pop();
    secNode.secondarytext.items.pop();
    this.initDiagramCreation();
    this.updateEvents();
};

SimpleLinearTwoLegDiagram.prototype.resetHolderWidth = function () {
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    nodesHolder.style.setProperty("--nodeWidth", "calc(50% - " + this.nodeGap / 2 + "px)");
    nodesHolder.style.setProperty("--nodeHeight", "auto");
    nodesHolder.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    nodesHolder.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    nodesHolder.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    nodesHolder.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");
    this.updateImageRatio();
    this.resetNodeAttributes();
};

/**
 * Author:    Bala Krishnan K.
 * Created:   Wed 20 July 2022
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function MultiCellOptionDiagram(diagramParent, diagramData, nodeProps, moodData = {}) {
    BaseDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.classList.add("clsMultiDiagram");
}

MultiCellOptionDiagram.prototype = Object.create(BaseDiagram.prototype);
MultiCellOptionDiagram.prototype.constructor = MultiCellOptionDiagram;

MultiCellOptionDiagram.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    let centerNodeStyle = this.nodeProps.centerNodeStyle || "";
    pattenDiv.className = "clsNodesHolder " + centerNodeStyle;
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.appendChild(pattenDiv);
    let nodealignment = this.nodeProps.nodealignment;
    this.diagramParent.setAttribute("data-node-alignment", nodealignment);

    // let gap = this.getGapForConnectors(nodeCount);
    // let gap = this.getGapForConnectors(nodeCount);
    let gap = DiagramNodeUtils.getGapForConnectors(this.nodeProps, nodeCount, this.diagramParent, this.diagramData.properties);

    pattenDiv.style.setProperty("--nodeWidth", "calc(1/" + nodeCount + "*100% - (1 - 1/" + nodeCount + ")*" + gap + "px)");
    pattenDiv.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    pattenDiv.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    pattenDiv.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    pattenDiv.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    pattenDiv.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");

    this.createNodeInstances(nodeCount, pattenDiv);
};

MultiCellOptionDiagram.prototype.checkSMLOverflow = function () {};
MultiCellOptionDiagram.prototype.createNodeInstances = function (nodeCount, pattenDiv) {
    let rows = this.diagramData.nodes;
    nodeCount = rows.length;

    for (let i = 0; i < nodeCount; i++) {
        let nodeObj = rows[i];
        this.nodeInstance(i, nodeCount, nodeObj, pattenDiv);
    }
    DiagramUtils.searchMultipleAICall(this.arrDiagramNode, this.diagramData.properties.contenttype, this.diagramData.properties, this.globalMoodData, this.searchIconCallBack, appBaseURL, this.appStaticURL);
};

MultiCellOptionDiagram.prototype.resetNodeAttributes = function () {
    this.setNodeCount();
    this.updateTextNodes();
    for (let i = 0; i < this.arrDiagramNode.length; i++) {
        if (this.globalMoodData) this.arrDiagramNode[i].globalMoodData = this.globalMoodData;
        if (this.arrTintArray) this.arrDiagramNode[i].arrTintArray = this.arrTintArray;
        this.arrDiagramNode[i].properties = this.diagramData.properties;
        this.arrDiagramNode[i].updateNodeAttributes(i, this.diagramRenderComplete);
        this.arrDiagramNode[i].updateImageLogoFrames();
        if (this.arrDiagramNode[i].parentNode && this.arrDiagramNode[i].parentNode.dataset.highlight == "true") this.setHighlightTargetPoints(this.arrDiagramNode[i].parentNode, this.diagramParent);
    }
    if (this.centerHolderNode) {
        this.centerHolderNode.updateNodeAttributes(0, this.diagramRenderComplete);
    }
};

MultiCellOptionDiagram.prototype.resetLayout = function () {};

MultiCellOptionDiagram.prototype.resetHolderWidth = function () {
    this.resetNodeAttributes();
};

MultiCellOptionDiagram.prototype.getJSONData = function (defaultproperties) {
    // if (this.arrDiagramNode.length == 0) return this.diagramData;
    let arrNodeData = [];
    for (let i = 0; i < this.arrDiagramNode.length; i++) {
        let nodeData = this.arrDiagramNode[i].getJSONData(this.diagramParent);
        arrNodeData.push(nodeData);
        this.arrDiagramNode[i].objData = nodeData; // Added to store data in nodeinstance also
    }
    // return { properties: this.getProperties(defaultproperties), rows: arrNodeData ,nodes:[]};
    return { properties: this.getProperties(defaultproperties), nodes: arrNodeData };
};

MultiCellOptionDiagram.prototype.resetImageLogoFrames = function () {};

MultiCellOptionDiagram.prototype.recreateElementData = function () {
    this.setMoodClassNames();
    let arrMultiGroupParent = this.diagramParent.querySelectorAll("div[name='multiGroupNode']");

    this.arrDiagramNode = [];
    let pattenDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    // this.createNodeInstances(3, pattenDiv);
    arrMultiGroupParent.forEach((element, index) => {
        this.nodeInstance(index, arrMultiGroupParent.length, {}, pattenDiv, element);
    });
    this.updateJSONData();
};

MultiCellOptionDiagram.prototype.nodeInstance = function (i, nodeCount, row, pattenDiv, parentNode = null) {
    let nodeItem = new window["MultiCellGroupNode"](pattenDiv, {}, row, this.eventManagerXY, i, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
    nodeItem.moodData = this.moodData;
    nodeItem.moodName = this.moodName;
    nodeItem.updateCallBack = this.updateCallBack;
    nodeItem.searchIconCallBack = this.searchIconCallBack;
    nodeItem.bgDeviceDiv = this.bgDeviceDiv;
    nodeItem.globalMoodData = this.globalMoodData;
    nodeItem.arrTintArray = this.arrTintArray;
    nodeItem.manifestUpdater = this.manifestUpdater;
    nodeItem.appStaticURL = this.appStaticURL;
    if (parentNode) nodeItem.reCreation(parentNode);
    else nodeItem.initCreation(i == nodeCount - 1);
    this.arrDiagramNode.push(nodeItem);
    nodeItem.updateNodeAttributes(i, this.diagramRenderComplete);
    return nodeItem;
};

MultiCellOptionDiagram.prototype.isNodeAddable = function (targetid) {
    let target = this.diagramParent.querySelector("[id='" + targetid + "']");
    let arrIndex = DiagramUtils.getMultiContentIndex(target.dataset.index);
    let multiGroupNode = this.diagramParent.querySelector("[id='multiGroupNode" + arrIndex[0] + "']");
    let type = this.nodeProps.nodeclassName.includes("Vertical") ? "vertical" : "horizontal";
    let nodeMainParent = this.diagramParent.querySelector("[id='nodeMainParent" + target.dataset.index + "']");
    let gap = getComputedStyle(multiGroupNode).gap;
    if (type == "horizontal") {
        multiGroupNode.style.setProperty("width", "fit-content");
        let remainingHeight = multiGroupNode.parentElement.offsetWidth - multiGroupNode.offsetWidth;
        multiGroupNode.style.removeProperty("width");
        if (remainingHeight <= 0 || nodeMainParent.offsetWidth + parseInt(gap) > remainingHeight) {
            return false;
        }
    } else if (type == "vertical") {
        multiGroupNode.style.setProperty("height", "fit-content");
        let remainingHeight = multiGroupNode.parentElement.offsetHeight - multiGroupNode.offsetHeight;
        multiGroupNode.style.removeProperty("height");
        if (remainingHeight <= 0 || nodeMainParent.clientHeight + parseInt(gap) > remainingHeight) {
            return false;
        }
    }
    return true;
};

MultiCellOptionDiagram.prototype.addNode = function (nodeData, index, isFromUndo = false) {
    this.eventManagerXY.clear();
    if (this.diagramData.nodes.length > index) {
        this.diagramData.nodes.splice(index, 0, nodeData);
    } else {
        this.diagramData.nodes.push(nodeData);
    }
    this.diagramParent.setAttribute("data-nodecount", this.diagramData.nodes.length);

    let lastNode = this.arrDiagramNode[this.arrDiagramNode.length - 1];
    // if (lastNode && this.diagramParent.dataset.classname == "SimpleLinearDiagram") lastNode.connectorNode = lastNode.createConnectorParent(lastNode.parentNode.parentElement, lastNode.objData.content);
    if (lastNode) lastNode.connectorNode = lastNode.createConnectorParent?.(lastNode.parentNode.parentElement, lastNode.objData.cells);
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    this.nodeInstance(index, this.diagramData.nodes.length, nodeData, nodesHolder);

    DiagramNodeUtils.updateNodeSizeForClient(this.diagramData, this.diagramParent, this.nodeGap);
    this.updateEvents();
    this.updateEmphasize();
    this.updateSpecialOperations();
    this.resetHolderWidth();
    this.resetNodeAttributes();
    this.updateJSONData();
    this.diagramRenderComplete();
    this.addFocus(index);

    // if (this.gridInstance) {
    //     if (this.nodeProps.imagegridclass) DiagramUtils.addClassNames(this.nodeProps.imagegridclass, this.diagramParent);
    // }
};

MultiCellOptionDiagram.prototype.getOldTargetJSON = function (target, index) {
    if (target.getAttribute("name") == "multiGroupNode") {
        return this.diagramData.nodes[index];
    } else {
        let arrIndex = DiagramUtils.getMultiContentIndex(index);
        return this.arrDiagramNode[arrIndex[0]].arrMultiCellNode[arrIndex[1]].getJSONData();
    }
};

MultiCellOptionDiagram.prototype.getOldTargetIndex = function (target) {
    if (target.getAttribute("name") == "multiGroupNode") {
        return Number(target.dataset.index);
    } else {
        // let arrIndex = DiagramUtils.getMultiContentIndex(target.dataset.index);
        return target.dataset.index;
    }
};

MultiCellOptionDiagram.prototype.deleteNode = function (targetIndex, target) {
    if (target.getAttribute("name") == "multiGroupNode") {
        if (this.arrDiagramNode.length > targetIndex) {
            this.arrDiagramNode.splice(targetIndex, 1);
            let nodeDelete = this.diagramParent.querySelector("[name='multiGroupNode'][data-index='" + targetIndex + "']");
            if (nodeDelete && nodeDelete.parentElement) {
                nodeDelete.parentElement.removeChild(nodeDelete);
            }
        }
        if (this.diagramData.nodes.length > targetIndex) {
            this.diagramData.nodes.splice(targetIndex, 1);
        }
    } else {
        let arrIndex = DiagramUtils.getMultiContentIndex(target.dataset.index);
        let arrNodes = this.arrDiagramNode[arrIndex[0]].arrMultiCellNode;
        let targetIndex = arrIndex[1];
        if (arrNodes.length > targetIndex) {
            arrNodes.splice(targetIndex, 1);
            let nodeDelete = this.diagramParent.querySelector("[name='nodeMainParent'][data-index='" + arrIndex[0] + "," + targetIndex + "']");
            if (nodeDelete && nodeDelete.parentElement) {
                nodeDelete.parentElement.removeChild(nodeDelete);
            }
        }
    }

    DiagramNodeUtils.updateNodeSizeForClient(this.diagramData, this.diagramParent, this.nodeGap);
    let index = this.diagramParent.getAttribute("data-emphasis");
    if (index == targetIndex) this.hideEmpahsis();

    this.resetHolderWidth();
    this.updateEmphasize();
    this.resetNodeAttributes();
    // setTimeout(() => {
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (targetIndex - 1) + "']");
    if (lastDiv) {
        let lastConnector = lastDiv.parentElement.querySelector("[name='connectorparent']");
        if (lastConnector) lastConnector.remove();
        this.updatePropsCallBack(lastDiv.id);
    }
    this.diagramRenderComplete();
    this.updateJSONData();
    // }, 100);
};

MultiCellOptionDiagram.prototype.swapNodes = function (objData, swapNodeIndex) {
    let target = this.diagramParent.querySelector("[id='" + objData.targetid + "']");
    if (target) {
        let index = parseInt(target.dataset.index);
        let arrIndex = DiagramUtils.getMultiContentIndex(target.dataset.index);
        let name = target.getAttribute("name");
        let swapIndex = index + swapNodeIndex;
        if (name && name != "multiGroupNode") {
            name = "nodeMainParent";
            index = target.dataset.index;
            swapIndex = arrIndex[0] + "," + (parseInt(arrIndex[1]) + swapNodeIndex);
        }
        let currentTarget = this.diagramParent.querySelector("[id='" + name + index + "']");
        let currentConnector = currentTarget.querySelector("[name='connectorparent']");
        let swapTarget = this.diagramParent.querySelector("[id='" + name + swapIndex + "']");
        let swapConnector = swapTarget.querySelector("[name='connectorparent']");

        currentTarget.remove();
        currentTarget.setAttribute("id", name + swapIndex);
        currentTarget.setAttribute("data-index", swapIndex);
        if (swapConnector) {
            swapConnector.remove();
            currentTarget.appendChild(swapConnector);
        }
        swapTarget.parentElement.insertBefore(currentTarget, swapNodeIndex == 1 ? swapTarget.nextSibling : swapTarget);
        swapTarget.setAttribute("id", name + index);
        swapTarget.setAttribute("data-index", index);
        if (currentConnector) {
            currentConnector.remove();
            swapTarget.appendChild(currentConnector);
        }
        if (name == "nodeMainParent") this.arrDiagramNode[arrIndex[0]].arrMultiCellNode = DiagramUtils.swapArrayElements(this.arrDiagramNode[arrIndex[0]].arrMultiCellNode, index.split(",")[1], swapIndex.split(",")[1]);
        else this.arrDiagramNode = DiagramUtils.swapArrayElements(this.arrDiagramNode, index, swapIndex);
        this.resetHolderWidth();
        this.resetNodeAttributes();
        if (this.checkHighlight) this.checkHighlight(this.diagramParent);
        this.updatePropsCallBack(objData.targetid);
    }
};

MultiCellOptionDiagram.prototype.crossout = function (objData) {
    let targetNode = this.diagramParent.querySelector("[id='" + objData.targetid + "']");
    let diagramContentNode = targetNode.id.includes("Holder") ? targetNode.parentElement : targetNode.querySelector("[data-id='diagramContentNode']");
    let isTextNode = false;
    let anchorPointObj = DiagramUtils.getObject(this.nodeProps.supportedNodes, true, "crossoutAnchor");
    if (anchorPointObj && targetNode) {
        let index = targetNode.dataset.index;
        let contentNode = this.diagramParent.querySelector("[name='" + anchorPointObj.name + "'][data-index='" + index + "']");
        if (contentNode && contentNode.clientHeight > 0) {
            targetNode = contentNode.firstElementChild;
            diagramContentNode = contentNode;
        }
    }
    if (!diagramContentNode || this.diagramData.properties.diagramcontent == false) return;
    let arrIndex = DiagramUtils.getMultiContentIndex(diagramContentNode ? diagramContentNode.dataset.index : "0,0");
    if (targetNode && targetNode.parentElement) {
        let className = isTextNode ? "clsCrossoutTextStyle" : "clsCrossoutStyle";
        let crossOutParent = targetNode.parentElement.querySelector("[name='crossoutParent']");
        // if (targetNode.parentElement.classList.contains(className)) {
        if (crossOutParent) {
            crossOutParent.parentElement.classList.remove(className);
            crossOutParent.remove();
            // targetNode.parentElement.removeAttribute("data-crossout", "true");
            this.arrDiagramNode[arrIndex[0]].arrMultiCellNode[arrIndex[1]]?.nodeGroup.removeAttribute("data-crossout");
        } else {
            targetNode.parentElement.classList.add(className);
            // targetNode.parentElement.setAttribute("data-crossout", "true");
            this.arrDiagramNode[arrIndex[0]].arrMultiCellNode[arrIndex[1]]?.nodeGroup.setAttribute("data-crossout", "true");
            this.arrDiagramNode[arrIndex[0]].arrMultiCellNode[arrIndex[1]]?.createCrossoutDiv(diagramContentNode);
        }
    }
    this.updatePropsCallBack(objData.targetid);
};

MultiCellOptionDiagram.prototype.updateNodeData = function (nodeData, type, index, parentId) {
    let target = this.diagramParent.querySelector("[id='" + parentId + "']");
    let arrIndex = DiagramUtils.getMultiContentIndex(target.dataset.index);
    if (this.arrDiagramNode && this.arrDiagramNode.length > arrIndex[0]) {
        this.arrDiagramNode[arrIndex[0]].arrMultiCellNode[arrIndex[1]].updateContentData(nodeData, type, parentId);
    }
};

// MultiCellOptionDiagram.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
//     dict[FloaterConstants.HIGHLIGHT] = null;
// };

MultiCellOptionDiagram.prototype.getOutlineMatrix = function () {
    this.updateJSONData();
    const properties = this.diagramData.properties;
    let rowMatrix = this.diagramData.nodes.map((data) => {
        return { matrix: data.cells };
    });
    return {
        subtype: "table",
        type: "table",
        outlinetype: "table",
        properties: properties,
        matrix: rowMatrix,
        multicontent: true,
    };
};

MultiCellOptionDiagram.prototype.changeSecondaryType = function (type, index) {
    // this.diagramData.properties.secondarytype = type;
    let arrIndex = DiagramUtils.getMultiContentIndex(index);
    if (this.arrDiagramNode && this.arrDiagramNode.length > arrIndex[0]) {
        this.arrDiagramNode[arrIndex[0]].arrMultiCellNode[arrIndex[1]].changeSecondaryType(type, index);
    }
    this.updateTextNodes();
};

MultiCellOptionDiagram.prototype.initDiagramCreationOutline = function (outlineData, data) {
    this.dataToMultiContentDataIfNeeded(data);
    let outlinetype = data.outlinetype;
    // if (data.outlinetype == "numbered" || data.outlinetype == "bulleted") outlinetype = data.outlinetype;
    let contentOptionNode = data.nodeclassName && data.nodeclassName.includes("ContentOptionNode");
    if (contentOptionNode) {
        outlinetype = outlineData && outlineData.subtype ? outlineData.subtype : data.outlinetype;
    }
    let enableIcon = this.getVisibilityForHolder(data.supportedNodes, "iconHolder");
    let enableValue = this.getVisibilityForHolder(data.supportedNodes, "valueTitleHolder");
    let enableImage = this.getVisibilityForHolder(data.supportedNodes, "imageHolder");
    let enableLogoList = this.getVisibilityForHolder(data.supportedNodes, "logoListHolder");
    let enableLogo = this.getVisibilityForHolder(data.supportedNodes, "imageSecHolder");
    let disableImage = data.floateroptionsdisable && data.floateroptionsdisable.includes("graphicsecondaryimage");
    let enableOverlay = this.globalMoodData.imageoverlayproperties?.enable;
    let enableOverlaySupport = this.globalMoodData.imageoverlayproperties?.support;
    let defaultprops = {
        diagramcontent: true,
        multicontentheader: true,
        secondarytext: this.getVisibilityForHolder(data.supportedNodes, "subTitleHolder", true),
        primarytext: this.getVisibilityForHolder(data.supportedNodes, "titleHolder", true),
        label: this.getVisibilityForHolder(data.supportedNodes, "textLabelHolder", false),
        subtext: this.getVisibilityForHolder(data.supportedNodes, "subtextHolder", false),
        authorname: this.getVisibilityForHolder(data.supportedNodes, "authorNameHolder", true),
        authordes: this.getVisibilityForHolder(data.supportedNodes, "authorDesHolder", true),
        authorimage: this.getVisibilityForHolder(data.supportedNodes, "authorImageHolder", true),
        gridimage: this.getVisibilityForHolder(data.supportedNodes, "imageHolder", true),
        secondaryplaceholder: enableIcon ? "icon" : enableValue ? "number" : enableImage ? "image" : enableLogoList ? "logolist" : enableLogo ? "logo" : null,
        enablesecplaceholder: enableIcon ? enableIcon : enableImage && !disableImage ? enableImage : enableLogoList ? enableLogoList : enableLogo ? enableLogo : enableValue ? enableValue : false,
        microchart: this.getVisibilityForHolder(data.supportedNodes, "microChartHolder", true),
        button: this.getVisibilityForHolder(data.supportedNodes, "buttonTitleHolder", false),
        contenttype: outlinetype,
        logosize: "large",
        isbleed: data.isbleedvisible != null ? data.isbleedvisible : false,
        isgutter: data.isguttervisible != null ? data.isguttervisible : false,
        isoverlay: data.isoverlayvisible != null ? data.isoverlayvisible : enableOverlay ? enableOverlay : false,
        isoverlaysupport: data.isoverlaysupport != null ? data.isoverlaysupport : enableOverlaySupport ? enableOverlaySupport : false,
        border: data.bordervisible || "",
        position: data.positionvisible || "",
        ismultigrid: data.isMultiGrid != null ? data.isMultiGrid : false,
        valueformat: data.numberformat || "actualnumber",
    };

    if ((outlineData.outlinetype == "checklist" || outlineData.outlinetype == "bulletlist") && outlineData.subtype && outlineData.subtype == "bulleted") outlinetype = outlineData.outlinetype;
    let hasProperties = outlineData && outlineData.hasOwnProperty("properties") && Object.keys(outlineData.properties).length != 0;
    // let properties = hasProperties ? outlineData.properties : defaultprops;
    let hasContent = true;
    let takeawayProperties = "";
    if (!hasProperties) {
        takeawayProperties = outlineData && outlineData.hasOwnProperty("takeawayproperties") && Object.keys(outlineData.takeawayproperties).length != 0;
    }
    // let properties = hasProperties ? outlineData.properties : takeawayProperties ? outlineData.takeawayproperties : defaultprops;
    let properties = defaultprops;
    let overrideProperties = !window.isFromSlideEditor && data?.name != outlineData?.properties?.name;
    if (overrideProperties && data?.extraData?.properties) defaultprops = { ...defaultprops, ...data.extraData.properties };
    if (hasProperties && !takeawayProperties) {
        properties = {
            ...defaultprops,
            ...outlineData.properties,
            // ...data?.extraData?.properties,
        };
    } else if (takeawayProperties) {
        properties = {
            ...defaultprops,
            ...outlineData.takeawayproperties,
            // ...data?.extraData?.properties,
        };
    }
    let nodes = [];
    // let hasLogo = true;

    if (outlineData && outlineData.matrix) {
        for (let i = 0; i < outlineData.matrix.length; i++) {
            let rowData = outlineData.matrix[i];
            nodes.push({ cells: rowData.matrix, rowproperties: rowData.rowproperties || {} });
        }
    }
    // properties.diagramcontent = data && data.textOnly ? false : outlinetype == "bulleted" || outlinetype == "numbered" ? false : properties.diagramcontent;
    // properties.contenttype = hasLogo && hasContent ? "logo" : properties.contenttype;
    let isSeqDisable = data.floateroptionsdisable && data.floateroptionsdisable.includes("sequencetext");
    properties.sequencetext = outlinetype == "numbered" || ((properties.sequencetext || outlineData.subtype == "numbered") && !isSeqDisable);
    // this.diagramData = { properties: properties, rows: outlineData.rows, nodes: nodes };
    this.diagramData = { properties: properties, nodes: nodes };
    this.centerholderdata = outlineData.centerholderdata;
    this.projectiondata = outlineData.projectiondata;
    this.startenddata = outlineData.startenddata;
    this.updateProperties(properties);
};

MultiCellOptionDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    BaseDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable.push("edit", "animationoption");
    } else mainProperties.floateroptionsdisable = ["edit", "animationoption"];
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

MultiCellOptionDiagram.prototype.updateTextNodes = function (index) {
    this.arrDiagramNode?.forEach((node) => {
        node?.setMaxHeightForLogoList?.();
        node?.updateOnFocusOut?.();
    });
};

MultiCellOptionDiagram.prototype.dataToMultiContentDataIfNeeded = function (data) {
    if (data.content.multicontent) return;
    let nodesData = data?.content?.matrix;

    let multiContentData = nodesData?.map((node) => {
        let cells = node?.matrix?.map((obj) => {
            if (!obj?.multicontent) {
                return dataForType(obj);
            }
        });

        return { matrix: cells };
    });

    if (nodesData) data.content.matrix = multiContentData;

    function dataForType(obj) {
        switch (obj.type) {
            case "text":
                return {
                    titleHolder: { type: "text", value: obj.value, contenttype: obj.contenttype },
                    nodeStyleClass: "clsTableDefaultText",
                };
            case "image":
                return {
                    imageHolder: { type: "image", value: obj.value, contenttype: obj.contenttype },
                    nodeStyleClass: "clsTableDefaultImage",
                };
            case "icon":
                return {
                    iconHolder: { type: "icon", value: obj.value, contenttype: obj.contenttype, id: obj.id },
                    nodeStyleClass: "clsTableDefaultIcon",
                };
        }
    }
};

/**
 * Author:    Bala Krishnan K.
 * Created:   Fri 12 May 20223
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function MultiCellOptionDeviceDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    MultiCellOptionDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    diagramParent.setAttribute("data-diagramtype", "vertical");
    this.lottieAnimationComplete = this.lottieAnimationComplete.bind(this);
    this.lottieAnimationReady = this.lottieAnimationReady.bind(this);
}

MultiCellOptionDeviceDiagram.prototype = Object.create(MultiCellOptionDiagram.prototype);
MultiCellOptionDeviceDiagram.prototype.constructor = MultiCellOptionDeviceDiagram;

MultiCellOptionDeviceDiagram.prototype.initDiagramCreation = function () {
    if (!this.diagramParent.dataset.contenttype) {
        this.diagramParent.setAttribute("data-contenttype", this.diagramData.properties.contenttype);
        this.setHolderType(this.diagramData.properties.contenttype, "contentNode");
    }
    this.diagramParent.style.opacity = 0;
    this.diagramParent.innerHTML = "";
    this.lottieAnimations = null;
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.resizeAsset = this.arrDiagramNode.length > 3;
    this.createPatternBackGround();
};

MultiCellOptionDeviceDiagram.prototype.getOutlineMatrix = function (isFromZenEditor = false) {
    let outlineData = MultiCellOptionDiagram.prototype.getOutlineMatrix.call(this, isFromZenEditor);
    let data = this.getCenterHolderData();
    outlineData.centerholderdata = data;
    return outlineData;
};

MultiCellOptionDeviceDiagram.prototype.getHeight = function () {
    this.resizeAsset = this.diagramData.nodes.length > 3;
    this.height = this.nodeProps.centerShape.height || 100;
    if (this.resizeAsset && this.nodeProps.centerShape.resizeheight) {
        this.height = this.nodeProps.centerShape.resizeheight;
    }
    return this.height;
};

MultiCellOptionDeviceDiagram.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsNodesHolderMultiDevice";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    pattenDiv.setAttribute("data-node", nodeCount + "nodes");
    this.diagramParent.appendChild(pattenDiv);
    if (!this.nodeProps.devicealignment) this.nodeProps.devicealignment = "center";
    this.diagramParent.setAttribute("data-device-alignment", this.nodeProps.devicealignment);
    let contentSize = (pattenDiv.offsetHeight - (nodeCount - 1) * this.nodeGap) / nodeCount;
    this.height = this.getHeight();
    this.marginleft = this.nodeProps.centerShape.marginleft || null;

    if (this.nodeProps.centerShape && this.nodeProps.centerShape.value == null) {
        let deviceType = (this.globalMoodData && this.globalMoodData.devicestyle) || "photographic";
        this.nodeProps.centerShape.value = "genericassets/device/" + deviceType + "/" + this.nodeProps.centerShape.id + ".svg";
    }
    if (this.bgDeviceDiv) {
        this.bgDeviceDiv.innerHTML = "";
        this.bgDeviceDiv.setAttribute("data-device-alignment", "left");
        this.bgDeviceDiv.setAttribute("data-hasDeviceBG", true);
    } else this.diagramParent.setAttribute("data-device-alignment", "center");

    pattenDiv.style.setProperty("--nodeWidth", "auto");
    pattenDiv.style.setProperty("--contentNodeWidth", "48px");
    pattenDiv.style.setProperty("--contentNodeHeight", "48px");
    pattenDiv.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    pattenDiv.style.setProperty("--nodeGap", this.nodeGap + "px");
    pattenDiv.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    pattenDiv.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    pattenDiv.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    pattenDiv.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");

    let circleWidth = (contentSize / 100) * 50;
    pattenDiv.style.setProperty("--circleSize", circleWidth + "px");

    this.createNodeInstances(nodeCount, pattenDiv);

    if (this.diagramData.properties.assetCenterShape?.assetGroupingId && JSON.stringify(this.diagramData.properties.assetCenterShape?.assetGroupingId) == JSON.stringify(this.nodeProps.assetGroupingId || [])) {
        this.nodeProps.centerShape = this.diagramData.properties.assetCenterShape;
        this.updateNodeProperties();
    }

    this.createDeviceHolder(this.bgDeviceDiv ? this.bgDeviceDiv : pattenDiv, this.nodeProps.centerShape);
};

MultiCellOptionDeviceDiagram.prototype.createCenterHolder = function (pattenDiv, contentData = { id: "", value: "", contenttype: "image" }) {
    let centerItem = new window["CustomDiagramNode"](pattenDiv, {}, this.centerholderdata ? this.centerholderdata : { content: {} }, this.eventManagerXY, 0, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.bgDeviceDiv ? this.bgDeviceDiv : this.diagramParent);
    centerItem.moodData = this.moodData;
    centerItem.moodName = this.moodName;
    centerItem.updateCallBack = this.updateCallBack;
    centerItem.searchIconCallBack = this.searchIconCallBack;
    centerItem.bgDeviceDiv = this.bgDeviceDiv;
    centerItem.arrDefaults = this.arrDefaults;
    centerItem.globalMoodData = this.globalMoodData;
    centerItem.arrTintArray = this.arrTintArray;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;
    this.centerHolderNode = centerItem;
    let centerNode = centerItem.createCenterNode(pattenDiv);
    return centerNode;
};

MultiCellOptionDeviceDiagram.prototype.recreateElementData = function (contentData = { id: "", value: "", contenttype: "image" }) {
    MultiCellOptionDiagram.prototype.recreateElementData.call(this);
    let pattenDiv = this.bgDeviceDiv ? this.bgDeviceDiv : this.diagramParent.querySelector("[name='nodesHolder']");
    let centerItem = new window[this.nodeProps.nodeclassName](pattenDiv, {}, this.centerholderdata ? this.centerholderdata : { content: {} }, this.eventManagerXY, 0, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.bgDeviceDiv ? this.bgDeviceDiv : this.diagramParent);
    let outerDiv = pattenDiv.querySelector("[data-id='outerDiv']");
    if (outerDiv) outerDiv.setAttribute("data-type", "device");
    centerItem.moodData = this.moodData;
    centerItem.moodName = this.moodName;
    centerItem.updateCallBack = this.updateCallBack;
    centerItem.searchIconCallBack = this.searchIconCallBack;
    centerItem.bgDeviceDiv = this.bgDeviceDiv;
    centerItem.arrDefaults = this.arrDefaults;
    centerItem.globalMoodData = this.globalMoodData;
    centerItem.arrTintArray = this.arrTintArray;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;

    this.centerHolderNode = centerItem;
    this.centerHolderNode.parentNode = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    this.centerHolderNode.nodeGroup = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    this.centerNode = this.diagramParent.querySelector("div[data-id='deviceHolderParent']");
    this.centerholderdata = this.getCenterHolderData();
    let centerShapeType = this.diagramParent.getAttribute("data-center-shape-type");
    if (!this.nodeProps.devicealignment) this.nodeProps.devicealignment = "center";
    if (!this.pptExport) {
        if (centerShapeType == "lottie") {
            let deviceHolder = this.diagramParent.querySelector("[data-id='deviceHolder']");
            let deviceHolderParent = deviceHolder.parentElement;
            deviceHolderParent.removeChild(deviceHolder);
            let deviceHolderCopy = deviceHolder.cloneNode();
            deviceHolderCopy.innerHTML = "";
            deviceHolderParent.appendChild(deviceHolderCopy);

            if (this.lottieAnimations) {
                this.clearLottieEvents();
            }
            try {
                this.lottieAnimations = lottie.loadAnimation({
                    container: deviceHolderCopy, // the dom element that will contain the animation
                    renderer: "svg",
                    loop: true,
                    autoPlay: this.isWidget,
                    path: DiagramUtils.checkAppStaticUrl(this.nodeProps.centerShape.value, this.appStaticURL), // the path to the animation json
                });
                this.lottieAnimations.addEventListener("data_ready", this.lottieAnimationReady);
            } catch (error) {
                this.diagramRenderComplete();
                console.log(error);
            }
        }
        this.marginleft = this.nodeProps.centerShape.marginleft || null;
        this.centerHolderNode.parentNode = this.bgDeviceDiv ? this.bgDeviceDiv.querySelector("[data-id='centerHolderParent']") : this.diagramParent.querySelector("[data-id='centerHolderParent']");
    }
    this.diagramParent.style.opacity = 1;
};

MultiCellOptionDeviceDiagram.prototype.lottieAnimationReady = function () {
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
    this.diagramParent.style.opacity = 1;
};

MultiCellOptionDeviceDiagram.prototype.lottieAnimationComplete = function () {
    this.diagramRenderComplete();
};

MultiCellOptionDeviceDiagram.prototype.isNonLinearAsset = function () {
    return true;
};

MultiCellOptionDeviceDiagram.prototype.updateNodeData = function (nodeData, type, index, parentId) {
    if (parentId && parentId.includes("centerHolderParent")) {
        this.centerHolderNode.objData.content = nodeData;
        this.centerholderdata = this.centerHolderNode.objData;
        this.centerHolderNode.updateContentData(nodeData, type, parentId);
    } else {
        MultiCellOptionDiagram.prototype.updateNodeData.call(this, nodeData, type, index, parentId);
    }
};

MultiCellOptionDeviceDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    MultiCellOptionDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable.push("sequencetext");
    } else mainProperties.floateroptionsdisable = ["sequencetext"];
    if (this.nodeProps.centerShape && this.nodeProps.centerShape.type && this.nodeProps.centerShape.type == "svg") {
        mainProperties.floateroptionsdisable.push("graphicbulletlist");
        mainProperties.floateroptionsdisable.push("graphicchecklist");
    }
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

MultiCellOptionDeviceDiagram.prototype.getCenterHolderData = function () {
    let objData = {};
    let parent = this.bgDeviceDiv ? this.bgDeviceDiv : this.diagramParent;
    if (!parent) return objData;
    let device = parent.querySelector("[data-id='deviceHolder']");
    let imageNode = device ? device.querySelector("[data-id='imageNode']") : null;
    let illustrationNode = device ? device.querySelector("[data-id='illustrationNode']") : null;
    if (imageNode) {
        let dataRef = { imageURL: imageNode.src };
        if (imageNode.dataset.csstext) dataRef.cropStyle = imageNode.dataset.csstext;
        if (imageNode.dataset.style) dataRef.cropData = imageNode.dataset.style;
        objData.content = { id: "", value: imageNode.src, type: "image", contenttype: "image", dataRef: dataRef };
    } else if (illustrationNode) objData.content = { id: illustrationNode.dataset.iconid, value: illustrationNode.dataset.iconpath, type: "icon", contenttype: "icon" };
    else objData.content = this.centerholderdata?.content || { id: "", value: "", type: "icon", contenttype: "icon" };
    this.centerholderdata = objData;
    return objData;
};

MultiCellOptionDeviceDiagram.prototype.slideDimensionChange = function () {
    if (window.ismoodchange) return;
    let parent = this.bgDeviceDiv ? this.bgDeviceDiv : this.diagramParent.querySelector("[name='nodesHolder']");
    let deviceHolder = parent.querySelector("[data-id='deviceHolder']");
    this.height = this.getHeight();
    let centerHolderParent = parent.querySelector("[data-id='deviceHolderParent']");
    if (!centerHolderParent) return;
    let imageHolder = centerHolderParent.querySelector("[data-id='contentimageparent']");
    let outerDiv = parent.querySelector("[data-id='outerDiv']");
    let isDevice = outerDiv && outerDiv.dataset.type == "device";
    if (isDevice && this.bgDeviceDiv) {
        centerHolderParent.style.width = this.bgDeviceDiv.clientWidth + "px";
        let additionalId = this.diagramParent.parentElement.getAttribute("data-element-id") || "";
        let clipPathNode = outerDiv.querySelector("clipPath[id='" + additionalId + this.nodeProps.centerShape.id + "-clip-path']");
        if (clipPathNode) DiagramResizeUtils.calcImageBounds(imageHolder, outerDiv, additionalId + this.nodeProps.centerShape.id);
    }
    if (isDevice) {
        outerDiv.firstElementChild.setAttribute("data-nodetype", "deviceSVG");
    }
    let finalWidth = centerHolderParent.clientWidth;

    if (imageHolder && finalWidth > 0) {
        let scale = DiagramResizeUtils.scaleToFit(finalWidth, (centerHolderParent.clientHeight * this.height) / 100, deviceHolder.getAttribute("original-width"), deviceHolder.getAttribute("original-height"), deviceHolder, this.bgDeviceDiv && !this.marginleft ? true : false, this.slideScale);
        imageHolder.setAttribute("data-scale", scale);
        parent.style.setProperty("--nodesMaxWidth", this.nodeProps.devicealignment && this.nodeProps.devicealignment == "left" ? "100%" : "calc(100% - " + centerHolderParent.clientWidth + "px)");
    }
    if (this.nodeProps.centerShape.type != "lottie" && !isDevice) this.setDimensionsForIllustrationNode(deviceHolder, centerHolderParent, parent, this.nodeProps.centerShape, { width: deviceHolder.clientWidth, height: deviceHolder.offsetHeight });
};

MultiCellOptionDeviceDiagram.prototype.createDeviceHolder = function (parentDiv, centerShape) {
    let centerHolderParent = document.createElement("div");
    centerHolderParent.setAttribute("data-id", "deviceHolderParent");
    centerHolderParent.className = "deviceHolderParent moodanimation";
    centerHolderParent.setAttribute("data-animation", "commonplaceholder");
    parentDiv.appendChild(centerHolderParent);
    parentDiv.style.setProperty("--devicemarginleft", this.marginleft ? this.marginleft : "0px");

    let deviceHolder = document.createElement("div");
    deviceHolder.setAttribute("data-id", "deviceHolder");
    deviceHolder.setAttribute("id", "deviceHolder");
    deviceHolder.className = "deviceHolder";
    centerHolderParent.appendChild(deviceHolder);

    this.diagramParent.setAttribute("data-center-shape-type", centerShape.type ? centerShape.type : "svg");
    if (centerShape.type == "lottie") {
        let height = centerShape.height ? centerShape.height + "px" : "600px";
        let width = centerShape.width ? centerShape.width + "px" : "600px";
        if (this.lottieAnimations) {
            this.clearLottieEvents();
        }

        try {
            this.lottieAnimations = lottie.loadAnimation({
                container: deviceHolder,
                renderer: "svg",
                loop: true,
                autoPlay: this.isWidget,
                path: DiagramUtils.checkAppStaticUrl(centerShape.value, this.appStaticURL),
            });
            this.lottieAnimations.addEventListener("data_ready", this.lottieAnimationComplete);
        } catch (error) {
            this.diagramRenderComplete();
            console.log(error);
        }

        deviceHolder.style.setProperty("width", width);
        centerHolderParent.style.setProperty("width", width);
        deviceHolder.style.setProperty("height", height);
        deviceHolder.setAttribute("original-width", width);
        deviceHolder.setAttribute("original-height", height);
        deviceHolder.setAttribute("lottie-type", true);
        if (this.nodeProps && this.nodeProps.assetGroupingId) deviceHolder.setAttribute("data-type", "lottie");
        deviceHolder.setAttribute("lottie-json-path", centerShape.value);
        DiagramResizeUtils.scaleToFit(width, height, width, height, deviceHolder, true);
        parentDiv.style.setProperty("--nodesMaxWidth", "calc(100% - " + width + ")");
    } else if (centerShape.type == "illustration") {
        let objAssets = this.centerholderdata?.content?.value && this.centerholderdata?.content?.value != "" && this.centerholderdata?.content?.value != "undefined" ? this.centerholderdata.content : { value: DiagramUtils.checkAppStaticUrl(centerShape.value, this.appStaticURL), id: centerShape.id };
        objAssets.value = DiagramUtils.checkAppStaticUrl(objAssets.value, this.appStaticURL);
        if (objAssets.type && objAssets.type == "image") {
            this.setDimensionsForIllustrationNode(deviceHolder, centerHolderParent, parentDiv, centerShape, { width: 400, height: 400 });
            this.changeImageNode(null, 0, objAssets.value);
            this.diagramRenderComplete();
        } else if ((objAssets.type && objAssets.type == "text") || objAssets.type == "number") {
            this.parseSvgForIllustration({ id: "placeholder", value: Constants.Value.placeholder_iconpath, data: Constants.Value.placeholdersvg }, deviceHolder, centerShape, centerHolderParent, parentDiv);
        } else
            DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body)
                .then((svgData) => {
                    this.parseSvgForIllustration(svgData, deviceHolder, centerShape, centerHolderParent, parentDiv);
                    this.needAssetUpdate(deviceHolder, centerShape, centerHolderParent, parentDiv, "illustration");
                })
                .catch((error) => {
                    console.log("Illustration asset load fail - " + error);
                    objAssets.id = "breaker_slide_2";
                    objAssets.value = this.appStaticURL + Constants.Value.placeholder_illustrationpath;
                    this.needAssetUpdate(deviceHolder, centerShape, centerHolderParent, parentDiv, "illustration");
                    DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body)
                        .then((svgData) => {
                            this.parseSvgForIllustration(svgData, deviceHolder, centerShape, centerHolderParent, parentDiv);
                        })
                        .catch((error) => {
                            console.log("Illustration asset load fail - " + error);
                            this.parseSvgForIllustration({ id: "placeholder", value: Constants.Value.placeholder_iconpath, data: Constants.Value.placeholdersvg }, deviceHolder, centerShape, centerHolderParent, parentDiv);
                        });
                });
    } else if (centerShape.type == "svg") {
        let isSingleAsset = centerShape.singleasset || false;
        let svgId = centerShape.id + (!isSingleAsset ? this.arrDiagramNode.length + "node" : "");
        let objAssets = { id: svgId, value: DiagramUtils.checkAppStaticUrl(centerShape.value, this.appStaticURL) + svgId + ".svg" };
        DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body)
            .then((svgData) => {
                this.parseSvgforShape(svgData, deviceHolder, centerShape, centerHolderParent, parentDiv);
            })
            .catch((error) => {
                console.log("Svg asset load fail - " + error);
                this.parseSvgforShape({ id: "placeholder", value: Constants.Value.placeholder_iconpath, data: Constants.Value.placeholdersvg }, deviceHolder, centerShape, centerHolderParent, parentDiv);
            });
    } else {
        const objAssets = { value: centerShape.value, id: centerShape.id, type: "icon" };
        DiagramCreateUtil.updateManifest(objAssets, this.manifestUpdater, this.appStaticURL);
        objAssets.value = DiagramUtils.checkAppStaticUrl(centerShape.value, this.appStaticURL);
        DiagramAssetLoader.oneTimeDownload(objAssets, false, document.body)
            .then((svgData) => {
                this.parseSvgforDevice(svgData, deviceHolder, centerShape, centerHolderParent, parentDiv);
            })
            .catch((error) => {
                console.log("Svg asset load fail - " + error);
                this.parseSvgforDevice({ id: "placeholder", value: Constants.Value.placeholder_iconpath, data: Constants.Value.placeholdersvg }, deviceHolder, centerShape, centerHolderParent, parentDiv);
            });
    }
};

MultiCellOptionDeviceDiagram.prototype.parseSvgForIllustration = function (svgData, deviceHolder, centerShape, centerHolderParent, parentDiv) {
    let svgNode = DiagramUtils.getSVGfromString(svgData.data);
    let dimensions = DiagramNodeUtils.getAssetDimensions(svgNode);
    svgNode.setAttribute("class", "illustrationNode accent1-fill");
    svgNode.setAttribute("data-id", "illustrationNode");
    svgNode.setAttribute("data-type", "illustration");
    svgNode.setAttribute("data-iconpath", svgData.value);
    svgNode.setAttribute("data-iconid", svgData.id);
    svgNode.setAttribute("id", svgData.id);
    deviceHolder.appendChild(svgNode);
    this.setDimensionsForIllustrationNode(deviceHolder, centerHolderParent, parentDiv, centerShape, dimensions);
    this.diagramRenderComplete();
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
    this.addFocus(this.arrDiagramNode.length - 1);
};

MultiCellOptionDeviceDiagram.prototype.needAssetUpdate = function (deviceHolder, centerShape, centerHolderParent, parentDiv, type) {
    let title = this.diagramParent.parentElement.parentElement.parentElement.querySelector("[id='TITLE']");
    let assetText = title ? title.innerText : null;
    if (assetText && assetText != null && this.diagramData.properties.isfromai) {
        function parseSVGIllustration(svgData) {
            deviceHolder.innerHTML = "";
            this.parseSvgForIllustration(svgData, deviceHolder, centerShape, centerHolderParent, parentDiv, assetText);
        }
        if (assetText) {
            centerShape.needAssetUpdate = false;
            deviceHolder.setAttribute("data-node-graphic-text", assetText);
            DiagramUtils.searchAIcall("illustrations", centerShape, assetText, this.diagramData.properties, this.globalMoodData, deviceHolder, 0, parseSVGIllustration.bind(this), appBaseURL, this.appStaticURL);
        }
    }
};

MultiCellOptionDeviceDiagram.prototype.parseSvgforShape = function (svgData, deviceHolder, centerShape, centerHolderParent, parentDiv) {
    let svgNode = DiagramUtils.getSVGfromString(svgData.data);
    let dimensions = DiagramNodeUtils.getAssetDimensions(svgNode);
    svgNode.setAttribute("class", "svgNode accent1-fill");
    svgNode.setAttribute("data-id", "svgNode");
    svgNode.setAttribute("data-type", "svg");
    svgNode.setAttribute("data-iconpath", svgData.value);
    svgNode.setAttribute("data-iconid", svgData.id);
    deviceHolder.appendChild(svgNode);
    DiagramNodeUtils.applyColorToNonLinearAssets(svgNode, svgData.id, this.arrTintArray);
    this.setDimensionsForIllustrationNode(deviceHolder, centerHolderParent, parentDiv, centerShape, dimensions);
    this.diagramRenderComplete();
    this.updateEmphasize();
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
    this.addFocus(this.arrDiagramNode.length - 1);
};

MultiCellOptionDeviceDiagram.prototype.parseSvgforDevice = function (svgData, deviceHolder, centerShape, centerHolderParent, parentDiv) {
    let outerDiv = document.createElement("div");
    outerDiv.setAttribute("data-id", "outerDiv");
    outerDiv.setAttribute("data-type", "device");
    outerDiv.setAttribute("data-nodetype", "deviceHolder");
    outerDiv.className = "outerDiv";
    deviceHolder.appendChild(outerDiv);
    deviceHolder.classList.add("clsDevice");
    outerDiv.innerHTML = svgData.data;

    let imageHolderParent = this.createCenterHolder(deviceHolder);
    let imageHolder = imageHolderParent.querySelector("[id*='imageHolder']");
    imageHolder.setAttribute("data-focus-parent", "centerHolderParent");
    imageHolder.setAttribute("id", "imageHolder" + DiagramNodeUtils.uuidv4());
    let scaleToFitType = this.bgDeviceDiv && !this.marginleft ? true : false;
    window.ismoodchange = false;
    this.diagramParent.style.setProperty("--nodesMaxWidth", "unset");
    let svgNode = DiagramUtils.getSVGfromString(svgData.data);
    let dimensions = DiagramNodeUtils.getAssetDimensions(svgNode);
    svgNode.setAttribute("data-nodetype", "deviceSVG");
    let width = dimensions.width;
    let height = dimensions.height;
    deviceHolder.style.setProperty("width", width + "px");
    deviceHolder.style.setProperty("height", height + "px");
    deviceHolder.setAttribute("original-width", width);
    deviceHolder.setAttribute("original-height", height);
    let additionalId = this.diagramParent.parentElement.getAttribute("data-element-id") || "";
    imageHolderParent.style.setProperty("clip-path", "url(#" + additionalId + centerShape.id + "-clip-path)");
    imageHolderParent.style.setProperty("-webkit-clip-path", "url(#" + additionalId + centerShape.id + "-clip-path)");
    imageHolderParent.style.setProperty("width", width + "px");
    imageHolderParent.style.setProperty("height", height + "px");

    let finalWidth = centerHolderParent.clientWidth;
    if (parseFloat(imageHolder.getAttribute("data-scale"))) {
        finalWidth = centerHolderParent.clientWidth * parseFloat(imageHolder.getAttribute("data-scale"));
    }
    let finalHeight = (centerHolderParent.clientHeight * this.height) / 100;

    let scale = DiagramResizeUtils.scaleToFit(finalWidth, finalHeight, width, height, deviceHolder, scaleToFitType, this.slideScale);
    imageHolder.setAttribute("data-scale", scale);
    let imgNode = imageHolder.querySelector("img[data-id='imageNode'],img[data-id='logoNode']");
    imgNode.setAttribute("data-focus-parent", "centerHolderParent");

    CommonImageUtils.updateImageBounds(imgNode, { islogofit: false, contenttype: "image" }, scale);
    this.diagramParent.style.setProperty("--nodesMaxWidth", this.nodeProps.devicealignment && this.nodeProps.devicealignment == "left" ? "100%" : "calc(100% - " + centerHolderParent.clientWidth + "px)");

    let clipPathNode = outerDiv.querySelector("clipPath[id='" + centerShape.id + "-clip-path']");
    if (!clipPathNode) return;
    this.calcImageBounds(clipPathNode, imageHolder, outerDiv);
    clipPathNode.setAttribute("clipPathUnits", "objectBoundingBox");
    DiagramNodeUtils.applySvgClipPath(centerShape.id, deviceHolder, 0, deviceHolder, outerDiv.firstElementChild, this.diagramParent.parentElement.getAttribute("data-element-id"));
    this.resetNodeAttributes();
    this.diagramRenderComplete();
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
    this.addFocus(this.arrDiagramNode.length - 1);
};

MultiCellOptionDeviceDiagram.prototype.calcImageBounds = function (clipPathNode, imageHolder, outerDiv) {
    let clipPathGroupNode = outerDiv.querySelector("g[clip-path*='url(#" + this.nodeProps.centerShape.id + "-clip-path)']");
    let bbox = clipPathGroupNode ? clipPathGroupNode.getBBox() : { width: 0, height: 0, x: 0, y: 0 };
    imageHolder.style.position = "absolute";
    imageHolder.style.width = bbox.width + "px";
    imageHolder.style.height = bbox.height + "px";
    imageHolder.style.left = bbox.x + "px";
    imageHolder.style.top = bbox.y + "px";
    imageHolder.style.setProperty("clip-path", "unset", "important");
};

MultiCellOptionDeviceDiagram.prototype.setDimensionsForIllustrationNode = function (deviceHolder, centerHolderParent, parentDiv, centerShape, dimensions) {
    let height = this.height ? this.height + "%" : dimensions.height + "px";
    let width = centerShape.width ? centerShape.width + "%" : (dimensions.width < this.diagramParent.clientWidth * 0.4 ? dimensions.width : this.diagramParent.clientWidth * 0.4) + "px";
    if (this.nodeProps.devicealignment && this.nodeProps.devicealignment == "left" && !centerShape.width) width = "100%";
    if (centerShape.type && centerShape.type == "illustration" && parseInt(width) < 460) width = "460px";
    deviceHolder.style.setProperty("height", height);
    deviceHolder.setAttribute("original-width", width);
    deviceHolder.setAttribute("original-height", height);
    centerHolderParent.style.setProperty("width", width);
    parentDiv.style.setProperty("--nodesMaxWidth", this.nodeProps.devicealignment && this.nodeProps.devicealignment == "left" ? "100%" : "calc(100% - " + centerHolderParent.clientWidth + "px)");
};

MultiCellOptionDeviceDiagram.prototype.changeImageNode = function (strImageCropID, index, imageURL, completeCallback) {
    let deviceHolder = (this.bgDeviceDiv ? this.bgDeviceDiv : this.diagramParent).querySelector("[data-id='deviceHolder']");
    deviceHolder.innerHTML = "";
    this.centerholderdata = { content: { value: imageURL, contenttype: "image", type: "image" } };
    let imageHolderParent = this.createCenterHolder(deviceHolder, { value: imageURL, contenttype: "image", type: "image" });
    let imageHolder = imageHolderParent.querySelector("[id*='imageHolder']");
    imageHolder.setAttribute("data-focus-parent", "centerHolderParent");
    let imgNode = imageHolder.querySelector("img[data-id='imageNode'],img[data-id='logoNode']");
    CommonImageUtils.updateImageBounds(imgNode, { islogofit: false, contenttype: "image" }, 1, completeCallback);
};

MultiCellOptionDeviceDiagram.prototype.changeAsset = function (obj) {
    let pattenDiv = this.bgDeviceDiv ? this.bgDeviceDiv : this.diagramParent.querySelector("[name='nodesHolder']");
    let deviceHolder = pattenDiv.querySelector("[data-id='deviceHolderParent']");
    deviceHolder.remove();
    this.nodeProps.centerShape.value = obj.value;
    this.nodeProps.centerShape.assetGroupingId = this.nodeProps.assetGroupingId;
    this.diagramData.properties.assetCenterShape = this.nodeProps.centerShape;
    this.updateProperties(this.diagramData.properties);
    this.createDeviceHolder(pattenDiv, this.nodeProps.centerShape);
};

MultiCellOptionDeviceDiagram.prototype.diagramRenderComplete = function () {
    this.diagramParent.style.opacity = 1;
    if (this.completeCallBack && this.completeCallBack.func) {
        this.completeCallBack.func(this.completeCallBack.params);
        this.completeCallBack = null;
    }
    this.resetLayout();
    this.updateEvents();
    let arrNodes = this.diagramParent.querySelectorAll("[name='nodeMainParent']");
    arrNodes.forEach((element) => {
        if (element.dataset.columntype) {
            if (element.dataset.columntype == "start") {
                if (arrNodes.length < 4) {
                    element.setAttribute("data-nodealign", "left");
                } else {
                    element.setAttribute("data-nodealign", "right");
                }
            } else {
                element.setAttribute("data-nodealign", "left");
            }
        }
    });
};

MultiCellOptionDeviceDiagram.prototype.updateNodesHolderClass = function (nodeCount) {
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    nodesHolder.setAttribute("data-node", nodeCount + "nodes");
};

MultiCellOptionDeviceDiagram.prototype.resetHolderWidth = function () {
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    nodesHolder.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    nodesHolder.style.setProperty("--nodeGap", this.nodeGap + "px");
    nodesHolder.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    nodesHolder.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    nodesHolder.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    nodesHolder.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");
    this.recalculateheight();
};

MultiCellOptionDeviceDiagram.prototype.diagramPasteHandler = function (event) {
    BaseDiagram.prototype.diagramPasteHandler.call(this, event);
};

MultiCellOptionDeviceDiagram.prototype.defaultFoucsOut = function (event) {
    BaseDiagram.prototype.defaultFoucsOut.call(this, event);
    this.recalculateheight();
};

MultiCellOptionDeviceDiagram.prototype.clear = function (event) {
    BaseDiagram.prototype.clear.call(this, event);
    if (this.isTempSlide) return;
    if (this.lottieAnimations) {
        this.clearLottieEvents();
    }
    this.lottieAnimations = null;
};

MultiCellOptionDeviceDiagram.prototype.clearLottieEvents = function () {
    this.lottieAnimations.removeEventListener("data_ready", this.lottieAnimationReady);
    this.lottieAnimations.removeEventListener("data_ready", this.lottieAnimationComplete);
    this.lottieAnimations.stop();
    this.lottieAnimations.destroy();
};

MultiCellOptionDeviceDiagram.prototype.setHighlightPosition = function (node, parent) {
    let nodeParent = node.parentElement;
    let element = nodeParent.querySelector("[data-id='diagramContentNode']");
    if (!element || element.clientWidth == 0) element = node;
    return { element: element, alignment: "auto" };
};

//Emphasize

MultiCellOptionDeviceDiagram.prototype.emphasize = function (emphasizeData) {
    BaseDiagram.prototype.emphasize.call(this, emphasizeData);
    this.updateNonLinearEmphasize();
};

MultiCellOptionDeviceDiagram.prototype.updateEmphasize = function () {
    BaseDiagram.prototype.updateEmphasize.call(this);
    this.updateNonLinearEmphasize();
};

MultiCellOptionDeviceDiagram.prototype.updateNonLinearEmphasize = function () {
    let centerNode = this.diagramParent.querySelector("[data-id='deviceHolderParent']");
    if (!centerNode) return;
    let arrPath = Array.from(centerNode.querySelectorAll("g[id*='-point']"));
    this.arrDiagramNode.map(
        function (node, i) {
            let nodeParent = node.parentNode.parentElement;
            let path = arrPath.find((grp) => grp.id.endsWith(i + 1));
            if (path) {
                let nodeBGColorOptions = this.nodeProps.bgColor ? this.nodeProps.bgColor.split(",") : [];
                let hasBG = nodeBGColorOptions.length > 1;
                let baseEmphasisClass = this.nodeProps.emphasisClass ? this.nodeProps.emphasisClass : "clsEmphasis";
                let emphasizeDisableClass = hasBG ? baseEmphasisClass + "DisabledBG" : baseEmphasisClass + "Disabled";
                let emphasizeEnableClass = hasBG ? baseEmphasisClass + "EnabledBG" : baseEmphasisClass + "Enabled";
                if (nodeParent && path && nodeParent.classList.contains(emphasizeEnableClass)) {
                    path.classList.remove(emphasizeDisableClass);
                    path.classList.add(emphasizeEnableClass);
                } else if (path && nodeParent.classList.contains(emphasizeDisableClass)) {
                    path.classList.remove(emphasizeEnableClass);
                    path.classList.add(emphasizeDisableClass);
                } else {
                    path.classList.remove("clsEmphasisEnabledBG");
                    path.classList.remove("clsEmphasisEnabled");
                    path.classList.remove("clsEmphasisDisabledBG");
                    path.classList.remove("clsEmphasisDisabled");
                }
            }
        }.bind(this)
    );
};

/**
 * Author:    Bala Krishnan K.
 * Created:   30.10.2020
 *
 **/

"use strict";

function SimpleLinearDiagramDevice(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    diagramParent.setAttribute("data-diagramtype", "vertical");
    this.lottieAnimationComplete = this.lottieAnimationComplete.bind(this);
    this.lottieAnimationReady = this.lottieAnimationReady.bind(this);
}

SimpleLinearDiagramDevice.prototype = Object.create(SimpleLinearDiagram.prototype);
SimpleLinearDiagramDevice.prototype.constructor = SimpleLinearDiagramDevice;

SimpleLinearDiagramDevice.prototype.initDiagramCreation = function () {
    if (!this.diagramParent.dataset.contenttype) {
        this.diagramParent.setAttribute("data-contenttype", this.diagramData.properties.contenttype);
        this.setHolderType(this.diagramData.properties.contenttype, "contentNode");
    }
    this.diagramParent.style.opacity = 0;
    this.diagramParent.innerHTML = "";
    this.lottieAnimations = null;
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.resizeAsset = this.arrDiagramNode.length > 3;
    this.createPatternBackGround();
};

SimpleLinearDiagramDevice.prototype.getHeight = function () {
    this.resizeAsset = this.diagramData?.nodes?.length > 3;
    this.height = this.nodeProps.centerShape.height || 100;
    if (this.resizeAsset && this.nodeProps.centerShape.resizeheight) {
        this.height = this.nodeProps.centerShape.resizeheight;
    }
    return this.height;
};

SimpleLinearDiagramDevice.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsNodesHolderDevice";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    pattenDiv.setAttribute("data-node", nodeCount + "nodes");
    this.diagramParent.appendChild(pattenDiv);
    if (!this.nodeProps.devicealignment) this.nodeProps.devicealignment = "center";
    this.diagramParent.setAttribute("data-device-alignment", this.nodeProps.devicealignment);
    let contentSize = (pattenDiv.offsetHeight - (nodeCount - 1) * this.nodeGap) / nodeCount;

    if (this.bgDeviceDiv) {
        this.bgDeviceDiv.innerHTML = "";
        this.bgDeviceDiv.setAttribute("data-device-alignment", "left");
        this.bgDeviceDiv.setAttribute("data-hasDeviceBG", true);
    } else this.diagramParent.setAttribute("data-device-alignment", "center");

    pattenDiv.style.setProperty("--nodeWidth", "auto");
    pattenDiv.style.setProperty("--contentNodeWidth", "48px");
    pattenDiv.style.setProperty("--contentNodeHeight", "48px");
    pattenDiv.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    pattenDiv.style.setProperty("--nodeGap", this.nodeGap + "px");
    pattenDiv.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    pattenDiv.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    pattenDiv.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    pattenDiv.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");

    let circleWidth = (contentSize / 100) * 50;
    pattenDiv.style.setProperty("--circleSize", circleWidth + "px");

    this.createNodeInstances(nodeCount, pattenDiv);

    this.height = this.getHeight();
    this.marginleft = this.nodeProps.centerShape.marginleft || null;

    if (this.nodeProps.centerShape && this.nodeProps.centerShape.value == null) {
        let deviceType = (this.globalMoodData && this.globalMoodData.devicestyle) || "photographic";
        this.nodeProps.centerShape.value = "genericassets/device/" + deviceType + "/" + this.nodeProps.centerShape.id + ".svg";
    }

    if (this.diagramData.properties.assetCenterShape?.assetGroupingId && JSON.stringify(this.diagramData.properties.assetCenterShape?.assetGroupingId) == JSON.stringify(this.nodeProps.assetGroupingId || [])) {
        this.nodeProps.centerShape = this.diagramData.properties.assetCenterShape;
        this.updateNodeProperties();
    }

    this.createDeviceHolder(this.bgDeviceDiv ? this.bgDeviceDiv : pattenDiv, this.nodeProps.centerShape);
};

SimpleLinearDiagramDevice.prototype.createCenterHolder = function (pattenDiv, contentData = { id: "", value: "", contenttype: "image" }) {
    let centerItem = new window[this.nodeProps.nodeclassName](pattenDiv, {}, this.centerholderdata ? this.centerholderdata : { content: {} }, this.eventManagerXY, 0, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.bgDeviceDiv ? this.bgDeviceDiv : this.diagramParent);
    centerItem.moodData = this.moodData;
    centerItem.moodName = this.moodName;
    centerItem.updateCallBack = this.updateCallBack;
    centerItem.searchIconCallBack = this.searchIconCallBack;
    centerItem.bgDeviceDiv = this.bgDeviceDiv;
    centerItem.arrDefaults = this.arrDefaults;
    centerItem.globalMoodData = this.globalMoodData;
    centerItem.arrTintArray = this.arrTintArray;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;
    this.centerHolderNode = centerItem;
    let centerNode = centerItem.createCenterNode(pattenDiv);
    return centerNode;
};

SimpleLinearDiagramDevice.prototype.recreateElementData = function (contentData = { id: "", value: "", contenttype: "image" }) {
    SimpleLinearDiagram.prototype.recreateElementData.call(this);
    let pattenDiv = this.bgDeviceDiv ? this.bgDeviceDiv : this.diagramParent.querySelector("[name='nodesHolder']");
    let centerItem = new window[this.nodeProps.nodeclassName](pattenDiv, {}, this.centerholderdata ? this.centerholderdata : { content: {} }, this.eventManagerXY, 0, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.bgDeviceDiv ? this.bgDeviceDiv : this.diagramParent);
    let outerDiv = pattenDiv.querySelector("[data-id='outerDiv']");
    if (outerDiv) outerDiv.setAttribute("data-type", "device");
    centerItem.moodData = this.moodData;
    centerItem.moodName = this.moodName;
    centerItem.updateCallBack = this.updateCallBack;
    centerItem.searchIconCallBack = this.searchIconCallBack;
    centerItem.bgDeviceDiv = this.bgDeviceDiv;
    centerItem.arrDefaults = this.arrDefaults;
    centerItem.globalMoodData = this.globalMoodData;
    centerItem.arrTintArray = this.arrTintArray;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;

    this.centerHolderNode = centerItem;
    this.centerHolderNode.parentNode = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    this.centerHolderNode.nodeGroup = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    this.centerNode = this.diagramParent.querySelector("div[data-id='deviceHolderParent']");
    this.centerholderdata = this.getCenterHolderData();
    let centerShapeType = this.diagramParent.getAttribute("data-center-shape-type");
    if (!this.nodeProps.devicealignment) this.nodeProps.devicealignment = "center";
    if (!this.pptExport) {
        if (centerShapeType == "lottie") {
            let deviceHolder = this.diagramParent.querySelector("[data-id='deviceHolder']");
            let deviceHolderParent = deviceHolder.parentElement;
            deviceHolderParent.removeChild(deviceHolder);
            let deviceHolderCopy = deviceHolder.cloneNode();
            deviceHolderCopy.innerHTML = "";
            deviceHolderParent.appendChild(deviceHolderCopy);

            if (this.lottieAnimations) {
                this.clearLottieEvents();
            }
            try {
                this.lottieAnimations = lottie.loadAnimation({
                    container: deviceHolderCopy, // the dom element that will contain the animation
                    renderer: "svg",
                    loop: true,
                    autoPlay: this.isWidget,
                    path: DiagramUtils.checkAppStaticUrl(this.nodeProps.centerShape.value, this.appStaticURL), // the path to the animation json
                });
                this.lottieAnimations.addEventListener("data_ready", this.lottieAnimationReady);
            } catch (error) {
                this.diagramRenderComplete();
                console.log(error);
            }
        }
        this.marginleft = this.nodeProps.centerShape.marginleft || null;
        this.centerHolderNode.parentNode = this.bgDeviceDiv ? this.bgDeviceDiv.querySelector("[data-id='centerHolderParent']") : this.diagramParent.querySelector("[data-id='centerHolderParent']");
    }
    this.diagramParent.style.opacity = 1;
};

SimpleLinearDiagramDevice.prototype.lottieAnimationReady = function () {
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
    this.diagramParent.style.opacity = 1;
};

SimpleLinearDiagramDevice.prototype.lottieAnimationComplete = function () {
    this.diagramRenderComplete();
};

SimpleLinearDiagramDevice.prototype.isNonLinearAsset = function () {
    return true;
};

SimpleLinearDiagramDevice.prototype.updateNodeData = function (nodeData, type, index, parentId) {
    if (parentId && parentId.includes("centerHolderParent")) {
        this.centerHolderNode.objData.content = nodeData;
        this.centerholderdata = this.centerHolderNode.objData;
        this.centerHolderNode.updateContentData(nodeData, type, parentId);
    } else if (this.arrDiagramNode && this.arrDiagramNode.length > index) {
        this.arrDiagramNode[index].updateContentData(nodeData, type, parentId);
    }
};

SimpleLinearDiagramDevice.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable.push("sequencetext");
    } else mainProperties.floateroptionsdisable = ["sequencetext"];
    if (this.nodeProps.centerShape && this.nodeProps.centerShape.type && this.nodeProps.centerShape.type == "svg") {
        mainProperties.floateroptionsdisable.push("graphicbulletlist");
        mainProperties.floateroptionsdisable.push("graphicchecklist");
    }
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

SimpleLinearDiagramDevice.prototype.getCenterHolderData = function () {
    let objData = {};
    let parent = this.bgDeviceDiv ? this.bgDeviceDiv : this.diagramParent;
    if (!parent) return objData;
    let device = parent.querySelector("[data-id='deviceHolder']");
    let imageNode = device ? device.querySelector("[data-id='imageNode']") : null;
    let iconNode = device ? device.querySelector("[data-id='iconNode']") : null;
    let illustrationNode = device ? device.querySelector("[data-id='illustrationNode']") : null;
    if (imageNode) {
        let dataRef = { imageURL: imageNode.src };
        if (imageNode.dataset.csstext) dataRef.cropStyle = imageNode.dataset.csstext;
        if (imageNode.dataset.style) dataRef.cropData = imageNode.dataset.style;
        objData.content = { id: "", value: imageNode.src, type: "image", contenttype: "image", dataRef: dataRef, assetText: imageNode?.parentElement?.dataset?.nodeGraphicText };
    } else if (illustrationNode) objData.content = { id: illustrationNode.dataset.iconid, value: illustrationNode?.dataset?.iconpath, type: "icon", contenttype: "icon", assetText: illustrationNode?.parentElement?.dataset?.nodeGraphicText };
    else objData.content = this.centerholderdata?.content || { id: "", value: "", type: "icon", contenttype: "icon", assetText: iconNode?.parentElement?.dataset?.nodeGraphicText };
    this.centerholderdata = objData;
    return objData;
};

SimpleLinearDiagramDevice.prototype.slideDimensionChange = function () {
    if (window.ismoodchange) return;
    let parent = this.bgDeviceDiv ? this.bgDeviceDiv : this.diagramParent.querySelector("[name='nodesHolder']");
    let deviceHolder = parent.querySelector("[data-id='deviceHolder']");
    this.height = this.getHeight();
    let centerHolderParent = parent.querySelector("[data-id='deviceHolderParent']");
    if (!centerHolderParent) return;
    let imageHolder = centerHolderParent.querySelector("[data-id='contentimageparent']");
    let outerDiv = parent.querySelector("[data-id='outerDiv']");
    let isDevice = outerDiv && outerDiv.dataset.type == "device";
    if (isDevice && this.bgDeviceDiv) {
        centerHolderParent.style.width = this.bgDeviceDiv.clientWidth + "px";
        let additionalId = this.diagramParent.parentElement.getAttribute("data-element-id") || "";
        let clipPathNode = outerDiv.querySelector("clipPath[id='" + additionalId + this.nodeProps.centerShape.id + "-clip-path']");
        if (clipPathNode) DiagramResizeUtils.calcImageBounds(imageHolder, outerDiv, additionalId + this.nodeProps.centerShape.id);
    }
    if (isDevice) {
        outerDiv.firstElementChild.setAttribute("data-nodetype", "deviceSVG");
    }
    let finalWidth = centerHolderParent.clientWidth;

    if (imageHolder && finalWidth > 0) {
        let scale = DiagramResizeUtils.scaleToFit(finalWidth, (centerHolderParent.clientHeight * this.height) / 100, deviceHolder.getAttribute("original-width"), deviceHolder.getAttribute("original-height"), deviceHolder, this.bgDeviceDiv && !this.marginleft ? true : false, this.slideScale);
        imageHolder.setAttribute("data-scale", scale);
        parent.style.setProperty("--nodesMaxWidth", this.nodeProps.devicealignment && this.nodeProps.devicealignment == "left" ? "100%" : "calc(100% - " + centerHolderParent.clientWidth + "px)");
    }
    if (this.nodeProps.centerShape.type != "lottie" && !isDevice) this.setDimensionsForIllustrationNode(deviceHolder, centerHolderParent, parent, this.nodeProps.centerShape, { width: deviceHolder.clientWidth, height: deviceHolder.offsetHeight });
};

SimpleLinearDiagramDevice.prototype.createDeviceHolder = function (parentDiv, centerShape) {
    let centerHolderParent = document.createElement("div");
    centerHolderParent.setAttribute("data-id", "deviceHolderParent");
    centerHolderParent.className = "deviceHolderParent moodanimation";
    centerHolderParent.setAttribute("data-animation", "commonplaceholder");
    parentDiv.appendChild(centerHolderParent);
    parentDiv.style.setProperty("--devicemarginleft", this.marginleft ? this.marginleft : "0px");

    let deviceHolder = document.createElement("div");
    deviceHolder.setAttribute("data-id", "deviceHolder");
    deviceHolder.setAttribute("id", "deviceHolder");
    deviceHolder.className = "deviceHolder";
    centerHolderParent.appendChild(deviceHolder);

    this.diagramParent.setAttribute("data-center-shape-type", centerShape.type ? centerShape.type : "svg");
    if (centerShape.type == "lottie") {
        let height = centerShape.height ? centerShape.height + "px" : "600px";
        let width = centerShape.width ? centerShape.width + "px" : "600px";
        if (this.lottieAnimations) {
            this.clearLottieEvents();
        }

        try {
            this.lottieAnimations = lottie.loadAnimation({
                container: deviceHolder,
                renderer: "svg",
                loop: true,
                autoPlay: this.isWidget,
                path: DiagramUtils.checkAppStaticUrl(centerShape.value, this.appStaticURL),
            });
            this.lottieAnimations.addEventListener("data_ready", this.lottieAnimationComplete);
        } catch (error) {
            this.diagramRenderComplete();
            console.log(error);
        }

        deviceHolder.style.setProperty("width", width);
        centerHolderParent.style.setProperty("width", width);
        deviceHolder.style.setProperty("height", height);
        deviceHolder.setAttribute("original-width", width);
        deviceHolder.setAttribute("original-height", height);
        deviceHolder.setAttribute("lottie-type", true);
        if (this.nodeProps && this.nodeProps.assetGroupingId) deviceHolder.setAttribute("data-type", "lottie");
        deviceHolder.setAttribute("lottie-json-path", centerShape.value);
        DiagramResizeUtils.scaleToFit(width, height, width, height, deviceHolder, true);
        parentDiv.style.setProperty("--nodesMaxWidth", "calc(100% - " + width + ")");
    } else if (centerShape.type == "illustration") {
        let objAssets = this.centerholderdata?.content?.value && this.centerholderdata?.content?.value != "" && this.centerholderdata?.content?.value != "undefined" ? this.centerholderdata.content : { value: DiagramUtils.checkAppStaticUrl(centerShape.value, this.appStaticURL), id: centerShape.id };
        objAssets.value = DiagramUtils.checkAppStaticUrl(objAssets.value, this.appStaticURL);
        if (objAssets.type && objAssets.type == "image") {
            this.setDimensionsForIllustrationNode(deviceHolder, centerHolderParent, parentDiv, centerShape, { width: 400, height: 400 });
            this.changeImageNode(null, 0, objAssets.value);
            this.diagramRenderComplete();
        } else if ((objAssets.type && objAssets.type == "text") || objAssets.type == "number") {
            this.parseSvgForIllustration({ id: "placeholder", value: Constants.Value.placeholder_iconpath, data: Constants.Value.placeholdersvg }, deviceHolder, centerShape, centerHolderParent, parentDiv);
        } else
            DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body)
                .then((svgData) => {
                    this.parseSvgForIllustration(svgData, deviceHolder, centerShape, centerHolderParent, parentDiv);
                    this.needAssetUpdate(deviceHolder, centerShape, centerHolderParent, parentDiv, "illustration");
                })
                .catch((error) => {
                    console.log("Illustration asset load fail - " + error);
                    objAssets.id = "breaker_slide_2";
                    centerShape.id = "breaker_slide_2";
                    centerShape.value = Constants.Value.placeholder_illustrationpath;
                    objAssets.value = DiagramUtils.checkAppStaticUrl(Constants.Value.placeholder_illustrationpath, this.appStaticURL);
                    this.loadDefaultDeviceAsset(objAssets, deviceHolder, centerShape, centerHolderParent, parentDiv, this.parseSvgForIllustration.bind(this));
                });
    } else if (centerShape.type == "svg") {
        let diagramstyle = DiagramUtils.checkDiagramStyle(this.globalMoodData.basicgraphics, centerShape);
        let svgId = DiagramUtils.getSvgAssetId(centerShape, this.arrDiagramNode);
        let diagramStyleValue = DiagramUtils.checkAppStaticUrl(diagramstyle + svgId + ".svg", this.appStaticURL);
        let objAssets = { id: svgId, value: diagramStyleValue };
        DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body)
            .then((svgData) => {
                this.parseSvgforShape(svgData, deviceHolder, centerShape, centerHolderParent, parentDiv);
            })
            .catch((error) => {
                console.log("Svg asset load fail - " + error);
                objAssets.id = "breaker_slide_2";
                centerShape.id = "breaker_slide_2";
                centerShape.value = Constants.Value.placeholder_illustrationpath;
                objAssets.value = DiagramUtils.checkAppStaticUrl(Constants.Value.placeholder_illustrationpath, this.appStaticURL);
                this.loadDefaultDeviceAsset(objAssets, deviceHolder, centerShape, centerHolderParent, parentDiv, this.parseSvgforShape.bind(this));
            });
    } else {
        const objAssets = { value: centerShape.value, id: centerShape.id, type: "icon" };
        DiagramCreateUtil.updateManifest(objAssets, this.manifestUpdater, this.appStaticURL);
        objAssets.value = DiagramUtils.checkAppStaticUrl(centerShape.value, this.appStaticURL);
        DiagramAssetLoader.oneTimeDownload(objAssets, false, document.body)
            .then((svgData) => {
                this.parseSvgforDevice(svgData, deviceHolder, centerShape, centerHolderParent, parentDiv);
            })
            .catch((error) => {
                console.log("Device asset load fail - " + error);
                objAssets.id = "iphone";
                centerShape.id = "iphone";
                centerShape.value = Constants.Value.placeholder_devicepath;
                objAssets.value = DiagramUtils.checkAppStaticUrl(Constants.Value.placeholder_devicepath, this.appStaticURL);
                this.loadDefaultDeviceAsset(objAssets, deviceHolder, centerShape, centerHolderParent, parentDiv, this.parseSvgforDevice.bind(this));
            });
    }
};

SimpleLinearDiagramDevice.prototype.needAssetUpdate = function (deviceHolder, centerShape, centerHolderParent, parentDiv, type) {
    let title = this.diagramParent.parentElement.parentElement.parentElement.querySelector("[id='TITLE']");
    let assetText = title ? title.innerText : null;
    if (assetText && assetText != null && this.diagramData.properties.isfromai) {
        function parseSVGIllustration(svgData) {
            deviceHolder.innerHTML = "";
            this.parseSvgForIllustration(svgData, deviceHolder, centerShape, centerHolderParent, parentDiv, assetText);
        }
        if (assetText) {
            centerShape.needAssetUpdate = false;
            deviceHolder.setAttribute("data-node-graphic-text", assetText);
            DiagramUtils.searchAIcall("illustrations", centerShape, assetText, this.diagramData.properties, this.globalMoodData, deviceHolder, 0, parseSVGIllustration.bind(this), appBaseURL, this.appStaticURL);
        }
    }
};

SimpleLinearDiagramDevice.prototype.loadDefaultDeviceAsset = function (objAssets, deviceHolder, centerShape, centerHolderParent, parentDiv, callback) {
    deviceHolder.innerHTML = "";
    DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body)
        .then((svgData) => {
            callback?.(svgData, deviceHolder, centerShape, centerHolderParent, parentDiv);
            if (centerShape.type == "illustration") this.needAssetUpdate(deviceHolder, centerShape, centerHolderParent, parentDiv, "illustration");
        })
        .catch((error) => {
            console.log("Device asset load fail - 2 " + error);
            callback?.({ id: "placeholder", value: Constants.Value.placeholder_iconpath, data: Constants.Value.placeholdersvg }, deviceHolder, centerShape, centerHolderParent, parentDiv);
        });
};

SimpleLinearDiagramDevice.prototype.parseSvgForIllustration = function (svgData, deviceHolder, centerShape, centerHolderParent, parentDiv, assetText = null) {
    let svgNode = DiagramUtils.getSVGfromString(svgData.data);
    let dimensions = DiagramNodeUtils.getAssetDimensions(svgNode);
    svgNode.setAttribute("class", "illustrationNode accent1-fill");
    svgNode.setAttribute("data-id", "illustrationNode");
    svgNode.setAttribute("data-type", "illustration");
    svgNode.setAttribute("data-iconpath", svgData.value);
    svgNode.setAttribute("data-iconid", svgData.id);
    svgNode.setAttribute("id", svgData.id);
    if (assetText) svgNode.setAttribute("data-node-graphic-text", assetText);
    deviceHolder.appendChild(svgNode);
    this.setDimensionsForIllustrationNode(deviceHolder, centerHolderParent, parentDiv, centerShape, dimensions);
    this.diagramRenderComplete();
    // let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    // if (lastDiv) this.updatePropsCallBack(lastDiv.id);
    this.addFocus(this.arrDiagramNode.length - 1);
};

SimpleLinearDiagramDevice.prototype.parseSvgforShape = function (svgData, deviceHolder, centerShape, centerHolderParent, parentDiv) {
    let svgNode = DiagramUtils.getSVGfromString(svgData.data);
    let dimensions = DiagramNodeUtils.getAssetDimensions(svgNode);
    svgNode.setAttribute("class", "svgNode accent1-fill");
    svgNode.setAttribute("data-id", "svgNode");
    svgNode.setAttribute("data-type", "svg");
    svgNode.setAttribute("data-iconpath", svgData.value);
    svgNode.setAttribute("data-iconid", svgData.id);
    deviceHolder.appendChild(svgNode);
    DiagramNodeUtils.applyColorToNonLinearAssets(svgNode, svgData.id, this.arrTintArray);
    this.setDimensionsForIllustrationNode(deviceHolder, centerHolderParent, parentDiv, centerShape, dimensions);
    this.updateEmphasize();
    this.diagramRenderComplete();
    // let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    // if (lastDiv) this.updatePropsCallBack(lastDiv.id);
    this.addFocus(this.arrDiagramNode.length - 1);
};

SimpleLinearDiagramDevice.prototype.parseSvgforDevice = function (svgData, deviceHolder, centerShape, centerHolderParent, parentDiv) {
    let outerDiv = document.createElement("div");
    outerDiv.setAttribute("data-id", "outerDiv");
    outerDiv.setAttribute("data-type", "device");
    outerDiv.setAttribute("data-nodetype", "deviceHolder");
    outerDiv.className = "outerDiv";
    deviceHolder.appendChild(outerDiv);
    deviceHolder.classList.add("clsDevice");
    outerDiv.innerHTML = svgData.data;

    let imageHolderParent = this.createCenterHolder(deviceHolder);
    let imageHolder = imageHolderParent.querySelector("[id*='imageHolder']");
    imageHolder.setAttribute("data-focus-parent", "centerHolderParent");
    // imageHolder.setAttribute("data-animation", "item");
    imageHolder.setAttribute("id", "imageHolder" + DiagramNodeUtils.uuidv4());
    let scaleToFitType = this.bgDeviceDiv && !this.marginleft ? true : false;
    window.ismoodchange = false;
    this.diagramParent.style.setProperty("--nodesMaxWidth", "unset");
    let svgNode = DiagramUtils.getSVGfromString(svgData.data);
    let dimensions = DiagramNodeUtils.getAssetDimensions(svgNode);
    svgNode.setAttribute("data-nodetype", "deviceSVG");
    let width = dimensions.width;
    let height = dimensions.height;
    deviceHolder.style.setProperty("width", width + "px");
    deviceHolder.style.setProperty("height", height + "px");
    deviceHolder.setAttribute("original-width", width);
    deviceHolder.setAttribute("original-height", height);
    let additionalId = this.diagramParent.parentElement.getAttribute("data-element-id") || "";
    imageHolderParent.style.setProperty("clip-path", "url(#" + additionalId + centerShape.id + "-clip-path)");
    imageHolderParent.style.setProperty("-webkit-clip-path", "url(#" + additionalId + centerShape.id + "-clip-path)");
    imageHolderParent.style.setProperty("width", width + "px");
    imageHolderParent.style.setProperty("height", height + "px");

    let finalWidth = centerHolderParent.clientWidth;
    if (parseFloat(imageHolder.getAttribute("data-scale"))) {
        finalWidth = centerHolderParent.clientWidth * parseFloat(imageHolder.getAttribute("data-scale"));
    }
    let finalHeight = (centerHolderParent.clientHeight * this.height) / 100;

    let scale = DiagramResizeUtils.scaleToFit(finalWidth, finalHeight, width, height, deviceHolder, scaleToFitType, this.slideScale);
    imageHolder.setAttribute("data-scale", scale);
    let imgNode = imageHolder.querySelector("img[data-id='imageNode'],img[data-id='logoNode']");
    imgNode.setAttribute("data-focus-parent", "centerHolderParent");

    CommonImageUtils.updateImageBounds(imgNode, { islogofit: false, contenttype: "image" }, scale);
    this.diagramParent.style.setProperty("--nodesMaxWidth", this.nodeProps.devicealignment && this.nodeProps.devicealignment == "left" ? "100%" : "calc(100% - " + centerHolderParent.clientWidth + "px)");

    let clipPathNode = outerDiv.querySelector("clipPath[id='" + centerShape.id + "-clip-path']");
    if (!clipPathNode) return;
    DiagramResizeUtils.calcImageBounds(imageHolder, outerDiv, this.nodeProps.centerShape.id);
    clipPathNode.setAttribute("clipPathUnits", "objectBoundingBox");
    DiagramNodeUtils.applySvgClipPath(centerShape.id, deviceHolder, 0, deviceHolder, outerDiv.firstElementChild, this.diagramParent.parentElement.getAttribute("data-element-id"));
    // this.resetNodeAttributes();
    this.diagramRenderComplete();
    // let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    // if (lastDiv) this.updatePropsCallBack(lastDiv.id);
    this.addFocus(this.arrDiagramNode.length - 1);
};

SimpleLinearDiagramDevice.prototype.setDimensionsForIllustrationNode = function (deviceHolder, centerHolderParent, parentDiv, centerShape, dimensions) {
    let height = this.height ? this.height + "%" : dimensions.height + "px";
    let width = centerShape.width ? centerShape.width + "%" : (dimensions.width < this.diagramParent.clientWidth * 0.4 ? dimensions.width : this.diagramParent.clientWidth * 0.4) + "px";
    if (this.nodeProps.devicealignment && this.nodeProps.devicealignment == "left" && !centerShape.width) width = "100%";
    if (centerShape.type && centerShape.type == "illustration" && parseInt(width) < 460) width = "460px";
    deviceHolder.style.setProperty("height", height);
    deviceHolder.setAttribute("original-width", width);
    deviceHolder.setAttribute("original-height", height);
    centerHolderParent.style.setProperty("width", width);
    parentDiv.style.setProperty("--nodesMaxWidth", this.nodeProps.devicealignment && this.nodeProps.devicealignment == "left" ? "100%" : "calc(100% - " + centerHolderParent.clientWidth + "px)");
};

SimpleLinearDiagramDevice.prototype.changeImageNode = function (strImageCropID, index, imageURL, completeCallback) {
    let deviceHolder = (this.bgDeviceDiv ? this.bgDeviceDiv : this.diagramParent).querySelector("[data-id='deviceHolder']");
    deviceHolder.innerHTML = "";
    this.centerholderdata = { content: { value: imageURL, contenttype: "image", type: "image" } };
    let imageHolderParent = this.createCenterHolder(deviceHolder, { value: imageURL, contenttype: "image", type: "image" });
    let imageHolder = imageHolderParent.querySelector("[id*='imageHolder']");
    imageHolder.setAttribute("data-focus-parent", "centerHolderParent");
    let imgNode = imageHolder.querySelector("img[data-id='imageNode'],img[data-id='logoNode']");
    CommonImageUtils.updateImageBounds(imgNode, { islogofit: false, contenttype: "image" }, 1, completeCallback);
};

SimpleLinearDiagramDevice.prototype.changeAsset = function (obj) {
    let pattenDiv = this.bgDeviceDiv ? this.bgDeviceDiv : this.diagramParent.querySelector("[name='nodesHolder']");
    let deviceHolder = pattenDiv.querySelector("[data-id='deviceHolderParent']");
    deviceHolder.remove();
    this.nodeProps.centerShape.value = obj.value;
    this.nodeProps.centerShape.assetGroupingId = this.nodeProps.assetGroupingId;
    this.diagramData.properties.assetCenterShape = this.nodeProps.centerShape;
    this.updateProperties(this.diagramData.properties);
    this.createDeviceHolder(pattenDiv, this.nodeProps.centerShape);
};

SimpleLinearDiagramDevice.prototype.diagramRenderComplete = function () {
    this.diagramParent.style.opacity = 1;
    this.resetLayout();
    this.updateEvents();
    let arrNodes = this.diagramParent.querySelectorAll("[name='nodeMainParent']");
    arrNodes.forEach((element) => {
        if (element.dataset.columntype) {
            if (element.dataset.columntype == "start") {
                if (arrNodes.length < 4) {
                    element.setAttribute("data-nodealign", "left");
                } else {
                    element.setAttribute("data-nodealign", "right");
                }
            } else {
                element.setAttribute("data-nodealign", "left");
            }
        }
    });
    if (this.completeCallBack && this.completeCallBack.func) {
        this.completeCallBack.func(this.completeCallBack?.params);
        this.completeCallBack = null;
        // console.log("diagramRenderComplete callback..", this.completeCallBack?.params);
    }
};

SimpleLinearDiagramDevice.prototype.addNode = function (nodeData, index) {
    let lastNode = this.arrDiagramNode[this.arrDiagramNode.length - 1];
    if (lastNode && lastNode.seperator) lastNode.connectorNode = lastNode.createConnectorParent(lastNode.parentNode.parentElement, lastNode.objData.content);
    if (this.diagramData.nodes.length > index) {
        this.diagramData.nodes.splice(index, 0, nodeData);
    } else {
        this.diagramData.nodes.push(nodeData);
    }
    this.initDiagramCreation();
    this.updateEvents();
    this.updateNodesHolderClass(this.diagramData.nodes.length);
    this.resetHolderWidth();
};

SimpleLinearDiagramDevice.prototype.updateNodesHolderClass = function (nodeCount) {
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    nodesHolder.setAttribute("data-node", nodeCount + "nodes");
};

SimpleLinearDiagramDevice.prototype.deleteNode = function (targetIndex) {
    if (this.arrDiagramNode.length > targetIndex) {
        this.arrDiagramNode.splice(targetIndex, 1);
        let nodeDelete = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + targetIndex + "']");
        if (nodeDelete && nodeDelete.parentElement) {
            nodeDelete.parentElement.remove();
        }
    }
    if (this.diagramData.nodes.length > targetIndex) {
        this.diagramData.nodes.splice(targetIndex, 1);
    }
    this.initDiagramCreation();
    this.updateEvents();
    this.updateNodesHolderClass(this.diagramData.nodes.length);
    this.recalculateheight();
};

SimpleLinearDiagramDevice.prototype.resetHolderWidth = function () {
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    nodesHolder.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    nodesHolder.style.setProperty("--nodeGap", this.nodeGap + "px");
    nodesHolder.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    nodesHolder.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    nodesHolder.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    nodesHolder.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");
    this.recalculateheight();
};

SimpleLinearDiagramDevice.prototype.diagramPasteHandler = function (event) {
    LinearDiagram.prototype.diagramPasteHandler.call(this, event);
};

SimpleLinearDiagramDevice.prototype.defaultFoucsOut = function (event) {
    LinearDiagram.prototype.defaultFoucsOut.call(this, event);
    this.recalculateheight();
};

SimpleLinearDiagramDevice.prototype.clear = function (event) {
    LinearDiagram.prototype.clear.call(this, event);
    if (this.isTempSlide) return;
    if (this.lottieAnimations) {
        this.clearLottieEvents();
    }
    this.lottieAnimations = null;
};

SimpleLinearDiagramDevice.prototype.clearLottieEvents = function () {
    this.lottieAnimations.removeEventListener("data_ready", this.lottieAnimationReady);
    this.lottieAnimations.removeEventListener("data_ready", this.lottieAnimationComplete);
    this.lottieAnimations.stop();
    this.lottieAnimations.destroy();
};

SimpleLinearDiagramDevice.prototype.setHighlightPosition = function (node, parent) {
    let nodeParent = node.parentElement;
    let element = nodeParent.querySelector("[data-id='diagramContentNode']");
    if (!element || element.clientWidth == 0) element = node;
    return { element: element, alignment: "auto" };
};

//Emphasize

SimpleLinearDiagramDevice.prototype.emphasize = function (emphasizeData) {
    LinearDiagram.prototype.emphasize.call(this, emphasizeData);
    this.updateNonLinearEmphasize();
};

SimpleLinearDiagramDevice.prototype.updateEmphasize = function () {
    LinearDiagram.prototype.updateEmphasize.call(this);
    this.updateNonLinearEmphasize();
};

SimpleLinearDiagramDevice.prototype.updateNonLinearEmphasize = function () {
    let centerNode = this.diagramParent.querySelector("[data-id='deviceHolderParent']");
    if (!centerNode) return;
    let arrPath = Array.from(centerNode.querySelectorAll("g[id*='-point']"));
    this.arrDiagramNode.map(
        function (node, i) {
            let nodeParent = node.parentNode.parentElement;
            let path = arrPath.find((grp) => grp.id.endsWith(i + 1));
            if (path) {
                let nodeBGColorOptions = this.nodeProps.bgColor ? this.nodeProps.bgColor.split(",") : [];
                let hasBG = nodeBGColorOptions.length > 1;
                let baseEmphasisClass = this.nodeProps.emphasisClass ? this.nodeProps.emphasisClass : "clsEmphasis";
                let emphasizeDisableClass = hasBG ? baseEmphasisClass + "DisabledBG" : baseEmphasisClass + "Disabled";
                let emphasizeEnableClass = hasBG ? baseEmphasisClass + "EnabledBG" : baseEmphasisClass + "Enabled";
                if (nodeParent && path && nodeParent.classList.contains(emphasizeEnableClass)) {
                    path.classList.remove(emphasizeDisableClass);
                    path.classList.add(emphasizeEnableClass);
                } else if (path && nodeParent.classList.contains(emphasizeDisableClass)) {
                    path.classList.remove(emphasizeEnableClass);
                    path.classList.add(emphasizeDisableClass);
                } else {
                    path.classList.remove("clsEmphasisEnabledBG");
                    path.classList.remove("clsEmphasisEnabled");
                    path.classList.remove("clsEmphasisDisabledBG");
                    path.classList.remove("clsEmphasisDisabled");
                }
            }
        }.bind(this)
    );
};

/**
 * Author:    Krishna prabhu.
 * Created:   9.5.2022
 *
 **/

"use strict";

function CircularDeviceDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearDiagramDevice.call(this, diagramParent, diagramData, nodeProps, moodData);
    diagramParent.className = "clsCircularDevice";
    this.arrowColor = "var(--circular-stroke-color)"
}

CircularDeviceDiagram.prototype = Object.create(SimpleLinearDiagramDevice.prototype);
CircularDeviceDiagram.prototype.constructor = CircularDeviceDiagram;

CircularDeviceDiagram.prototype.contentChange = function (operation) {
    SimpleLinearDiagramDevice.prototype.contentChange.call(this, operation);
    this.updataNodePosition();
};

CircularDeviceDiagram.prototype.recalculateheight = function () {
    SimpleLinearDiagramDevice.prototype.recalculateheight.call(this);
    this.updataNodePosition();
};

CircularDeviceDiagram.prototype.updataNodePosition = function () {
    this.widthRadius = (this.diagramParent.clientHeight / 2) - 10;
    this.heightRadius = (this.diagramParent.clientHeight / 2) - 10;
    this.centerX = this.diagramParent.clientWidth / 2;
    this.centerY = this.diagramParent.clientHeight / 2;
    let circleSvg = this.diagramParent.querySelector("[id='circularbase']");
    if (!circleSvg) {
        let circleSvg = DiagramNodeUtils.createSVGElement("svg");
        DiagramNodeUtils.assignSVGNodeAttributes(circleSvg, { class: "circle-svg" });
        DiagramNodeUtils.assignSVGNodeAttributes(circleSvg, { width: this.diagramParent.clientWidth, height: this.diagramParent.clientHeight });
        circleSvg.id = "circularbase";
        let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
        nodeHolder.appendChild(circleSvg);
    }
    // this.drawSvgArc(circleSvg);
    this.drawArcPath(circleSvg);
    this.updateTextNodes();
};

CircularDeviceDiagram.prototype.drawSvgArc = function (svg) {
    if (!svg) return;
    var ellipse = svg.firstElementChild;
    if (!ellipse) {
        ellipse = DiagramNodeUtils.createSVGElement("ellipse");
        svg.appendChild(ellipse);
    }

    DiagramNodeUtils.assignSVGNodeAttributes(ellipse, {
        cx: this.diagramParent.clientWidth / 2,
        cy: this.diagramParent.clientHeight / 2,
        rx: (this.diagramParent.clientHeight / 2) - 10,
        ry: (this.diagramParent.clientHeight / 2) - 10,
        stroke: this.arrowColor,
        fill: "none",
        'stroke-width': "var(--seperator-width)",
        class: "svg-ellipse"
    });

    this.alignNodes(ellipse);
};

CircularDeviceDiagram.prototype.alignNodes = function (ellipse) {
    let angleGap = 360 / this.arrDiagramNode.length;
    this.arrDiagramNode.forEach((node, i) => {
        let x = (ellipse.rx.baseVal.value * Math.cos(i * angleGap)) + ellipse.cx.baseVal.value;
        let y = (ellipse.ry.baseVal.value * Math.sin(i * angleGap)) + ellipse.cy.baseVal.value;
        let parent = node.parentNode.parentElement;
        parent.style.left = x - (parent.clientWidth / 2) + "px";
        parent.style.top = y - (parent.clientHeight / 2) + "px";
    });
};

CircularDeviceDiagram.prototype.drawArcPath = function (svg) {
    if (!svg) return;
    var path = svg.querySelector('path');
    if (!path) {
        path = DiagramNodeUtils.createSVGElement("path");
        svg.appendChild(path);
    }

    let arrNodeStructure = this.getArrNodeStructure("full");

    DiagramNodeUtils.assignSVGNodeAttributes(path, {
        d: this.circlePathWithAngle(
            this.centerX,
            this.centerY,
            this.widthRadius,
            this.heightRadius,
            90,
            arrNodeStructure.length == 2
        ),
        stroke: this.arrowColor,
        fill: "none",
        'stroke-width': "4px",
        class: "moodanimation",
        "data-animation": "commonplaceholder"
    });

    // this.alignNodesInEllipse(path);
    this.alignNodesInHalfEllipse(path, arrNodeStructure);
};

CircularDeviceDiagram.prototype.alignNodesInEllipse = function (path) {
    let deviceHolder = this.centerHolderNode?.parentNode.parentElement;
    // if (!deviceHolder) return;
    let offsetLength = deviceHolder.clientWidth;
    let totalLength = path.getTotalLength();
    let availableLength = totalLength - offsetLength;

    let arrNodeStructure = this.getArrNodeStructure("mixed");
    arrNodeStructure.forEach((arrNodes, i) => {
        let gap = (availableLength / 2) / (arrNodes.length + 1);
        arrNodes.forEach((num, j) => {
            let length = (gap * (j + 1)) + (offsetLength / 4);
            length = i > 0 ? (totalLength / 2) + length : length;
            let point = path.getPointAtLength(length);
            let node = this.arrDiagramNode.at(num - 1);
            let parent = node.parentNode.parentElement;
            parent.setAttribute("data-circular-align", i > 0 ? "left" : "right");
            let contentNode = parent.querySelector("[name='contentNode']");
            if (contentNode) {
                parent.style.left = point.x + "px";
                parent.style.top = point.y + "px";
                let contentRect = DiagramNodeUtils.getOffsetRectByParent(parent, contentNode);
                parent.style.left = point.x - contentRect.x - (contentRect.width / 2) + "px";
                parent.style.top = point.y - contentRect.y - (contentRect.height / 2) + "px";
            } else {
                parent.style.left = point.x - (parent.clientWidth / 2) + "px";
                parent.style.top = point.y - (parent.clientHeight / 2) + "px";
            }
            return
        })
    })
};

CircularDeviceDiagram.prototype.alignNodesInHalfEllipse = function (path, arrNodeStructure) {
    let isHalfPath = arrNodeStructure.length == 1;
    let deviceHolder = this.centerHolderNode?.parentNode.parentElement;
    // if (!deviceHolder) return;
    let offsetLength = deviceHolder.clientWidth / (isHalfPath ? 2 : 1);
    let totalLength = path.getTotalLength();
    let availableLength = totalLength - offsetLength;

    arrNodeStructure.forEach((arrNodes, i) => {
        let gap = (availableLength / (isHalfPath ? 1 : 2)) / (arrNodes.length + 1);
        arrNodes.forEach((num, j) => {
            let length = (gap * (j + 1)) + (offsetLength / (isHalfPath ? 2 : 4));
            length = i > 0 ? (totalLength / 2) + length : length;
            let point = path.getPointAtLength(length);
            point.x = parseInt(point.x);
            point.y = parseInt(point.y);
            let node = this.arrDiagramNode.at(num - 1);
            let nodeParent = node.parentNode.parentElement;
            nodeParent.setAttribute("data-circular-align", i > 0 ? "left" : "right");
            nodeParent.style.maxHeight = (this.diagramParent.clientHeight*getHeightRatio(this.arrDiagramNode.length)) + "px";
            nodeParent.style.height =  nodeParent.style.maxHeight;
            nodeParent.style.setProperty("height", nodeParent.style.maxHeight, "important");

            setClass(nodeParent, i > 0);
            let contentNode = nodeParent.querySelector("[name='contentNode']");
            setWidth(nodeParent, this.diagramParent, contentNode, point, i > 0);
            if (contentNode) {
                nodeParent.style.left = point.x + "px";
                nodeParent.style.top = point.y + "px";
                let contentRect = DiagramNodeUtils.getOffsetRectByParent(nodeParent, contentNode);
                nodeParent.style.left = point.x - contentRect.x - (contentRect.width / 2) + "px";
                nodeParent.style.top = point.y - contentRect.y - (contentRect.height / 2) + "px";
            } else {
                nodeParent.style.left = point.x - (nodeParent.clientWidth / 2) + "px";
                nodeParent.style.top = point.y - (nodeParent.clientHeight / 2) + "px";
            }

            let angle = Math.atan2(this.centerX - point.x, this.centerY - point.y) * (180 / Math.PI) + 90;
            angle = angle < 0 ? 360 + angle : angle;
            nodeParent.setAttribute("data-angle", angle.toFixed(2));
        })
    })

    function setClass(parent, isLeftAlign) {
        parent.classList.remove("clsCircleDeviceNodeLeftAlign");
        parent.classList.remove("clsCircleDeviceNodeRightAlign");
        parent.classList.add(!isLeftAlign ? "clsCircleDeviceNodeLeftAlign" : "clsCircleDeviceNodeRightAlign");
    }

    function setWidth(node, parent, contentNode, point, isLeftAlign) {
        if (!isLeftAlign)
            node.style.width = parent.clientWidth - point.x + (contentNode.clientWidth / 2) + "px";
        else
            node.style.width = point.x + (contentNode.clientWidth / 2) + "px";
    }

    function getHeightRatio(count) {
        switch(count){
            case 2: return 0.6;
            case 3: return 0.3;
            case 4: return 0.3;
            case 5: return 0.25;
            case 6: return 0.25;
            case 7: return 0.18;
            case 8: return 0.18;
            default: return 0.2;
        }
    }
};

CircularDeviceDiagram.prototype.circlePathWithAngle = function (cx, cy, rx, ry, deg = 0, isFullPath = true) {
    var theta = (deg * Math.PI) / 180,
        dx = rx * Math.cos(theta),
        dy = -ry * Math.sin(theta);
    let firstHalf = "M " + cx + " " + cy + "m " + dx + "," + dy + "a " + rx + "," + ry + " 0 1,1 " + -2 * dx + "," + -2 * dy;
    let secondHalf = "a " + rx + "," + ry + " 0 1,1 " + 2 * dx + "," + 2 * dy;
    return isFullPath ? firstHalf + secondHalf : firstHalf;
};

CircularDeviceDiagram.prototype.getArrNodeStructure = function (type) {
    switch (type) {
        case "mixed":
            switch (this.arrDiagramNode.length) {
                case 2: return [[1, 2]]
                case 3: return [[1, 2, 3]]
                case 4: return [[1, 2, 3, 4]]
                case 5: return [[1, 2, 3], [4, 5]]
                case 6: return [[1, 2, 3], [4, 5, 6]]
                case 7: return [[1, 2, 3, 4], [5, 6, 7]]
                case 8: return [[1, 2, 3, 4], [5, 6, 7, 8]]
            }
        case "full":
            switch (this.arrDiagramNode.length) {
                case 2: return [[1], [2]]
                case 3: return [[1], [2, 3]]
                case 4: return [[1, 2], [3, 4]]
                case 5: return [[1, 2, 3], [4, 5]]
                case 6: return [[1, 2, 3], [4, 5, 6]]
                case 7: return [[1, 2, 3, 4], [5, 6, 7]]
                case 8: return [[1, 2, 3, 4], [5, 6, 7, 8]]
            }
    }
};

CircularDeviceDiagram.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    SimpleLinearDiagramDevice.prototype.setupInLineFloaterOption?.call(this);
    delete dict.textalign;
};

CircularDeviceDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearDiagramDevice.prototype.updateFloaterSettings.call(this, mainProperties);
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable.push("connector");
        mainProperties.floateroptionsdisable.push("imagesize");
        mainProperties.floateroptionsdisable.push("arrange");
    } else mainProperties.floateroptionsdisable = ["connector", "imagesize", "arrange"];
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};
/**
 * Author:    Bala Krishnan K.
 * Created:   30.10.2020
 *
 **/

"use strict";

function SimpleNonLinearDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    diagramParent.setAttribute("data-diagramtype", "vertical");
    this.isCenterShapeLoaded = false;
}

SimpleNonLinearDiagram.prototype = Object.create(SimpleLinearDiagram.prototype);
SimpleNonLinearDiagram.prototype.constructor = SimpleNonLinearDiagram;

SimpleNonLinearDiagram.prototype.initDiagramCreation = function () {
    if (!this.diagramParent.dataset.contenttype) {
        this.diagramParent.setAttribute("data-contenttype", this.diagramData.properties.contenttype);
        this.setHolderType(this.diagramData.properties.contenttype, "contentNode");
    }
    // this.diagramParent.style.removeProperty("--originalresizewidth");
    // this.diagramParent.style.removeProperty("--originalresizeheight");
    this.diagramParent.setAttribute("data-notloaded", "true");
    this.diagramParent.style.opacity = 0;
    this.diagramParent.innerHTML = "";
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.createPatternBackGround();
};

SimpleNonLinearDiagram.prototype.createPatternBackGround = function () {
    this.createElements();
};

SimpleNonLinearDiagram.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsNodesHolderSvg";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    pattenDiv.setAttribute("data-node", nodeCount + "nodes");
    this.diagramParent.appendChild(pattenDiv);
    this.diagramParent.setAttribute("data-parenttype", "nonlinear");
    // this.diagramParent.setAttribute("data-togglelists", "true");
    let contentSize = (pattenDiv.offsetHeight - (nodeCount - 1) * this.nodeGap) / nodeCount;
    this.height = this.nodeProps.centerShape.height || 100;
    this.marginleft = this.nodeProps.centerShape.marginleft || null;
    this.basealign = (this.nodeProps.centerShape.position && this.nodeProps.centerShape.position.split(",")[0]) || "horizontal";
    this.subtype = (this.nodeProps.centerShape.position && this.nodeProps.centerShape.position.split(",")[1]) || "process";
    this.svgalign = (this.nodeProps.centerShape.position && this.nodeProps.centerShape.position.split(",")[2]) || "center";
    this.diagramParent.setAttribute("data-subtype", this.subtype);
    this.diagramParent.setAttribute("data-basealign", this.basealign);
    if (this.subtype == "process" || this.subtype == "convergediverge") this.diagramParent.setAttribute("data-nodealign", this.svgalign);
    else this.diagramParent.setAttribute("data-svgalign", this.svgalign);
    this.diagramParent.setAttribute("data-nonlinearcontentoptions", "true");

    pattenDiv.style.setProperty("--nodeWidth", "auto");
    pattenDiv.style.setProperty("--contentNodeWidth", "48px");
    pattenDiv.style.setProperty("--contentNodeHeight", "48px");
    pattenDiv.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    pattenDiv.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    pattenDiv.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    pattenDiv.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    pattenDiv.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");

    let circleWidth = (contentSize / 100) * 50;
    pattenDiv.style.setProperty("--circleSize", circleWidth + "px");

    this.checkCenterNodeStyle();

    this.createNodeInstances(nodeCount, pattenDiv);

    if (this.diagramData.properties.assetCenterShape?.assetGroupingId && JSON.stringify(this.diagramData.properties.assetCenterShape?.assetGroupingId) == JSON.stringify(this.nodeProps.assetGroupingId || [])) {
        this.nodeProps.centerShape = this.diagramData.properties.assetCenterShape;
        this.updateNodeProperties();
    }

    this.createDeviceHolder(pattenDiv, this.nodeProps.centerShape);
};

SimpleNonLinearDiagram.prototype.createCenterHolder = function (pattenDiv, contentrect = null) {
    let centerItem = new window[this.nodeProps?.centerNode && this.nodeProps.centerNode.length > 1 ? "CommonDiagramNode" : this.nodeProps.nodeclassName](
        pattenDiv,
        {},
        this.centerholderdata ? this.centerholderdata : { content: {} },
        this.eventManagerXY,
        0,
        "",
        this.objStyleData,
        this.appStaticURL,
        this.nodeProps,
        this.diagramParent
    );
    centerItem.moodData = this.moodData;
    centerItem.moodName = this.moodName;
    centerItem.updateCallBack = this.updateCallBack;
    centerItem.searchIconCallBack = this.searchIconCallBack;
    centerItem.bgDeviceDiv = this.bgDeviceDiv;
    centerItem.arrDefaults = this.arrDefaults;
    centerItem.globalMoodData = this.globalMoodData;
    centerItem.arrTintArray = this.arrTintArray;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;
    this.centerHolderNode = centerItem;
    // let centerNode = centerItem.createCenterNode(pattenDiv);
    let centerNode = null;
    if (contentrect && !contentrect.contenttype)
        centerNode = this.createCenterImageNode(
            contentrect,
            this.centerholderdata && this.centerholderdata.content && this.centerholderdata.content.type && this.centerholderdata.content.type == "image" && this.centerholderdata.content.value ? this.centerholderdata.content.value : this.appStaticURL + "genericassets/placeholderimages/placeholder.png"
        );
    else centerNode = centerItem.createCenterNode(pattenDiv);
    this.centerHolderNode.nodeGroup = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    // this.updatePropsCallBack();
    return centerNode;
};

SimpleNonLinearDiagram.prototype.recreateElementData = function (contentData = { id: "", value: "", contenttype: "image" }) {
    SimpleLinearDiagram.prototype.recreateElementData.call(this);
    let pattenDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    let centerItem = new window[this.nodeProps.nodeclassName](pattenDiv, {}, this.centerholderdata ? this.centerholderdata : { content: {} }, this.eventManagerXY, 0, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
    this.height = this.nodeProps.centerShape.height || 100;
    this.basealign = (this.nodeProps.centerShape.position && this.nodeProps.centerShape.position.split(",")[0]) || "horizontal";
    this.subtype = (this.nodeProps.centerShape.position && this.nodeProps.centerShape.position.split(",")[1]) || "process";
    this.svgalign = (this.nodeProps.centerShape.position && this.nodeProps.centerShape.position.split(",")[2]) || "center";
    let outerDiv = pattenDiv.querySelector("[data-id='outerDiv']");
    if (outerDiv) outerDiv.setAttribute("data-type", "device");
    centerItem.moodData = this.moodData;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;
    this.centerHolderNode = centerItem;
    this.centerHolderNode.parentNode = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    this.centerHolderNode.nodeGroup = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    this.centerNode = this.diagramParent.querySelector("div[data-id='deviceHolderParent']");
    this.centerholderdata = this.getCenterHolderData();
    this.addImageContrastColor(this.diagramParent, this.nodeProps.centerShape);
    this.isCenterShapeLoaded = true;
};

SimpleNonLinearDiagram.prototype.updateElements = function () {
    SimpleLinearDiagram.prototype.updateElements.call(this);
    if (this.appmode.toLowerCase() != "present") {
        // this.getCenterHolderData();
        // this.slideDimensionChange();
    }
};

SimpleNonLinearDiagram.prototype.addImageContrastColor = function (diagramParent, centerShape) {
    // if (centerShape?.color && !diagramParent.className.includes(centerShape?.color)) diagramParent.classList.add(centerShape.color);
};

SimpleNonLinearDiagram.prototype.changeAsset = function (obj) {
    let pattenDiv = this.bgDeviceDiv ? this.bgDeviceDiv : this.diagramParent.querySelector("[name='nodesHolder']");
    let deviceHolder = pattenDiv.querySelector("[data-id='deviceHolderParent']");
    deviceHolder.remove();
    if (obj.type && obj.type == "image-svg") {
        this.nodeProps.centerShape.imageUrl = obj.value;
        if (obj.id) this.nodeProps.centerShape.color = obj.id;
    } else {
        this.nodeProps.centerShape.id = obj.id;
        this.nodeProps.centerShape.value = obj.value;
    }
    if (this.nodeProps.assetGroupingId && !(this.nodeProps.assetGroupingId instanceof Array)) {
        this.nodeProps.assetGroupingId = [this.nodeProps.assetGroupingId];
    }
    this.nodeProps.centerShape.assetGroupingId = this.nodeProps.assetGroupingId;
    this.diagramData.properties.assetCenterShape = this.nodeProps.centerShape;
    this.nodeProps.stockImageChange = false;
    this.nodeProps.centerShape.needAssetUpdate = false;
    this.updateProperties(this.diagramData.properties);
    this.createDeviceHolder(pattenDiv, this.nodeProps.centerShape);
    // this.updateColorCallBack(obj);
};

SimpleNonLinearDiagram.prototype.showHideOptions = function (value) {
    let contentVisible = value != "none" && value != "sequence";
    let numberVisible = value == "sequence";
    this.diagramParent.parentElement.style.setProperty("--contentdisplay", contentVisible ? "flex" : "none");
    this.diagramParent.setAttribute("data-content", contentVisible);
    this.diagramParent.setAttribute("data-nonlinearcontent", value);
    this.diagramParent.setAttribute("data-contenttype", value);
    this.diagramData.properties.nonlinearcontent = value;
    this.diagramData.properties.diagramcontent = contentVisible;
    this.diagramData.properties.contenttype = value;
    this.diagramParent.parentElement.style.setProperty("--numberdisplay", numberVisible ? "flex" : "none");
    this.diagramData.properties.sequencetext = numberVisible;
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "sequence", this.diagramData.properties.sequencetext, true);
    this.updateProperties(this.diagramData.properties);
    this.slideDimensionChange();
    this.updateTextNodes();
};

SimpleNonLinearDiagram.prototype.checkItemVisiblily = function () {
    SimpleLinearDiagram.prototype.checkItemVisiblily.call(this);
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "sequence", this.diagramData.properties.sequencetext, true);
};

SimpleNonLinearDiagram.prototype.setNonlinearContentType = function () {
    this.diagramParent.setAttribute("data-nonlinearcontent", this.diagramData.properties.contenttype);
    this.diagramData.properties.nonlinearcontent = this.diagramData.properties.contenttype;
};

SimpleNonLinearDiagram.prototype.showHideContent = function () {
    let diagramParentStyle = getComputedStyle(this.diagramParent.parentElement);
    let contentPreviousState = diagramParentStyle.getPropertyValue("--contentdisplay").trim();
    let contentVisible = contentPreviousState == "flex";
    this.diagramParent.parentElement.style.setProperty("--contentdisplay", contentVisible ? "none" : "flex");
    this.diagramParent.setAttribute("data-content", !contentVisible);
    this.diagramData.properties.diagramcontent = !contentVisible;
    let numberCurrentState = diagramParentStyle.getPropertyValue("--numberdisplay").trim();
    if (contentVisible == false && numberCurrentState == "flex") {
        let numberVisible = true;
        this.diagramParent.parentElement.style.setProperty("--numberdisplay", numberVisible ? "none" : "flex");
        this.diagramData.properties.sequencetext = !numberVisible;
    }
    this.updateProperties(this.diagramData.properties);
    this.slideDimensionChange();
    this.updateTextNodes();
};

SimpleNonLinearDiagram.prototype.showHideNumber = function () {
    let diagramParentStyle = getComputedStyle(this.diagramParent.parentElement);
    let numberPreviousState = diagramParentStyle.getPropertyValue("--numberdisplay").trim();
    let numberVisible = numberPreviousState == "flex";
    this.diagramParent.parentElement.style.setProperty("--numberdisplay", numberVisible ? "none" : "flex");
    this.diagramData.properties.sequencetext = !numberVisible;
    let contentCurrentState = diagramParentStyle.getPropertyValue("--contentdisplay").trim();
    if (numberVisible == false && contentCurrentState == "flex") {
        let contentVisible = true;
        this.diagramParent.parentElement.style.setProperty("--contentdisplay", contentVisible ? "none" : "flex");
        this.diagramParent.setAttribute("data-content", !contentVisible);
        this.diagramData.properties.diagramcontent = !contentVisible;
    }
    DiagramUtils.setEnableDisableClassNames(this.diagramParent, "sequence", this.diagramData.properties.sequencetext, true);
    this.updateProperties(this.diagramData.properties);
    this.slideDimensionChange();
    this.updateTextNodes();
};

SimpleNonLinearDiagram.prototype.getCenterHolderData = function () {
    try {
        let parent = this.diagramParent.querySelector("[data-id='centerHolderParent']");
        if (parent) {
            this.centerholderdata = this.centerHolderNode?.getJSONData?.();
            this.centerHolderNode.objData = this.centerholderdata;
        }
    } catch (error) {
        console.log(error);
    }
    return this.centerholderdata || {};
};

SimpleNonLinearDiagram.prototype.slideDimensionChange = function () {
    let svgNode = this.diagramParent.querySelector("[data-id='svgNode']");
    let parentDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    let deviceHolder = this.diagramParent.querySelector("[data-id='deviceHolder']");
    if (svgNode && svgNode.firstElementChild) this.setDimensionsForNodes(deviceHolder, svgNode, parentDiv, this.nodeProps.centerShape, false);
};

SimpleNonLinearDiagram.prototype.createDeviceHolder = function (parentDiv, centerShape) {
    let centerHolderParent = document.createElement("div");
    centerHolderParent.setAttribute("data-id", "deviceHolderParent");
    centerHolderParent.className = "deviceHolderParent";
    parentDiv.appendChild(centerHolderParent);
    this.addImageContrastColor(parentDiv.parentElement, centerShape);
    let deviceHolder = document.createElement("div");
    deviceHolder.setAttribute("data-id", "deviceHolder");
    deviceHolder.setAttribute("id", "deviceHolder");
    deviceHolder.setAttribute("name", "deviceHolder");
    deviceHolder.className = "deviceHolder";
    // deviceHolder.setAttribute("data-animation", "commonplaceholder");
    centerHolderParent.appendChild(deviceHolder);
    if (this.nodeProps && this.nodeProps.assetGroupingId) deviceHolder.setAttribute("data-type", "svg");

    this.diagramParent.setAttribute("data-center-shape-type", centerShape.type ? centerShape.type : "svg");
    let diagramstyle = DiagramUtils.checkDiagramStyle(this.globalMoodData.basicgraphics, centerShape);
    let svgId = DiagramUtils.getSvgAssetId(centerShape, this.arrDiagramNode);
    let diagramStyleValue = DiagramUtils.checkAppStaticUrl(diagramstyle + svgId + ".svg", this.appStaticURL);
    let objAssets = { id: svgId, value: diagramStyleValue };
    // this.updateJSONData();
    // this.isCenterShapeLoaded = true;
    // this.diagramRenderComplete();

    DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body)
        .then((svgData) => {
            this.diagramParent.removeAttribute("data-notloaded");
            // this.updateJSONData();
            // console.log(arrDiagramNodesLocal[0].objData.content)
            try {
                this.parseSvgData(svgData, centerShape, diagramStyleValue, deviceHolder, parentDiv);
            } catch (error) {
                this.parseSvgData(null, centerShape, diagramStyleValue, deviceHolder, parentDiv);
                console.log("Render fail - " + error);
                this.diagramParent.style.opacity = 1;
                this.isCenterShapeLoaded = true;
                this.diagramRenderComplete();
            }
        })
        .catch((error) => {
            this.diagramParent.removeAttribute("data-notloaded");
            this.parseSvgData(null, centerShape, diagramStyleValue, deviceHolder, parentDiv);
            console.log("SVG asset load fail - " + error);
            this.diagramParent.style.opacity = 1;
            this.isCenterShapeLoaded = true;
            this.diagramRenderComplete();
        });
};

// Parse svg from data and render
SimpleNonLinearDiagram.prototype.parseSvgData = function (svgData, centerShape, diagramStyleValue, deviceHolder, parentDiv) {
    if (!svgData) {
        if (this.subtype == "connectorpoint") svgData = { ...svgData, data: Constants.Value.trophy6node, id: "trophy6node" };
        else svgData = { ...svgData, data: Constants.Value.coin6node, id: "coin6node" };
    }
    let svgNode = DiagramUtils.getSVGfromString(svgData.data);
    svgNode.setAttribute("class", "svgNode clsAccentfill");
    svgNode.setAttribute("data-id", "svgNode");
    svgNode.setAttribute("data-type", "svg");
    svgNode.setAttribute("data-iconpath", svgData.value);
    svgNode.setAttribute("data-iconid", svgData.id);
    deviceHolder.appendChild(svgNode);
    DiagramNodeUtils.replaceImagePathToNonLinearAssets(svgNode, diagramStyleValue, centerShape, this.diagramRenderComplete.bind(this));
    let assetGroupingId = centerShape.assetGroupingId || this.nodeProps.assetGroupingId;
    this.searchStockImageFromAI(centerShape, assetGroupingId instanceof Array ? assetGroupingId?.[0] : assetGroupingId, svgNode, diagramStyleValue, this.diagramRenderComplete.bind(this));
    DiagramNodeUtils.applyColorToNonLinearAssets(svgNode, svgData.id, this.arrTintArray);
    this.updateFloaterSettings(this.diagramData.properties, svgNode);
    // this.checkCenterNodeStyle();
    this.updateEvents();
    // this.updatePrimaryFont();
    // this.resetHolderWidth();
    this.setDimensionsForNodes(deviceHolder, svgNode, parentDiv, centerShape);
    this.updateEmphasize();
    this.updateSpecialOperations();
    this.updateFloaterOperations();
    this.setNonlinearContentType();
    this.updateAnimationType();
    this.updateJSONData();
    this.isCenterShapeLoaded = true;
    this.resetHolderWidth();
    this.diagramRenderComplete();
    // let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    // if (lastDiv) this.updatePropsCallBack(lastDiv.id);
    this.addFocus(this.arrDiagramNode.length - 1);
};

SimpleNonLinearDiagram.prototype.searchStockImageFromAI = function (centerShape, assetGroupingId, svgNode, diagramStyleValue, callback) {
    if (this.diagramData.properties.isfromai && assetGroupingId && this.nodeProps?.stockImageChange) {
        // if (assetGroupingId && this.nodeProps?.stockImageChange) {
        if (centerShape.stockImageChange != null && centerShape.stockImageChange == false) return;
        if (centerShape.needAssetUpdate != null && centerShape.needAssetUpdate == false) return;
        let title = this.diagramParent.parentElement.parentElement.parentElement.querySelector("[id='TITLE']");
        let assetText = title ? title.innerText : null;
        function setStockImage(objResponse) {
            if (objResponse && objResponse.url && objResponse.url != "") {
                centerShape.imageUrl = objResponse.url;
                DiagramNodeUtils.replaceImagePathToNonLinearAssets(svgNode, diagramStyleValue, centerShape, callback);
                let enableContrast = this.nodeProps?.enableContrast;
                if (objResponse.color && enableContrast) {
                    let graphicContrast = enableContrast.graphic;
                    let titleContrast = enableContrast.title;
                    let contrastColor = DiagramUtils.lightOrDark(objResponse.color);
                    // console.log(contrastColor);
                    objResponse.type = centerShape.type;
                    if (contrastColor == "light") {
                        if (titleContrast) {
                            objResponse.id = "themeWhitebg bglightText";
                        }
                        if (!graphicContrast) {
                            objResponse.id = "darkText";
                        }
                    } else {
                        if (titleContrast) {
                            objResponse.id = "themeBlackbg bgdarkText";
                        }
                        if (!graphicContrast) {
                            objResponse.id = "lightText";
                        }
                    }
                    this.updateColorCallBack(objResponse);
                }
                this.nodeProps.centerShape.imageUrl = objResponse.url;
                if (objResponse.id) this.nodeProps.centerShape.color = objResponse.id;

                if (this.nodeProps.assetGroupingId && !(this.nodeProps.assetGroupingId instanceof Array)) {
                    this.nodeProps.assetGroupingId = [this.nodeProps.assetGroupingId];
                }
                this.nodeProps.centerShape.assetGroupingId = this.nodeProps.assetGroupingId;
                this.diagramData.properties.assetCenterShape = this.nodeProps.centerShape;
                this.updateProperties(this.diagramData.properties);
                this.updatePropsCallBack();
            }
        }
        if (assetText && assetText != "") {
            centerShape.needAssetUpdate = false;
            // deviceHolder.setAttribute("data-node-graphic-text", assetText);
            DiagramUtils.searchAIcall("stockimage", centerShape, assetText, { graphicData: { type: "image", imgtype: assetGroupingId } }, this.globalMoodData, null, 0, setStockImage.bind(this), appBaseURL, this.appStaticURL);
        }
    }
};

SimpleNonLinearDiagram.prototype.toggleSeqContent = function () {
    if (this.diagramData.properties.diagramcontent != false) {
        this.diagramData.properties.diagramcontent = !this.diagramData.properties.sequencetext;
        this.diagramParent.setAttribute("data-content", this.diagramData.properties.diagramcontent);
    }
    this.diagramParent.parentElement.style.setProperty("--contentdisplay", this.diagramData.properties.diagramcontent ? "flex" : "none");
    this.diagramParent.parentElement.style.setProperty("--numberdisplay", this.diagramData.properties.sequencetext ? "flex" : "none");
};

SimpleNonLinearDiagram.prototype.setNumberIconNodes = function (pointNode, index, objData = {}, nodeParent, alignment, isFromInsert) {
    let connectorItem = pointNode.querySelector("[id*='connectorline']");
    if (connectorItem && !this.nodeProps.name.includes("convergent") && !this.nodeProps.name.includes("divergent")) {
        if (this.diagramData.properties.sequencetext == false && this.diagramData.properties.diagramcontent == false && this.diagramData.properties.primarytext == false && this.diagramData.properties.secondarytext == false) connectorItem.style.setProperty("display", "none");
        else connectorItem.style.removeProperty("display");
    }
    this.diagramParent.setAttribute("data-innercontent", "false");
    let placeHolder = pointNode.querySelector("[id*='-placeholder']");
    if (!placeHolder) {
        if (isFromInsert) this.toggleSeqContent();
        return false;
    }
    let contentRect = placeHolder.querySelector("[id*='-content']");
    let iconRect = placeHolder.querySelector("[id*='-icon']");
    let placeholderType = this.nodeProps.centerShape.placeholdertype;
    nodeParent.style.setProperty("position", "absolute");
    if (contentRect) {
        let arrCoords = DiagramUtils.getAbsCoordOfElement(contentRect, this.diagramParent, this.slideScale);
        nodeParent.style.setProperty("left", arrCoords.x + "px", "important");
        nodeParent.style.setProperty("top", arrCoords.y + "px", "important");
        nodeParent.style.setProperty("width", arrCoords.width + "px", "important");
        nodeParent.style.setProperty("height", arrCoords.height + "px", "important");
        // if (alignment == "vertical") {
        // this.diagramParent.style.setProperty("--nodesMaxHeight", arrCoords.height + "px");
        let secContent = nodeParent.querySelector("[name='secContentNode']");
        if (secContent) secContent.style.setProperty("max-height", arrCoords.height + "px", "important");
        // }
        let id = contentRect.getAttribute("id");
        let logoNode = nodeParent.querySelector("[data-nodetype='logoNode']");
        if (id.includes("left")) {
            nodeParent.setAttribute("data-nodealign", "right");
            if (logoNode) logoNode.setAttribute("data-imagecropalignment", "left");
        } else if (id.includes("right")) {
            nodeParent.setAttribute("data-nodealign", "left");
            if (logoNode) logoNode.setAttribute("data-imagecropalignment", "right");
        } else if (id.includes("top")) {
            nodeParent.setAttribute("data-nodealign", "bottom");
        } else if (id.includes("bottom")) {
            nodeParent.setAttribute("data-nodealign", "top");
        } else {
            nodeParent.setAttribute("data-nodealign", "center");
        }
        nodeParent.style.setProperty("padding", "unset", "important");
        nodeParent.style.setProperty("padding-left", "unset", "important");
        nodeParent.style.setProperty("padding-right", "unset", "important");
        nodeParent.style.setProperty("padding-top", "unset", "important");
        nodeParent.style.setProperty("padding-bottom", "unset", "important");

        // Text Highlight
        let bgShape = pointNode.querySelector("[id*='bgcolor']");
        let colorShape = pointNode.querySelector("[id*='shape']");
        let arrHightlightNodes = nodeParent.querySelectorAll("[data-highlight-event='true']");

        arrHightlightNodes.forEach((element) => {
            element.classList.remove("titleColorBg");
            element.classList.remove("subtitleColorBg");
            element.classList.remove("transparentBg");
            element.classList.add(colorShape && !bgShape ? "titleColorBg" : "transparentBg");
        });
        //  this.bgColor.includes("accent") ? " titleColorBg " : this.bgColor.includes("secondary") ? " subtitleColorBg " : " transparentBg ";

        if (!placeholderType) return true;
    }
    if (iconRect) {
        let x = iconRect.getAttribute("x");
        let y = iconRect.getAttribute("y");
        let width = iconRect.getAttribute("width");
        let height = iconRect.getAttribute("height");
        iconRect.innerHTML = "";
        placeHolder.setAttribute("class", "moodanimation");
        placeHolder.setAttribute("data-animation", "item");
        let svgNode = DiagramNodeUtils.createSVGElement("svg");
        let isInnerColor = this.nodeProps.innerColor && this.nodeProps.innerColor == "inner";
        let svgItem = placeHolder.querySelector("[id='svgItem" + index + "']");
        if (svgItem) svgItem.remove();
        DiagramNodeUtils.assignAttributes(svgNode, {
            id: "svgItem" + index,
            width: width,
            height: height,
            x: x,
            y: y,
            "data-index": index,
            "data-maxwidth": width,
            "data-maxheight": height,
            // class: "moodanimation " + (isInnerColor ? "clsContrastFill" : "clsAccentfill"),
            class: "clsSvgNode " + (isInnerColor ? "clsContrastFill" : "clsAccentfill"),
            // "data-animation": "item",
        });
        let contentChangeNode = this.nodeProps && this.nodeProps.nodeclassName && this.nodeProps.nodeclassName.includes("ContentOptionNode");
        if ((!contentChangeNode && this.diagramData.properties.sequencetext == true) || (contentChangeNode && this.diagramParent.dataset.contenttype && this.diagramParent.dataset.contenttype == "sequence")) {
            pointNode.style.pointerEvents = "none";
            let content = DiagramUtils.getSeqMoodStyle(this.globalMoodData.seqnumproperties, this.diagramData.properties, "sequencenumber", index, this.diagramParent.dataset.nodecount);
            let textNode = DiagramNodeUtils.createSVGElement("text");
            textNode.setAttribute("text-anchor", "middle");
            textNode.setAttribute("class", "n1");
            let fontSize = DiagramNodeUtils.fitFontSize(textNode, index.toString(), width, height, 100, false, this.diagramParent);
            textNode.style.fontSize = fontSize + "px";
            let tspanNode = DiagramNodeUtils.createSVGElement("tspan");
            tspanNode.setAttribute("dx", "50%");
            tspanNode.setAttribute("dy", "1em");
            tspanNode.textContent = content;
            textNode.appendChild(tspanNode);
            svgNode.appendChild(textNode);
            svgNode.style.setProperty("overflow", "unset");
            this.diagramData.properties.diagramcontent = false;
            this.diagramData.properties.contenttype = "sequence";
            this.diagramParent.setAttribute("data-contenttype", "sequence");
            this.diagramParent.setAttribute("data-diagramcontent", "false");
            this.diagramParent.setAttribute("data-innercontent", "true");
            placeHolder.appendChild(svgNode);
        } else if ((!contentChangeNode && this.diagramData.properties.diagramcontent == true) || (contentChangeNode && this.diagramParent.dataset.contenttype && this.diagramParent.dataset.contenttype == "icon")) {
            pointNode.style.pointerEvents = "all";
            pointNode.setAttribute("data-type", "icon");
            pointNode.setAttribute("data-index", index - 1);
            pointNode.setAttribute("data-contentType", "icon");
            pointNode.setAttribute("data-node-content-type", "icon");
            placeHolder.setAttribute("data-contentType", "icon");
            placeHolder.setAttribute("data-node-content-type", "icon");
            svgNode.setAttribute("data-focus-parent", pointNode.id);
            svgNode.setAttribute("data-id", "iconNode");
            let useNode = DiagramNodeUtils.createSVGElement("use");
            let content = objData.content && objData.content.type == "icon" && objData.content.value && objData.content.value != "" ? objData.content : DiagramNodeUtils.diagramContentData("icon", this.appStaticURL, this.arrDefaults, index);
            svgNode.setAttribute("iconpath", content.value);
            content.id = DiagramNodeUtils.getIconName(content);
            if (!content.id || content.id == "") content.id = "placeholder";
            svgNode.setAttribute("iconid", content.id);
            content.value = DiagramUtils.checkAppStaticUrl(content.value, this.appStaticURL);
            DiagramAssetLoader.oneTimeDownload(content, true, document.body);
            DiagramNodeUtils.assignAttributes(useNode, {
                "xlink:href": "#" + content.id,
                class: "clsSvgIcon " + (isInnerColor ? "clsContrastFill" : "clsAccentfill"),
                "data-id": "useNode",
                iconpath: content.value,
                iconid: content.id,
            });
            content.dataRef = null;
            svgNode.appendChild(useNode);
            this.diagramData.properties.sequencetext = false;
            this.diagramData.properties.contenttype = "icon";
            this.diagramParent.setAttribute("data-contenttype", "icon");
            this.diagramParent.setAttribute("data-sequencetext", "false");
            this.diagramParent.setAttribute("data-innercontent", "true");
            DiagramCreateUtil.updateManifest(content, this.manifestUpdater, this.appStaticURL);
            placeHolder.appendChild(svgNode);
            placeHolder.setAttribute("data-node-graphic-text", content.assetText);
            this.arrDiagramNode[index - 1]?.needAssetUpdate(placeHolder, content);
        }
        let contentType = this.diagramData.properties.contenttype;
        if (contentType && contentChangeNode) this.switchContentBetweenNodeAndSvg(contentType, index - 1);
        else this.diagramParent.setAttribute("data-nomargin", contentType == "icon" || contentType == "sequence" || contentType == "none" ? "true" : "false");
        return false;
    }
};

SimpleNonLinearDiagram.prototype.resizeNode = function (svgNode, alignment, position, parentDiv, deviceHolder) {
    if (alignment == "placeholder") {
        parentDiv.style.setProperty("width", "100%");
        parentDiv.style.setProperty("height", "100%");
        this.diagramParent.style.setProperty("--nodesMaxWidth", "unset");
        if (position == "horizontal") this.diagramParent.style.setProperty("--nodesMaxHeight", "unset");
        deviceHolder.style.setProperty("height", this.height + "%", "important");
    } else if (position == "horizontal") {
        parentDiv.style.setProperty("width", "100%");
        let menuHeight = this.nodeProps.centerShape.height;
        let maxHeight = menuHeight ? (this.diagramParent.clientHeight * menuHeight) / 100 : this.diagramParent.clientHeight * 0.5;
        let height = alignment == "convergediverge" ? maxHeight : svgNode.clientHeight < maxHeight ? svgNode.clientHeight : maxHeight;
        let divideFactor = alignment == "alternate" ? 2 : 1;
        let centeHolderHeight = getComputedStyle(this.diagramParent).getPropertyValue("--centerHolderMaxHeight").trim();
        centeHolderHeight = centeHolderHeight ? parseFloat(centeHolderHeight) : 0;
        let paddingTop = alignment == "process" ? 24 : 0;
        this.diagramParent.style.setProperty("--nodesMaxHeight", "calc(" + (this.diagramParent.clientHeight - height - centeHolderHeight) + "px / " + divideFactor + " - " + paddingTop + "px)");
        svgNode.style.height = height + "px";
        if (alignment == "process") {
            // let menuMinHeight = this.nodeProps.centerShape.minHeight;
            let menuMaxHeight = this.nodeProps.centerShape.maxHeight;
            let svgMaxHeight = height;
            if (menuMaxHeight) {
                svgNode.style.setProperty("max-height", (this.diagramParent.clientHeight * menuMaxHeight) / 100 + "px");
                svgNode.style.height = "auto";
                svgNode.style.setProperty("min-height", height + "px");
            }
            // if (menuMinHeight) {
            // svgNode.style.setProperty("min-height", (this.diagramParent.clientHeight * menuMinHeight) / 100 + "px");
            // }
            else {
                let dimens = DiagramNodeUtils.getAssetDimensions(svgNode);
                svgNode.style.setProperty("min-height", dimens.height + "px");
                svgMaxHeight = Math.max(dimens.height, height);
            }
            // this.diagramParent.style.setProperty("--nodesMaxHeight", "calc(100% - " + svgMaxHeight + "px)");
            this.diagramParent.style.setProperty("--nodesMaxHeight", "calc(" + (this.diagramParent.clientHeight - svgMaxHeight - centeHolderHeight) + "px / " + divideFactor + ")");
        }
    } else if (position == "vertical") {
        let centeHolderWidth = getComputedStyle(this.diagramParent).getPropertyValue("--centerHolderMaxWidth").trim();
        parentDiv.style.setProperty("height", "100%");
        // deviceHolder.style.setProperty("height", "auto", "important");
        deviceHolder.style.setProperty("height", "fit-content", "important");
        deviceHolder.style.setProperty("display", "flex", "important");
        // deviceHolder.style.setProperty("height", "auto", "important");
        // deviceHolder.style.setProperty("height", "100%", "important");
        deviceHolder.style.setProperty("max-height", this.height + "%", "important");
        deviceHolder.style.setProperty("max-width", "100%", "important");
        let maxWidth = this.diagramParent.clientWidth * (alignment == "convergediverge" || alignment == "placeholder" ? 1 : 0.5);
        let width = maxWidth;
        // let svgNodeWidth = svgNode.getAttribute("viewBox").split(" ")[2];
        let svgNodeWidth = svgNode.clientWidth;
        if (alignment == "convergediverge") {
            width = svgNodeWidth > maxWidth ? maxWidth : svgNodeWidth;
            // svgNode.style.setProperty("min-width", width + "px", "important");
            // svgNode.style.setProperty("max-width", width + "px", "important");
            if (this.svgalign == "left" || this.svgalign == "right") {
                deviceHolder.style.setProperty("height", "100%", "important");
                deviceHolder.style.setProperty("--centerHolderMaxHeight", this.diagramParent.clientHeight - 24 + "px", "important");
                svgNode.style.setProperty("height", "100%", "important");
                svgNode.style.setProperty("width", "auto", "important");
            }
        } else deviceHolder.parentElement.style.setProperty("max-width", width + "px", "important");
        let menuWidth = this.nodeProps.centerShape.width;
        if (menuWidth) {
            width = menuWidth;
            deviceHolder.parentElement.style.setProperty("max-width", width + "%", "important");
        }
        let menuMinWidth = this.nodeProps.centerShape.minWidth;
        let menuMaxWidth = this.nodeProps.centerShape.maxWidth;
        if (menuMinWidth) deviceHolder.parentElement.style.setProperty("min-width", menuMinWidth + "%", "important");
        if (menuMaxWidth) {
            deviceHolder.parentElement.style.setProperty("max-width", menuMaxWidth + "%", "important");
            width = menuMaxWidth;
        } else {
            if (width / 2 < 250) {
                width = this.diagramParent.clientWidth - 2 * 250;
            }
        }
        // deviceHolder.parentElement.style.setProperty("max-width", "750px", "important");
        let divideFactor = alignment == "convergediverge" ? 1 : 2;
        maxWidth = (this.diagramParent.clientWidth - width) / divideFactor;
        if (alignment == "convergediverge") {
            maxWidth = this.diagramParent.clientWidth - svgNode.clientWidth;
        }
        this.diagramParent.style.setProperty("--nodesMaxWidth", maxWidth - parseFloat(centeHolderWidth) + "px");
    }
};

SimpleNonLinearDiagram.prototype.updateNodeData = function (nodeData, type, index, parentId) {
    if (parentId && parentId.includes("IMAGE")) {
        this.centerHolderNode.objData.content = nodeData;
        this.centerholderdata = this.centerHolderNode.objData;
        let imgNode = this.diagramParent.querySelector("[id='" + parentId + "']");
        imgNode.setAttribute("xlink:href", nodeData.value);
        return;
    }
    if (parentId && parentId.includes("centerHolderParent")) {
        this.centerHolderNode.objData.content = nodeData;
        this.centerholderdata = this.centerHolderNode.objData;
        if (this.arrDiagramNode && this.arrDiagramNode.length > index) {
            this.arrDiagramNode[index].updateContentData(nodeData, type, parentId);
        }
    } else if (type.includes("icon")) {
        let parentNode = this.diagramParent.querySelector("[id='" + parentId + "']");
        if (parentNode) {
            let iconNode = parentNode.querySelector("[data-id='useNode']");
            nodeData.id = DiagramNodeUtils.getIconName(nodeData);
            iconNode.setAttribute("xlink:href", "#" + nodeData.id);
            parentNode.setAttribute("iconpath", nodeData.value);
            parentNode.setAttribute("iconid", nodeData.id);
            iconNode.setAttribute("iconpath", nodeData.value);
            iconNode.setAttribute("iconid", nodeData.id);
            SimpleLinearDiagram.prototype.updateNodeData.call(this, nodeData, type, parentNode.getAttribute("data-index"), parentId);
        }
    } else {
        SimpleLinearDiagram.prototype.updateNodeData.call(this, nodeData, type, index);
    }
};

SimpleNonLinearDiagram.prototype.isNonLinearAsset = function () {
    return true;
};

SimpleNonLinearDiagram.prototype.defaultFoucsOut = function (event) {
    LinearDiagram.prototype.defaultFoucsOut.call(this, event);
};

SimpleNonLinearDiagram.prototype.setDimensionsForNodes = function (deviceHolder, svgNode, parentDiv, centerShape, isFromInsert = true) {
    let position = centerShape.position.split(",")[0];
    let alignment = centerShape.position.split(",")[1] || "center";
    this.resizeNode(svgNode, alignment, position, parentDiv, deviceHolder);
    let maxHeight = this.diagramParent.clientHeight * 0.5;
    let maxWidth = parseFloat(getComputedStyle(this.diagramParent).getPropertyValue("--nodesMaxWidth").trim());
    this.setSlideScale();
    for (let index = 0; index < this.arrDiagramNode.length; index++) {
        let element = this.arrDiagramNode[index];
        let nodeParent = element.parentNode.parentElement;
        let pointNode = deviceHolder.querySelector("[id*='-point" + (index + 1) + "']");
        if (!pointNode) return;
        let connector = deviceHolder.querySelector("[id*='connector" + (index + 1) + "']");
        let connector2 = deviceHolder.querySelector("[id*='connector" + (index + 2) + "']");
        let offset = DiagramNodeUtils.calcBoundsDifference("x", deviceHolder, pointNode);
        if (alignment == "alternate") {
            let nodeGroup = nodeParent.querySelector("[name='nodeGroup']");
            nodeParent.style.left = offset / this.slideScale + "px";
            nodeParent.style.maxWidth = pointNode.getBoundingClientRect().width / this.slideScale + "px";
            let startAlign = centerShape.position.split(",")[2] || "top";
            let startValue = startAlign == "top" ? 0 : 1;
            if (index % 2 == startValue) {
                nodeParent.style.bottom = "100%";
                nodeParent.style.paddingBottom = "8px";
                nodeParent.firstElementChild.style.alignItems = "flex-end";
                if (nodeGroup) {
                    nodeGroup.style.marginBottom = "var(--nodeTopMargin)";
                    nodeGroup.style.marginTop = "unset";
                }
            } else {
                nodeParent.style.top = "100%";
                nodeParent.style.paddingTop = "8px";
                nodeParent.firstElementChild.style.alignItems = "flex-start";
            }
        }

        let isPositionSet = this.setNumberIconNodes(pointNode, index + 1, element.objData, nodeParent, position, isFromInsert);
        if (!isPositionSet) {
            let gap = this.nodeGap ? parseFloat(this.nodeGap) : 16;
            if (alignment == "convergediverge") {
                if (index == 0 && connector && connector2) {
                    if (position == "vertical") {
                        let coords2 = (connector2.getBoundingClientRect().y - connector.getBoundingClientRect().y) / this.slideScale - gap - 1;
                        this.diagramParent.style.setProperty("--nodesMaxHeight", coords2 - 1 + "px");
                    } else {
                        let coords2 = (connector2.getBoundingClientRect().x - connector.getBoundingClientRect().x) / this.slideScale - gap;
                        this.diagramParent.style.setProperty("--nodesMaxWidth", coords2 - 1 + "px");
                    }
                }
                if (connector) {
                    let rect = connector.firstElementChild;
                    if (rect) {
                        let id = rect.getAttribute("id");
                        if (id.includes("left")) {
                            nodeParent.setAttribute("data-nodealign", "right");
                            deviceHolder.style.alignItems = "flex-end";
                        } else if (id.includes("right")) {
                            nodeParent.setAttribute("data-nodealign", "left");
                            deviceHolder.style.alignItems = "flex-start";
                        } else if (id.includes("top")) {
                            nodeParent.setAttribute("data-nodealign", "bottom");
                            deviceHolder.style.justifyContent = "flex-end";
                        } else if (id.includes("bottom")) {
                            nodeParent.setAttribute("data-nodealign", "top");
                            deviceHolder.style.justifyContent = "flex-start";
                        }
                        nodeParent.style.padding = "unset";
                        if (position == "vertical") {
                            nodeParent.style.marginTop = gap / 2 + "px";
                            nodeParent.style.marginBottom = gap / 2 + "px";
                            // nodeParent.style.marginTop = gap / 2 + parseFloat(extraPadding) + "px";
                            // nodeParent.style.marginBottom = gap / 2 + parseFloat(extraPadding) + "px";
                        } else {
                            // nodeParent.style.paddingLeft = gap / 2 + "px";
                            // nodeParent.style.paddingRight = gap / 2 + "px";
                            nodeParent.style.marginLeft = gap / 2 + "px";
                            nodeParent.style.marginRight = gap / 2 + "px";
                        }
                    }
                }
            } else if (position == "horizontal") {
                if (index == 0) {
                    let nextPointNode = deviceHolder.querySelector("[id*='-point" + (index + 2) + "']");
                    let offsetNext = DiagramNodeUtils.calcBoundsDifference("x", deviceHolder, nextPointNode);
                    this.diagramParent.style.setProperty("--nodesMaxWidth", (offsetNext - offset - gap) / this.slideScale + "px");
                    if (alignment != "alternate") {
                        let padding = svgNode.firstElementChild.getBoundingClientRect().x - svgNode.getBoundingClientRect().x;
                        this.diagramParent.style.setProperty("--nodesMaxWidth", "calc((100% - " + (padding / this.slideScale) * 2 + "px - " + this.arrDiagramNode.length * gap + "px) / " + this.arrDiagramNode.length + ")");
                    }
                }
                if (gap && gap != 0 && alignment != "alternate") {
                    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
                    if (nodesHolder) nodesHolder.style.columnGap = gap + "px";
                    // nodeParent.style.marginRight = gap / 2 + "px";
                    // nodeParent.style.marginLeft = gap / 2 + "px";
                }
            } else if (position == "vertical") {
                // console.log("scale", this.slideScale);
                if (connector) {
                    if (index == 0) {
                        let leftArray = deviceHolder.querySelectorAll("rect[id*='left']");
                        let rightArray = deviceHolder.querySelectorAll("rect[id*='right']");
                        let bottomArray = deviceHolder.querySelectorAll("rect[id*='bottom']");
                        let topArray = deviceHolder.querySelectorAll("rect[id*='top']");
                        let maxNodes = Math.max(leftArray.length, rightArray.length);
                        let maxNodesHeight = this.diagramParent.clientHeight / maxNodes - (maxNodes - 1) * gap;
                        if (rightArray.length >= 1 || leftArray.length >= 1) {
                            if (rightArray.length >= 2 && rightArray.length > leftArray.length) {
                                maxHeight = DiagramNodeUtils.calcBoundsDifference("y", rightArray[1], rightArray[0]) / this.slideScale;
                                maxHeight = Math.abs(maxHeight) - gap;
                            } else if (leftArray.length >= 2) {
                                maxHeight = DiagramNodeUtils.calcBoundsDifference("y", leftArray[1], leftArray[0]) / this.slideScale;
                                maxHeight = Math.abs(maxHeight) - gap;
                            }
                            try {
                                if (rightArray.length > 0) {
                                    let maxLimitRightFirst = DiagramNodeUtils.calcBoundsDifference("y", this.diagramParent, rightArray[0]) / this.slideScale;
                                    let maxLimitRightLast = DiagramNodeUtils.calcBoundsDifference("y", this.diagramParent, rightArray[rightArray.length - 1]) / this.slideScale;
                                    if (maxLimitRightFirst && maxLimitRightLast && maxLimitRightFirst != 0 && maxLimitRightLast != 0) maxHeight = Math.min(maxNodesHeight, maxHeight, Math.abs(maxLimitRightFirst) * 2, Math.abs(maxLimitRightLast) * 2);
                                }
                                if (leftArray.length > 0) {
                                    let maxLimitLeftLast = DiagramNodeUtils.calcBoundsDifference("y", this.diagramParent, leftArray[leftArray.length - 1]) / this.slideScale;
                                    let maxLimitLeftFirst = DiagramNodeUtils.calcBoundsDifference("y", this.diagramParent, leftArray[0]) / this.slideScale;
                                    if (maxLimitLeftLast && maxLimitLeftFirst && maxLimitLeftLast != 0 && maxLimitLeftFirst != 0) maxHeight = Math.min(maxNodesHeight, maxHeight, Math.abs(maxLimitLeftLast) * 2, Math.abs(maxLimitLeftFirst) * 2);
                                }
                            } catch (error) {
                                console.log("error", error);
                                maxHeight = Math.min(maxHeight, maxNodesHeight);
                            }

                            this.diagramParent.style.setProperty("--nodesMaxHeight", maxHeight + "px");
                        }
                        if (bottomArray.length >= 1 || topArray.length >= 1) {
                            if (bottomArray.length >= 2) {
                                maxWidth = DiagramNodeUtils.calcBoundsDifference("x", bottomArray[1], bottomArray[0]) / this.slideScale;
                                maxWidth = Math.abs(maxWidth) - gap;
                                // this.diagramParent.style.setProperty("--nodesMaxWidth", maxWidth + "px");
                            } else if (topArray.length >= 2) {
                                maxWidth = DiagramNodeUtils.calcBoundsDifference("x", topArray[1], topArray[0]) / this.slideScale;
                                maxWidth = Math.abs(maxWidth) - gap;
                            }
                            // maxHeight = Math.min(maxHeight, maxNodesHeight);
                            this.diagramParent.style.setProperty("--nodesMaxWidth", maxWidth + "px");
                        }
                    }
                    let rect = connector.firstElementChild;
                    if (rect) {
                        nodeParent.style.removeProperty("max-width");
                        nodeParent.style.removeProperty("max-height");
                        let logoNode = nodeParent.querySelector("[data-nodetype='logoNode']");
                        let top = Math.abs(DiagramNodeUtils.calcBoundsDifference("y", rect, this.diagramParent)) / this.slideScale;
                        let left = Math.abs(DiagramNodeUtils.calcBoundsDifference("x", rect, this.diagramParent)) / this.slideScale;
                        let id = rect.getAttribute("id");
                        if (id.includes("left")) {
                            nodeParent.setAttribute("data-nodealign", "left");
                            nodeParent.style.top = top - maxHeight / 2 + "px";
                            nodeParent.style.left = "0px";
                            nodeParent.style.maxWidth = left + "px";
                            if (logoNode) logoNode.setAttribute("data-imagecropalignment", "right");
                        } else if (id.includes("right")) {
                            nodeParent.setAttribute("data-nodealign", "right");
                            nodeParent.style.top = top - maxHeight / 2 + "px";
                            nodeParent.style.left = left + "px";
                            nodeParent.style.maxWidth = this.diagramParent.clientWidth - left + "px";
                            if (logoNode) logoNode.setAttribute("data-imagecropalignment", "left");
                        } else if (id.includes("top")) {
                            nodeParent.setAttribute("data-nodealign", "top");
                            nodeParent.style.top = "0px";
                            nodeParent.style.left = left - maxWidth / 2 + "px";
                            nodeParent.style.setProperty("height", top + "px", "important");
                            nodeParent.style.setProperty("max-height", top + "px", "important");
                            element.parentNode.style.alignItems = "flex-end";
                        } else if (id.includes("bottom")) {
                            nodeParent.setAttribute("data-nodealign", "bottom");
                            nodeParent.style.setProperty("height", this.diagramParent.clientHeight - top + "px", "important");
                            nodeParent.style.setProperty("max-height", this.diagramParent.clientHeight - top + "px", "important");
                            nodeParent.style.top = top + "px";
                            nodeParent.style.left = left - maxWidth / 2 + "px";
                            element.parentNode.style.alignItems = "flex-start";
                        }
                    }
                }
            }
        }
    }
    let gCommonpoint = svgNode.querySelector("g[id*='commonpoint']");
    if (gCommonpoint) {
        let placeholder = gCommonpoint.querySelector("[id*='placeholder']");
        let commonConnector = gCommonpoint.querySelector("[id*='connector']");
        let contentrect = gCommonpoint.querySelector("[id*='content']");
        let devicerect = gCommonpoint.querySelector("[id*='-deviceholder']");
        if (!placeholder && !commonConnector && !contentrect) return;
        let centerHolderParent = deviceHolder.querySelector("[data-id='centerHolderParent']");
        if (centerHolderParent) centerHolderParent.remove();
        if (devicerect) {
            deviceHolder.style.setProperty("display", "unset", "important");
            let commonParentDiv = this.createCenterHolder(deviceHolder);
            commonParentDiv.style.setProperty("position", "absolute", "important");
            commonParentDiv.style.setProperty("top", "0", "important");

            let imageHolder = commonParentDiv.querySelector("[id*='imageHolder']");
            imageHolder.setAttribute("data-focus-parent", "centerHolderParent");
            imageHolder.setAttribute("id", "imageHolder" + DiagramNodeUtils.uuidv4());

            let dimensions = DiagramNodeUtils.getAssetDimensions(svgNode);
            let width = dimensions.width;
            let height = dimensions.height;
            let svgId = DiagramUtils.getSvgAssetId(centerShape, this.arrDiagramNode);
            let additionalId = this.diagramParent.parentElement.getAttribute("data-element-id");
            commonParentDiv.style.setProperty("clip-path", "url(#" + additionalId + svgId + "-clip-path)");
            commonParentDiv.style.setProperty("-webkit-clip-path", "url(#" + additionalId + svgId + "-clip-path)");
            commonParentDiv.style.setProperty("width", width + "px");
            commonParentDiv.style.setProperty("height", height + "px");

            let clipPathNode = svgNode.querySelector("clipPath[id='" + svgId + "-clip-path']");
            if (!clipPathNode) return;
            DiagramResizeUtils.calcImageBounds(imageHolder, svgNode, additionalId + svgId);
            clipPathNode.setAttribute("clipPathUnits", "objectBoundingBox");
            DiagramNodeUtils.applySvgClipPath(svgId, deviceHolder, 0, deviceHolder, svgNode, additionalId);
            let imgNode = imageHolder.querySelector("img[data-id='imageNode'],img[data-id='logoNode']");
            imgNode.style.setProperty("position", "absolute");
        } else {
            if (commonConnector && alignment == "convergediverge") {
                let commonParentDiv = this.createCenterHolder(deviceHolder);
                let commonText = commonParentDiv.querySelector("[data-name='text']");
                if (commonText) {
                    commonText.setAttribute("data-prompt-text", Constants.Value.commonTextPrompt);
                    if (this.centerHolderNode) {
                        commonText.classList.remove(this.centerHolderNode.titleFontSize);
                        commonText.classList.add(this.centerHolderNode.commonTitleFontSize);
                    }
                }
            }
            if (contentrect) {
                let textHolderParent = this.createCenterHolder(deviceHolder);
                textHolderParent.style.setProperty("position", "absolute", "important");
                let arrCoords = DiagramUtils.getAbsCoordOfElement(contentrect, this.diagramParent, this.slideScale);
                textHolderParent.style.setProperty("left", arrCoords.x + "px", "important");
                textHolderParent.style.setProperty("top", arrCoords.y + "px", "important");
                textHolderParent.style.setProperty("width", arrCoords.width + "px", "important");
                textHolderParent.style.setProperty("height", arrCoords.height + "px", "important");
            }
            contentrect = placeholder && placeholder.firstElementChild;
            if (contentrect && contentrect.getAttribute("clip-path")) {
                gCommonpoint.style.pointerEvents = "all";
                this.createCenterHolder(deviceHolder, contentrect);
            }
        }
    }
};

SimpleNonLinearDiagram.prototype.createCenterImageNode = function (contentrect, value) {
    let svgItem = contentrect.querySelector("[id='svgNode']");
    if (svgItem) svgItem.remove();
    contentrect.style.setProperty("-webkit-clip-path", contentrect.getAttribute("clip-path"));
    let svgImageData = DiagramNodeUtils.createSVGElement("svg");
    let bbox = contentrect.getBBox();
    let centerX = contentrect.children?.[0]?.getAttribute("x") || bbox.x;
    let centerY = contentrect.children?.[0]?.getAttribute("y") || bbox.y;
    let centerWidth = contentrect.children?.[0]?.getAttribute("width") || bbox.width;
    let centerHeight = contentrect.children?.[0]?.getAttribute("height") || bbox.height;

    DiagramNodeUtils.assignAttributes(svgImageData, {
        width: centerWidth,
        height: centerHeight,
        x: centerX,
        y: centerY,
        "data-x": centerX,
        "data-y": centerY,
        "data-animation": "commonplaceholder",
        class: "moodanimation",
        "data-id": "centerHolderParent",
        "data-content-type": "image",
        id: "svgNode",
    });
    let imageNode = DiagramNodeUtils.createSVGElement("image");
    let imageWidth = contentrect.getBoundingClientRect().width / this.slideScale;
    let imageHeight = contentrect.getBoundingClientRect().height / this.slideScale;

    DiagramNodeUtils.assignAttributes(imageNode, {
        id: "IMAGE0",
        "data-type": "IMAGE",
        "data-belongto": "node0",
        "xlink:href": value,
        "data-x": centerX,
        "data-y": centerY,
        "data-width": imageHeight,
        "data-height": imageHeight,
        "data-type": "gridimage",
        "data-id": "imageNode",
    });
    svgImageData.appendChild(imageNode);
    contentrect.appendChild(svgImageData);
    let objDimensions = new Object();
    let imagestyle = null;
    objDimensions.x = centerX;
    objDimensions.y = centerY;
    objDimensions.width = imageHeight;
    objDimensions.height = imageHeight;
    objDimensions.viewBoxWidth = svgImageData.getAttribute("width");
    objDimensions.viewBoxHeight = svgImageData.getAttribute("height");
    DiagramResizeUtils.updateSvgImageBounds(imageNode, imagestyle, objDimensions, svgImageData);
};

SimpleNonLinearDiagram.prototype.alignNodeContent = function (centerHolderParent, parentDiv, arrange) {
    let index = 1;
    let connector = centerHolderParent.querySelector("[id*='connector" + index + "']");
    index = 2;
    let connector2 = centerHolderParent.querySelector("[id*='connector" + index + "']");
    if (connector && connector2) {
        if (arrange == "vertical") {
            let coords2 = (connector2.getBoundingClientRect().y - connector.getBoundingClientRect().y) / this.slideScale - 24;
            parentDiv.style.setProperty("--nodeHeight", coords2 + "px");
            parentDiv.style.setProperty("--nodeWidth", "auto");
        } else {
            let coords2 = (connector2.getBoundingClientRect().x - connector.getBoundingClientRect().x) / this.slideScale - 24;
            parentDiv.style.setProperty("--nodeWidth", coords2 + "px");
        }
    }
};

SimpleNonLinearDiagram.prototype.diagramRenderComplete = function () {
    if (this.isCenterShapeLoaded) {
        this.diagramParent.style.opacity = 1;
        SimpleLinearDiagram.prototype.diagramRenderComplete.call(this);
    }
};

SimpleNonLinearDiagram.prototype.addNode = function (nodeData, index) {
    if (this.diagramData.nodes.length > index) {
        this.diagramData.nodes.splice(index, 0, nodeData);
    } else {
        this.diagramData.nodes.push(nodeData);
    }
    this.initDiagramCreation();
    this.updateNodesHolderClass(this.diagramData.nodes.length);
};

SimpleNonLinearDiagram.prototype.updateNodesHolderClass = function (nodeCount) {
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    nodesHolder.setAttribute("data-node", nodeCount + "nodes");
};

SimpleNonLinearDiagram.prototype.deleteNode = function (targetIndex) {
    if (this.arrDiagramNode.length > targetIndex) {
        this.arrDiagramNode.splice(targetIndex, 1);
        let nodeDelete = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + targetIndex + "']");
        if (nodeDelete && nodeDelete.parentElement) {
            nodeDelete.parentElement.remove();
        }
    }
    if (this.diagramData.nodes.length > targetIndex) {
        this.diagramData.nodes.splice(targetIndex, 1);
    }
    this.initDiagramCreation();
    this.updateNodesHolderClass(this.diagramData.nodes.length);
};

SimpleNonLinearDiagram.prototype.resetHolderWidth = function () {
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    nodesHolder.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    nodesHolder.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    nodesHolder.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    nodesHolder.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    nodesHolder.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");
    this.resetNodeAttributes();
    this.checkSMLOverflow();
};

SimpleNonLinearDiagram.prototype.setHighlightPosition = function (node, parent) {
    let nodeParent = node.parentElement;
    let element = nodeParent.querySelector("[data-id='diagramContentNode']");
    if (!element || element.clientWidth == 0) element = node;
    return { element: element, alignment: "auto" };
};

SimpleNonLinearDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    let arrFloaterDisable = mainProperties.floateroptionsdisable;
    if (!arrFloaterDisable) return;
    let deviceHolder = this.diagramParent.querySelector("[data-id='deviceHolder']");
    let iconRect = null;
    if (deviceHolder) {
        iconRect = deviceHolder.querySelector("[id*='-icon']");
        let contentindex = -1;
        try {
            if (iconRect) {
                contentindex = arrFloaterDisable.indexOf("content");
                if (contentindex !== -1) arrFloaterDisable.splice(contentindex, 1);
            }
        } catch (error) {}
    }

    if (arrFloaterDisable) {
        arrFloaterDisable.push("arrange");
        arrFloaterDisable.push("sequencetext");
        arrFloaterDisable.push("content");
        arrFloaterDisable = DiagramUtils.restrictContentOptions(arrFloaterDisable, this.nodeProps ? this.nodeProps.supportedNodes : null, iconRect);
    }
    if (this.diagramData.properties.minnode == this.diagramData.properties.maxnode) {
        arrFloaterDisable.push("addoption");
    }
    mainProperties.floateroptionsdisable = arrFloaterDisable;
    this.diagramParent.setAttribute("data-floateroptionsdisable", arrFloaterDisable);
};

SimpleNonLinearDiagram.prototype.showHideSecondary = function (value) {
    LinearDiagram.prototype.showHideSecondary.call(this, value);
    this.slideDimensionChange();
    this.updateTextNodes();
};

SimpleNonLinearDiagram.prototype.showHidePrimary = function (value) {
    LinearDiagram.prototype.showHidePrimary.call(this, value);
    this.slideDimensionChange();
    this.updateTextNodes();
};

SimpleNonLinearDiagram.prototype.changeNumberStart = function (value) {
    LinearDiagram.prototype.changeNumberStart.call(this, value);
    this.slideDimensionChange();
    this.updateTextNodes();
};

SimpleNonLinearDiagram.prototype.changeNumberReverse = function (value) {
    LinearDiagram.prototype.changeNumberReverse.call(this, value);
    this.slideDimensionChange();
    this.updateTextNodes();
};

SimpleNonLinearDiagram.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    let centerNode = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    let isCenterChild = elTarget && elTarget?.dataset?.id == "centerHolderParent" ? elTarget : centerNode ? this.isChildOfParent(elTarget, centerNode) : false;

    if (isCenterChild) {
        let objContentSwap = this.getSeletion(strSelectionType, "centerNode");
        if (objContentSwap != null && Object.keys(objContentSwap).length > 0) {
            let { options, selectedindex } = this.getSeletion(centerNode.dataset.contentType, "centerNode");
            dict.contentswap = {
                dpsource: options,
                selectedindex: selectedindex,
                floaterproperty: "contentChange",
                visible: options.length > 1 ? true : false,
            };
        }
        elTarget.setAttribute("data-focus-parent", "centerHolderParent");
        dict[FloaterConstants.DELETE_ASSET] = null;
        dict[FloaterConstants.HIGHLIGHT] = null;
    }
};

/////////// Animation function

SimpleNonLinearDiagram.prototype.setupAnimation = function (animationType, callback) {
    this.isEmphasisEnable = this.diagramParent.dataset.hover && this.diagramParent.dataset.hover == "true" ? false : true;
    this.centerNode = this.diagramParent.querySelector("div[data-id='deviceHolderParent']");
    LinearDiagram.prototype.setupAnimation.call(this, animationType, callback);
    let arrPoints = Array.from(this.centerNode.querySelectorAll("[id*='-point']"));
    this.diagramParent.style.opacity = 1;
    arrPoints.map(
        function (point) {
            if (this.subtype && this.subtype != "process") point.style.transition = "all 0.5s";
            this.animateSvgShape(point, "hide", true);
            if (this.subtype && this.subtype != "process" && !point.classList.contains("clsEmphasisEnabled")) point.style.filter = "url(#hoverfilter)";
        }.bind(this)
    );
};

SimpleNonLinearDiagram.prototype.initPresent = function (currentSlide, boolNoAnimation = false) {
    if (this.subtype && this.subtype == "process") {
        return LinearDiagram.prototype.initPresent.call(this, currentSlide, boolNoAnimation);
    }
    if (boolNoAnimation) return { isTitleAnimation: false, isGraphicAnimation: false };
    this.diagramParent = currentSlide.querySelector("[id='diagramparent']");

    let animationType = this.diagramParent.parentElement.dataset.animationtype;
    if (animationType != "all") {
        this.arrDiagramNode.map((node) => {
            let nodeParent = node.getNodeParent().parentElement;
            nodeParent.removeAttribute("data-animation");
            nodeParent.classList.remove("moodanimation");
            let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
            arrObj.map((item) => {
                item.removeAttribute("data-animation");
                item.classList.remove("moodanimation");
            });
        });

        this.centerNode = this.diagramParent.querySelector("div[data-id='deviceHolderParent']");
        let arrPoints = Array.from(this.centerNode.querySelectorAll("[id*='-point']"));
        arrPoints.map(
            function (point) {
                let connectorline = point.querySelector("[id*='-connector']");
                if (connectorline) {
                    connectorline.removeAttribute("data-animation");
                    connectorline.classList.remove("moodanimation");
                }
            }.bind(this)
        );
    }

    if (this.diagramParent.parentElement.dataset.animationtype && this.diagramParent.parentElement.dataset.animationtype == "none") return { isTitleAnimation: false, isGraphicAnimation: false };

    if (this.diagramParent) this.diagramParent.style.opacity = 0;

    if (animationType != "all") this.diagramParent.classList.add("clsNonHover");
    let isGraphicAnimation = animationType == "all" ? true : false;
    return { isTitleAnimation: true, isGraphicAnimation: true };
};

SimpleNonLinearDiagram.prototype.animateAfterMoodDelay = function () {
    let moodAnimationDisable = this.diagramParent.parentElement.dataset.moodanimation;
    this.animationFactor = moodAnimationDisable && moodAnimationDisable == "none" ? 0 : 1;
    this.diagramParent.style.transition = `all ${0.3 * this.animationFactor}s`;
    this.diagramParent.style.opacity = 1;
    this.animationCompleteCallback?.fn?.(this.animationCompleteCallback.params);
};

SimpleNonLinearDiagram.prototype.animateSvgShape = function (point, animation, isSetup = false) {
    let shape = point.querySelector("[id*='-shape']");
    let connectorline = point.querySelector("[id*='-connector']");
    let icon = point.querySelector("[id*='-icon']");
    let placeholder = point.querySelector("[id*='-placeholder']");
    let animationFactor = isSetup ? 0 : 1;

    if (point && this.subtype && this.subtype == "process") {
        point.style.transition = `all ${0.5 * animationFactor}s`;
        point?.style.setProperty("opacity", animation == "show" ? 1 : 0, "important");
    }

    if (shape && this.svgPointShapAnimatable) {
        shape?.style.setProperty("opacity", animation == "show" ? 1 : 0, "important");
    }
    if (connectorline) {
        connectorline?.style.setProperty("opacity", animation == "show" ? 1 : 0, "important");
    }
    if (icon) {
        icon?.style.setProperty("opacity", animation == "show" ? 1 : 0, "important");
    }
    if (placeholder) {
        placeholder?.style.setProperty("opacity", animation == "show" ? 1 : 0, "important");
    }
};

SimpleNonLinearDiagram.prototype.animateArrowForward = function (index) {
    let arrPoints = Array.from(this.centerNode.querySelectorAll("[id*='-point']"));
    if (this.subtype && this.subtype == "process") {
        return this.animateArrowForwardProcess(index);
    }
    let arrSelectedPoint = arrPoints.filter(
        function (point, i) {
            let isSelectedNode = point.id.includes("-point" + (index + 1) + "");
            let pointIndex = parseInt(point.id.split("-")[1].match(/\d/g)[0]);
            if (this.animationType == "one") {
                if (!this.isEmphasisEnable) {
                    point.style.filter = "url(#hoverfilter)";
                    point.style.setProperty("-webkit-filter", "url(#hoverfilter)");
                    if (this.arrDiagramNode[pointIndex - 1]) this.arrDiagramNode[pointIndex - 1].getNodeParent().style.filter = "grayscale(1)";
                    if (isSelectedNode) {
                        point.style.filter = "none";
                        if (this.arrDiagramNode[pointIndex - 1]) this.arrDiagramNode[pointIndex - 1].getNodeParent().style.filter = "none";
                    }
                }
                this.animateSvgShape(point, "hide");
            } else if (!this.isEmphasisEnable) {
                point.style.filter = "url(#hoverfilter)";
                if (this.arrDiagramNode[pointIndex - 1]) this.arrDiagramNode[pointIndex - 1].getNodeParent().style.filter = "grayscale(1)";
                if (pointIndex - 1 <= index) {
                    point.style.filter = "none";
                    if (this.arrDiagramNode[pointIndex - 1]) this.arrDiagramNode[pointIndex - 1].getNodeParent().style.filter = "none";
                }
            }
            return isSelectedNode;
        }.bind(this)
    );

    arrSelectedPoint.map(
        function (point) {
            this.animateSvgShape(point, "show");
        }.bind(this)
    );
};

SimpleNonLinearDiagram.prototype.animateArrowForwardProcess = function (index) {
    let arrPoints = Array.from(this.centerNode.querySelectorAll("[id*='-point']"));
    let arrSelectedPoint = arrPoints.filter(
        function (point) {
            if (this.animationType == "one") this.animateSvgShape(point, "hide");
            return point.id.includes("-point" + (index + 1) + "");
        }.bind(this)
    );
    arrSelectedPoint.map(
        function (point) {
            this.animateSvgShape(point, "show");
        }.bind(this)
    );
};

SimpleNonLinearDiagram.prototype.animateArrowBackward = function (index) {
    let arrPoints = Array.from(this.centerNode.querySelectorAll("[id*='-point']"));
    if (this.subtype && this.subtype == "process") {
        return this.animateArrowBackwardProcess(index);
    }
    let arrSelectedPoint = arrPoints.filter(
        function (point) {
            let isSelectedNode = point.id.includes("-point" + (index + 1) + "");
            let pointIndex = parseInt(point.id.split("-")[1].match(/\d/g)[0]);
            if (this.animationType == "one") {
                if (!this.isEmphasisEnable) {
                    point.style.filter = "url(#hoverfilter)";
                    if (this.arrDiagramNode[pointIndex - 1]) this.arrDiagramNode[pointIndex - 1].getNodeParent().style.filter = "grayscale(1)";
                    if (isSelectedNode) {
                        point.style.filter = "none";
                        if (this.arrDiagramNode[pointIndex - 1]) this.arrDiagramNode[pointIndex - 1].getNodeParent().style.filter = "none";
                    }
                }
                this.animateSvgShape(point, "hide");
            } else if (!this.isEmphasisEnable) {
                point.style.filter = "url(#hoverfilter)";
                if (this.arrDiagramNode[pointIndex - 1]) this.arrDiagramNode[pointIndex - 1].getNodeParent().style.filter = "grayscale(1)";
                if (pointIndex < index + 1) {
                    point.style.filter = "none";
                    if (this.arrDiagramNode[pointIndex - 1]) this.arrDiagramNode[pointIndex - 1].getNodeParent().style.filter = "none";
                }
            }
            return isSelectedNode;
        }.bind(this)
    );
    arrSelectedPoint.map(
        function (point) {
            if (this.animationType == "one") this.animateSvgShape(point, "show");
            else this.animateSvgShape(point, "hide");
        }.bind(this)
    );
};

SimpleNonLinearDiagram.prototype.animateArrowBackwardProcess = function (index) {
    let arrPoints = Array.from(this.centerNode.querySelectorAll("[id*='-point']"));
    let arrSelectedPoint = arrPoints.filter(
        function (point) {
            point.style.transition = "all 0.5s";
            if (this.animationType == "one") this.animateSvgShape(point, "hide");
            return point.id.includes("-point" + (index + 1) + "");
        }.bind(this)
    );
    arrSelectedPoint.map(
        function (point) {
            if (this.animationType == "one") this.animateSvgShape(point, "show");
            else this.animateSvgShape(point, "hide");
        }.bind(this)
    );
};

SimpleNonLinearDiagram.prototype.updateAllNodesInOneAtTime = function (direction) {
    LinearDiagram.prototype.updateAllNodesInOneAtTime.call(this, direction);
    let arrPoints = Array.from(this.centerNode.querySelectorAll("[id*='-point']"));
    if (this.isEmphasisEnable) {
        arrPoints.map(
            function (point, i) {
                this.animateSvgShape(point, direction == "next" ? "show" : "hide");
            }.bind(this)
        );
        return;
    }

    arrPoints.map(
        function (point, i) {
            point.style.filter = "none";
            this.animateSvgShape(point, direction == "next" ? "show" : "hide");
            let node = this.arrDiagramNode[i];
            if (node) node.getNodeParent().style.filter = "none";
        }.bind(this)
    );
};

SimpleNonLinearDiagram.prototype.switchContentBetweenNodeAndSvg = function (type, index) {
    let deviceHolder = this.diagramParent.querySelector("[data-id='deviceHolder']");
    if (!deviceHolder) return;

    let node = this.arrDiagramNode[index];
    let nodeParent = node && node.parentNode && node.parentNode.parentElement;
    if (!nodeParent) return;
    // let index = parseInt(nodeParent.dataset.index);
    let pointNode = deviceHolder.querySelector("[id*='-point" + (index + 1) + "']");
    if (!pointNode) return;
    let placeHolder = pointNode.querySelector("[id*='-placeholder']");
    let pointShape = pointNode.querySelector("[id*='-shape']");
    let pointNoneShape = pointNode.querySelector("[id*='-noneshape']");
    if (pointShape && pointNoneShape) {
        pointShape.style.display = type == "icon" || type == "sequence" ? "block" : "none";
        pointNoneShape.style.display = type == "icon" || type == "sequence" ? "none" : "block";
    }
    if (placeHolder) {
        placeHolder.style.display = type == "icon" || type == "sequence" ? "flex" : "none";
        this.diagramParent.setAttribute("data-nomargin", type == "icon" || type == "sequence" || type == "none" ? "true" : "false");

        let content = nodeParent.querySelector("[data-type='diagramContentNode']");
        if (content) content.style.setProperty("display", type == "icon" || type == "sequence" || type == "none" ? "none" : "flex");
    } else {
        this.diagramParent.setAttribute("data-nomargin", "false");
        return;
    }
};

//Emphasize

SimpleNonLinearDiagram.prototype.emphasize = function (emphasizeData) {
    LinearDiagram.prototype.emphasize.call(this, emphasizeData);
    this.updateNonLinearEmphasize();
};

SimpleNonLinearDiagram.prototype.updateEmphasize = function () {
    LinearDiagram.prototype.updateEmphasize.call(this);
    this.updateNonLinearEmphasize();
};

SimpleNonLinearDiagram.prototype.updateNonLinearEmphasize = function () {
    let centerNode = this.diagramParent.querySelector("[data-id='deviceHolderParent']");
    if (!centerNode) return;
    let arrPath = Array.from(centerNode.querySelectorAll("g[id*='-point']"));
    this.arrDiagramNode.map(
        function (node, i) {
            let nodeParent = node.parentNode.parentElement;
            let path = arrPath.find((grp) => grp.id.endsWith(i + 1));
            if (path) {
                let nodeBGColorOptions = this.nodeProps.bgColor ? this.nodeProps.bgColor.split(",") : [];
                let hasBG = nodeBGColorOptions.length > 1;
                let baseEmphasisClass = this.nodeProps.emphasisClass ? this.nodeProps.emphasisClass : "clsEmphasis";
                let emphasizeDisableClass = hasBG ? baseEmphasisClass + "DisabledBG" : baseEmphasisClass + "Disabled";
                let emphasizeEnableClass = hasBG ? baseEmphasisClass + "EnabledBG" : baseEmphasisClass + "Enabled";
                if (nodeParent && path && nodeParent.classList.contains(emphasizeEnableClass)) {
                    path.classList.remove(emphasizeDisableClass);
                    path.classList.add(emphasizeEnableClass);
                } else if (path && nodeParent.classList.contains(emphasizeDisableClass)) {
                    path.classList.remove(emphasizeEnableClass);
                    path.classList.add(emphasizeDisableClass);
                } else {
                    path.classList.remove("clsEmphasisEnabledBG");
                    path.classList.remove("clsEmphasisEnabled");
                    path.classList.remove("clsEmphasisDisabledBG");
                    path.classList.remove("clsEmphasisDisabled");
                }
            }
        }.bind(this)
    );
};

/**
 * Author:    Bala Krishnan K.
 * Created:   4.5.2020
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function SimpleLinearConnectorNode(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.animateItemCount = 0;
    this.diagramParent.parentElement.setAttribute("data-allowdefaultanimation", "true");
}

SimpleLinearConnectorNode.prototype = Object.create(SimpleLinearDiagram.prototype);
SimpleLinearConnectorNode.prototype.constructor = SimpleLinearConnectorNode;

SimpleLinearConnectorNode.prototype.initDiagramCreation = function () {
    if (!this.diagramParent.dataset.contenttype) {
        this.diagramParent.setAttribute("data-contenttype", this.diagramData.properties.contenttype);
        this.setHolderType(this.diagramData.properties.contenttype, "contentNode");
    }
    this.diagramParent.innerHTML = "";
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.createPatternBackGround();
    this.diagramRenderComplete();
};

SimpleLinearConnectorNode.prototype.createElements = function () {
    SimpleLinearDiagram.prototype.createElements.call(this);
    let parentDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    let centerNodeStyle = this.nodeProps.centerNodeStyle;
    this.getConnectorVariables();
    parentDiv.className = "clsNodesHolderConnector " + centerNodeStyle + " " + this.connectorcolor;
    parentDiv.style.setProperty("--connectorHolderHeight", this.connectorheight);
    this.diagramParent.setAttribute("data-connectoralign", this.connectoralign);
    this.diagramParent.setAttribute("data-connectortype", this.connectortype);
    this.createConnectorHolder(parentDiv);
};

SimpleLinearConnectorNode.prototype.getConnectorVariables = function () {
    this.connectortype = this.nodeProps?.connector?.flowloop ? "flowloop" : "hierarchy";
    this.connectoralign = this.nodeProps?.connector?.[this.connectortype]?.align || "bottom";
    this.connectorheight = this.nodeProps?.connector?.[this.connectortype]?.height || "50%";
    this.connectorspacing = this.nodeProps?.connector?.[this.connectortype]?.spacebetween;
    this.connectortopbottomgap = this.nodeProps?.connector?.[this.connectortype]?.topbottomgap || 20;
    // this.strokeWidth = this.nodeProps?.connector?.[this.connectortype].strokewidth || 2;
    this.connectorcolor = this.nodeProps?.connector?.[this.connectortype]?.color;
    if (this.nodeProps?.connector?.[this.connectortype]?.rounded) {
        this.connectorrounded = this.nodeProps?.connector?.[this.connectortype]?.rounded[0];
        this.connectorroundedradius = parseFloat(getComputedStyle(this.diagramParent.parentElement.parentElement.parentElement).getPropertyValue("--mood-secondary-borderradius").trim()) || this.nodeProps?.connector?.[this.connectortype]?.rounded[1] || 15;
    }
    this.strokeWidth = 3;
    if (this.connectortype == "hierarchy") {
        this.strokeWidth = parseFloat(getComputedStyle(this.diagramParent.parentElement.parentElement.parentElement).getPropertyValue("--hierarchyStrokeWidth").trim()) || 3;
    } else {
        let pattenDiv = this.diagramParent.querySelector("[name='nodesHolder']");
        let connectorParent = pattenDiv.querySelector("[name='connectorparent']");
        if (connectorParent) this.strokeWidth = parseFloat(getComputedStyle(connectorParent).getPropertyValue("--arrowcssHeight").trim()) || 3;
        pattenDiv.style.setProperty("--strokeWidth", this.strokeWidth + "px");
    }
};

SimpleLinearConnectorNode.prototype.createCenterHolder = function (pattenDiv, contentData = { id: "", value: "", contenttype: "text", type: "text" }) {
    let centerItem = new window[this.nodeProps?.centerNode && this.nodeProps.centerNode.length > 1 ? "CommonDiagramNode" : this.nodeProps.nodeclassName](
        pattenDiv,
        {},
        this.centerholderdata ? this.centerholderdata : { content: {} },
        this.eventManagerXY,
        0,
        "",
        this.objStyleData,
        this.appStaticURL,
        this.nodeProps,
        this.diagramParent
    );
    centerItem.moodData = this.moodData;
    centerItem.moodName = this.moodName;
    centerItem.updateCallBack = this.updateCallBack;
    centerItem.searchIconCallBack = this.searchIconCallBack;
    centerItem.bgDeviceDiv = this.bgDeviceDiv;
    centerItem.arrDefaults = this.arrDefaults;
    centerItem.globalMoodData = this.globalMoodData;
    centerItem.arrTintArray = this.arrTintArray;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;
    this.centerHolderNode = centerItem;
    let centerNode = centerItem.createCenterNode(pattenDiv);
    this.centerHolderNode.nodeGroup = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    this.updatePropsCallBack();
    return centerNode;
};

SimpleLinearConnectorNode.prototype.recreateElementData = function (contentData = { id: "", value: "", contenttype: "image" }) {
    SimpleLinearDiagram.prototype.recreateElementData.call(this);
    this.getConnectorVariables();
    let pattenDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    let centerItem = new window[this.nodeProps.nodeclassName](pattenDiv, {}, this.centerholderdata ? this.centerholderdata : { content: {} }, this.eventManagerXY, 0, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
    centerItem.moodData = this.moodData;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;
    this.centerHolderNode = centerItem;
    this.centerHolderNode.parentNode = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    this.centerHolderNode.nodeGroup = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    this.centerNode = this.diagramParent.querySelector("div[data-id='deviceHolderParent']");
    // this.updatePropsCallBack();
};

SimpleLinearConnectorNode.prototype.createConnectorHolder = function (parentDiv) {
    let centerHolderParent = document.createElement("div");
    centerHolderParent.setAttribute("data-id", "connectorHolderParent");
    centerHolderParent.setAttribute("name", "holderParent");
    centerHolderParent.className = "connectorHolderParent";
    parentDiv.appendChild(centerHolderParent);

    let svgConnectorParent = document.createElement("div");
    svgConnectorParent.setAttribute("data-id", "svgConnectorParent");
    svgConnectorParent.setAttribute("name", "svgConnectorParent");
    svgConnectorParent.className = "svgConnectorParent moodanimation";
    svgConnectorParent.setAttribute("data-animation", "connector");

    centerHolderParent.appendChild(svgConnectorParent);
    this.drawCustomConnector();

    if (this.nodeProps.centerNode) {
        let holderParent = this.createCenterHolder(centerHolderParent);
        holderParent.classList.add("moodanimation");
        holderParent.setAttribute("data-animation", "primarytext");
        let imageHolder = holderParent.querySelector("[id*='imageHolder']");
        if (imageHolder) {
            imageHolder.setAttribute("data-focus-parent", "centerHolderParent");
            let imgNode = holderParent.querySelector("img[data-id='imageNode'],img[data-id='logoNode']");
            if (imgNode) CommonImageUtils.updateImageBounds(imgNode, { islogofit: true, contenttype: "logo" }, 1);
        }
        let arrTextNodes = holderParent.querySelectorAll("[data-default-event='true']");
        arrTextNodes.forEach((element) => {
            element.setAttribute("floaterdisableall", "true");
        });
    }
    this.centerCommonTextNode();
    // setTimeout(() => {
    // SimpleLinearDiagram.prototype.resetHolderWidth.call(this);
    // this.diagramRenderComplete();
    // }, 0);
};

SimpleLinearConnectorNode.prototype.updateNodeData = function (nodeData, type, index, parentId) {
    if (parentId && parentId.includes("centerHolderParent")) {
        this.centerHolderNode.objData.content = nodeData;
        this.centerholderdata = this.centerHolderNode.objData;
    }
    if (this.arrDiagramNode && this.arrDiagramNode.length > index) {
        this.arrDiagramNode[index].updateContentData(nodeData, type, parentId);
    }
};

SimpleLinearConnectorNode.prototype.getCenterHolderData = function () {
    try {
        let parent = this.diagramParent.querySelector("[data-id='centerHolderParent']");
        if (parent) {
            this.centerholderdata = this.centerHolderNode?.getJSONData?.();
            this.centerHolderNode.objData = this.centerholderdata;
        }
    } catch (error) {
        console.log(error);
    }
    return this.centerholderdata || {};
};

SimpleLinearConnectorNode.prototype.addNode = function (nodeJSON, index, isFromUndo = false) {
    SimpleLinearDiagram.prototype.addNode.call(this, nodeJSON, index, isFromUndo);
    this.resetHolderWidth();
};

SimpleLinearConnectorNode.prototype.deleteNode = function (targetIndex) {
    SimpleLinearDiagram.prototype.deleteNode.call(this, targetIndex);
    this.resetNodeAttributes();
    this.resetHolderWidth();
};

SimpleLinearConnectorNode.prototype.diagramPasteHandler = function (event) {
    SimpleLinearDiagram.prototype.diagramPasteHandler.call(this, event);
    this.resetHolderWidth();
    if (event.target.parentElement.parentElement.getAttribute("name") == "centerHolderParent") {
        this.centerCommonTextNode();
        this.centerHolderNode.objData.content.value = event.target.textContent;
    }
};

SimpleLinearConnectorNode.prototype.defaultFoucsOut = function (event) {
    let canPerformFocusOut = this.isDifferentText(event.target);
    if (canPerformFocusOut) {
        if (event.target.parentElement.parentElement.getAttribute("name") == "centerHolderParent") {
            this.centerCommonTextNode();
        }
        SimpleLinearDiagram.prototype.defaultFoucsOut.call(this, event);
        this.resetHolderWidth();
    }
};

SimpleLinearConnectorNode.prototype.centerCommonTextNode = function () {
    if (this.connectortype == "flowloop") {
        let centerHolderParent = this.diagramParent.querySelector("[data-id='centerHolderParent']");
        centerHolderParent.style[this.connectoralign] = -centerHolderParent.clientHeight / 2 + this.strokeWidth / 2 + "px";
    }
};

SimpleLinearConnectorNode.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    if (!mainProperties.floateroptionsdisable) mainProperties.floateroptionsdisable = [];
    mainProperties.floateroptionsdisable.push("animateoneatatime");
    mainProperties.floateroptionsdisable.push("content", "contentoptions");
    if (this.connectortype == "hierarchy") {
        mainProperties.floateroptionsdisable.push("connector");
        mainProperties.floateroptionsdisable.push("seperatorline");
    }
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

SimpleLinearConnectorNode.prototype.drawCustomConnector = function () {
    let length = this.arrDiagramNode.length - 1;
    let connectorNode = this.diagramParent.querySelector("[data-id='svgConnectorParent']");
    connectorNode.innerHTML = "";
    let svg = DiagramNodeUtils.createSVGElement("svg");
    svg.setAttribute("class", "svgLine");
    svg.setAttribute("data-id", "svgConnectorLine");
    connectorNode.appendChild(svg);
    this.connectortype = this.nodeProps?.connector?.flowloop ? "flowloop" : "hierarchy";
    this.connectoralign = this.nodeProps?.connector?.[this.connectortype]?.align || "bottom";
    this.renderPaths(svg, this.connectoralign, length, connectorNode);
};

SimpleLinearConnectorNode.prototype.setDiagramSpecficOption = function (obj) {
    obj.dpcontent.slidecomponent = { bgImage: false, takeAwayText: false };
    obj.isDisableLayoutOption = "true";
};

SimpleLinearConnectorNode.prototype.renderPaths = function (svg, align = "bottom", length, connectorNode) {
    let node = this.diagramParent.querySelector("[name='nodeMainParent']");
    let moodGap = getComputedStyle(this.diagramParent.parentElement.parentElement.parentElement).getPropertyValue("--diagramHorNodeGap").trim();
    let nodeHeight = node.clientHeight;
    this.diagramParent.style.setProperty("--nodeHeight", nodeHeight);
    let gap = moodGap && moodGap != "" ? parseInt(moodGap) : this.nodeProps?.connector?.gap;
    if (align == "bottom") svg.parentElement.style.transform = "scaleY(-1)";
    let arrowHeadHeight = parseFloat(getComputedStyle(node.parentElement).getPropertyValue("--arrowHeight").trim());
    try {
        node.parentElement.style.setProperty("--connectorOpacity", this.nodeProps.connector?.opacity || 0.5);
    } catch (error) {
        node.parentElement.style.setProperty("--connectorOpacity", 0.5);
    }
    // Create common arrow head to use both in flowloop and hierarchy types
    let arrowMiddle = document.createElement("div");
    arrowMiddle.setAttribute("data-id", "arrowCommon");
    connectorNode.appendChild(arrowMiddle);
    DiagramUtils.addClassList(connectorNode, this.nodeProps.connector.class);

    if (this.connectortype == "flowloop") {
        let pathBase = DiagramNodeUtils.createSVGElement("path");
        pathBase.setAttribute("data-id", "pathConnectorLoop");
        pathBase.setAttribute("id", "pathConnectorLoop");
        pathBase.setAttribute("class", "pathLine");
        this.diagramParent.style.setProperty("--flowLoopRadius", (this.connectorroundedradius || 0) + "px");
        svg.appendChild(pathBase);
        let loopdirection = this.diagramParent.getAttribute("data-connectorstyle");
        let flowLoopObj = this.nodeProps.connector.flowloop;
        let flowTopOffset = flowLoopObj.topoffset || 0;
        let flowStartOffset = flowLoopObj.startoffset || 0;
        let flowStartGap = loopdirection == "arrownone" ? 0 : flowLoopObj.startgap || 0;
        this.diagramParent.style.setProperty("--nodeGap", flowStartOffset + flowStartGap + "px");
        let anchor = this.nodeProps.connector.anchor;
        this.loopdirection = loopdirection == "arrowleft" ? "reverse" : "forward";
        let nodeName = DiagramNodeUtils.getNodeFromMenuNodeName(anchor);
        // let anchorNode = node.querySelector(`[name='${nodeName}']`);
        let anchorNode = node.querySelector(`[name='nodeGroup']`);
        let connectorPlainNode = node.querySelector("[id='connectorparent0']") || node.querySelector("[id='connectorparent1']");
        let topValue = anchorNode.offsetTop + anchorNode.clientHeight / 2 + connectorPlainNode.clientHeight / 2;
        topValue = nodeName == "nodeparent" || nodeName == "nodeGroup" || nodeName == "contentNode" ? 0 : topValue;
        if (align == "bottom" && topValue != 0) node.parentElement.style.setProperty("--connectorHolderHeight", node.clientHeight + flowTopOffset + "px");
        else node.parentElement.style.setProperty("--connectorHolderHeight", topValue + anchorNode.clientHeight + flowTopOffset + "px");
        node.parentElement.style.setProperty("--flowTopOffset", flowTopOffset + "px");
        // let anchorOffset = nodeName == "contentNode"?  (node.clientHeight - node.querySelector(`[name='${nodeName}']`)?.clientHeight/2 - this.strokeWidth/2) : nodeHeight / 2;
        let anchorContent = node.querySelector(`[name='${nodeName}']`);
        let anchorOffset = nodeName == "contentNode" ? (align == "bottom" ? anchorContent?.clientHeight / 2 : node.clientHeight - anchorContent?.clientHeight / 2) : nodeHeight / 2;
        let roundedRadius = this.connectorroundedradius || 6;
        let allConnectorRound = this.connectorrounded && this.connectorrounded == "all";
        let point1 = { x: flowStartOffset - (loopdirection == "arrowright" ? this.strokeWidth / 2 : 0), y: connectorNode.clientHeight - anchorOffset - this.strokeWidth / 2 };
        let point2 = { x: this.strokeWidth / 2, y: connectorNode.clientHeight - anchorOffset - this.strokeWidth / 2, rounded: allConnectorRound };
        let point3 = { x: this.strokeWidth / 2, y: this.strokeWidth, rounded: allConnectorRound };
        let point4 = { x: connectorNode.clientWidth - this.strokeWidth / 2, y: this.strokeWidth, rounded: allConnectorRound };
        let point5 = { x: connectorNode.clientWidth - this.strokeWidth / 2, y: connectorNode.clientHeight - anchorOffset - this.strokeWidth / 2, rounded: allConnectorRound };
        let point6 = { x: connectorNode.clientWidth - this.strokeWidth / 2 - flowStartOffset + (loopdirection == "arrowleft" ? this.strokeWidth / 2 : 0), y: connectorNode.clientHeight - anchorOffset - this.strokeWidth / 2 };
        let svgPath = DiagramUtils.createLineOrRoundedPathString([point1, point2, point3, point4, point5, point6], roundedRadius);
        pathBase.setAttribute("d", svgPath);
        connectorNode.parentElement.style[align == "bottom" ? "marginTop" : "marginBottom"] = (topValue != 0 ? -topValue : -anchorNode.clientHeight) - (align == "bottom" ? 2 * this.strokeWidth : topValue == 0 ? this.strokeWidth : -arrowHeadHeight) + "px";
        if (align == "bottom" && topValue != 0) {
            connectorNode.parentElement.style["marginTop"] = -(node.clientHeight - topValue) - arrowHeadHeight - this.strokeWidth / 2 + "px";
        }
        arrowMiddle.className = loopdirection == "arrowright" ? "arrow arrowRight clsarrowrightflowloop" : loopdirection == "arrowleft" ? "arrow arrowLeft clsarrowleftflowloop" : "";
        arrowMiddle.style.top = "calc(" + (connectorNode.clientHeight - anchorOffset) + "px  - var(--strokeWidth)/2)";
        arrowMiddle.style[loopdirection == "arrowright" ? "left" : "right"] = flowStartOffset + "px";
        arrowMiddle.style.position = "absolute";
        this.setMoodArrowHead(arrowMiddle);
    } else if (this.connectortype == "hierarchy") {
        connectorNode.style.width = "100%";
        if (!this.connectorspacing) {
            arrowMiddle.setAttribute("data-id", "arrowTop");
            arrowMiddle.className = "arrow arrowTop TMAlign clsarrowrighttop";
            arrowMiddle.style.top = this.connectortopbottomgap + this.strokeWidth / 2 + "px";
            this.setMoodArrowHead(arrowMiddle);
        }

        // this.setCssArrowHead(arrowMiddle);

        for (let index = 0; index < length + 1; index++) {
            let offsetX = (gap + node.clientWidth) * index + node.clientWidth / 2;
            let arrow = document.createElement("div");
            arrow.setAttribute("data-id", "arrowBottom");
            arrow.setAttribute("id", "arrowBottom" + index);
            let className = "clsarrowrightbottom";
            arrow.className = "arrow arrowBottom " + className;
            arrow.style.position = "absolute";
            connectorNode.appendChild(arrow);
            // this.setCssArrowHead(arrow);
            this.setMoodArrowHead(arrow);
            let pathBaseleft = DiagramNodeUtils.createSVGElement("path");
            pathBaseleft.setAttribute("data-id", "pathConnector");
            pathBaseleft.setAttribute("id", "pathConnector" + index);
            pathBaseleft.setAttribute("class", "pathLine");
            svg.appendChild(pathBaseleft);
            let roundedRadius = this.connectorroundedradius || 6;
            let allConnectorRound = this.connectorrounded && this.connectorrounded == "all";
            let edgesRound = this.connectorrounded && this.connectorrounded == "edges";
            let odd = (length + 1) % 2 == 1;
            let middleConnector = odd && index + 1 == ((length + 1) / 2).toFixed();
            // if (this.connectorspacing) middleConnector = false;
            let xCoord = [
                middleConnector ? connectorNode.clientWidth / 2 - this.strokeWidth / 2 : offsetX - this.strokeWidth / 2,
                connectorNode.clientWidth / 2 - this.strokeWidth / 2 + (this.connectorspacing ? (parseInt(this.connectorspacing) * (length - index) * -1) / 2 + ((this.strokeWidth / 2) * length + 1 + (parseInt(this.connectorspacing) / 2) * length) / 2 : 0),
            ];
            let spaceTopOffset = index == 0 || index == length;
            let yCoord = [connectorNode.clientHeight - this.connectortopbottomgap, connectorNode.clientHeight / 2 - (this.connectorspacing ? (length + 1 > 3 ? (parseInt(this.connectorspacing) * (spaceTopOffset ? 2 : 1)) / 2 - parseInt(this.connectorspacing) : 0) : 0), arrowHeadHeight / 2 + this.connectortopbottomgap];
            let point1 = { x: middleConnector && this.connectorspacing ? xCoord[1] : xCoord[0], y: yCoord[0] };
            let point2 = {
                x: middleConnector && this.connectorspacing ? xCoord[1] : xCoord[0],
                y: yCoord[1],
                rounded: !middleConnector && ((edgesRound && index == 0) || (edgesRound && index == length) || allConnectorRound) ? true : false,
            };
            let point3 = {
                x: xCoord[1],
                y: yCoord[1],
                rounded: !middleConnector && allConnectorRound,
            };
            let point4 = { x: xCoord[1], y: yCoord[2] };
            let svgPath = DiagramUtils.createLineOrRoundedPathString([point1, point2, point3, point4], roundedRadius);
            pathBaseleft.setAttribute("d", svgPath);
            arrow.style.bottom = this.connectortopbottomgap - this.strokeWidth / 2 + "px";
            arrow.style.left = point1.x + "px";
            if (this.connectorspacing) {
                let arrow = document.createElement("div");
                arrow.setAttribute("data-id", "arrowTop");
                arrow.setAttribute("id", "arrowTop" + index);
                arrow.className = "arrow arrowTop TMAlign clsarrowrighttop";
                arrow.style.position = "absolute";
                arrow.style.top = this.connectortopbottomgap + this.strokeWidth / 2 + "px";
                arrow.style.left = point3.x + "px";
                connectorNode.appendChild(arrow);
                // this.setCssArrowHead(arrow);
                this.setMoodArrowHead(arrow);
            }
        }
    }
};

SimpleLinearConnectorNode.prototype.setMoodArrowHead = function (arrow) {
    let arrowHolderNode = document.createElement("div");
    DiagramNodeUtils.assignAttributes(arrowHolderNode, {
        name: "arrowHolderNode",
        class: "arrowHolderNode",
        id: "arrowHolderNode" + 0,
        "data-id": "arrowHolderNode",
    });
    arrow.appendChild(arrowHolderNode);

    let arrowNode = document.createElement("div");
    DiagramNodeUtils.assignAttributes(arrowNode, {
        name: "arrowNode",
        class: "arrowNode ",
        id: "arrowNode0",
        "data-id": "arrowNode",
    });
    arrowHolderNode.appendChild(arrowNode);
};

SimpleLinearConnectorNode.prototype.setCssArrowHead = function (arrow) {
    let arrowHolder = document.createElement("div");
    DiagramNodeUtils.assignAttributes(arrowHolder, {
        name: "arrowHolderNode",
        class: "arrowHolderNode",
        id: "arrowHolderNodeStart",
        "data-id": "arrowHolderNode",
    });
    let arrowNode = document.createElement("div");
    DiagramNodeUtils.assignAttributes(arrowNode, {
        name: "arrowNode",
        class: "arrowNode " + (this.nodeProps.connector && this.nodeProps.connector.colorClass ? this.nodeProps.connector.colorClass : "accent1-bg-color"),
        id: "arrowNode0",
        "data-id": "arrowNode",
    });
    arrowHolder.appendChild(arrowNode);
    arrow.appendChild(arrowHolder);
};

SimpleLinearConnectorNode.prototype.resetHolderWidth = function () {
    SimpleLinearDiagram.prototype.resetHolderWidth.call(this);
    this.drawCustomConnector();
    // this.changeLogoSize(this.diagramData.properties.logosize);
};

SimpleLinearConnectorNode.prototype.initPresent = function (currentSlide, boolNoAnimation = false) {
    if (boolNoAnimation) return { isTitleAnimation: false, isGraphicAnimation: false };
    this.diagramParent = currentSlide.querySelector("[id='diagramparent']");

    if (this.diagramParent.parentElement.dataset.animationtype && this.diagramParent.parentElement.dataset.animationtype == "none") return { isTitleAnimation: false, isGraphicAnimation: false };

    if (this.diagramParent) this.diagramParent.style.opacity = 0;
    let animationType = this.diagramParent.parentElement.dataset.animationtype;

    if (animationType != "all") this.diagramParent.classList.add("clsNonHover");
    // let isGraphicAnimation = animationType == "all" ? true : false;
    this.diagramParent.classList.add("clsNonHover");
    this.arrDiagramNode.map((node) => {
        let nodeParent = node.getNodeParent().parentElement;
        nodeParent.removeAttribute("data-animation");
        nodeParent.classList.remove("moodanimation");
        let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
        arrObj.map((item) => {
            item.removeAttribute("data-animation");
            item.classList.remove("moodanimation");
        });
    });
    let isGraphicAnimation = false;
    return { isTitleAnimation: true, isGraphicAnimation: isGraphicAnimation };
};

SimpleLinearConnectorNode.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    let centerNode = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    let isCenterChild = elTarget && elTarget?.dataset?.id == "centerHolderParent" ? elTarget : centerNode ? this.isChildOfParent(elTarget, centerNode) : false;

    if (isCenterChild) {
        let objContentSwap = this.getSeletion(strSelectionType, "centerNode");
        if (objContentSwap != null && Object.keys(objContentSwap).length > 0) {
            let { options, selectedindex } = this.getSeletion(centerNode.dataset.contentType, "centerNode");
            dict.contentswap = {
                dpsource: options,
                selectedindex: selectedindex,
                floaterproperty: "contentChange",
                visible: options.length > 1 ? true : false,
            };
        }
        elTarget.setAttribute("data-focus-parent", "centerHolderParent");
        dict[FloaterConstants.DELETE_ASSET] = null;
        dict[FloaterConstants.HIGHLIGHT] = null;
        dict.changesize = null;
    }
};
// SimpleLinearConnectorNode.prototype.setupOneAtTimeAnimation = function (animationType = "one", callback) {
SimpleLinearConnectorNode.prototype.setupAnimation = function (animationType = "one", callback) {
    this.connectortype = this.nodeProps?.connector?.flowloop ? "flowloop" : "hierarchy";
    this.connectoralign = this.nodeProps?.connector?.[this.connectortype]?.align || "bottom";
    this.animationCompleteCallback = callback;
    this.animationType = animationType;
    let centerParent = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    centerParent.style.opacity = 0;

    if (this.connectortype == "hierarchy") {
        let pathLines = this.diagramParent.querySelectorAll("[class*='pathLine']");
        pathLines.forEach((element) => {
            element.style.opacity = 0;
        });
        let arrows = this.diagramParent.querySelectorAll("[class*='arrowBottom'],[class*='arrowTop']");
        arrows.forEach((element) => {
            element.style.opacity = 0;
        });
    } else if (this.connectortype == "flowloop") {
        this.loopdirection = this.diagramData.properties.connectorstyle == "arrowleft" ? "reverse" : "forward";
        let svgConnectorParent = this.diagramParent.querySelector("[data-id='connectorHolderParent']");
        let arrConnectorParent = this.diagramParent.querySelectorAll("[data-id='connectorparent']");
        svgConnectorParent.style.opacity = 0;
        arrConnectorParent.forEach((element) => {
            element.style.opacity = 0;
        });
    }

    this.arrConnector = Array.from(this.diagramParent.querySelectorAll("[name='connectorparent']"));
    this.arrConnector.map((connector) => (connector.style.opacity = 0));
    this.isReversAnimation = this.loopdirection && this.loopdirection == "reverse";

    // if (this.isReversAnimation) {
    //     this.arrDiagramNode.reverse();
    //     if (this.arrConnector) this.arrConnector.reverse();
    // }

    DiagramAnimateUtil.setupFadeInAnimation(this.arrDiagramNode, this.diagramParent);
    if (this.loopdirection && this.loopdirection == "reverse") this.animationIndex = this.arrDiagramNode.length - 1;
    else this.animationIndex = 0;
    this.animateAfterMoodDelay(animationType);
};

SimpleLinearConnectorNode.prototype.updateAnimationPath = function (type) {
    this.cubicPath = "";
    try {
        this.cubicPath = this.moodData.animationData[type].animation.all.effect;
    } catch (error) {
        this.cubicPath = "";
        console.log("Erro accessind cubicPath animation data SimpleLinearConnectorNode.js");
    }
};

SimpleLinearConnectorNode.prototype.animateAfterMoodDelay = function (animationType) {
    this.diagramParent.style.opacity = 1;
    this.diagramParent.style.transition = "all 0.5s";
    animationType == "all" ? this.playAllAtOnce() : this.playNext();
    if (this.animationType == "all") {
        let time = 1500 * this.arrDiagramNode.length;
        setTimeout(() => {
            if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        }, time);
    } else if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
};

SimpleLinearConnectorNode.prototype.animateCenterHolder = function (type = "show", delay = 0) {
    let opacity = type == "show" ? 1 : 0;
    let centerParent = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    if (this.connectortype == "flowloop" && centerParent.textContent == "") opacity = 0;
    else {
        centerParent.style.transition = "all 0.5s " + delay + "s " + this.cubicPath;
        centerParent.style.opacity = opacity;
    }
};

SimpleLinearConnectorNode.prototype.animateArrowHolder = function (type = "show", delay = 0) {
    let opacity = type == "show" ? 1 : 0;
    let centerParent = this.diagramParent.querySelector("[data-id='connectorHolderParent']");
    centerParent.style.transition = "all 0.5s " + delay + "s " + this.cubicPath;
    centerParent.style.opacity = opacity;
};

SimpleLinearConnectorNode.prototype.animateArrow = function (index, type = "show", delay = 0) {
    let opacity = type == "show" ? 1 : 0;
    let centerParent = this.diagramParent.querySelector("[id='connectorparent" + index + "']");
    if (centerParent) {
        centerParent.style.transition = "all 0.5s " + delay + "s " + this.cubicPath;
        centerParent.style.opacity = opacity;
    }
};

SimpleLinearConnectorNode.prototype.animateArrowPath = function (index, isStart = false, type = "show") {
    // let arrowTop = this.diagramParent.querySelector("[data-id='arrowTop']");
    let arrowTop = this.diagramParent.querySelector("[id='arrowTop" + index + "']");
    let arrowBottom = this.diagramParent.querySelector("[id='arrowBottom" + index + "']");
    let connectorLine = this.diagramParent.querySelector("[id='pathConnector" + index + "']");
    let opacity = type == "show" ? 1 : 0;

    if (connectorLine) {
        connectorLine.style.transition = "all 0.5s " + this.cubicPath;
        connectorLine.style.opacity = opacity;
    }
    if (arrowBottom) {
        arrowBottom.style.transition = "all 0.5s " + this.cubicPath;
        arrowBottom.style.opacity = opacity;
    }
    if (arrowTop) {
        arrowTop.style.transition = "all 0.5s " + this.cubicPath;
        arrowTop.style.opacity = opacity;
    }
};

SimpleLinearConnectorNode.prototype.animateNode = function (index, type = "show", delay = 0) {
    let opacity = type == "show" ? 1 : 0;
    let nodeObj = this.arrDiagramNode[index];
    let node = nodeObj.parentNode.parentElement;
    node.style.transition = "all 0.5s " + delay + "s " + this.cubicPath;
    nodeObj.parentNode.style.opacity = opacity;
    if (nodeObj && nodeObj.getNodeParent().dataset.highlight && nodeObj.getNodeParent().dataset.highlight == "true") {
        this.isShowHighlight = true;
        this.highlightIndex = parseInt(node.dataset.index);
    }
};

SimpleLinearConnectorNode.prototype.setHighlightPosition = function (node, parent) {
    let nodeParent = node.parentElement;
    return { element: nodeParent, alignment: "vertical" };
};

SimpleLinearConnectorNode.prototype.playAllAtOnce = function () {
    if (this.animateItemCount == this.arrDiagramNode.length) return false;
    this.playNext(0, true);
    this.animateItemCount = 1;
    var interval = setInterval(() => {
        if (this.connectortype == "hierarchy" && this.animationCompleteCallback && this.animateItemCount > this.arrDiagramNode.length) {
            this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
            clearInterval(interval);
        } else if (this.connectortype == "flowloop" && this.animationCompleteCallback && this.animateItemCount == this.arrDiagramNode.length) {
            this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
            clearInterval(interval);
        } else this.playNext(0, true);

        this.animateItemCount += 1;
    }, 1000);
    return true;
};

SimpleLinearConnectorNode.prototype.playAllAtOnceReverse = function () {
    for (var i = 0; i < this.arrDiagramNode.length + 1; i++) {
        setTimeout(() => {
            this.playNext();
        }, 500 * i);
    }
    return true;
};

SimpleLinearConnectorNode.prototype.playNext = function (index, isAllAtOnce = false) {
    this.updateAnimationPath("show");
    if (this.connectortype == "hierarchy" && this.connectoralign == "top") {
        if (this.animationIndex > this.arrDiagramNode.length) {
            try {
                if (this.moodData.animationData.isHideAnimation) {
                    // this.diagramParent.style.transition = "all 0.5s " + this.cubicPath;
                    // this.diagramParent.style.opacity = 0;
                }
            } catch (error) {
                console.log("Hide Animation erro :" + error);
            }
            return false;
        }
    } else if (this.connectortype == "flowloop" && this.loopdirection == "reverse") {
        if (this.animationIndex == -1) {
            try {
                if (this.moodData.animationData.isHideAnimation) {
                    // this.diagramParent.style.transition = "all 0.5s " + this.cubicPath;
                    // this.diagramParent.style.opacity = 0;
                }
            } catch (error) {
                console.log("Hide Animation erro :" + error);
            }
            return false;
        }
    } else if (this.animationIndex >= this.arrDiagramNode.length) {
        try {
            if (this.moodData.animationData.isHideAnimation) {
                // this.diagramParent.style.transition = "all 0.5s " + this.cubicPath;
                // this.diagramParent.style.opacity = 0;
            }
        } catch (error) {
            console.log("Hide Animation erro :" + error);
        }
        return false;
    }

    if (this.connectortype == "hierarchy") {
        if (this.connectoralign == "top") {
            if (this.animationIndex == 0) {
                this.animateCenterHolder();
            } else if (this.animationIndex == 1) {
                this.animateArrowPath(this.animationIndex - 1, true);
                this.animateNode(this.animationIndex - 1);
            } else {
                this.animateArrowPath(this.animationIndex - 1);
                this.animateNode(this.animationIndex - 1);
            }
        } else if (this.connectoralign == "bottom") {
            if (this.animationIndex == 0) {
                this.animateNode(this.animationIndex);
                this.animateArrowPath(this.animationIndex, true);
                this.animateCenterHolder();
            } else {
                this.animateArrowPath(this.animationIndex);
                this.animateNode(this.animationIndex);
            }
        }
    } else if (this.connectortype == "flowloop") {
        if (this.loopdirection == "forward") {
            this.animateArrow(this.animationIndex - 1);
            let animdelay = 0.35;
            this.animateNode(this.animationIndex, "show", animdelay);
            if (this.animationIndex == this.arrDiagramNode.length - 1) {
                animdelay = animdelay + 0.35;
                this.animateArrowHolder("show", animdelay);
                animdelay = animdelay + 0.35;
                this.animateCenterHolder("show", animdelay);
            }
        } else if (this.loopdirection == "reverse") {
            this.animateArrow(this.animationIndex);
            let animdelay = 0.35;
            this.animateNode(this.animationIndex, "show", animdelay);
            if (this.animationIndex == 0) {
                animdelay = animdelay + 0.35;
                this.animateArrowHolder("show", animdelay);
                animdelay = animdelay + 0.35;
                this.animateCenterHolder("show", animdelay);
            }
        }
    }

    let delay = 2;
    setTimeout(() => {
        if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, delay * 1000);
    if (this.loopdirection && this.loopdirection == "reverse") this.animationIndex -= 1;
    else this.animationIndex += 1;

    return true;
};

SimpleLinearConnectorNode.prototype.playPrevious = function (index) {
    this.updateAnimationPath("hide");
    if (this.loopdirection && this.loopdirection == "reverse") {
        this.animationIndex += 1;
        if (this.animationIndex == this.arrDiagramNode.length) {
            // this.diagramParent.style.transition = "all 0.5s " + this.cubicPath;
            // this.diagramParent.style.opacity = 0;
            return false;
        }
    } else {
        this.animationIndex -= 1;
        if (this.animationIndex == 0) {
            // this.diagramParent.style.transition = "all 0.5s " + this.cubicPath;
            // this.diagramParent.style.opacity = 0;
            return false;
        }
    }

    if (this.connectortype == "hierarchy") {
        if (this.connectoralign == "top") {
            if (this.animationIndex == 0) {
                this.animateCenterHolder("hide");
            } else if (this.animationIndex == 1) {
                this.animateArrowPath(this.animationIndex - 1, true, "hide");
                this.animateNode(this.animationIndex - 1, "hide");
            } else {
                this.animateArrowPath(this.animationIndex - 1, false, "hide");
                this.animateNode(this.animationIndex - 1, "hide");
            }
        } else if (this.connectoralign == "bottom") {
            if (this.animationIndex == 0) {
                this.animateNode(this.animationIndex, "hide");
                this.animateArrowPath(this.animationIndex, true, "hide");
                this.animateCenterHolder("hide");
            } else {
                this.animateArrowPath(this.animationIndex, false, "hide");
                this.animateNode(this.animationIndex, "hide");
            }
        }
    } else if (this.connectortype == "flowloop") {
        if (this.loopdirection == "forward") {
            let delay = 0;
            if (this.animationIndex == this.arrDiagramNode.length - 1) {
                this.animateCenterHolder("hide", delay);
                delay += 0.35;
                this.animateArrowHolder("hide", delay);
            }
            this.animateNode(this.animationIndex, "hide", delay);
            delay += 0.35;
            this.animateArrow(this.animationIndex - 1, "hide", delay);
        } else if (this.loopdirection == "reverse") {
            let delay = 0;
            if (this.animationIndex == 0) {
                this.animateCenterHolder("hide", delay);
                delay += 0.35;
                this.animateArrowHolder("hide", delay);
            }
            this.animateNode(this.animationIndex, "hide", delay);
            delay += 0.35;
            this.animateArrow(this.animationIndex, "hide", delay);
        }
    }
    let completionDelay = 2;
    setTimeout(() => {
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, completionDelay * 1000);

    return true;
};

/**
 * Author:    Bala Krishnan K.
 * Created:   10.7.2020
 **/

"use strict";

function SimpleLinearCommonNodeBase(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
}

SimpleLinearCommonNodeBase.prototype = Object.create(SimpleLinearDiagram.prototype);
SimpleLinearCommonNodeBase.prototype.constructor = SimpleLinearCommonNodeBase;

SimpleLinearCommonNodeBase.prototype.initDiagramCreation = function () {
    this.diagramParent.innerHTML = "";
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.createPatternBackGround();
};

SimpleLinearCommonNodeBase.prototype.createElements = function () {
    SimpleLinearDiagram.prototype.createElements.call(this);
    let parentDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    let centerNodeStyle = this.nodeProps.centerNodeStyle;
    parentDiv.className = "clsNodesHolderCommonCenter " + centerNodeStyle;
    this.createCommonHolder(parentDiv);
};

SimpleLinearCommonNodeBase.prototype.createCenterHolder = function (pattenDiv, contentData = { id: "", value: "", contenttype: "text", type: "text" }) {
    let centerItem = new window[this.nodeProps.nodeclassName](
        pattenDiv,
        {},
        this.centerholderdata ? this.centerholderdata : this.diagramData.nodes[0] ? this.diagramData.nodes[0] : { content: {} },
        this.eventManagerXY,
        0,
        "",
        this.objStyleData,
        this.appStaticURL,
        this.nodeProps,
        this.diagramParent
    );
    centerItem.moodData = this.moodData;
    centerItem.moodName = this.moodName;
    centerItem.updateCallBack = this.updateCallBack;
    centerItem.searchIconCallBack = this.searchIconCallBack;
    centerItem.bgDeviceDiv = this.bgDeviceDiv;
    centerItem.arrDefaults = this.arrDefaults;
    centerItem.globalMoodData = this.globalMoodData;
    centerItem.arrTintArray = this.arrTintArray;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;
    this.centerHolderNode = centerItem;
    let centerNode = centerItem.createCenterNode(pattenDiv);
    this.centerHolderNode.nodeGroup = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    this.updatePropsCallBack();
    return centerNode;
};

SimpleLinearCommonNodeBase.prototype.recreateElementData = function () {
    SimpleLinearDiagram.prototype.recreateElementData.call(this);
    let pattenDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    let centerItem = new window[this.nodeProps.nodeclassName](
        pattenDiv,
        {},
        this.centerholderdata ? this.centerholderdata : { content: {} },
        this.eventManagerXY,
        0,
        "",
        this.objStyleData,
        this.appStaticURL,
        this.nodeProps,
        this.diagramParent
    );
    centerItem.moodData = this.moodData;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;
    this.centerHolderNode = centerItem;
    this.centerHolderNode.parentNode = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    this.centerHolderNode.nodeGroup = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    // this.updatePropsCallBack();
};

SimpleLinearCommonNodeBase.prototype.createCommonHolder = function (parentDiv) {
    if (this.nodeProps.centerNode) {
        let holderParent = this.createCenterHolder(parentDiv);
        holderParent.classList.add("moodanimation");
        holderParent.setAttribute("data-animation", "primarytext");
        let imageHolder = holderParent.querySelector("[id*='imageHolder']");
        if (imageHolder) {
            imageHolder.setAttribute("data-focus-parent", "centerHolderParent");
            let imgNode = holderParent.querySelector("img[data-id='imageNode'],img[data-id='logoNode']");
            if (imgNode) CommonImageUtils.updateImageBounds(imgNode, { islogofit: true, contenttype: "logo" }, 1);
        }
    }
    this.diagramRenderComplete();
};

SimpleLinearCommonNodeBase.prototype.updateNodeData = function (nodeData, type, index, parentId) {
    if (parentId.includes("centerHolderParent")) {
        this.centerHolderNode.objData.content = nodeData;
        this.centerholderdata = this.centerHolderNode.objData;
    }
    if (this.arrDiagramNode && this.arrDiagramNode.length > index) {
        this.arrDiagramNode[index].updateContentData(nodeData, type, parentId);
    }
};

SimpleLinearCommonNodeBase.prototype.getCenterHolderData = function () {
    let objData = {};
    let parent = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    let contentType = parent.dataset.contentType || "text";
    objData = this.centerHolderNode.getJSONData();
    let contentNode = parent.querySelector("[data-id='" + contentType + "Node']");
    if (contentNode) {
        objData.content = DiagramNodeUtils.getContentDataFromNode(contentNode, contentType);
    }
    this.centerHolderNode.objData = objData;
    this.centerholderdata = this.centerHolderNode.objData;
    return objData;
};

SimpleLinearCommonNodeBase.prototype.setHighlightPosition = function (node, parent) {
    let nodeParent = node.parentElement;
    // let element = nodeParent.querySelector("[data-id='diagramContentNode']");
    // if (!element) element = node;
    return { element: nodeParent, alignment: "horizontal" };
};

/**
 * Author:    Bala Krishnan K
 * Created:   3.10.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function SimpleLinearRatioDiagram(diagramParent, diagramData, nodeProps, moodData = {}) {
    SimpleLinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
}

SimpleLinearRatioDiagram.prototype = Object.create(SimpleLinearDiagram.prototype);
SimpleLinearRatioDiagram.prototype.constructor = SimpleLinearRatioDiagram;

SimpleLinearRatioDiagram.prototype.resetHolderWidth = function () {
    this.updateSizeRatio();
    SimpleLinearDiagram.prototype.resetHolderWidth.call(this);
};

SimpleLinearRatioDiagram.prototype.updateSizeRatio = function () {
    let nodeRatio = this.nodeProps.nodeRatio;
    let contentMinHeight = nodeRatio ? parseFloat(nodeRatio.split(",")[0]) : 100;
    let contentMaxHeight = nodeRatio ? parseFloat(nodeRatio.split(",")[1]) : 300;
    let isPercentage = false;
    if (nodeRatio && nodeRatio.includes("%")) {
        isPercentage = true;
    }
    let suffix = isPercentage ? "%" : "px";
    let node = nodeRatio ? nodeRatio.split(",")[2] : "content";
    node = DiagramNodeUtils.getNodeFromMenuNodeName(node);
    let increment = nodeRatio ? nodeRatio.split(",")[3] == "increase" : true;
    let isHeightOnly = nodeRatio ? nodeRatio.split(",")[4] == "height" : false;
    let nodeGroup = this.diagramParent.querySelector("[name='nodeGroup']");
    // let nodeWidth = nodeGroup.clientWidth;
    let gap = DiagramNodeUtils.getGapForConnectors(this.nodeProps, this.arrDiagramNode.length, this.diagramParent,  this.diagramData.properties);
    let nodeWidth = (this.diagramParent.clientWidth - gap * (this.arrDiagramNode.length - 1)) / this.arrDiagramNode.length;
    for (let index = 0; index < this.arrDiagramNode.length; index++) {
        let nodeParent = this.arrDiagramNode[index].parentNode;
        let content = nodeParent.querySelector("[name='" + node + "']");
        let contentBackgound = content ? content.querySelector("[name='contentBackgound']") : null;
        let valueHolder = content ? content.querySelector("[name='valueTitleHolder']") : null;
        let secContentNode = content ? content.querySelector("[name='secContentNode']") : null;

        if (!isHeightOnly) contentMaxHeight = nodeWidth < contentMaxHeight ? nodeWidth : contentMaxHeight;
        let size = (contentMaxHeight - contentMinHeight) / (this.arrDiagramNode.length - 1);
        if (increment) {
            size = contentMinHeight + size * index;
        } else {
            size = contentMaxHeight - size * index;
        }
        nodeParent.style.setProperty("--varyHeight", size + suffix);
        if (content) {
            if (!isHeightOnly) content.style.width = size + suffix;
            content.style.setProperty("height", "var(--varyHeight)");
            content.style.maxHeight = "unset";
            content.style.maxWidth = "100%";
        }
        if (contentBackgound) contentBackgound.style.height = "var(--varyHeight)";
        if (valueHolder) {
            // valueHolder.style.maxHeight = size * 0.4 + "px";
            let valueText = valueHolder.firstElementChild;
            valueText.setAttribute("data-prompt-text", Constants.Value.valueTextPrompt);
            valueText.style.fontSize = size * 0.3 - 8 + "px";
            // let lineHeight = parseFloat(window.getComputedStyle(valueText).lineHeight);
            valueHolder.style.setProperty("max-height", size * 0.3 + "px");
            // valueText.style.lineHeight = size * 0.4 + "px";
        }
        if (secContentNode) {
            secContentNode.style.maxHeight = size + suffix;
        }
    }
    this.diagramParent.style.setProperty("--contentMinRatioHeight", contentMaxHeight + suffix);
};

SimpleLinearRatioDiagram.prototype.slideDimensionChange = function () {
    this.updateSizeRatio();
};

SimpleLinearRatioDiagram.prototype.addNode = function (nodeJSON, index, isFromUndo = false) {
    SimpleLinearDiagram.prototype.addNode.call(this, nodeJSON, index, isFromUndo);
    this.updateSizeRatio();
};

SimpleLinearRatioDiagram.prototype.deleteNode = function (targetIndex) {
    SimpleLinearDiagram.prototype.deleteNode.call(this, targetIndex);
    this.updateSizeRatio();
};

/**
 * Author:    Bala Krishnan
 * Created:   1.08.2020
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function SvgScale9BgList(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearVerticalDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    diagramParent.setAttribute("data-diagramtype", "vertical");
    this.isCenterShapeLoaded = false;
}

SvgScale9BgList.prototype = Object.create(SimpleLinearVerticalDiagram.prototype);
SvgScale9BgList.prototype.constructor = SvgScale9BgList;

SvgScale9BgList.prototype.initDiagramCreation = function () {
    this.diagramParent.innerHTML = "";
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.diagramParent.setAttribute("data-disablelinearcontent", "true");
    this.createPatternBackGround();
};

SvgScale9BgList.prototype.createElements = function () {
    SimpleLinearVerticalDiagram.prototype.createElements.call(this);

    let arrAssets = [{ type: "icon", value: this.nodeProps.bgsvg.path + this.nodeProps.bgsvg.id + ".svg", id: this.nodeProps.bgsvg.id }];
    for (let i = 0; i < this.diagramData.properties.maxnode; i++) {
        let svgId = "number" + (i + 1) + this.nodeProps.bgsvg.id;
        arrAssets.push({ type: "icon", value: this.nodeProps.bgsvg.path + svgId + ".svg", id: svgId });
    }
    DiagramAssetLoader.loadAssetGroup(this.diagramParent, arrAssets, this.appStaticURL)
        .then(() => {
            for (let i = 0; i < this.arrDiagramNode.length; i++) {
                if (this.nodeProps.bgsvg) {
                    let bgsvgid = this.getSvgId(i, this.nodeProps.bgsvg.id);
                    let bgsvgvalue = this.nodeProps.bgsvg.path + bgsvgid + ".svg";
                    const objAssets = { value: bgsvgvalue, id: bgsvgid, type: "icon" };
                    DiagramCreateUtil.updateManifest(objAssets, this.manifestUpdater, this.appStaticURL);
                    let svgDefs = DiagramNodeUtils.getDocumentDefs(this.diagramParent, true);
                    if (svgDefs) {
                        let svgNodeOriginal = svgDefs.querySelector("[id='" + bgsvgid + "']");
                        if (svgNodeOriginal) {
                            let svgNode = svgNodeOriginal.cloneNode(true);
                            svgNode.setAttribute("class", "bgsvgNode");
                            svgNode.setAttribute("id", "bgsvgNode" + DiagramNodeUtils.uuidv4());
                            svgNode.setAttribute("data-id", "bgsvgNode");
                            let imageOvelay = svgNode.querySelector("image[data-name='overlay']");
                            if (imageOvelay) {
                                imageOvelay.setAttribute("xlink:href", this.appStaticURL + "genericassets/shapes/overlay.png");
                            }
                            let arrUseNodes = Array.from(svgNode.querySelectorAll("use"));
                            for (let useNode of arrUseNodes) {
                                useNode.setAttribute("class", "clsAccentfill");
                            }
                            let nodeParent = this.arrDiagramNode[i].parentNode;
                            let nodeBg = nodeParent.querySelector("[name='nodeBackgound']");
                            nodeBg.setAttribute("data-id", "bgsvgparent");
                            nodeBg.appendChild(svgNode);
                            DiagramResizeUtils.drawNineScale(bgsvgid, nodeParent);
                            this.adjustPlaceholder(nodeParent, bgsvgid);
                        }
                    }

                    // })
                    // .catch((error) => {
                    // console.log("Illustration asset load fail - " + error);
                    // });
                }
            }
            this.addFocus(this.arrDiagramNode.length - 1);
            this.isCenterShapeLoaded = true;
            this.diagramRenderComplete();
            // let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
            // if (lastDiv) this.updatePropsCallBack(lastDiv.id);
            this.diagramParent.parentElement.style.setProperty("--contentdisplay", this.diagramData.properties.diagramcontent ? "flex" : "none");
            this.diagramParent.parentElement.style.setProperty("--numberdisplay", this.diagramData.properties.sequencetext ? "flex" : "none");
        })
        .catch((rej) => {
            console.log(rej);
            this.isCenterShapeLoaded = true;
            this.diagramRenderComplete();
        });
};

SvgScale9BgList.prototype.recreateElementData = function () {
    SimpleLinearVerticalDiagram.prototype.recreateElementData.call(this);
    this.isCenterShapeLoaded = true;
};

SvgScale9BgList.prototype.diagramRenderComplete = function () {
    if (this.isCenterShapeLoaded) {
        this.diagramParent.style.opacity = 1;
        SimpleLinearVerticalDiagram.prototype.diagramRenderComplete.call(this);
    }
};

SvgScale9BgList.prototype.isNonLinearAsset = function () {
    return true;
};

SvgScale9BgList.prototype.resetLayout = function () {
    SimpleLinearVerticalDiagram.prototype.resetLayout.call(this);
    // this.createElements();
    for (let i = 0; i < this.arrDiagramNode.length; i++) {
        if (this.nodeProps.bgsvg) {
            let bgsvgid = this.getSvgId(i, this.nodeProps.bgsvg.id);
            let nodeParent = this.arrDiagramNode[i].parentNode;
            let bgNode = nodeParent.querySelector("[data-id='bgsvgNode']");
            if (bgNode) {
                DiagramResizeUtils.drawNineScale(bgsvgid, nodeParent);
                this.adjustPlaceholder(nodeParent, i);
            }
        }
    }
};

SvgScale9BgList.prototype.adjustPlaceholder = function (nodeParent, bgsvgid) {
    let bgsvgNode = nodeParent.querySelector("[data-id='bgsvgparent']");
    let nodeitem = nodeParent.querySelector("[name='nodeGroup']");
    let contentNode = nodeParent.querySelector("[id='" + bgsvgid + "-content']");
    let rightUse = bgsvgNode.querySelector("[*|href='#" + bgsvgid + "-right']");
    if (contentNode) {
        let placeholderX = contentNode.getAttribute("x") * bgsvgNode.getAttribute("data-scale");
        let placeholderY = contentNode.getAttribute("y") * bgsvgNode.getAttribute("data-scale");
        let height = contentNode.getAttribute("height") * bgsvgNode.getAttribute("data-scale");
        nodeitem.style.paddingLeft = placeholderX + "px";
        nodeitem.style.paddingRight = rightUse.getBBox().width * bgsvgNode.getAttribute("data-scale") + "px";
        nodeitem.style.paddingTop = placeholderY + "px";
        nodeitem.style.paddingBottom = nodeitem.clientHeight - (height + placeholderY) + "px";
        nodeitem.style.top = "0px";
        this.diagramParent.style.setProperty("--nodecontentheight", "calc(" + nodeitem.clientHeight + "px - " + nodeitem.style.paddingTop + " - " + nodeitem.style.paddingBottom + ")");
    }
};

SvgScale9BgList.prototype.getSvgId = function (index, bgsvgid) {
    let id = "";
    if (this.diagramData.properties.sequencetext) {
        id = "number" + (index + 1) + bgsvgid;
    } else {
        id = bgsvgid;
    }
    return id;
};

SvgScale9BgList.prototype.addNode = function (nodeData, index) {
    if (this.diagramData.nodes.length > index) {
        this.diagramData.nodes.splice(index, 0, nodeData);
    } else {
        this.diagramData.nodes.push(nodeData);
    }
    this.initDiagramCreation();
    this.updateEvents();
};

SvgScale9BgList.prototype.deleteNode = function (targetIndex) {
    if (this.arrDiagramNode.length > targetIndex) {
        this.arrDiagramNode.splice(targetIndex, 1);
        let nodeDelete = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + targetIndex + "']");
        if (nodeDelete && nodeDelete.parentElement) {
            nodeDelete.parentElement.remove();
        }
    }
    if (this.diagramData.nodes.length > targetIndex) {
        this.diagramData.nodes.splice(targetIndex, 1);
    }
    this.initDiagramCreation();
    this.updateEvents();
};

SvgScale9BgList.prototype.showHideContent = function () {
    let previousState = getComputedStyle(this.diagramParent.parentElement).getPropertyValue("--contentdisplay").trim();
    let visible = previousState != "none";
    this.diagramParent.parentElement.style.setProperty("--contentdisplay", visible ? "none" : "flex");
    this.diagramParent.setAttribute("data-content", !visible);
    this.diagramData.properties.diagramcontent = !visible;
    this.updateProperties(this.diagramData.properties);
    this.getJSONData(this.diagramData.properties);
    this.initDiagramCreation();
    this.updateEvents();
};

SvgScale9BgList.prototype.showHideNumber = function () {
    let previousState = getComputedStyle(this.diagramParent.parentElement).getPropertyValue("--numberdisplay").trim();
    let visible = previousState == "flex";
    this.diagramParent.parentElement.style.setProperty("--numberdisplay", visible ? "none" : "flex");
    this.diagramData.properties = this.getProperties();
    this.diagramData.properties.sequencetext = !visible;
    this.updateProperties(this.diagramData.properties);
    this.getJSONData(this.diagramData.properties);
    this.initDiagramCreation();
    this.updateEvents();
};

SvgScale9BgList.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearVerticalDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    let index = -1;
    let contentindex = -1;
    let secondaryindex = -1;
    if (mainProperties.floateroptionsdisable) {
        index = mainProperties.floateroptionsdisable.indexOf("sequencetext");
        if (index !== -1) mainProperties.floateroptionsdisable.splice(index, 1);

        secondaryindex = mainProperties.floateroptionsdisable.indexOf("secondaryplaceholder");
        if (secondaryindex !== -1) mainProperties.floateroptionsdisable.splice(secondaryindex, 1);

        contentindex = mainProperties.floateroptionsdisable.indexOf("content");
        if (contentindex !== -1) mainProperties.floateroptionsdisable.splice(contentindex, 1);

        mainProperties.floateroptionsdisable.push("arrange");
        mainProperties.floateroptionsdisable.push("contentoptions");
        mainProperties.floateroptionsdisable.push("content");
        mainProperties.floateroptionsdisable.push("sequencetext");
    }
    // else mainProperties.floateroptionsdisable = ["sequencetext","graphicbulletlist","graphicchecklist"];
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

SvgScale9BgList.prototype.setHighlightPosition = function (node, parent) {
    let nodeParent = node.parentElement;
    let element = nodeParent.querySelector("[data-id='diagramContentNode']");
    if (!element || element.clientWidth == 0) element = node;
    return { element: element, alignment: "vertical" };
};

/**
 * Author:    Bala Krishnan
 * Created:   4.08.2020
 *
 **/

"use strict";

function SvgLinearNumberDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    diagramParent.setAttribute("data-diagramtype", "vertical");
}

SvgLinearNumberDiagram.prototype = Object.create(SimpleLinearDiagram.prototype);
SvgLinearNumberDiagram.prototype.constructor = SvgLinearNumberDiagram;

SvgLinearNumberDiagram.prototype.initDiagramCreation = function () {
    this.diagramParent.innerHTML = "";
    this.diagramParent.style.opacity = 0;
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.diagramParent.setAttribute("data-currencyformat", "disable");
    this.createPatternBackGround();
};

SvgLinearNumberDiagram.prototype.applySvgColor = function (svgNode, i) {
    DiagramUtils.setCustomItemColor(svgNode, this.arrTintArray, i, i + 1);
    let arrPathNodes = svgNode.querySelectorAll("[id*='number']");
    for (let i = 0; i < arrPathNodes.length; i++) {
        if (arrPathNodes[i].id.includes("themecolor")) {
            // let themeIndex = arrPathNodes[i].id.charAt(arrPathNodes[i].id.length - 1);
            // arrPathNodes[i].setAttribute("class", "accent" + themeIndex + "-fill");
            arrPathNodes[i].setAttribute("class", "clsAccentfill");
        }
    }
};

SvgLinearNumberDiagram.prototype.createElements = function () {
    SimpleLinearDiagram.prototype.createElements.call(this);
    let strNumber = this.diagramData.nodes[0].content.value;
    strNumber = DiagramUtils.extractNumber(strNumber).toString();
    var regex = new RegExp(",", "gi");
    strNumber = strNumber.replace(regex, "");
    strNumber = strNumber.length > 2 ? strNumber.substring(0, 2) : strNumber.length == 1 ? "0" + strNumber : strNumber;
    if (strNumber == "") {
        // this.diagramParent.style.opacity = 1;
        // this.resetNodeAttributes();
        // this.diagramRenderComplete();
        // return;
        strNumber = "12";
    }
    let arrNumber = strNumber.split("");
    this.arrAssets = [];
    // let basePath = "../assets/svg/";
    // let basePath = "number/metadata/";
    this.arrAssets.push({
        type: "icon",
        value: this.nodeProps.bgsvg.path + this.nodeProps.bgsvg.id + arrNumber[0] + ".svg",
        id: this.nodeProps.bgsvg.id + arrNumber[0],
        index: 0,
    });
    this.arrAssets.push({
        type: "icon",
        value: this.nodeProps.bgsvg.path + this.nodeProps.bgsvg.id + arrNumber[1] + ".svg",
        id: this.nodeProps.bgsvg.id + arrNumber[1],
        index: 1,
    });
    const diagramAssetLoader = new window["DiagramAssetLoader"]();
    diagramAssetLoader
        .loadDiagramAssets(this.diagramParent, this.arrAssets, this.appStaticURL)
        .then(() => {
            let numberNode = this.diagramParent.querySelector("[data-id='numberNode']");
            if (numberNode) {
                numberNode.innerHTML = "";
                numberNode.setAttribute("data-text", strNumber);
                numberNode.setAttribute("data-iscounteranim", "false");
                let svgDefs = DiagramNodeUtils.getDocumentDefs(this.diagramParent, true);
                let svgNode1 = svgDefs.querySelector("[id='" + this.arrAssets[0].id + "']").cloneNode(true);
                svgNode1.setAttribute("data-id", "svgNumberNode" + this.arrAssets[0].index);
                svgNode1.setAttribute("class", "svgNumberNode clsMultiColorParent");
                this.applySvgColor(svgNode1, 0);
                numberNode.appendChild(svgNode1);
                let svgNode2 = svgDefs.querySelector("[id='" + this.arrAssets[1].id + "']").cloneNode(true);
                svgNode2.setAttribute("data-id", "svgNumberNode" + this.arrAssets[1].index);
                svgNode2.setAttribute("class", "svgNumberNode clsMultiColorParent");
                this.applySvgColor(svgNode2, 1);
                numberNode.appendChild(svgNode2);
            }
            this.diagramParent.style.opacity = 1;
            this.resetNodeAttributes();
            this.diagramRenderComplete();
        })
        .catch((rej) => {
            this.diagramParent.style.opacity = 1;
            this.diagramRenderComplete();
            console.log(rej);
        });
};

SvgLinearNumberDiagram.prototype.addNode = function (nodeData, index) {
    if (this.diagramData.nodes.length > index) {
        this.diagramData.nodes.splice(index, 0, nodeData);
    } else {
        this.diagramData.nodes.push(nodeData);
    }
    this.initDiagramCreation();
    this.updateEvents();
};

SvgLinearNumberDiagram.prototype.deleteNode = function (targetIndex) {
    if (this.arrDiagramNode.length > targetIndex) {
        this.arrDiagramNode.splice(targetIndex, 1);
        let nodeDelete = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + targetIndex + "']");
        if (nodeDelete && nodeDelete.parentElement) {
            nodeDelete.parentElement.remove();
        }
    }
    if (this.diagramData.nodes.length > targetIndex) {
        this.diagramData.nodes.splice(targetIndex, 1);
    }
    this.initDiagramCreation();
    this.updateEvents();
};

SvgLinearNumberDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable.push("arrange");
        mainProperties.floateroptionsdisable.push("content");
    }
    // else mainProperties.floateroptionsdisable = ["sequencetext","graphicbulletlist","graphicchecklist"];
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

SvgLinearNumberDiagram.prototype.setHighlightPosition = function (node, parent) {
    let nodeParent = node.parentElement;
    let element = nodeParent.querySelector("[data-id='diagramContentNode']");
    if (!element || element.clientWidth == 0) element = node;
    return { element: element, alignment: "vertical" };
};

/**
 * Author:    Saravanan G
 * Created:   13.12.2019
 *
 * (c) Copyright by Gs.
 **/

("use strict");

function PlainDiagramNodeBase(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    this.index = index;
    this.objData = objData;
    this.eventManager = eventManager;
    this.parentID = parentID;
    this.mainParent = mainParent;
    this.diagramParent = diagramParent;
    this.isTakeAway = this.diagramParent?.parentElement?.getAttribute("id")?.includes("TEXTBOX");
    this.bgDeviceDiv = null;
    this.objStyleData = objStyleData || {};
    this.appStaticURL = appStaticURL;
    this.properties = properties;
    this.diagramProps = diagramProps || {};

    this.onFocusOut = this.onFocusOut.bind(this);
    this.microChartFoucsOut = this.microChartFoucsOut.bind(this);
    this.microChartKeyDown = this.microChartKeyDown.bind(this);
    this.microChartFoucsIn = this.microChartFoucsIn.bind(this);
    this.microChartClickEvent = this.microChartClickEvent.bind(this);
    this.mutationCallBack = this.mutationCallBack.bind(this);

    this.titleID = Constants.Value.titleID;
    this.subTitleID = Constants.Value.subTitleID;
    this.numberID = Constants.Value.numberID;
    this.contentID = Constants.Value.contentID;
    this.imageNodeID = Constants.Value.imageNodeID;
    this.iconNodeID = Constants.Value.iconNodeID;
    this.textGroupID = Constants.Value.textGroupID;
    this.objStyleData.selectorList = this.diagramProps.selectorList ? this.diagramProps.selectorList.split(",") : [];

    this.observer = new MutationObserver(this.mutationCallBack);
    this.observer.mytargets = [];

    this.arrSupportedNodes = (diagramProps && diagramProps.supportedNodes) || [{ name: "subTitleHolder" }];
    this.centerNode = (diagramProps && diagramProps.centerNode) || [{ name: "imageHolder" }];
    // this.isHolderTypePresent = JSON.stringify(this.arrSupportedNodes).includes('holdertype');
    let strSupportedNodes = JSON.stringify(this.arrSupportedNodes);
    this.isHolderTypePresent = strSupportedNodes.includes('"holdertype":"primary"');
    this.connector = (diagramProps && diagramProps.connector) || null;
    this.connectortext = (diagramProps && diagramProps.connectortext) || null;
    this.seperatorline = (diagramProps && diagramProps.seperatorline) || null;
    this.boolTextOnly = (diagramProps && diagramProps.textOnly) || false;
    this.titleVAlign = (diagramProps && diagramProps.titleVAlign) || "flex-end";
    // this.titleFontSize = (diagramProps && diagramProps.titleFontSize) || "h5";
    let menuFontClass = diagramProps && diagramProps.fontClass ? diagramProps.fontClass.split(",")[0] : null;
    let menuFontSize = diagramProps && diagramProps.fontClass ? diagramProps.fontClass.split(",")[1] : null;
    this.objStyleData.fontSizeData = this.objStyleData.fontSizeData || {};
    this.diagramTitleFontSize = menuFontClass && menuFontClass == "diagramtitle" ? menuFontSize : (diagramProps && diagramProps.diagramTitleFontSize) || this.objStyleData.fontSizeData.diagramtitle || "h5";
    this.titleFontSize = menuFontClass && menuFontClass == "primarytext" ? menuFontSize : (diagramProps && diagramProps.titleFontSize) || this.objStyleData.fontSizeData.primarytext || "h5";
    this.subTitleFontSize = menuFontClass && menuFontClass == "secondarytext" ? menuFontSize : this.objStyleData.fontSizeData.secondarytext || "p4";
    this.connectorTextFontSize = menuFontClass && menuFontClass == "connectortext" ? menuFontSize : this.objStyleData.fontSizeData.connectortext || "p7";
    this.seqNumberFontSize = menuFontClass && menuFontClass == "sequencetext" ? menuFontSize : this.objStyleData.fontSizeData.sequencetext || "n1";
    this.textFontSize = menuFontClass && menuFontClass == "holdertext" ? menuFontSize : this.objStyleData.fontSizeData.holdertext || "p2";
    this.buttonFontSize = menuFontClass && menuFontClass == "buttonlabel" ? menuFontSize : this.objStyleData.fontSizeData.buttonlabel || "p2";
    this.numberFontSize = menuFontClass && menuFontClass == "valuetext" ? menuFontSize : this.objStyleData.fontSizeData.valuetext || "n1";
    this.microchartFontSize = menuFontClass && menuFontClass == "microchart" ? menuFontSize : this.objStyleData.fontSizeData.microchart || "n1";
    this.commonTitleFontSize = menuFontClass && menuFontClass == "commontitle" ? menuFontSize : this.objStyleData.fontSizeData.commontitle || "h4";
    this.authorNameFontSize = menuFontClass && menuFontClass == "authorname" ? menuFontSize : this.objStyleData.fontSizeData.authorname || "p2";
    this.authorDesFontSize = menuFontClass && menuFontClass == "authordes" ? menuFontSize : this.objStyleData.fontSizeData.authordes || "p2";
    this.textLabelFontSize = menuFontClass && menuFontClass == "textlabel" ? menuFontSize : this.objStyleData.fontSizeData.textlabel || "p2";
    this.numberToggleFontSize = menuFontClass && menuFontClass == "numbertoggle" ? menuFontSize : this.objStyleData.fontSizeData.numbertoggle || "p2";
    this.numberToggleDesFontSize = menuFontClass && menuFontClass == "numbertoggledes" ? menuFontSize : this.objStyleData.fontSizeData.numbertoggledes || "p2";
    this.subTextFontSize = menuFontClass && menuFontClass == "subtext" ? menuFontSize : this.objStyleData.fontSizeData.subtext || "p2";

    this.subTitleVAlign = (diagramProps && diagramProps.subTitleVAlign) || "flex-end";
    this.arrAllowResize = (diagramProps && diagramProps.arrResizeNode) || [];
    this.arrTextNodes = (diagramProps && diagramProps.arrTextNodes) || ["titleHolder", "subTitleHolder", "textTitleHolder", "authorNameHolder", "authorDesHolder"];
    this.arrTextNodes = JSON.parse(JSON.stringify(this.arrTextNodes)).reverse();
    let connectorNode = mainParent?.querySelector("[name='connectortext']");
    if (!this.arrTextNodes.includes("connectortext") && connectorNode) this.arrTextNodes.push("connectortext");
    this.verticalAlign = diagramProps && diagramProps.valign ? diagramProps.valign : window.getComputedStyle(diagramParent).getPropertyValue("--graphicVAlign");
    this.parentStyle = diagramProps && diagramProps.parentStyle ? diagramProps.parentStyle : "";
    this.globalstyle = diagramProps && diagramProps.globalstyle ? diagramProps.globalstyle : "";
    this.arrAllowResizeHeight = diagramProps && diagramProps.arrHeight ? diagramProps.arrHeight : ["1000"];
    this.boolFixedGroup = (diagramProps && diagramProps.fixedGroup) || false;
    this.boolFixedContent = (diagramProps && diagramProps.fixedContent) || false;
    this.boolFixedSecContent = (diagramProps && diagramProps.fixedSecContent) || false;
    this.boolFixedSecSubContent = (diagramProps && diagramProps.fixedSecSubContent) || false;
    this.boolFixedNode = (diagramProps && diagramProps.fixedNode) || false;

    this.contentIconBG = diagramProps && diagramProps.iconBG ? diagramProps.iconBG : null;
    this.contentBG = diagramProps && diagramProps.contentBG ? diagramProps.contentBG : null;
    this.quoteShape = diagramProps && diagramProps.quoteShape ? diagramProps.quoteShape : null;
    this.strikeOut = diagramProps && diagramProps.strikeOut ? diagramProps.strikeOut : null;
    this.hasIllustration = this.quoteShape && this.quoteShape.type && this.quoteShape.type == "illustration" ? true : false;
    this.isQuote = diagramProps && diagramProps.name && diagramProps.name.includes("qt");
    this.isTestimonial = diagramProps && diagramProps.name && diagramProps.name.includes("tes");
    this.strikeOutShape = diagramProps && diagramProps.strikeOutShape ? diagramProps.strikeOutShape : null;

    this.mainParent.style.setProperty("--titleJustify", this.titleVAlign);
    this.mainParent.style.setProperty("--subTitleJustify", this.subTitleVAlign);
    // if (this.diagramProps.contentNodePadding) {
    //     this.mainParent.style.setProperty("--widthPadding", this.diagramProps.contentNodePadding.split(" ")[2]);
    // }
    this.arrMainNodes = this.arrAllowResize.concat(this.arrTextNodes);
    this.microStyle = diagramProps && diagramProps.microStyle ? diagramProps.microStyle : "clssimpleMicro";

    let nodeParentPadding = diagramProps.nodeParentPadding ? diagramProps.nodeParentPadding : "0px";
    this.mainParent.style.setProperty("--nodeParentPadding", nodeParentPadding);

    let moodShapePosition = diagramProps.moodShapePosition ? diagramProps.moodShapePosition.split(",") : [0, 0, 0];
    this.mainParent.style.setProperty("--moodShapeTop", moodShapePosition[0]);
    this.mainParent.style.setProperty("--moodShapeLeft", moodShapePosition[1]);
    this.mainParent.style.setProperty("--moodShapeRotate", moodShapePosition.length == 3 ? moodShapePosition[2] + "deg" : "0deg");

    let sqNodePosition = diagramProps.sqNodePosition ? diagramProps.sqNodePosition.split(",") : [diagramProps.sqNodePositionTop || 0, diagramProps.sqNodePositionLeft || 0];
    this.mainParent.style.setProperty("--sqNodePositionTop", sqNodePosition[0]);
    this.mainParent.style.setProperty("--sqNodePositionLeft", sqNodePosition[1]);

    //BG Color SetUp

    let nodeBGColorOptions = this.diagramProps.bgColor ? this.diagramProps.bgColor.split(",") : [];
    let strColorOptions = nodeBGColorOptions.length > 0 ? nodeBGColorOptions[0] : "";
    const hasOpacity = nodeBGColorOptions.length > 0 && strColorOptions.includes(":") && strColorOptions.includes("[") && strColorOptions.includes("]");
    if (hasOpacity && nodeBGColorOptions.length > 1) {
        let opacity = isNaN(nodeBGColorOptions[1]) ? "1" : nodeBGColorOptions[1];
        nodeBGColorOptions = strColorOptions.replace("[", "").replace("]", "").split(":");
        nodeBGColorOptions.push(opacity);
    }

    this.bgColorNode = nodeBGColorOptions.length > 1 ? nodeBGColorOptions[1].replace(/\s/g, "") : "";
    if (nodeBGColorOptions.length > 0) {
        this.bgColor = "clsNode" + DiagramUtils.capitalize(nodeBGColorOptions[0]) + "bg";
        this.bgOpacity = nodeBGColorOptions.length > 2 ? nodeBGColorOptions[2] : 1;
    }

    //Border Color SetUp
    this.borderNode = "";
    let nodeBorder = this.diagramProps.nodeBorder ? this.diagramProps.nodeBorder.split(",") : [];
    if (nodeBorder.length == 4) {
        const nodeData = nodeBorder[3].replace(/\s/g, "");
        let arrNodeData = [nodeData];
        if (nodeData.includes("[") && nodeData.includes("]")) {
            arrNodeData = nodeData.replace("[", "").replace("]", "").split(":");
        }

        for (let i = 0; i < arrNodeData.length; i++) {
            this.borderNode = this.borderNode + arrNodeData[i].replace(/\s/g, "");
            this.borderColor = "clsBorder" + DiagramUtils.capitalize(nodeBorder[1]);
            this.mainParent.style.setProperty("--border-width", nodeBorder[0]);
            let borderSplit = nodeBorder[0].split(" ");
            this.mainParent.style.setProperty("--border-top-width", borderSplit[0]);
            this.mainParent.style.setProperty("--border-right-width", borderSplit[1]);
            this.mainParent.style.setProperty("--border-bottom-width", borderSplit[2]);
            this.mainParent.style.setProperty("--border-left-width", borderSplit[3]);
            this.mainParent.style.setProperty("--border-style", "solid");
            this.mainParent.style.setProperty("--border-opacity", nodeBorder[2].replace(/\s/g, ""));
        }
    }

    this.innerFill = this.diagramProps.innerColor && !this.diagramProps.innerColor.includes("accent") ? "clsContrastFill" : "clsAccentfill";
    this.innerColor = this.diagramProps.innerColor && !this.diagramProps.innerColor.includes("accent") ? "clsAlterSecondaryColor" : "clsAccentColor";
    this.innerStroke = this.diagramProps.innerColor && !this.diagramProps.innerColor.includes("accent") ? "clsAlterSecondaryStroke" : "clsAccentStroke";
}
// Creation of NodeParent
PlainDiagramNodeBase.prototype.initCreation = function (isLastNode = false) {
    this.preLoadValues();
    this.parentNode = this.createXYNodeParent(this.mainParent);
    this.getCardStyleCss();
    this.nodeGroup = this.createNodeGroup(this.parentNode);
    this.updateStyles();
    this.createBackGround();
    let contentBackgound = this.parentNode.querySelector("[name='contentBackgound']");
    if (contentBackgound) this.parsecontentBG(contentBackgound, this.index);
    this.connectorNode = this.createConnectorParent(this.parentNode.parentElement, this.objData.content, isLastNode);
    if (this.objData && this.objData.nodeproperties) this.updateNodeProperties(this.objData.nodeproperties);
    this.setHighlightData();
    this.setLinkData();
    this.setCrossoutData();
    this.setEmphasizeData();
    this.setLogoContrastData();
};

// Get mood specific element bg class for card styles.
PlainDiagramNodeBase.prototype.getCardStyleCss = function () {
    let parentNodeStyle = getComputedStyle(this.parentNode.parentElement);
    if (parentNodeStyle) {
        Constants.Value.arrNodeStyleClass.forEach((element) => {
            let cardStyleNode = parentNodeStyle.getPropertyValue(element);
            if (cardStyleNode && cardStyleNode != "") this.parentNode.parentElement.classList.add(cardStyleNode);
        });
        this.cardStyleGroup = parentNodeStyle.getPropertyValue("--cardstylegroup");
        this.cardStyleContent = parentNodeStyle.getPropertyValue("--cardstylecontent");
        this.cardStyleSecContent = parentNodeStyle.getPropertyValue("--cardstyleseccontent");
        this.cardStyleSubSecContent = parentNodeStyle.getPropertyValue("--cardstylesubseccontent");
    }
};

PlainDiagramNodeBase.prototype.createXYNodeParent = function (parentPlotDiagramNode) {
    let nodeParentMain = document.createElement("div");
    nodeParentMain.className = " clsMultiColorParent clsNodeParentMain " + this.parentStyle + " " + this.globalstyle;

    if (this.objData?.nodeStyleClass) {
        let arrNodeStyleClass = this.objData.nodeStyleClass.split(" ");
        arrNodeStyleClass.forEach((styleClass) => {
            if (styleClass.trim() != "" && !nodeParentMain.classList.contains(styleClass)) nodeParentMain.classList.add(styleClass.trim());
        });
        nodeParentMain.setAttribute("data-nodestyleclass", this.objData?.nodeStyleClass);
    }
    if (this.objData?.static) {
        nodeParentMain.setAttribute("data-static", this.objData?.static);
    }
    if (this.objData?.type) {
        nodeParentMain.setAttribute("data-nodestyletype", this.objData?.type);
    }
    if (this.diagramProps && this.diagramProps.grid && this.diagramProps.grid.type && this.diagramProps.grid.type == "custom") nodeParentMain.style.setProperty("grid-area", "cell" + (this.index + 1));
    nodeParentMain.setAttribute("name", "nodeMainParent");
    nodeParentMain.setAttribute("data-index", this.index);
    nodeParentMain.setAttribute("id", "nodeMainParent" + this.index);

    let hasBg = false;
    Constants.Value.arrGroupBG.forEach((element) => {
        if (this.parentStyle.includes(element)) hasBg = true;
    });
    // if (this.bgColorNode == "node" || this.bgColorNode == "group" || hasBg) {
    // nodeParentMain.classList.add("moodanimation");
    // nodeParentMain.setAttribute("data-animation", "nodebg");
    // }
    DiagramUtils.addClassesFromMenu(this.diagramProps.objClass, nodeParentMain);

    // }
    parentPlotDiagramNode.insertChildAtIndex(nodeParentMain, this.index + 1);

    let nodeSubParent = document.createElement("div");
    DiagramNodeUtils.assignAttributes(nodeSubParent, {
        class: "clsNodeParent",
        name: "nodeparent",
        id: "nodeparent" + this.index,
        "data-parent-id": this.parentID,
        "data-index": this.index + "",
    });
    nodeParentMain.appendChild(nodeSubParent);
    DiagramUtils.addClassesFromMenu(this.diagramProps.objClass, nodeSubParent);

    // if (this.bgColorNode == "node") {
    //     nodeSubParent.classList.add(this.bgColor);
    //     if (this.bgOpacity) nodeSubParent.style.setProperty("--bg-opacity", this.bgOpacity);
    // }

    if (this.borderNode.includes("node")) {
        nodeSubParent.classList.add(this.borderColor);
    }
    return nodeSubParent;
};

PlainDiagramNodeBase.prototype.createNodeGroup = function (parentPlotDiagramNode) {
    let nodeGroup = document.createElement("div");
    parentPlotDiagramNode.appendChild(nodeGroup);

    DiagramNodeUtils.assignAttributes(nodeGroup, {
        class: "clsNodeGroup" + " " + this.cardStyleGroup,
        id: "nodeGroup" + this.index,
        name: "nodeGroup",
        "data-name": "nodeGroup",
        "data-dck-selector": true,
        "data-index": this.index,
        "data-type": "nodegroup",
    });

    // if (this.bgColorNode == "group") {
    //     nodeGroup.classList.add(this.bgColor);
    //     if (this.bgOpacity) nodeGroup.style.setProperty("--bg-opacity", this.bgOpacity);
    // }

    if (this.borderNode.includes("group")) {
        nodeGroup.classList.add(this.borderColor);
    }
    DiagramUtils.addClassesFromMenu(this.diagramProps.objClass, nodeGroup);

    let bgNodeDiv = document.createElement("div");
    bgNodeDiv.className = "clsGroupBackgound moodanimation";
    bgNodeDiv.setAttribute("id", "groupBackgound" + this.index);
    bgNodeDiv.setAttribute("data-animation", "groupnodebg");
    nodeGroup.appendChild(bgNodeDiv);
    DiagramNodeUtils.assignAttributes(bgNodeDiv, { "data-index": this.index, name: "groupBackgound" });
    DiagramUtils.addClassesFromMenu(this.diagramProps.objClass, bgNodeDiv);

    if (this.bgColorNode == "group") {
        bgNodeDiv.classList.add(this.bgColor);
        bgNodeDiv.classList.add("clsBgDefault");
        if (this.bgOpacity) bgNodeDiv.style.setProperty("--bg-opacity", this.bgOpacity);
    }

    // DiagramUtils.addClassesFromMenu(nodeObj.objClass,nodeGroup);
    return nodeGroup;
};

PlainDiagramNodeBase.prototype.createBackGround = function () {
    let bgDiv = document.createElement("div");
    bgDiv.className = "clsNodeBackgound moodanimation";
    bgDiv.setAttribute("id", "nodeBackgound" + this.index);
    this.parentNode.appendChild(bgDiv);
    if (this.bgColorNode == "node") {
        bgDiv.classList.add(this.bgColor);
        bgDiv.classList.add("clsBgDefault");
        if (this.bgOpacity) bgDiv.style.setProperty("--bg-opacity", this.bgOpacity);
    }
    // DiagramNodeUtils.assignAttributes(bgDiv, { name: "nodeBackgound", "data-name": "nodeBackgound", "data-animation": "nodeitem", "data-index": this.index });
    DiagramNodeUtils.assignAttributes(bgDiv, { name: "nodeBackgound", "data-name": "nodeBackgound", "data-index": this.index, "data-animation": "nodebg" });
    // DiagramNodeUtils.assignAttributes(bgDiv, { name: "nodeBackgound", "data-name": "nodeBackgound", "data-index": this.index });
    DiagramUtils.addClassesFromMenu(this.diagramProps.objClass, bgDiv);

    let intCount = this.arrSupportedNodes.length;
    for (let i = 0; i < intCount; i++) {
        let nodeObj = this.arrSupportedNodes[i];
        let nodeParent = this.createNodes(nodeObj, this.nodeGroup);
        if (nodeObj.subNodes && nodeParent && nodeParent.getAttribute("name") != "subTitleHolder") {
            this.createNestedNodes(nodeObj.subNodes, nodeParent);
        }
        if (nodeObj.subNodes && nodeObj.name == "nodeBackground") {
            this.createNestedNodes(nodeObj.subNodes, bgDiv);
        }
    }
};

PlainDiagramNodeBase.prototype.createNestedNodes = function (subNodes, nodeParentToInsert, objDataSec) {
    for (let j = 0; j < subNodes.length; j++) {
        let nodeObj = subNodes[j];
        let nodeParent = this.createNodes(nodeObj, nodeParentToInsert, objDataSec);
        if (nodeObj.subNodes && nodeParent) {
            this.createNestedNodes(nodeObj.subNodes, nodeParent, objDataSec);
        }
    }
};

PlainDiagramNodeBase.prototype.createNodes = function (nodeObj, nodeParent, objSecData = null) {
    let name = nodeObj.name ? nodeObj.name.trim() : "";
    let holdertype = nodeObj.holdertype ? nodeObj.holdertype : !this.isHolderTypePresent && this.getHolderTypeByName(name, this.diagramProps.name) ? "primary" : "secondary";
    let content = this.getContentDataBasedOnHolder(name, holdertype, this.objData, nodeObj.islogo, nodeParent);

    if (objSecData) content = objSecData;
    if (!content) content = {};
    switch (name) {
        case "titleHolder":
            return this.createTitle(nodeParent, this.objData.primarytext, nodeObj);
        case "multiTextNode":
            this.multiTextBox = new window["MultiTextComponent"](nodeParent, this.objData.multitextdata, this.index, this.eventManager, nodeObj, this.objStyleData.fontSizeData, this.manifestUpdater, this.appStaticURL);
            this.multiTextBox.properties = this.properties;
            this.multiTextBox.innerFill = this.innerFill;
            this.multiTextBox.slideID = this.diagramParent.parentElement.parentElement.parentElement.id;
            this.multiTextBox.globalMoodData = this.globalMoodData;
            this.multiTextBox.updateCallBack = this.updateCallBack;
            this.multiTextBox.focusCallBack = {
                func: this.updateOnFocusOut.bind(this),
            };
            this.multiTextBox.setQuillOperationHandler = this.setQuillOperation;
            return this.multiTextBox.initCreation();
        case "contentNode":
            return this.createContentNode(nodeParent, nodeObj);
        case "secContentNode":
            return this.createSecContentNode(nodeParent, nodeObj);
        case "moodNode":
            return this.createMoodNode(nodeParent, nodeObj);
        case "subTitleHolder":
            return this.createSubTitle(nodeParent, nodeObj);
        case "seqTitleHolder":
            return this.createSeqTitle(nodeParent, nodeObj);
        case "checkListHolder":
            return this.createCheckListNode(nodeParent, nodeObj, content);
        case "checkListSecHolder":
            return this.createCheckListSecNode(nodeParent, nodeObj, content);
        case "secSubContentNode":
            return this.createSecSubContentNode(nodeParent, nodeObj);
        case "valueTitleHolder":
        case "valueListHolder":
            this.checkPrimaryHolder(nodeObj, holdertype);
            return this.createValueTitle(nodeParent, content, holdertype, nodeObj);
        case "textTitleHolder":
            this.checkPrimaryHolder(nodeObj, holdertype);
            return this.createTextTitle(nodeParent, content, holdertype, nodeObj);
        case "buttonTitleHolder":
            return this.createButtonTitleHolder(nodeParent, this.objData.button, holdertype, nodeObj);
        case "deviceImageHolder":
            // this.checkPrimaryHolder(nodeObj, holdertype);
            return this.createDeviceImageHolder(nodeParent, content, name, holdertype, nodeObj);
        case "imageHolder":
        case "imageSecHolder":
        case "imageListHolder": // for Image inside secondary text (li)
            this.checkPrimaryHolder(nodeObj, holdertype);
            return this.createImageNode(nodeParent, nodeObj.authorimage ? this.objData?.author?.image || {} : content, name, holdertype, nodeObj);
        case "iconHolder":
        case "iconSecHolder":
        case "iconListHolder": // for Icon inside secondary text (li)
            this.checkPrimaryHolder(nodeObj, holdertype);
            return this.createIconNode(nodeParent, content, name, holdertype, nodeObj);
        case "spriteHolder": // for SPRITE sheet assets
            return this.createSpriteElement(nodeParent, this.diagramProps?.emphasisShape?.frame ? 0 : null);
        case "microChartHolder":
            this.checkPrimaryHolder(nodeObj, holdertype);
            return this.createMicroNode(nodeParent, content, name, holdertype, nodeObj);
        case "microChartNode":
            this.checkPrimaryHolder(nodeObj, holdertype);
            return this.createMicroValueNode(nodeParent, content, name, holdertype, nodeObj);
        case "shapeHolder":
            return this.createShapeNode(nodeParent, nodeObj, name, nodeObj);
        case "staticTextHolder":
            return this.createStaticContent(nodeParent, nodeObj);
        case "textLabelHolder":
            return this.createTextLabelHolder(nodeParent, this.objData.label, holdertype, nodeObj);
        case "subtextHolder":
            return this.createSubTextHolder(nodeParent, this.objData.subtext, holdertype, nodeObj);
        case "authorStyleGroup":
            this.authorStyle = new window["AuthorStyleGroup"](this.diagramProps, this.objData.author, this.index, { authorNameFontSize: this.authorNameFontSize, authorDesFontSize: this.authorDesFontSize, globalMoodData: this.globalMoodData }, this.diagramParent, this.appStaticURL, this.properties);
            this.authorStyle.createAuthorStyle(nodeParent, nodeObj);
            return;
        case "numberToggleStyleGroup":
            this.numberToggleStyle = new window["NumberToggleStyleGroup"](this.diagramProps, this.objData.number, this.index, { numberToggleFontSize: this.numberToggleFontSize, numberToggleDesFontSize: this.numberToggleDesFontSize }, nodeObj, this.appStaticURL);
            this.numberToggleStyle.createNumberToggleStyle(nodeParent, nodeObj);
            return;
        case "logoListHolder":
            this.createLogoListHolder(nodeParent, nodeObj, this.objData.seccontent);
            return;
        default:
            break;
    }
};

// Content / Sec Content holders creation

PlainDiagramNodeBase.prototype.createContentNode = function (bgDiv, nodeObj) {
    let nodeIndex = this.index;
    let nodeParent = document.createElement("div");
    bgDiv.appendChild(nodeParent);
    DiagramNodeUtils.assignAttributes(nodeParent, {
        class: "clsContentNode clsLegendShape clsValueBg" + " " + this.cardStyleContent,
        id: "contentNode" + nodeIndex,
        name: "contentNode",
        // "data-animation": "item",
        tabIndex: nodeIndex,
        "data-id": this.contentID,
        "data-type": this.contentID,
        "data-focus-parent": "nodeGroup",
        "data-index": nodeIndex,
        "data-nodetype": "contentContainer",
        name: "contentNode",
    });

    if (nodeObj.colorClass) nodeParent.classList.add(DiagramUtils.createColorClass(nodeObj.colorClass));
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, nodeParent);

    let bgNodeDiv = document.createElement("div");
    bgNodeDiv.className = "clsContentBackgound clsNodeAccentbg moodanimation";
    bgNodeDiv.setAttribute("id", "contentBackgound" + this.index);
    nodeParent.appendChild(bgNodeDiv);
    DiagramNodeUtils.assignAttributes(bgNodeDiv, { "data-index": nodeIndex, name: "contentBackgound", "data-nodetype": "contentBackground", "data-animation": "itembg" });
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, bgNodeDiv);
    // if (this.bgColorNode == "content") {
    //     // bgNodeDiv.classList.add(this.bgColor);
    //     bgNodeDiv.setAttribute("data-isvisible", true);
    //     if (this.bgOpacity) bgNodeDiv.style.setProperty("--bg-opacity", this.bgOpacity);
    // }

    if (this.bgColorNode == "content") {
        bgNodeDiv.classList.add(this.bgColor);
        bgNodeDiv.classList.add("clsBgDefault");
        if (this.bgOpacity) bgNodeDiv.style.setProperty("--bg-opacity", this.bgOpacity);
    }

    if (this.borderNode.includes("content")) {
        bgNodeDiv.classList.add(this.borderColor);
        bgNodeDiv.setAttribute("data-isvisible", true);
    }
    return nodeParent;
};

PlainDiagramNodeBase.prototype.getContentBGForDeviceAsset = function () {
    let isDeviceAsset = false;
    if (this.contentBG.id.includes("phone") || this.contentBG.id.includes("tab") || this.contentBG.id.includes("laptop") || this.contentBG.id.includes("desktop") || this.contentBG.id.includes("watch") || this.contentBG.id.includes("television")) {
        let deviceType = (this.globalMoodData && this.globalMoodData.devicestyle) || "photographic";
        this.contentBG.value = "genericassets/device/" + deviceType + "/" + (this.contentBG.oldid ? this.contentBG.oldid : this.contentBG.id) + ".svg";
        isDeviceAsset = true;
        let additionalId = this.diagramParent.parentElement.dataset.elementId;
        if (!this.contentBG.id.includes(additionalId)) {
            this.contentBG.oldid = this.contentBG.id;
            this.contentBG.id = additionalId + this.contentBG.id;
        }
    }
    return isDeviceAsset;
};

PlainDiagramNodeBase.prototype.parsecontentBG = function (bgNodeDiv, nodeIndex) {
    if (this.contentBG) {
        let isDeviceAsset = this.getContentBGForDeviceAsset();

        const bg = { value: this.contentBG.value, id: this.contentBG.id, type: this.contentBG.type ? this.contentBG.type : "icon" };

        if (bg.type == "png" || bg.type == "gif") {
            let imgDiv = document.createElement("img");
            imgDiv.className = "clsContentImage";
            imgDiv.setAttribute("id", "contentImage" + this.index);
            imgDiv.setAttribute("src", bg.value);
            bgNodeDiv.appendChild(imgDiv);
            DiagramNodeUtils.assignAttributes(imgDiv, { "data-index": nodeIndex, name: "contentImage", "data-nodetype": "contentImage" });
        } else {
            let svgNode = DiagramNodeUtils.createSVGDataNode(this.innerFill, bg.id, bg.value, nodeIndex, "contetntBGNode");
            bgNodeDiv.appendChild(svgNode);
            if (isDeviceAsset) {
                svgNode.setAttribute("data-nodetype", "deviceSVG");
                bgNodeDiv.setAttribute("data-nodetype", "deviceHolder");
                bgNodeDiv.parentElement.classList.add("clsDevice");
            }
            DiagramCreateUtil.updateManifest(bg, this.manifestUpdater, this.appStaticURL);
            bg.value = DiagramUtils.checkAppStaticUrl(this.contentBG.value, this.appStaticURL);
            let defsParent = isDeviceAsset ? this.diagramParent : document.body;
            DiagramAssetLoader.oneTimeDownload(bg, true, defsParent).then((svgData) => {
                let svgDefs = defsParent.querySelector("[id*='svgDefs']");
                let svgDOM = svgDefs.querySelector("svg[id='" + this.contentBG.id + "']");
                let bbox = svgNode.querySelector("use");
                if (this.contentBG.id.includes("award")) {
                    svgNode.setAttribute("width", bbox.getBBox().width);
                    svgNode.setAttribute("height", bbox.getBBox().height);
                    // svgNode.setAttribute("viewBox", "0 0 400 234");
                    bbox.setAttribute("class", "secondary-fill");
                    if (svgDOM) svgNode.setAttribute("viewBox", svgDOM.getAttribute("viewBox"));
                }
                if (this.contentBG.id == "semicircle") svgNode.setAttribute("data-loopanimation", "true");
                if (this.contentBG.colorClass) bbox.classList.add(DiagramUtils.createColorClass(this.contentBG.colorClass));
                // DiagramNodeUtils.replaceImagePathToNonLinearAssets(svgDOM, bg.value);
                // setTimeout(() => {
                if (this.contentBG.oldid && svgDOM) {
                    svgDOM.setAttribute("oldid", this.contentBG.oldid);
                }
                DiagramNodeUtils.applyNodeStyleClipPath(this.contentBG.id, this.diagramParent, this.index, null, defsParent);
                // }, 2000);
            });
        }
    }
};

PlainDiagramNodeBase.prototype.createSecContentNode = function (bgDiv, nodeObj) {
    let nodeParent = document.createElement("div");
    bgDiv.appendChild(nodeParent);
    DiagramNodeUtils.assignAttributes(nodeParent, {
        class: "clsSecContentNode" + " " + this.cardStyleSecContent,
        id: "secContentNode" + this.index,
        "data-index": this.index,
        "data-type": "secContentNode",
        name: "secContentNode",
    });
    // if (this.bgColorNode == "secContent") {
    //     nodeParent.classList.add(this.bgColor);
    //     if (this.bgOpacity) nodeParent.style.setProperty("--bg-opacity", this.bgOpacity);
    // }

    if (this.borderNode.includes("secContent")) {
        nodeParent.classList.add(this.borderColor);
    }
    if (nodeObj.colorClass) nodeParent.classList.add(DiagramUtils.createColorClass(nodeObj.colorClass));
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, nodeParent);

    let bgNodeDiv = document.createElement("div");
    bgNodeDiv.className = "clsSecContentBackgound moodanimation clsNodeAccentbg";
    bgNodeDiv.setAttribute("id", "secContentBackgound" + this.index);
    bgNodeDiv.setAttribute("data-animation", "secitembg");
    nodeParent.appendChild(bgNodeDiv);
    DiagramNodeUtils.assignAttributes(bgNodeDiv, { "data-index": this.index, name: "secContentBackgound" });
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, bgNodeDiv);

    if (this.bgColorNode == "secContent") {
        bgNodeDiv.classList.add(this.bgColor);
        bgNodeDiv.classList.add("clsBgDefault");
        if (this.bgOpacity) bgNodeDiv.style.setProperty("--bg-opacity", this.bgOpacity);
    }

    // if (this.bgColorNode == "secContent") {
    //     // bgNodeDiv.classList.add(this.bgColor);
    //     bgNodeDiv.setAttribute("data-isvisible",true);
    //     if (this.bgOpacity) bgNodeDiv.style.setProperty("--bg-opacity", this.bgOpacity);
    // }

    // if (this.borderNode.includes("secContent")) {
    //     bgNodeDiv.setAttribute("data-isvisible",true);
    //     bgNodeDiv.classList.add(this.borderColor);
    // }
    return nodeParent;
};

PlainDiagramNodeBase.prototype.createSecSubContentNode = function (bgDiv, nodeObj) {
    let nodeParent = document.createElement("div");
    bgDiv.appendChild(nodeParent);
    let hasAnimation = !nodeObj.hasOwnProperty("subNodes") || nodeObj.subNodes.length == 0;
    DiagramNodeUtils.assignAttributes(nodeParent, {
        id: "secSubContentNode" + this.index,
        class: "clsSubSecContentNode " + (hasAnimation ? "moodanimation" : "") + " " + this.cardStyleSubSecContent,
        "data-type": "secSubContentNode",
        "data-index": this.index,
        name: "secSubContentNode",
    });
    if (hasAnimation) {
        nodeParent.setAttribute("data-animation", "secsubitembg");
    }
    if (nodeObj.colorClass) nodeParent.classList.add(DiagramUtils.createColorClass(nodeObj.colorClass));
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, nodeParent);

    let bgNodeDiv = document.createElement("div");
    // bgNodeDiv.className = "clsSecSubContentBackgound";
    bgNodeDiv.className = "clsSecSubContentBackgound moodanimation";
    bgNodeDiv.setAttribute("id", "secSubContentBackgound" + this.index);
    bgNodeDiv.setAttribute("data-animation", "secsubitembg");
    nodeParent.appendChild(bgNodeDiv);
    DiagramNodeUtils.assignAttributes(bgNodeDiv, { "data-index": this.index, name: "secSubContentBackgound" });
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, bgNodeDiv);

    return nodeParent;
};

PlainDiagramNodeBase.prototype.createSubSecondaryContent = function (li, arrContentObj, value, item) {
    let intCount = arrContentObj.length;
    li.innerHTML = "";
    for (let i = 0; i < intCount; i++) {
        let nodeObj = arrContentObj[i];
        let nodeParent = this.createNodes(nodeObj, li, item);
        if (nodeObj.subNodes && nodeParent && nodeParent.getAttribute("name") != "subTitleHolder") {
            this.createNestedNodes(nodeObj.subNodes, nodeParent, item);
        }
    }
    li.innerHTML = li.innerHTML + value;
};

// Text nodes creation

PlainDiagramNodeBase.prototype.createTitle = function (bgDiv, primaryTextData, nodeObj) {
    let titleHolder = document.createElement("div");
    DiagramNodeUtils.assignAttributes(titleHolder, {
        class: "clsTitleParent moodanimation",
        "data-index": this.index,
        "data-animation": "primarytext",
        name: "titleHolder",
        "data-id": this.titleID,
        "data-dck-selector": true,
        id: this.titleID + this.index,
    });
    bgDiv.appendChild(titleHolder);
    const value = primaryTextData && primaryTextData.value ? primaryTextData.value : "";
    let fontSize = this.getFontSize("primaryText", nodeObj, this.titleFontSize, this.properties);
    let titleNode = DiagramCreateUtil.createLabel(
        this.index,
        "clsPrimaryText " + (nodeObj.colorClass ? " " : " clsPrimaryTextColor ") + fontSize + " " + DiagramCreateUtil.setHighlightClass(nodeObj.colorClass),
        "primaryText",
        nodeObj.prompt ? nodeObj.prompt : this.isQuote ? Constants.Value.primaryTextAuthorPrompt : this.isTestimonial ? Constants.Value.primaryTextTestimonialPrompt : Constants.Value.primaryTextPrompt,
        value,
        "nodeGroup"
    );
    let originalFontSize = DiagramNodeUtils.getOriginalFontSize("primaryText", nodeObj, this.titleFontSize, this.properties);
    DiagramNodeUtils.assignAttributes(titleNode, {
        id: "primaryText" + this.index,
        "data-type": "primaryText",
        "data-id": "primaryText",
        "data-highlight-event": "true",
        "data-observer": "true",
        "original-fontclass": originalFontSize,
        "original-fontbase": originalFontSize.split("")[0],
        "original-fontnumber": originalFontSize.split("")[1],
        // "data-fontresize": fontSize,
    });
    titleHolder.appendChild(titleNode);
    DiagramUtils.applyTextNodeProperties(titleNode, value, nodeObj, this.diagramProps, this.globalMoodData, Constants.Value.primaryTextColor, primaryTextData);
    this.observer.observe(titleNode, { childList: true });
    this.observer.mytargets.push(titleNode);
    return titleHolder;
};

PlainDiagramNodeBase.prototype.createSubTitle = function (bgDiv, nodeObj) {
    if (this.diagramProps.titlecomponent) return;

    let nodeData = this.objData.secondarytext || this.objData.subTitleHolder || nodeObj;
    let secondaryType = this.properties.secondarytype || "none";

    if (!nodeData) nodeData = { items: [{ type: "text", value: "" }] };
    nodeData.sublist = nodeData.sublist && nodeData.sublist != "none" ? nodeData.sublist : secondaryType != "none" ? secondaryType : "none";
    if (nodeData.sublist != "none" && nodeData.sublist != "decimal" && this.moodData && this.moodData.secondarylist && this.moodData.secondarylist.bullettype) nodeData.sublist = this.moodData.secondarylist.bullettype;
    let secondaryListType = DiagramUtils.getSecondaryType(nodeData.sublist);
    this.nodeGroup.setAttribute("data-sublist", secondaryListType);
    nodeData.sublist = secondaryListType;
    if (this.objData && this.objData.nodeproperties) this.objData.nodeproperties.sublist = secondaryListType;
    this.nodeGroup.style.setProperty("--secondarytexttype", this.isCustomType(secondaryListType) ? "none" : secondaryListType);
    this.nodeGroup.style.setProperty("--secondarytextpadding", secondaryListType == "none" ? "0px" : secondaryListType == "decimal" ? "36px" : "26px");

    let titleHolder = document.createElement("div");
    titleHolder.className = "clsSubTitleParent moodanimation moodClsSubTitle ";
    titleHolder.setAttribute("id", this.subTitleID + this.index);
    bgDiv.appendChild(titleHolder);
    DiagramNodeUtils.assignAttributes(titleHolder, {
        "data-index": this.index,
        name: "subTitleHolder",
        "data-id": this.subTitleID,
        "data-type": "secondaryText",
        "data-animation": "secondarytext",
    });
    let originalFontSize = DiagramNodeUtils.getOriginalFontSize("secondaryText", nodeObj, this.subTitleFontSize, this.properties);
    let fontSize = this.getFontSize("secondaryText", nodeObj, this.subTitleFontSize, this.properties);
    let ul = document.createElement("ul");
    ul.contentEditable = "true";
    ul.className = "clsSubTitleText " + (nodeObj.colorClass ? " " : " clsSecondaryTextColor ") + fontSize + " " + DiagramCreateUtil.setHighlightClass(nodeObj.colorClass);
    ul.setAttribute("data-focus-parent", "nodeGroup");
    ul.setAttribute("name", "secondaryText");
    ul.setAttribute("data-name", "text");
    ul.setAttribute("data-dck-selector", true);
    ul.setAttribute("data-id", "secondaryText");
    ul.setAttribute("id", "secondaryText" + this.index);
    ul.setAttribute("data-type", "secondaryText");
    ul.setAttribute("data-default-event", true);
    ul.setAttribute("data-observer", true);
    ul.setAttribute("data-highlight-event", true);
    ul.setAttribute("data-ignore-general-selector", "1");
    ul.setAttribute("original-fontclass", originalFontSize);
    ul.setAttribute("original-fontbase", originalFontSize.split("")[0]);
    ul.setAttribute("original-fontnumber", originalFontSize.split("")[1]);
    ul.setAttribute("original-fontresize", fontSize);
    ul.setAttribute("tabIndex", this.index);
    ul.setAttribute("data-prompt-text", nodeObj.prompt ? nodeObj.prompt : this.isQuote ? Constants.Value.secondaryTextAuthorPrompt : Constants.Value.secondaryTextPrompt);
    ul.setAttribute("data-index", this.index);
    titleHolder.appendChild(ul);

    DiagramUtils.applyTextNodeProperties(ul, null, nodeObj, this.diagramProps, this.globalMoodData, Constants.Value.secondaryTextColor, nodeData);

    let count = 0;
    let quote = this.isQuote;
    if (nodeData.items)
        nodeData.items.forEach((item, index) => {
            if (item.value && item.value != "") {
                let textNode = DiagramNodeUtils.createListNodes(ul, quote, count, nodeObj.prompt);
                textNode.innerHTML = item && item.value ? item.value : "";
                textNode.className = nodeData.sublist == "none" ? "secondaryTextItemNormal" : "secondaryTextItem";
                count = count + 1;
                TextHighLightUtils.updateHighlight(textNode, textNode.innerHTML);
                this.enableSecondarySubContent(textNode, textNode.innerHTML, index, item.content);
            }
        });
    if (!this.arrTextNodes.includes("subTitleHolder")) {
        titleHolder.style.setProperty("max-height", "28px");
    }

    if (ul.children.length == 0) {
        let textNode = DiagramNodeUtils.createListNodes(ul, quote, count, nodeObj.prompt);
        textNode.innerHTML = "";
        textNode.className = secondaryType == "none" ? "secondaryTextItemNormal" : "secondaryTextItem";
        textNode.setAttribute("data-list-index", count);
    }

    return titleHolder;
};

PlainDiagramNodeBase.prototype.createTextTitle = function (bgDiv, content, holdertype, nodeObj) {
    let titleHolder = document.createElement("div");
    DiagramNodeUtils.assignAttributes(titleHolder, {
        class: "clsTextTitleParent",
        "data-index": this.index,
        "data-dck-selector": true,
        name: "textTitleHolder",
        id: "textTitleHolder" + this.index,
        "data-holder-type": holdertype,
        "data-content-type": "text",
        "data-id": "contenttextparent",
    });
    bgDiv.appendChild(titleHolder);
    this.setDataAnimationToSecContent(holdertype, titleHolder);

    let value = content && content.type == "text" && content.value ? content.value : "";
    content.contenttype = "text";
    content.value = value;
    let fontSize = this.getFontSize("textNode", nodeObj, this.textFontSize, this.properties);

    let titleNode = DiagramCreateUtil.createLabel(
        this.index,
        "clsHolderText " + (nodeObj.colorClass ? " " : " clsPrimaryTextColor ") + fontSize + DiagramCreateUtil.setHighlightClass(nodeObj.colorClass),
        "textNode",
        nodeObj.prompt ? nodeObj.prompt : this.isQuote ? Constants.Value.holderTextQuotePrompt : Constants.Value.holderTextPrompt,
        value,
        "nodeGroup"
    );
    titleHolder.setAttribute("data-super-text", value.charAt(0).toUpperCase());
    titleNode.setAttribute("id", "textNode" + this.index);
    titleHolder.appendChild(titleNode);
    let originalFontSize = DiagramNodeUtils.getOriginalFontSize("textNode", nodeObj, this.textFontSize, this.properties);
    DiagramNodeUtils.assignAttributes(titleNode, {
        "data-index": this.index,
        "data-type": "textNode",
        "data-id": "textNode",
        "data-highlight-event": "true",
        "original-fontclass": originalFontSize,
        "original-fontbase": originalFontSize.split("")[0],
        "original-fontnumber": originalFontSize.split("")[1],
        // "data-fontresize": fontSize,
        "data-centernodefontresize": fontSize,
    });
    DiagramUtils.applyTextNodeProperties(titleNode, value, nodeObj, this.diagramProps, this.globalMoodData, Constants.Value.holderTextColor, content);
    return titleHolder;
};

PlainDiagramNodeBase.prototype.createTextLabelHolder = function (bgDiv, content, holdertype, nodeObj) {
    let titleHolder = document.createElement("div");
    DiagramNodeUtils.assignAttributes(titleHolder, {
        "data-index": this.index,
        class: "clsTextLabelHolder moodanimation",
        "data-animation": "labeltext",
        "data-dck-selector": true,
        // "data-holder-type": holdertype,
        "data-content-type": "text",
        name: "textLabelHolder",
        id: "textLabelHolder" + this.index,
    });
    bgDiv.appendChild(titleHolder);
    // this.setDataAnimationToSecContent(holdertype, titleHolder);
    let value = content && content.type == "text" && content.value ? content.value : "";
    let titleNode = DiagramCreateUtil.createLabel(
        this.index,
        "clsTextLabel clsSingleLineRestrict " + this.getFontSize("textLabel", nodeObj, this.textLabelFontSize, this.properties) + DiagramCreateUtil.setHighlightClass(nodeObj.colorClass),
        "textLabel",
        nodeObj.prompt ? nodeObj.prompt : Constants.Value.labelTextPrompt,
        value,
        "nodeGroup"
    );
    titleHolder.appendChild(titleNode);
    DiagramNodeUtils.assignAttributes(titleNode, { id: "textLabel" + this.index, "data-index": this.index, "data-type": "labelNode", "data-id": "labelNode" });
    DiagramUtils.applyTextNodeProperties(titleNode, value, nodeObj, this.diagramProps, this.globalMoodData, Constants.Value.labelTextColor, content);
    DiagramUtils.restrictMaxLines(titleNode);
    return titleHolder;
};

PlainDiagramNodeBase.prototype.createSubTextHolder = function (bgDiv, content, holdertype, nodeObj) {
    let titleHolder = document.createElement("div");
    DiagramNodeUtils.assignAttributes(titleHolder, {
        "data-index": this.index,
        class: "clsSubTextHolder moodanimation",
        "data-dck-selector": true,
        "data-animation": "subholdertext",
        // "data-holder-type": holdertype,
        "data-content-type": "text",
        name: "subTextHolder",
        id: "subTextHolder" + this.index,
    });
    bgDiv.appendChild(titleHolder);
    // this.setDataAnimationToSecContent(holdertype, titleHolder);
    let value = content && content.type == "text" && content.value ? content.value : "";

    let titleNode = DiagramCreateUtil.createLabel(
        this.index,
        "clsSubText " + (nodeObj.colorClass ? " " : " clsQuaternaryColor ") + this.getFontSize("subText", nodeObj, this.subTextFontSize, this.properties) + DiagramCreateUtil.setHighlightClass(nodeObj.colorClass),
        "subText",
        nodeObj.prompt ? nodeObj.prompt : Constants.Value.subTextPrompt,
        value,
        "nodeGroup"
    );
    titleHolder.appendChild(titleNode);
    DiagramNodeUtils.assignAttributes(titleNode, { id: "subText" + this.index, "data-index": this.index, "data-type": "subtextNode", "data-id": "subtextNode", "data-highlight-event": "true" });
    DiagramUtils.applyTextNodeProperties(titleNode, value, nodeObj, this.diagramProps, this.globalMoodData, Constants.Value.subTextColor, content);
    DiagramUtils.restrictMaxLines(titleNode, 2);
    return titleHolder;
};

PlainDiagramNodeBase.prototype.createButtonTitleHolder = function (bgDiv, content, holdertype, nodeObj) {
    let titleHolder = document.createElement("div");
    bgDiv.appendChild(titleHolder);
    DiagramNodeUtils.assignAttributes(titleHolder, {
        "data-index": this.index,
        name: "buttonTitleHolder",
        class: "clsButtonTitleParent",
        // "data-holder-type": holdertype,
        "data-dck-selector": true,
        "data-content-type": "button",
        "data-id": "contenttextparent",
        id: "buttonTitleHolder" + this.index,
    });
    this.setDataAnimationToSecContent(holdertype, titleHolder);

    let value = content && content.type == "text" && content.value ? content.value : nodeObj.prompt ? nodeObj.prompt : "Learn more";
    let titleNode = DiagramCreateUtil.createLabel(this.index, "clsHolderText clsSingleLineRestrict " + (nodeObj.fontClass || this.buttonFontSize), "buttonNode", nodeObj.prompt ? nodeObj.prompt : Constants.Value.buttonPrompt, value, "buttonTitleHolder");
    DiagramNodeUtils.assignAttributes(titleNode, { id: "buttonNode" + this.index, "data-index": this.index, "data-type": "text", "data-id": "buttonNode", name: "buttonNode" });
    titleHolder.appendChild(titleNode);
    DiagramUtils.applyTextNodeProperties(titleNode, null, nodeObj, this.diagramProps, this.globalMoodData, Constants.Value.primaryTextColor, null);
    if (this.innerColor && !nodeObj.colorClass) titleNode.classList.add(this.innerColor);
    return titleHolder;
};

PlainDiagramNodeBase.prototype.createValueTitle = function (bgDiv, content, holdertype, nodeObj) {
    content = DiagramCreateUtil.checkDefaultData(this.diagramParent, content, "number", this.appStaticURL, this.arrDefaults, this.index);
    let valueObj = {
        content: content,
        name: nodeObj.name,
        holdertype: holdertype,
        nodeObj: nodeObj,
        index: this.index,
        numberFontSize: this.numberFontSize,
        innerColor: this.innerColor,
        globalMoodData: this.globalMoodData,
        diagramParent: this.diagramParent,
        diagramProps: this.diagramProps,
    };
    if (nodeObj.charactercount) {
        this.diagramParent.setAttribute("data-charactercount", nodeObj.charactercount);
    }
    let titleHolder = DiagramCreateUtil.createValueTitle(bgDiv, valueObj, this.properties);
    let originalresizewidth = this.diagramParent.style.getPropertyValue("--originalresizewidth");
    if (this.index == 0 && holdertype == "primary" && !parseInt(originalresizewidth)) {
        this.diagramParent.style.setProperty("--originalresizewidth", titleHolder.offsetWidth + "px");
        this.diagramParent.style.setProperty("--originalresizeheight", titleHolder.offsetHeight + "px");
    }
    return titleHolder;
};

PlainDiagramNodeBase.prototype.createSeqTitle = function (bgDiv, nodeObj) {
    let titleHolder = document.createElement("div");
    // titleHolder.className = "clsSeqTitleParent moodanimation " + (this.bgColorNode == "sequence" ? "clsNodeAccentbg" : "");
    titleHolder.className = "clsSeqTitleParent moodanimation " + "clsNodeAccentbg ";
    titleHolder.setAttribute("id", this.numberID + this.index);
    titleHolder.setAttribute("data-type", "sequence");
    titleHolder.setAttribute("data-content-type", "sequence");
    bgDiv.appendChild(titleHolder);
    DiagramNodeUtils.assignAttributes(titleHolder, {
        "data-visible-status": this.properties.sequencetext,
        "data-animation": "sequencenumber",
        "data-index": this.index,
        "data-dck-selector": true,
        name: "seqTitleHolder",
        "data-id": this.numberID,
    });
    let content = DiagramUtils.getSeqMoodStyle(this.globalMoodData && this.globalMoodData.seqnumproperties, this.properties, "sequencenumber", this.index + 1, this.diagramParent.dataset.nodecount);
    // let titleNode = DiagramCreateUtil.createLabel(this.index, "clsSeqText "+this.seqNumberFontSize+" " + this.innerColor, "seqText", "", "0" + this.index + 1);
    let titleNode = DiagramCreateUtil.createLabel(this.index, "clsSeqText " + (nodeObj.fontClass || this.seqNumberFontSize), "seqText", "", content, "", false);
    titleNode.setAttribute("id", "sequenceText" + this.index);
    titleNode.setAttribute("data-type", "sequence");
    titleNode.setAttribute("data-content-type", "sequence");
    titleHolder.appendChild(titleNode);
    DiagramUtils.applyTextNodeProperties(titleNode, null, nodeObj, this.diagramProps, this.globalMoodData, Constants.Value.sequenceTextColor, null);

    if (this.innerColor && !nodeObj.colorClass) titleHolder.classList.add(this.innerColor);
    if (this.diagramProps.nodeclassName && this.diagramProps.nodeclassName.includes("ContentOptionNode")) {
        this.diagramParent.classList.remove("clssequencedisable");
        this.diagramParent.parentElement.style.setProperty("--numberdisplay", "flex");
    } else if (!this.properties.sequencetext) this.diagramParent.parentElement.style.setProperty("--numberdisplay", "none");
    DiagramNodeUtils.assignAttributes(titleNode, { "data-index": this.index, "data-id": "sequenceText" });
    return titleHolder;
};

PlainDiagramNodeBase.prototype.createMicroNode = function (parentNode, content, name, holdertype, nodeObj) {
    let microObj = {
        content: content,
        name: name,
        holdertype: holdertype,
        nodeObj: nodeObj,
        index: this.index,
        microchartFontSize: this.microchartFontSize,
        microStyle: this.microStyle,
        innerStroke: this.innerStroke,
        globalMoodData: this.globalMoodData,
        diagramParent: this.diagramParent,
    };
    DiagramCreateUtil.createMicroNode(parentNode, microObj);
    let microNode = parentNode.querySelector("[name='microchartNode']");
    if (nodeObj.microStyle) microNode.dataset.microStyle = nodeObj.microStyle;
};

PlainDiagramNodeBase.prototype.createMicroValueNode = function (parentNode, content, name, holdertype, nodeObj) {
    let microObj = {
        content: content,
        name: name,
        holdertype: holdertype,
        nodeObj: nodeObj,
        index: this.index,
        microchartFontSize: this.microchartFontSize,
        microStyle: this.microStyle,
        innerStroke: this.innerStroke,
        globalMoodData: this.globalMoodData,
        diagramParent: this.diagramParent,
    };
    DiagramCreateUtil.createMicroValueNode(parentNode, microObj);
};

PlainDiagramNodeBase.prototype.getFontSize = function (name, nodeObj, defaultFontSize, properties) {
    return DiagramNodeUtils.getFontSize(name, nodeObj, defaultFontSize, properties);
};

// Static nodes

PlainDiagramNodeBase.prototype.createStaticContent = function (bgDiv, nodeObj) {
    const className = "clsPrimaryText " + (nodeObj.fontClass || this.titleFontSize);
    const value = nodeObj && nodeObj.value ? nodeObj.value : "";
    let titleNode = DiagramCreateUtil.createLabel(this.index, className, "primaryText", "", value, "nodeGroup", false);
    titleNode.setAttribute("id", "staticTextHolder" + this.index);
    DiagramCreateUtil.checkTextContrast(nodeObj, titleNode);
    if (nodeObj.colorClass) titleNode.classList.add(DiagramUtils.createColorClass(nodeObj.colorClass));
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, titleNode);
    bgDiv.appendChild(titleNode);
    return titleNode;
};

PlainDiagramNodeBase.prototype.createMoodNode = function (bgDiv, nodeObj) {
    let nodeParent = document.createElement("div");
    nodeParent.className = "clsMoodNode moodanimation";
    nodeParent.setAttribute("id", "moodNode" + this.index);
    if (nodeObj.parent) bgDiv.parentElement.appendChild(nodeParent);
    else bgDiv.appendChild(nodeParent);
    DiagramNodeUtils.assignAttributes(nodeParent, {
        "data-index": this.index,
        "data-type": "moodNode",
        name: "moodNode",
        "data-animation": "item",
    });
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, nodeParent);
    return nodeParent;
};

PlainDiagramNodeBase.prototype.createCrossoutDiv = function (div) {
    let crossoutDiv = div.querySelector("[data-id='crossoutNode']");
    if (!crossoutDiv) {
        let crossoutParent = document.createElement("div");
        crossoutParent.className = "clsCrossoutParent moodanimation";
        crossoutParent.setAttribute("data-animation", "crossout");
        crossoutParent.setAttribute("name", "crossoutParent");
        crossoutDiv = document.createElement("div");
        crossoutDiv.className = "clsCrossout";
        crossoutDiv.setAttribute("id", "crossoutNode");
        crossoutDiv.setAttribute("data-id", "crossoutNode");
        crossoutParent.appendChild(crossoutDiv);
        div.appendChild(crossoutParent);
    }
};

PlainDiagramNodeBase.prototype.createSpriteElement = function (nodeParent, emphasisFrame) {
    let pngPath = DiagramUtils.checkAppStaticUrl(this.quoteShape.path, this.appStaticURL) + this.quoteShape.id + ".png";
    let assetelement = DiagramCreateUtil.createSpriteElement(nodeParent, this.diagramParent, this.index);
    try {
        let svgData = this.animatedSprites?.[this.quoteShape.id];
        DiagramUtils.parseImageSprites(nodeParent, svgData, this.quoteShape, pngPath, assetelement, this?.index, this?.diagramParent?.dataset?.nodecount, emphasisFrame);
    } catch (error) {
        console.log("sprit json load error ", error);
    }
    return assetelement.parentElement;
};

PlainDiagramNodeBase.prototype.updatePropsCallBack = function (id = "ELEMENT_DIV") {
    if (this.updateCallBack && this.updateCallBack.func) {
        // this.updateCallBack.func(this.updateCallBack.params, "ql-editor0");
        this.updateCallBack.func(this.updateCallBack.params, id);
    }
};
// Placeholders creation
PlainDiagramNodeBase.prototype.createDeviceImageHolder = function (parentNode, nodeData, nodeName = "imageHolder", holdertype, nodeObj) {
    let deviceImageHolder = document.createElement("div");
    deviceImageHolder.className = "clsDeviceImageHolder";
    deviceImageHolder.setAttribute("id", nodeName + this.index);
    deviceImageHolder.setAttribute("data-index", this.index);
    deviceImageHolder.setAttribute("data-id", nodeName);

    let imageHolder = this.createImageNode(parentNode, nodeData, "imageHolder", holdertype, nodeObj);
    deviceImageHolder.appendChild(imageHolder);
    parentNode.appendChild(deviceImageHolder);
    return deviceImageHolder;
};

PlainDiagramNodeBase.prototype.createImageNode = function (parentNode, nodeData, nodeName = "imageHolder", holdertype, nodeObj) {
    let islogo = nodeObj.islogo || nodeData?.contenttype == "logo";
    let alignment = nodeObj.alignment;
    if (nodeName == "imageSecHolder" && !alignment && this.diagramProps && (this.diagramProps.name.includes("hor-") || this.diagramProps.name.includes("grd-"))) {
        let moodAlign = window.getComputedStyle(this.diagramParent).getPropertyValue("--logoalignment");
        alignment = moodAlign.trim() == "left" ? "leftbottom" : "bottom";
    }
    alignment = this.properties?.graphicData?.alignment || alignment;
    if (parentNode && parentNode.getAttribute("name") && parentNode.getAttribute("name") == "nodeBackgound" && this.objData.bgimage) {
        nodeData = this.objData.bgimage;
    }
    if (!islogo && nodeData.value && nodeData.value != "" && !nodeData.value.includes("placeholder.png") && nodeData.contenttype == "logo") nodeData.contenttype = "image";
    else if (islogo && nodeData.value && nodeData.value != "" && !nodeData.value.includes("placeholder.png") && nodeData.contenttype == "image") nodeData.contenttype = "logo";
    else nodeData = DiagramCreateUtil.checkDefaultData(this.diagramParent, nodeData, islogo ? "logo" : "image", this.appStaticURL, this.arrDefaults, this.index);
    if (holdertype == "primary") this.objData.content = nodeData;
    if (!islogo && nodeData.value.includes("logoplaceholder_landscape.png")) nodeData = DiagramNodeUtils.diagramContentData("image", this.appStaticURL, this.arrDefaults, this.index);
    let isTeamAsset = this.diagramProps && this.diagramProps.name.includes("-team");
    if (isTeamAsset && nodeData.value.includes("placeholder.png")) {
        let nodeDataObj = DiagramNodeUtils.diagramContentData("teamimage", this.appStaticURL, this.arrDefaults, this.index);
        nodeData.value = nodeDataObj.value;
    }
    if (this.properties && this.properties.floateroptionsdisable && this.properties.floateroptionsdisable.includes("logocontrast")) {
        nodeObj.disablelogocontrast = true;
    }
    if (this.properties && this.properties.floateroptionsdisable && this.properties.floateroptionsdisable.includes("overlay")) {
        nodeObj.contrastimagesource = null;
    }
    let imageHolder = DiagramCreateUtil.createImageNode(parentNode, nodeData, nodeName, this.index, holdertype, this.objStyleData.selectorList, alignment, "", this.defaultImageLoadCallBack || this.updateCallBack, nodeObj, this.appStaticURL);
    if (nodeObj.authorimage) imageHolder.setAttribute("data-authorimage", "true");
    this.setDataAnimationToSecContent(holdertype, imageHolder);
    if (nodeData.logodata && nodeData.logodata.length > 0) DiagramNodeUtils.setLogoUrlData(imageHolder, nodeData.logodata, nodeData.logodata[0].baseurl);
    // if (this.index == 0 && islogo) {
    let originalWidth = this.diagramParent.style.getPropertyValue("--originalresizewidth");
    if (this.index == 0 && holdertype == "primary" && imageHolder.offsetHeight > 0 && (originalWidth == "" || originalWidth == null)) {
        this.diagramParent.style.setProperty("--originalresizewidth", imageHolder.offsetWidth + "px");
        this.diagramParent.style.setProperty("--originalresizeheight", imageHolder.offsetHeight + "px");
    }
    // this.needAssetUpdate(imageHolder, nodeData);
    return imageHolder;
};

PlainDiagramNodeBase.prototype.needAssetUpdate = function (imageHolder, nodeData, centerNode = false) {
    let assetText = nodeData?.assetText;
    let assetNode = imageHolder.querySelector("[data-id='logoNode']") || imageHolder.querySelector("[data-id='imageNode']") || imageHolder.querySelector("[data-id='iconNode']");
    if (assetNode && assetNode.parentElement && nodeData.needAssetUpdate && assetText) {
        nodeData.needAssetUpdate = false;
        assetNode.parentElement.setAttribute("data-node-graphic-text", assetText);
        let type = assetNode.parentElement.dataset.nodeContentType;
        DiagramUtils.searchAIcall(type, this.objData, assetText, this.properties, this.globalMoodData, centerNode ? imageHolder : assetNode, this.index, this.searchIconCallBack, appBaseURL, this.appStaticURL);
    }
};

PlainDiagramNodeBase.prototype.createIconNode = function (parentNode, nodeData, nodeName = "iconHolder", holdertype, nodeObj) {
    let iconSVGBackground = null;
    if (this.contentIconBG) {
        if (this.properties.bg) iconSVGBackground = { value: this.appStaticURL + this.properties.bg.path, id: this.properties.bg.id };
        else iconSVGBackground = { value: this.appStaticURL + this.contentIconBG.value, id: this.contentIconBG.id };
    }
    nodeData = DiagramCreateUtil.checkDefaultData(this.diagramParent, nodeData, "icon", this.appStaticURL, this.arrDefaults, this.index);
    let isIllustration = this.quoteShape && this.quoteShape.type && this.quoteShape.type == "illustration";
    let isPlaceholder = nodeData.id && nodeData.id.includes("placeholder");
    // if (this.quoteShape && isPlaceholder) {
    let isIconSecHolder = DiagramUtils.getObjectFromName(this.diagramProps.supportedNodes, "iconSecHolder");
    if (this.quoteShape && ((isIconSecHolder && nodeName == "iconSecHolder") || (!isIconSecHolder && nodeName == "iconHolder"))) {
        if (this.quoteShape.type && this.quoteShape.type == "counting") {
            nodeData.id = this.quoteShape.id + (this.index + 1);
            nodeData.value = this.quoteShape.path + nodeData.id + ".svg";
        } else {
            nodeData.id = this.quoteShape.id;
            nodeData.value = this.quoteShape.value;
            if (this.quoteShape.type) {
                this.diagramParent.setAttribute("data-nodetype", this.quoteShape.type);
            }
        }
    }

    let colorClass = this.diagramProps?.nodecontentcolor || nodeObj.colorClass;
    let colorData = colorClass ? DiagramUtils.createColorClass(colorClass) : this.innerFill;

    let iconHolder = DiagramCreateUtil.createIconNode(parentNode, nodeData, nodeName, this.index, this.appStaticURL, iconSVGBackground, colorData, holdertype, nodeObj, this.defaultIconLoadCallBack || this.iconLoadCallback.bind(this), this.manifestUpdater);
    if (nodeData.groupid) iconHolder.setAttribute("data-groupid", nodeData.groupid);
    let originalresizewidth = this.diagramParent.style.getPropertyValue("--originalresizewidth");
    if (this.index == 0 && holdertype == "primary" && !parseInt(originalresizewidth)) {
        // setTimeout(() => {
        this.diagramParent.style.setProperty("--originalresizewidth", iconHolder.offsetWidth + "px");
        this.diagramParent.style.setProperty("--originalresizeheight", iconHolder.offsetHeight + "px");
        // }, 500);
    }

    this.setDataAnimationToSecContent(holdertype, iconHolder);
    if (this.quoteShape && !isIllustration) {
        iconHolder.setAttribute("data-allowchange", "false");
        if (this.diagramProps?.name.includes("qt")) iconHolder.removeAttribute("data-holder-type");
    }
    let iconBG = iconHolder.querySelector("[name='iconBG']");
    iconBG.classList.add("clsNodeAccentbg");

    return iconHolder;
};

PlainDiagramNodeBase.prototype.iconLoadCallback = function (nodeData) {
    DiagramCreateUtil.updateManifest(nodeData, this.manifestUpdater, this.appStaticURL);
    try {
        this.updatePropsCallBack();
    } catch (error) {
        console.log("error in updatePropsCallBack iconLoadCallback", error);
    }
};

PlainDiagramNodeBase.prototype.createShapeNode = function (parentNode, nodeData, nodeName = "iconHolder", nodeObj) {
    let colorData = nodeObj.colorClass ? DiagramUtils.createColorClass(nodeObj.colorClass) : this.innerFill;
    let node = DiagramCreateUtil.createShapeNode(parentNode, nodeData, nodeName, this.index, this.appStaticURL, null, colorData);
    if (!nodeData.value.includes(this.appStaticURL)) nodeData.value = this.appStaticURL + nodeData.value;
    DiagramCreateUtil.updateManifest(nodeData, this.manifestUpdater, this.appStaticURL);
    return node;
};

// Center node creation

PlainDiagramNodeBase.prototype.createCenterNode = function (pattenDiv) {
    let centerHolderParent = document.createElement("div");
    centerHolderParent.setAttribute("data-id", "centerHolderParent");
    centerHolderParent.className = "centerHolderParent clsMultiColorParent";
    centerHolderParent.setAttribute("name", "centerHolderParent");
    centerHolderParent.setAttribute("data-name", "centerHolderParent");
    centerHolderParent.setAttribute("id", "centerHolderParent" + this.index);

    let intCount = this.centerNode.length;
    for (let i = 0; i < intCount; i++) {
        let nodeObj = this.centerNode[i];
        let nodeParent = this.createNodes(nodeObj, centerHolderParent);
        if (nodeParent) nodeParent.setAttribute("data-focus-parent", "centerHolderParent");
        let focusDiv = nodeParent?.querySelector("[data-focus-parent]");
        if (focusDiv) {
            focusDiv.setAttribute("data-focus-parent", "centerHolderParent");
        }
        if (nodeObj.subNodes && nodeParent) {
            this.createNestedNodes(nodeObj.subNodes, nodeParent);
        }
    }

    let arrAnimateElement = centerHolderParent.querySelectorAll(".moodanimation");

    arrAnimateElement.forEach((animateElement) => {
        animateElement.dataset.animation = "commonplaceholder";
    });

    centerHolderParent.setAttribute("data-type", centerHolderParent.firstElementChild.dataset.type);
    centerHolderParent.setAttribute("data-content-type", centerHolderParent.firstElementChild.dataset.contentType);
    centerHolderParent.setAttribute("data-focus-parent", "centerHolderParent");
    pattenDiv.appendChild(centerHolderParent);
    this.parentNode = centerHolderParent;
    this.setLinkData();
    this.centerNodeAssetUpdate(centerHolderParent);
    return centerHolderParent;
};

PlainDiagramNodeBase.prototype.centerNodeAssetUpdate = function (centerHolderParent) {
    let content = this.objData.content || this.objData;
    if (content) {
        if (!content.assetText) {
            let title = this.diagramParent?.parentElement?.parentElement?.parentElement?.querySelector("[id='TITLE']");
            if (title) {
                content.assetText = title.innerText;
                content.needAssetUpdate = true;
            }
        }
        this.needAssetUpdate(centerHolderParent, content, true);
    }
};

PlainDiagramNodeBase.prototype.createCommonNode = function (parent, i) {
    let commonNodeParent = document.createElement("div");
    commonNodeParent.setAttribute("data-id", "commonNodeParent");
    commonNodeParent.className = "commonNodeParent moodanimation";
    commonNodeParent.setAttribute("name", "commonNodeParent");
    commonNodeParent.setAttribute("data-name", "commonNodeParent");
    commonNodeParent.setAttribute("id", "commonNodeParent" + i);

    this.nodeGroup = this.createNodeGroup(commonNodeParent);
    this.nodeGroup.setAttribute("id", "nodeGroupCommon" + i + "");
    this.nodeGroup.setAttribute("name", "nodeGroupCommon");
    this.nodeGroup.setAttribute("data-name", "nodeGroupCommon");
    commonNodeParent.appendChild(this.nodeGroup);

    let intCount = this.centerNode.length;
    for (let i = 0; i < intCount; i++) {
        let nodeObj = this.centerNode[i];
        let nodeParent = this.createNodes(nodeObj, this.nodeGroup);
        // if (nodeParent) nodeParent.setAttribute("data-focus-parent", "centerHolderParent");
        if (nodeObj.subNodes && nodeParent) {
            this.createNestedNodes(nodeObj.subNodes, nodeParent);
        }
    }

    let arrChild = Array.from(commonNodeParent.querySelectorAll("[data-focus-parent]"));
    arrChild.map((child) => child.setAttribute("data-focus-parent", "nodeGroupCommon"));

    commonNodeParent.setAttribute("data-type", this.objData.content.contenttype);
    commonNodeParent.setAttribute("data-focus-parent", "commonNodeParent");
    parent.appendChild(commonNodeParent);
    this.parentNode = commonNodeParent;
    return commonNodeParent;
};

// Connector node creation

PlainDiagramNodeBase.prototype.createConnectorParent = function (parentNode, nodeData, isLastNode, name = "connectorparent") {
    let quillNode = DiagramUtils.getObjectFromName(this.arrSupportedNodes, "multiTextNode");
    if (quillNode) return;

    let seperatorMoodData = DiagramUtils.getSeperatorObject(this.globalMoodData?.basicgraphics, this.diagramParent.dataset.classname);
    let seperatorLineData = this.seperatorline || seperatorMoodData?.seperatorline;
    let connectorData = this.connector || seperatorMoodData?.connector;
    let connectorTextData = this.connectortext || seperatorMoodData?.connectortext;
    if ((this.diagramParent.dataset?.nodename?.includes("agenda") && !this.diagramParent.dataset?.nodename?.includes("hor-")) || this.diagramParent.dataset?.nodename?.includes("ver-num") || this.diagramParent.dataset?.nodename?.includes("ver-bul") || this.diagramParent.dataset?.nodename?.includes("ver-ckd")) {
        // if (isLastNode && !this.properties.seperatorline) {
        //     return;
        // }
    } else if (isLastNode) return;

    let connectorNodeParent = document.createElement("div");
    DiagramNodeUtils.assignAttributes(connectorNodeParent, {
        name: name,
        class: "nodeconnectorParent",
        id: name + this.index,
        "data-id": name,
        "data-index": this.index,
        "data-node-name": name,
    });
    parentNode.appendChild(connectorNodeParent);
    if (connectorTextData) this.createConnectorText(connectorNodeParent, connectorTextData);
    if (connectorData || seperatorLineData) {
        return this.createConnector(connectorNodeParent, connectorData, seperatorLineData);
    }
};

PlainDiagramNodeBase.prototype.createConnectorText = function (parentNode, nodeData, name = "connectortext") {
    let colorData = nodeData.colorClass ? DiagramUtils.createColorClass(nodeData.colorClass) : "accent" + (this.index + 1) + "-color";
    let connectortext = document.createElement("div");
    let position = nodeData.position && nodeData.position == "alternate" ? (this.index % 2 ? "bottom" : "top") : nodeData.position || "top";
    DiagramNodeUtils.assignAttributes(connectortext, {
        name: name,
        class: "nodeconnectortext moodanimation ",
        id: name + this.index,
        "data-id": name,
        "data-index": this.index,
        "data-node-name": name,
        "data-position": position,
        "data-animation": "connectortext",
        tabIndex: this.index,
        "data-ignore-general-selector": "1",
    });
    let connectortextNode = document.createElement("div");
    name = "connectortextNode";
    DiagramNodeUtils.assignAttributes(connectortextNode, {
        name: name,
        class: "nodeconnectortextnode  " + (nodeData.fontClass || this.connectorTextFontSize),
        id: name + this.index,
        "data-id": name,
        "data-index": this.index,
        "data-node-name": name,
        "data-name": "text",
        contentEditable: "true",
        "data-prompt-text": Constants.Value.connectorTextPrompt,
        tabIndex: this.index,
        "data-ignore-general-selector": "1",
        "data-default-event": true,
    });
    DiagramUtils.setColorClass(connectortextNode, nodeData, this.globalMoodData, Constants.Value.connectorTextColor);
    if (nodeData.opacity) {
        connectortext.style.opacity = nodeData.opacity;
        if (parseFloat(nodeData.opacity) != 1) connectortext.setAttribute("data-customopacity", nodeData.opacity);
    }
    let value = this.objData.customconnectortext ? this.objData.customconnectortext.value : "Connector text";
    connectortextNode.innerText = value;
    connectortext.appendChild(connectortextNode);
    parentNode.appendChild(connectortext);
    let nodeName = connectortext.getAttribute("name");
    if (!this.arrTextNodes.includes(nodeName)) this.arrTextNodes.push(nodeName);
};

PlainDiagramNodeBase.prototype.createConnector = function (parentNode, nodeDataConnector, nodeDataSeperatorLine, name = "connector") {
    let connectorNode = document.createElement("div");
    DiagramNodeUtils.assignAttributes(connectorNode, {
        name: name,
        class: "nodeconnector moodanimation ",
        id: name + this.index,
        "data-id": name,
        "data-type": name,
        "data-index": this.index,
        "data-node-name": name,
        "data-animation": "connector",
    });

    parentNode.appendChild(connectorNode);

    let arrowHolderNode = document.createElement("div");
    DiagramNodeUtils.assignAttributes(arrowHolderNode, {
        name: "arrowHolderNode",
        class: "arrowHolderNode",
        id: "arrowHolderNode" + this.index,
        "data-id": "arrowHolderNode",
    });
    connectorNode.appendChild(arrowHolderNode);

    let arrowNode = document.createElement("div");
    DiagramNodeUtils.assignAttributes(arrowNode, {
        name: "arrowNode",
        class: "arrowNode ",
        id: "arrowNode0",
        "data-id": "arrowNode",
    });
    arrowHolderNode.appendChild(arrowNode);

    if (nodeDataConnector) {
        // let removeRightArrow = this.properties.floateroptionsdisable && (this.properties.floateroptionsdisable.includes("arrowright") || this.properties.floateroptionsdisable.includes("arrownone"));
        nodeDataConnector.style = this.objData.customconnector ? this.objData.customconnector.style : this.properties.connectorstyle ? this.properties.connectorstyle : nodeDataConnector.style || "arrownone";
        // if (removeRightArrow && (nodeDataConnector.style == "arrowright" || nodeDataConnector.style == "arrownone")) {
        //     nodeDataConnector.style = "plus";
        // }
        if (this.properties.floateroptionsdisable && this.properties.floateroptionsdisable.includes(nodeDataConnector.style)) {
            let isAdded = false;
            Constants.Value.arrConnectors.forEach((element) => {
                if (nodeDataConnector.style != element && !this.properties.floateroptionsdisable.includes(element) && !isAdded) {
                    nodeDataConnector.style = element;
                    this.properties.connectorstyle = element;
                    isAdded = true;
                    this.diagramParent.setAttribute("data-connectorstyle", element);
                }
            });
        }

        connectorNode.setAttribute("data-customconnectorstyle", nodeDataConnector.style);
        connectorNode.classList.add("cls" + nodeDataConnector.style);

        if (nodeDataConnector.opacity) {
            if (parseFloat(nodeDataConnector.opacity) != 1) connectorNode.setAttribute("data-customopacity", nodeDataConnector.opacity);
            parentNode.style.setProperty("--nodeconnectoropacity", nodeDataConnector.opacity);
        }
        if (nodeDataConnector.class) DiagramUtils.addClassList(parentNode, nodeDataConnector.class);
        // parentNode.classList.add(nodeDataConnector.class);
        let colorData = nodeDataConnector?.color || "clsNodeAccentbg";
        arrowNode.classList.add(colorData);
    }
    if (nodeDataSeperatorLine) {
        if (nodeDataSeperatorLine.opacity) {
            if (parseFloat(nodeDataSeperatorLine.opacity) != 1) connectorNode.setAttribute("data-customopacity", nodeDataSeperatorLine.opacity);
            parentNode.style.setProperty("--nodeseperatorlineopacity", nodeDataSeperatorLine.opacity);
        }
    }
    let arrowHolderNode1 = arrowHolderNode.cloneNode(true);
    DiagramNodeUtils.assignAttributes(arrowHolderNode1, {
        name: "arrowHolderNode1",
        class: "arrowHolderNode1",
        id: "arrowHolderNode1",
        "data-id": "arrowHolderNode1",
    });
    connectorNode.appendChild(arrowHolderNode1);

    if (nodeDataConnector?.style) {
        return connectorNode;
    } else return null;
};

PlainDiagramNodeBase.prototype.updateLogoListLoadCallback = function (nodeGroup) {
    this.alignArrowOnFocus();
};

PlainDiagramNodeBase.prototype.alignArrowOnFocus = function () {
    let hasconnector = this.properties.hasconnector;
    if (!hasconnector) return;
    let index = this.index;
    let parentNode = this.diagramParent.querySelector("[id='nodeparent" + index + "']");
    let connectorNode = this.diagramParent.querySelector("[id='connector0']");
    if (connectorNode) {
        let connectorMinGap = DiagramNodeUtils.getGapForConnectors(this.diagramProps, index, this.diagramParent, this.properties, true);
        let gap = DiagramNodeUtils.getGapForConnectors(this.diagramProps, index, this.diagramParent, this.properties);
        DiagramNodeUtils.alignCssArrowNode(this.diagramProps, parentNode, connectorNode, gap, connectorMinGap);
    }
};
// Other nodes creation

PlainDiagramNodeBase.prototype.createLogoListHolder = function (bgDiv, nodeObj, seccontent) {
    this.gridInstance = new window["SimpleImageGrid"](bgDiv, this.diagramProps, this.appStaticURL, DiagramUtils.getDefaultDataForLogoList(this.arrDefaults, this.diagramProps), nodeObj);
    this.gridInstance.searchIconCallBack = this.searchIconCallBack;
    this.gridInstance.nodeIndex = this.index;
    this.diagramParent.classList.add("clsLinerDiagram");
    this.diagramParent.classList.add("clsLinearImageGridNode");
    // if (!nodeObj.class && this.diagramProps && this.diagramProps.name.includes("hor-")) {
    if (!nodeObj.class) {
        let moodAlign = window.getComputedStyle(this.diagramParent).getPropertyValue("--logogridalignment");
        nodeObj.class = moodAlign == "left" ? "clsLinearImageGridNode" : "clsLinearImageGridNodecenter";
    }
    DiagramUtils.addClassNames(nodeObj.class, this.parentNode.parentElement);
    let gridImages = this.getLogoListDataFromSecondary(seccontent);
    if (gridImages && gridImages.length > 0) this.gridInstance.gridimages = gridImages;
    this.gridInstance.updateCallBack = this.updateCallBack;
    this.gridInstance.completeCallback = this.updateLogoListLoadCallback.bind(this);
    // this.gridInstance.focusCallBack = this.updateOnFocusOut;
    this.gridInstance.focusCallBack = {
        func: this.updateOnFocusOut.bind(this),
    };
    this.gridInstance.initDiagramCreationNode(this.index, nodeObj, bgDiv);
    // DiagramUtils.addClassNames(nodeObj.class, bgDiv.firstElementChild);
};

PlainDiagramNodeBase.prototype.enableSecondarySubContent = function (li, value, index, item = null) {
    let sublist = (this.objData && this.objData.secondarytext && this.objData.secondarytext.sublist) || "none";
    switch (sublist) {
        case "icon":
            let iconListHolder = li.querySelector("[name='iconListHolder']");
            if (!iconListHolder) {
                this.createSubSecondaryContent(li, [{ name: "secSubContentNode", subNodes: [{ name: "iconListHolder" }] }], value, item);
                iconListHolder = li.querySelector("[name='iconListHolder']");
            }
            iconListHolder?.setAttribute("id", "iconListHolder" + iconListHolder?.getAttribute("data-index") + index);
            break;
        case "number":
            let valueListHolder = li.querySelector("[id*='valueListHolder']");
            if (!valueListHolder) {
                this.createSubSecondaryContent(li, [{ name: "secSubContentNode", subNodes: [{ name: "valueListHolder" }] }], value, item);
                valueListHolder = li.querySelector("[id*='valueListHolder']");
            }
            valueListHolder?.setAttribute("id", "valueListHolder" + valueListHolder?.getAttribute("data-index") + index);
            break;
        case "image":
        case "logo":
            let imageListHolder = li.querySelector("[name='imageListHolder']");
            if (!imageListHolder) {
                this.createSubSecondaryContent(li, [{ name: "secSubContentNode", subNodes: [{ name: "imageListHolder", islogo: sublist == "logo" ? true : false, alignment: "center" }] }], value, item);
                imageListHolder = li.querySelector("[name='imageListHolder']");
            }
            imageListHolder?.setAttribute("id", "imageListHolder" + imageListHolder?.getAttribute("data-index") + index);
            if (imageListHolder) CommonImageUtils.updateImageBounds(li, { isimagefit: this.properties.isimagefit, islogofit: sublist == "logo", contenttype: sublist }, 1);
            break;
        case "check":
            let checkListHolder = li.querySelector("[data-id='checklistNode']");
            if (!checkListHolder) {
                this.createSubSecondaryContent(
                    li,
                    [
                        {
                            name: "secSubContentNode",
                            subNodes: [{ name: "checkListSecHolder", checkedClass: "checkListSecTick", nodeClass: "checkListSecNode" }],
                            // subNodes: [{ name: "checkListHolder"}],
                        },
                    ],

                    value,
                    item
                );
                checkListHolder = li.querySelector("[data-id='checklistNode']");
                if (item) {
                    let isChecked = item.value && item.value == "true";
                    if (isChecked) {
                        checkListHolder?.parentElement?.classList.add("checkListSecTick");
                    } else {
                        checkListHolder?.parentElement?.classList.remove("checkListSecTick");
                    }
                    checkListHolder?.setAttribute("data-ischecked", isChecked);
                }
            }
            checkListHolder?.setAttribute("id", "checkListHolder" + checkListHolder?.getAttribute("data-index") + index);
            break;
        default:
            this.removeAllSubContent(li);
            break;
    }
    let secSubContentNode = li.querySelector("[name='secSubContentNode']");
    if (secSubContentNode) secSubContentNode.setAttribute("id", "secSubContentNode" + secSubContentNode.getAttribute("data-index") + index);
};

PlainDiagramNodeBase.prototype.createCheckListNode = function (bgDiv, nodeObj, nodeData) {
    let contentParentNode = document.createElement("div");
    contentParentNode.className = "checkbox moodanimation";
    contentParentNode.setAttribute("data-id", "checklistNode");
    contentParentNode.setAttribute("data-animation", "item");
    contentParentNode.setAttribute("data-index", this.index);
    contentParentNode.setAttribute("data-type", "checklist");
    contentParentNode.setAttribute("name", "checkListHolder");
    bgDiv.setAttribute("data-content-type", "checklist");
    contentParentNode.setAttribute("data-checkbox-event", "true");
    contentParentNode.setAttribute("data-checkedClass", nodeObj.checkedClass);
    this.properties.contenttype = "checklist";
    let checkmark = document.createElement("div");
    checkmark.setAttribute("data-id", "checkmark");
    checkmark.setAttribute("name", "checkmark");

    // if (Object.keys(nodeData).length == 0) nodeData = DiagramCreateUtil.checkDefaultData(this.diagramParent, nodeData, "checklist", this.appStaticURL);
    // nodeData.value = nodeData.value.toString();
    let ischecked = this.objData && this.objData.nodeproperties && this.objData.nodeproperties.ischecked;
    if (!this.objData.nodeproperties) {
        ischecked = nodeData.value;
    }
    checkmark.setAttribute("data-ischecked", ischecked);
    contentParentNode.setAttribute("data-ischecked", ischecked);
    checkmark.className = "checkmark";
    contentParentNode.appendChild(checkmark);
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, contentParentNode);
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, checkmark);
    let checkmarksvg = DiagramNodeUtils.createSVGElement("svg");
    checkmarksvg.innerHTML = '<svg id="tick-main" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48"><polygon points="20.3 31.8 14.2 25.8 16.3 23.7 20.3 27.6 31.7 16.2 33.8 18.3 20.3 31.8" stroke="none" /></svg>';
    checkmarksvg.setAttribute("class", "checkmarksvg");
    checkmarksvg.setAttribute("data-id", "checkmarksvg");
    checkmark.appendChild(checkmarksvg);

    if (this.diagramProps.checkBG) {
        let objAssets = { id: this.diagramProps.checkBG.id, value: this.appStaticURL + this.diagramProps.checkBG.value };
        DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body)
            .then((svgData) => {
                checkmarksvg.innerHTML = svgData.data;
                checkmarksvg.style.display = ischecked ? "flex" : "none";
            })
            .catch((error) => {
                console.log("SVG asset load fail - " + error);
            });
    }

    if (this.diagramProps.uncheckBG) {
        let uncheckmarksvg = DiagramNodeUtils.createSVGElement("svg");
        uncheckmarksvg.setAttribute("class", "uncheckmarksvg");
        uncheckmarksvg.setAttribute("data-id", "uncheckmarksvg");
        checkmark.appendChild(uncheckmarksvg);
        let objAssets = { id: this.diagramProps.uncheckBG.id, value: this.appStaticURL + this.diagramProps.uncheckBG.value };
        DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body)
            .then((svgData) => {
                uncheckmarksvg.innerHTML = svgData.data;
                uncheckmarksvg.style.display = ischecked ? "none" : "flex";
            })
            .catch((error) => {
                console.log("SVG asset load fail - " + error);
            });
    }

    bgDiv.appendChild(contentParentNode);
    return contentParentNode;
};

PlainDiagramNodeBase.prototype.createCheckListSecNode = function (bgDiv, nodeObj, nodeData) {
    let contentParentNode = document.createElement("div");
    contentParentNode.className = "checkbox moodanimation";
    contentParentNode.setAttribute("data-id", "checklistNode");
    contentParentNode.setAttribute("data-animation", "item");
    contentParentNode.setAttribute("data-index", this.index);
    bgDiv.setAttribute("data-content-type", "checklist");
    contentParentNode.setAttribute("data-checkbox-event", "true");
    contentParentNode.setAttribute("data-checkedClass", nodeObj.checkedClass);
    this.properties.contenttype = "checklist";
    let checkmark = document.createElement("div");
    checkmark.setAttribute("data-id", "checkmark");

    // if (Object.keys(nodeData).length == 0) nodeData = DiagramCreateUtil.checkDefaultData(this.diagramParent, nodeData, "checklist", this.appStaticURL);
    // nodeData.value = nodeData.value.toString();
    let ischecked = nodeData && nodeData.value && nodeData.value == "true" ? true : false;
    // let ischecked = this.objData && this.objData.secondarytext && this.objData.secondarytext.items[this.index].content.value

    checkmark.setAttribute("data-ischecked", ischecked);
    contentParentNode.setAttribute("data-ischecked", ischecked);
    checkmark.className = "checkmark";
    contentParentNode.appendChild(checkmark);
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, contentParentNode);
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, checkmark);

    let checkmarksvg = DiagramNodeUtils.createSVGElement("svg");
    checkmarksvg.innerHTML = '<svg id="tick-main" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48"><polygon points="20.3 31.8 14.2 25.8 16.3 23.7 20.3 27.6 31.7 16.2 33.8 18.3 20.3 31.8" stroke="none" /></svg>';
    checkmarksvg.setAttribute("class", "checkmarksvg");
    checkmarksvg.setAttribute("data-id", "checkmarksvg");
    checkmark.appendChild(checkmarksvg);

    if (this.diagramProps.checkBG) {
        let objAssets = { id: this.diagramProps.checkBG.id, value: this.appStaticURL + this.diagramProps.checkBG.value, type: "icon" };
        let checkmarksvguse = DiagramNodeUtils.createSVGDataNode("clsUseNodeCheck", objAssets.id, objAssets.value, this.index, "checkmarksvg");
        checkmarksvguse.setAttribute("data-nodetype", "checklistNode");
        checkmarksvguse.setAttribute("data-id", "checkmarksvg");
        checkmark.removeChild(checkmarksvg);
        checkmark.appendChild(checkmarksvguse);
        // checkmarksvg.outerHTML = checkmarksvguse.outerHTML;
        checkmarksvguse.style.display = ischecked ? "flex" : "none";
        DiagramCreateUtil.updateManifest(objAssets, this.manifestUpdater, this.appStaticURL);
        DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body);

        // .then((svgData) => {
        //     checkmarksvg.innerHTML = svgData.data;
        //     checkmarksvg.style.display = ischecked ? "flex" : "none";
        // })
        // .catch((error) => {
        //     console.log("SVG asset load fail - " + error);
        // });
    }

    if (this.diagramProps.uncheckBG) {
        let objAssets = { id: this.diagramProps.uncheckBG.id, value: this.appStaticURL + this.diagramProps.uncheckBG.value, type: "icon" };
        let uncheckmarksvg = DiagramNodeUtils.createSVGDataNode("clsUseNodeUncheck", objAssets.id, objAssets.value, this.index, "uncheckmarksvg");
        uncheckmarksvg.setAttribute("data-id", "uncheckmarksvg");
        uncheckmarksvg.setAttribute("data-nodetype", "checklistNode");
        uncheckmarksvg.style.display = ischecked ? "none" : "flex";
        checkmark.appendChild(uncheckmarksvg);
        DiagramCreateUtil.updateManifest(objAssets, this.manifestUpdater, this.appStaticURL);
        DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body);
        // .then((svgData) => {
        //     uncheckmarksvg.innerHTML = svgData.data;
        //     uncheckmarksvg.style.display = ischecked ? "none" : "flex";
        // })
        // .catch((error) => {
        //     console.log("SVG asset load fail - " + error);
        // });
    }

    bgDiv.appendChild(contentParentNode);
    return contentParentNode;
};

PlainDiagramNodeBase.prototype.createPriorityNode = function (bgDiv, nodeData) {
    let priorityNodeHolder = document.createElement("div");
    priorityNodeHolder.className = "priorityNodeHolder";
    priorityNodeHolder.setAttribute("id", "priorityNodeHolder" + this.index);
    priorityNodeHolder.setAttribute("name", "priorityNodeHolder");
    priorityNodeHolder.setAttribute("data-index", this.index);
    priorityNodeHolder.setAttribute("data-type", nodeData.type);
    priorityNodeHolder.setAttribute("data-contenttype", nodeData.contenttype);
    priorityNodeHolder.setAttribute("data-priority", nodeData.value || "0");

    let { text, color } = DiagramUtils.getPriorityTextArray(nodeData.contenttype)[nodeData.value];
    priorityNodeHolder.style.setProperty("--prioritycolor", color);

    let indicator = document.createElement("div");
    indicator.className = "indicator";
    priorityNodeHolder.appendChild(indicator);

    let textNode = document.createElement("div");
    textNode.className = "text";
    textNode.innerText = text;
    priorityNodeHolder.appendChild(textNode);

    bgDiv.appendChild(priorityNodeHolder);
};

PlainDiagramNodeBase.prototype.priorityClickEvent = function (event) {
    let target = event.target;
};

PlainDiagramNodeBase.prototype.changePriority = function (target) {
    let arrTypeData = DiagramUtils.getPriorityTextArray(target.dataset.contenttype);
    let index = Number(target.dataset.priority);
    index = index < arrTypeData.length - 1 ? index + 1 : 0;
    target.dataset.priority = index;
    let { text, color } = DiagramUtils.getPriorityTextArray(target.dataset.contenttype)[index];
    target.style.setProperty("--prioritycolor", color);
    target.lastElementChild.innerText = text;
};

// Event functions

PlainDiagramNodeBase.prototype.microChartClickEvent = function (event) {
    let nodeItem = this.nodeGroup.querySelector('[data-id="contentmicrochartparent"]');
    if (nodeItem) {
        event.target.setAttribute("data-oldtext", nodeItem.style.getPropertyValue("--percentageData"));
    }

    let percent = (event.offsetX / event.target.parentElement.parentElement.offsetWidth) * 100;
    DiagramCreateUtil.parseRatingValue(this.nodeGroup, parseInt(percent));
    this.eventManager.dispatch("focusout", event.target);
};

PlainDiagramNodeBase.prototype.microChartFoucsIn = function (event) {
    event.target.setAttribute("data-oldtext", event.target.innerHTML);
    event.target.setAttribute("data-oldinnertext", event.target.innerText);
};

PlainDiagramNodeBase.prototype.microChartFoucsOut = function (event) {
    let nodeItem = this.diagramParent.querySelector("[id='microChartHolder" + event.currentTarget.dataset.index + "']");
    let oldText = event.target.getAttribute("data-oldtext");
    if (nodeItem && oldText != event.target.innerHTML) {
        DiagramCreateUtil.parseMicroChartValue(event.target.innerText, event.target, nodeItem, this.globalMoodData);
        this.eventManager.dispatch("focusout", event.target);
    }
};

PlainDiagramNodeBase.prototype.microChartKeyDown = function (event) {
    if (event.keyCode == 13) {
        event.preventDefault();
        this.microChartFoucsOut(event);
    }
};

PlainDiagramNodeBase.prototype.onFocusOut = function (event) {
    // this.updateOnFocusOut?.(event.target);
    // let isDateLabel = this.diagramParent?.dataset?.nodename?.includes("timeline") && event.target.dataset.type == "numberNode";
    // if (isDateLabel && this.diagramParent?.dataset?.dateformat) this.updateDateFormat({ value: this.diagramParent.dataset.dateformat });
};

PlainDiagramNodeBase.prototype.mutationCallBack = function (mutations) {
    // console.log("mutationCallBack");
    for (let mutation of mutations) {
        if (mutation.type === "childList") {
            if (mutation.target.getAttribute("name") == "primaryText") {
                if (mutation.addedNodes.length > 0) {
                    let addedNode = mutation.addedNodes[0];
                    if (addedNode.nodeName == "DIV" && addedNode.parentElement) {
                        this.observer.disconnect();
                        let insertParent = addedNode.parentElement;
                        // if (addedNode.textContent == "\n") insertParent.insertBefore(document.createElement("br"), addedNode);
                        // insertParent.insertBefore(document.createElement("br"), addedNode);
                        // insertParent.replaceChild(document.createTextNode(addedNode.textContent), addedNode);
                        this.observer.mytargets.forEach((item) => {
                            this.observer.observe(item, { childList: true });
                        });
                    }
                }
                // this.onTextChange({ target: mutation.target });
            } else if (mutation.target.getAttribute("name") == "secondaryText") {
                if (mutation.target.childElementCount == 0 && mutation.removedNodes.length > 0) {
                    let removeChild = mutation.removedNodes[0];
                    removeChild.innerText = "";
                    if (removeChild.nodeName == "LI") {
                        this.observer.disconnect();
                        mutation.target.appendChild(removeChild);
                        this.observer.mytargets.forEach((item) => {
                            this.observer.observe(item, { childList: true });
                        });
                    }
                }
                // this.onTextChange({ target: mutation.target });
            }
        }
    }
};

// Other functions and utilities

PlainDiagramNodeBase.prototype.preLoadValues = function () {
    // Load quote icon from mood (generalized).
    if (this.diagramProps.name && this.diagramProps.name.includes("qt")) {
        this.quoteShape = { id: this.moodName + "quote.svg", value: "moods/" + this.moodName + "/" + this.moodName + "quote.svg" };
    }
};

Element.prototype.insertChildAtIndex = function (child, index) {
    if (!index) index = 0;
    if (index >= this.children.length) {
        this.appendChild(child);
    } else {
        this.insertBefore(child, this.children[index]);
    }
};

PlainDiagramNodeBase.prototype.isCustomType = function (secondaryListType) {
    return secondaryListType == "check" || secondaryListType == "icon" || secondaryListType == "image" || secondaryListType == "logo" || secondaryListType == "number";
};

PlainDiagramNodeBase.prototype.removeAllSubContent = function (li) {
    let arrSecSubContentNode = Array.from(li.querySelectorAll("[name='secSubContentNode']"));
    arrSecSubContentNode.forEach((element) => {
        element?.remove();
    });
};

PlainDiagramNodeBase.prototype.checkPrimaryHolder = function (nodeObj, holdertype) {
    this.isHolderTypePresent = this.isHolderTypePresent == true || holdertype == "primary" ? true : nodeObj.holdertype == "primary";
    // this.isHolderTypePresent = true;
};

PlainDiagramNodeBase.prototype.changeSecondaryType = function (type, index) {
    this.objData.secondarytext.sublist = type;
    // this.properties.secondarytype = type;
    let nodeGroup = this.diagramParent.querySelector("[id='nodeGroup" + index + "']");
    let secondaryNodeList = nodeGroup.querySelectorAll("[name='secondaryTextItem']");
    let secondaryTextNode = nodeGroup.querySelector("[data-id='secondaryText']");
    if (secondaryTextNode && secondaryTextNode.children.length > 0) {
        this.objData.secondarytext.sublist = type;
        nodeGroup.setAttribute("data-sublist", type);
        nodeGroup.style.setProperty("--secondarytexttype", this.isCustomType(type) ? "none" : type);
        nodeGroup.style.setProperty("--secondarytextpadding", type == "none" ? "0px" : type == "decimal" ? "36px" : "26px");
        if (secondaryNodeList) {
            for (var i = 0; i < secondaryNodeList.length; i++) {
                let secondaryNode = secondaryNodeList[i];
                if (type == "none") {
                    secondaryNode.classList.remove("secondaryTextItem");
                    secondaryNode.classList.add("secondaryTextItemNormal");
                } else {
                    secondaryNode.classList.add("secondaryTextItem");
                    secondaryNode.classList.remove("secondaryTextItemNormal");
                }
            }
        }
    }
};

// Get/Data functions

PlainDiagramNodeBase.prototype.getJSONData = function () {
    let nodeData = {};
    if (this.multiTextBox) {
        this.multiTextBox.updateJSONData();
        nodeData.multitextdata = this.multiTextBox.multitextdata;
        nodeData.quilldelta = this.multiTextBox.quilldelta;
    } else {
        nodeData.primarytext = this.getPrimaryTextData();
        nodeData.secondarytext = this.getListData();
    }
    nodeData.label = this.getLabelData();
    nodeData.subtext = this.getSubTextData();
    nodeData.button = this.getButtonData();
    nodeData.content = this.getContentData("primary");
    nodeData.seccontent = this.getSecContent();
    nodeData.tertiarycontent = this.getTertiaryContent();
    nodeData.nodeproperties = this.getNodeProperties();
    nodeData.bgimage = this.getBgImage();
    nodeData.arrowData = "";
    nodeData.rect = this.getNodeRect();
    if (this.authorStyle) {
        nodeData.author = this.authorStyle.getAuthorData(this.parentNode);
        if (nodeData.author) nodeData.author.description = nodeData.secondarytext;
    }
    if (this.numberToggleStyle) {
        nodeData.number = this.numberToggleStyle.getNumberToggleData(this.parentNode);
    }

    nodeData.customconnector = this.getConnectorData();
    nodeData.customconnectortext = this.getConnectorTextData();

    // Other Properties.
    if (this.parentNode) {
        nodeData.position = { x: this.parentNode.style.left || "0", y: this.parentNode.style.top || "0" };
        nodeData.highlightdata = this.getHighlightData();
        nodeData.link = this.parentNode.dataset.navigateToSlideOnClick || this.nodeGroup.dataset.navigateToSlideOnClick;
        let extraLinkDiv = this.parentNode.querySelector("[data-linkid]");
        if (extraLinkDiv) nodeData.extralink = { value: extraLinkDiv.parentElement.dataset.navigateToSlideOnClick, id: extraLinkDiv.getAttribute("id") };
    }

    return nodeData;
};

PlainDiagramNodeBase.prototype.getConnectorData = function () {
    let connectorDiv = this.parentNode && this.parentNode.parentElement && this.parentNode.parentElement.querySelector("[name='connector']");
    if (connectorDiv && connectorDiv.dataset && connectorDiv.dataset.customconnectorstyle) {
        return {
            type: "icon",
            style: connectorDiv.dataset.customconnectorstyle,
        };
    }
    return null;
};

PlainDiagramNodeBase.prototype.getConnectorTextData = function () {
    let connectorDiv = this.parentNode && this.parentNode.parentElement && this.parentNode.parentElement.querySelector("[id*='connectortext']");
    if (connectorDiv) {
        return {
            type: "text",
            value: connectorDiv.textContent,
        };
    }
    return null;
};

PlainDiagramNodeBase.prototype.getNodeRect = function () {
    if (this.parentNode == null || this.parentNode.parentElement == null) return null;
    let x = this.parentNode.parentElement.dataset.x || this.parentNode.parentElement.offsetLeft;
    let y = this.parentNode.parentElement.dataset.y || this.parentNode.parentElement.offsetTop;
    let width = this.parentNode.parentElement.dataset.width || this.parentNode.parentElement.clientWidth;
    let height = this.parentNode.parentElement.dataset.height || this.parentNode.parentElement.clientHeight;
    return { x: x, y: y, width: width, height: height, top: y, left: x };
};

PlainDiagramNodeBase.prototype.getHighlightData = function () {
    let highlightdata = {};
    if (this.parentNode.dataset.highlight != undefined) {
        highlightdata.highlight = this.parentNode.dataset.highlight || "";
        highlightdata.alignment = this.parentNode.dataset.alignment || "";
        highlightdata.highlighttext = this.parentNode.dataset.highlighttext || "";
        highlightdata.highlighttargetbounds = this.parentNode.dataset.highlighttargetbounds || "";
        highlightdata.highlightviewportbounds = this.parentNode.dataset.highlightviewportbounds || "";
        highlightdata.highlightgraphictype = this.parentNode.dataset.highlightgraphictype || "";
        highlightdata.highlightgraphicpath = this.parentNode.dataset.highlightgraphicpath || "";
        highlightdata.highlightstyle = this.parentNode.dataset.highlightstyle || "";
    }
    return highlightdata;
};

PlainDiagramNodeBase.prototype.getSecContent = function (parent = null) {
    let arrSecContent = [];
    // let arrSecContentNodes = this.nodeGroup.querySelectorAll("div[data-holder-type='secondary']:not([data-allowchange='false'])");
    let parentNode = parent ? parent : this.nodeGroup;
    let arrSecContentNodes = parentNode.querySelectorAll("div[data-holder-type='secondary']");
    arrSecContentNodes.forEach((nodeItem) => {
        arrSecContent.push(this.getContentData("secondary", nodeItem.id));
    });
    return arrSecContent;
};

PlainDiagramNodeBase.prototype.getTertiaryContent = function (parent = null) {
    let arrSecContent = [];
    let parentNode = parent ? parent : this.nodeGroup;
    let arrSecContentNodes = parentNode.querySelectorAll("div[data-holder-type='tertiary']");
    arrSecContentNodes.forEach((nodeItem) => {
        arrSecContent.push(this.getContentData("tertiary", nodeItem.id));
    });
    return arrSecContent;
};

PlainDiagramNodeBase.prototype.getPrimaryTextData = function () {
    if (!this.nodeGroup) return;
    let primaryText = this.nodeGroup.querySelector("div[data-id='primaryText']");
    if (primaryText) {
        return {
            type: "text",
            value: primaryText.innerHTML && primaryText.innerHTML != "" ? TextHighLightUtils.highlightToString(primaryText.innerHTML) : "",
            ...DiagramCreateUtil.getTextProps(primaryText),
        };
    } else {
        return "";
    }
};

PlainDiagramNodeBase.prototype.getLabelData = function () {
    if (!this.nodeGroup) return;
    let labelText = this.nodeGroup.querySelector("div[name='textLabel']");
    if (labelText) {
        return { type: "text", value: labelText.innerHTML && labelText.innerHTML != "" ? TextHighLightUtils.highlightToString(labelText.innerHTML) : "", ...DiagramCreateUtil.getTextProps(labelText) };
    } else {
        return "";
    }
};

PlainDiagramNodeBase.prototype.getSubTextData = function () {
    if (!this.nodeGroup) return;
    let labelText = this.nodeGroup.querySelector("div[name='subText']");
    if (labelText) {
        return { type: "text", value: labelText.innerHTML && labelText.innerHTML != "" ? TextHighLightUtils.highlightToString(labelText.innerHTML) : "", ...DiagramCreateUtil.getTextProps(labelText) };
    } else {
        return "";
    }
};

PlainDiagramNodeBase.prototype.getButtonData = function () {
    if (!this.nodeGroup) return;
    let labelText = this.nodeGroup.querySelector("[name='buttonNode']");
    if (labelText) {
        return { type: "text", value: labelText.textContent };
    } else {
        return "";
    }
};

PlainDiagramNodeBase.prototype.getSecondayText = function () {
    if (!this.nodeGroup) return;
    let secondayText = this.nodeGroup.querySelector("div[data-id='secondaryText']");
    if (secondayText) {
        return secondayText.textContent;
    } else {
        return "";
    }
};

PlainDiagramNodeBase.prototype.getListData = function () {
    if (!this.nodeGroup) return;
    let listItems = this.nodeGroup.querySelectorAll("[name='secondaryTextItem']");
    let secText = this.nodeGroup.querySelector("[data-id='secondaryText']");
    let listtype = this.nodeGroup.getAttribute("data-sublist") || "none";
    let arrItems = [];
    if (listItems.length > 0) {
        listItems.forEach((listItem, index) => {
            arrItems.push({
                type: "text",
                value: listItem.innerHTML && listItem.innerHTML != "" ? TextHighLightUtils.highlightToString(listItem.innerHTML) : "",
                index: index,
                content: this.getListContent(listItem),
            });
        });
    } else if (secText) {
        arrItems.push({ type: "text", value: secText.innerHTML && secText.innerHTML != "" ? TextHighLightUtils.highlightToString(secText.innerHTML) : "", index: 0 });
    }

    return arrItems.length > 0 ? { sublist: listtype, items: arrItems, ...DiagramCreateUtil.getTextProps(secText.parentElement) } : null;
};

PlainDiagramNodeBase.prototype.getListContent = function (li) {
    let iconListHolder = li.querySelector("[name='iconListHolder']");
    let imageListHolder = li.querySelector("[name='imageListHolder']");
    let valueListHolder = li.querySelector("[name='valueListHolder']");
    let checkListHolder = li.querySelector("[data-id='checklistNode']");
    if (iconListHolder) {
        let iconNode = iconListHolder.querySelector("[data-content-type='icon']");
        return DiagramNodeUtils.getContentDataFromNode(iconNode, "icon");
    } else if (checkListHolder) {
        return DiagramNodeUtils.getContentDataFromNode(checkListHolder, "checklist");
    } else if (imageListHolder) {
        let imageNode = imageListHolder.querySelector("[data-id='imageNode']");
        let logoNode = imageListHolder.querySelector("[data-id='logoNode']");
        let isLogo = logoNode;
        return DiagramNodeUtils.getContentDataFromNode(isLogo ? logoNode : imageNode, isLogo ? "logo" : "image");
    } else if (valueListHolder) {
        let valueNode = valueListHolder.querySelector("[data-id='numberNode']");
        return DiagramNodeUtils.getContentDataFromNode(valueNode, "number");
    }
    return null;
};

PlainDiagramNodeBase.prototype.getBgImage = function () {
    let nodeBG = this.parentNode && this.parentNode.parentElement && this.parentNode.parentElement.querySelector("[name='nodeBackgound']");
    if (nodeBG && nodeBG.querySelector("[data-id='imageNode']")) return DiagramNodeUtils.getContentDataFromNode(nodeBG.querySelector("[data-id='imageNode']"), "image");
    else return null;
};

PlainDiagramNodeBase.prototype.getContentData = function (holdertype, secContentParent = null) {
    if (!this.nodeGroup) return;
    // let contentNode = this.nodeGroup.querySelector("div[data-id='diagramContentNode']");
    let contentNode = null;
    if (this.nodeGroup.querySelector("div[data-holder-type='" + holdertype + "']")) contentNode = this.nodeGroup.querySelector("div[data-holder-type='" + holdertype + "']");
    if (secContentParent) contentNode = this.nodeGroup.querySelector("div[id='" + secContentParent + "']");
    // if (!contentNode && secContentParent) contentNode = this.nodeGroup.querySelector("div[id='" + secContentParent + "']");

    // if (!contentNode && this.diagramParent.dataset.classname.includes("SimpleNonLinearDiagram")) {
    if (this.diagramParent.dataset.classname.includes("SimpleNonLinearDiagram")) {
        if (this.nodeGroup?.dataset?.id == "centerHolderParent" && this.nodeGroup.dataset.contentType) {
            // let contentType = this.nodeGroup.dataset.contentType;
            contentNode = this.nodeGroup;
        } else contentNode = this.diagramParent.querySelector("[data-contentType][data-index='" + this.index + "']") || contentNode;
    } else if (!contentNode) contentNode = this.nodeGroup.querySelector("[data-contentType][data-index='" + this.index + "']");
    if (contentNode && contentNode.dataset) {
        let contentType = contentNode.dataset.contentType || contentNode.dataset.contenttype || contentNode.dataset.type;
        let node = contentNode.querySelector("[data-id='" + contentType + "Node']");
        let svgNode = this.nodeGroup.querySelector("[id='svgItem" + (this.index + 1) + "']");
        if (svgNode) node = svgNode;
        if (!node) node = contentNode.querySelector("[data-content-type]");
        if (!node) node = this.nodeGroup.querySelector("[data-content-type]");
        if (!node) return { type: contentType, contenttype: contentType };
        return DiagramNodeUtils.getContentDataFromNode(node, contentType, this.nodeGroup);
    } else {
        return { type: "text", value: "" };
    }
};

PlainDiagramNodeBase.prototype.getNodeProperties = function () {
    let nodeproperties = { highlight: false, emphasize: false, sublist: "none", ischecked: false };
    let currentParent = this.nodeGroup;
    Constants.Value.arrNodeProps.map(function (item) {
        let value = currentParent.getAttribute("data-" + item);
        if (value) nodeproperties[item] = value == "true" ? true : value == "false" ? false : value;
    });
    return nodeproperties;
};

PlainDiagramNodeBase.prototype.getNodeParent = function () {
    return this.parentNode;
};

PlainDiagramNodeBase.prototype.getHolderTypeByName = function (nodeObjName, name) {
    switch (nodeObjName) {
        case "iconHolder":
            return name.includes("-ic-");
        case "imageHolder":
        case "deviceImageHolder":
            return name.includes("-img-") || name.includes("-team-") || name.includes("-imagegrid-") || name.includes("-appscreen-tx");
        case "imageSecHolder":
            return name.includes("-lg-");
        case "valueTitleHolder":
            return name.includes("-val-");
        case "microChartHolder":
            return name.includes("-mc-");
        case "textTitleHolder":
            return name.includes("-qt-");
        default:
            break;
    }
};

PlainDiagramNodeBase.prototype.getLogoListDataFromSecondary = function (secnodeData) {
    let logoListData = [];
    if (secnodeData && secnodeData.length > 0)
        secnodeData.forEach((element) => {
            // if (element.type && element.type == "logolist") {
            //     logoListData = element.list;
            // }
            if (element.type && element.contenttype == "logo") {
                if (!element.hasOwnProperty("logocontrast")) {
                    element.logocontrast = false;
                }
                logoListData.push(element);
            }
        });

    return logoListData;
};

PlainDiagramNodeBase.prototype.getContentDataBasedOnHolder = function (name, holdertype, objData, islogo, nodeParent) {
    if (!objData) return null;
    // if (name == "iconListHolder") {
    //     return objData.content;
    // }
    if (holdertype == "primary") {
        if (objData.content && objData.content.contenttype && objData.content.contenttype != "diagramContentNode") this.properties.contenttype = objData.content.contenttype;
        return objData.content;
    } else if (holdertype == "secondary") {
        if (objData.seccontent && objData.seccontent.length > 0) {
            let content = {};
            objData.seccontent.forEach((element) => {
                if (name.toLowerCase().includes(element.contenttype) || (name.toLowerCase().includes("value") && element.contenttype == "number") || (islogo && element.contenttype == "logo")) {
                    content = element;
                }
            });
            return content;
        } else return {};
    } else if (holdertype == "tertiary") {
        if (objData.tertiarycontent && objData.tertiarycontent.length > 0) {
            let content = {};
            objData.tertiarycontent.forEach((element) => {
                if (name.toLowerCase().includes(element.contenttype) || (name.toLowerCase().includes("value") && element.contenttype == "number") || (islogo && element.contenttype == "logo")) {
                    content = element;
                }
            });
            return content;
        } else return {};
    } else return objData.content;
};

PlainDiagramNodeBase.prototype.getContentDataBasedOnSelectedHolder = function (name, selectedContentType, objData, islogo) {
    if ((objData.content && selectedContentType == objData.content.contenttype) || (objData.content && name.includes("image") && objData.content.contenttype && (objData.content.contenttype.includes("image") || objData.content.contenttype.includes("logo")))) {
        if (objData.content && objData.content.contenttype && objData.content.contenttype != "diagramContentNode") this.properties.contenttype = objData.content.contenttype;
        return objData.content;
    } else {
        if (objData.seccontent && objData.seccontent.length > 0) {
            let content = {};
            objData.seccontent.forEach((element) => {
                if (name.toLowerCase().includes(element.contenttype) || (name.toLowerCase().includes("value") && element.contenttype == "number") || (islogo && element.contenttype == "logo")) {
                    content = element;
                }
            });
            return content;
        } else return {};
    }
};

// Set / Update functions

PlainDiagramNodeBase.prototype.setHighlightData = function () {
    if (this.objData.highlightdata != undefined) {
        this.parentNode.setAttribute("data-highlight", this.objData.highlightdata.highlight || "");
        this.parentNode.setAttribute("data-alignment", this.objData.highlightdata.alignment || "");
        this.parentNode.setAttribute("data-highlighttext", this.objData.highlightdata.highlighttext || "");
        this.parentNode.setAttribute("data-highlighttargetbounds", this.objData.highlightdata.highlighttargetbounds || "");
        this.parentNode.setAttribute("data-highlightviewportbounds", this.objData.highlightdata.highlightviewportbounds || "");
        this.parentNode.setAttribute("data-highlightgraphictype", this.objData.highlightdata.highlightgraphictype || "");
        this.parentNode.setAttribute("data-highlightgraphicpath", this.objData.highlightdata.highlightgraphicpath || "");
        this.parentNode.setAttribute("data-highlightstyle", this.objData.highlightdata.highlightstyle || "");
    }
};

PlainDiagramNodeBase.prototype.setLinkData = function () {
    if (this.objData.link) {
        this.parentNode.setAttribute("data-navigate-to-slide-on-click", this.objData.link);
    }
    if (this.objData.extralink) {
        let linknode = this.parentNode.querySelector("[id='" + this.objData.extralink.id + "']");
        if (linknode) {
            linknode.parentElement.setAttribute("data-navigate-to-slide-on-click", this.objData.extralink.value);
        }
    }
};

PlainDiagramNodeBase.prototype.setEmphasizeData = function () {
    if (this.properties.floateroptionsdisable && this.properties.floateroptionsdisable.includes("emphasize")) return;
    if (this.objData && this.objData.nodeproperties && this.objData.nodeproperties.emphasize) {
        this.diagramParent.setAttribute("data-emphasis", this.index);
    }
};

PlainDiagramNodeBase.prototype.setLogoContrastData = function () {
    if (this.properties.floateroptionsdisable && this.properties.floateroptionsdisable.includes("logocontrast")) return;
    if (this.objData && this.objData.nodeproperties && this.objData.nodeproperties.logocontrast != null) {
        let logoNode = this.nodeGroup.querySelector("[data-id='logoNode']");
        DiagramUtils.setLogoContrast(logoNode, this.nodeGroup, this.objData.nodeproperties.logocontrast);
    }
};

PlainDiagramNodeBase.prototype.setInlineSize = function () {
    if (this.properties.floateroptionsdisable && this.properties.floateroptionsdisable.includes("logocontrast")) return;
    if (this.objData && this.objData.nodeproperties && this.objData.nodeproperties.logocontrast != null) {
        let logoNode = this.nodeGroup.querySelector("[data-id='logoNode']");
        DiagramUtils.setLogoContrast(logoNode, this.nodeGroup, this.objData.nodeproperties.logocontrast);
    }
};

PlainDiagramNodeBase.prototype.setCrossoutData = function () {
    if (this.properties.floateroptionsdisable && this.properties.floateroptionsdisable.includes("crossout")) return;
    if (this.objData && this.objData.nodeproperties && this.objData.nodeproperties.crossout) {
        let contentNode = this.parentNode.querySelector("[data-id='diagramContentNode']");
        let isTextNode = false;
        if (!contentNode) {
            contentNode = this.parentNode.querySelector("[data-id='primaryTextNode']");
            isTextNode = true;
        }
        let className = isTextNode ? "clsCrossoutTextStyle" : "clsCrossoutStyle";
        if (contentNode) {
            // contentNode.classList.add("clsCrossoutStyle");
            contentNode.classList.add(className);
            this.createCrossoutDiv(contentNode);
        }
    }
};

PlainDiagramNodeBase.prototype.setHolderType = function (contenttype, holder) {
    let key = holder == "centerNode" ? "data-centerholdertype" : "data-contentholdertype";
    switch (contenttype) {
        case "none":
            this.diagramParent.setAttribute(key, "noneHolder");
            break;
        case "icon":
            this.diagramParent.setAttribute(key, "iconHolder");
            break;
        case "image":
            this.diagramParent.setAttribute(key, "imageHolder");
            break;
        case "logo":
            this.diagramParent.setAttribute(key, "imageSecHolder");
            break;
        case "number":
            this.diagramParent.setAttribute(key, "valueTitleHolder");
            break;
        case "text":
            this.diagramParent.setAttribute(key, "textTitleHolder");
            break;
        case "sequence":
            this.diagramParent.setAttribute(key, "seqTitleHolder");
            break;
        case "checklist":
            this.diagramParent.setAttribute(key, "checkListHolder");
            break;
        case "bulletlist":
            this.diagramParent.setAttribute(key, "bulletHolder");
            break;
        default:
            break;
    }
};

PlainDiagramNodeBase.prototype.setDataAnimationToSecContent = function (holdertype, titleHolder) {
    if (holdertype == "secondary") {
        titleHolder.classList.add("moodanimation");
        titleHolder.setAttribute("data-animation", "secondaryholder");
    } else if (holdertype == "primary") {
        titleHolder.classList.add("moodanimation");
        titleHolder.setAttribute("data-animation", "item");
    }
};

PlainDiagramNodeBase.prototype.updateContentData = function (nodeData, type, parentId = null, enableSave = false) {
    let parent = this.diagramParent.querySelector("[id='" + parentId + "']") || this.nodeGroup;
    let node = null;
    if (parent) node = parent.querySelector("[data-id='" + type + "Node']");
    // if (node == null || (parentId && parentId.includes("centerHolder"))) {
    if (node == null && parentId) {
        if (this.bgDeviceDiv) parent = this.bgDeviceDiv.querySelector("[id='" + parentId + "']");
        if (!parent) return;
        node = parent.querySelector("[data-id='" + type + "Node']");
    }
    if (node == null && parentId && parentId.includes(type + "Node")) node = parent;
    if (node) {
        switch (type) {
            case "image":
            case "bgimage":
            case "logo":
                node.setAttribute("data-src", nodeData.value);
                DiagramResizeUtils.updateDefaultImageData(node, type, (!enableSave && this.imageLoadCallBack) || this.updateCallBack);
                let dataRef = { imageURL: node.src };
                if (node.dataset.csstext) dataRef.cropStyle = node.dataset.csstext;
                if (node.dataset.style) dataRef.cropData = node.dataset.style;
                nodeData.dataRef = dataRef;
                node.removeAttribute("data-csstext");
                node.style.cssText = "";
                // node.parentElement.removeAttribute("data-node-graphic-text");
                if (nodeData.searchText && node.parentElement) {
                    node.parentElement.setAttribute("data-node-graphic-text", nodeData.searchText);
                }
                break;
            case "icon":
                let useNode = node.querySelector("use");
                if (useNode) useNode.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "#" + DiagramNodeUtils.getIconName(nodeData));
                node.setAttribute("iconid", nodeData.id);
                node.setAttribute("iconpath", nodeData.value);
                useNode?.setAttribute("iconid", nodeData.id);
                useNode?.setAttribute("iconpath", nodeData.value);
                if (nodeData.searchText && node.parentElement) {
                    node.parentElement.setAttribute("data-node-graphic-text", nodeData.searchText);
                }
                break;
            case "text":
            case "number":
            case "microchart":
                node.innerText = nodeData.value;
                break;
            default:
                break;
        }
    }
};

PlainDiagramNodeBase.prototype.updateNodeProperties = function (nodeproperties) {
    let currentParent = this.nodeGroup;
    Constants.Value.arrNodeProps.map(function (item) {
        if (nodeproperties[item] && nodeproperties[item] != null && nodeproperties[item] != undefined) {
            currentParent.setAttribute("data-" + item, nodeproperties[item]);
        } else currentParent.removeAttribute("data-" + item);
    });
};

PlainDiagramNodeBase.prototype.updateNodeAttributes = function (index) {
    this.index = index;
    if (!this.parentNode) return;
    this.parentNode.setAttribute("data-index", this.index);
    this.parentNode.setAttribute("id", this.parentNode.getAttribute("name") + this.index);

    if (this.parentNode.parentElement) {
        this.parentNode.parentElement.setAttribute("id", this.parentNode.parentElement.getAttribute("name") + this.index);
        this.parentNode.parentElement.setAttribute("data-index", this.index);
    }

    let allNodes = this.parentNode.querySelectorAll("[data-index]");
    allNodes.forEach((nodeItem) => {
        nodeItem.setAttribute("data-index", this.index);
        // let attrName = nodeItem.getAttribute("name");
        // let attrDataId = nodeItem.getAttribute("data-id");
        let name = nodeItem.getAttribute("name") || nodeItem.getAttribute("data-id");
        let imageGridIndex = nodeItem.getAttribute("data-imagegrid-index");
        if (imageGridIndex != null) {
            nodeItem.setAttribute("id", name + imageGridIndex + "-gridNode" + this.index);
        } else if (name) {
            nodeItem.setAttribute("id", name + this.index);
        }
    });

    let allConnectors = this.parentNode.parentElement.querySelectorAll("[name='connector']");
    allConnectors.forEach((nodeItem) => {
        nodeItem.setAttribute("id", "connector" + this.index);
        nodeItem.setAttribute("data-animation", this.properties.hasconnector ? "connector" : "separator");
    });

    let allConnectorParent = this.parentNode.parentElement.querySelectorAll("[data-id='connectorparent']");
    allConnectorParent.forEach((nodeItem) => {
        nodeItem.setAttribute("id", "connectorparent" + this.index);
    });

    let allSeqText = this.parentNode.querySelectorAll("[name='seqText']");
    allSeqText.forEach((nodeItem) => {
        let content = DiagramUtils.getSeqMoodStyle(this.globalMoodData ? this.globalMoodData.seqnumproperties : null, this.properties, "sequencenumber", this.index + 1, this.diagramParent.dataset.nodecount);
        nodeItem.innerText = content;
    });

    let valueTextObj = DiagramUtils.getObjectFromName(this.arrSupportedNodes, "valueTitleHolder");
    let allValueText = this.parentNode.querySelectorAll("[name='numberNode']");
    allValueText.forEach((nodeItem) => {
        if (valueTextObj && valueTextObj.scale) {
            let scale = valueTextObj.scale.split(",")[0];
            let scaledSize = nodeItem.parentElement.parentElement.offsetWidth * parseFloat(scale);
            nodeItem.style.fontSize = scaledSize - 8 + "px";
            let maxHeight = scaledSize + "px";
            nodeItem.style.maxHeight = maxHeight;
            nodeItem.style.height = maxHeight;
            nodeItem.style.minHeight = maxHeight;
            nodeItem.parentElement.style.maxHeight = maxHeight;
            nodeItem.parentElement.style.height = maxHeight;
            nodeItem.parentElement.style.minHeight = maxHeight;
        }
    });

    let allIconNodes = this.parentNode.querySelectorAll("[data-id='iconNode']");

    allIconNodes.forEach((nodeItem) => {
        let parentElement = nodeItem.parentElement;
        if (!parentElement?.getAttribute("name")?.includes("iconListHolder")) parentElement.setAttribute("id", parentElement.getAttribute("name") + this.index);
    });

    this.updateCheckListNode();

    if (this.contentBG) {
        let isDeviceAsset = this.getContentBGForDeviceAsset();
        if (isDeviceAsset && !this.diagramParent.querySelector("[id='" + this.contentBG.id + "']")) {
            let defsParent = this.diagramParent;
            const bg = { value: this.contentBG.value, id: this.contentBG.id, type: this.contentBG.type ? this.contentBG.type : "icon" };
            DiagramCreateUtil.updateManifest(bg, this.manifestUpdater, this.appStaticURL);
            bg.value = this.appStaticURL + this.contentBG.value;
            DiagramAssetLoader.oneTimeDownload(bg, true, defsParent).then((svgData) => {
                let svgDefs = defsParent.querySelector("[id*='svgDefs']");
                let svgDOM = svgDefs.querySelector("svg[id='" + this.contentBG.id + "']");
                if (this.contentBG.oldid && svgDOM) {
                    svgDOM.setAttribute("oldid", this.contentBG.oldid);
                }
                DiagramNodeUtils.applyNodeStyleClipPath(this.contentBG.id, this.diagramParent, this.index, null, defsParent);
                this.updateImageLogoFrames();
            });
        } else {
            DiagramNodeUtils.applyNodeStyleClipPath(this.contentBG.id, this.diagramParent, index, null, isDeviceAsset ? this.diagramParent : document.body);
            this.updateImageLogoFrames();
        }
    }

    if (this.arrTintArray && this.arrTintArray.length > 0) {
        DiagramUtils.setCustomItemColor(this.parentNode.parentElement, this.arrTintArray, this.index, this.index + 1);
        let nodeNonlinear = this.diagramParent.querySelector("[name='nodeNonlinearMainParent'][data-index='" + this.index + "']");
        if (nodeNonlinear) DiagramUtils.setCustomItemColor(nodeNonlinear, this.arrTintArray, this.index, this.index + 1);
    }
};

PlainDiagramNodeBase.prototype.updateImageLogoFrames = function () {
    if (!this.parentNode) return;
    let allImgNodes = this.parentNode.querySelectorAll("img[data-id='imageNode'],img[data-id='logoNode']");

    allImgNodes.forEach((nodeItem) => {
        if (!this.parentNode.id.includes("centerHolderParent"))
            if (nodeItem.parentElement.id.includes("gridNode")) nodeItem.parentElement.setAttribute("id", nodeItem.parentElement.getAttribute("name") + nodeItem.parentElement.getAttribute("data-imagegrid-index") + "-gridNode" + this.index);
            else nodeItem.parentElement.setAttribute("id", nodeItem.parentElement.getAttribute("name") + this.index);

        let contentType = nodeItem.parentElement.dataset.contentType;
        let scale = nodeItem.parentElement.getAttribute("data-scale") || 1;
        CommonImageUtils.updateImageBounds(nodeItem, { isimagefit: this.properties.isimagefit, islogofit: contentType == "logo", contenttype: contentType }, scale);
    });
};

PlainDiagramNodeBase.prototype.updateCheckListNode = function () {
    let toggleListNode = this.parentNode.querySelector("[name='numberToggleStyle']");
    if (toggleListNode && this.numberToggleStyle) {
        this.numberToggleStyle.updateNumberToggleNode(this.parentNode);
        let numberToggleName = toggleListNode.querySelector("[name='numberToggleName']");
        if (numberToggleName) this.numberToggleStyle.updateNumberToggleNodeForSign(numberToggleName, this.parentNode);
        return;
    }
    let checklistNode = this.parentNode.querySelector("[data-id='checklistNode']");
    if (checklistNode) {
        if (checklistNode.parentElement.parentElement.id.includes("secondaryText")) return;
        let checkedClass = checklistNode.dataset.checkedclass;
        let ischecked = checklistNode.dataset.ischecked && checklistNode.dataset.ischecked == "true";
        let index = checklistNode.dataset.index;
        let nodeParent = this.diagramParent.querySelector("[id='nodeMainParent" + index + "']");
        let checkmarksvg = nodeParent.querySelector("[data-id='checkmarksvg']");
        let uncheckmarksvg = nodeParent.querySelector("[data-id='uncheckmarksvg']");
        let primarytext = this.diagramParent.querySelector("[data-id='primaryText'][data-index='" + index + "']");

        if (ischecked) {
            nodeParent.classList.add(checkedClass);
            primarytext.classList.add("clsAccentColor");
        } else {
            nodeParent.classList.remove(checkedClass);
            primarytext.classList.remove("clsAccentColor");
        }

        if (this.diagramProps.checkBG && checkmarksvg) {
            checkmarksvg.style.display = ischecked ? "flex" : "none";
        }

        if (this.diagramProps.uncheckBG && uncheckmarksvg) {
            uncheckmarksvg.style.display = ischecked ? "none" : "flex";
        }
    }
};

PlainDiagramNodeBase.prototype.updateSecCheckListNode = function (checklistNode) {
    if (!checklistNode) {
        checklistNode = this.parentNode.querySelector("[data-id='checklistNode']");
    }
    if (checklistNode) {
        let checkedClass = checklistNode.dataset.checkedclass;
        let checkmarksvg = checklistNode.querySelector("[data-id='checkmarksvg']");
        let uncheckmarksvg = checklistNode.querySelector("[data-id='uncheckmarksvg']");
        let ischecked = checklistNode.dataset.ischecked && checklistNode.dataset.ischecked == "true";

        if (ischecked) {
            checklistNode.parentElement.classList.add(checkedClass);
        } else {
            checklistNode.parentElement.classList.remove(checkedClass);
        }

        if (this.diagramProps.checkBG && checkmarksvg) {
            checkmarksvg.style.display = ischecked ? "flex" : "none";
        }

        if (this.diagramProps.uncheckBG && uncheckmarksvg) {
            uncheckmarksvg.style.display = ischecked ? "none" : "flex";
        }
        // if (checkmarksvg) {
        //     checkmarksvg.style.display = ischecked ? "flex" : "none";
        // }

        // if (uncheckmarksvg) {
        //     uncheckmarksvg.style.display = ischecked ? "none" : "flex";
        // }
    }
};

PlainDiagramNodeBase.prototype.updateStyles = function () {
    this.parentNode.style.setProperty("--contentShadow", "none");
    this.parentNode.style.setProperty("--secContentShadow", "none");
    this.parentNode.style.setProperty("--groupShadow", "none");
    this.parentNode.style.setProperty("--nodeShadow", "none");
    this.parentNode.style.setProperty("--secImageShadow", "none");

    this.parentNode.style.setProperty("--contentCustomBG", "none");
    this.parentNode.style.setProperty("--nodeCustomBG", "none");
    this.parentNode.style.setProperty("--groupCustomBG", "none");
    this.parentNode.style.setProperty("--secContentCustomBG", "none");

    let index = this.index?.split ? Number(this.index.split(",")[0]) : this.index;
    DiagramUtils.setCustomItemColor(this.parentNode.parentElement, this.arrTintArray, index, index + 1, this.isTakeAway);

    let nodeGradient = this.diagramProps.nodeGradient ? this.diagramProps.nodeGradient.split(",") : [];
    if (nodeGradient.length >= 4) {
        let startColorData = nodeGradient[0].split(" ");
        let order = nodeGradient[4] && nodeGradient[4].includes("split");
        let startOpacity = startColorData[2].replace(/\s/g, "");
        let startOffset = startColorData[1].replace(/\s/g, "");
        let arrStartIndex = startColorData[0].split("-");
        let index = arrStartIndex.length > 1 ? arrStartIndex[1] - 1 : this.index;
        let startColorName = arrStartIndex.length > 1 ? arrStartIndex[0] : startColorData[0];
        let startColor = DiagramUtils.createRBGColor(startColorName, index, startOpacity);

        let endColorData = nodeGradient[1].split(" ");
        let endOpacity = endColorData[2].replace(/\s/g, "");
        let endOffset = endColorData[1].replace(/\s/g, "");
        let arrEndIndex = endColorData[0].split("-");
        let endIndex = arrEndIndex.length > 1 ? arrEndIndex[1] - 1 : this.index;
        if (order) {
            let arrdifference = nodeGradient[4] && nodeGradient[4].split(" ");
            let difference = arrdifference.length > 1 ? parseInt(arrdifference[1]) : 1;
            endIndex = this.index + difference;
            endIndex = endIndex % 6;
        }
        let endColorName = arrEndIndex.length > 1 ? arrEndIndex[0] : endColorData[0];
        let endColor = DiagramUtils.createRBGColor(endColorName, endIndex, endOpacity);

        let nodName = "--" + nodeGradient[3].replace(/\s/g, "") + "Gradient";
        this.parentNode.style.setProperty(nodName, "linear-gradient(" + nodeGradient[2] + ", " + endColor + " " + endOffset + ", " + startColor + " " + startOffset + ")");
    }

    let nodeShadow = this.diagramProps.nodeShadow ? this.diagramProps.nodeShadow.split(",") : [];
    if (nodeShadow.length == 4) {
        let opacity = nodeShadow[2].replace(/\s/g, "");
        let color = DiagramUtils.createRBGColor(nodeShadow[1], this.index, opacity);
        const sNodeData = nodeShadow[3].replace(/\s/g, "");
        let arrSNodeData = [sNodeData];
        const hasMultiShadow = sNodeData.includes("[") && sNodeData.includes("]");
        if (hasMultiShadow) {
            arrSNodeData = sNodeData.replace("[", "").replace("]", "").split(":");
        }
        for (let i = 0; i < arrSNodeData.length; i++) {
            let nodName = "--" + arrSNodeData[i].replace(/\s/g, "") + "Shadow";
            this.parentNode.style.setProperty(nodName, nodeShadow[0] + " " + color);
        }
    }

    let nodeBRadius = this.diagramProps.nodeBorderRadius ? this.diagramProps.nodeBorderRadius.split(",") : [];
    if (nodeBRadius.length == 2) {
        const rNodeData = nodeBRadius[1].replace(/\s/g, "");
        let arrRNodeData = [rNodeData];
        const hasMultiShadow = rNodeData.includes("[") && rNodeData.includes("]");
        if (hasMultiShadow) {
            arrRNodeData = rNodeData.replace("[", "").replace("]", "").split(":");
        }
        for (let i = 0; i < arrRNodeData.length; i++) {
            let nodName = "--" + arrRNodeData[i].replace(/\s/g, "") + "BRadius";
            this.parentNode.style.setProperty(nodName, nodeBRadius[0]);
        }
    }
};

PlainDiagramNodeBase.prototype.updateTextNodes = function () {
    try {
        this.updateOnFocusOut();
    } catch (error) {
        console.log(error);
    }
};

PlainDiagramNodeBase.prototype.updateDateFormat = function (obj) {
    let textNode = this.parentNode.querySelector("[data-id='numberNode']");
    if (!textNode) return;

    let format = obj.value || "DD/MM/YYYY";
    let currentDate = new Date().toLocaleDateString("en-IN", { year: "numeric", month: "2-digit", day: "2-digit" });
    let dateContent = textNode.textContent.isEmpty() ? currentDate : textNode.textContent;
    textNode.textContent = DiagramUtils.formatStrDate(dateContent, format.toLowerCase());
    this.diagramParent.setAttribute("data-dateformat", format);
};

//Text change
PlainDiagramNodeBase.prototype.onTextChange = function (obj) {};

/**
 * Author:    Saravanan G
 * Created:   13.12.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function PlainDiagramNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    PlainDiagramNodeBase.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
    this.onTextChange = this.onTextChange.bind(this);
    this.nodeTopMarginCalc = true;
}

PlainDiagramNode.prototype = Object.create(PlainDiagramNodeBase.prototype);
PlainDiagramNode.prototype.constructor = PlainDiagramNode;

PlainDiagramNode.prototype.updateOnFocusOut = function (index) {
    // console.log("inside updateOnFocusOut " + this.index + " - " + index + " - " + this.mainParent.id);
    this.mainParent.style.setProperty("--nodeTopMargin", "unset");
    this.mainParent.style.setProperty("--titleHolderMH", "unset");
    this.resetMaxHeight();
    if (!this.mainParent || !this.mainParent.parentElement) return;
    // this.checkCenteHolderText();
    let allNodes = this.mainParent.parentElement.querySelectorAll("[name='nodeparent']");
    this.aliginNodeContent(allNodes, index);
    this.setMinFontSize();
    let parentHeight = this.parentNode.offsetHeight;
    let objStyleData = window.getComputedStyle(this.parentNode);
    if (parseFloat(objStyleData.paddingTop)) parentHeight = parentHeight - parseFloat(objStyleData.paddingTop);
    if (parseFloat(objStyleData.paddingBottom)) parentHeight = parentHeight - parseFloat(objStyleData.paddingBottom);
    this.aliginNodeMinSize(allNodes, parentHeight);
    if (this.boolFixedGroup) this.alignToGroup(allNodes);
    if (this.boolFixedSecContent) this.alignToSecContent(allNodes);
    if (this.boolFixedSecSubContent) this.alignToSecSubContent(allNodes);
    if (this.boolFixedContent) this.alignToContent(allNodes);
    // this.setMaxHeightForLogoList();
    //console.log("updateOnFocusOut aligns - " + (new Date().getTime() - dateNow));

    // if (targetNode) targetNode.scrollTop = 0;
    //if (isHeightAuto) this.mainParent.parentElement.style.height = "auto";
};
PlainDiagramNode.prototype.checkCenteHolderText = function () {
    let isCenterHolder = this.parentNode?.dataset?.id == "centerHolderParent";
    if (isCenterHolder) {
        for (let i2 = 0; i2 < this.arrTextNodes.length; i2++) {
            const nodeName = this.arrTextNodes[i2];
            let nodeToResize = this.parentNode?.querySelector("[name='" + nodeName + "']");
            if (nodeToResize && nodeToResize.clientHeight > 0) {
                this.onTextChangeUpdate(nodeToResize, this.parentNode, this.nodeGroup, true);
            }
        }
        return;
    }
};

PlainDiagramNode.prototype.setMaxHeightForLogoList = function () {
    // let arrLogoListParent = this.mainParent.querySelectorAll("[name='imageGridNode']");
    let logoListParent = this.parentNode.querySelector("[name='imageGridNode']");
    // arrLogoListParent.forEach((logoListParent) => {
    if (logoListParent) {
        logoListParent.style.display = "none";
        this.nodeGroup.style.minHeight = "unset";
        let maxHeight = this.parentNode?.offsetHeight - this.nodeGroup?.offsetHeight;
        logoListParent.style.removeProperty("display");
        this.nodeGroup.style.removeProperty("min-height");
        if (maxHeight > 0 && maxHeight != null && maxHeight != undefined) logoListParent.style.setProperty("max-height", maxHeight + "px");
        this.gridInstance?.fitLogoGridImages?.();
    }
    // });
};

// let isAutoResize = DiagramResizeUtils.isAutoFontResize(textNode, this.properties.fontresize);
// if (isAutoResize) {
//     this.mainParent.style.setProperty("--titleHolderMH", "unset");
//     this.mainParent.style.setProperty("--subtitleHolderMH", "unset");
//     DiagramResizeUtils.doFontResize(textNode, nodeGroup, parentNode, this.fontClassList);
//     this.updateTextSingleLineHeight();
// } else

// set min font class to all nodes eg) h1, h2, h3, p1, p2, p3
PlainDiagramNode.prototype.setMinFontSize = function () {
    let nodecount = this.diagramParent.dataset.nodecount;
    this.arrTextNodes?.forEach((element) => {
        let arrNodeToResize = this.diagramParent?.querySelectorAll("[name='" + element + "']");
        let textNode = arrNodeToResize?.[0]?.querySelector("[data-name='text']");
        let maxNode = this.diagramParent?.querySelector("[name='" + textNode?.getAttribute("name") + "'][data-max-node='true']");
        if (maxNode && arrNodeToResize) {
            let primaryMinusFactor = 0;
            // if (nodecount > 5) {
            //     primaryMinusFactor = 2;
            // } else if (nodecount > 3) {
            //     primaryMinusFactor = 1;
            // }
            let secondaryMinusFactor = 0;
            // if (nodecount > 5) {
            //     secondaryMinusFactor = 1;
            // }
            let newFontClass = maxNode.getAttribute("data-newfontclass") || maxNode.getAttribute("original-fontclass") || "";
            // let number = newFontClass.replace("h", "").replace("p", "");
            // let numberOriginal = maxNode.getAttribute("original-fontclass")?.replace("h", "")?.replace("p", "");
            // numberOriginal = parseInt(numberOriginal) + (newFontClass && newFontClass.startsWith("p") ? secondaryMinusFactor : primaryMinusFactor);
            let fontType = newFontClass?.startsWith("h") ? "h" : "p";
            let minFont = 0;
            let arrMaxNodes = this.diagramParent?.querySelectorAll("[name='" + textNode?.getAttribute("name") + "'][data-newfontclass]");
            arrMaxNodes?.forEach((node) => {
                let newFontClass = node.getAttribute("data-newfontclass");
                let number = newFontClass.replace("h", "").replace("p", "");
                let numberOriginal = node.getAttribute("original-fontclass")?.replace("h", "")?.replace("p", "");
                numberOriginal = parseInt(numberOriginal) + (newFontClass && newFontClass.startsWith("p") ? secondaryMinusFactor : primaryMinusFactor);
                if (newFontClass && newFontClass.startsWith("h")) {
                    minFont = Math.max(number, minFont, numberOriginal);
                } else if (newFontClass && newFontClass.startsWith("p")) {
                    minFont = Math.max(number, minFont, numberOriginal);
                }
            });

            if (minFont > 0) {
                arrNodeToResize.forEach((node) => {
                    let textNode = node?.querySelector("[data-name='text']");
                    TextHighLightUtils.removeFontClassName(textNode, this.fontClassList);
                    textNode.classList.add(fontType + minFont);
                    textNode.setAttribute("data-newfontclass", fontType + minFont);
                    this.onTextUpdate(textNode);
                });
            }

            maxNode.setAttribute("data-newfontclass", fontType + minFont);
            maxNode.removeAttribute("data-max-node");
        }
    });

    this.updateTextSingleLineHeight();
};

PlainDiagramNode.prototype.alignToGroup = function (allNodes) {
    let height = this.mainParent.getAttribute("data-nodeGroupMinHeight") || 0;
    this.mainParent.style.setProperty("--nodeGroupHeight", "auto");
    for (let i1 = 0; i1 < allNodes.length; i1++) {
        let node = allNodes[i1];
        let nodeToResize = node.querySelector("[name='nodeGroup']");
        if (nodeToResize) {
            nodeToResize.style.setProperty("height", "auto");
            height = Math.max(height, nodeToResize.offsetHeight);
            nodeToResize.style.removeProperty("height");
        }
    }
    this.mainParent.style.setProperty("--nodeGroupHeight", height + "px");
};

PlainDiagramNode.prototype.alignToSecContent = function (allNodes) {
    let height = 0;
    this.mainParent.style.setProperty("--nodeSecContentHeight", 0 + "px");
    for (let i1 = 0; i1 < allNodes.length; i1++) {
        let node = allNodes[i1];
        let nodeToResize = node.querySelector("[name='secContentNode']");
        if (nodeToResize) height = Math.max(height, nodeToResize.offsetHeight);
    }
    this.mainParent.style.setProperty("--nodeSecContentHeight", height + "px");
};

PlainDiagramNode.prototype.alignToSecSubContent = function (allNodes) {
    let height = 0;
    this.mainParent.style.setProperty("--nodeSecSubContentHeight", 0 + "px");
    for (let i1 = 0; i1 < allNodes.length; i1++) {
        let node = allNodes[i1];
        let nodeToResize = node.querySelector("[name='secSubContentNode']");
        if (nodeToResize) height = Math.max(height, nodeToResize.offsetHeight);
    }
    this.mainParent.style.setProperty("--nodeSecSubContentHeight", height + "px");
};

PlainDiagramNode.prototype.alignToContent = function (allNodes) {
    let height = 0;
    this.mainParent.style.setProperty("--nodeContentHeight", 0 + "px");
    for (let i1 = 0; i1 < allNodes.length; i1++) {
        let node = allNodes[i1];
        let nodeToResize = node.querySelector("[name='contentNode']");
        if (nodeToResize) height = Math.max(height, nodeToResize.offsetHeight);
    }
    this.mainParent.style.setProperty("--nodeContentHeight", height + "px");
};

PlainDiagramNode.prototype.resetMaxHeight = function () {
    //console.log("resetMaxHeight");
    this.mainParent.style.setProperty("--nodeGroupHeight", "auto");

    for (let l3 = 0; l3 < this.arrAllowResize.length; l3++) {
        const key = this.arrAllowResize[l3];
        this.mainParent.style.setProperty("--" + key + "MH", this.arrAllowResizeHeight[l3] + "px");
        // this.diagramParent.style.setProperty("--contentResizeMH", this.arrAllowResizeHeight[l3] + "px");
        if (key.includes("content")) this.setContentResize(this.arrAllowResizeHeight[l3]);
    }

    this.updateTextSingleLineHeight();
    this.updateScrollLeft();
};

PlainDiagramNode.prototype.updateTextSingleLineHeight = function () {
    for (let l3 = 0; l3 < this.arrTextNodes.length; l3++) {
        const key = this.arrTextNodes[l3];
        let node = this.mainParent.querySelector("[name='" + key + "']");
        if (node && node.firstElementChild) {
            let lineHeight = getComputedStyle(node.firstElementChild)["lineHeight"];
            this.mainParent.style.setProperty("--" + key + "MH", lineHeight);
            if (this.boolTextOnly) this.mainParent.style.setProperty("--" + key + "TextOnlyMH", lineHeight);
        } else {
            this.mainParent.style.setProperty("--" + key + "MH", "27px");
            if (this.boolTextOnly) this.mainParent.style.setProperty("--" + key + "TextOnlyMH", "27px");
        }
    }
    let strSupportedNodes = JSON.stringify(this.arrSupportedNodes);
    if (strSupportedNodes.includes("multilineSupport")) {
        let valueText = this.mainParent.querySelector("[name='numberNode']");
        if (valueText) {
            let lineHeight = getComputedStyle(valueText)["lineHeight"];
            this.mainParent.style.setProperty("--valueTitleHolderMH", lineHeight);
        }
    }
};

PlainDiagramNode.prototype.updateScrollLeft = function () {
    let allSingleLineText = Array.from(this.diagramParent.querySelectorAll(".clsSingleLineRestrict"));
    allSingleLineText.forEach((element) => {
        element.parentElement.scrollLeft = 0;
        element.scrollLeft = 0;
    });
};

// Update max size of biggest node to all the nodes.
PlainDiagramNode.prototype.aliginNodeMinSize = function (allNodes, parentHeight) {
    let minNode = null;
    let objMinData = {};
    for (let i1 = 0; i1 < allNodes.length; i1++) {
        let node = allNodes[i1];
        for (let i2 = 0; i2 < this.arrAllowResize.length; i2++) {
            const nodeName = this.arrAllowResize[i2];
            node.setAttribute("data-min-node", false);
            let nodeToResize = node.querySelector("[name='" + this.arrAllowResize[i2] + "']");
            if (this.checkAllowResize(nodeToResize)) {
                objMinData[nodeName] = objMinData[nodeName] ? objMinData[nodeName] : { height: nodeToResize.offsetHeight };
                if (i2 == 0 && nodeToResize.offsetHeight <= objMinData[nodeName].height) minNode = node;
                objMinData[nodeName].height = Math.min(objMinData[nodeName].height, nodeToResize.offsetHeight);
                nodeToResize.style.removeProperty("max-height");
            }
        }
        if (this.boolTextOnly) this.alignToTitleText(node, objMinData);
    }
    if (minNode) minNode.setAttribute("data-min-node", "true");

    this.aliginToContent(objMinData);
    if (allNodes[0] && allNodes[0].firstElementChild) {
        let minHeight = allNodes[0].firstElementChild.offsetHeight;
        for (let i1 = 0; i1 < allNodes.length; i1++) {
            minHeight = Math.max(minHeight, allNodes[i1].firstElementChild.offsetHeight);
        }
        let topMargin = this.verticalAlign == "top" ? 0 : (parentHeight - minHeight) / (this.verticalAlign == "bottom" ? 1 : 2);
        if (this.nodeTopMarginCalc) this.mainParent.style.setProperty("--nodeTopMargin", topMargin + "px");
        this.mainParent.parentElement.style.setProperty("--nodeVAlign", this.verticalAlign == "top" ? "flex-start" : this.verticalAlign == "bottom" ? "flex-end" : "center");
    }
};

PlainDiagramNode.prototype.checkAllowResize = function (nodeToResize) {
    if (this.properties?.name?.includes("timeline") && nodeToResize) return true;

    let numberNode = nodeToResize?.querySelector("[data-type='numberNode']");
    if (!numberNode && nodeToResize) {
        return true;
    }
};

// Resize the image to fill the available height / update all text nodes.
PlainDiagramNode.prototype.aliginNodeContent = function (allNodes, index) {
    // let allNodes = Array.from(allNodesTemp);
    this.arrTextNodes.forEach((element) => {
        let arrNodeToResize = this.diagramParent?.querySelectorAll("[name='" + element + "']");
        let textNode = arrNodeToResize?.[0]?.querySelector("[data-name='text']");
        if (arrNodeToResize && textNode) {
            let isAutoResize = DiagramResizeUtils.isAutoFontResize(textNode, this.properties.fontresize);
            if (isAutoResize) {
                let maxHeight = 0;
                let maxHeightValue = 10000;
                let maxHeightNode = null;
                let maxWidth = textNode?.clientWidth;
                let maxWidthNode = null;
                let maxSizeNode = null;
                arrNodeToResize.forEach((nodeResize) => {
                    let textNodeResize = nodeResize?.querySelector("[data-name='text']");
                    if (textNodeResize) {
                        if (textNodeResize.getAttribute("data-newfontclass")) {
                            textNodeResize.parentElement.style.removeProperty("max-height");
                            textNodeResize.classList.remove(textNodeResize.getAttribute("data-newfontclass"));
                            if (textNodeResize.getAttribute("original-fontclass")) textNodeResize.classList.add(textNodeResize.getAttribute("original-fontclass"));
                        }
                    }
                    let node = nodeResize.querySelector("[data-name='text']");
                    node.parentElement.style.setProperty("min-height", "unset");
                    if (node.clientHeight > 0) {
                        maxHeight = Math.max(maxHeight, node.clientHeight);
                        if (maxHeight == node.clientHeight) maxHeightNode = node;
                    }
                    if (node.scrollHeight > 0) {
                        maxHeight = Math.max(maxHeight, node.scrollHeight);
                        if (maxHeight == node.scrollHeight) maxHeightNode = node;
                    }
                    // if (node.clientWidth > 0) {
                    //     maxWidth = Math.max(maxWidth, node.clientWidth);
                    //     if (maxWidth == node.clientWidth && maxWidth != arrNodeToResize[0]?.clientWidth) maxWidthNode = node;
                    // }
                    if (node.scrollHeight > node.parentElement.clientHeight || node.scrollWidth > node.parentElement.clientWidth) {
                        maxHeightValue = Math.min(maxHeightValue, node.clientHeight);
                        if (maxHeightValue == node.clientHeight) maxSizeNode = node;
                    }
                    node.parentElement.style.removeProperty("min-height");
                });
                // maxWidthNode?.setAttribute("data-max-node", "true");
                if (maxSizeNode) maxSizeNode?.setAttribute("data-max-node", "true");
                else maxHeightNode?.setAttribute("data-max-node", "true");
            }
        }
    });
    for (let i1 = 0; i1 < allNodes.length; i1++) {
        for (let i3 = 0; i3 < this.arrAllowResize.length; i3++) {
            const nodeName = this.arrAllowResize[i3];
            let nodeToResize = allNodes[i1]?.parentElement?.querySelector("[name='" + nodeName + "']");
            if (this.checkAllowResize(nodeToResize)) {
                nodeToResize.style.removeProperty("max-height");
                nodeToResize.style.height = getComputedStyle(nodeToResize).minHeight;
            }
            this.mainParent.style.setProperty("--nodeGroupHeight", "auto");
        }

        for (let i2 = 0; i2 < this.arrTextNodes.length; i2++) {
            const nodeName = this.arrTextNodes[i2];
            let nodeToResize = allNodes[i1]?.parentElement?.querySelector("[name='" + nodeName + "']");
            if (nodeToResize && nodeToResize.clientHeight > 0) {
                let nodeGroup = allNodes[i1].querySelector("[name='nodeGroup']");
                this.onTextChangeUpdate(nodeToResize, allNodes[i1], nodeGroup, true);
            }
        }
        for (let i4 = 0; i4 < this.arrAllowResize.length; i4++) {
            let nodeName = this.arrAllowResize[i4];
            let nodeToResize = allNodes[i1].querySelector("[name='" + nodeName + "']");
            if (this.checkAllowResize(nodeToResize)) {
                let paddingBottom = getComputedStyle(allNodes[i1]).paddingBottom;
                if (paddingBottom && paddingBottom != "") {
                    paddingBottom = parseInt(paddingBottom.replace("px", ""));
                }
                let remHeight = allNodes[i1].offsetHeight - paddingBottom - (allNodes[i1].firstElementChild.offsetHeight - parseInt(getComputedStyle(nodeToResize).minHeight));
                nodeToResize.style.height = remHeight + "px";
            }
        }
    }
};

PlainDiagramNode.prototype.aliginToContent = function (objMinData) {
    let keys = Object.keys(objMinData);
    for (let l3 = 0; l3 < keys.length; l3++) {
        this.mainParent.style.setProperty("--" + keys[l3] + "MH", objMinData[keys[l3]].height + "px");
        if (keys[l3].includes("content")) {
            this.setContentResize(objMinData[keys[l3]].height);
        }
    }
};

// s/m/l content resize
PlainDiagramNode.prototype.setContentResize = function (height) {
    let sizeOveride = this.diagramParent.getAttribute("data-sizeOveride") && this.diagramParent.getAttribute("data-sizeOveride") == "true";
    if ((this.properties.contenttype == "number" && !this.diagramParent.getAttribute("data-resizemicrochart")) || sizeOveride) return;
    if (this.properties[this.properties.contenttype + "size"] != "auto") return;
    this.diagramParent.style.setProperty("--contentResizeMH", height + "px");
    let sizevalue = this.getResizeValue(height);
    if (!this.arrSMLSize) {
        let nodeParentStyle = getComputedStyle(this.parentNode.parentElement);
        this.arrSMLSize = DiagramUtils.getSMLValues(nodeParentStyle);
    }
    sizevalue = DiagramUtils.checkSMLSizeFromFloater(sizevalue, this.properties.floateroptionsdisable, this.arrSMLSize);
    DiagramUtils.updateResize(this.diagramParent, sizevalue, this.diagramProps, this.properties);
};

PlainDiagramNode.prototype.getResizeValue = function (height = null) {
    let objStyleData = window.getComputedStyle(this.diagramParent);
    let maxHeight = parseFloat(objStyleData.getPropertyValue("--originalresizeheight"));
    let maxWidth = parseFloat(objStyleData.getPropertyValue("--originalresizewidth"));
    let heightValue = height / maxHeight;
    let widthValue = heightValue;
    let content = this.nodeGroup.querySelector("[name='contentNode']");
    let computedStyle = window.getComputedStyle(this.nodeGroup);
    let paddingLeft = parseInt(computedStyle.paddingLeft);
    let paddingRight = parseInt(computedStyle.paddingRight);
    let finalWidth = this.nodeGroup.clientWidth - paddingRight - paddingLeft;
    if (this.nodeGroup && content && content.clientWidth > parseInt(finalWidth)) {
        widthValue = finalWidth / maxWidth;
    }
    heightValue = Math.min(heightValue, widthValue);
    heightValue = Math.round(heightValue * 100) / 100;
    heightValue = Math.floor(heightValue * 10) / 10;
    return DiagramUtils.getSMLSizeFromValue(heightValue, {
        tiny: objStyleData.getPropertyValue("--tinySize") || 0.25,
        small: objStyleData.getPropertyValue("--smallSize") || 0.4,
        medium: objStyleData.getPropertyValue("--mediumSize") || 0.6,
        large: objStyleData.getPropertyValue("--largeSize") || 0.8,
        extralarge: objStyleData.getPropertyValue("--extralargeSize") || 1,
    });
};

PlainDiagramNode.prototype.alignToTitleText = function (node, objMinData) {
    for (let i3 = 0; i3 < this.arrTextNodes.length; i3++) {
        const nodeName = this.arrTextNodes[i3];
        let nodeToResize = node?.parentElement?.querySelector("[name='" + nodeName + "']");
        if (nodeToResize) {
            let objMinDataTextOnly = {};
            objMinDataTextOnly[nodeName] = objMinData[nodeName] ? objMinData[nodeName] : { height: nodeToResize.offsetHeight };
            objMinDataTextOnly[nodeName].height = Math.max(objMinDataTextOnly[nodeName].height, nodeToResize.offsetHeight);
            this.mainParent.style.setProperty("--" + nodeName + "TextOnlyMH", objMinDataTextOnly[nodeName].height + "px");
        }
    }
};

// Set font crop logic
PlainDiagramNode.prototype.onTextUpdate = function (textNode) {
    // if (textNode.parentElement.offsetHeight <= textNode.offsetHeight) {
    if (textNode.parentElement.offsetHeight <= textNode.scrollHeight) {
        let objStyleData = window.getComputedStyle(textNode);
        let lineHeight = objStyleData.lineHeight;
        let fontsize = objStyleData.fontSize;
        lineHeight = isNaN(parseFloat(lineHeight)) ? parseFloat(fontsize) * 1.2 : parseFloat(lineHeight);
        let gap = 0;
        let noLinesGap = 0;
        let totalGap = 0;
        if (textNode.childElementCount > 1) {
            // lineHeight = parseFloat(lineHeight) + parseFloat(window.getComputedStyle(textNode.firstElementChild).marginBottom.replace("px", ""));
            // let gap = (parseFloat(window.getComputedStyle(textNode).gap.replace("px", "")) * textNode.children.length-1) /textNode.children.length
            gap = parseFloat(window.getComputedStyle(textNode).gap.replace("px", ""));
            gap = isNaN(gap) ? 0 : gap;
            let totalHeight = 0;

            Array.from(textNode.children).forEach((element, index) => {
                totalHeight += element.offsetHeight + gap;
                if (totalHeight >= textNode.parentElement.offsetHeight && totalGap == 0) {
                    totalGap = index;
                }
            });
            // lineHeight = parseFloat(lineHeight) + gap;
            lineHeight = parseFloat(lineHeight);
            // noLinesGap = gap == 0 ? 0 : Math.max((gap * (totalGap)) / lineHeight, 1);
        }
        let noLines = Math.max(textNode.parentElement.offsetHeight / lineHeight, 1);
        // noLines = noLines + noLinesGap;
        let offDifference = noLines - parseInt(noLines);
        let lines = offDifference > 0.85 ? parseInt(noLines) + 1 : parseInt(noLines);
        // textNode.parentElement.style.maxHeight = lines * lineHeight + gap + "px";
        textNode.parentElement.style.maxHeight = lines * lineHeight + "px";
        if (textNode.nodeName != "UL") textNode.parentElement.style.overflow = "hidden";
    }
    // textNode.parentElement.scrollTop = 0;
    // textNode.scrollTop = 0;
};

PlainDiagramNode.prototype.onTextChange = function (event) {
    // console.log("onTextChange");
    this.diagramParent.removeAttribute("data-sizeOveride");
    if (event.target && event.target.dataset && event.target.dataset.index && this.boolFixedGroup) {
        let nodeGroup = this.parentNode.querySelector("[id='nodeGroup" + event.target.dataset.index + "']");
        if (!nodeGroup && this.parentNode.id.includes("common")) {
            nodeGroup = this.parentNode.querySelector("[id='nodeGroupCommon" + event.target.dataset.index + "']");
        }
        if (nodeGroup) {
            nodeGroup.style.setProperty("max-height", "unset");
            nodeGroup.parentElement.style.setProperty("max-height", "unset");
        }
        // nodeGroup.style.removeProperty("max-height");
        // nodeGroup.parentElement.style.removeProperty("max-height");
    }
    this.onTextChangeUpdate(event.target.parentElement, this.parentNode, this.nodeGroup);
};

PlainDiagramNode.prototype.onTextChangeUpdate = function (nodeToUpdate, parentNode, nodeGroup) {
    if (!nodeToUpdate) return;
    let textNode = nodeToUpdate.querySelector("[data-name='text']");
    if (textNode) {
        textNode.style.removeProperty("max-height");
        textNode.parentElement.style.removeProperty("max-height");
    }
    // let parentHeight = parentNode.offsetHeight;
    // let contentHeight = nodeGroup.offsetHeight;
    // let heightDiff = contentHeight - parentHeight;
    let parentStyle = window.getComputedStyle(nodeGroup, null);
    let nodeParentStyle = window.getComputedStyle(parentNode, null);
    let paddingTop = parentStyle?.getPropertyValue("padding-top")?.replace("px", "");
    let paddingBottom = parentStyle?.getPropertyValue("padding-bottom")?.replace("px", "");
    let nodePaddingTop = nodeParentStyle?.getPropertyValue("padding-top")?.replace("px", "");
    let nodePaddingBottom = nodeParentStyle?.getPropertyValue("padding-bottom")?.replace("px", "");

    let parentHeight = parentNode.offsetHeight - (parseFloat(nodePaddingTop) + parseFloat(nodePaddingBottom));
    let contentHeight = nodeGroup.offsetHeight - (parseFloat(paddingTop) + parseFloat(paddingBottom));
    let heightDiff = contentHeight - parentHeight;
    if (contentHeight > parentHeight) {
        for (let i1 = 0; i1 < this.arrAllowResize.length; i1++) {
            let nodeName = this.arrAllowResize[i1];
            let nodeToResize = parentNode.querySelector("[name='" + nodeName + "']");
            if (this.checkAllowResize(nodeToResize)) {
                let computedStype = window.getComputedStyle(nodeToResize);
                let nodeHeight = parseInt(computedStype.height.replace("px", ""));
                let minHeight = parseInt(computedStype.minHeight.replace("px", ""));
                nodeToResize.style.setProperty("max-height", Math.max(minHeight, nodeHeight - heightDiff) + "px");
                contentHeight = nodeGroup.offsetHeight;
                heightDiff = contentHeight - parentHeight;
                if (contentHeight <= parentHeight) break;
            }
        }

        contentHeight = nodeGroup.offsetHeight;
        heightDiff = contentHeight - parentHeight;
        if (contentHeight > parentHeight) {
            let nodeHeight = nodeToUpdate.offsetHeight;
            let maxHeight = nodeHeight - heightDiff;
            nodeToUpdate.style.setProperty("max-height", maxHeight + "px");
        }
    }
    contentHeight = nodeGroup.offsetHeight;
    heightDiff = contentHeight - parentHeight;
    if (contentHeight > parentHeight) {
        let nodeHeight = nodeToUpdate.offsetHeight;
        let maxHeight = nodeHeight - heightDiff;
        nodeToUpdate.style.setProperty("max-height", maxHeight + "px");
    }
    let isAutoResize = DiagramResizeUtils.isAutoFontResize(textNode, this.properties.fontresize);
    // if (isAutoResize && textNode.dataset?.maxNode == "true") {
    if (isAutoResize) {
        // this.mainParent.style.setProperty("--titleHolderMH", "unset");
        // this.mainParent.style.setProperty("--subtitleHolderMH", "unset");
        DiagramResizeUtils.doFontResize(textNode, nodeGroup, parentNode, this.fontClassList, paddingTop, paddingBottom, nodePaddingTop, nodePaddingBottom);
        this.updateTextSingleLineHeight();
    } else if (textNode) this.onTextUpdate(textNode);
};

PlainDiagramNode.prototype.aliginResizeNode = function (allNodes) {
    for (let i1 = 0; i1 < allNodes.length; i1++) {
        for (let i2 = 0; i2 < this.arrTextNodes.length; i2++) {
            const nodeName = this.arrTextNodes[i2];
            let nodeToResize = allNodes[i1]?.parentElement?.querySelector("[name='" + nodeName + "']");
            if (nodeToResize) {
                let nodeGroup = allNodes[i1].querySelector("[name='nodeGroup']");
                this.onPlainTextChangeUpdateForResize(nodeToResize, allNodes[i1], nodeGroup, true);
            }
        }
    }
};

PlainDiagramNode.prototype.onPlainTextChangeUpdateForResize = function (nodeToUpdate) {
    if (!nodeToUpdate) return;
    let textNode = nodeToUpdate.querySelector("[data-name='text']");
    if (textNode) {
        textNode.style.removeProperty("max-height");
        textNode.parentElement.style.removeProperty("max-height");
    }
    if (textNode) this.onTextUpdate(textNode);
};

/**
 * Author:    Saravanan G
 * Created:   13.12.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function GridDiagramNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    PlainDiagramNode.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
    this.boolFixedGroup = false;
    this.boolFixedContent =  false;
    this.boolFixedSecContent = false;
    this.boolFixedNode = false;
    this.nodeTopMarginCalc = false;
}

GridDiagramNode.prototype = Object.create(PlainDiagramNode.prototype);

GridDiagramNode.prototype.constructor = GridDiagramNode;

/**
 * Author:    Saravanan G
 * Created:   22.04.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function CustomDiagramNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    PlainDiagramNode.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
}

CustomDiagramNode.prototype = Object.create(PlainDiagramNode.prototype);
CustomDiagramNode.prototype.constructor = CustomDiagramNode;

/**
 * Author:    Saravanan G
 * Created:   22.04.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function CommonDiagramNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    PlainDiagramNode.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
    this.nodeGroup = mainParent;
    this.objData = this.objData && Object.keys(this.objData).length != 0 ? this.objData : this.getJSONData();

    let menuFontSize = diagramProps && diagramProps.fontClass ? diagramProps.fontClass.split(",")[0] : null;
    let menuFontClass = diagramProps && diagramProps.fontClass ? diagramProps.fontClass.split(",")[1] : null;
    this.objStyleData.fontSizeData = this.objStyleData.fontSizeData || {};
    this.textFontSize = menuFontClass && menuFontClass == "commontitle" ? menuFontSize : (diagramProps && diagramProps.titleFontSize) || this.objStyleData.fontSizeData?.commontitle || "h5";
}

CommonDiagramNode.prototype = Object.create(PlainDiagramNode.prototype);
CommonDiagramNode.prototype.constructor = CommonDiagramNode;

CommonDiagramNode.prototype.createNodes = function (nodeObj, nodeParent, objSecData = null) {
    let name = nodeObj.name;
    let holdertype = !this.isHolderTypePresent ? "primary" : nodeObj.holdertype || "secondary";
    let content = null;
    let centernodetype = this.diagramParent.getAttribute("data-centernodetype") || "icon";
    let centerholdertype = this.diagramParent.getAttribute("data-centerholdertype") || "iconHolder";
    if (centernodetype && name.includes(centerholdertype)) {
        content = this.getContentDataBasedOnSelectedHolder(name, centernodetype, this.objData, nodeObj.islogo, nodeParent);
        // } else if (this.objData?.content) {
        //     content = this.objData.content;
    } else {
        return;
    }

    if (objSecData) content = objSecData;
    if ((!content || (content && Object.keys(content).length == 0)) && this.objData?.content) content = this.objData.content;
    if (!content) content = {};
    switch (name) {
        case "titleHolder":
            return this.createTitle(nodeParent, this.objData.primarytext, nodeObj);
        case "contentNode":
            return this.createContentNode(nodeParent, nodeObj);
        case "secContentNode":
            return this.createSecContentNode(nodeParent, nodeObj);
        case "moodNode":
            return this.createMoodNode(nodeParent, nodeObj);
        case "subTitleHolder":
            return this.createSubTitle(nodeParent, nodeObj);
        case "seqTitleHolder":
            return this.createSeqTitle(nodeParent, nodeObj);
        case "checkListHolder":
            return this.createCheckListNode(nodeParent, nodeObj, content);
        case "secSubContentNode":
            return this.createSecSubContentNode(nodeParent, nodeObj);
        case "valueTitleHolder":
            this.isHolderTypePresent = true;
            return this.createValueTitle(nodeParent, content, holdertype, nodeObj);
        case "textTitleHolder":
            this.isHolderTypePresent = true;
            return this.createTextTitle(nodeParent, content, holdertype, nodeObj);
        case "buttonTitleHolder":
            this.isHolderTypePresent = true;
            return this.createButtonTitleHolder(nodeParent, content, holdertype, nodeObj);
        case "imageHolder":
            this.isHolderTypePresent = true;
            return this.createImageNode(nodeParent, content, name, holdertype, nodeObj);
        case "imageSecHolder":
            this.isHolderTypePresent = true;
            return this.createImageNode(nodeParent, content, name, holdertype, nodeObj);
        case "iconHolder":
        case "iconSecHolder":
            this.isHolderTypePresent = true;
            return this.createIconNode(nodeParent, content, name, holdertype, nodeObj);
        case "microChartHolder":
            this.isHolderTypePresent = true;
            return this.createMicroNode(nodeParent, content, name, holdertype, nodeObj);
        case "shapeHolder":
            return this.createShapeNode(nodeParent, nodeObj, name, nodeObj);
        case "staticTextHolder":
            return this.createStaticContent(nodeParent, nodeObj);
        default:
            break;
    }
};

CommonDiagramNode.prototype.createCenterNode = function (pattenDiv) {
    let centerHolderParent = document.createElement("div");
    centerHolderParent.setAttribute("data-id", "centerHolderParent");
    centerHolderParent.className = "centerHolderParent clsMultiColorParent";
    centerHolderParent.setAttribute("name", "centerHolderParent");
    centerHolderParent.setAttribute("data-name", "centerHolderParent");
    centerHolderParent.setAttribute("id", "centerHolderParent0");

    let intCount = this.centerNode.length;
    for (let i = 0; i < intCount; i++) {
        let nodeObj = this.centerNode[i];
        let nodeParent = this.createNodes(nodeObj, centerHolderParent);
        if (nodeParent) nodeParent.setAttribute("data-focus-parent", "centerHolderParent");
        if (nodeObj.subNodes && nodeParent) {
            this.createNestedNodes(nodeObj.subNodes, nodeParent);
        }
    }

    let arrAnimateElement = centerHolderParent.querySelectorAll(".moodanimation");

    arrAnimateElement.forEach((animateElement) => {
        animateElement.dataset.animation = "commonplaceholder";
    });

    centerHolderParent.setAttribute("data-type", centerHolderParent.firstElementChild.dataset.type);
    centerHolderParent.setAttribute("data-content-type", centerHolderParent.firstElementChild.dataset.contentType);
    centerHolderParent.setAttribute("data-focus-parent", "centerHolderParent");
    pattenDiv.appendChild(centerHolderParent);
    this.parentNode = centerHolderParent;
    this.setLinkData();
    this.centerNodeAssetUpdate(centerHolderParent);
    return centerHolderParent;
};

CommonDiagramNode.prototype.createNestedNodes = function (subNodes, nodeParentToInsert, objDataSec) {
    for (let j = 0; j < subNodes.length; j++) {
        let nodeObj = subNodes[j];
        let nodeParent = this.createNodes(nodeObj, nodeParentToInsert, objDataSec);
        if (nodeParent) nodeParent.setAttribute("data-focus-parent", "centerHolderParent");
        if (nodeObj.subNodes && nodeParent) {
            this.createNestedNodes(nodeObj.subNodes, nodeParent, objDataSec);
        }
    }
};

CommonDiagramNode.prototype.createTextTitle = function (bgDiv, content, holdertype, nodeObj) {
    if (!content.value || content.value == "") {
        content.value = "Title";
    }
    let titleHolder = PlainDiagramNode.prototype.createTextTitle.call(this, bgDiv, content, holdertype, nodeObj);
    return titleHolder;
};

CommonDiagramNode.prototype.getFontSize = function (name, nodeObj, defaultFontSize, properties) {
    let hasFontResize = properties.centernodefontresize?.[name] && properties.centernodefontresize?.[name] != "auto";
    return hasFontResize ? properties.centernodefontresize?.[name] : nodeObj.fontClass || defaultFontSize;
};

CommonDiagramNode.prototype.updateNodeAttributes = function (index, diagramRenderComplete) {
    this.index = index;
    if (!this.parentNode) return;
    this.parentNode.setAttribute("data-index", this.index);

    let allNodes = this.parentNode.querySelectorAll("[data-index]");
    allNodes.forEach((nodeItem) => {
        nodeItem.setAttribute("data-index", this.index);
    });

    let allCOntentNodes = this.parentNode.querySelectorAll("[name='contentNode']");
    allCOntentNodes.forEach((nodeItem) => {
        nodeItem.setAttribute("id", "contentNode" + this.index);
    });

    let allNodeGroups = this.parentNode.querySelectorAll("[name='nodeGroup']");
    allNodeGroups.forEach((nodeItem) => {
        nodeItem.setAttribute("id", "nodeGroup" + this.index);
    });

    let allConnectors = this.parentNode.querySelectorAll("[name='connector']");
    allConnectors.forEach((nodeItem) => {
        nodeItem.setAttribute("id", "connector" + this.index);
    });

    let allConnectorParent = this.parentNode.querySelectorAll("[data-id='connectorparent']");
    allConnectorParent.forEach((nodeItem) => {
        nodeItem.setAttribute("id", "connectorparent" + this.index);
    });

    let allSeqText = this.parentNode.querySelectorAll("[name='seqText']");
    allSeqText.forEach((nodeItem) => {
        let content = DiagramUtils.getSeqMoodStyle(this.globalMoodData ? this.globalMoodData.seqnumproperties : null, this.properties, "sequencenumber", this.index + 1, this.diagramParent.dataset.nodecount);
        nodeItem.innerText = content;
    });

    if (this.arrTextNodes && this.nodeGroup)
        this.arrTextNodes.forEach((item) => {
            let objItem = this.nodeGroup.querySelector("[name='" + item + "']");
            if (objItem && objItem.children) this.updateOnFocusOut(objItem.children[0]);
        });

    let allIconNodes = this.parentNode.querySelectorAll("[data-id='iconNode']");

    allIconNodes.forEach((nodeItem) => {
        let parentElement = nodeItem.parentElement;
        parentElement.setAttribute("id", "iconHolder" + this.index);
    });

    this.updateCheckListNode();

    if (this.contentBG) DiagramNodeUtils.applyNodeStyleClipPath(this.contentBG.id, this.diagramParent, index);

    this.updateImageLogoFrames();

    if (this.arrTintArray && this.arrTintArray.length > 0) {
        DiagramUtils.setCustomItemColor(this.parentNode.parentElement, this.arrTintArray, this.index, this.index + 1);
        let nodeNonlinear = this.diagramParent.querySelector("[name='nodeNonlinearMainParent'][data-index='" + this.index + "']");
        if (nodeNonlinear) DiagramUtils.setCustomItemColor(nodeNonlinear, this.arrTintArray, this.index, this.index + 1);
    }
};

CommonDiagramNode.prototype.setLinkData = function () {
    if (this.objData.link) {
        this.mainParent.setAttribute("data-navigate-to-slide-on-click", this.objData.link);
    }
    if (this.objData.extralink) {
        let linknode = this.mainParent.parentElement.querySelector("[id='" + this.objData.extralink.id + "']");
        if (linknode) {
            linknode.parentElement.setAttribute("data-navigate-to-slide-on-click", this.objData.extralink.value);
        }
    }
};

CommonDiagramNode.prototype.getJSONData = function () {
    let data = PlainDiagramNode.prototype.getJSONData.call(this);
    data.link = this.mainParent.dataset.navigateToSlideOnClick;
    let extraLinkDiv = this.mainParent.parentElement.querySelector("[data-linkid]");
    if (extraLinkDiv) nodeData.extralink = { value: extraLinkDiv.parentElement.dataset.navigateToSlideOnClick, id: extraLinkDiv.getAttribute("id") };
    if (data.content?.type === "text") {
        let textNode = this.mainParent.querySelector("[name='holderText']");
        if (textNode) data.content.textproperties = DiagramCreateUtil.getTextProps(textNode)?.textproperties;
    }
    return data;
};

CommonDiagramNode.prototype.getTextProps = function (primaryText) {
    let objProps = PlainDiagramNodeBase.prototype.getTextProps.call(this, primaryText);
    let textclassname = this.properties?.centernodefontresize?.[primaryText.getAttribute("name")];
    if (textclassname && objProps.textproperties) objProps.textproperties.textclassname = textclassname;
    return objProps;
};

/**
 * Author:    Saravanan G
 * Created:   13.12.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function VerticalDiagramNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    PlainDiagramNode.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
}

VerticalDiagramNode.prototype = Object.create(PlainDiagramNode.prototype);
VerticalDiagramNode.prototype.constructor = VerticalDiagramNode;

VerticalDiagramNode.prototype.updateOnFocusOut = function (targetNode) {
    // console.log("inside updateOnFocusOut "+ this.index  + " - " + this.mainParent.id    );
    this.resetMaxHeight();
    if (!this.mainParent || !this.mainParent.parentElement) return;
    if (this.boolFixedContent) {
        let minWidth = 0;
        let allNodes = this.mainParent.querySelectorAll("[name='contentNode']");
        for (let i1 = 0; i1 < allNodes.length; i1++) {
            let nodeToResize = allNodes[i1];
            nodeToResize.style.minWidth = "unset";
            minWidth = Math.max(minWidth, nodeToResize.offsetWidth);
            nodeToResize.style.minWidth = "var(--contentWidth)";
        }
        this.parentNode.parentElement.parentElement.style.setProperty("--contentWidth", minWidth + "px");
    }

    if (this.boolFixedSecContent) {
        let minWidth = 0;
        let allNodes = this.mainParent.querySelectorAll("[name='secContentNode']");
        for (let i1 = 0; i1 < allNodes.length; i1++) {
            let nodeToResize = allNodes[i1];
            nodeToResize.style.minWidth = "unset";
            minWidth = Math.max(minWidth, nodeToResize.offsetWidth);
            nodeToResize.style.minWidth = "var(--contentWidth)";
        }
        this.parentNode.parentElement.parentElement.style.setProperty("--contentWidth", minWidth + "px");
    }
    if (this.boolFixedSecSubContent) {
        let minWidth = 0;
        let allNodes = this.mainParent.querySelectorAll("[name='secSubContentNode']");
        for (let i1 = 0; i1 < allNodes.length; i1++) {
            let nodeToResize = allNodes[i1];
            nodeToResize.style.minWidth = "unset";
            minWidth = Math.max(minWidth, nodeToResize.offsetWidth);
            nodeToResize.style.minWidth = "var(--contentWidth)";
        }
        this.parentNode.parentElement.parentElement.style.setProperty("--contentWidth", minWidth + "px");
    }
    // this.boolFixedNode = true;
    if (this.boolFixedNode) {
        let minHeight = 0;
        let allNodes = this.mainParent.querySelectorAll("[name='nodeparent']");
        for (let i1 = 0; i1 < allNodes.length; i1++) {
            let nodeToResize = allNodes[i1];
            nodeToResize.style.minHeight = "unset";
            minHeight = Math.max(minHeight, nodeToResize.offsetHeight);
            nodeToResize.style.minHeight = "var(--nodeVerMinHeight)";
        }
        this.parentNode.parentElement.parentElement.style.setProperty("--nodeVerMinHeight", minHeight + "px");
    }
    let allNodes = this.mainParent.parentElement.querySelectorAll("[name='nodeparent']");
    this.aliginNodeContent(allNodes);
    // if (!this.diagramProps?.nodealignment?.includes("agenda")) {
    this.setMinFontSize();
    // }

    this.mainParent.parentElement.style.setProperty("--nodeVAlign", this.verticalAlign == "top" ? "flex-start" : this.verticalAlign == "bottom" ? "flex-end" : "center");
};

VerticalDiagramNode.prototype.onTextChangeUpdate = function (nodeToUpdate, parentNode, nodeGroup) {
    if (!nodeToUpdate) return;
    // nodeGroup = nodeGroup.querySelector("[name='secContentNode']");
    // if (!nodeGroup) return;
    let textNode = nodeToUpdate.querySelector("[data-name='text']");
    if (textNode) {
        textNode.style.removeProperty("max-height");
        textNode.parentElement.style.removeProperty("max-height");
    }

    let node = parentNode.querySelector("[name='nodeGroup']");
    let parentStyle = window.getComputedStyle(node, null);
    let nodeParentStyle = window.getComputedStyle(parentNode, null);
    let paddingTop = parentStyle?.getPropertyValue("padding-top")?.replace("px", "");
    let paddingBottom = parentStyle?.getPropertyValue("padding-bottom")?.replace("px", "");
    let nodePaddingTop = nodeParentStyle?.getPropertyValue("padding-top")?.replace("px", "");
    let nodePaddingBottom = nodeParentStyle?.getPropertyValue("padding-bottom")?.replace("px", "");

    let parentHeight = parentNode.offsetHeight - (parseFloat(nodePaddingTop) + parseFloat(nodePaddingBottom));
    let contentHeight = nodeGroup.offsetHeight - (parseFloat(paddingTop) + parseFloat(paddingBottom));

    if (parentHeight == contentHeight) {
        let secContent = parentNode.querySelector("[name='secContentNode']");
        nodeGroup = secContent || nodeGroup;
        contentHeight = nodeGroup.scrollHeight;
    }

    if (contentHeight < parentHeight) {
        for (let i1 = 0; i1 < this.arrAllowResize.length; i1++) {
            let nodeName = this.arrAllowResize[i1];
            let nodeToResize = parentNode.querySelector("[name='" + nodeName + "']");
            if (nodeToResize) {
                let maxHeight = parentNode.dataset.minNode == "true" || this.arrAllowResize.length == 0 ? "1000px" : this.mainParent.style.getPropertyValue("--" + nodeName + "MH");
                nodeToResize.style.setProperty("max-height", maxHeight);
                contentHeight = nodeGroup.scrollHeight - (parseFloat(paddingTop) + parseFloat(paddingBottom));
                if (contentHeight >= parentHeight) break;
            }
        }
    }
    let heightDiff = contentHeight - parentHeight;
    if (contentHeight > parentHeight) {
        for (let i1 = 0; i1 < this.arrAllowResize.length; i1++) {
            let nodeName = this.arrAllowResize[i1];
            let nodeToResize = parentNode.querySelector("[name='" + nodeName + "']");
            if (nodeToResize) {
                let computedStype = window.getComputedStyle(nodeToResize);
                let nodeHeight = parseInt(computedStype.height.replace("px", ""));
                let minHeight = parseInt(computedStype.minHeight.replace("px", ""));
                nodeToResize.style.setProperty("max-height", Math.max(minHeight, nodeHeight - heightDiff) + "px");
                contentHeight = nodeGroup.scrollHeight - (parseFloat(paddingTop) + parseFloat(paddingBottom));
                heightDiff = contentHeight - parentHeight;
                if (contentHeight <= parentHeight) break;
            }
        }

        contentHeight = nodeGroup.scrollHeight - (parseFloat(paddingTop) + parseFloat(paddingBottom));
        heightDiff = contentHeight - parentHeight;
        if (contentHeight > parentHeight) {
            let nodeHeight = nodeToUpdate.offsetHeight - (parseFloat(paddingTop) + parseFloat(paddingBottom));
            let maxHeight = Math.abs(nodeHeight - heightDiff);
            nodeToUpdate.style.setProperty("max-height", maxHeight + "px");
        }
    }
    contentHeight = nodeGroup.scrollHeight - (parseFloat(paddingTop) + parseFloat(paddingBottom));
    heightDiff = contentHeight - parentHeight;

    if (contentHeight > parentHeight) {
        let nodeHeight = nodeToUpdate.offsetHeight;
        let maxHeight = Math.abs(nodeHeight - heightDiff);
        nodeToUpdate.style.setProperty("max-height", maxHeight + "px");
    }
    let isAutoResize = DiagramResizeUtils.isAutoFontResize(textNode, this.properties.fontresize);
    // if (isAutoResize && textNode.dataset?.maxNode == "true") {
    if (isAutoResize) {
        // this.mainParent.style.setProperty("--titleHolderMH", "unset");
        // this.mainParent.style.setProperty("--subtitleHolderMH", "unset");
        DiagramResizeUtils.doFontResize(textNode, nodeGroup, parentNode, this.fontClassList, paddingTop, paddingBottom, nodePaddingTop, nodePaddingBottom);
        this.updateTextSingleLineHeight();
    } else if (textNode) this.onTextUpdate(textNode);
};

VerticalDiagramNode.prototype.setContentResize = function (height) {};

//Only used for nonlinear circle
function NonLinearCircleNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    VerticalDiagramNode.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
}

NonLinearCircleNode.prototype = Object.create(VerticalDiagramNode.prototype);
NonLinearCircleNode.prototype.constructor = NonLinearCircleNode;

NonLinearCircleNode.prototype.getContentData = function (holdertype, secContentParent = null) {
    let svgHolder = this.diagramParent.querySelector("[data-id='deviceHolder']");
    if (svgHolder && svgHolder.firstChild && this.parentNode?.dataset?.index) {
        let point = svgHolder.firstChild.querySelector(`[id*=-point${parseFloat(this.parentNode.dataset.index) + 1}]`);
        if (point) {
            let placeHolder = point.querySelector("[id*='placeholder']");
            let svgItem = placeHolder.querySelector("[id*='svgItem']");
            if (svgItem) {
                return this.getDataByNodeType(svgItem.firstChild);
            }
        }
    }
    return { type: "text", value: "" };
};

NonLinearCircleNode.prototype.getDataByNodeType = function (node) {
    let data = {};
    let dataRef = {};
    let assetText = node.parentElement.getAttribute("data-node-graphic-text") || "";
    switch (node.tagName) {
        case "use":
            let iconid = node.getAttribute("iconid");
            let path = node.getAttribute("iconpath");
            dataRef.name = iconid;
            data = { type: "icon", assetText: assetText, value: path, id: iconid, dataRef: dataRef, contenttype: "icon" };
            break;
        case "text":
            data = { type: "text", value: node.textContent == "" && node.getAttribute("data-text") ? node.getAttribute("data-text") : node.textContent, contenttype: "text" };
            break;
    }

    return data;
};

/**
 * Author:    Saravanan G
 * Created:   13.12.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function VerticalSplitColumnDiagramNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    VerticalDiagramNode.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
}

VerticalSplitColumnDiagramNode.prototype = Object.create(VerticalDiagramNode.prototype);
VerticalSplitColumnDiagramNode.prototype.constructor = VerticalSplitColumnDiagramNode;

VerticalSplitColumnDiagramNode.prototype.updateOnFocusOut = function (targetNode) {
    // console.log("inside updateOnFocusOut "+ this.index + " - " + index + " - " + this.mainParent.id    );
    this.mainParent.style.setProperty("--nodeTopMargin", "unset");
    this.mainParent.style.setProperty("--titleHolderMH", "unset");

    this.resetMaxHeight();
    if (!this.mainParent || !this.mainParent.parentElement) return;
    let allNodes = this.mainParent.parentElement.querySelectorAll("[name='nodeparent']");

    this.aliginNodeContent(allNodes);
    this.setMinFontSize();
    if (this.boolFixedContent) {
        let minWidth = 0;
        let allNodes = this.mainParent.querySelectorAll("[name='contentNode']");
        for (let i1 = 0; i1 < allNodes.length; i1++) {
            let nodeToResize = allNodes[i1];
            nodeToResize.style.minWidth = "unset";
            minWidth = Math.max(minWidth, nodeToResize.offsetWidth);
            nodeToResize.style.minWidth = "var(--contentWidth)";
        }
        this.parentNode.parentElement.parentElement.style.setProperty("--contentWidth", minWidth + "px");
    }

    if (this.boolFixedSecContent) {
        let minWidth = 0;
        let allNodes = this.mainParent.querySelectorAll("[name='secContentNode']");
        for (let i1 = 0; i1 < allNodes.length; i1++) {
            let nodeToResize = allNodes[i1];
            nodeToResize.style.minWidth = "unset";
            minWidth = Math.max(minWidth, nodeToResize.offsetWidth);
            nodeToResize.style.minWidth = "var(--contentWidth)";
        }
        this.parentNode.parentElement.parentElement.style.setProperty("--contentWidth", minWidth + "px");
    }
    // this.boolFixedNode = true;
    if (this.boolFixedNode) {
        let minHeight = 0;
        let allNodes = this.mainParent.querySelectorAll("[name='nodeparent']");
        for (let i1 = 0; i1 < allNodes.length; i1++) {
            let nodeToResize = allNodes[i1];
            nodeToResize.style.minHeight = "unset";
            minHeight = Math.max(minHeight, nodeToResize.offsetHeight);
            nodeToResize.style.minHeight = "var(--nodeVerMinHeight)";
        }
        this.parentNode.parentElement.parentElement.style.setProperty("--nodeVerMinHeight", minHeight + "px");
    }
    this.mainParent.parentElement.style.setProperty("--nodeVAlign", this.verticalAlign == "top" ? "flex-start" : this.verticalAlign == "bottom" ? "flex-end" : "center");
    // if (targetNode) targetNode.scrollTop = 0;
};

VerticalSplitColumnDiagramNode.prototype.onTextChangeUpdate = function (nodeToUpdate, parentNode, nodeGroup) {
    VerticalDiagramNode.prototype.onTextChangeUpdate.call(this, nodeToUpdate, parentNode, nodeGroup);
    if (!nodeToUpdate) return;
    nodeGroup = nodeGroup.querySelector("[name='secContentNode']");
    if (!nodeGroup) return;
    let textNode = nodeToUpdate.querySelector("[data-name='text']");
    if (textNode) {
        textNode.style.removeProperty("max-height");
        textNode.parentElement.style.removeProperty("max-height");
        // parentNode.parentElement.style.removeProperty("max-height");
    }
    if (textNode) this.onTextUpdate(textNode);
    let emptySpace = DiagramResizeUtils.calculateEmptySpace(this.diagramParent);
    let secContent = parentNode.querySelector("[name='secContentNode']");
    let lineHeight = parseFloat(window.getComputedStyle(textNode).lineHeight);
    if (emptySpace < lineHeight) {
        // let padding = 32;
        // try {
        //     padding = parseInt(window.getComputedStyle(this.diagramParent).getPropertyValue("--paddingSplit"));
        // } catch (error) {
        //     console.log(error);
        // }
        parentNode.parentElement.style.setProperty("max-height", parentNode.parentElement.clientHeight + "px", "important");
        secContent.style.setProperty("max-height", parentNode.parentElement.clientHeight + "px", "important");
    } else {
        parentNode.parentElement.style.removeProperty("max-height");
        secContent.style.removeProperty("max-height");
    }
};

/**
 * Author:    Saravanan G
 * Created:   13.12.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function VerticalContentOptionNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    VerticalDiagramNode.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
}

VerticalContentOptionNode.prototype = Object.create(VerticalDiagramNode.prototype);
VerticalContentOptionNode.prototype.constructor = VerticalContentOptionNode;

VerticalContentOptionNode.prototype.createNodes = function (nodeObj, nodeParent, objSecData = null) {
    let name = nodeObj.name;
    let holdertype = !this.isHolderTypePresent ? "primary" : nodeObj.holdertype || "secondary";
    let content = null;
    let arrPyramidClass = ["PyramidDiagram", "FunnelDiagram", "SingleSidePyramidDiagram"];
    if (nodeParent && nodeParent.id && nodeParent.id.includes("contentNode")) {
        let contenttype = this.diagramParent.getAttribute("data-contenttype") || "icon";
        if (arrPyramidClass.includes(this.diagramParent.dataset.classname) && contenttype == "none") {
            contenttype = "icon";
            this.diagramParent.setAttribute("data-contenttype", contenttype);
        }
        this.setHolderType(contenttype, "");
        let contentholdertype = this.diagramParent.getAttribute("data-contentholdertype") || "iconHolder";
        nodeParent.style.setProperty("display", contenttype == "none" ? "none" : "flex", "important");
        if (this.diagramParent) this.diagramParent.setAttribute("data-nomargin", contenttype == "none" ? "true" : "false");
        if (contentholdertype && name.includes(contentholdertype)) {
            if (nodeObj.nodeClass) this.parentNode.parentElement.className = this.parentNode.parentElement.className + " " + nodeObj.nodeClass;
            content = this.getContentDataBasedOnSelectedHolder(name, contenttype, this.objData, nodeObj.islogo, nodeParent);
        } else return;
    }
    //  else content = this.getContentDataBasedOnHolder(name, holdertype, this.objData, nodeObj.islogo, nodeParent);

    if (objSecData) content = objSecData;
    if (!content) content = {};
    switch (name) {
        case "titleHolder":
            return this.createTitle(nodeParent, this.objData.primarytext, nodeObj);
        case "contentNode":
            return this.createContentNode(nodeParent, nodeObj);
        case "secContentNode":
            return this.createSecContentNode(nodeParent, nodeObj);
        case "moodNode":
            return this.createMoodNode(nodeParent, nodeObj);
        case "subTitleHolder":
            return this.createSubTitle(nodeParent, nodeObj);
        case "seqTitleHolder":
            return this.createSeqTitle(nodeParent, nodeObj);
        case "checkListHolder":
            return this.createCheckListNode(nodeParent, nodeObj, content);
        case "checkListSecHolder":
            return this.createCheckListSecNode(nodeParent, nodeObj, content);
        case "secSubContentNode":
            return this.createSecSubContentNode(nodeParent, nodeObj);
        case "valueTitleHolder":
            this.isHolderTypePresent = true;
            return this.createValueTitle(nodeParent, content, holdertype, nodeObj);
        case "textTitleHolder":
            this.isHolderTypePresent = true;
            return this.createTextTitle(nodeParent, content, holdertype, nodeObj);
        case "buttonTitleHolder":
            this.isHolderTypePresent = true;
            return this.createButtonTitleHolder(nodeParent, content, holdertype, nodeObj);
        case "imageHolder":
            this.isHolderTypePresent = true;
            return this.createImageNode(nodeParent, content, name, holdertype, nodeObj);
        case "imageSecHolder":
            this.isHolderTypePresent = true;
            return this.createImageNode(nodeParent, content, name, holdertype, nodeObj);
        case "iconHolder":
        case "iconSecHolder":
            this.isHolderTypePresent = true;
            return this.createIconNode(nodeParent, content, name, holdertype, nodeObj);
        case "microChartHolder":
            this.isHolderTypePresent = true;
            return this.createMicroNode(nodeParent, content, name, holdertype, nodeObj);
        case "shapeHolder":
            return this.createShapeNode(nodeParent, nodeObj, name, nodeObj);
        case "staticTextHolder":
            return this.createStaticContent(nodeParent, nodeObj);
        default:
            break;
    }
};

function VerticalCircularContentOptionNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    VerticalDiagramNode.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
}

VerticalCircularContentOptionNode.prototype = Object.create(VerticalDiagramNode.prototype);
VerticalCircularContentOptionNode.prototype.constructor = VerticalContentOptionNode;

VerticalCircularContentOptionNode.prototype.createNodes = function (nodeObj, nodeParent, objSecData = null) {
    let name = nodeObj.name;
    let holdertype = !this.isHolderTypePresent ? "primary" : nodeObj.holdertype || "secondary";
    let content = null;

    let contenttype = this.diagramParent.getAttribute("data-contenttype") || "icon";
    if (nodeParent && nodeParent.id && nodeParent.id.includes("contentNode")) {
        this.setHolderType(contenttype, "");
        let contentholdertype = this.diagramParent.getAttribute("data-contentholdertype") || "iconHolder";
        if (this.diagramParent) this.diagramParent.setAttribute("data-nomargin", contenttype == "none" ? "true" : "false");
        if (contentholdertype && name.includes(contentholdertype)) {
            if (nodeObj.nodeClass) this.parentNode.parentElement.className = this.parentNode.parentElement.className + " " + nodeObj.nodeClass;
            content = this.getContentDataBasedOnSelectedHolder(name, contenttype, this.objData, nodeObj.islogo, nodeParent);
        } else return;
    } else content = this.getContentDataBasedOnHolder(name, holdertype, this.objData, nodeObj.islogo, nodeParent);

    let arrHolderName = ["imageHolder", "iconHolder", "seqTitleHolder"];
    if (contenttype == "none" && arrHolderName.includes(nodeParent.getAttribute("name") || "")) {
        nodeParent.style.setProperty("display", contenttype == "none" ? "none" : "flex");
    }

    if (objSecData) content = objSecData;
    if (!content) content = {};
    switch (name) {
        case "titleHolder":
            return this.createTitle(nodeParent, this.objData.primarytext, nodeObj);
        case "contentNode":
            return this.createContentNode(nodeParent, nodeObj);
        case "secContentNode":
            return this.createSecContentNode(nodeParent, nodeObj);
        case "moodNode":
            return this.createMoodNode(nodeParent, nodeObj);
        case "subTitleHolder":
            return this.createSubTitle(nodeParent, nodeObj);
        case "seqTitleHolder":
            return this.createSeqTitle(nodeParent, nodeObj);
        case "checkListHolder":
            return this.createCheckListNode(nodeParent, nodeObj, content);
        case "secSubContentNode":
            return this.createSecSubContentNode(nodeParent, nodeObj);
        case "valueTitleHolder":
            this.isHolderTypePresent = true;
            return this.createValueTitle(nodeParent, content, holdertype, nodeObj);
        case "textTitleHolder":
            this.isHolderTypePresent = true;
            return this.createTextTitle(nodeParent, content, holdertype, nodeObj);
        case "buttonTitleHolder":
            this.isHolderTypePresent = true;
            return this.createButtonTitleHolder(nodeParent, content, holdertype, nodeObj);
        case "imageHolder":
            this.isHolderTypePresent = true;
            return this.createImageNode(nodeParent, content, name, holdertype, nodeObj);
        case "imageSecHolder":
            this.isHolderTypePresent = true;
            return this.createImageNode(nodeParent, content, name, holdertype, nodeObj);
        case "iconHolder":
        case "iconSecHolder":
            this.isHolderTypePresent = true;
            return this.createIconNode(nodeParent, content, name, holdertype, nodeObj);
        case "microChartHolder":
            this.isHolderTypePresent = true;
            return this.createMicroNode(nodeParent, content, name, holdertype, nodeObj);
        case "shapeHolder":
            return this.createShapeNode(nodeParent, nodeObj, name, nodeObj);
        case "staticTextHolder":
            return this.createStaticContent(nodeParent, nodeObj);
        default:
            break;
    }
};

/**
 * Author:    Bala Krishnan K.
 * Created:   Wed 20 July 2022
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function MultiCellOptionNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    PlainDiagramNode.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
}

MultiCellOptionNode.prototype = Object.create(PlainDiagramNode.prototype);
MultiCellOptionNode.prototype.constructor = MultiCellOptionNode;

MultiCellOptionNode.prototype.createBackGround = function () {
    let bgDiv = document.createElement("div");
    bgDiv.className = "clsNodeBackgound moodanimation";
    bgDiv.setAttribute("id", "nodeBackgound" + this.index);
    this.parentNode.appendChild(bgDiv);
    DiagramNodeUtils.assignAttributes(bgDiv, { name: "nodeBackgound", "data-name": "nodeBackgound", "data-index": this.index, "data-animation": "nodebg" });
    DiagramUtils.addClassesFromMenu(this.diagramProps.objClass, bgDiv);
    if (this.objData?.nodename) this.nodeParent?.firstElementChild?.setAttribute("data-nodename", this.objData.nodename);
    let cellObj = this.objData;
    this.createNodes(cellObj, this.nodeGroup);
    this.updateNodeAttributes();
};

MultiCellOptionNode.prototype.createNestedNodes = function (nodeObj, nodeParentToInsert) {
    let subNodes = nodeObj.subNodes;
    if (subNodes) this.createNodes(subNodes, nodeParentToInsert);
};

MultiCellOptionNode.prototype.reCreation = function (parentNode) {
    this.parentNode = parentNode.firstElementChild;
    this.nodeGroup = parentNode.querySelector("[name='nodeGroup']");
    this.objData = this.getJSONData();
};

MultiCellOptionNode.prototype.createNodes = function (nodeObj, nodeParent) {
    let holdertype = "primary";
    if (!nodeObj) debugger;
    let arrKeys = Object.keys(nodeObj);
    arrKeys.forEach((element) => {
        switch (element) {
            case "titleHolder":
                this.createTitle(nodeParent, nodeObj["titleHolder"], nodeObj["titleHolder"]);
                break;
            case "subTitleHolder":
                this.createSubTitle(nodeParent, nodeObj["subTitleHolder"]);
                break;
            case "subtextHolder":
                this.createSubTextHolder(nodeParent, nodeObj["subtextHolder"], holdertype, nodeObj["subtextHolder"]);
                break;
            case "textLabelHolder":
                this.createTextLabelHolder(nodeParent, nodeObj["textLabelHolder"], holdertype, nodeObj["textLabelHolder"]);
                break;
            case "textTitleHolder":
                this.createTextTitle(nodeParent, nodeObj["textTitleHolder"], holdertype, nodeObj["textTitleHolder"]);
                break;
            case "valueTitleHolder":
                this.createValueTitle(nodeParent, nodeObj["valueTitleHolder"], holdertype, nodeObj["valueTitleHolder"]);
                break;
            case "buttonTitleHolder":
                this.createButtonTitleHolder(nodeParent, nodeObj["buttonTitleHolder"], holdertype, nodeObj["buttonTitleHolder"]);
                break;
            case "seqTitleHolder":
                this.createSeqTitle(nodeParent, nodeObj["seqTitleHolder"]);
                break;
            case "iconHolder":
                let iconObj = nodeObj["iconHolder"];
                iconObj.value = DiagramUtils.getAssetValueBasedOnType("icon", iconObj.value, this.globalMoodData, this.appStaticURL);
                this.createIconNode(nodeParent, nodeObj["iconHolder"], "iconHolder", holdertype, nodeObj["iconHolder"]);
                break;
            case "imageHolder":
                this.createImageNode(nodeParent, nodeObj["imageHolder"], "imageHolder", holdertype, nodeObj["imageHolder"]);
                break;
            case "iconSecHolder":
                this.createIconNode(nodeParent, nodeObj["iconSecHolder"], "iconSecHolder", holdertype, nodeObj["iconSecHolder"]);
                break;
            case "imageSecHolder":
                this.createImageNode(nodeParent, nodeObj["imageSecHolder"], "imageSecHolder", holdertype, nodeObj["imageSecHolder"]);
                break;
            case "imageGridNode":
                let data = nodeObj.imageGridNode;
                this.createLogoListHolder(nodeParent, data, data.value);
                break;
            case "microChartHolder":
                let microObj = nodeObj["microChartHolder"];
                if (microObj.microStyle) this.microStyle = microObj.microStyle;
                this.createMicroNode(nodeParent, microObj, "microChartHolder", holdertype, microObj);
                break;
            case "checkListHolder":
                this.createCheckListNode(nodeParent, nodeObj["checkListHolder"], nodeObj["checkListHolder"]);
                break;
            case "moodNode":
                this.createMoodNode(nodeParent, nodeObj["moodNode"]);
                break;
            case "shapeHolder":
                this.createShapeNode(nodeParent, nodeObj["shapeHolder"], "shapeHolder", nodeObj["shapeHolder"]);
                break;
            case "staticTextHolder":
                this.createStaticContent(nodeParent, nodeObj["staticTextHolder"]);
                break;
            case "contentNode":
                let contentParent = this.createContentNode(nodeParent, nodeObj["contentNode"]);
                this.createNestedNodes(nodeObj["contentNode"], contentParent);
                break;
            case "secContentNode":
                let secContentParent = this.createSecContentNode(nodeParent, nodeObj);
                this.createNestedNodes(nodeObj["secContentNode"], secContentParent);
                break;
            case "secSubContentNode":
                let secSubContentNode = this.createSecSubContentNode(nodeParent, nodeObj);
                this.createNestedNodes(nodeObj["secSubContentNode"], secSubContentNode);
                break;
            case "authorStyle":
                this.authorStyle = new window["AuthorStyleGroupMultiNode"](
                    this.diagramProps,
                    nodeObj["authorStyle"],
                    this.index,
                    { authorNameFontSize: this.authorNameFontSize, authorDesFontSize: this.authorDesFontSize, globalMoodData: this.globalMoodData },
                    this.diagramParent,
                    this.appStaticURL,
                    this.properties,
                    this.mainParent.querySelector("[name='nodeMainParent']")
                );
                this.authorStyle.createMultiAuthorStyle(nodeParent, nodeObj["authorStyle"]);
                break;
            case "numberToggleStyle":
                this.numberToggleStyle = new window["NumberToggleStyleGroup"](this.diagramProps, nodeObj["numberToggleStyle"], this.index, { numberToggleFontSize: this.numberToggleFontSize, numberToggleDesFontSize: this.numberToggleDesFontSize }, nodeObj, this.appStaticURL);
                this.numberToggleStyle.createNumberToggleStyle(nodeParent, nodeObj);
                break;
            case "priorityNodeHolder":
                this.createPriorityNode(nodeParent, nodeObj["priorityNodeHolder"]);
                break;
            default:
                break;
        }
    });
};

MultiCellOptionNode.prototype.createImageNode = function (parentNode, nodeData, nodeName = "imageHolder", holdertype, nodeObj) {
    let imageHolder = PlainDiagramNodeBase.prototype.createImageNode.call(this, parentNode, nodeData, nodeName, holdertype, nodeObj);
    this.needAssetUpdate(imageHolder, nodeData);
    return imageHolder;
};

MultiCellOptionNode.prototype.createIconNode = function (parentNode, nodeData, nodeName = "iconHolder", holdertype, nodeObj) {
    let iconHolder = PlainDiagramNodeBase.prototype.createIconNode.call(this, parentNode, nodeData, nodeName, holdertype, nodeObj);
    this.needAssetUpdate(iconHolder, nodeData);
    return iconHolder;
};

MultiCellOptionNode.prototype.createCheckListNode = function (bgDiv, nodeObj, nodeData) {
    let contentParentNode = document.createElement("div");
    contentParentNode.className = "checkbox moodanimation";
    contentParentNode.setAttribute("data-id", "checklistNode");
    contentParentNode.setAttribute("data-animation", "item");
    contentParentNode.setAttribute("data-index", this.index);
    contentParentNode.setAttribute("data-type", "checklist");
    contentParentNode.setAttribute("name", "checkListHolder");
    bgDiv.setAttribute("data-content-type", "checklist");
    contentParentNode.setAttribute("data-checkbox-event", "true");
    contentParentNode.setAttribute("data-checkedClass", nodeObj.checkedClass);
    this.properties.contenttype = "checklist";
    let checkmark = document.createElement("div");
    checkmark.setAttribute("data-id", "checkmark");
    checkmark.setAttribute("name", "checkmark");

    // if (Object.keys(nodeData).length == 0) nodeData = DiagramCreateUtil.checkDefaultData(this.diagramParent, nodeData, "checklist", this.appStaticURL);
    // nodeData.value = nodeData.value.toString();
    let ischecked = this.objData && this.objData.nodeproperties && this.objData.nodeproperties.ischecked;
    if (!this.objData.nodeproperties) {
        ischecked = nodeData.value;
    }
    checkmark.setAttribute("data-ischecked", ischecked);
    contentParentNode.setAttribute("data-ischecked", ischecked);
    checkmark.className = "checkmark";
    contentParentNode.appendChild(checkmark);
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, contentParentNode);
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, checkmark);
    let checkmarksvg = DiagramNodeUtils.createSVGElement("svg");
    checkmarksvg.setAttribute("class", "checkmarksvg");
    checkmarksvg.setAttribute("data-id", "checkmarksvg");
    checkmark.appendChild(checkmarksvg);

    let checkBG = nodeData.checkBG || this.diagramProps.checkBG;
    if (checkBG) {
        checkmarksvg.dataset.iconid = checkBG.id;
        checkmarksvg.dataset.iconpath = checkBG.value;
        let objAssets = { id: checkBG.id, value: DiagramUtils.checkAppStaticUrl(checkBG.value, this.appStaticURL) };
        DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body, false)
            .then((svgData) => {
                checkmarksvg.innerHTML = svgData.data;
            })
            .catch((error) => {
                console.log("SVG asset load fail - " + error);
            });
    }

    let uncheckBG = nodeData.uncheckBG || this.diagramProps.uncheckBG;
    if (uncheckBG) {
        let uncheckmarksvg = DiagramNodeUtils.createSVGElement("svg");
        uncheckmarksvg.setAttribute("class", "uncheckmarksvg");
        uncheckmarksvg.setAttribute("data-id", "uncheckmarksvg");
        checkmark.appendChild(uncheckmarksvg);
        uncheckmarksvg.dataset.iconid = uncheckBG.id;
        uncheckmarksvg.dataset.iconpath = uncheckBG.value;
        let objAssets = { id: uncheckBG.id, value: DiagramUtils.checkAppStaticUrl(uncheckBG.value, this.appStaticURL) };
        DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body, false)
            .then((svgData) => {
                uncheckmarksvg.innerHTML = svgData.data;
            })
            .catch((error) => {
                console.log("SVG asset load fail - " + error);
            });
    }

    bgDiv.appendChild(contentParentNode);
    return contentParentNode;
};

MultiCellOptionNode.prototype.changeSecondaryType = function (type, index) {
    let secondaryNodeList = this.nodeGroup.querySelectorAll("[name='secondaryTextItem']");
    let secondaryTextNode = this.nodeGroup.querySelector("[data-id='secondaryText']");
    if (secondaryTextNode && secondaryTextNode.children.length > 0) {
        this.nodeGroup.setAttribute("data-sublist", type);
        this.nodeGroup.style.setProperty("--secondarytexttype", this.isCustomType(type) ? "none" : type);
        this.nodeGroup.style.setProperty("--secondarytextpadding", type == "none" ? "0px" : type == "decimal" ? "36px" : "26px");
        if (secondaryNodeList) {
            for (var i = 0; i < secondaryNodeList.length; i++) {
                let secondaryNode = secondaryNodeList[i];
                if (type == "none") {
                    secondaryNode.classList.remove("secondaryTextItem");
                    secondaryNode.classList.add("secondaryTextItemNormal");
                } else {
                    secondaryNode.classList.add("secondaryTextItem");
                    secondaryNode.classList.remove("secondaryTextItemNormal");
                }
            }
        }
    }
};

MultiCellOptionNode.prototype.getJSONData = function () {
    let objElement = {
        titleHolder: { type: "text" },
        subTitleHolder: { type: "list" },
        seqTitleHolder: { type: "text" },
        valueTitleHolder: { type: "text" },
        textTitleHolder: { type: "text" },
        subTextHolder: { type: "text" },
        buttonTitleHolder: { type: "text" },
        imageHolder: { type: "image" },
        imageSecHolder: { type: "logo" },
        iconHolder: { type: "icon" },
        iconSecHolder: { type: "icon" },
        microChartHolder: { type: "microchart" },
        authorImageHolder: { type: "image" },
        authorNameHolder: { type: "text" },
        authorDesHolder: { type: "text" },
        checkListHolder: { type: "checklist" },
        logoListHolder: { type: "logolist" },
        numberToggleStyle: { type: "numberToggle" },
        imageGridNode: { type: "imageGrid" },
        priorityNodeHolder: { type: "priority" },
    };

    let nodeData = {};
    if (this.parentNode.parentElement.dataset.nodestyleclass) nodeData.nodeStyleClass = this.parentNode.parentElement.dataset.nodestyleclass;
    if (this.parentNode.parentElement.dataset.static) nodeData.static = this.parentNode.parentElement.dataset.static;
    if (this.parentNode.parentElement.dataset.nodestyletype) nodeData.type = this.parentNode.parentElement.dataset.nodestyletype;
    if (this.nodeParent?.firstElementChild?.dataset.nodename) nodeData.nodename = this.nodeParent?.firstElementChild?.dataset.nodename;
    nodeData.nodeproperties = this.getNodeProperties();

    let getDataFormParent = (element, sourceObj) => {
        let arrChildren = element?.children ? Array.from(element.children) : [];

        arrChildren.forEach((child) => {
            let childName = child.getAttribute("name");
            if (childName && Object.keys(objElement).includes(childName)) {
                let { type } = objElement[childName];
                this[type + "Data"]?.(sourceObj, childName, nodeData);
            } else if (childName && child.hasChildNodes()) {
                let data = { subNodes: {} };
                sourceObj[childName] = data;
                getDataFormParent(child, data.subNodes);
            }
        });
    };

    let groupNode = this.parentNode.querySelector("[name='nodeGroup']");
    getDataFormParent(groupNode, nodeData);
    this.objData = nodeData;
    return nodeData;
};

MultiCellOptionNode.prototype.getNodeProperties = function () {
    let nodeProperties = {};
    let arrProperties = ["nodeAlign"];
    arrProperties.forEach((property) => {
        if (this.nodeParent?.firstElementChild) {
            let value = this.nodeParent.firstElementChild.dataset[property];
            if (value) nodeProperties[property] = value;
        }
    });
    return nodeProperties;
};

MultiCellOptionNode.prototype.checklistData = function (nodeData, name, rootNodeData) {
    let element = this.parentNode.querySelector("[name='" + name + "']");
    let checkSvg = element.querySelector("[data-id='checkmarksvg']");
    let uncheckSvg = element.querySelector("[data-id='uncheckmarksvg']");
    let checkPath = checkSvg?.dataset?.iconpath?.replace(this.appStaticURL, "");
    let uncheckPath = uncheckSvg?.dataset?.iconpath?.replace(this.appStaticURL, "");
    if (element)
        nodeData[name] = {
            type: "checklist",
            contenttype: "checklist",
            value: element.dataset.ischecked == "true",
            checkedClass: element.dataset.checkedclass,
            ...(checkPath && { checkBG: { id: checkSvg.dataset.iconid, value: checkPath } }),
            ...(uncheckPath && { uncheckBG: { id: uncheckSvg.dataset.iconid, value: uncheckPath } }),
        };
    if (rootNodeData.nodeproperties) rootNodeData.nodeproperties.ischecked = element.dataset.ischecked == "true";
};

MultiCellOptionNode.prototype.textData = function (nodeData, name, rootNodeData) {
    let element = this.parentNode.querySelector("[name='" + name + "']");
    element = element.firstElementChild || element;
    let tempText = "";
    if (element)
        nodeData[name] = {
            type: "text",
            value: this.getTextContent(element),
            ...DiagramCreateUtil.getTextProps(element),
            contenttype: element.dataset.contentType || "text",
            valuetype: element.dataset.valuetype || "text",
        };

    let valueType = element.dataset.valuetype || element.parentElement.dataset.valuetype;
    if (valueType) {
        rootNodeData.nodeproperties ? (rootNodeData.nodeproperties.valuetype = valueType) : (rootNodeData.nodeproperties = { valuetype: valueType });
    }

    rootNodeData.assetText = { ...(rootNodeData.assetText && { ...rootNodeData.assetText }), primary: element?.textContent };
    rootNodeData.tempText = { ...(rootNodeData.assetText && { ...rootNodeData.assetText }), primary: nodeData[name]?.value };
};

MultiCellOptionNode.prototype.listData = function (nodeData, name, rootNodeData) {
    let element = this.parentNode.querySelector("[name='" + name + "']");
    element = element.firstElementChild || element;
    let subtype = this.nodeGroup.dataset.sublist || "none";
    if (element) {
        let arrLi = element.querySelectorAll("li");
        let items = [];
        let tempText = "";
        arrLi.forEach((li, i) => {
            if (i == 0) tempText = this.getUlTextContent(li);
            items.push({ value: this.getUlTextContent(li), type: "text" });
        });
        nodeData[name] = { type: "list", items: items, sublist: subtype, ...DiagramCreateUtil.getTextProps(element) };

        let valueType = element.dataset.valuetype || element.parentElement.dataset.valuetype;
        if (valueType) {
            rootNodeData.nodeproperties ? (rootNodeData.nodeproperties.valuetype = valueType) : (rootNodeData.nodeproperties = { valuetype: valueType });
        }

        rootNodeData.assetText = { ...(rootNodeData.assetText && { ...rootNodeData.assetText }), secondary: element?.textContent };
        rootNodeData.tempText = { ...(rootNodeData.assetText && { ...rootNodeData.assetText }), secondary: tempText };
    }
};

MultiCellOptionNode.prototype.microchartData = function (nodeData, name, rootNodeData) {
    let element = this.parentNode.querySelector("[name='microchartNode']");
    if (element)
        nodeData[name] = {
            type: "text",
            value: element.textContent,
            ...DiagramCreateUtil.getTextProps(element),
            contenttype: element.dataset.contentType || "microchart",
            ...(element.dataset.microStyle && { microStyle: element.dataset.microStyle }),
        };
};

MultiCellOptionNode.prototype.imageData = function (nodeData, name, rootNodeData) {
    let element = this.parentNode.querySelector("[name='" + name + "']");
    if (element) {
        let imageNode = element.querySelector("[name='imageNode']");
        if (imageNode) {
            nodeData[name] = {
                type: "image",
                value: imageNode.src,
                contenttype: "image",
                dataRef: {
                    imageURL: imageNode.src,
                    ...(imageNode.dataset.csstext && { cropStyle: imageNode.dataset.csstext }),
                    ...(imageNode.dataset.style && { cropData: imageNode.dataset.style }),
                },
            };
            rootNodeData.assetText = { ...(rootNodeData.assetText && { ...rootNodeData.assetText }), image: imageNode.src };
        }
    }
};

MultiCellOptionNode.prototype.logoData = function (nodeData, name, rootNodeData) {
    let element = this.parentNode.querySelector("[name='" + name + "']");
    if (element) {
        let imageNode = element.querySelector("[name='logoNode']");
        if (imageNode)
            nodeData[name] = {
                type: "image",
                value: imageNode.src,
                contenttype: "logo",
                dataRef: {
                    imageURL: imageNode.src,
                    ...(imageNode.dataset.csstext && { cropStyle: imageNode.dataset.csstext }),
                    ...(imageNode.dataset.style && { cropData: imageNode.dataset.style }),
                },
                logocontrast: imageNode.parentElement.dataset.logocontrast || false,
            };
        rootNodeData.assetText = { ...(rootNodeData.assetText && { ...rootNodeData.assetText }), logo: imageNode.src };
    }
};

MultiCellOptionNode.prototype.iconData = function (nodeData, name, rootNodeData) {
    let element = this.parentNode.querySelector("[name='" + name + "']");
    if (element) {
        let iconNode = element.querySelector("[name='iconNode']");
        if (iconNode) nodeData[name] = { contenttype: "icon", type: "icon", id: iconNode.getAttribute("iconid"), value: iconNode.getAttribute("iconpath") };
        if (element.dataset.groupid) nodeData[name].groupid = element.dataset.groupid;
        rootNodeData.assetText = { ...(rootNodeData.assetText && { ...rootNodeData.assetText }), icon: nodeData[name] };
    }
};

MultiCellOptionNode.prototype.authorData = function (nodeData, name, rootNodeData) {
    let element = this.parentNode.querySelector("[name='" + name + "']");
    if (element && this.authorStyle) {
        this.authorStyle.getJSONData();
    }
};

MultiCellOptionNode.prototype.imageGridData = function (nodeData, name, rootNodeData) {
    let logolistData = this.gridInstance?.getLogoListData(this.parentNode);
    if (logolistData) nodeData[name] = { value: logolistData, mincount: 1 };
};

MultiCellOptionNode.prototype.numberToggleData = function (nodeData, name, rootNodeData) {
    let data = this.numberToggleStyle.getNumberToggleData(this.mainParent);
    nodeData[name] = data;
};

MultiCellOptionNode.prototype.priorityData = function (nodeData, name, rootNodeData) {
    let priorityNodeHolder = this.mainParent.querySelector("[name='priorityNodeHolder']");
    if (priorityNodeHolder) {
        nodeData[name] = {
            type: priorityNodeHolder.dataset.type,
            contenttype: priorityNodeHolder.dataset.contenttype,
            value: priorityNodeHolder.dataset.priority,
        };
    }
};

MultiCellOptionNode.prototype.updateNodeAttributes = function (rowIndexP, colIndexP) {
    this.index = typeof rowIndexP !== "undefined" && typeof colIndexP !== "undefined" ? `${rowIndexP},${colIndexP}` : this.index;
    if (!this.parentNode) return;
    this.parentNode.setAttribute("data-index", this.index);
    this.parentNode.setAttribute("id", this.parentNode.getAttribute("name") + this.index);
    this.parentNode.parentElement.setAttribute("data-index", this.index);
    this.parentNode.parentElement.setAttribute("id", this.parentNode.parentElement.getAttribute("name") + this.index);

    let [rowIndex, colIndex] = this.parentNode.dataset.index.split(",");
    if (!rowIndex || !colIndex) {
        if (this.index != null) PlainDiagramNodeBase.prototype.updateNodeAttributes.call(this, this.index);
        return;
    }
    let allNodes = this.parentNode.querySelectorAll("[data-index]");
    allNodes.forEach((nodeItem) => {
        let name = nodeItem.getAttribute("name") || nodeItem.getAttribute("data-id");
        nodeItem.setAttribute("data-index", this.index);
        if (name) nodeItem.setAttribute("id", name + this.index);
        switch (name) {
            case "seqText":
                let content = DiagramUtils.getSeqMoodStyle(this.globalMoodData ? this.globalMoodData.seqnumproperties : null, this.properties, "sequencenumber", Number(rowIndex), this.diagramParent.dataset.nodecount);
                nodeItem.innerText = content;
                break;
            case "numberNode":
                let valueTextObj = DiagramUtils.getObjectFromName(this.arrSupportedNodes, "valueTitleHolder");
                if (valueTextObj && valueTextObj.scale) {
                    let scale = valueTextObj.scale.split(",")[0];
                    let scaledSize = nodeItem.parentElement.parentElement.offsetWidth * parseFloat(scale);
                    nodeItem.style.fontSize = scaledSize - 8 + "px";
                    let maxHeight = scaledSize + "px";
                    nodeItem.style.maxHeight = maxHeight;
                    nodeItem.style.height = maxHeight;
                    nodeItem.style.minHeight = maxHeight;
                    nodeItem.parentElement.style.maxHeight = maxHeight;
                    nodeItem.parentElement.style.height = maxHeight;
                    nodeItem.parentElement.style.minHeight = maxHeight;
                }
                break;
            default:
                break;
        }
    });

    if (this.contentBG) DiagramNodeUtils.applyNodeStyleClipPath(this.contentBG.id, this.diagramParent, colIndex);

    this.updateCheckListNode();

    if (this.arrTintArray && this.arrTintArray.length > 0) {
        DiagramUtils.setCustomItemColor(this.parentNode.parentElement, this.arrTintArray, colIndex, colIndex + 1);
        let nodeNonlinear = this.diagramParent.querySelector("[name='nodeNonlinearMainParent'][data-index='" + this.index + "']");
        if (nodeNonlinear) DiagramUtils.setCustomItemColor(nodeNonlinear, this.arrTintArray, colIndex, colIndex + 1);
    }
};

MultiCellOptionNode.prototype.addMicroChartEventIfneed = function (eventManagerXY) {
    let microChartHolder = this.mainParent.querySelector("[name='microChartHolder']");
    if (microChartHolder && microChartHolder.querySelector(".clsRatingMicro")) {
        // clsRatingMicro
        let microchartNodeCircle = microChartHolder.querySelectorAll("[id*='clsCircleBG']");
        if (microchartNodeCircle && microchartNodeCircle.length > 0) {
            microchartNodeCircle.forEach((element) => {
                eventManagerXY.addEvent(element, "click", this.microChartClickEvent);
            });
        }
    }
};

MultiCellOptionNode.prototype.getTextContent = (element) => {
    return element.innerHTML && element.innerHTML != "" ? TextHighLightUtils.highlightToString(element.innerHTML) : "";
};

MultiCellOptionNode.prototype.getUlTextContent = (element) => {
    return element.innerHTML && element.innerHTML != "" ? TextHighLightUtils.highlightToString(element.innerHTML) : "";
};

// Function update the text lineHeight/letterSpacing from AETextStyleChangeOpration
MultiCellOptionNode.prototype.updateLineProperties = function (type, value, targetNode) {
    let count = 0;
    let arrTargetNames = ["secondaryText", "primaryText"];
    let nodeToUpdate = checkForNodeMatch(targetNode);
    if (nodeToUpdate) nodeToUpdate.dataset[type == "letterspace" ? "letterspacing" : type] = value + "em";
    console.log(nodeToUpdate);

    function checkForNodeMatch(targetNode) {
        count++;
        if (arrTargetNames.includes(targetNode.getAttribute("name"))) return targetNode;
        else if (count < 10) return checkForNodeMatch(targetNode.parentElement);
        else return null;
    }
};

MultiCellOptionNode.prototype.needAssetUpdate = function (imageHolder, nodeData) {
    let assetText = nodeData?.assetText?.primary || nodeData?.assetText?.secondary || this.objData?.assetText?.primary || this.objData?.assetText?.secondary;
    let isPlainText = nodeData?.assetText || this.objData.assetText;
    if (!assetText && typeof isPlainText == "string") assetText = isPlainText;
    let assetNode = imageHolder.querySelector("[data-id='logoNode']") || imageHolder.querySelector("[data-id='imageNode']") || imageHolder.querySelector("[data-id='iconNode']");
    if (assetNode && assetNode.parentElement && nodeData?.needAssetUpdate && assetText) {
        nodeData.needAssetUpdate = false;
        assetNode.parentElement.setAttribute("data-node-graphic-text", assetText);
        let type = assetNode.parentElement.dataset.nodeContentType;
        DiagramUtils.searchAIcall(type, this.objData, assetText, this.properties, this.globalMoodData, assetNode, this.index, this.searchIconCallBack, appBaseURL, this.appStaticURL);
    }
};

MultiCellOptionNode.prototype.updateTextIfNeed = function (newData) {
    if (newData.nodename && (newData.nodename == "currency" || newData.nodename == "number" || newData.nodename == "date")) return;
    let isPrimaryUpdate = false;
    let isSecondaryUpdate = false;
    let isImageUpdate = false;
    let isLogoUpdate = false;
    let isIconUpdate = false;

    if (this.objData?.assetText?.primary) {
        let textHolder = DiagramUtils.getChildObjectByName(newData, "titleHolder");
        if (!textHolder) textHolder = DiagramUtils.getChildObjectByName(newData, "subTitleHolder");
        if (textHolder?.hasOwnProperty("value")) {
            textHolder.value = this.objData.tempText?.primary || this.objData.assetText.primary;
            isPrimaryUpdate = true;
            this.objData.assetText.primary = "";
        }
        if (textHolder?.items && !this.objData?.assetText?.secondary) {
            textHolder.items = [{ type: "text", value: this.objData.tempText?.primary || this.objData.assetText.primary, index: 0, content: null }];
            isSecondaryUpdate = true;
            this.objData.assetText.primary = "";
        }
    }

    if (this.objData?.assetText?.secondary) {
        let textHolder = DiagramUtils.getChildObjectByName(newData, "subTitleHolder");
        if (!textHolder && !isPrimaryUpdate) textHolder = DiagramUtils.getChildObjectByName(newData, "titleHolder");
        if (textHolder?.hasOwnProperty("value")) {
            isPrimaryUpdate = true;
            textHolder.value = this.objData.tempText?.secondary || this.objData.assetText.secondary;
            this.objData.assetText.secondary = "";
        }
        if (textHolder?.items) {
            textHolder.items = [{ type: "text", value: this.objData.tempText?.secondary || this.objData.assetText.secondary, index: 0, content: null }];
            isSecondaryUpdate = true;
            this.objData.assetText.secondary = "";
        }
    }

    if (this.objData?.assetText?.image) {
        let imageHolder = DiagramUtils.getChildObjectByName(newData, "imageHolder");
        if (imageHolder) {
            imageHolder.value = this.objData.assetText.image;
            this.objData.assetText.image = "";
            isImageUpdate = true;
        }
    }

    if (this.objData?.assetText?.logo) {
        let logoHolder = DiagramUtils.getChildObjectByName(newData, "imageSecHolder");
        if (logoHolder) {
            logoHolder.value = this.objData.assetText.logo;
            isLogoUpdate = true;
            this.objData.assetText.logo = "";
        }
    }

    if (this.objData?.assetText?.icon) {
        let iconHolder = DiagramUtils.getChildObjectByName(newData, "iconHolder");
        if (iconHolder) {
            iconHolder.value = this.objData.assetText.icon.value;
            iconHolder.id = this.objData.assetText.icon.id;
        }
    }

    if (this.objData?.assetText?.primary && !isIconUpdate) {
        let iconHolder = DiagramUtils.getChildObjectByName(newData, "iconHolder");
        if (iconHolder) {
            iconHolder.assetText = this.objData.assetText.primary;
            iconHolder.needAssetUpdate = true;
            isIconUpdate = true;
        }
    }

    if (this.objData?.assetText?.secondary && !isIconUpdate) {
        let iconHolder = DiagramUtils.getChildObjectByName(newData, "iconHolder");
        if (iconHolder) {
            iconHolder.assetText = this.objData.assetText.secondary;
            iconHolder.needAssetUpdate = true;
            isIconUpdate = true;
        }
    }

    if (this.objData?.assetText?.primary && !isImageUpdate) {
        let imageHolder = DiagramUtils.getChildObjectByName(newData, "imageHolder");
        if (imageHolder) {
            imageHolder.assetText = this.objData.assetText.primary;
            imageHolder.needAssetUpdate = true;
            isImageUpdate = true;
        }
    }

    if (this.objData?.assetText?.secondary && !isImageUpdate) {
        let imageHolder = DiagramUtils.getChildObjectByName(newData, "imageHolder");
        if (imageHolder) {
            imageHolder.assetText = this.objData.assetText.secondary;
            imageHolder.needAssetUpdate = true;
            isImageUpdate = true;
        }
    }

    if (this.objData?.assetText?.primary && !isLogoUpdate) {
        let logoHolder = DiagramUtils.getChildObjectByName(newData, "imageSecHolder");
        if (logoHolder) {
            logoHolder.assetText = this.objData.assetText.primary;
            logoHolder.needAssetUpdate = true;
            isLogoUpdate = true;
        }
    }

    if (this.objData?.assetText?.secondary && !isLogoUpdate) {
        let logoHolder = DiagramUtils.getChildObjectByName(newData, "imageSecHolder");
        if (logoHolder) {
            logoHolder.assetText = this.objData.assetText.secondary;
            logoHolder.needAssetUpdate = true;
            isLogoUpdate = true;
        }
    }

    if (this.objData?.assetText?.image) {
        let logoHolder = DiagramUtils.getChildObjectByName(newData, "imageSecHolder");
        if (logoHolder) {
            logoHolder.value = this.objData.assetText.image;
            isLogoUpdate = true;
            this.objData.assetText.image = "";
        }
    }

    if (this.objData?.assetText?.logo) {
        let imageHolder = DiagramUtils.getChildObjectByName(newData, "imageHolder");
        if (imageHolder) {
            imageHolder.value = this.objData.assetText.logo;
            this.objData.assetText.logo = "";
            isImageUpdate = true;
        }
    }
};

MultiCellOptionNode.prototype.updateAssetExtraText = function (obj) {
    let searchText = obj.value?.trim(0, 16);
    let allowSearch = searchText?.trim() != "";
    if (!allowSearch) return;
    let assetNode = this.mainParent.querySelector("[data-id='logoNode']") || this.mainParent.querySelector("[data-id='imageNode']") || this.mainParent.querySelector("[data-id='iconNode']");
    let contenttype = assetNode?.parentElement?.dataset?.nodeContentType || "";
    assetNode?.parentElement?.setAttribute("data-node-graphic-text", searchText);
    DiagramUtils.searchAIcall(contenttype, this.objData, searchText, this.properties, this.globalMoodData, assetNode, 0, this.apiSearchIconCallBack.bind(this), this.dInst.serverUrl, this.appStaticURL);
};

MultiCellOptionNode.prototype.apiSearchIconCallBack = function (content, type, index, id) {
    switch (type) {
        case "icon":
            let nodeData = {
                type: "icon",
                value: content.value,
                id: content.id,
                contenttype: "icon",
            };
            this.updateContentData?.(nodeData, type, id);
            DiagramCreateUtil.updateManifest(content, this.dInst.manifestUpdater, this.appStaticURL);
            break;
        case "image":
            let imgNodeData = {
                type: "image",
                value: content.value,
                id: content.id,
                contenttype: "icon",
            };
            this.updateContentData?.(imgNodeData, type, id);
            DiagramCreateUtil.updateManifest(content, this.dInst.manifestUpdater, this.appStaticURL);
            break;
        case "logo":
            let logoNodeData = {
                type: "image",
                value: content.value,
                id: content.id,
                contenttype: "logo",
            };
            this.updateContentData?.(logoNodeData, type, id);
            break;
    }
};

MultiCellOptionNode.prototype.updateLogoContrast = function (obj, target) {
    let logoNode = target.querySelector("[name='logoNode']");
    if (this.gridInstance && logoNode) {
        this.gridInstance.changeLogoGridContrast(logoNode, obj.selected, target.dataset.imagegridIndex);
    } else if (logoNode) {
        logoNode.classList.add(!obj.selected ? "logoBrightnessDiagramUnset" : "logoBrightnessDiagram");
        logoNode.classList.remove(!obj.selected ? "logoBrightnessDiagram" : "logoBrightnessDiagramUnset");
        logoNode.parentElement.setAttribute("data-logocontrast", obj.selected);
    }
};

function MultiCellOptionVerticalNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    MultiCellOptionNode.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
}

MultiCellOptionVerticalNode.prototype = Object.create(MultiCellOptionNode.prototype);
MultiCellOptionVerticalNode.prototype.constructor = MultiCellOptionVerticalNode;

/**
 * Author:    Bala Krishnan K.
 * Created:   Wed 21 July 2022
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function MultiCellGroupNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    // PlainDiagramNode.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
    this.index = index;
    this.objData = objData;
    this.eventManager = eventManager;
    this.parentID = parentID;
    this.mainParent = mainParent;
    this.diagramParent = diagramParent;
    this.bgDeviceDiv = null;
    this.objStyleData = objStyleData || {};
    this.appStaticURL = appStaticURL;
    this.properties = properties;
    this.diagramProps = diagramProps;
    this.arrMultiCellNode = [];
}

// MultiCellGroupNode.prototype = Object.create(PlainDiagramNode.prototype);
MultiCellGroupNode.prototype.constructor = MultiCellGroupNode;

MultiCellGroupNode.prototype.initCreation = function (isLastNode = false) {
    this.parentNode = this.createGroupParent(this.mainParent);
    // this.groupNode = this.parentNode;
    this.createGroupBg(this.parentNode);
    if (this.objData.cells) {
        let cellCount = this.objData.cells.length;
        for (let j = 0; j < cellCount; j++) {
            let cellObj = this.objData.cells[j];
            this.nodeInstance(j, cellCount, cellObj, this.parentNode);
        }
    }
};

MultiCellGroupNode.prototype.reCreation = function (parentNode) {
    this.parentNode = parentNode;
    this.nodeGroup = parentNode;
    let arrMultiCells = parentNode.querySelectorAll("[name='nodeMainParent']");
    arrMultiCells.forEach((element, index) => {
        // this.properties = this.objData.properties
        this.nodeInstance(index, arrMultiCells.length, {}, parentNode, element);
    });
    this.objData = this.getJSONData();
    this.updateNodeAttributes(this.index);
};

MultiCellGroupNode.prototype.createGroupParent = function (mainParent) {
    let nodeParentMain = document.createElement("div");
    DiagramNodeUtils.assignAttributes(nodeParentMain, {
        class: "clsMultiGroupNode",
        name: "multiGroupNode",
        id: "multiGroupNode" + this.index,
        "data-index": this.index,
        "data-type": "multiGroupNode",
    });

    mainParent.appendChild(nodeParentMain);
    this.nodeGroup = nodeParentMain;
    return nodeParentMain;
};

MultiCellGroupNode.prototype.createGroupBg = function (mainParent) {
    let nodeParentMain = document.createElement("div");
    DiagramNodeUtils.assignAttributes(nodeParentMain, {
        class: "clsMultiGroupBackground moodanimation",
        name: "multiGroupBackground",
        id: "multiGroupBackground" + this.index,
        "data-index": this.index,
        "data-animation": "nodebg",
    });
    mainParent.appendChild(nodeParentMain);
    return nodeParentMain;
};

MultiCellGroupNode.prototype.nodeInstance = function (i, nodeCount, row, pattenDiv, parentNode = null, isInsert = false) {
    let nodeItem = new window[this.diagramProps.nodeclassName](
        pattenDiv,
        row.properties ? { ...this.properties, ...row.properties } : this.properties,
        row,
        this.eventManager,
        i,
        "",
        this.objStyleData,
        this.appStaticURL,
        row.typeproperties ? { ...this.diagramProps, ...row.typeproperties } : this.diagramProps,
        this.diagramParent
    );
    nodeItem.moodData = this.moodData;
    nodeItem.moodName = this.moodName;
    nodeItem.updateCallBack = this.updateCallBack;
    nodeItem.searchIconCallBack = this.searchIconCallBack;

    nodeItem.bgDeviceDiv = this.bgDeviceDiv;
    nodeItem.globalMoodData = this.globalMoodData;
    nodeItem.arrTintArray = this.arrTintArray;
    nodeItem.manifestUpdater = this.manifestUpdater;
    nodeItem.appStaticURL = this.appStaticURL;
    if (parentNode) nodeItem.reCreation(parentNode);
    else if (isInsert) nodeItem.initCreation(i);
    else nodeItem.initCreation(i == nodeCount - 1);
    if (isInsert) {
        if (this.arrMultiCellNode.length > i) {
            this.arrMultiCellNode.splice(i, 0, nodeItem);
        } else {
            this.arrMultiCellNode.push(nodeItem);
        }
    } else this.arrMultiCellNode.push(nodeItem);
    return nodeItem;
};

MultiCellGroupNode.prototype.getJSONData = function () {
    let nodeData = {};
    nodeData.rowProperties = {};
    nodeData.cells = [];
    this.arrMultiCellNode.forEach((element) => {
        nodeData.cells.push(element.getJSONData());
    });
    return nodeData;
};

MultiCellGroupNode.prototype.updateCheckListNode = function (index) {
    this.arrMultiCellNode[index].updateCheckListNode();
    this.objData = this.getJSONData();
};

MultiCellGroupNode.prototype.addNode = function (index) {
    let nodeData = JSON.parse(JSON.stringify(this.arrMultiCellNode[index].objData));
    // this.arrMultiCellNode.splice(parseInt(index) + 1, 0, nodeData);
    this.nodeInstance(parseInt(index) + 1, this.arrMultiCellNode.length, nodeData, this.parentNode, null, true);
    this.updateNodeAttributes(index);
};

MultiCellGroupNode.prototype.updateNodeAttributes = function (index) {
    this.index = index;
    this.parentNode.setAttribute("data-index", this.index);
    // this.parentNode.setAttribute("id", this.parentNode.getAttribute("name") + "-" + this.index);
    this.parentNode.setAttribute("id", this.parentNode.getAttribute("name") + this.index);
    this.arrMultiCellNode.forEach((element, multiCellIndex) => {
        element.updateNodeAttributes(index, multiCellIndex);
    });
};

// MultiCellGroupNode.prototype.updateNodeData = function (nodeData, type, index, parentId) {
//     let target = this.parentNode.querySelector("[id=" + parentId + "]");
//     let arrIndex = DiagramUtils.getMultiContentIndex(target.dataset.index);
//     if (this.arrMultiCellNode && this.arrMultiCellNode.length > arrIndex[0]) {
//         this.arrMultiCellNode[arrIndex[0]].updateContentData(nodeData, type, parentId);
//     }
// };

MultiCellGroupNode.prototype.updateOnFocusOut = function () {
    this.arrMultiCellNode.forEach((element) => {
        element?.updateTextSingleLineHeight();
    });
};

MultiCellGroupNode.prototype.updateImageLogoFrames = function () {
    if (!this.parentNode) return;
    let allImgNodes = this.parentNode.querySelectorAll("img[data-id='imageNode'],img[data-id='logoNode']");

    allImgNodes.forEach((nodeItem) => {
        let contentType = nodeItem.parentElement.dataset.contentType;
        let scale = nodeItem.parentElement.getAttribute("data-scale") || 1;
        CommonImageUtils.updateImageBounds(nodeItem, { isimagefit: this.properties.isimagefit, islogofit: contentType == "logo", contenttype: contentType }, scale);
    });
};

/**
 * Author:    Krishna
 * Created:   Fri 18 Dec 2020
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function CustomContentOptionNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    PlainDiagramNode.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
}

CustomContentOptionNode.prototype = Object.create(PlainDiagramNode.prototype);
CustomContentOptionNode.prototype.constructor = CustomContentOptionNode;

CustomContentOptionNode.prototype.createNodes = function (nodeObj, nodeParent, objSecData = null) {
    let name = nodeObj.name;
    let holdertype = !this.isHolderTypePresent ? "primary" : nodeObj.holdertype || "secondary";
    let content = null;

    if (nodeParent && nodeParent.id && nodeParent.id.includes("contentNode")) {
        let contenttype = this.diagramParent.getAttribute("data-contenttype") || "icon";
        this.setHolderType(contenttype, "");
        let contentholdertype = this.diagramParent.getAttribute("data-contentholdertype") || "iconHolder";
        nodeParent.style.setProperty("display", contenttype == "none" ? "none" : "flex", "important");
        if (this.diagramParent) this.diagramParent.setAttribute("data-nomargin", contenttype == "none" ? "true" : "false");
        if (contentholdertype && name.includes(contentholdertype)) {
            if (nodeObj.nodeClass) this.parentNode.parentElement.className = this.parentNode.parentElement.className + " " + nodeObj.nodeClass;
            content = this.getContentDataBasedOnSelectedHolder(name, contenttype, this.objData, nodeObj.islogo, nodeParent);
        } else return;
    }
    // else content = this.getContentDataBasedOnHolder(name, holdertype, this.objData, nodeObj.islogo, nodeParent);

    if (objSecData) content = objSecData;
    if (!content) content = {};
    switch (name) {
        case "titleHolder":
            return this.createTitle(nodeParent, this.objData.primarytext, nodeObj);
        case "contentNode":
            return this.createContentNode(nodeParent, nodeObj);
        case "secContentNode":
            return this.createSecContentNode(nodeParent, nodeObj);
        case "moodNode":
            return this.createMoodNode(nodeParent, nodeObj);
        case "subTitleHolder":
            return this.createSubTitle(nodeParent, nodeObj);
        case "seqTitleHolder":
            return this.createSeqTitle(nodeParent, nodeObj);
        case "checkListHolder":
            return this.createCheckListNode(nodeParent, nodeObj, content);
        case "checkListSecHolder":
            return this.createCheckListSecNode(nodeParent, nodeObj, content);
        case "secSubContentNode":
            return this.createSecSubContentNode(nodeParent, nodeObj);
        case "valueTitleHolder":
            this.isHolderTypePresent = true;
            return this.createValueTitle(nodeParent, content, holdertype, nodeObj);
        case "textTitleHolder":
            this.isHolderTypePresent = true;
            return this.createTextTitle(nodeParent, content, holdertype, nodeObj);
        case "buttonTitleHolder":
            this.isHolderTypePresent = true;
            return this.createButtonTitleHolder(nodeParent, content, holdertype, nodeObj);
        case "imageHolder":
            this.isHolderTypePresent = true;
            return this.createImageNode(nodeParent, content, name, holdertype, nodeObj);
        case "imageSecHolder":
            this.isHolderTypePresent = true;
            return this.createImageNode(nodeParent, content, name, holdertype, nodeObj);
        case "iconHolder":
        case "iconSecHolder":
            this.isHolderTypePresent = true;
            return this.createIconNode(nodeParent, content, name, holdertype, nodeObj);
        case "microChartHolder":
            this.isHolderTypePresent = true;
            return this.createMicroNode(nodeParent, content, name, holdertype, nodeObj);
        case "shapeHolder":
            return this.createShapeNode(nodeParent, nodeObj, name, nodeObj);
        case "staticTextHolder":
            return this.createStaticContent(nodeParent, nodeObj);
        default:
            break;
    }
};

CustomContentOptionNode.prototype.onTextChangeUpdate = function (nodeToUpdate, parentNode, nodeGroup) {
    //console.log("onTextChangeUpdate");

    if (!nodeToUpdate) return;
    let textNode = nodeToUpdate.querySelector("[data-name='text']");
    if (textNode) {
        textNode.style.removeProperty("max-height");
        textNode.parentElement.style.removeProperty("max-height");
    }
    let parentStyle = window.getComputedStyle(nodeGroup, null);
    let nodeParentStyle = window.getComputedStyle(parentNode, null);
    let paddingTop = parentStyle?.getPropertyValue("padding-top")?.replace("px", "");
    let paddingBottom = parentStyle?.getPropertyValue("padding-bottom")?.replace("px", "");
    let nodePaddingTop = nodeParentStyle?.getPropertyValue("padding-top")?.replace("px", "");
    let nodePaddingBottom = nodeParentStyle?.getPropertyValue("padding-bottom")?.replace("px", "");

    let parentHeight = parentNode.offsetHeight - (parseFloat(nodePaddingTop) + parseFloat(nodePaddingBottom));
    let contentHeight = nodeGroup.offsetHeight - (parseFloat(paddingTop) + parseFloat(paddingBottom));
    if (parentHeight == contentHeight) {
        let secContent = parentNode.querySelector("[name='secContentNode']");
        nodeGroup = secContent || nodeGroup;
        contentHeight = nodeGroup.offsetHeight;
    }
    let heightDiff = contentHeight - parentHeight;
    if (contentHeight > parentHeight) {
        for (let i1 = 0; i1 < this.arrAllowResize.length; i1++) {
            let nodeName = this.arrAllowResize[i1];
            let nodeToResize = parentNode.querySelector("[name='" + nodeName + "']");
            if (nodeToResize) {
                let computedStype = window.getComputedStyle(nodeToResize);
                let nodeHeight = parseInt(computedStype.height.replace("px", ""));
                let minHeight = parseInt(computedStype.minHeight.replace("px", ""));
                nodeToResize.style.setProperty("max-height", Math.max(minHeight, nodeHeight - heightDiff) + "px");
                contentHeight = nodeGroup.offsetHeight;
                heightDiff = contentHeight - parentHeight;
                if (contentHeight <= parentHeight) break;
            }
        }

        contentHeight = nodeGroup.offsetHeight;
        heightDiff = contentHeight - parentHeight;
        if (contentHeight > parentHeight) {
            let nodeHeight = nodeToUpdate.offsetHeight;
            let maxHeight = nodeHeight - heightDiff;
            nodeToUpdate.style.setProperty("max-height", maxHeight + "px");
        }
    }
    contentHeight = nodeGroup.offsetHeight;
    heightDiff = contentHeight - parentHeight;

    if (contentHeight > parentHeight) {
        let nodeHeight = nodeToUpdate.offsetHeight;
        let maxHeight = nodeHeight - heightDiff;
        nodeToUpdate.style.setProperty("max-height", maxHeight + "px");
    }
    let isAutoResize = DiagramResizeUtils.isAutoFontResize(textNode, this.properties.fontresize);
    // if (isAutoResize && textNode.dataset?.maxNode == "true") {
    if (isAutoResize) {
        // this.mainParent.style.setProperty("--titleHolderMH", "unset");
        // this.mainParent.style.setProperty("--subtitleHolderMH", "unset");
        DiagramResizeUtils.doFontResize(textNode, nodeGroup, parentNode, this.fontClassList, paddingTop, paddingBottom, nodePaddingTop, nodePaddingBottom);
    } else if (textNode) this.onTextUpdate(textNode);
};

/**
 * Author:    Saravanan G
 * Created:   13.12.2019
 *
 * (c) Copyright by Gs.
 **/

("use strict");

function PositionableDiagramNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    VerticalDiagramNode.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
}

PositionableDiagramNode.prototype = Object.create(VerticalDiagramNode.prototype);
PositionableDiagramNode.prototype.constructor = PositionableDiagramNode;

PositionableDiagramNode.prototype.createXYNodeParent = function (parentPlotDiagramNode) {
    let nodeParentMain = document.createElement("div");
    nodeParentMain.className = "accent" + (this.index + 1) + " clsMultiColorParent clsNodeParentMain " + this.parentStyle + " " + this.globalstyle;
    
    if (this.objData.position) {
        nodeParentMain.style.left = this.objData.position.left+"px";
        nodeParentMain.style.top = this.objData.position.top+"px";
        nodeParentMain.style.width = this.objData.position.width+"px";
        nodeParentMain.style.height = this.objData.position.height+"px";
    }
    
    if (this.diagramProps && this.diagramProps.grid && this.diagramProps.grid.type && this.diagramProps.grid.type == "custom") nodeParentMain.style.setProperty("grid-area", "cell" + (this.index + 1));
    nodeParentMain.setAttribute("name", "nodeMainParent");
    nodeParentMain.setAttribute("data-index", this.index);
    nodeParentMain.setAttribute("id", "nodeMainParent" + this.index);
    if (this.bgColorNode == "node" || this.bgColorNode == "group") {
        nodeParentMain.classList.add("moodanimation");
        nodeParentMain.setAttribute("data-animation", "nodebg");
    }
    parentPlotDiagramNode.insertChildAtIndex(nodeParentMain, this.index + 1);

    let nodeSubParent = document.createElement("div");
    DiagramNodeUtils.assignAttributes(nodeSubParent, {
        class: "clsNodeParent",
        name: "nodeparent",
        id: "nodeparent" + this.index,
        "data-parent-id": this.parentID,
        "data-index": this.index + "",
    });
    nodeParentMain.appendChild(nodeSubParent);
    if (this.bgColorNode == "node") {
        nodeSubParent.classList.add(this.bgColor);
    }

    if (this.borderNode.includes("node")) {
        nodeSubParent.classList.add(this.borderColor);
    }
    return nodeSubParent;
};

PositionableDiagramNode.prototype.getJSONData = function () {
    let nodeData = {};
    let primaryTextData = this.getPrimaryTextData();
    nodeData.primarytext = primaryTextData;
    nodeData.secondarytext = this.getListData();
    nodeData.content = this.getContentData("primary");
    nodeData.nodeproperties = this.getNodeProperties();
    nodeData.rect = this.getNodeRect();
    // Other Properties.
    if (this.parentNode) {
        nodeData.position = this.getNodeRect();
        nodeData.highlightdata = this.getHighlightData();
        nodeData.link = this.parentNode.dataset.navigateToSlideOnClick;
        let extraLinkDiv = this.parentNode.querySelector("[data-linkid]");
        if (extraLinkDiv) nodeData.extralink = { value: extraLinkDiv.parentElement.dataset.navigateToSlideOnClick, id: extraLinkDiv.getAttribute("id") };
    }

    return nodeData;
};

PositionableDiagramNode.prototype.getNodeRect = function () {
    if (this.parentNode == null || this.parentNode.parentElement == null) return null;
    let x = this.parentNode.parentElement.dataset.x || this.parentNode.parentElement.offsetLeft;
    let y = this.parentNode.parentElement.dataset.y || this.parentNode.parentElement.offsetTop;
    let width = this.parentNode.parentElement.dataset.width || this.parentNode.parentElement.clientWidth || 200;
    let height = this.parentNode.parentElement.dataset.height || this.parentNode.parentElement.clientHeight || 200;
    return { x: x, y: y, width: width, height: height, top: y, left: x };
};
/**
 * Author:    Krishna
 * Created:   28 Jul 2021
 *
 * (c) Copyright by Gs.
 **/

("use strict");

function MultiContentTableNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent, dInst) {
    MultiCellOptionNode.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
    this.arrTextNodes = ["titleHolder", "subTitleHolder"];
    this.nodeParent = mainParent;
    this.dInst = dInst;
    this.recreateImageGridInstance();
    this.recreateNumberToggleInstance();
    this.checkForHighlight(objData);
}

MultiContentTableNode.prototype = Object.create(MultiCellOptionNode.prototype);
MultiContentTableNode.prototype.constructor = MultiContentTableNode;

MultiContentTableNode.prototype.addClassName = function (className) {
    if (!this.mainParent.classList.contains(className)) this.mainParent.classList.add(className);
};

MultiContentTableNode.prototype.getJSONData = function () {
    let nodeData = MultiCellOptionNode.prototype.getJSONData.call(this);
    let width = this.mainParent?.firstElementChild?.clientWidth != 0 ? this.mainParent.firstElementChild.clientWidth : this.objData?.cellproperties?.width || "auto";
    let height = this.mainParent?.firstElementChild?.clientHeight != 0 ? this.mainParent.firstElementChild.clientHeight : this.objData?.cellproperties?.height || 70;
    nodeData.cellproperties = { width: width, height: height };
    let highlight = this.mainParent.classList.contains("row-highlightEnabled") ? "row" : "";
    highlight = this.mainParent.classList.contains("col-highlightEnabled") ? (highlight != "" ? highlight + ",col" : "col") : highlight;
    if (highlight != "") nodeData.cellproperties.highlight = highlight;
    nodeData.value = nodeData.assetText?.primary || nodeData.assetText?.secondary || "";

    let nodeParent = this.nodeParent.firstElementChild;
    nodeData.cellproperties.minwidth = parseInt(nodeParent.style.minWidth) || nodeParent.style.minWidth;
    nodeData.cellproperties.minheight = parseInt(nodeParent.style.minHeight) || nodeParent.style.minHeight;

    if (this.mainParent?.firstElementChild?.dataset?.nodestyleclass) nodeData.nodeStyleClass = this.mainParent.firstElementChild.dataset.nodestyleclass;
    if (this.mainParent?.firstElementChild?.dataset?.navigateToSlideOnClick) nodeData.navigateToSlideOnClick = this.mainParent.firstElementChild.dataset.navigateToSlideOnClick;
    return nodeData;
};

MultiContentTableNode.prototype.setFontStyle = function (obj) {
    let multiTextParent = this.parentNode.querySelector("[id='" + obj.targetid + "']") || this.parentNode.querySelector("[name='primaryText']") || this.parentNode.querySelector("[name='secondaryText']");
    if (!multiTextParent) return;
    multiTextParent = multiTextParent.id.includes("secondaryTextItem") ? multiTextParent.parentElement : multiTextParent;
    if (!multiTextParent) return;
    switch (obj.property) {
        case "textstyle":
            TextHighLightUtils.removeFontClassName(multiTextParent, this.fontClassList);
            if (obj.value.includes("auto")) multiTextParent.classList.add(multiTextParent.getAttribute("original-fontclass"));
            else multiTextParent.classList.add(obj.value);
            multiTextParent.setAttribute("data-fontresize", obj.value);
            multiTextParent.style.removeProperty("font-size");
            break;
        case "fontsize":
            // TextHighLightUtils.removeFontClassName(multiTextParent, this.fontClassList);
            multiTextParent.dataset.textsize = obj.value;
            multiTextParent.style.fontSize = obj.value == "reset" ? "" : obj.value;
            if (obj.value == "reset") multiTextParent.classList.add(multiTextParent.getAttribute("original-fontclass"));
            break;
        case "textopacity":
            multiTextParent.dataset.textopacity = obj.value;
            multiTextParent.style.opacity = obj.value;
            break;
        case "textcase":
            multiTextParent.dataset.texttransform = obj.value;
            multiTextParent.style.textTransform = obj.value;
            break;
        case "fontbold":
            multiTextParent.dataset.textbold = obj.selected;
            multiTextParent.style.fontWeight = obj.selected ? "700" : "unset";
            break;
        case "fontitalic":
            let fontStyle = obj.selected ? "italic" : "normal";
            multiTextParent.style.fontStyle = fontStyle;
            multiTextParent.setAttribute("data-fontitalic", fontStyle);
            break;
        case "textalign":
            multiTextParent.dataset.textalign = obj.value;
            multiTextParent.style.textAlign = obj.value;
            if (multiTextParent.firstElementChild) {
                multiTextParent.firstElementChild.dataset.textalign = obj.value;
                multiTextParent.firstElementChild.style.textAlign = obj.value;
            }
            break;
        case "textcolor":
            multiTextParent.dataset.textcolor = obj.value;
            multiTextParent.style.setProperty("color", obj.value, "important");
            break;
        case "colorreset":
            multiTextParent.dataset.textcolor = "";
            multiTextParent.style.removeProperty("color");
            break;
    }
    this.updateTextSingleLineHeight();
};

MultiContentTableNode.prototype.resetAllTextProps = function (obj) {
    let multiTextParent = this.parentNode.querySelector("[id='" + obj.targetid + "']") || this.parentNode.querySelector("[name='primaryText']") || this.parentNode.querySelector("[name='secondaryText']");
    multiTextParent = multiTextParent.id.includes("secondaryTextItem") ? multiTextParent.parentElement : multiTextParent;
    if (!multiTextParent) return;

    multiTextParent.style.removeProperty("font-size");
    multiTextParent.style.removeProperty("opacity");
    multiTextParent.style.removeProperty("font-weight");
    multiTextParent.style.removeProperty("text-align");
    multiTextParent.style.removeProperty("text-transform");
    multiTextParent.style.removeProperty("line-height");
    multiTextParent.style.removeProperty("letter-spacing");
    multiTextParent.classList.add(multiTextParent.getAttribute("original-fontclass"));

    let childern = Array.from(multiTextParent.children);
    childern?.forEach?.((child) => {
        child.style.removeProperty("line-height");
        child.style.removeProperty("letter-spacing");
    });
};

MultiContentTableNode.prototype.changeContentType = function (obj, arrIndex, isUndoRedo = false) {
    this.mainParent.innerHTML = "";
    let newData = JSON.parse(JSON.stringify(obj.nodeData || obj.data));
    if (!newData.nodename) newData.nodename = obj.value;
    let textUpdate = newData.hasOwnProperty("textupdate") ? newData.textupdate : true;
    if (!isUndoRedo && textUpdate) this.updateTextIfNeed(newData);
    if (newData.nodename == "date") {
        let titleHolder = DiagramUtils.getChildObjectByName(newData, "titleHolder");
        if (titleHolder) titleHolder.value = DiagramNodeUtils.formatDate(new Date(), "DD/MM/YYYY");
    }
    this.objData = newData;
    this.nodeData = this.objData;
    this.initCreation();
    this.updateNodeAttributes(arrIndex?.[0] || this.rowIndex, arrIndex?.[1] || this.colIndex);
    this.dInst?.updateEvents?.();
    this.dInst?.callTableFillIfNeed?.();
    if (obj.nodeData.navigateToSlideOnClick) {
        DiagramUtils.updateNodeLink(this.mainParent, obj, this.mainParent.firstElementChild);
    }
};

MultiContentTableNode.prototype.updateTextIfNeed = function (newData) {
    if (newData.nodename && (newData.nodename == "currency" || newData.nodename == "number" || newData.nodename == "date")) return;
    let isPrimaryUpdate = false;
    let isSecondaryUpdate = false;
    let isImageUpdate = false;
    let isLogoUpdate = false;
    let isIconUpdate = false;

    if (this.objData?.assetText?.primary) {
        let textHolder = DiagramUtils.getChildObjectByName(newData, "titleHolder");
        if (!textHolder) textHolder = DiagramUtils.getChildObjectByName(newData, "subTitleHolder");
        if (textHolder?.hasOwnProperty("value")) {
            textHolder.value = this.objData.tempText?.primary || this.objData.assetText.primary;
            isPrimaryUpdate = true;
            this.objData.assetText.primary = "";
        }
        if (textHolder?.items && !this.objData?.assetText?.secondary) {
            textHolder.items = [{ type: "text", value: this.objData.tempText?.primary || this.objData.assetText.primary, index: 0, content: null }];
            isSecondaryUpdate = true;
            this.objData.assetText.primary = "";
        }
    }

    if (this.objData?.assetText?.secondary) {
        let textHolder = DiagramUtils.getChildObjectByName(newData, "subTitleHolder");
        if (!textHolder && !isPrimaryUpdate) textHolder = DiagramUtils.getChildObjectByName(newData, "titleHolder");
        if (textHolder?.hasOwnProperty("value")) {
            isPrimaryUpdate = true;
            textHolder.value = this.objData.tempText?.secondary || this.objData.assetText.secondary;
            this.objData.assetText.secondary = "";
        }
        if (textHolder?.items) {
            textHolder.items = [{ type: "text", value: this.objData.tempText?.secondary || this.objData.assetText.secondary, index: 0, content: null }];
            isSecondaryUpdate = true;
            this.objData.assetText.secondary = "";
        }
    }

    if (this.objData?.assetText?.image) {
        let imageHolder = DiagramUtils.getChildObjectByName(newData, "imageHolder");
        if (imageHolder) {
            imageHolder.value = this.objData.assetText.image;
            this.objData.assetText.image = "";
            isImageUpdate = true;
        }
    }

    if (this.objData?.assetText?.logo) {
        let logoHolder = DiagramUtils.getChildObjectByName(newData, "imageSecHolder");
        if (logoHolder) {
            logoHolder.value = this.objData.assetText.logo;
            isLogoUpdate = true;
            this.objData.assetText.logo = "";
        }
    }

    let nodeName = newData.nodename || "";
    if (this.objData?.assetText?.icon && nodeName != "harveyball") {
        let iconHolder = DiagramUtils.getChildObjectByName(newData, "iconHolder");
        if (iconHolder) {
            iconHolder.value = this.objData.assetText.icon.value;
            iconHolder.id = this.objData.assetText.icon.id;
        }
    }

    if (this.objData?.assetText?.primary && !isIconUpdate && nodeName != "harveyball") {
        let iconHolder = DiagramUtils.getChildObjectByName(newData, "iconHolder");
        if (iconHolder) {
            iconHolder.assetText = this.objData.assetText.primary;
            iconHolder.needAssetUpdate = true;
            isIconUpdate = true;
        }
    }

    if (this.objData?.assetText?.secondary && !isIconUpdate && nodeName != "harveyball") {
        let iconHolder = DiagramUtils.getChildObjectByName(newData, "iconHolder");
        if (iconHolder) {
            iconHolder.assetText = this.objData.assetText.secondary;
            iconHolder.needAssetUpdate = true;
            isIconUpdate = true;
        }
    }

    if (this.objData?.assetText?.primary && !isImageUpdate) {
        let imageHolder = DiagramUtils.getChildObjectByName(newData, "imageHolder");
        if (imageHolder) {
            imageHolder.assetText = this.objData.assetText.primary;
            imageHolder.needAssetUpdate = true;
            isImageUpdate = true;
        }
    }

    if (this.objData?.assetText?.secondary && !isImageUpdate) {
        let imageHolder = DiagramUtils.getChildObjectByName(newData, "imageHolder");
        if (imageHolder) {
            imageHolder.assetText = this.objData.assetText.secondary;
            imageHolder.needAssetUpdate = true;
            isImageUpdate = true;
        }
    }

    if (this.objData?.assetText?.primary && !isLogoUpdate) {
        let logoHolder = DiagramUtils.getChildObjectByName(newData, "imageSecHolder");
        if (logoHolder) {
            logoHolder.assetText = this.objData.assetText.primary;
            logoHolder.needAssetUpdate = true;
            isLogoUpdate = true;
        }
    }

    if (this.objData?.assetText?.secondary && !isLogoUpdate) {
        let logoHolder = DiagramUtils.getChildObjectByName(newData, "imageSecHolder");
        if (logoHolder) {
            logoHolder.assetText = this.objData.assetText.secondary;
            logoHolder.needAssetUpdate = true;
            isLogoUpdate = true;
        }
    }

    if (this.objData?.assetText?.image) {
        let logoHolder = DiagramUtils.getChildObjectByName(newData, "imageSecHolder");
        if (logoHolder) {
            logoHolder.value = this.objData.assetText.image;
            isLogoUpdate = true;
            this.objData.assetText.image = "";
        }
    }

    if (this.objData?.assetText?.logo) {
        let imageHolder = DiagramUtils.getChildObjectByName(newData, "imageHolder");
        if (imageHolder) {
            imageHolder.value = this.objData.assetText.logo;
            this.objData.assetText.logo = "";
            isImageUpdate = true;
        }
    }
};

MultiContentTableNode.prototype.changeNodeAlign = function (obj) {
    this.nodeParent.firstElementChild.dataset.nodeAlign = obj.value;
};

MultiContentTableNode.prototype.setNodeStyle = function (obj, arrIndex) {
    this.mainParent.firstElementChild.setAttribute("data-nodestyle", obj.value);
};

MultiContentTableNode.prototype.setImageEditStyle = function (obj) {
    let imageStyleData = obj.data;
    let imageParent = this.mainParent.querySelector("[id='" + obj.targetid + "']");
    let imgNode = imageParent.querySelector("[name='imageNode'],[name='logoNode']");

    if (imgNode) {
        imgNode.setAttribute("data-style", imageStyleData.styleData);
        imgNode.setAttribute("data-csstext", imageStyleData.style.cssText);
        imgNode.style.cssText = imageStyleData.style.cssText;
    }
};

MultiContentTableNode.prototype.updateNodeAttributes = function (rowIndexP, colIndexP) {
    this.index = typeof rowIndexP !== "undefined" && typeof colIndexP !== "undefined" ? `${rowIndexP},${colIndexP}` : this.index;
    if (!this.parentNode) return;
    this.parentNode.setAttribute("data-index", this.index);
    this.parentNode.setAttribute("id", this.parentNode.getAttribute("name") + "-" + this.index);

    if (this.parentNode.getAttribute("name") == "nodeparent") {
        this.parentNode.parentElement.setAttribute("data-index", this.index);
        this.parentNode.parentElement.setAttribute("id", this.parentNode.parentElement.getAttribute("name") + "-" + this.index);
    }

    if (this.objData.nodeproperties?.nodeAlign) this.nodeParent.firstElementChild.dataset.nodeAlign = this.objData.nodeproperties.nodeAlign;
    if (this.objData.nodeproperties?.needAssetUpdate) this.nodeParent.firstElementChild.dataset.needAssetUpdate = this.objData.nodeproperties.needAssetUpdate;
    if (this.objData.nodeproperties?.assetText) this.nodeParent.firstElementChild.dataset.assetText = this.objData.nodeproperties.assetText;

    let [rowIndex, colIndex] = this.parentNode.dataset.index.split(",");
    if (!rowIndex || !colIndex) return;
    let allNodes = this.parentNode.querySelectorAll("[data-index]");
    allNodes.forEach((nodeItem) => {
        let name = nodeItem.getAttribute("name") || nodeItem.getAttribute("data-id");
        if (!nodeItem.dataset.imagegridIndex) {
            nodeItem.setAttribute("data-index", this.index);
            if (name) nodeItem.setAttribute("id", name + "-" + this.index);
        } else {
            nodeItem.setAttribute("id", "imageHolder" + this.index + "-gridNode" + nodeItem.dataset.imagegridIndex);
            nodeItem.setAttribute("data-index", this.index);
        }
        nodeItem.removeAttribute("data-animation");
        nodeItem.classList.remove("moodanimation");
        switch (name) {
            case "seqText":
                let content = DiagramUtils.getSeqMoodStyle(this.globalMoodData ? this.globalMoodData.seqnumproperties : null, this.properties, "sequencenumber", Number(rowIndex) + 1, this.diagramParent.dataset.nodecount);
                nodeItem.innerText = content;
                this.mainParent.parentElement.style.opacity = rowIndex == 0 && colIndex == 0 && this.properties.ignorefirstrow ? 0 : 1;
                break;
            case "numberNode":
                let valueTextObj = DiagramUtils.getObjectFromName(this.arrSupportedNodes, "valueTitleHolder");
                if (valueTextObj && valueTextObj.scale) {
                    let scale = valueTextObj.scale.split(",")[0];
                    let scaledSize = nodeItem.parentElement.parentElement.offsetWidth * parseFloat(scale);
                    nodeItem.style.fontSize = scaledSize - 8 + "px";
                    let maxHeight = scaledSize + "px";
                    nodeItem.style.maxHeight = maxHeight;
                    nodeItem.style.height = maxHeight;
                    nodeItem.style.minHeight = maxHeight;
                    nodeItem.parentElement.style.maxHeight = maxHeight;
                    nodeItem.parentElement.style.height = maxHeight;
                    nodeItem.parentElement.style.minHeight = maxHeight;
                }
                break;
            default:
                break;
        }
    });

    this.updateCheckListNode();

    if (this.contentBG) DiagramNodeUtils.applyNodeStyleClipPath(this.contentBG.id, this.diagramParent, colIndex);

    this.setMinSize();

    this.nodeParent.firstElementChild.style.width = "var(--width" + colIndex + ")";
    this.nodeParent.firstElementChild.style.height = "var(--height" + rowIndex + ")";

    if (this.arrTintArray && this.arrTintArray.length > 0) {
        DiagramUtils.setCustomItemColor(this.parentNode.parentElement, this.arrTintArray, colIndex, colIndex + 1);
        let nodeNonlinear = this.diagramParent.querySelector("[name='nodeNonlinearMainParent'][data-index='" + this.index + "']");
        if (nodeNonlinear) DiagramUtils.setCustomItemColor(nodeNonlinear, this.arrTintArray, colIndex, colIndex + 1);
    }

    if (this.objData.nodeStyleClass) this.mainParent.dataset.nodestyle = this.objData.nodeStyleClass;
    if (rowIndex == 0 && colIndex == 0) {
        this.mainParent.parentElement.style.visibility = this.properties.ignorefirstrow ? "hidden" : "visible";
    }
};

MultiContentTableNode.prototype.updateCheckListNode = function (obj) {
    let toggleListNode = this.parentNode.querySelector("[name='numberToggleStyle']");
    if (toggleListNode && this.numberToggleStyle) {
        let nodeParent = this.mainParent.querySelector("[name='nodeparent']");
        let checklistNode = this.mainParent.querySelector("[data-id='checklistNode']");
        checklistNode.dataset.ischecked = obj ? obj.ischecked : checklistNode.dataset.ischecked;
        this.numberToggleStyle.updateNumberToggleNode(nodeParent);
        return;
    }

    let checklistNode = this.parentNode.querySelector("[data-id='checklistNode']");
    if (checklistNode) {
        if (obj) checklistNode.dataset.ischecked = obj.ischecked;
        let checkedClass = checklistNode.dataset.checkedclass;
        let ischecked = checklistNode.dataset.ischecked && checklistNode.dataset.ischecked == "true";
        let index = checklistNode.dataset.index;
        let nodeParent = this.nodeGroup?.parentElement?.parentElement; //this.getNodeParent().parentElement;
        if (!nodeParent) return;
        let checkmarksvg = nodeParent.querySelector("[data-id='checkmarksvg']");
        let uncheckmarksvg = nodeParent.querySelector("[data-id='uncheckmarksvg']");

        if (ischecked) {
            nodeParent.classList.add(checkedClass);
        } else {
            nodeParent.classList.remove(checkedClass);
        }

        if (this.diagramProps.checkBG && checkmarksvg) {
            checkmarksvg.style.display = ischecked ? "flex" : "none";
        }

        if (this.diagramProps.uncheckBG && uncheckmarksvg) {
            uncheckmarksvg.style.display = ischecked ? "none" : "flex";
        }
    }
};

MultiContentTableNode.prototype.recreateImageGridInstance = function () {
    try {
        let imageGridNode = this.nodeParent.querySelector("[name='imageGridNode']");
        if (imageGridNode) {
            let nodeItem = this.mainParent.firstElementChild.firstElementChild;
            this.gridInstance = new window["SimpleImageGrid"](nodeItem, this.dInst.nodeProps, this.dInst.appStaticURL, DiagramUtils.getDefaultDataForLogoList(this.dInst.arrDefaults, this.dInst.nodeProps), {});
            this.gridInstance.gridimages = this.gridInstance.getLogoListData(nodeItem);
            this.gridInstance.updateCallBack = this.updateCallBack;
            this.gridInstance.focusCallBack = {
                func: this.updateOnFocusOut.bind(this),
            };
            let arrLogoNodes = imageGridNode.querySelectorAll("[name='logoNode']");
            if (arrLogoNodes?.length > 0) {
                arrLogoNodes.forEach((element) => {
                    DiagramResizeUtils.updateDefaultImageData(element, "logo", this?.gridInstance?.imageLoadCallBack);
                });
            }
        }
    } catch (error) {
        console.log(error);
    }
};

MultiContentTableNode.prototype.recreateNumberToggleInstance = function () {
    try {
        let numberToggleStyle = this.mainParent.querySelector("[id*='numberToggleStyle']");
        if (numberToggleStyle) {
            this.numberToggleStyle = new window["NumberToggleStyleGroup"](this.dInst.nodeProps, {}, this.index, DiagramUtils.getObjectFromName(this.dInst.nodeProps.supportedNodes, "numberToggleStyleGroup"), this.dInst.appStaticURL);
            this.number = this.numberToggleStyle.getNumberToggleData(this.mainParent);
        }
    } catch (error) {
        console.log(error);
    }
};

MultiContentTableNode.prototype.microChartFoucsOut = function (event) {
    let nodeItem = this.diagramParent.querySelector("[id='microChartHolder-" + event.currentTarget.dataset.index + "']");
    DiagramCreateUtil.parseMicroChartValue(event.target.innerText, event.target, nodeItem, this.globalMoodData);
    this.eventManager.dispatch("focusout", event.target);
};

MultiContentTableNode.prototype.updateHighlight = function (type) {
    let highlightClass = type + "-highlightEnabled";
    this.mainParent.classList.contains(highlightClass) ? this.mainParent.classList.remove(highlightClass) : this.mainParent.classList.add(highlightClass);
    this.nodeData.cellproperties.isHighlight = this.mainParent.classList.contains(highlightClass);
};

MultiContentTableNode.prototype.checkForHighlight = function (nodeData) {
    let [rowId, colId] = this.index.split(",");
    colId = this.properties.numbering ? parseInt(colId) - 1 : parseInt(colId);
    rowId = parseInt(rowId);
    if (rowId == 0 && this.properties.rowheader) return;
    if (colId == 0 && this.properties.colheader) return;
    let colClass = this.properties.colhighlightindex?.includes(colId) ? "col-highlightEnabled" : "";
    let rowClass = this.properties.rowhighlightindex?.includes(rowId) ? "row-highlightEnabled" : "";
    if (colClass != "" && !this.mainParent.classList.contains(colClass)) this.mainParent.classList.add(colClass);
    if (rowClass != "" && !this.mainParent.classList.contains(rowClass)) this.mainParent.classList.add(rowClass);

    // if (this.properties.cellhighlightindex && JSON.stringify(this.properties.cellhighlightindex).includes(JSON.stringify([rowId, colId]))) {
    //     let cellClass = "col-highlightEnabled";
    //     if (cellClass != "" && !this.mainParent.classList.contains(cellClass)) this.mainParent.classList.add(cellClass);
    // }
};

MultiContentTableNode.prototype.updateGridSwap = function (obj, arrIndex) {
    let targetObj = DiagramUtils.getChildObjectByName(this.nodeData, "imageGridNode");
    let gridNode = this.mainParent.querySelector("[id='" + obj.targetid + "']");
    if (targetObj && gridNode) {
        let sourceIndex = Number(gridNode.dataset.imagegridIndex);
        let destinationIndex = obj.property == "swapnext" ? sourceIndex + 1 : sourceIndex - 1;
        targetObj.value.splice(sourceIndex, 1, targetObj.value.splice(destinationIndex, 1, targetObj.value[sourceIndex])[0]);

        this.objData = this.nodeData;
        this.mainParent.innerHTML = "";
        this.initCreation();
        this.updateNodeAttributes(arrIndex[0], arrIndex[1]);
        this.dInst?.updateEvents?.();
    }
};

MultiContentTableNode.prototype.createTitle = function (bgDiv, primaryTextData, nodeObj) {
    let titleHolder = PlainDiagramNodeBase.prototype.createTitle.call(this, bgDiv, primaryTextData, nodeObj);
    if (primaryTextData.valuetype) {
        titleHolder.dataset.valuetype = primaryTextData.valuetype;
        titleHolder.firstElementChild.dataset.valuetype = primaryTextData.valuetype;
    }
    return titleHolder;
};

MultiContentTableNode.prototype.createSubTitle = function (bgDiv, nodeObj) {
    let subtitleHolder = PlainDiagramNodeBase.prototype.createSubTitle.call(this, bgDiv, nodeObj);
    if (nodeObj?.valuetype) {
        subtitleHolder.dataset.valuetype = nodeObj.valuetype;
        subtitleHolder.firstElementChild.dataset.valuetype = nodeObj.valuetype;
    }
    this.updateTextSingleLineHeight();
    return subtitleHolder;
};

MultiContentTableNode.prototype.createValueTitle = function (bgDiv, content, holdertype, nodeObj) {
    let valueHolder = PlainDiagramNodeBase.prototype.createValueTitle.call(this, bgDiv, content, holdertype, nodeObj);
    if (content.valuetype) {
        valueHolder.dataset.valuetype = content.valuetype;
        valueHolder.firstElementChild.dataset.valuetype = content.valuetype;
    }
};

MultiContentTableNode.prototype.updateValueFormat = function (obj, arrIndex) {
    let textNode = this.mainParent.querySelector("[id='" + obj.targetid + "']");
    if (textNode.tagName == "UL") textNode = textNode.firstElementChild;
    let format = obj.data;
    if (!textNode) return;
    let valueType = textNode.dataset.valuetype || textNode.parentElement.dataset.valuetype;
    switch (valueType) {
        case "number":
            format = format || "0";
            let numcontent = textNode.textContent.isEmpty() ? "0" : textNode.textContent;
            textNode.textContent = DiagramUtils.formatNumberWithCommas(numcontent, format);
            break;
        case "currency":
            format = format || "INR";
            let curcontent = textNode.textContent.isEmpty() ? "0" : textNode.textContent;
            textNode.textContent = DiagramUtils.formatCurrency(curcontent, format);
            break;
        case "date":
            format = format || "DD/MM/YYYY";
            let currentDate = new Date().toLocaleDateString("en-IN", { year: "numeric", month: "2-digit", day: "2-digit" });
            let dateContent = textNode.textContent.isEmpty() ? currentDate : textNode.textContent;
            textNode.textContent = DiagramUtils.formatDate(dateContent, format, textNode.dataset.format || "DD/MM/YYYY");
            break;
    }
    textNode.setAttribute("data-format", format);
    textNode.parentElement.setAttribute("data-format", format);
};

MultiContentTableNode.prototype.onTextChangeUpdate = function (nodeToUpdate, parentNode, nodeGroup) {
    if (!nodeToUpdate) return;
    let textNode = nodeToUpdate.querySelector("[data-name='text']");
    if (textNode) {
        textNode.style.removeProperty("max-height");
        textNode.parentElement.style.removeProperty("max-height");
    }
    let parentHeight = parentNode.offsetHeight;
    let contentHeight = nodeGroup.offsetHeight;
    let heightDiff = contentHeight - parentHeight;
    // this.updateMaxFontCallBack(textNode.id);
    if (contentHeight > parentHeight) {
        for (let i1 = 0; i1 < this.arrAllowResize.length; i1++) {
            let nodeName = this.arrAllowResize[i1];
            let nodeToResize = parentNode.querySelector("[name='" + nodeName + "']");
            if (nodeToResize) {
                let computedStype = window.getComputedStyle(nodeToResize);
                let nodeHeight = parseInt(computedStype.height.replace("px", ""));
                let minHeight = parseInt(computedStype.minHeight.replace("px", ""));
                nodeToResize.style.setProperty("max-height", Math.max(minHeight, nodeHeight - heightDiff) + "px");
                contentHeight = nodeGroup.offsetHeight;
                heightDiff = contentHeight - parentHeight;
                if (contentHeight <= parentHeight) break;
            }
        }

        contentHeight = nodeGroup.offsetHeight;
        heightDiff = contentHeight - parentHeight;
        if (contentHeight > parentHeight) {
            let nodeHeight = nodeToUpdate.offsetHeight;
            let maxHeight = nodeHeight - heightDiff;
            nodeToUpdate.style.setProperty("max-height", maxHeight + "px");
        }
    }
    contentHeight = nodeGroup.offsetHeight;
    heightDiff = contentHeight - parentHeight;
    if (contentHeight > parentHeight) {
        let nodeHeight = nodeToUpdate.offsetHeight;
        let maxHeight = nodeHeight - heightDiff;
        nodeToUpdate.style.setProperty("max-height", maxHeight + "px");
    }
    let isAutoResize = DiagramResizeUtils.isAutoFontResize(textNode, this.properties.fontresize);
    if (!isAutoResize) {
        let remaningSpace = parentHeight - contentHeight + textNode.parentElement.offsetHeight;
        nodeGroup.style.height = "100%";
        nodeGroup.style.minHeight = "auto";
        let fontClass = DiagramResizeUtils.commonFontResize(contentHeight, textNode.parentElement.offsetHeight, remaningSpace, textNode, textNode.parentElement, this.fontClassList);
        if (fontClass && fontClass != "") {
            textNode.dataset.newfontclass = fontClass;
        }

        nodeGroup.style.removeProperty("height");
        nodeGroup.style.removeProperty("min-height");
    } else if (textNode) this.onTextUpdate(textNode);
};

MultiContentTableNode.prototype.setMinSize = function () {
    let defaultMinWidth = this.objData?.cellproperties?.minwidth ? DiagramUtils.valueInPx(this.objData?.cellproperties?.minwidth) : "200px";
    let defaultMinHeight = this.objData?.cellproperties?.minheight ? DiagramUtils.valueInPx(this.objData?.cellproperties?.minheight) : "80px";
    this.nodeParent.firstElementChild.style.minWidth = this.nodeParent.firstElementChild.dataset.minwidth || defaultMinWidth;
    this.nodeParent.firstElementChild.style.minHeight = this.nodeParent.firstElementChild.dataset.minheight || defaultMinHeight;
    this.nodeParent.firstElementChild.dataset.minwidth = defaultMinWidth;
    this.nodeParent.firstElementChild.dataset.minheight = defaultMinHeight;
};

MultiContentTableNode.prototype.setAutoSize = function (setWidth = true, setHeight = true) {
    let defaultMinWidth = this.objData?.cellproperties?.minwidth ? DiagramUtils.valueInPx(this.objData?.cellproperties?.minwidth) : "auto";
    let defaultMinHeight = this.objData?.cellproperties?.minheight ? DiagramUtils.valueInPx(this.objData?.cellproperties?.minheight) : "auto";

    if (setWidth) this.nodeParent.firstElementChild.style.minWidth = defaultMinWidth;
    if (setHeight) this.nodeParent.firstElementChild.style.minHeight = defaultMinHeight;
};

MultiContentTableNode.prototype.autoDimension = function (setWidth = true, setHeight = true) {
    if (setWidth) this.nodeParent.firstElementChild.style.minWidth = "auto";
    if (setHeight) this.nodeParent.firstElementChild.style.minHeight = "auto";
};

MultiContentTableNode.prototype.updateOnFocusIn = function (event) {};

MultiContentTableNode.prototype.updateOnFocusOut = function (targetNode) {
    this.resetMaxHeight();
    if (!this.mainParent || !this.mainParent.parentElement) return;
    let allNodes = this.dInst.tableParent.querySelectorAll("[name='nodeparent']");
    this.aliginNodeContent(allNodes);
    this.setMinFontSize();
};

MultiContentTableNode.prototype.resetMaxHeight = function () {
    for (let l3 = 0; l3 < this.arrAllowResize.length; l3++) {
        const key = this.arrAllowResize[l3];
        this.dInst.tableParent.style.setProperty("--" + key + "MH", this.arrAllowResizeHeight[l3] + "px");
        this.setContentResize(this.arrAllowResizeHeight[l3]);
    }

    for (let l3 = 0; l3 < this.arrTextNodes.length; l3++) {
        const key = this.arrTextNodes[l3];
        let node = this.dInst.tableParent.querySelector("[name='" + key + "']");
        if (node && node.firstElementChild) {
            let lineHeight = getComputedStyle(node.firstElementChild)["lineHeight"];
            this.dInst.tableParent.style.setProperty("--" + key + "MH", lineHeight);
        } else this.dInst.tableParent.style.setProperty("--" + key + "MH", "27px");
    }
};

MultiContentTableNode.prototype.setMinFontSize = function () {
    let arrNewFontClass = this.dInst.tableParent.querySelectorAll("[data-newfontclass]");
    if (arrNewFontClass && arrNewFontClass.length > 0) {
        let minTitleFont = 0;
        let minSubTitleFont = 0;
        arrNewFontClass.forEach((node) => {
            let isAutoResize = DiagramResizeUtils.isAutoFontResize(node, this.properties.fontresize);
            if (!isAutoResize) {
                let newFontClass = node.getAttribute("data-newfontclass") || node.getAttribute("original-fontclass") || "";
                let number = newFontClass.replace("h", "").replace("p", "");
                let numberOriginal = node.getAttribute("original-fontclass").replace("h", "").replace("p", "");
                numberOriginal = parseInt(numberOriginal);
                if (newFontClass && newFontClass.startsWith("h")) {
                    minTitleFont = Math.max(number, minTitleFont, numberOriginal);
                } else if (newFontClass && newFontClass.startsWith("p")) {
                    minSubTitleFont = Math.max(number, minSubTitleFont, numberOriginal);
                }
            }
        });
        if (minTitleFont != 0) {
            this.dInst.arrTableNode.forEach((row) => {
                row.forEach((cell) => {
                    let arrNewFontClass = cell.mainParent.querySelectorAll("[name='primaryText'],[name='authorName']");
                    arrNewFontClass.forEach((node) => {
                        TextHighLightUtils.removeFontClassName(node, cell.fontClassList);
                        node.classList.add("h" + minTitleFont);
                        cell.onTextUpdate(node);
                    });
                });
            });
        }
        if (minSubTitleFont != 0) {
            this.dInst.arrTableNode.forEach((row) => {
                row.forEach((cell) => {
                    let arrNewFontClass = cell.mainParent.querySelectorAll("[name='secondaryText'],[name='authorName']");
                    arrNewFontClass.forEach((node) => {
                        TextHighLightUtils.removeFontClassName(node, cell.fontClassList);
                        node.classList.add("p" + minSubTitleFont);
                        cell.onTextUpdate(node);
                    });
                });
            });
        }
    }
};

MultiContentTableNode.prototype.getTextContent = (element) => {
    let textContent = element.dataset?.oldtext || element.innerHTML || "";
    return textContent != "" ? TextHighLightUtils.highlightToString(textContent) : "";
};

MultiContentTableNode.prototype.listData = function (nodeData, name, rootNodeData) {
    let element = this.parentNode.querySelector("[name='" + name + "']");
    element = element.firstElementChild || element;
    let subtype = this.nodeGroup.dataset.sublist || "none";
    if (element) {
        let arrLi = element.querySelectorAll("li");
        let dummyUl = document.createElement("ul");
        dummyUl.innerHTML = element.dataset.oldtext || element.innerHTML || "";
        arrLi = dummyUl.querySelectorAll("li");
        let items = [];
        let tempText = "";
        arrLi.forEach((li, i) => {
            if (i == 0) tempText = this.getUlTextContent(li);
            items.push({ value: this.getUlTextContent(li), type: "text" });
        });
        nodeData[name] = { type: "list", items: items, sublist: subtype, ...DiagramCreateUtil.getTextProps(element) };

        let valueType = element.dataset.valuetype || element.parentElement.dataset.valuetype;
        if (valueType) {
            rootNodeData.nodeproperties ? (rootNodeData.nodeproperties.valuetype = valueType) : (rootNodeData.nodeproperties = { valuetype: valueType });
        }

        rootNodeData.assetText = { ...(rootNodeData.assetText && { ...rootNodeData.assetText }), secondary: element?.textContent };
        rootNodeData.tempText = { ...(rootNodeData.assetText && { ...rootNodeData.assetText }), secondary: tempText };
    }
};

// dont delete this line used in MultiContentTableMouseController
String.prototype.isEmpty = function () {
    return this == "" && this.length === 0;
};

/**
 * Author:    Krishna
 * Created:   Mon 25 Oct 2021
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function TimelineNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    PlainDiagramNode.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
}

TimelineNode.prototype = Object.create(PlainDiagramNode.prototype);
TimelineNode.prototype.constructor = TimelineNode;

TimelineNode.prototype.onTextChangeUpdate = function () {
    let secContentNode = this.nodeGroup.querySelector("[name='secContentNode']");
    let maxHeight = parseFloat(window.getComputedStyle(secContentNode).maxHeight);
    let valueText = this.nodeGroup.querySelector("[name='valueTitleHolder']");

    let availableHeight = maxHeight - valueText.clientHeight;
    let titleText = this.nodeGroup.querySelector("[name='titleHolder']");
    let titleStyleObj = styleObj(titleText);
    let subtitleText = this.nodeGroup.querySelector("[name='subTitleHolder']");
    let subtitleStyleObj = styleObj(subtitleText);

    titleText.style.removeProperty("max-height");
    subtitleText.style.removeProperty("max-height");
    subtitleText.style.removeProperty("min-height");

    let titleLineHeight = parseFloat(titleStyleObj.lineHeight);
    let subtitleLineHeight = parseFloat(subtitleStyleObj.lineHeight);

    if (subtitleText.clientHeight == 0 && titleText.clientHeight == 0) {
        return;
    } else if (subtitleText.clientHeight == 0) {

        let noOfLines = getNoOfLine(titleText, availableHeight);
        let maxHeight = noOfLines * titleLineHeight;
        titleText.style.maxHeight = maxHeight + "px";

    } else if (titleText.clientHeight == 0) {

        let noOfLines = getNoOfLine(subtitleText, availableHeight);
        let maxHeight = noOfLines * subtitleLineHeight;
        subtitleText.style.maxHeight = maxHeight + "px";
        subtitleText.parentElement.style.maxHeight = maxHeight + "px";

    } else if (availableHeight < titleText.clientHeight + subtitleLineHeight) {

        availableHeight = availableHeight - subtitleLineHeight;
        let noOfLines = getNoOfLine(titleText, availableHeight);
        let maxHeight = noOfLines * titleLineHeight;
        titleText.style.maxHeight = maxHeight + "px";
        subtitleText.style.maxHeight = subtitleLineHeight + "px";

    } else if (availableHeight > titleText.clientHeight) {

        subtitleText.style.height = 0 + "px";
        let height = titleText.clientHeight;
        titleText.style.maxHeight = height + "px";
        availableHeight = availableHeight - height;
        let noOfLines = getNoOfLine(subtitleText, availableHeight);
        let maxHeight = noOfLines * subtitleLineHeight;
        // subtitleText.style.height = maxHeight + "px";
        subtitleText.style.height = "unset";
        subtitleText.style.maxHeight = maxHeight + "px";
    }
};

TimelineNode.prototype.aliginNodeContent = function () {

};

function getNoOfLine(element, maxHeight) {
    let styleObj = window.getComputedStyle(element);
    let lineHeight = styleObj.lineHeight;
    let fontsize = styleObj.fontSize;
    lineHeight = isNaN(parseFloat(lineHeight)) ? parseFloat(fontsize) * 1.2 : parseFloat(lineHeight);
    return parseInt(Math.max(maxHeight / lineHeight, 1));
};

function styleObj(element) {
    return window.getComputedStyle(element);
};
/**
 * Author:    Saravanan G
 * Created:   3.10.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function PlotDiagramNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    MultiCellOptionNode.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
    this.index = index;
    this.objData = objData;
    this.eventManager = eventManager;
    this.parentID = parentID;
    this.mainParent = mainParent;
    this.objStyleData = objStyleData || {};
    this.objStyleData.fontSizeData = this.objStyleData.fontSizeData || {};
    this.titleFontSize = this.objStyleData.fontSizeData.primarytext || "h7";
    this.subtitleFontSize = this.objStyleData.fontSizeData.primarytext || "p4";

    this.appStaticURL = appStaticURL;
    this.properties = properties;
    this.diagramParent = diagramParent;
}

PlotDiagramNode.prototype = Object.create(MultiCellOptionNode.prototype);
PlotDiagramNode.prototype.constructor = PlotDiagramNode;

PlotDiagramNode.prototype.initCreation = function () {
    let nodesHolder = this.diagramParent.querySelector("div[name='nodesHolder']");
    this.parentNode = this.createXYNodeParent(nodesHolder);
    // this.arrSupportedNodes = [{ name: "contentNode", subNodes: [{ name: "iconHolder" }] }, { name: "titleHolder" }];
    if (!this.objData)
        this.objData = {
            contentNode: {
                subNodes: {
                    iconHolder: {
                        type: "icon",
                        assetText: "",
                        value: "default/best.svg",
                        id: "best",
                        dataRef: { name: "best" },
                        contenttype: "icon",
                    },
                },
            },
            nodeStyleClass: "clsTablePlainIcon",
            needAssetUpdate: true,
        };
    this.nodeGroup = this.createNodeGroup(this.parentNode);
    this.createBackGround();
    let contentNode = this.nodeGroup.querySelector("[name='iconHolder'],[name='imageHolder'],[name='imageSecHolder']");
    // let contentNode = this.nodeGroup.querySelector("[name='iconHolder'],[name='imageSecHolder']");
    if (contentNode) {
        contentNode.setAttribute("data-original-width", contentNode.offsetWidth);
        contentNode.setAttribute("data-original-height", contentNode.offsetHeight);
    }
    let nodeParentMain = this.parentNode.parentElement;
    if (this.objData?.nodeproperties?.x) {
        nodeParentMain.style.left = this.objData.nodeproperties.x + "px";
        nodeParentMain.setAttribute("data-x", this.objData.nodeproperties.x);
        // nodeParentMain.setAttribute("data-percentx", this.diagramParent.offsetWidth / this.objData.nodeproperties.x);
    }
    if (this.objData?.nodeproperties?.y) {
        nodeParentMain.style.top = this.objData.nodeproperties.y + "px";
        nodeParentMain.setAttribute("data-y", this.objData.nodeproperties.y);
        // nodeParentMain.setAttribute("data-percenty", this.diagramParent.offsetHeight / this.objData.nodeproperties.y);
    }
    if (this.objData?.nodeproperties?.percentx) {
        let left = this.objData.nodeproperties.percentx * this.diagramParent.offsetWidth;
        nodeParentMain.style.left = left + "px";
        nodeParentMain.setAttribute("data-x", left);
        nodeParentMain.setAttribute("data-percentx", this.objData.nodeproperties.percentx);
    }
    if (this.objData?.nodeproperties?.percenty) {
        let top = this.objData.nodeproperties.percenty * this.diagramParent.offsetHeight;
        nodeParentMain.style.top = top + "px";
        nodeParentMain.setAttribute("data-y", top);
        nodeParentMain.setAttribute("data-percenty", this.objData.nodeproperties.percenty);
    }
    if (this.objData?.nodeproperties?.contentsize) {
        nodeParentMain.setAttribute("data-contentsize", this.objData.nodeproperties.contentsize);
        if (contentNode) {
            this.changeContentSize(contentNode, { value: this.objData.nodeproperties.contentsize });
        }
    }
    // this.parentNode.setAttribute("axis", this.objData.axis);
    // let hasContent = this.properties.contentoptions == "titlecontent" || this.properties.contentoptions == "contentonly";
    // if (hasContent) this.createContentNode();
};

PlotDiagramNode.prototype.changeContentType = function (obj) {
    let nodeProperties = this.getNodeProperties();
    this.parentNode.parentElement.remove();
    let newData = JSON.parse(JSON.stringify(obj.nodeData || obj.data));
    if (!newData.nodename) newData.nodename = obj.value;
    this.updateTextIfNeed(newData);
    newData.nodeproperties = nodeProperties;
    this.objData = newData;
    this.nodeData = this.objData;
    this.initCreation();
    this.updateNodeAttributes(this.index);
    // this.dInst?.updateEvents?.();
    // this.dInst?.callTableFillIfNeed?.();
};

PlotDiagramNode.prototype.changeContentSize = function (target, obj) {
    let scaledValue = parseFloat(obj.value);
    let originalWidth = target.getAttribute("data-original-width");
    let originalHeight = target.getAttribute("data-original-height");
    let newWidth = parseFloat(originalWidth) * scaledValue;
    let newHeight = parseFloat(originalHeight) * scaledValue;
    target.style.setProperty("width", newWidth + "px", "important");
    target.style.setProperty("height", newHeight + "px", "important");
    target.style.setProperty("min-width", newWidth + "px", "important");
    target.style.setProperty("min-height", newHeight + "px", "important");
    target.style.setProperty("max-width", newWidth + "px", "important");
    target.style.setProperty("max-height", newHeight + "px", "important");
    this.parentNode.parentElement.setAttribute("data-contentsize", scaledValue);
};

PlotDiagramNode.prototype.updateNodeAttributes = function (index) {
    MultiCellOptionNode.prototype.updateNodeAttributes.call(this, index);
    let dragHandle = this.parentNode?.parentElement?.querySelector("[name='nodeDragHandle']");
    dragHandle?.setAttribute("data-index", this.index);
    dragHandle?.setAttribute("id", "nodeDragHandle" + this.index);
};

PlotDiagramNode.prototype.getNodeProperties = function () {
    let nodeProperties = {};
    let arrProperties = ["x", "y", "percentx", "percenty", "axis", "contentsize"];
    arrProperties.forEach((property) => {
        if (this.parentNode.parentElement) {
            let value = this.parentNode.parentElement.dataset[property];
            if (value) nodeProperties[property] = value;
        }
    });
    return nodeProperties;
};

PlotDiagramNode.prototype.createXYNodeParent = function (parentPlotDiagramNode) {
    let nodeParentMain = document.createElement("div");
    nodeParentMain.className = "accent" + (this.index + 1) + " clsMultiColorParent clsNodeParentMain " + this.diagramProps.parentStyle + " " + this.diagramProps.globalstyle + " " + this.objData?.nodeStyleClass;
    nodeParentMain.setAttribute("data-nodestyleclass", this.objData?.nodeStyleClass);
    nodeParentMain.setAttribute("name", "nodeMainParent");
    nodeParentMain.setAttribute("data-index", this.index);
    nodeParentMain.setAttribute("id", "nodeMainParent" + this.index);
    nodeParentMain.setAttribute("data-move", "true");
    nodeParentMain.setAttribute("data-index", this.index);
    // nodeParentMain.setAttribute("draggable", true);
    nodeParentMain.setAttribute("data-parent-id", this.parentID);

    DiagramUtils.addClassesFromMenu(this.diagramProps.objClass, nodeParentMain);

    parentPlotDiagramNode.insertChildAtIndex(nodeParentMain, this.index);

    let nodeSubParent = document.createElement("div");
    DiagramNodeUtils.assignAttributes(nodeSubParent, {
        class: "clsNodeParent",
        name: "nodeparent",
        id: "nodeparent" + this.index,
        "data-parent-id": this.parentID,
        "data-index": this.index + "",
    });
    nodeParentMain.appendChild(nodeSubParent);

    let nodeDragHandle = document.createElement("div");
    DiagramNodeUtils.assignAttributes(nodeDragHandle, {
        class: "clsNodeDragHandle ic_drag_outline",
        name: "nodeDragHandle",
        id: "nodeDragHandle" + this.index,
        "data-parent-id": this.parentID,
        "data-index": this.index + "",
    });
    // nodeDragHandle.style.display = "none";
    nodeParentMain.appendChild(nodeDragHandle);

    DiagramUtils.addClassesFromMenu(this.diagramProps.objClass, nodeSubParent);

    if (this.bgColorNode == "node") {
        nodeSubParent.classList.add(this.bgColor);
        if (this.bgOpacity) nodeSubParent.style.setProperty("--bg-opacity", this.bgOpacity);
    }

    if (this.borderNode.includes("node")) {
        nodeSubParent.classList.add(this.borderColor);
    }

    return nodeSubParent;
};

PlotDiagramNode.prototype.defaultFoucsOut = function (event) {
    if (event.target.innerText == "") event.target.innerHTML = "";
};

PlotDiagramNode.prototype.updateContentData = function (nodeData) {
    let contentNode = this.parentNode.querySelector("div[name='contentNode']");
    if (contentNode && contentNode.dataset && contentNode.dataset.contentType) {
        let contentType = contentNode.dataset.contentType;
        let node = contentNode.querySelector("[data-id='" + contentType + "Node']");
        switch (contentType) {
            case "image":
            case "logo":
                node.setAttribute("data-src", nodeData.value);
                DiagramResizeUtils.updateDefaultImageData(node, contentType, this.imageLoadCallBack || this.updateCallBack);
                break;
            case "icon":
                let iconName = DiagramNodeUtils.getIconName({ id: nodeData.id, value: nodeData.value });
                let useNode = node.querySelector("[id='useNode']");
                if (useNode) useNode.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "#" + iconName);
                node.setAttribute("iconid", nodeData.id);
                node.setAttribute("iconpath", nodeData.value);
                break;
            default:
                break;
        }
    }
};

PlotDiagramNode.prototype.getContentData = function () {
    let contentNode = this.parentNode.querySelector("div[name='contentNode']");
    if (contentNode && contentNode.dataset && contentNode.dataset.contentType) {
        let contentType = contentNode.dataset.contentType;
        let node;
        let data = {};
        let dataRef = {};
        node = contentNode.querySelector("[data-id='" + contentType + "Node']");
        switch (contentType) {
            case "image":
            case "logo":
                dataRef = { imageURL: node.src };
                if (node.dataset.csstext) dataRef.cropStyle = node.dataset.csstext;
                if (node.dataset.style) dataRef.cropData = node.dataset.style;
                data = { type: "image", value: node.src, dataRef: dataRef, contenttype: contentType };
                break;
            case "icon":
                // case "bgimage":
                let iconid = node.getAttribute("iconid");
                let path = node.getAttribute("iconpath");
                dataRef.name = iconid;
                dataRef.id = iconid;
                data = { type: "icon", value: path, id: iconid, dataRef: dataRef, contenttype: contentType };
                break;
            default:
                data = { type: "text", value: "", contenttype: contentType };
                break;
        }
        return data;
    } else {
        if (this.properties.diagram_type == "icon") return { type: "icon", value: "genericassets/icons/placeholder/placeholder.svg", dataRef: { name: "placeholder" } };
        return { type: "image", value: this.appStaticURL + "genericassets/placeholderimages/logoplaceholder_landscape.png" };
    }
};

PlotDiagramNode.prototype.updateProperty = function (properties) {
    this.properties = properties;
    this.parentNode.parentElement.removeChild(this.parentNode);
    this.parentNode.innerHTML = "";
    this.initCreation();
    this.parentNode.style.left = this.objData.nodeproperties.x + "px";
    this.parentNode.style.top = this.objData.nodeproperties.y + "px";
};

/**
 * Author:    Saravanan G
 * Created:   13.12.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function TwoLegDiagramNode(mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent) {
    PlainDiagramNode.call(this, mainParent, properties, objData, eventManager, index, parentID, objStyleData, appStaticURL, diagramProps, diagramParent);
    this.dataType = "header";
}

TwoLegDiagramNode.prototype = Object.create(PlainDiagramNode.prototype);

TwoLegDiagramNode.prototype.constructor = TwoLegDiagramNode;

TwoLegDiagramNode.prototype.getJSONData = function () {
    let nodeData = PlainDiagramNode.prototype.getJSONData.call(this);
    nodeData.connectortext = this.getConnectorText();
    return nodeData;
};

TwoLegDiagramNode.prototype.getConnectorText = function () {
    let connectortext = [];
    let connectorText = this.mainParent.querySelectorAll("div[name='connectorText']");
    connectorText.forEach((element) => {
        connectortext.push({ value: element.textContent });
    });
    return connectortext;
};

/**
 * Author:    Krishna prabhu M
 * Created:   8 Jan 20
 *
 * (c) Copyright by Gs.
 **/

//test

"use strict";

//SimpleLinearDiagram
function CircularMultiSlide(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "clsLinerDiagram clsMultiCircle clsNonHover";
    this.rotation = 75;
    this.pageIndex = 0;
    this.totalPage = 0;
    this.svgHolder = null;
    this.rotationOffset = -180;
    this.bgShape = "circle";
    this.multislideBase = null;
    this.arrShapePoints = null;
    this.arrOldVisiblePoints = [];
    this.durationFactor = 0;
    this.delayFactor = 0;
    this.defaultscale = 1;
    this.orderedNodes = [];
    this.textPositions = [];
    this.diagramParent.parentElement.setAttribute("data-ismultislide", true);

    // this.cubicPath = "cubic-bezier(0.33, 0.75, 0.57, 0.98)";
    this.animationDuration = 1.4;
    this.cubicPath = "cubic-bezier(.65,0,.25,1)";
    this.isRenderComplete = false;
}

CircularMultiSlide.prototype = Object.create(SimpleLinearDiagram.prototype);
CircularMultiSlide.prototype.constructor = CircularMultiSlide;

CircularMultiSlide.prototype.initDiagramCreation = function () {
    this.isRenderComplete = false;
    this.diagramParent.parentElement.setAttribute("data-animationtype", "one");
    while (this.diagramData.nodes.length < 4) {
        let data = JSON.parse(JSON.stringify(this.diagramData.nodes[0]));
        this.diagramData.nodes.push(data);
    }

    this.rotation = 75;
    this.pageIndex = 0;
    SimpleLinearDiagram.prototype.initDiagramCreation.call(this);
    this.isRenderComplete = true;
    setTimeout(() => {
        this.diagramRenderComplete();
    }, 0);
};

CircularMultiSlide.prototype.diagramRenderComplete = function () {
    SimpleLinearDiagram.prototype.diagramRenderComplete.call(this);
};

CircularMultiSlide.prototype.slideDimensionChange = function () {
    this.gotoPage();
};

CircularMultiSlide.prototype.getProperties = function (defaultproperties = {}) {
    let mainProperties = LinearDiagram.prototype.getProperties.call(this, defaultproperties);
    mainProperties.diagramcontent = true;
    return mainProperties;
};

CircularMultiSlide.prototype.updateElements = function (defaultproperties) {
    this.svgHolder = this.diagramParent.querySelector("[id='multislidesvgholder']");
    if (this.diagramParent && this.svgHolder) {
        this.rotation = 75;
        this.rotationOffset = -180;
        this.totalPage = this.orderedNodes.length;
        this.pageIndex = 0;
        this.durationFactor = 0;
        this.delayFactor = 0;

        this.multislideBase = this.diagramParent.querySelector("[id='multislidebase']");
        this.arrShapePoints = Array.from(this.svgHolder.querySelectorAll("[data-id='shapepoint']"));

        this.svgHolder.style.transition = "opacity " + this.animationDuration * this.durationFactor + "s, transform " + this.animationDuration * this.durationFactor + "s " + this.cubicPath + "";
        this.svgHolder.style.transform = "rotate(" + this.rotation + "deg) scale(" + this.defaultscale + ")";
        this.arrShapePoints.map((point) => (point.style.transform = "rotate(" + -this.rotation + "deg)"));
    }
    SimpleLinearDiagram.prototype.updateElements.call(this, defaultproperties);
    this.orderedNodes = this.assignNodes();
    this.textPositions = this.getTextPosition();
    this.gotoPage();
    this.updatePropsCallBack();
};

CircularMultiSlide.prototype.recreateElementData = function () {
    SimpleLinearDiagram.prototype.recreateElementData.call(this);
};

CircularMultiSlide.prototype.setup = function () {
    this.nodecount = this.diagramData.nodes.length;
    let oldBase = this.diagramParent.querySelector("[id='multislidebase']");
    if (oldBase && oldBase.parentElement) oldBase.parentElement.removeChild(oldBase);

    let baseDiv = document.createElement("div");
    baseDiv.id = "multislidebase";
    baseDiv.className = "multislidebase";
    this.diagramParent.appendChild(baseDiv);
    this.multislideBase = baseDiv;

    let svgHolder = document.createElement("div");
    svgHolder.className = "svgholder";
    svgHolder.id = "multislidesvgholder";
    svgHolder.style.width = Math.min(950 * (this.slideWidth / 1280), this.diagramParent.clientHeight * 0.9 * 2) + "px";
    svgHolder.style.height = svgHolder.style.width;
    baseDiv.appendChild(svgHolder);
    this.svgHolder = svgHolder;

    let svg = DiagramNodeUtils.createSVGElement("svg");
    svg.setAttribute("class", "pathsvg");
    let path = DiagramNodeUtils.createSVGElement("path");
    path.setAttribute("class", "shapepath");
    svg.appendChild(path);
    svgHolder.appendChild(svg);

    //rectangle circle
    this.setPath("circle", path);
    this.setShapeAlignment();
    this.arrShapePoints = Array.from(this.svgHolder.querySelectorAll("[data-id='shapepoint']"));
    this.arrDiagramNode.map(
        function (node, i) {
            let point = this.arrShapePoints[i];
            if (point) {
                node.parentNode.setAttribute("data-pointid", point.id);
                point.setAttribute("data-nodeid", node.parentNode.id);
                let iconBG = point.querySelector("[name='iconBG']");
                let useNode = iconBG.querySelector("[data-id='useNode']");
                DiagramUtils.setCustomItemColor(useNode, this.arrTintArray, i, i + 1);
            }
        }.bind(this)
    );
};

CircularMultiSlide.prototype.getJSONData = function (defaultproperties) {
    if (this.arrDiagramNode.length == 0) return this.diagramData;
    let arrNodes = [];
    for (let i = 0; i < this.arrDiagramNode.length; i++) {
        let nodeData = this.arrDiagramNode[i].getJSONData();
        let point = this.multislideBase.querySelector("[data-index='" + i + "']");
        if (point) {
            let contentData = this.getData(point, point.dataset.contentType);
            nodeData.content = contentData;
        } else {
            nodeData.content = JSON.parse(JSON.stringify(this.diagramData.nodes[0]));
            nodeData.content = DiagramNodeUtils.diagramContentData(this.diagramData.properties.contenttype, this.appStaticURL, this.arrDefaults, i);
        }
        arrNodes.push(nodeData);
    }
    return { properties: this.getProperties(defaultproperties), nodes: arrNodes };
};

CircularMultiSlide.prototype.setCircularPosition = function (arrSection, path, baseDiv) {
    let totalLength = path.getTotalLength();
    let sectionLength = totalLength / 4;
    let itemGap = sectionLength / 3;

    let arrPoints = [];
    let index = 0;
    let noOfItem = this.arrDiagramNode.length;
    for (var j = 0; j < noOfItem; j++) {
        let length = itemGap * j;
        length = length == 0 ? 0.00000001 : length;
        length = length > totalLength ? length - totalLength : length;
        let point = path.getPointAtLength(length);
        arrPoints.push(point);
        let div = this.createPoint(point, baseDiv, index);
        index += 1;
    }
};

CircularMultiSlide.prototype.setRectanglePosition = function (arrSection, path, baseDiv) {
    let noOfSection = arrSection.length;
    let sectionLength = path.getTotalLength() / 4;

    let arrPoints = [];
    let index = 1;
    for (var i = 0; i < noOfSection; i++) {
        let noOfItem = arrSection[i].count;
        noOfItem = noOfItem == 2 ? 3 : noOfItem;
        let pointGap = sectionLength / (noOfItem + 1);

        for (var j = 0; j < noOfItem; j++) {
            if (arrSection[i].count != noOfItem && j == 1) continue;
            let length = pointGap * (j + 1) + sectionLength * i;
            length = length == 0 ? 0.00000001 : length;

            let point = path.getPointAtLength(length);
            arrPoints.push(point);
            let div = this.createPoint(point, baseDiv);
            div.innerText = index;
            index += 1;
        }
    }
};

CircularMultiSlide.prototype.createPoint = function (point, parent, i) {
    let div = document.createElement("div");
    div.className = "shapepoint clsMultiColorParent " + "accent" + (i + 1);
    div.setAttribute("data-id", "shapepoint");
    div.id = Math.random();
    parent.appendChild(div);

    div.style.left = point.x - div.clientWidth / 2 + "px";
    div.style.top = point.y - div.clientHeight / 2 + "px";

    let data = this.diagramData.nodes[i] != null ? this.diagramData.nodes[i].content : null;
    if (data == null) {
        data = this.diagramData.nodes[0].content;
    }
    data = DiagramCreateUtil.checkDefaultData(this.diagramParent, data, "icon", this.appStaticURL);

    let bgNodeData = '{"type":"icon","value":"' + "genericassets/shapes/" + this.bgShape + '.svg","id":"shapes/' + this.bgShape + '","dataRef":{"name":"shapes/' + this.bgShape + '"},"contenttype":"icon"}';
    bgNodeData = JSON.parse(bgNodeData);
    DiagramCreateUtil.createIconNode(div, data, "iconHolder", i, this.appStaticURL, bgNodeData, "clsContrastFill", "primary", {}, this.iconLoadCallback.bind(this), this.manifestUpdater);
    // DiagramCreateUtil.updateManifest(data, this.manifestUpdater);
    // DiagramCreateUtil.updateManifest(bgNodeData, this.manifestUpdater);

    div.setAttribute("data-index", i);
    let bgSvg = div.querySelector("[data-id='iconBGNode']");
    bgSvg.firstElementChild.setAttribute("class", "clsAccentfill");
    DiagramUtils.setCustomItemColor(bgSvg.firstElementChild, this.arrTintArray, i, i + 1);
    return div;
};

CircularMultiSlide.prototype.iconLoadCallback = function (nodeData) {
    DiagramCreateUtil.updateManifest(nodeData, this.manifestUpdater, this.appStaticURL);
    try {
        this.updatePropsCallBack();
    } catch (error) {
        console.log("error in updatePropsCallBack iconLoadCallback", error);
    }
};

CircularMultiSlide.prototype.assignNodes = function () {
    return this.arrDiagramNode.reduce((acc, cur, i) => {
        let group = parseInt(i / 3);
        acc[group] ? acc[group].push(cur) : (acc[group] = [cur]);
        return acc;
    }, []);
};

CircularMultiSlide.prototype.circlePath = function (cx, cy, r) {
    return "M " + cx + " " + cy + " m -" + r + ", 0 a " + r + "," + r + " 0 1,0 " + r * 2 + ",0 a " + r + "," + r + " 0 1,0 -" + r * 2 + ",0";
};

CircularMultiSlide.prototype.rectPath = function (rect) {
    let p1 = { x: rect.x, y: rect.y + rect.height / 2 };
    let p2 = { x: rect.x, y: rect.y };
    let p3 = { x: rect.x + rect.width, y: p2.y };
    let p4 = { x: p3.x, y: rect.y + rect.height };
    let p5 = { x: p1.x, y: p4.y };

    return "M " + p1.x + " " + p1.y + "L " + p2.x + " " + p2.y + "L " + p3.x + " " + p3.y + "L " + p4.x + " " + p4.y + "L " + p5.x + " " + p5.y + " Z";
};

CircularMultiSlide.prototype.octPath = function () {};

CircularMultiSlide.prototype.circlePathWithAngle = function (cx, cy, r, deg) {
    var theta = (deg * Math.PI) / 180,
        dx = r * Math.cos(theta),
        dy = -r * Math.sin(theta);
    return "M " + cx + " " + cy + "m " + dx + "," + dy + "a " + r + "," + r + " 0 1,0 " + -2 * dx + "," + -2 * dy + "a " + r + "," + r + " 0 1,0 " + 2 * dx + "," + 2 * dy;
};

CircularMultiSlide.prototype.setPath = function (shape, path) {
    this.orderedNodes = this.assignNodes();
    this.textPositions = this.getTextPosition();

    switch (shape) {
        case "circle":
            let cd = this.circlePathWithAngle(this.svgHolder.clientWidth / 2, this.svgHolder.clientHeight / 2, this.svgHolder.clientHeight / 2, this.rotationOffset);
            path.setAttribute("d", cd);
            this.setCircularPosition(this.orderedNodes, path, this.svgHolder);
            break;
        case "rectangle":
            let rd = this.circlePathWithAngle(this.svgHolder.clientWidth / 2, this.svgHolder.clientHeight / 2, this.svgHolder.clientHeight / 2, this.rotationOffset);
            path.setAttribute("d", rd);
            rd = this.rectPath(path.getBBox());
            path.setAttribute("d", rd);
            this.setRectanglePosition(this.orderedNodes, path, this.svgHolder);
    }
};

CircularMultiSlide.prototype.setShapeAlignment = function (alignment = "rb") {
    switch (alignment) {
        case "lt":
            this.svgHolder.style.top = -(this.svgHolder.clientHeight / 2) + "px";
            this.svgHolder.style.left = -(this.svgHolder.clientWidth / 2) + "px";
            break;
        case "lb":
            this.svgHolder.style.top = this.svgHolder.parentElement.clientHeight - this.svgHolder.clientHeight / 2 + "px";
            this.svgHolder.style.left = -(this.svgHolder.clientWidth / 2) + "px";
            break;
        case "rt":
            this.svgHolder.style.top = -(this.svgHolder.clientHeight / 2) + "px";
            this.svgHolder.style.left = this.svgHolder.parentElement.clientWidth - this.svgHolder.clientWidth / 2 + "px";
            break;
        case "rb":
            this.svgHolder.style.top = this.svgHolder.parentElement.clientHeight - this.svgHolder.clientHeight / 2 + "px";
            this.svgHolder.style.left = this.svgHolder.parentElement.clientWidth - this.svgHolder.clientWidth / 2 + "px";
            break;
        default:
            break;
    }
};

CircularMultiSlide.prototype.setupAnimation = function (animationType = "all", callback) {
    this.animationType = animationType;
    this.animationCompleteCallback = callback;
    this.setupOneAtTimeAnimation(animationType, callback);
};

CircularMultiSlide.prototype.setupOneAtTimeAnimation = function (animationType, callback) {
    this.animationCompleteCallback = callback;
    let moodAnimationDisable = this.diagramParent.parentElement.dataset.moodanimation;
    if (this.animationType == "none" || this.moodData.animationData.multislideAnimation || moodAnimationDisable == "none") {
        this.diagramParent.style.opacity = 1;
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return;
    }

    this.animationFactor = 1;
    this.totalPage = this.orderedNodes.length;
    this.pageIndex = 0;
    this.rotation = 75;
    this.durationFactor = 1;
    this.delayFactor = 1;
    this.animationType = animationType;

    this.svgHolder = this.diagramParent.querySelector("[id='multislidesvgholder']");
    this.svgHolder.style.transition = "unset";
    this.svgHolder.style.transform = "rotate(" + this.rotation + "deg) scale(0)";
    this.diagramParent.style.opacity = 1;
    this.arrDiagramNode.forEach((node) => (node.parentNode.parentElement.style.opacity = 0));

    setTimeout(() => {
        this.svgHolder.style.transition = "opacity " + this.animationDuration * this.durationFactor + "s, transform " + this.animationDuration * this.durationFactor + "s " + this.cubicPath + "";
        this.svgHolder.style.transform = "rotate(" + this.rotation + "deg) scale(1)";
    }, 200);

    setTimeout(() => {
        this.updateNodePosition(this.getVisiblePoints(), false, this.durationFactor, "next");
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, 300);
};

CircularMultiSlide.prototype.playNext = function (index) {
    if (this.pageIndex >= this.orderedNodes.length - 1) return false;
    this.pageIndex += 1;
    this.rotation += 30 * this.orderedNodes[this.pageIndex].length;
    this.updateNodePosition(this.getVisiblePoints(), false, this.durationFactor, "next");

    this.svgHolder.style.transition = "opacity " + this.animationDuration * this.durationFactor + "s, transform " + this.animationDuration * this.durationFactor + "s " + this.cubicPath + "";
    this.svgHolder.style.transform = "rotate(" + this.rotation + "deg) scale(" + this.defaultscale + ")";
    this.arrShapePoints.map((point) => (point.style.transform = "rotate(" + -this.rotation + "deg)"));

    setTimeout(() => {
        if (this.animationCompleteCallback && this.animationType != "none") this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, 700);

    return true;
};

CircularMultiSlide.prototype.playPrevious = function (index) {
    if (this.pageIndex <= 0) return false;
    this.rotation -= 30 * this.orderedNodes[this.pageIndex].length;
    this.pageIndex -= 1;
    this.updateNodePosition(this.getVisiblePoints(), false, this.durationFactor, "previous");

    this.svgHolder.style.transition = "opacity " + this.animationDuration * this.durationFactor + "s, transform " + this.animationDuration * this.durationFactor + "s " + this.cubicPath + "";
    this.svgHolder.style.transform = "rotate(" + this.rotation + "deg) scale(" + this.defaultscale + ")";
    this.arrShapePoints.map((point) => (point.style.transform = "rotate(" + -this.rotation + "deg)"));

    setTimeout(() => {
        if (this.animationCompleteCallback && this.animationType != "none") this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, 700);

    return true;
};

CircularMultiSlide.prototype.isVisibleElement = function (element) {
    return DiagramNodeUtils.isRectInSideRect(this.diagramParent, element);
    let parentRect = this.diagramParent.getBoundingClientRect();
    let elementRect = element.getBoundingClientRect();
    let width = parentRect.x + parentRect.width;
    let height = parentRect.y + parentRect.height;
    return elementRect.x > parentRect.x && elementRect.y > parentRect.y && elementRect.x < width && elementRect.y < height ? true : false;
};

CircularMultiSlide.prototype.getVisiblePoints = function () {
    let pageNodes = this.orderedNodes[this.pageIndex];
    if (!pageNodes) return [[], []];
    let lastVisibleNode = pageNodes.at(-1);
    let lastIndex = parseInt(lastVisibleNode.parentNode.parentElement.dataset.index) + 1;
    let visibleNodes = this.arrDiagramNode.slice(lastIndex - 3, lastIndex);
    let arrPoints = Array.from(this.diagramParent.querySelectorAll("[data-id='shapepoint']"));
    let visiblePoints = arrPoints.slice(lastIndex - 3, lastIndex);
    return [visiblePoints, visibleNodes];
};

CircularMultiSlide.prototype.updateNodePosition = function ([arrVisiblePoint, arrVisibleNodes], isSetup = false, isAnimation = 1, direction = "") {
    let durationFactor = this.durationFactor * isAnimation;
    let delayFactor = this.delayFactor * isAnimation;

    this.svgHolder.style.transition = "opacity " + this.animationDuration * durationFactor + "s, transform " + this.animationDuration * durationFactor + "s " + this.cubicPath + "";
    this.svgHolder.style.transform = "rotate(" + this.rotation + "deg) scale(" + this.defaultscale + ")";
    this.arrShapePoints.map((point) => {
        let isVisible = arrVisiblePoint.includes(point);
        let delay = isVisible ? 0 : isSetup ? 0 : 0.5;

        point.style.transition = "transform " + this.animationDuration * durationFactor + "s " + 0.1 * delayFactor + "s " + this.cubicPath + ", opacity " + this.animationDuration * durationFactor + "s " + delay * delayFactor + "s";
        point.style.transform = "rotate(" + -this.rotation + "deg)";
        point.style.opacity = 1;
        point.style.opacity = isVisible ? 1 : 0;
    });

    this.arrDiagramNode.map((node) => {
        let nodeParent = node.parentNode.parentElement;
        nodeParent.style.opacity = 0;
        nodeParent.style.transition = "opacity " + (this.animationDuration / 2) * durationFactor + "s, transform " + (this.animationDuration / 2) * durationFactor + "s " + this.cubicPath + "";
        nodeParent.style.zIndex = 0;
    });

    this.arrOldVisiblePoints.reverse().forEach((node, i) => {
        let nodeParent = node.parentNode.parentElement;
        nodeParent.style.transition = "opacity " + (this.animationDuration / 2) * durationFactor + "s, transform " + (this.animationDuration / 2) * durationFactor + "s " + 0.1 * i * durationFactor + "s " + this.cubicPath + "";
        nodeParent.style.transform = `translate(-80px, 0px)`;
    });

    setTimeout(() => {
        arrVisibleNodes.forEach((node) => {
            let nodeParent = node.parentNode.parentElement;
            nodeParent.style.transition = "opacity 0s, transform 0s";
            nodeParent.style.transform = `translate(-80px, 0px)`;
        });
    }, (this.animationDuration / 2) * 1000 * delayFactor);

    setTimeout(() => {
        this.arrOldVisiblePoints = arrVisibleNodes;
        arrVisibleNodes.forEach(
            function (node, i) {
                let nodeParent = node.parentNode.parentElement;
                nodeParent.style.transition = "opacity " + (this.animationDuration / 2) * durationFactor + "s " + i * 0.1 * durationFactor + "s, transform " + (this.animationDuration / 2) * durationFactor + "s " + i * 0.1 * durationFactor + "s " + this.cubicPath + "";
                let textRect = this.textPositions[i];
                nodeParent.style.right = textRect.right + "px";
                nodeParent.style.top = textRect.centerY - textRect.height / 2 + "px";
                nodeParent.style.width = textRect.width + "px";
                nodeParent.style.height = textRect.height + "px";
                nodeParent.style.opacity = this.appmode == "DESIGN" || (this.appmode.toLowerCase() == "present" && direction != "") || this.animationType == "none" ? 1 : 0;
                nodeParent.style.zIndex = 1;
                nodeParent.style.transform = `translate(0px, 0px)`;
            }.bind(this)
        );
    }, (this.animationDuration / 2 + 0.1) * 1000 * delayFactor);
};

CircularMultiSlide.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsNodesHolderMultiSlide";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.appendChild(pattenDiv);
    pattenDiv.style.setProperty("--nodeWidth", "100%");
    pattenDiv.style.setProperty("--nodeHeight", "50 !important");
    pattenDiv.style.setProperty("--contentNodeWidth", "0px");
    pattenDiv.style.setProperty("--nodeTopMargin", "unset !important");

    this.createNodeInstances(nodeCount, pattenDiv);
    this.setup();
    this.gotoPage();
    //Cri
};

CircularMultiSlide.prototype.resetHolderWidth = function () {};

CircularMultiSlide.prototype.updateNodeData = function (nodeData, type, index, id) {
    SimpleLinearDiagram.prototype.updateNodeData.call(this, nodeData, type, index);
    let parent = this.multislideBase.querySelector("[id='" + id + "']");
    parent.setAttribute("data-content-type", type);
    let node = parent.querySelector("[data-id='" + type + "Node']") || parent.parentElement.querySelector("[data-id='" + type + "Node']");

    switch (type) {
        case "image":
        case "bgimage":
        case "logo":
            node.src = nodeData.value;
            break;
        case "icon":
            let iconName = DiagramNodeUtils.getIconName({ id: nodeData.id, value: nodeData.value });
            let useNode = node.querySelector("[id='useNode']");
            if (useNode) useNode.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "#" + iconName);
            node.setAttribute("iconid", nodeData.id);
            node.setAttribute("iconpath", nodeData.value);
            break;
        case "text":
        case "number":
        case "microchart":
            node.innerText = nodeData.value;
            break;
        default:
            break;
    }
};

CircularMultiSlide.prototype.setupNavigation = function (navigationContent) {
    navigationContent.imagelist = [];
    let noOfPage = this.orderedNodes.length;
    for (var i = 0; i < noOfPage; i++) {
        navigationContent.imagelist.push({});
    }

    navigationContent.imagestackselectedindex = this.pageIndex;
    return navigationContent;
};

CircularMultiSlide.prototype.navigation = function (navigation) {
    if (navigation.direction == "next") {
        if (this.pageIndex >= this.orderedNodes.length - 1) return false;
        this.pageIndex += 1;
        this.rotation += 30 * this.orderedNodes[this.pageIndex].length;
        this.gotoPage();
    } else if (navigation.direction == "previous") {
        if (this.pageIndex <= 0) return false;
        this.rotation -= 30 * this.orderedNodes[this.pageIndex].length;
        this.pageIndex -= 1;
        this.gotoPage();
    }

    return true;
};

CircularMultiSlide.prototype.gotoPage = function () {
    this.svgHolder = this.diagramParent.querySelector("[id='multislidesvgholder']");
    this.svgHolder.style.transform = `rotate(${this.rotation}deg) scale(${this.defaultscale})`;

    let [arrVisiblePoint, arrVisibleNodes] = this.getVisiblePoints();
    let arrVisibleIndex = arrVisibleNodes.map((node) => node.index);

    let textIndex = 0;
    this.arrShapePoints.map((point, i) => {
        let isVisible = arrVisibleIndex.includes(i);
        point.style.transform = "rotate(" + -this.rotation + "deg)";
        point.style.opacity = isVisible ? 1 : 0;
        point.style.zIndex = isVisible ? 1 : 0;
        point.style.pointerEvents = isVisible ? "all" : "none";

        let nodeParent = this.arrDiagramNode[i]?.parentNode.parentElement;
        if (nodeParent) {
            nodeParent.style.opacity = isVisible ? 1 : 0;
            nodeParent.style.zIndex = isVisible ? 1 : 0;
            nodeParent.classList.remove("moodanimation");
            nodeParent.removeAttribute("data-animation");
            nodeParent.style.transform = "translate(0px, 0px)";

            if (isVisible) {
                let textRect = this.textPositions[textIndex];
                nodeParent.style.right = textRect.right + "px";
                nodeParent.style.top = textRect.centerY - textRect.height / 2 + "px";
                nodeParent.style.width = textRect.width + "px";
                nodeParent.style.height = textRect.height + "px";
                textIndex++;
            }
        }
    });
};

CircularMultiSlide.prototype.getData = function (contentNode, contentType) {
    let node;
    let data = {};
    let dataRef = {};
    node = contentNode.querySelector("[data-id='" + contentType + "Node']");
    switch (contentType) {
        case "image":
        case "logo":
            dataRef = { imageURL: node.src };
            if (node.dataset.csstext) dataRef.cropStyle = node.dataset.csstext;
            if (node.dataset.style) dataRef.cropData = node.dataset.style;
            data = { type: "image", value: node.src, dataRef: dataRef, contenttype: contentType };
            break;
        case "icon":
            let iconid = node.getAttribute("iconid");
            let path = node.getAttribute("iconpath");
            dataRef.name = iconid;
            data = { type: "icon", value: path, id: iconid, dataRef: dataRef, contenttype: contentType };
            break;
        case "text":
        case "number":
        case "microchart":
            let strValue = node.textContent.replace("%", "");
            data = { type: "text", value: strValue, contenttype: contentType };
            break;
        case "checklist":
            data = { type: "text", value: node.dataset.ischecked, contenttype: contentType };
            break;
        default:
            data = { type: "text", value: "", contenttype: contentType };
            break;
    }
    return data;
};

CircularMultiSlide.prototype.addNode = function (nodeData, index, isFromUndo = false) {
    if (this.diagramData.nodes.length >= this.diagramData.properties.maxnode) return;
    SimpleLinearDiagram.prototype.addNode.call(this, nodeData, index, isFromUndo);
    this.initDiagramCreation();
};

CircularMultiSlide.prototype.deleteNode = function (targetIndex) {
    SimpleLinearDiagram.prototype.deleteNode.call(this, targetIndex);
    this.initDiagramCreation();
};

CircularMultiSlide.prototype.initPresent = function (currentSlideData, boolNoAnimation = false) {
    this.diagramParent = currentSlideData.querySelector("[id='diagramparent']");

    this.updateElements();
    this.arrDiagramNode.map((node) => {
        let nodeParent = node.getNodeParent().parentElement;
        nodeParent.removeAttribute("data-animation");
        nodeParent.classList.remove("moodanimation");
        let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
        arrObj.map((item) => {
            item.removeAttribute("data-animation");
            item.classList.remove("moodanimation");
        });
    });
    if (boolNoAnimation) {
        this.diagramParent.style.opacity = 1;
        return { isTitleAnimation: false, isGraphicAnimation: false };
    }

    if (this.diagramParent && !this.moodData?.animationData?.multislideAnimation) this.diagramParent.style.opacity = 0;
    return { isTitleAnimation: true, isGraphicAnimation: false };
};

CircularMultiSlide.prototype.setDiagramSpecficOption = function (obj) {
    obj.dpcontent.slidecomponent = { bgImage: false, takeAwayText: false };
    obj.isDisableLayoutOption = "true";
};

CircularMultiSlide.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable.push("graphicnone");
        mainProperties.floateroptionsdisable.push("sequencetext");
        mainProperties.floateroptionsdisable.push("arrange");
        mainProperties.floateroptionsdisable.push("swap");
    } else mainProperties.floateroptionsdisable = ["graphicnone", "sequencetext", "arrange", "swap"];
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

CircularMultiSlide.prototype.getTextPosition = function () {
    return [
        {
            right: 220 * (this.slideWidth / 1280),
            centerY: 180 * (this.slideWidth / 1280),
            width: 480 * (this.slideWidth / 1280),
            height: 150 * (this.slideWidth / 1280),
        },
        {
            right: 440 * (this.slideWidth / 1280),
            centerY: 375 * (this.slideWidth / 1280),
            width: 480 * (this.slideWidth / 1280),
            height: 150 * (this.slideWidth / 1280),
        },
        {
            right: 560 * (this.slideWidth / 1280),
            centerY: 600 * (this.slideWidth / 1280),
            width: 480 * (this.slideWidth / 1280),
            height: 150 * (this.slideWidth / 1280),
        },
    ];
};

CircularMultiSlide.prototype.createNodeInstances = function (nodeCount, pattenDiv) {
    for (let i = 0; i < nodeCount; i++) {
        let nodeItem = new window[this.nodeProps.nodeclassName](pattenDiv, this.diagramData.properties, this.diagramData.nodes[i], this.eventManagerXY, i, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
        this.createNodeInstanceProperties(nodeItem);
        nodeItem.initCreation(this.isGridAsset(this.nodeProps.name) ? false : i == nodeCount - 1);
        if (nodeItem.multiTextBox && i == 0) {
            this.arrDiagramNode.push(nodeItem);
            return;
        }
        this.arrDiagramNode.push(nodeItem);
    }
    let placeholderType = this.nodeProps?.centerShape?.placeholdertype;
    if (!placeholderType) DiagramUtils.searchMultipleAICall(this.arrDiagramNode, this.diagramData.properties.contenttype, this.diagramData.properties, this.globalMoodData, this.searchIconCallBack, appBaseURL, this.appStaticURL, this.multipleSearchCallBack.bind(this));
};

CircularMultiSlide.prototype.multipleSearchCallBack = function (objResponse, objParams) {
    let { arrDiagramNode, staticURL, arrIndex, type, searchCallBack, properties } = objParams;

    objResponse?.data?.forEach((objData, objIndex) => {
        let index = arrIndex[objIndex];
        let nodeData = arrDiagramNode[index]?.objData?.content;
        let shapePoint = this.multislideBase.querySelector("[data-id='shapepoint'][data-index='" + index + "']");
        let assetNode = shapePoint?.querySelector("[data-id='logoNode']") || shapePoint?.querySelector("[data-id='imageNode']") || shapePoint?.querySelector("[data-id='iconNode']");

        if (assetNode && assetNode.parentElement && nodeData.assetText) {
            assetNode.parentElement.setAttribute("data-node-graphic-text", nodeData.assetText);
            let updateProps = objIndex == objResponse.data.length - 1;
            DiagramUtils.searchAICallback({ data: [objData] }, { staticURL, contentNode: assetNode, index: index, type, searchCallBack, properties, updateProps });
        }
    });
};

/**
 * Author:    Krishna prabhu M
 * Created:   8 Jan 20
 *
 * (c) Copyright by Gs.
 **/

"use strict";

//CircularMultiSlide
function HexagonMultislide(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    CircularMultiSlide.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "clsLinerDiagram clsHexDiagram clsNonHover";
    this.pageIndex = 0;
    this.totalPage = 0;
    this.rotation = 0;
    this.rotationOffset = 120;
    this.bgShape = "hexagon";
    this.defaultscale = 1;

    this.animationDuration = 1.4;
    this.cubicPath = "cubic-bezier(.65,0,.25,1)";
}

HexagonMultislide.prototype = Object.create(CircularMultiSlide.prototype);
HexagonMultislide.prototype.constructor = HexagonMultislide;

HexagonMultislide.prototype.initDiagramCreation = function () {
    this.isRenderComplete = false;
    this.diagramParent.parentElement.setAttribute("data-animationtype", "one");
    while (this.diagramData.nodes.length < 2) {
        let data = JSON.parse(JSON.stringify(this.diagramData.nodes[0]));
        this.diagramData.nodes.push(data);
    }
    this.pageIndex = 0;
    this.totalPage = 0;
    this.rotation = 0;
    SimpleLinearDiagram.prototype.initDiagramCreation.call(this);
    this.isRenderComplete = true;
    setTimeout(() => {
        this.diagramRenderComplete();
    }, 0);
};

HexagonMultislide.prototype.slideDimensionChange = function () {
    if (this.diagramParent) {
        // this.setup();
        this.rotation = 0;
        this.pageIndex = 0;
        this.gotoPage();
    }
};

HexagonMultislide.prototype.setup = function () {
    this.nodecount = this.diagramData.nodes.length;
    let oldBase = this.diagramParent.querySelector("[id='multislidebase']");
    if (oldBase && oldBase.parentElement) oldBase.parentElement.removeChild(oldBase);

    let baseDiv = document.createElement("div");
    baseDiv.id = "multislidebase";
    baseDiv.className = "multislidebase";
    this.diagramParent.appendChild(baseDiv);
    this.multislideBase = baseDiv;

    let svgHolder = document.createElement("div");
    svgHolder.className = "svgholder";
    svgHolder.id = "multislidesvgholder";
    svgHolder.style.height = this.diagramParent.clientHeight * 0.9 + "px";
    svgHolder.style.width = this.diagramParent.clientHeight * 0.9 + "px";
    baseDiv.appendChild(svgHolder);
    this.svgHolder = svgHolder;

    let svg = DiagramNodeUtils.createSVGElement("svg");
    svg.setAttribute("class", "pathsvg");
    let path = DiagramNodeUtils.createSVGElement("path");
    path.setAttribute("class", "shapepath");
    svg.appendChild(path);
    svgHolder.appendChild(svg);

    //rectangle circle
    this.setPath("circle", path);
    this.setShapeAlignment();
    this.arrShapePoints = Array.from(this.svgHolder.querySelectorAll("[data-id='shapepoint']"));
    this.arrDiagramNode.map(
        function (node, i) {
            let point = this.arrShapePoints[i];
            if (point) {
                node.parentNode.setAttribute("data-pointid", point.id);
                point.setAttribute("data-nodeid", node.parentNode.id);
                let iconBG = point.querySelector("[name='iconBG']");
                let useNode = iconBG.querySelector("[data-id='useNode']");
                DiagramUtils.setCustomItemColor(useNode, this.arrTintArray, i, i + 1);
            }
        }.bind(this)
    );
};

HexagonMultislide.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsNodesHolderMultiSlide";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.appendChild(pattenDiv);
    pattenDiv.style.setProperty("--nodeWidth", "100%");
    pattenDiv.style.setProperty("--nodeHeight", "50 !important");
    pattenDiv.style.setProperty("--contentNodeWidth", "0px");
    pattenDiv.style.setProperty("--nodeTopMargin", "unset !important");

    this.createNodeInstances(nodeCount, pattenDiv);
    this.setup();
    this.gotoPage();
    //Cri
};

HexagonMultislide.prototype.updateElements = function (defaultproperties) {
    this.svgHolder = this.diagramParent.querySelector("[id='multislidesvgholder']");
    if (this.diagramParent && this.svgHolder) {
        this.pageIndex = 0;
        this.rotation = 0;
        this.rotationOffset = 120;
        this.bgShape = "hexagon";
        this.durationFactor = 0;
        this.delayFactor = 0;

        this.multislideBase = this.diagramParent.querySelector("[id='multislidebase']");
        this.arrShapePoints = Array.from(this.svgHolder.querySelectorAll("[data-id='shapepoint']"));
    }
    SimpleLinearDiagram.prototype.updateElements.call(this, defaultproperties);
    this.orderedNodes = this.assignNodes();
    this.textPositions = this.getTextPosition();

    this.gotoPage();
    this.updatePropsCallBack();
};

HexagonMultislide.prototype.setCircularPosition = function (arrSection, path, baseDiv) {
    let noOfSection = this.arrDiagramNode.length < 6 ? 6 : this.arrDiagramNode.length;
    let totalLength = path.getTotalLength();
    let gap = totalLength / 6;

    let arrPoints = [];
    let gapMultiplier = 0;
    for (var i = 0; i < noOfSection; i++) {
        let length = gap * gapMultiplier;
        if (length > totalLength) {
            gapMultiplier = 1;
            length = gap * gapMultiplier;
        }
        length = length == 0 ? 0.00000001 : length;

        let point = path.getPointAtLength(length);
        arrPoints.push(point);
        let div = this.createPoint(point, baseDiv, i);
        let pageIndex = Math.floor(i / 2);
        div.setAttribute("data-pageindex", pageIndex);
        gapMultiplier += 1;
    }

    this.totalPage = this.orderedNodes.length;
};

HexagonMultislide.prototype.setPath = function (shape, path) {
    this.orderedNodes = this.assignNodes();
    this.textPositions = this.getTextPosition();

    switch (shape) {
        case "circle":
            let cd = this.circlePathWithAngle(this.svgHolder.clientWidth / 2, this.svgHolder.clientHeight / 2, this.svgHolder.clientHeight / 2.7, this.rotationOffset);
            path.setAttribute("d", cd);
            this.setCircularPosition(this.orderedNodes, path, this.svgHolder);
            break;
        case "rectangle":
            let rd = this.circlePathWithAngle(this.svgHolder.clientWidth / 2, this.svgHolder.clientHeight / 2, this.svgHolder.clientHeight / 2, this.rotationOffset);
            path.setAttribute("d", rd);
            rd = this.rectPath(path.getBBox());
            path.setAttribute("d", rd);
            this.setRectanglePosition(this.orderedNodes, path, this.svgHolder);
    }
};

HexagonMultislide.prototype.circlePathWithAngle = function (cx, cy, r, deg) {
    var theta = (deg * Math.PI) / 180,
        dx = r * Math.cos(theta),
        dy = -r * Math.sin(theta);
    return "M " + cx + " " + cy + "m " + dx + "," + dy + "a " + r + "," + r + " 0 1,1 " + -2 * dx + "," + -2 * dy + "a " + r + "," + r + " 0 1,1 " + 2 * dx + "," + 2 * dy;
};

HexagonMultislide.prototype.createPoint = function (point, parent, i) {
    let div = document.createElement("div");
    div.className = "shapepoint clsMultiColorParent " + "accent" + (i + 1);
    div.setAttribute("data-id", "shapepoint");
    div.id = Math.random();
    parent.appendChild(div);

    div.style.left = point.x - div.clientWidth / 2 + "px";
    div.style.top = point.y - div.clientHeight / 2 + "px";

    let data = this.diagramData.nodes[i] != null ? this.diagramData.nodes[i].content : null;
    if (!data) {
        data = this.diagramData.nodes[0].content;
    }
    data = DiagramCreateUtil.checkDefaultData(this.diagramParent, data, "icon", this.appStaticURL);

    let bgNodeData = '{"type":"icon","value":"genericassets/shapes/hexagon.svg","id":"shapes/hexagon","dataRef":{"name":"shapes/hexagon"},"contenttype":"icon"}';
    bgNodeData = JSON.parse(bgNodeData);
    DiagramCreateUtil.createIconNode(div, data, "iconHolder", i, this.appStaticURL, bgNodeData, "clsContrastFill", "primary", {}, this.iconLoadCallback.bind(this), this.manifestUpdater);
    // DiagramCreateUtil.updateManifest(data, this.manifestUpdater);
    // DiagramCreateUtil.updateManifest(bgNodeData, this.manifestUpdater);

    div.setAttribute("data-index", i);
    let bgSvg = div.querySelector("[data-id='iconBGNode']");
    bgSvg.firstElementChild.setAttribute("class", "clsAccentfill");
    DiagramUtils.setCustomItemColor(bgSvg.firstElementChild, this.arrTintArray, i, i + 1);
    return div;
};

HexagonMultislide.prototype.setShapeAlignment = function (alignment = "ct") {
    this.svgHolder.style.bottom = -180 * (this.slideWidth / 1280) + "px";
    this.svgHolder.style.left = -80 * (this.slideWidth / 1280) + "px";
};

HexagonMultislide.prototype.setupOneAtTimeAnimation = function (animationType, callback) {
    let moodAnimationDisable = this.diagramParent.parentElement.dataset.moodanimation;
    if (this.animationType == "none" || this.moodData.animationData.multislideAnimation || moodAnimationDisable == "none") {
        this.diagramParent.style.opacity = 1;
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return;
    }

    this.pageIndex = 0;
    this.rotation = 0;
    this.animationType = animationType;
    this.animationCompleteCallback = callback;
    this.totalPage = this.orderedNodes.length;
    this.diagramParent.style.opacity = 1;
    this.durationFactor = 1;
    this.delayFactor = 1;

    this.svgHolder = this.diagramParent.querySelector("[id='multislidesvgholder']");
    this.svgHolder.style.transition = "unset";
    this.svgHolder.style.transform = "rotate(" + this.rotation + "deg) scale(0)";
    this.arrDiagramNode.forEach((node) => (node.parentNode.parentElement.style.opacity = 0));

    setTimeout(() => {
        this.svgHolder.style.transition = `opacity ${this.animationDuration * this.durationFactor}s, transform ${this.animationDuration * this.durationFactor}s ${this.cubicPath}`;
        this.svgHolder.style.transform = `rotate(${this.rotation}deg) scale(${this.defaultscale})`;
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, 100);

    setTimeout(() => {
        this.updateNodePosition(this.getVisiblePoints(), this.durationFactor != 0, "next");
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, 200);
};

HexagonMultislide.prototype.playNext = function (index) {
    this.totalPage = this.orderedNodes.length;
    if (this.pageIndex >= this.totalPage - 1) return false;
    this.pageIndex += 1;
    this.rotation = -(180 * this.pageIndex - (3 - this.orderedNodes[this.pageIndex].length) * 60);
    this.updateNodePosition(this.getVisiblePoints(), this.durationFactor != 0, "next");
    if (this.animationCompleteCallback && this.animationType != "none") this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    return true;
};

HexagonMultislide.prototype.playPrevious = function (index) {
    this.totalPage = this.orderedNodes.length;
    if (this.pageIndex <= 0) return false;
    this.pageIndex -= 1;
    this.rotation = -(180 * this.pageIndex - (3 - this.orderedNodes[this.pageIndex].length) * 60);
    this.updateNodePosition(this.getVisiblePoints(), this.durationFactor != 0, "previous");
    if (this.animationCompleteCallback && this.animationType != "none") this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    return true;
};

HexagonMultislide.prototype.gotoPage = function () {
    this.svgHolder = this.diagramParent.querySelector("[id='multislidesvgholder']");
    this.svgHolder.style.transform = `rotate(${this.rotation}deg) scale(${this.defaultscale})`;

    let [arrVisiblePoint, arrVisibleNodes] = this.getVisiblePoints();
    let arrVisibleIndex = arrVisibleNodes.map((node) => node.index);

    let textIndex = 0;
    this.arrShapePoints.map((point, i) => {
        let isVisible = arrVisibleIndex.includes(i);
        let iconNode = point.querySelector("[data-id='iconNode']");
        iconNode.style.opacity = isVisible ? 1 : 0;
        point.style.transform = "rotate(" + -this.rotation + "deg)";
        point.style.opacity = isVisible ? 1 : 0.3;
        point.style.zIndex = isVisible ? 1 : 0;
        point.style.pointerEvents = isVisible ? "all" : "none";

        let nodeParent = this.arrDiagramNode[i]?.parentNode.parentElement;
        if (nodeParent) {
            nodeParent.style.opacity = isVisible ? 1 : 0;
            nodeParent.style.zIndex = isVisible ? 1 : 0;
            nodeParent.classList.remove("moodanimation");
            nodeParent.removeAttribute("data-animation");
            nodeParent.style.transform = "translate(0px, 0px)";

            if (isVisible) {
                let textRect = this.textPositions[textIndex];
                nodeParent.style.left = textRect.left + "px";
                nodeParent.style.top = textRect.centerY - textRect.height / 2 + "px";
                nodeParent.style.width = textRect.width + "px";
                nodeParent.style.height = textRect.height + "px";

                let group = nodeParent.querySelector("[name='nodeGroup']");
                group.style.justifyContent = textRect.position;
                textIndex++;
            }
        }
    });
};

HexagonMultislide.prototype.updateNodePosition = function ([arrVisiblePoint, arrVisibleNodes], isAnimation = true, direction = "") {
    let durationFactor = isAnimation ? this.durationFactor : 0;
    let delayFactor = isAnimation ? this.delayFactor : 0;

    this.svgHolder = this.diagramParent.querySelector("[id='multislidesvgholder']");
    this.svgHolder.style.transition = `opacity ${this.animationDuration * durationFactor}s, transform ${this.animationDuration * durationFactor}s ${this.cubicPath}`;
    this.svgHolder.style.transform = `rotate(${this.rotation}deg) scale(${this.defaultscale})`;

    this.arrShapePoints.map((point, i) => {
        let iconNode = point.querySelector("[data-id='iconNode']");
        iconNode.style.transition = `transform ${(this.animationDuration / 2) * durationFactor}s ${this.cubicPath} ${0.1 * durationFactor}s, opacity ${(this.animationDuration / 2) * durationFactor}s ${0.1 * durationFactor}s`;
        iconNode.style.opacity = 0;
        if (durationFactor != 0) iconNode.style.transform = "rotate(" + -this.rotation + "deg)";
        point.style.transition = `transform ${(this.animationDuration / 2) * durationFactor}s ${this.cubicPath}, opacity ${(this.animationDuration / 2) * durationFactor}s`;
        if (durationFactor == 0) point.style.transform = "rotate(" + -this.rotation + "deg)";
        point.style.zIndex = 0;
        point.style.opacity = i < 6 ? 0.3 : 0;
        point.style.pointerEvents = "none";
    });

    this.arrDiagramNode.map((node) => {
        node.parentNode.parentElement.style.opacity = 0;
        node.parentNode.parentElement.style.transition = `transform ${(this.animationDuration / 2) * durationFactor}s ${this.cubicPath}, opacity ${(this.animationDuration / 2) * durationFactor}s`;
        node.parentNode.parentElement.style.transform = "translate(80px, 0px)";
        node.parentNode.parentElement.style.zIndex = 0;
        node.parentNode.parentElement.classList.remove("moodanimation");
        node.parentNode.parentElement.removeAttribute("data-animation");
    });

    this.arrOldVisiblePoints.reverse().map((node, i) => {
        let nodeParent = node.parentNode.parentElement;
        nodeParent.style.transition = `transform ${(this.animationDuration / 2) * durationFactor}s ${this.cubicPath} ${0.1 * i * durationFactor}s, opacity ${(this.animationDuration / 2) * durationFactor}s ${0.1 * i * durationFactor}s`;
        nodeParent.style.transform = "translate(80px, 0px)";
        nodeParent.style.opacity = 0;
    });

    setTimeout(() => {
        arrVisibleNodes.forEach((node) => {
            let nodeParent = node.parentNode.parentElement;
            nodeParent.style.transition = "opacity 0s, transform 0s";
            nodeParent.style.transform = `translate(80px, 0px)`;
        });
    }, (this.animationDuration / 2 + 0.2) * 1000 * delayFactor);

    setTimeout(() => {
        this.arrOldVisiblePoints = arrVisibleNodes;
        arrVisibleNodes.map(
            function (node, i) {
                let point = arrVisiblePoint[i];
                let iconNode = point.querySelector("[data-id='iconNode']");
                iconNode.style.transition = `transform ${(this.animationDuration / 2) * durationFactor}s ${this.cubicPath}, opacity ${(this.animationDuration / 2) * durationFactor}s`;
                // iconNode.style.transform = "rotate(" + -this.rotation + "deg) scale(1)";
                iconNode.style.opacity = this.appmode == "DESIGN" || (this.appmode.toLowerCase() == "present" && direction != "") || this.animationType == "none" ? 1 : 0;
                point.style.pointerEvents = "all";
                point.style.opacity = 1;
                point.style.zIndex = 1;

                let nodeParent = node.parentNode.parentElement;
                nodeParent.style.zIndex = 1;
                nodeParent.style.opacity = this.appmode == "DESIGN" || (this.appmode.toLowerCase() == "present" && direction != "") || this.animationType == "none" ? 1 : 0;
                nodeParent.style.transform = "translate(0px, 0px)";
                nodeParent.style.transition = `transform ${(this.animationDuration / 2) * durationFactor}s ${this.cubicPath} ${0.1 * i * durationFactor}s, opacity ${(this.animationDuration / 2) * durationFactor}s ${0.1 * i * durationFactor}s`;

                let textRect = this.textPositions[i];
                nodeParent.style.left = textRect.left + "px";
                nodeParent.style.top = textRect.centerY - textRect.height / 2 + "px";
                nodeParent.style.width = textRect.width + "px";
                nodeParent.style.height = textRect.height + "px";

                let group = nodeParent.querySelector("[name='nodeGroup']");
                group.style.justifyContent = textRect.position;
            }.bind(this)
        );
    }, (this.animationDuration / 2 + 0.3) * 1000 * durationFactor);
};

HexagonMultislide.prototype.setupNavigation = function (navigationContent) {
    navigationContent.imagelist = [];
    let noOfPage = this.orderedNodes.length;

    for (var i = 0; i < noOfPage; i++) {
        navigationContent.imagelist.push({});
    }

    navigationContent.imagestackselectedindex = this.pageIndex;
    return navigationContent;
};

HexagonMultislide.prototype.navigation = function (navigation) {
    if (navigation.direction == "next") {
        this.totalPage = this.orderedNodes.length;
        if (this.pageIndex >= this.totalPage - 1) return false;
        this.pageIndex += 1;
        this.rotation = -(180 * this.pageIndex - (3 - this.orderedNodes[this.pageIndex].length) * 60);
        this.gotoPage();
    } else if (navigation.direction == "previous") {
        this.totalPage = this.orderedNodes.length;
        if (this.pageIndex <= 0) return false;
        this.pageIndex -= 1;
        this.rotation = -(180 * this.pageIndex - (3 - this.orderedNodes[this.pageIndex].length) * 60);
        this.gotoPage();
    }

    return true;
};

HexagonMultislide.prototype.initPresent = function (currentSlideData, boolNoAnimation = false) {
    this.diagramParent = currentSlideData.querySelector("[id='diagramparent']");
    this.updateElements();
    this.arrDiagramNode.map((node) => {
        let nodeParent = node.getNodeParent().parentElement;
        nodeParent.removeAttribute("data-animation");
        nodeParent.classList.remove("moodanimation");
        let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
        arrObj.map((item) => {
            item.removeAttribute("data-animation");
            item.classList.remove("moodanimation");
        });
    });
    if (boolNoAnimation) {
        this.diagramParent.style.opacity = 1;
        return { isTitleAnimation: false, isGraphicAnimation: false };
    }
    if (this.diagramParent && !this.moodData?.animationData?.multislideAnimation) this.diagramParent.style.opacity = 0;
    return { isTitleAnimation: true, isGraphicAnimation: false };
};

HexagonMultislide.prototype.getTextPosition = function () {
    return [
        {
            left: 640 * (this.slideWidth / 1280),
            centerY: 572 * (this.slideWidth / 1280),
            width: 480 * (this.slideWidth / 1280),
            height: 150 * (this.slideWidth / 1280),
            position: "center",
        },
        {
            left: 520 * (this.slideWidth / 1280),
            centerY: 365 * (this.slideWidth / 1280),
            width: 480 * (this.slideWidth / 1280),
            height: 150 * (this.slideWidth / 1280),
            position: "center",
        },
        {
            left: 120 * (this.slideWidth / 1280),
            centerY: 140 * (this.slideWidth / 1280),
            width: 480 * (this.slideWidth / 1280),
            height: 150 * (this.slideWidth / 1280),
            position: "flex-end",
        },
    ].reverse();
};

/**
 * Author:    Krishna
 * Created:   20 fri march 2020
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function LinearCircularDiagram(diagramParent, diagramData, nodeProps, moodData = {}) {
    SimpleLinearVerticalDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "clsCircularDiagram";
    this.circleParent = null;
    this.centerNode = null;
    this.circleRadius = 0;
    this.centerContentType = this.nodeProps.centernodetype ? this.nodeProps.centernodetype : "icon";
    this.centerHolderNode = null;
    this.isRenderComplete = false;
    this.arrArrowPath = [];
    this.radius = 0;
    this.commonNodeSizeRatio = 1;
    this.centerNodeClass = "CommonDiagramNode";
    this.diagramParent.setAttribute("data-connectortoggle", "false");
    this.arrowColor = "var(--circular-stroke-color)";
}

LinearCircularDiagram.prototype = Object.create(SimpleLinearVerticalDiagram.prototype);

LinearCircularDiagram.prototype.initDiagramCreation = function () {
    if (!this.diagramParent.dataset.contenttype) {
        this.diagramParent.setAttribute("data-contenttype", this.diagramData.properties.contenttype);
        this.setHolderType(this.diagramData.properties.contenttype, "contentNode");
    }
    SimpleLinearVerticalDiagram.prototype.initDiagramCreation.call(this);
    this.diagramParent.setAttribute("data-resizelogo", "false");
    // if (this.diagramData?.properties?.commonnodesize) this.commonNodeSizeChange({ value: this.diagramData.properties.commonnodesize });
};

LinearCircularDiagram.prototype.diagramInitComplete = function () {
    this.diagramParent.setAttribute("data-diagramtype", "horizontal");
    SimpleLinearVerticalDiagram.prototype.diagramInitComplete.call(this);
    this.diagramParent.style.opacity = 1;
};

LinearCircularDiagram.prototype.diagramRenderComplete = function () {
    if (!this.isRenderComplete) {
        this.diagramParent.style.opacity = 1;
        return;
    }
    LinearDiagram.prototype.diagramRenderComplete.call(this);
};

LinearCircularDiagram.prototype.checkConnectorVisible = function () {};

LinearCircularDiagram.prototype.init = function () {
    if (this.nodeProps.iconvisible && this.nodeProps.iconvisible == "false") this.diagramParent.className = "clsCircularDiagram hideIcon";
    if (this.circleParent != null && this.circleParent.parentElement) {
        this.circleParent.parentElement.removeChild(this.circleParent);
        this.circleParent = null;
    }
    this.setupLinearCircularDiagram(this.diagramParent, this.diagramData);
    this.isRenderComplete = true;
    this.diagramRenderComplete();
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
};

LinearCircularDiagram.prototype.slideDimensionChange = function () {
    this.updateNodePosition();
};

LinearCircularDiagram.prototype.addNode = function (nodeData, index, isFromUndo = false) {
    SimpleLinearVerticalDiagram.prototype.addNode.call(this, nodeData, index, isFromUndo);
    this.updateNodePosition();
};

LinearCircularDiagram.prototype.deleteNode = function (index) {
    SimpleLinearVerticalDiagram.prototype.deleteNode.call(this, index);
    this.updateNodePosition();
};

LinearCircularDiagram.prototype.updateCustomProperties = function (customproperties) {
    let circleCustomproperties = customproperties ? customproperties : {};
    this.diagramParent.setAttribute("data-circle-outeranglegap", circleCustomproperties.outeranglegap ? circleCustomproperties.outeranglegap : 0);
    this.diagramParent.setAttribute("data-circle-innerradius", circleCustomproperties.innerradius ? circleCustomproperties.innerradius : 0);
    this.diagramParent.setAttribute("data-circle-bgtype", circleCustomproperties.bgtype ? circleCustomproperties.bgtype : "none");
    this.diagramParent.setAttribute("data-circle-nodeitemoffset", circleCustomproperties.nodeitemoffset ? circleCustomproperties.nodeitemoffset : 20);
    this.diagramParent.setAttribute("data-circle-innercontent", circleCustomproperties.innercontent ? circleCustomproperties.innercontent : false);
    this.diagramParent.setAttribute("data-circle-innercontentoffset", circleCustomproperties.innercontentoffset ? circleCustomproperties.innercontentoffset : 20);
    this.diagramParent.setAttribute("data-circle-innercontentsize", circleCustomproperties.innercontentsize ? circleCustomproperties.innercontentsize : 50);
    this.diagramParent.setAttribute("data-circle-innercontenttype", circleCustomproperties.innercontenttype ? circleCustomproperties.innercontenttype : "icon");
    this.diagramParent.setAttribute("data-circle-contentsize", circleCustomproperties.contentsize ? circleCustomproperties.contentsize : 50);
    this.diagramParent.setAttribute("data-circle-content", circleCustomproperties.content && circleCustomproperties.content == true ? true : false);
    this.diagramParent.setAttribute("data-circle-contentbg", circleCustomproperties.contentbg && circleCustomproperties.contentbg == true ? true : false);
    this.diagramParent.setAttribute("data-circle-style", circleCustomproperties.style ? circleCustomproperties.style : "ring");
    this.diagramParent.setAttribute("data-circle-contentresizable", circleCustomproperties.contentresizable && circleCustomproperties.contentresizable == true ? true : false);

    if (customproperties.innercontentdata) {
        this.diagramParent.setAttribute("data-circle-innercontentvalue", circleCustomproperties.innercontentdata.content.value || "");
        this.diagramParent.setAttribute("data-circle-innercontentid", circleCustomproperties.innercontentdata.content.id || "");
    }
};

LinearCircularDiagram.prototype.getCustomProperties = function () {
    let customproperties = {};
    customproperties.outeranglegap = parseInt(this.diagramParent.dataset.circleOuteranglegap) || 0;
    customproperties.innerradius = parseInt(this.diagramParent.dataset.circleInnerradius) || 0;
    customproperties.nodeitemoffset = parseInt(this.diagramParent.dataset.circleNodeitemoffset) || 20;
    customproperties.innercontentoffset = parseInt(this.diagramParent.dataset.circleInnercontentoffset) || 20;
    customproperties.logosize = parseInt(this.diagramParent.dataset.circleContentsize) || 50;
    customproperties.innercontentsize = parseInt(this.diagramParent.dataset.circleInnercontentsize) || 20;

    customproperties.bgtype = this.diagramParent.dataset.circleBgtype || "none";
    customproperties.innercontenttype = this.diagramParent.dataset.circleInnercontenttype || "icon";
    customproperties.style = this.diagramParent.dataset.circleStyle || "ring";

    customproperties.innercontent = this.diagramParent.dataset.circleInnercontent == "true";
    customproperties.content = this.diagramParent.dataset.circleContent == "true";
    customproperties.contentbg = this.diagramParent.dataset.circleContentbg == "true";
    customproperties.contentresizable = this.diagramParent.dataset.circleContentresizable == "true";

    if (customproperties.innercontentdata == null) {
        let value = this.diagramParent.dataset.circleInnercontentvalue || "";
        let id = this.diagramParent.dataset.circleInnercontentid || "";
        customproperties.innercontentdata = { content: { type: customproperties.innercontenttype, value: value, id: id } };
    }
    return customproperties;
};

LinearCircularDiagram.prototype.updateElements = function (defaultproperties) {
    this.centerNode = this.diagramParent.querySelector("div[data-id='centerNode']");
    this.circleParent = this.diagramParent.querySelector("[id='circularbase']");
    SimpleLinearVerticalDiagram.prototype.updateElements.call(this, defaultproperties);
    if (this.appmode == "PRESENT") return;
    this.isReverse = this.diagramParent.dataset.isreverse === "true";
    this.isFlip = this.diagramParent.dataset.isflip === "true";
    this.isLineConnector = this.diagramParent.dataset.islineconnector === "true";
    if (this.centerNode) this.createCenterElements(this.centerNode, this.diagramData?.properties || {}, true);
    if (this.diagramParent.dataset?.commonnodesize) this.commonNodeSizeChange({ value: this.diagramParent.dataset.commonnodesize });
    if (this.diagramParent.dataset?.strokewidth && this.diagramParent.dataset?.strokewidthindex) this.updateConnectorWidth({ data: this.diagramParent.dataset.strokewidth, index: this.diagramParent.dataset.strokewidthindex });
    if (this.diagramParent.dataset?.dasharray && this.diagramParent.dataset?.dasharrayindex) this.updateConnectorDasharray({ data: this.diagramParent.dataset.dasharray, index: this.diagramParent.dataset.dasharrayindex });
    if (this.diagramParent.dataset?.connectorstart && this.diagramParent.dataset?.connectorstartindex) this.updateConnetorStart({ data: this.diagramParent.dataset.connectorstart, index: this.diagramParent.dataset.connectorstartindex });
    if (this.diagramParent.dataset?.connectorend && this.diagramParent.dataset?.connectorendindex) this.updateConnetorEnd({ data: this.diagramParent.dataset.connectorend, index: this.diagramParent.dataset.connectorendindex });
};

LinearCircularDiagram.prototype.setupLinearCircularDiagram = function (parent, data, iconChangeCallback, textBoxData) {
    let oldBase = this.diagramParent.querySelector("[id='circularbase']");
    if (oldBase) this.diagramParent.removeChild(oldBase);

    let baseDiv = document.createElement("div");
    baseDiv.className = "circularbase clsMultiColorParent accent1  ";
    baseDiv.id = "circularbase";
    baseDiv.setAttribute("data-displayname", "circular");
    this.diagramParent.appendChild(baseDiv);
    this.circleParent = baseDiv;

    let svg = DiagramNodeUtils.createSVGElement("svg");
    svg.setAttribute("width", baseDiv.clientWidth);
    svg.setAttribute("height", baseDiv.clientHeight);
    svg.setAttribute("id", "svgbase");
    svg.setAttribute("class", "svgbase");
    svg.setAttribute("opacity", 0);
    baseDiv.appendChild(svg);

    let path = DiagramNodeUtils.createSVGElement("path");
    let svgRect = { width: baseDiv.clientWidth, height: baseDiv.clientHeight };
    let { radius, centerX, centerY } = this.getCircleInfo(svgRect);
    let d = DiagramNodeUtils.circlePathWithAngle(centerX, centerY, radius, 0);
    path.setAttribute("d", d);
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", "gray");
    path.setAttribute("stroke-width", "2");
    svg.appendChild(path);

    if (this.nodeProps.centernodevisible && this.nodeProps.centernodevisible == "true") {
        let div = this.setCenterPlaceHolder(baseDiv, this.getCenterHolderSize());
        this.centerNode = div;
        div.style.top = centerY - div.clientHeight / 2 + "px";
    }

    this.updateNodePosition();

    return;
};

LinearCircularDiagram.prototype.getCenterHolderSize = function () {
    let svgRect = { width: this.circleParent.clientWidth, height: this.circleParent.clientHeight };
    this.getCircleInfo(svgRect);
    let width = this.radius * this.commonNodeSizeRatio;
    return { width: width, height: width };
};

LinearCircularDiagram.prototype.updateNodePosition = function () {
    let baseDiv = this.diagramParent.querySelector("[id='circularbase']");
    if (!baseDiv) return;

    let centerNode = baseDiv.querySelector("[data-id='centerNode']");
    if (centerNode) {
        let size = this.getCenterHolderSize();
        centerNode.style.width = size.width + "px";
        centerNode.style.height = size.height + "px";

        let centerHolder = this.diagramParent.querySelector("[name='centerHolderParent']");
        let contentType = centerHolder.dataset.type;
        let imageNode = centerHolder.querySelector("img[data-id='imageNode'],img[data-id='logoNode']");
        if (imageNode) CommonImageUtils.updateImageBounds(imageNode, { islogofit: contentType == "logo", contenttype: contentType }, 1);
    }

    let svgRect = { width: baseDiv.clientWidth, height: baseDiv.clientHeight };
    let { radius, centerX, centerY, contentNodeHeight } = this.getCircleInfo(svgRect);
    if (this.centerNode) this.centerNode.style.top = centerY - this.centerNode.clientHeight / 2 + "px";

    let count = this.diagramData.nodes.length;
    let angleDif = 360 / count;
    let arrAlignClassname = ["circularAlignLeft", "circularAlignRight", "circularAlignTop"];
    let arrTextAlignClassname = ["circularTextAlignTop", "circularTextAlignBottom"];

    let pathOffset = 20; //this.nodeProps.pathoffset ? parseFloat(this.nodeProps.pathoffset) : 0;

    let top = 0;
    let bottom = 0;

    this.arrDiagramNode.map(
        function (nodeObj, i) {
            let node = nodeObj.getNodeParent().parentElement;
            if (node) {
                let angle = angleDif * i + this.getAngleBaseOnNodeCount();
                let iconCenterPoint = this.polarToCartesian(centerX, centerY, radius, angle);
                node.setAttribute("data-angle", angle);

                let contentNode = node.querySelector("[name='contentNode']");
                let point = this.intersection(centerX, centerY, radius, iconCenterPoint.x, iconCenterPoint.y, contentNode.clientHeight / 2 + pathOffset);
                node.setAttribute("data-arfx", point[1]);
                node.setAttribute("data-arfy", point[3]);
                node.setAttribute("data-arbx", point[0]);
                node.setAttribute("data-arby", point[2]);

                let nodeGroup = node.querySelector("[name='nodeGroup']");
                arrAlignClassname.map((className) => {
                    nodeGroup.classList.remove(className);
                });

                let heightRation = this.getHeightRatio();
                let height = radius * heightRation;
                node.style.height = height + "px";
                node.style.maxHeight = node.style.height;
                node.style.width = "100px";
                if (angle > 0 && angle < 180) {
                    nodeGroup.classList.add("circularAlignRight");
                } else if (angle > 180 && angle < 360) {
                    nodeGroup.classList.add("circularAlignLeft");
                    // node.style.width = iconCenterPoint.x + "px";
                } else if (angle == 0) {
                    nodeGroup.classList.add("circularAlignTop");

                    node.style.height = this.diagramParent.clientHeight / 2 - radius + contentNodeHeight + 20 + "px";
                    node.style.maxHeight = node.style.height;
                    node.style.width = this.diagramParent.clientWidth * 0.5 + "px";
                }

                let secContentNode = node.querySelector("[name='secContentNode']");
                arrTextAlignClassname.map((className) => {
                    secContentNode.classList.remove(className);
                });

                if (angle > 90 && angle < 270) secContentNode.classList.add("circularTextAlignBottom");
                else if (angle > 270 || angle < 90) secContentNode.classList.add("circularTextAlignTop");

                let taget = node.querySelector("[name='contentNode']");
                let tagetRect = DiagramNodeUtils.getOffsetRectByParent(node, taget);
                node.style.left = iconCenterPoint.x - (tagetRect.x + tagetRect.width / 2) + "px";
                node.style.top = iconCenterPoint.y - (tagetRect.y + tagetRect.height / 2) + "px";

                //need to set bottom instead of top if a node place above the circle
                secContentNode.style.setProperty("max-height", "100%", "important");
                if (angle == 0) {
                    node.style.bottom = this.diagramParent.offsetHeight - (node.offsetTop + node.offsetHeight) + "px";
                    node.style.top = "unset";
                }

                // let contentNode = node.querySelector("[name='contentNode']");
                let sequencText = node.querySelector("[name='seqTitleHolder']");
                if (sequencText && contentNode) {
                    let numCenterPoint = this.polarToCartesian(contentNode.clientWidth / 2, contentNode.clientHeight / 2, contentNode.clientHeight / 2, 45);
                    sequencText.style.left = numCenterPoint.x - contentNode.width / 2 + "px";
                    sequencText.style.top = numCenterPoint.y - contentNode.height / 2 + "px";
                }

                top = Math.min(top, node.offsetTop);
                bottom = Math.max(bottom, node.offsetTop + node.offsetHeight);

                this.checkForIntersection(this.circleParent, node, angle);

                if (angle > 0 && angle < 180) {
                    node.style.width = this.diagramParent.clientWidth - node.offsetLeft + "px";
                } else if (angle > 180 && angle < 360) {
                    node.style.width = node.offsetLeft + node.clientWidth + "px";
                    node.style.left = "0px";
                }
            }
        }.bind(this)
    );

    this.arrDiagramNode.map(
        function (nodeObj) {
            let node = nodeObj.getNodeParent().parentElement;
            this.updateImagePosition(node);
        }.bind(this)
    );
};

LinearCircularDiagram.prototype.getAngleBaseOnNodeCount = function () {
    switch (this.diagramData.nodes.length) {
        case 2:
            return 90;
        case 3:
            return 0;
        case 4:
            return 45;
        case 5:
            return 0;
        case 6:
            return 30;
    }
};

LinearCircularDiagram.prototype.setCenterPlaceHolder = function (parent, size, data) {
    let div = document.createElement("div");
    div.className = "centerNode";
    div.setAttribute("data-id", "centerNode");
    div.style.width = size.width + "px";
    div.style.height = size.height + "px";
    div.id = Math.random();
    parent.appendChild(div);
    this.centerNode = div;

    let nonlinerCenterData = this.centerholderdata && this.centerholderdata.content ? this.centerholderdata.content : { id: "", value: "", contenttype: "image" };
    let nodeData = { content: this.diagramData.properties.customproperties ? this.diagramData.properties.customproperties : nonlinerCenterData };
    this.createCenterElements(div, this.centerholderdata || nodeData);
    return div;
};

LinearCircularDiagram.prototype.describeArc = function (x, y, radius, startAngle, endAngle, objData) {
    let startAngleInner = startAngle;
    let endAngleInner = endAngle;

    startAngle = startAngle + objData.outeranglegap / 2;
    endAngle = endAngle - objData.outeranglegap / 2;

    var start = this.polarToCartesian(x, y, radius, endAngle);
    var end = this.polarToCartesian(x, y, radius, startAngle);

    var innerstart = this.polarToCartesian(x, y, objData.innerradius, endAngleInner);
    var innerend = this.polarToCartesian(x, y, objData.innerradius, startAngleInner);

    var largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";

    var d = ["M", innerstart.x, innerstart.y, "A", objData.innerradius, objData.innerradius, 0, largeArcFlag, 0, innerend.x, innerend.y, "L", end.x, end.y, "A", radius, radius, 0, largeArcFlag, 1, start.x, start.y].join(" ");

    return d;
};

LinearCircularDiagram.prototype.polarToCartesian = function (centerX, centerY, radius, angleInDegrees) {
    var angleInRadians = ((angleInDegrees - 90) * Math.PI) / 180.0;

    return {
        x: centerX + radius * Math.cos(angleInRadians),
        y: centerY + radius * Math.sin(angleInRadians),
    };
};

LinearCircularDiagram.prototype.intersection = function (x0, y0, r0, x1, y1, r1) {
    var a, dx, dy, d, h, rx, ry;
    var x2, y2;

    dx = x1 - x0;
    dy = y1 - y0;

    d = Math.sqrt(dy * dy + dx * dx);

    if (d > r0 + r1) {
        return false;
    }
    if (d < Math.abs(r0 - r1)) {
        return false;
    }

    a = (r0 * r0 - r1 * r1 + d * d) / (2.0 * d);

    x2 = x0 + (dx * a) / d;
    y2 = y0 + (dy * a) / d;

    h = Math.sqrt(r0 * r0 - a * a);

    rx = -dy * (h / d);
    ry = dx * (h / d);

    var xi = x2 + rx;
    var xi_prime = x2 - rx;
    var yi = y2 + ry;
    var yi_prime = y2 - ry;

    return [xi, xi_prime, yi, yi_prime];
};

LinearCircularDiagram.prototype.checkForIntersection = function (circleBase, nodeItem, angle) {
    let target = nodeItem.querySelector("[name='secContentNode']");
    let targetRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent, target);
    var circle = {
        radius: this.circleRadius,
        center: { x: circleBase.offsetLeft + circleBase.offsetWidth / 2, y: circleBase.offsetTop + circleBase.offsetHeight / 2 },
    };
    var topLine = {
        p1: { x: targetRect.left, y: targetRect.top },
        p2: { x: targetRect.left + targetRect.width, y: targetRect.top },
    };

    var bottomLine = {
        p1: { x: targetRect.left, y: targetRect.top + targetRect.height },
        p2: { x: targetRect.left + targetRect.width, y: targetRect.top + targetRect.height },
    };

    var centerLine = {
        p1: { x: targetRect.left, y: targetRect.top + targetRect.height / 2 },
        p2: { x: targetRect.left + targetRect.width, y: targetRect.top + targetRect.height / 2 },
    };

    let topIntersetPoint = DiagramUtils.findCircleLineIntersections(circle, topLine);
    let bottomIntersetpoint = DiagramUtils.findCircleLineIntersections(circle, bottomLine);
    let centerIntersetpoint = DiagramUtils.findCircleLineIntersections(circle, centerLine);

    let topX = topIntersetPoint[0] ? topIntersetPoint[0].x : 0;
    let bottomX = bottomIntersetpoint[0] ? bottomIntersetpoint[0].x : 0;
    let centterX = centerIntersetpoint[0] ? centerIntersetpoint[0].x : 0;
    let x = Math.max(topX, bottomX);

    if (angle == 90) {
        x = centterX == 0 ? targetRect.left : centterX;
    } else if (angle == 270) {
        x = centterX == 0 ? targetRect.left + targetRect.width : centterX;
    }

    let isRightItem = angle > 0 && angle < 180;
    let isLeftItem = angle > 180 && angle < 360;

    let nodeOffset = this.nodeProps.iconvisible && this.nodeProps.iconvisible == "false" ? 10 : 10;
    x = x == 0 && isRightItem ? targetRect.left : x;
    x = x == 0 && isLeftItem ? targetRect.left + targetRect.width : x;
    let rightX = x + nodeOffset;
    let leftX = x - nodeOffset - targetRect.width;

    target.style.setProperty("margin-left", 0 + "px", "important");
    if (isRightItem) {
        target.style.setProperty("margin-left", rightX - targetRect.left + "px", "important");
    } else if (isLeftItem) {
        target.style.setProperty("margin-right", targetRect.left - leftX + "px", "important");
        // nodeItem.style.left = isLeftItem ? leftX + "px" : nodeItem.style.left;
    }
};

LinearCircularDiagram.prototype.setHighlightPosition = function (node, parent) {
    let nodeParent = node.parentElement;
    let element = nodeParent.querySelector("[data-id='diagramContentNode']");
    if (!element || element.clientWidth == 0) element = node;

    let alignment = "auto";
    let nodeAlign = nodeParent.firstElementChild?.dataset?.alignment || "auto";

    alignment = nodeAlign == "left" ? "right" : alignment;
    alignment = nodeAlign == "right" ? "left" : alignment;

    return { element: element, alignment: alignment };
};

LinearCircularDiagram.prototype.createMarker = function () {
    if (this.nodeProps.iconvisible && this.nodeProps.iconvisible == "false") return;

    let ldef = DiagramNodeUtils.getDocumentDefs(this.diagramParent, true);
    let defs = ldef;
    if (!ldef) return;
    let arrMarker = Array.from(defs.querySelectorAll("marker"));
    arrMarker.map((marker) => {
        marker.parentElement.removeChild(marker);
    });

    this.createMarkerShape("markerend-arrow", '<path xmlns="http://www.w3.org/2000/svg" d="M0 0L9 4L0 8V0Z" width="9" height="8"/>', defs);
    this.createMarkerShape("markerstart-arrow", '<path xmlns="http://www.w3.org/2000/svg" d="M9 0L0 4L9 8V0Z" width="9" height="8"/>', defs);
    this.createMarkerShape("markerend-dot", '<rect xmlns="http://www.w3.org/2000/svg" width="6" height="6" rx="3"/>', defs);
    this.createMarkerShape("markerstart-dot", '<rect xmlns="http://www.w3.org/2000/svg" width="6" height="6" rx="3"/>', defs);
};

LinearCircularDiagram.prototype.createMarkerShape = function (id, innerHtmlText, defs, scale = 0.7) {
    let width = innerHtmlText.match(/width="(\d+)"/)?.[1];
    let height = innerHtmlText.match(/height="(\d+)"/)?.[1];

    let strokewidth = parseInt(this.diagramParent.dataset.strokewidth || "0");
    if (strokewidth <= 5) scale = 0.6;
    if (strokewidth > 5) scale = 0.4;

    let marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
    let refy = scale * (height / 2);
    let refx = scale * (width / 2) + (id.includes("start") ? -(width * scale * 0.2) : width * scale * 0.2);
    marker.setAttribute("id", id);
    marker.setAttribute("markerWidth", width);
    marker.setAttribute("markerHeight", height);
    marker.setAttribute("refX", refx);
    marker.setAttribute("refY", refy);
    marker.setAttribute("orient", "auto");
    marker.innerHTML = innerHtmlText;
    marker.firstElementChild.setAttribute("style", "transform: scale(" + scale + ")");
    marker.firstElementChild.setAttribute("fill", this.arrowColor);
    defs.appendChild(marker);
};

LinearCircularDiagram.prototype.changeArrow = function (arrowName) {
    this.diagramData.properties.connectorstyle = arrowName;
    this.diagramParent.setAttribute("data-connectorstyle", arrowName);
};

LinearCircularDiagram.prototype.updateImagePosition = function (node) {
    let contentDiv = node.querySelector("[name='contentNode']");
    let imgParent = node.querySelector("[name='imageHolder']");
    if (!imgParent) return;
    let img = node.querySelector("[data-id='imageNode']");

    let slide = document.getElementById(this.slideID);
    let item = DiagramNodeUtils.getOffsetRectByParent(slide, contentDiv);
    imgParent.setAttribute("data-x", item.x);
    imgParent.setAttribute("data-y", item.y);
    imgParent.setAttribute("data-width", contentDiv.clientWidth);
    imgParent.setAttribute("data-height", contentDiv.clientHeight);
    img.setAttribute("data-width", contentDiv.clientWidth);
    img.setAttribute("data-height", contentDiv.clientHeight);
    img.setAttribute("data-x", item.x);
    img.setAttribute("data-y", item.y);
};

LinearCircularDiagram.prototype.resetHolderWidth = function () {
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    this.getCircleInfo(nodesHolder);
    let iconRation = this.radius * 2 * 0.2; //46*(this.slideWidth/1280);
    nodesHolder.style.setProperty("--nodeWidth", "200px");
    nodesHolder.style.setProperty("--contentwidth", iconRation * this.getSizeForHolderType() + "px", "important");
    if (this.diagramData?.properties?.commonnodesize) this.commonNodeSizeChange({ value: this.diagramData.properties.commonnodesize });
    SimpleLinearVerticalDiagram.prototype.resetHolderWidth.call(this);
};

LinearCircularDiagram.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsNodesHolder";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.appendChild(pattenDiv);

    this.getCircleInfo(pattenDiv);
    let iconRation = this.radius * 2 * 0.2; //46*(this.slideWidth/1280);
    pattenDiv.style.setProperty("--nodeWidth", "200px");
    pattenDiv.style.setProperty("--contentwidth", iconRation * this.getSizeForHolderType() + "px", "important");
    pattenDiv.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    pattenDiv.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    pattenDiv.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    pattenDiv.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    pattenDiv.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");

    if (this.nodeProps.iconvisible == "false") pattenDiv.style.setProperty("--imagediaplay", "none");

    this.createNodeInstances(nodeCount, pattenDiv);

    this.init();
};

LinearCircularDiagram.prototype.createCenterElements = function (pattenDiv, nodeData, isRecreate = false) {
    let centerItem = new window[this.centerNodeClass](pattenDiv, this.diagramData?.properties || {}, nodeData, this.eventManagerXY, 0, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
    centerItem.moodData = this.moodData;
    centerItem.moodName = this.moodName;
    centerItem.updateCallBack = this.updateCallBack;
    centerItem.searchIconCallBack = this.searchIconCallBack;
    centerItem.bgDeviceDiv = this.bgDeviceDiv;
    centerItem.arrDefaults = this.arrDefaults;
    centerItem.globalMoodData = this.globalMoodData;
    centerItem.arrTintArray = this.arrTintArray;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;
    if (!isRecreate) centerItem.createCenterNode(pattenDiv);
    this.centerHolderNode = centerItem;
    this.centerHolderNode.parentNode = this.centerHolderNode.mainParent.firstElementChild;

    let centerHolder = pattenDiv.querySelector("[name='centerHolderParent']");
    centerHolder.setAttribute("data-animation", "commonplaceholder");
    centerHolder.firstElementChild.setAttribute("data-animation", "commonplaceholder");

    let iconNode = centerHolder.querySelector("[name='iconHolder']");
    if (iconNode) {
        let useNode = iconNode.querySelector("[data-id='useNode']");
        useNode.className.baseVal = "clsAccentfill";
    }

    let contentType = centerHolder.dataset.type;
    let arrImageNode = Array.from(centerHolder.querySelectorAll("img[data-id='imageNode'],img[data-id='logoNode']"));
    arrImageNode.map(
        function (imageNode) {
            contentType = imageNode.parentElement.dataset.contentType;
            if (imageNode) CommonImageUtils.updateImageBounds(imageNode, { islogofit: contentType == "logo", contenttype: contentType }, 1);
        }.bind(this)
    );
};

LinearCircularDiagram.prototype.updateNodeData = function (nodeData, type, index, parentId) {
    if (parentId.includes("center")) {
        let parent = this.diagramParent.querySelector("[id='" + parentId + "']");
        if (!parent) return;
        parent.setAttribute("data-content-type", type);
        let node = parent.querySelector("[data-id='" + type + "Node']");

        switch (type) {
            case "image":
            case "bgimage":
            case "logo":
                node.src = nodeData.value;
                if (node) CommonImageUtils.updateImageBounds(node, { islogofit: type == "logo", contenttype: type }, 1);
                break;
            case "icon":
                let iconName = DiagramNodeUtils.getIconName({ id: nodeData.id, value: nodeData.value });
                let useNode = node.querySelector("[id='useNode']");
                if (useNode) useNode.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "#" + iconName);
                node.setAttribute("iconid", nodeData.id);
                node.setAttribute("iconpath", nodeData.value);
                break;
            case "text":
            case "number":
            case "microchart":
                node.innerText = nodeData.value;
                break;
            default:
                break;
        }
        return;
    }

    if (this.arrDiagramNode && this.arrDiagramNode.length > index) {
        this.arrDiagramNode[index].updateContentData(nodeData, type, parentId);
    }
};

LinearCircularDiagram.prototype.getProperties = function (defaultproperties = {}) {
    let properties = SimpleLinearVerticalDiagram.prototype.getProperties.call(this, defaultproperties);
    this.centerNode = this.diagramParent.querySelector("div[data-id='centerNode']");
    properties.customproperties = this.getNodeData(this.centerNode);
    let isConnectorVisible = this.nodeProps.iconvisible == "false" ? false : true;
    properties.hasconnector = isConnectorVisible;
    properties.connector = isConnectorVisible;
    return properties;
};

LinearCircularDiagram.prototype.getNodeData = function (centerNode) {
    if (!centerNode) return this.diagramData ? this.diagramData.properties.customproperties : null;
    let contentNode = centerNode.firstElementChild;
    if (contentNode && contentNode.dataset && contentNode.dataset.contentType) {
        let contentType = contentNode.dataset.contentType;
        let node;
        let data = {};
        let dataRef = {};
        node = contentNode.querySelector("[data-id='" + contentType + "Node']");
        switch (contentType) {
            case "image":
            case "logo":
                dataRef = { imageURL: node.src };
                if (node.dataset.csstext) dataRef.cropStyle = node.dataset.csstext;
                if (node.dataset.style) dataRef.cropData = node.dataset.style;
                data = { type: "image", value: node.src, dataRef: dataRef, contenttype: contentType };
                break;
            case "icon":
                let iconid = node.getAttribute("iconid");
                let path = node.getAttribute("iconpath");
                dataRef.name = iconid;
                data = { type: "icon", value: path, id: iconid, dataRef: dataRef, contenttype: contentType };
                break;
            case "text":
            case "number":
            case "microchart":
                let strValue = node.textContent.replace("%", "");
                data = { type: "text", value: strValue, contenttype: contentType };
                break;
            case "checklist":
                data = { type: "text", value: node.dataset.ischecked, contenttype: contentType };
                break;
            default:
                data = { type: "text", value: "", contenttype: contentType };
                break;
        }
        return data;
    } else {
        return { type: "text", value: "" };
    }
};

LinearCircularDiagram.prototype.getCenterHolderData = function () {
    this.centerholderdata = this.centerHolderNode?.getJSONData?.();
    return this.centerholderdata || {};
    this.centerNode = this.diagramParent.querySelector("div[data-id='centerNode']");
    if (!this.centerNode) return {};
    let data = { content: this.getNodeData(this.centerNode) };
    return data;
};

LinearCircularDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearVerticalDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable.push("animateoneatatime");
        mainProperties.floateroptionsdisable.push("arrange");
        mainProperties.floateroptionsdisable.push("imagesize");
    } else mainProperties.floateroptionsdisable = ["animateoneatatime", "arrange", "imagesize"];
    DiagramUtils.removeElementFromArray("fontresize", mainProperties.floateroptionsdisable);
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

LinearCircularDiagram.prototype.checkForArrowReverseAnimation = function () {
    return this.diagramParent.dataset.hasOwnProperty("connectorstyle") && this.diagramParent.dataset.connectorstyle == "arrowleft";
};

LinearCircularDiagram.prototype.changeIconSize = function (value) {};
LinearCircularDiagram.prototype.changeLogoSize = function (value) {};

LinearCircularDiagram.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    this.floaterOption(this, elTarget, strSelectionType, dict);

    let centerNode = this.diagramParent.querySelector("[data-id='centerNode']");
    let isCenterChild = centerNode ? this.isChildOfParent(elTarget, centerNode) : false;

    if (isCenterChild) {
        let { options, selectedindex } = this.getSeletion(this.centerNode.firstElementChild.dataset.contentType, "centerNode");
        dict.contentswap = {
            dpsource: options,
            selectedindex: selectedindex,
            floaterproperty: "contentChange",
            visible: options.length > 1 ? true : false,
        };
        elTarget.setAttribute("data-focus-parent", "centerHolderParent");
        dict[FloaterConstants.DELETE_ASSET] = null;
        dict[FloaterConstants.HIGHLIGHT] = null;
    }

    delete dict.textalign;
};

LinearCircularDiagram.prototype.floaterOption = function (dInstant, elTarget, strSelectionType, dict) {
    if (elTarget.id && (elTarget.id.includes("center") || elTarget.id.includes("ELEMENT_DIV"))) {
        dict["highlight"] = null;
        dict["highlightemphasize"] = null;
        dict["deleteasset"] = null;
    } else if (dInstant && dInstant.diagramData.properties.minnode >= dInstant.arrDiagramNode.length) {
        dict["deleteasset"] = null;
    }
    dict["crossout"] = null;
    dict["highlightemphasize"] = null;
};

//Used to set different height for nodeParent depends on node count
LinearCircularDiagram.prototype.getHeightRatio = function () {
    switch (this.diagramData.nodes.length) {
        case 2:
            return 1;
        case 3:
        case 4:
            return 0.8;
        case 5:
            return 0.7;
        case 6:
            return 0.7;
        case 7:
            return 0.5;
        case 8:
            return 0.45;
        default:
            return 0.2;
    }
};

LinearCircularDiagram.prototype.isNonLinearAsset = function () {
    return true;
};

LinearCircularDiagram.prototype.resetNodeAttributes = function () {
    this.setNodeCount();
    this.updateTextNodes();
    for (let i = 0; i < this.arrDiagramNode.length; i++) {
        if (this.globalMoodData) this.arrDiagramNode[i].globalMoodData = this.globalMoodData;
        if (this.arrTintArray) this.arrDiagramNode[i].arrTintArray = this.arrTintArray;
        this.arrDiagramNode[i].properties = this.diagramData.properties;
        this.arrDiagramNode[i].updateNodeAttributes(i, this.diagramRenderComplete);
        this.arrDiagramNode[i].updateImageLogoFrames();
        if (this.arrDiagramNode[i].parentNode && this.arrDiagramNode[i].parentNode.dataset.highlight == "true") this.setHighlightTargetPoints(this.arrDiagramNode[i].parentNode, this.diagramParent);
    }
    let minWidthHeight = this.nodeProps && this.nodeProps.minWidthHeight;
    if (minWidthHeight) {
        let type = this.diagramParent.dataset.graphiclayoutname || this.diagramParent.dataset.name.substr(0, this.diagramParent.dataset.name.indexOf("-"));
        if (typeof minWidthHeight == "string") minWidthHeight = JSON.parse(minWidthHeight);
        this.diagramParent.style.minWidth = (type == "hor" ? minWidthHeight[0] * this.arrDiagramNode.length : minWidthHeight[0]) + "px";
        this.diagramParent.style.minHeight = (type == "ver" ? minWidthHeight[1] * this.arrDiagramNode.length : minWidthHeight[1]) + "px";
    }
    if (this.centerHolderNode) {
        this.centerHolderNode.updateNodeAttributes(0, this.diagramRenderComplete);
    }
};

LinearCircularDiagram.prototype.getOutlineMatrix = function (isFromZenEditor = false) {
    let outlineData = LinearDiagram.prototype.getOutlineMatrix.call(this, isFromZenEditor);
    let data = this.getCenterHolderData();
    outlineData.centerholderdata = data;
    return outlineData;
};

LinearCircularDiagram.prototype.setHolderType = function (contenttype, holder) {
    LinearDiagram.prototype.setHolderType.call(this, contenttype, holder);
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    this.getCircleInfo(nodesHolder);
    let iconRation = this.radius * 2 * 0.2; //46*(this.sliderWidth/1280);
    nodesHolder.style.setProperty("--nodeWidth", "200px");
    nodesHolder.style.setProperty("--contentwidth", iconRation * this.getSizeForHolderType() + "px", "important");
};

//Used to set different content size for different content types
LinearCircularDiagram.prototype.getSizeForHolderType = function () {
    let contentOption = this.nodeProps.supportedNodes.find((obj) => obj.name == "contentNode");
    if (contentOption) {
        let selectedContent = contentOption.subNodes.find((obj) => obj.name == this.diagramData.properties.contentholdertype);
        if (selectedContent) return selectedContent.sizeRatio || 1;
    }
    return 1;
};

//Used to calculate the base circle radius give from menue
LinearCircularDiagram.prototype.getCircleInfo = function (nodesHolder) {
    let heightRadius = (nodesHolder.height || nodesHolder.clientHeight) / 2;
    let widthRadius = (nodesHolder.width || nodesHolder.clientWidth) / 4;
    let radius = Math.min(heightRadius, widthRadius);
    if (this.diagramData.nodes.length == 3 || this.diagramData.nodes.length == 5) radius = radius * 0.65;
    else radius = radius * 0.7;
    let contentNodeHeight = this.arrDiagramNode?.[0]?.parentNode.querySelector("[name='contentNode']")?.clientHeight || 0;
    radius = [3, 5].includes(this.arrDiagramNode.length) ? radius - contentNodeHeight / 2 : radius;

    let centerX = this.diagramParent.clientWidth / 2;
    let centerY = this.diagramParent.clientHeight / 2;

    if ([3, 5].includes(this.arrDiagramNode.length)) {
        centerY = centerY + contentNodeHeight / 2 + 20;
    }

    this.radius = radius;
    this.circleRadius = radius;
    return { radius: parseInt(radius), centerX: centerX, centerY: centerY, contentNodeHeight: contentNodeHeight };
};

LinearCircularDiagram.prototype.commonNodeSizeChange = function (obj) {
    var value = parseFloat(obj.value);
    this.commonNodeSizeRatio = value * 2;
    if (!obj.dragging) this.diagramParent.setAttribute("data-commonnodesize", value);
    this.updateNodePosition();
    this.centerHolderNode?.updateImageLogoFrames?.();
};

LinearCircularDiagram.prototype.setDiagramSpecficOption = function (obj) {
    let contentNode = this.arrDiagramNode?.[0].parentNode.querySelector("[name='contentNode']");
    let diff = this.radius - contentNode.clientWidth;
    let maxPercentage = 0.7; //diff / this.radius;
    let value = this.diagramData.properties.commonnodesize || this.diagramParent.dataset.commonnodesize || 0.3;
    let commongraphicsize = { visible: true, minval: 0.3, maxval: maxPercentage, value: parseFloat(value), property: "commonnodesizechange" };
    obj.dpcontent.floatdiagramsettings.commongraphicsize = commongraphicsize;
    this.addConnectorSettings(obj);
    delete obj.dpcontent.floatdiagramsettings.separator;
    delete obj.dpcontent.floatdiagramsettings.graphiclogosize;
};

LinearCircularDiagram.prototype.addConnectorSettings = function (obj) {
    this.addLineSetting(obj);
    this.addArrowSetting(obj);
};

LinearCircularDiagram.prototype.addLineSetting = function (obj) {
    let dashIndex = parseInt(this.diagramData.properties.dasharrayindex || this.diagramParent.dataset.dasharrayindex || 0);
    let dasharray = {
        selectedindex: dashIndex,
        dpsource: [
            { data: 0, label: "Solid" },
            { data: 2, label: "Dotted" },
            { data: 8, label: "Dash" },
        ],
        property: "dasharray",
    };
    obj.dpcontent.floatdiagramsettings.dasharray = dasharray;

    let strokeWidthIndex = parseInt(this.diagramData.properties.strokewidthindex || this.diagramParent.dataset.strokewidthindex || 0);
    let strokewidth = {
        selectedindex: strokeWidthIndex,
        dpsource: [
            { data: 3, label: "3px" },
            { data: 5, label: "5px" },
            { data: 6, label: "6px" },
            { data: 7, label: "7px" },
            { data: 8, label: "8px" },
        ],
        property: "strokewidth",
    };
    obj.dpcontent.floatdiagramsettings.strokewidth = strokewidth;
};

LinearCircularDiagram.prototype.addArrowSetting = function (obj) {
    let connectorstartIndex = parseInt(this.diagramData.properties.connectorstartindex || this.diagramParent.dataset.connectorstartindex || 0);
    let connectorstart = {
        selectedindex: connectorstartIndex,
        dpsource: [
            { data: "none", label: "None" },
            { data: "arrow", label: "Arrow" },
            { data: "dot", label: "Dot" },
        ],
        property: "connectorstart",
    };
    obj.dpcontent.floatdiagramsettings.connectorstart = connectorstart;

    let connectorendIndex = parseInt(this.diagramData.properties.connectorendindex || this.diagramParent.dataset.connectorendindex || 0);
    let connectorend = {
        selectedindex: connectorendIndex,
        dpsource: [
            { data: "none", label: "None" },
            { data: "arrow", label: "Arrow" },
            { data: "dot", label: "Dot" },
        ],
        property: "connectorend",
    };
    obj.dpcontent.floatdiagramsettings.connectorend = connectorend;
};

LinearCircularDiagram.prototype.addReversOption = function (obj) {
    let circlenodeorder = { value: this.isReverse, property: "circlenodeorder" };
    obj.dpcontent.floatdiagramsettings.circlenodeorder = circlenodeorder;
};

LinearCircularDiagram.prototype.updateConnectorDasharray = function (obj) {
    this.diagramParent.setAttribute("data-dasharrayindex", obj.index);
    this.diagramParent.setAttribute("data-dasharray", obj.data);
    this.diagramData.properties.dasharrayindex = obj.index;
    this.diagramData.properties.dasharray = this.diagramData.properties.strokewidth * obj.index;
    let arrPaths = Array.from(this.diagramParent.querySelectorAll(".arrow-path"));
    arrPaths.forEach((path) => {
        path.setAttribute("stroke-dasharray", this.diagramData.properties.dasharray);
    });

    let circlePath = this.diagramParent.querySelector("#circle-path");
    if (circlePath) circlePath.setAttribute("stroke-dasharray", obj.data);
};

LinearCircularDiagram.prototype.updateConnectorWidth = function (obj) {
    this.diagramParent.setAttribute("data-strokewidthindex", obj.index);
    this.diagramParent.setAttribute("data-strokewidth", obj.data);
    this.diagramData.properties.strokewidthindex = obj.index;
    this.diagramData.properties.strokewidth = obj.data;
    let arrPaths = Array.from(this.diagramParent.querySelectorAll(".arrow-path"));
    this.updateNodePosition();
    arrPaths.forEach((path) => {
        path.setAttribute("stroke-width", obj.data);
        this.diagramData.properties.dasharray = obj.data * this.diagramData.properties.dasharrayindex;
        path.setAttribute("stroke-dasharray", this.diagramData.properties.dasharray);
    });

    let circlePath = this.diagramParent.querySelector("#circle-path");
    if (circlePath) circlePath.setAttribute("stroke-width", obj.data);
};

LinearCircularDiagram.prototype.updateConnetorStart = function (obj) {
    this.diagramParent.setAttribute("data-connectorstartindex", obj.index);
    this.diagramParent.setAttribute("data-connectorstart", obj.data);
    this.diagramData.properties.connectorstartindex = obj.index;
    this.diagramData.properties.connectorstart = obj.data;
    let arrPaths = Array.from(this.diagramParent.querySelectorAll(".arrow-path"));
    this.updateNodePosition();
    arrPaths.forEach((path) => {
        path.setAttribute("marker-start", `url(#markerstart-${obj.data})`);
        path.style.display = "block";
    });
};

LinearCircularDiagram.prototype.updateConnetorEnd = function (obj) {
    this.diagramParent.setAttribute("data-connectorendindex", obj.index);
    this.diagramParent.setAttribute("data-connectorend", obj.data);
    this.diagramData.properties.connectorendindex = obj.index;
    this.diagramData.properties.connectorend = obj.data;
    let arrPaths = Array.from(this.diagramParent.querySelectorAll(".arrow-path"));
    this.updateNodePosition();
    arrPaths.forEach((path) => {
        path.setAttribute("marker-end", `url(#markerend-${obj.data})`);
    });
};

LinearCircularDiagram.prototype.doReversDirection = function (obj) {
    this.isReverse = obj.value;
    this.diagramParent.setAttribute("data-isreverse", this.isReverse);
    this.diagramData.properties.isreverse = this.isReverse;
    this.updateNodePosition();
};

LinearCircularDiagram.prototype.doFlipOperation = function (obj) {
    this.isFlip = obj.value;
    this.diagramParent.setAttribute("data-isflip", this.isFlip);
    this.diagramData.properties.isflip = this.isFlip;
    this.updateNodePosition();
};

LinearCircularDiagram.prototype.clearOldPath = function () {
    let arrOldPath = Array.from(this.diagramParent.querySelectorAll(".arrow-path"));
    arrOldPath.forEach((path) => path.parentElement?.removeChild(path));
};

LinearCircularDiagram.prototype.changeLogoContrast = function (valueObj, target, nodeGroup, logoGridIndex) {
    if (valueObj.targetid.includes("center")) {
        let logoNode = this.centerNode.querySelector("[data-id='logoNode']");
        DiagramUtils.setLogoContrast(logoNode, logoNode.parentElement, valueObj.value);
        this.centerNode.firstElementChild.dataset.logocontrast = valueObj.value;
    } else LinearDiagram.prototype.changeLogoContrast?.call(this, valueObj, target, nodeGroup, logoGridIndex);
};

LinearCircularDiagram.prototype.changeNumberStart = function (value) {
    this.diagramData.properties.sequencetextstart = value;
    this.updateProperties(this.diagramData.properties);
    this.resetNodeAttributes();
};

LinearCircularDiagram.prototype.updateTextSize = function (valueObj, targetNode) {
    let focusParent = targetNode.dataset.focusParent || false;
    if (focusParent && focusParent == "centerHolderParent") {
        let textNode = this.centerHolderNode?.parentNode.querySelector("[data-id='textNode'],[data-id='numberNode']") || false;
        if (textNode) textNode.style.fontSize = valueObj.value == "reset" ? "" : valueObj.value;
    } else LinearDiagram.prototype.updateTextSize.call(this, valueObj, targetNode);
};

/**
 * Author:    Krishna
 * Created:   20 fri march 2020
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function LinearCircularRingDiagram(diagramParent, diagramData, nodeProps, moodData = {}) {
    LinearCircularDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.setAttribute("data-toggleassets", "true");
    this.diagramParent.setAttribute("data-togglecategory", Constants.Value.circularRingToggleCategory);
}

LinearCircularRingDiagram.prototype = Object.create(LinearCircularDiagram.prototype);

LinearCircularRingDiagram.prototype.initDiagramCreation = function () {
    this.diagramData.properties.hasconnector = true;
    this.diagramData.properties.connector = true;
    LinearCircularDiagram.prototype.initDiagramCreation.call(this);
};

LinearCircularRingDiagram.prototype.updateElements = function (defaultproperties) {
    let isConnectorVisible = this.nodeProps.iconvisible == "false" ? false : true;
    defaultproperties.hasconnector = isConnectorVisible;
    defaultproperties.connector = isConnectorVisible;
    this.diagramParent.setAttribute("data-hasconnector", isConnectorVisible);
    this.diagramParent.setAttribute("data-connector", isConnectorVisible);
    LinearCircularDiagram.prototype.updateElements.call(this, defaultproperties);
    this.diagramData.properties.hasconnector = isConnectorVisible;
    this.diagramData.properties.connector = isConnectorVisible;
    this.diagramParent.setAttribute("data-hasconnector", isConnectorVisible);
    this.diagramParent.setAttribute("data-connector", isConnectorVisible);
    this.arrArrowPath = Array.from(this.diagramParent.querySelectorAll(".arrow-path"));
};

LinearCircularRingDiagram.prototype.updateNodePosition = function () {
    this.createMarker();
    LinearCircularDiagram.prototype.updateNodePosition.call(this);
    this.drawArc();
};

LinearCircularRingDiagram.prototype.getCenterHolderSize = function () {
    let svgRect = { width: this.circleParent.clientWidth, height: this.circleParent.clientHeight };
    this.getCircleInfo(svgRect);
    let width = this.radius * 1 * this.commonNodeSizeRatio;
    if (this.nodeProps.iconvisible == "false") width = this.radius * 2 - 40;
    return { width: width, height: width };
};

LinearCircularRingDiagram.prototype.drawArc = function () {
    if (this.appmode == "PRESENT") return;
    let oldSvg = this.diagramParent.querySelector("[id='circleBase']");
    if (oldSvg && oldSvg.parentElement) {
        oldSvg.parentElement.removeChild(oldSvg);
    }
    if (!this.circleParent) return;

    this.arrArrowPath = [];
    let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("id", "circleBase");
    svg.setAttribute("class", "circlearrowsvg");
    svg.setAttribute("width", "100%");
    svg.setAttribute("height", "100%");
    svg.setAttribute("opacity", 1);
    this.circleParent.appendChild(svg);

    this.arrDiagramNode.map((nodeObj, index) => {
        let node = nodeObj.getNodeParent().parentElement;
        let nextIcon = index == this.arrDiagramNode.length - 1 ? this.arrDiagramNode[0].getNodeParent().parentElement : this.arrDiagramNode[index + 1].getNodeParent().parentElement;
        let startAngle = parseFloat(node.dataset.angle);
        let endAngle = parseFloat(nextIcon.dataset.angle);

        let start = { x: parseFloat(node.dataset.arbx), y: parseFloat(node.dataset.arby) };
        let end = { x: parseFloat(nextIcon.dataset.arfx), y: parseFloat(nextIcon.dataset.arfy) };
        this.drawConnector(svg, startAngle, endAngle, this.circleRadius, start, end);
    });
};

LinearCircularRingDiagram.prototype.updateConnetorStart = function (obj) {
    this.createMarker();
    LinearCircularDiagram.prototype.updateConnetorStart.call(this, obj);
};

LinearCircularRingDiagram.prototype.drawConnector = function (svg, startAngle, endAngle, radius, start, end) {
    let largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";

    let d = ["M", start.x, start.y, "A", radius, radius, 0, largeArcFlag, 1, end.x, end.y].join(" ");
    let path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", this.arrowColor);
    path.setAttribute("stroke-width", this.diagramParent.dataset.strokewidth || "2");
    path.setAttribute("stroke-dasharray", this.diagramParent.dataset.dasharray || "0");
    path.setAttribute("class", "arrow-path moodanimation");
    path.setAttribute("data-animation", "connector");
    path.setAttribute("d", d);
    path.setAttribute("marker-end", `url(#markerend-${this.diagramParent.dataset.connectorend})`);
    path.setAttribute("marker-start", `url(#markerstart-${this.diagramParent.dataset.connectorstart})`);
    svg.appendChild(path);
    this.arrArrowPath.push(path);
};

LinearCircularRingDiagram.prototype.createArcDivs = function (circleBase) {
    let arrArrowSvg = Array.from(this.circleParent.querySelectorAll(".circlearrowsvg"));

    arrArrowSvg.map((svg) => {
        let path = svg.querySelector("path");
        if (path) {
            let arrowHolder = document.createElement("div");
            arrowHolder.className = "circlearrowholder";
            circleBase.appendChild(arrowHolder);
            // this.setImageFrame(path, arrowHolder);

            svg.setAttribute("width", path.getBBox().width + 30 + "px");
            svg.setAttribute("height", path.getBBox().height + 30 + "px");
            arrowHolder.appendChild(svg);
        }
    });
};

LinearCircularRingDiagram.prototype.getArrowScale = function (count) {
    switch (this.diagramData.nodes.length) {
        case 2:
            return 0.5;
        case 3:
            return 0.5;
        case 4:
            return 0.5;
        case 5:
            return 0.5;
        case 6:
            return 0.4;
    }
};

LinearCircularRingDiagram.prototype.setupAnimation = function (animationType = "one", callback) {
    this.arrArrowPath.map((path) => (path.style.opacity = 0));
    if (this.centerNode) this.centerNode.style.opacity = 0;
    let moodAnimationDisable = this.diagramParent.parentElement.dataset.moodanimation;
    this.animationFactor = moodAnimationDisable && moodAnimationDisable == "none" ? 0 : 1;
    LinearCircularDiagram.prototype.setupAnimation.call(this, animationType, callback);
    this.arrArrowPath = Array.from(this.diagramParent.querySelectorAll(".arrow-path"));
    this.isReversAnimation = this.checkForArrowReverseAnimation();

    if (this.isReversAnimation) {
        if (this.arrArrowPath) {
            this.arrArrowPath.reverse();
            this.arrArrowPath.push(this.arrArrowPath.shift());
        }
    }
};

LinearCircularRingDiagram.prototype.animateAfterMoodDelay = function () {
    this.diagramParent.style.opacity = 1;
    if (this.centerNode) this.centerNode.style.transition = `all ${0.3 * this.animationFactor}s`;
    if (this.centerNode) this.centerNode.style.opacity = 1;

    if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
};

LinearCircularRingDiagram.prototype.playNext = function (index) {
    return LinearCircularDiagram.prototype.playNext.call(this);
};

LinearCircularRingDiagram.prototype.playPrevious = function (index) {
    return LinearCircularDiagram.prototype.playPrevious.call(this);
};

LinearCircularRingDiagram.prototype.animateArrowForward = function (index) {
    if (this.animationIndex > 0) {
        this.arrArrowPath[this.animationIndex - 1].style.opacity = 1;
        if (this.animationIndex == this.arrArrowPath.length - 1) {
            this.arrArrowPath[this.arrArrowPath.length - 1].style.opacity = 1;
            this.arrArrowPath[this.arrArrowPath.length - 1].style.transition = `all ${0.5 * this.animationFactor}s`;
        }
    }
};

LinearCircularRingDiagram.prototype.animateArrowBackward = function (index) {
    if (index == this.arrArrowPath.length - 1) {
        this.arrArrowPath[index].style.opacity = 0;
        this.arrArrowPath[index - 1].style.opacity = 0;
    } else if (index > 0) {
        this.arrArrowPath[index - 1].style.opacity = 0;
    }
};

LinearCircularRingDiagram.prototype.createElements = function () {
    LinearCircularDiagram.prototype.createElements.call(this);
};

/**
 * Author:    Krishna
 * Created:   13/5/2022
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function LinearHalfCircleDiagram(diagramParent, diagramData, nodeProps, moodData = {}) {
    LinearCircularDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.isReverse = false;
    this.isFlip = false;
}

LinearHalfCircleDiagram.prototype = Object.create(LinearCircularDiagram.prototype);
LinearHalfCircleDiagram.prototype.constructor = LinearHalfCircleDiagram;

LinearHalfCircleDiagram.prototype.initDiagramCreation = function () {
    this.diagramData.properties.hasconnector = true;
    this.diagramData.properties.connector = true;
    LinearCircularDiagram.prototype.initDiagramCreation.call(this);
};

LinearHalfCircleDiagram.prototype.updateNodePosition = function () {
    this.isReverse = this.diagramParent.dataset.isreverse === "true";
    this.isFlip = this.diagramParent.dataset.isflip === "true";
    this.isLineConnector = this.diagramParent.dataset.islineconnector === "true";

    let nodeHeight = this.arrDiagramNode?.[0].parentNode?.clientHeight || 90;
    let heighRadius = this.diagramParent.clientHeight - nodeHeight / 2;
    this.widthRadius = this.diagramParent.clientWidth / 2 - 150;
    this.heightRadius = this.widthRadius > heighRadius ? heighRadius : this.widthRadius * (this.isFlip ? 0.75 : 1); //this.widthRadius * (this.isFlip ? 0.75 : 1);
    this.heightRadius = this.widthRadius <= heighRadius ? this.widthRadius : this.heightRadius;
    this.centerX = this.diagramParent.clientWidth / 2;
    this.centerY = this.isFlip ? 0 : this.diagramParent.clientHeight;

    let centerNode = this.diagramParent.querySelector("[data-id='centerNode']");
    if (centerNode) {
        this.centerNode = centerNode;
        if (this.isFlip) {
            centerNode.style.bottom = "unset";
            centerNode.style.top = "0px";
        } else {
            centerNode.style.bottom = "0px";
            centerNode.style.top = "unset";
        }
        // centerNode.style.height = this.heightRadius - 150 + "px";
        centerNode.style.width = this.heightRadius * this.commonNodeSizeRatio + "px";
        centerNode.style.height = (this.heightRadius / 2) * this.commonNodeSizeRatio + "px";
        this.centerNodeRect = {
            x: centerNode.offsetLeft,
            y: centerNode.offsetTop,
            width: centerNode.clientWidth,
            height: centerNode.clientHeight,
        };
    }

    let circleSvg = this.diagramParent.querySelector("[id='svgbase']");
    if (circleSvg) {
        DiagramNodeUtils.assignSVGNodeAttributes(circleSvg, { width: this.diagramParent.clientWidth, height: this.diagramParent.clientHeight });
        this.drawArc(circleSvg);
    }
};

LinearHalfCircleDiagram.prototype.getCenterHolderSize = function () {
    return { width: 430, height: 400 };
};

LinearHalfCircleDiagram.prototype.drawArc = function (svg) {
    if (!svg) return;
    svg.setAttribute("opacity", 1);
    var path = svg.querySelector("path");
    if (!path) {
        path = DiagramNodeUtils.createSVGElement("path");
        svg.appendChild(path);
    }

    DiagramNodeUtils.assignSVGNodeAttributes(path, {
        d: this.circlePathWithAngle(this.centerX, this.centerY, this.widthRadius, this.heightRadius, this.isFlip ? 180 : 0, this.isReverse),
        stroke: this.arrowColor,
        fill: "none",
        "stroke-width": "2px",
        opacity: 0,
    });

    this.alignNodesInHalfEllipse(path);
    // this.drawArrow(svg);
};

LinearHalfCircleDiagram.prototype.drawArrow = function (svg) {
    let centerNodeCx = this.centerNode.offsetLeft + this.centerNode.clientWidth / 2;
    let centerNodeCy = this.centerNode.offsetTop + this.centerNode.clientHeight / 2;

    this.arrDiagramNode.forEach((node, i) => {
        let nodeParent = node.parentNode.parentElement;

        let startPoint = DiagramUtils.lineIntersectionOnRect(
            nodeParent.clientWidth,
            nodeParent.clientHeight,
            nodeParent.offsetLeft + nodeParent.clientWidth / 2,
            nodeParent.offsetTop + nodeParent.clientHeight / 2,
            centerNodeCx,
            centerNodeCy,
            40
        );

        var endPoint = DiagramUtils.lineIntersectionOnRect(
            this.centerNode.clientWidth,
            this.centerNode.clientHeight,
            centerNodeCx,
            centerNodeCy,
            nodeParent.offsetLeft + nodeParent.clientWidth / 2,
            nodeParent.offsetTop + nodeParent.clientHeight / 2
        );

        let line = this.diagramParent.querySelector("#arrow-path-" + i);
        if (!line) {
            line = DiagramNodeUtils.createSVGElement("line");
            svg.appendChild(line);
        }

        DiagramNodeUtils.assignSVGNodeAttributes(line, {
            x1: startPoint.x,
            y1: startPoint.y,
            x2: endPoint.x,
            y2: endPoint.y,
            stroke: this.arrowColor,
            fill: "none",
            "stroke-width": this.diagramParent.dataset.strokewidth || "2",
            "stroke-dasharray": this.diagramParent.dataset.dasharray || "0",
            id: "arrow-path-" + i,
            "marker-end": `url(#markerend-${this.diagramParent.dataset.connectorend})`,
            "marker-start": `url(#markerstart-${this.diagramParent.dataset.connectorstart})`,
        });
    });
};

LinearHalfCircleDiagram.prototype.alignNodesInHalfEllipse = function (path) {
    let offsetLength = 200;
    let totalLength = path.getTotalLength() + offsetLength;
    let nodeGap = totalLength / (this.arrDiagramNode.length + 1);

    let nodecount = this.arrDiagramNode.length;
    this.arrDiagramNode.forEach((node, i) => {
        let length = nodeGap * (i + 1) - offsetLength / 2;
        let point = path.getPointAtLength(length);
        point.x = parseInt(point.x);
        point.y = parseInt(point.y - (20/(1280/this.slideWidth)));
        let nodeParent = node.parentNode.parentElement;
        nodeParent.classList.remove("clsHalfCircularNode");
        nodeParent.classList.add("clsHalfCircularNode");
        let contentNode = nodeParent.querySelector("[name='contentNode']");
        if (!contentNode) {
            nodeParent.style.left = point.x + "px";
            nodeParent.style.top = point.y + "px";
            let contentRect = DiagramNodeUtils.getOffsetRectByParent(nodeParent, contentNode);
            nodeParent.style.left = point.x - contentRect.x - contentRect.width / 2 + "px";
            nodeParent.style.top = point.y - contentRect.y - contentRect.height / 2 + "px";
        } else {
            nodeParent.style.left = point.x - nodeParent.clientWidth / 2 + "px";
            nodeParent.style.top = point.y - nodeParent.clientHeight / 2 + "px";
        }

        let width = this.diagramParent.clientWidth * this.getHeightRatio();
        nodeParent.style.setProperty("width", width + "px", "important");

        let height = (contentNode?.clientHeight || 0) + (35*3);//this.diagramParent.clientHeight * this.getHeightRatio()
        nodeParent.style.height = height + "px", "important";
        nodeParent.style.maxHeight = height + "px", "important";


        let angle = Math.atan2(this.centerX - point.x, this.centerY - point.y) * (180 / Math.PI) + 90;
        angle = angle < 0 ? 360 + angle : angle;
        nodeParent.setAttribute("data-angle", angle.toFixed(2));
    });
};

LinearHalfCircleDiagram.prototype.getHeightRatio = function () {
    switch (this.arrDiagramNode.length) {
        case 1:
        case 2:
            return 0.4;
        case 3:
            return 0.3;
        case 4:
            return 0.25;
        case 5:
            return 0.2;
        case 6:
            return 0.16;
        case 7:
            return 0.15;
        case 8:
            return 0.12;
        default:
            return 0.16;
    }
};

LinearHalfCircleDiagram.prototype.circlePathWithAngle = function (cx, cy, rx, ry, deg = 0, isReverse = false) {
    var theta = (deg * Math.PI) / 180,
        dx = rx * Math.cos(theta),
        dy = -ry * Math.sin(theta);
    // let directionFlag = isReverse ? 0 : 1
    // return `M${cx} ${cy} m${dx},${dy} a${rx},${ry} 0 1,${directionFlag} ${-2 * dx},${-2 * dy}`;
    let clock = `M${cx - rx} ${cy} a${rx},${ry} 0 1,${1} ${2 * dx},${2 * dy}`;
    let anticlock = `M${cx + rx} ${cy} a${rx},${ry} 0 1,${0} ${-2 * dx},${-2 * dy}`;
    let flipClock = `M${cx - rx} ${cy} a${rx},${ry} 0 1,${0} ${-2 * dx},${-2 * dy}`;
    let flipAntiClock = `M${cx + rx} ${cy} a${rx},${ry} 0 1,${1} ${2 * dx},${2 * dy}`;
    return isReverse ? (this.isFlip ? flipAntiClock : anticlock) : this.isFlip ? flipClock : clock;
};

LinearHalfCircleDiagram.prototype.setDiagramSpecficOption = function (obj) {
    var value = parseFloat(this.diagramData.properties.commonnodesize || this.diagramParent.dataset.commonnodesize || 0.3);
    value = value < 0.4 ? 0.4 : value;
    let commongraphicsize = { visible: true, minval: 0.4, maxval: 0.5, value: parseFloat(value), property: "commonnodesizechange" };
    obj.dpcontent.floatdiagramsettings.commongraphicsize = commongraphicsize;
    let arcFlip = { value: this.isFlip, property: "arcflip" };
    obj.dpcontent.floatdiagramsettings.arcflip = arcFlip;
    this.addReversOption(obj);
    delete obj.dpcontent.floatdiagramsettings.separator;
    delete obj.dpcontent.floatdiagramsettings.graphiclogosize;
};

LinearHalfCircleDiagram.prototype.commonNodeSizeChange = function (obj) {
    let val = parseFloat(obj.value);
    val = val > 0.5 ? 0.5 : val;
    val = val < 0.4 ? 0.4 : val;
    obj.value = val;
    LinearHalfCircleSpokesDiagram.prototype.commonNodeSizeChange.call(this, obj);
};

LinearHalfCircleDiagram.prototype.updateDirection = function (obj) {
    this.doReversDirection(obj);
};

LinearHalfCircleDiagram.prototype.updateFlip = function (obj) {
    this.doFlipOperation(obj);
};

/**
 * Author:    Krishna
 * Created:   17/5/2022 
 *
 * (c) Copyright by Gs.
 **/

"use strict"

function LinearHalfCircleSpokesDiagram(diagramParent, diagramData, nodeProps, moodData = {}) {
    LinearCircularDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.isReverse = false;
    this.isFlip = false;
}

LinearHalfCircleSpokesDiagram.prototype = Object.create(LinearCircularDiagram.prototype);
LinearHalfCircleSpokesDiagram.prototype.constructor = LinearHalfCircleSpokesDiagram;

LinearHalfCircleSpokesDiagram.prototype.initDiagramCreation = function () {
    LinearCircularDiagram.prototype.initDiagramCreation.call(this);
};

LinearHalfCircleSpokesDiagram.prototype.updateNodePosition = function () {
    this.isFlip = this.diagramParent.dataset.isflip === "true";
    let heighRadius = this.diagramParent.clientHeight - 100;
    this.widthRadius = (this.diagramParent.clientWidth / 2) - 100;
    this.heightRadius = this.widthRadius * (this.isFlip ? 0.75 : 0.85);
    this.heightRadius = this.widthRadius <= heighRadius ? this.widthRadius : this.heightRadius;
    this.centerX = this.diagramParent.clientWidth / 2;
    this.centerY = this.isFlip ? 0 : this.diagramParent.clientHeight;

    this.createMarker();

    let centerNode = this.diagramParent.querySelector("[data-id='centerNode']");
    if (centerNode) {
        this.centerNode = centerNode;
        if (this.isFlip) {
            centerNode.style.bottom = "unset";
            centerNode.style.top = "20px";
        } else {
            centerNode.style.bottom = "20px";
            centerNode.style.top = "unset";
        }
        // centerNode.style.height = (this.widthRadius * 0.4) + "px";
        // centerNode.style.width = centerNode.style.height;

        centerNode.style.width = ((this.heightRadius / 2) * this.commonNodeSizeRatio) + "px";
        centerNode.style.height = this.centerNode.style.width;

        this.centerNodeRect = {
            x: centerNode.offsetLeft,
            y: centerNode.offsetTop,
            width: centerNode.clientWidth,
            height: centerNode.clientHeight
        };
    }

    let circleSvg = this.diagramParent.querySelector("[id='svgbase']");
    if (circleSvg) {
        DiagramNodeUtils.assignSVGNodeAttributes(circleSvg, { width: this.diagramParent.clientWidth, height: this.diagramParent.clientHeight });
        this.drawArc(circleSvg);
    }
};

LinearHalfCircleSpokesDiagram.prototype.showHideSecondary = function (value) {
    LinearCircularDiagram.prototype.showHideSecondary.call(this, value)
    this.updateNodePosition();
};

LinearHalfCircleSpokesDiagram.prototype.getCenterHolderSize = function () {
    return { width: 200, height: 200 };
};

LinearHalfCircleSpokesDiagram.prototype.drawArc = function (svg) {
    if (!svg) return;
    svg.setAttribute("opacity", 1);
    var path = svg.querySelector('path');
    if (!path) {
        path = DiagramNodeUtils.createSVGElement("path");
        svg.appendChild(path);
    }

    DiagramNodeUtils.assignSVGNodeAttributes(path, {
        d: this.circlePathWithAngle(
            this.centerX,
            this.centerY,
            this.widthRadius,
            this.heightRadius,
            this.isFlip ? 180 : 0,
            this.isReverse
        ),
        stroke: this.arrowColor,
        fill: "none",
        'stroke-width': "2px",
        opacity: 0
    });

    this.alignNodesInHalfEllipse(path);
    this.drawArrow(svg);
};

LinearHalfCircleSpokesDiagram.prototype.drawArrow = function (svg) {
    let centerNodeCx = this.centerNode.offsetLeft + (this.centerNode.clientWidth / 2);
    let centerNodeCy = this.centerNode.offsetTop + (this.centerNode.clientHeight / 2);

    this.arrDiagramNode.forEach((node, i) => {
        let nodeParent = node.parentNode.parentElement;

        let startPoint = DiagramUtils.lineIntersectionOnRect(
            nodeParent.clientWidth,
            nodeParent.clientHeight,
            nodeParent.offsetLeft + (nodeParent.clientWidth / 2),
            nodeParent.offsetTop + (nodeParent.clientHeight / 2),
            centerNodeCx,
            centerNodeCy,
            40
        )

        var endPoint = DiagramUtils.lineIntersectionOnRect(
            this.centerNode.clientWidth,
            this.centerNode.clientHeight,
            centerNodeCx,
            centerNodeCy,
            nodeParent.offsetLeft + (nodeParent.clientWidth / 2),
            nodeParent.offsetTop + (nodeParent.clientHeight / 2)
        )

        let line = this.diagramParent.querySelector("#arrow-path-" + i);
        if (!line) {
            line = DiagramNodeUtils.createSVGElement("line");
            svg.appendChild(line);
        }

        DiagramNodeUtils.assignSVGNodeAttributes(line, {
            x1: endPoint.x,
            y1: endPoint.y,
            x2: startPoint.x,
            y2: startPoint.y,
            stroke: this.arrowColor,
            fill: "none",
            "stroke-width": this.diagramParent.dataset.strokewidth || "2",
            "stroke-dasharray": this.diagramParent.dataset.dasharray || "0",
            id: "arrow-path-" + i,
            "class": "arrow-path moodanimation",
            "data-animation": "connector",
            "marker-end": `url(#markerend-${this.diagramParent.dataset.connectorend})`,
            "marker-start": `url(#markerstart-${this.diagramParent.dataset.connectorstart})`
        });
    })
};

LinearHalfCircleSpokesDiagram.prototype.alignNodesInHalfEllipse = function (path) {
    let offsetLength = 200;
    let totalLength = path.getTotalLength() + offsetLength;
    let nodeGap = totalLength / (this.arrDiagramNode.length + 1);

    this.arrDiagramNode.forEach((node, i) => {
        let length = nodeGap * (i + 1) - (offsetLength / 2);
        let point = path.getPointAtLength(length);
        point.x = parseInt(point.x);
        point.y = parseInt(point.y);
        let nodeParent = node.parentNode.parentElement;
        nodeParent.classList.remove("clsHalfCircularNode");
        nodeParent.classList.add("clsHalfCircularNode");
        let contentNode = nodeParent.querySelector("[name='contentNode']");
        if (contentNode) {
            nodeParent.style.left = point.x + "px";
            nodeParent.style.top = point.y + "px";
            let contentRect = DiagramNodeUtils.getOffsetRectByParent(nodeParent, contentNode);
            nodeParent.style.left = point.x - contentRect.x - (contentRect.width / 2) + "px";
            nodeParent.style.top = point.y - contentRect.y - (contentRect.height / 2) + "px";
        } else {
            nodeParent.style.left = point.x - (nodeParent.clientWidth / 2) + "px";
            nodeParent.style.top = point.y - (nodeParent.clientHeight / 2) + "px";
        }

        let width = this.diagramParent.clientWidth * this.getWidth()
        nodeParent.style.setProperty("width", width + "px", "important");

        let height = this.diagramParent.clientHeight * this.getWidth()
        this.diagramParent.style.setProperty("--secContentHeight", height + "px", "important");

        let angle = Math.atan2(this.centerX - point.x, this.centerY - point.y) * (180 / Math.PI) + 90;
        angle = angle < 0 ? 360 + angle : angle;
        nodeParent.setAttribute("data-angle", angle.toFixed(2));
    })
}

LinearHalfCircleSpokesDiagram.prototype.getWidth = function () {
    switch (this.arrDiagramNode.length) {
        case 1:
        case 2: return 0.4
        case 3: return 0.3
        case 4: return 0.25
        case 5: return 0.2  
        case 6: return 0.16
        case 7: return 0.15
        case 8: return 0.12
        default: return 0.16
    }
};

LinearHalfCircleSpokesDiagram.prototype.circlePathWithAngle = function (cx, cy, rx, ry, deg = 0, isReverse = false) {
    return LinearHalfCircleDiagram.prototype.circlePathWithAngle.call(this, cx, cy, rx, ry, deg, isReverse);
    var theta = (deg * Math.PI) / 180,
        dx = rx * Math.cos(theta),
        dy = -ry * Math.sin(theta);
    let directionFlag = isReverse ? 0 : 1
    return `M${parseInt(cx)} ${parseInt(cy)} m${parseInt(dx)},${parseInt(dy)} a${parseInt(rx)},${parseInt(ry)} 0 1,${directionFlag} ${-2 * parseInt(dx)},${-2 * parseInt(dy)}`;
};

LinearHalfCircleSpokesDiagram.prototype.getArrowScale = function (count) {
    return 0.4;
};

LinearHalfCircleSpokesDiagram.prototype.setDiagramSpecficOption = function (obj) {
    var value = parseFloat(this.diagramData.properties.commonnodesize || this.diagramParent.dataset.commonnodesize || 0.3);
    value = value < 0.4 ? 0.4 : value;
    let commongraphicsize = { visible: true, minval: 0.4, maxval: 0.7, value: parseFloat(value), property: "commonnodesizechange" }
    obj.dpcontent.floatdiagramsettings.commongraphicsize = commongraphicsize;
    let arcFlip = { value: this.isFlip, property: "arcflip" };
    obj.dpcontent.floatdiagramsettings.arcflip = arcFlip;
    this.addReversOption(obj);
    this.addConnectorSettings(obj);
    delete obj.dpcontent.floatdiagramsettings.separator;
    delete obj.dpcontent.floatdiagramsettings.graphiclogosize;
};

LinearHalfCircleSpokesDiagram.prototype.commonNodeSizeChange = function (obj) {
    var value = parseFloat(obj.value);
    obj.value = value < 0.4 ? 0.4 : value;
    LinearCircularDiagram.prototype.commonNodeSizeChange.call(this, obj);
};

LinearHalfCircleSpokesDiagram.prototype.updateDirection = function (obj) {
    this.doReversDirection(obj);
};

LinearHalfCircleSpokesDiagram.prototype.updateFlip = function (obj) {
    this.doFlipOperation(obj);
};

// Animation related function

LinearHalfCircleSpokesDiagram.prototype.setupAnimation = function (animationType = "one", callback) {
    this.arrArrowPath = Array.from(this.diagramParent.querySelectorAll(".arrow-path"));
    this.arrArrowPath.map(path => path.style.opacity = 0);
    this.centerNode.style.opacity = 0;
    let moodAnimationDisable = this.diagramParent.parentElement.dataset.moodanimation;
    this.animationFactor = moodAnimationDisable && moodAnimationDisable == "none" ? 0 : 1;
    LinearCircularDiagram.prototype.setupAnimation.call(this, animationType, callback);
};

LinearHalfCircleSpokesDiagram.prototype.animateAfterMoodDelay = function () {
    this.diagramParent.style.opacity = 1;
    this.centerNode.style.transition = `all ${0.3 * this.animationFactor}s`;
    this.centerNode.style.opacity = 1;

    if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
};

LinearHalfCircleSpokesDiagram.prototype.animateArrowForward = function (index) {
    this.arrArrowPath[index].style.opacity = 1;
    this.arrArrowPath[index].style.transition = `all ${0.3 * this.animationFactor}s ${0.1 * this.animationFactor}s`;
};

LinearHalfCircleSpokesDiagram.prototype.animateArrowBackward = function (index) {
    this.arrArrowPath[index].style.opacity = 0;
};
/**
 * Author:    Krishna
 * Created:   19/5/2022 
 *
 * (c) Copyright by Gs.
 **/

"use strict"

function LinearHalfCircleRingDiagram(diagramParent, diagramData, nodeProps, moodData = {}) {
    LinearHalfCircleDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
}

LinearHalfCircleRingDiagram.prototype = Object.create(LinearHalfCircleDiagram.prototype);
LinearHalfCircleRingDiagram.prototype.constructor = LinearHalfCircleRingDiagram;

LinearHalfCircleRingDiagram.prototype.initDiagramCreation = function () {
    this.strokeWidth = 200 / (1280/this.slideWidth);
    LinearHalfCircleDiagram.prototype.initDiagramCreation.call(this);
};

LinearHalfCircleRingDiagram.prototype.updateNodePosition = function () {
    this.strokeWidth = 200 / (1280/this.slideWidth);
    this.isReverse = this.diagramParent.dataset.isreverse === "true";
    this.isFlip = this.diagramParent.dataset.isflip === "true";
    this.isLineConnector = this.diagramParent.dataset.islineconnector === "true";

    let heighRadius = this.diagramParent.clientHeight - (this.strokeWidth/2);
    this.widthRadius = heighRadius
    this.heightRadius = this.widthRadius > heighRadius ? heighRadius : this.widthRadius * (this.isFlip ? 0.75 : 1); //this.widthRadius * (this.isFlip ? 0.75 : 1);
    this.heightRadius = this.widthRadius <= heighRadius ? this.widthRadius : this.heightRadius;
    this.centerX = this.diagramParent.clientWidth / 2;
    this.centerY = this.isFlip ? 0 : this.diagramParent.clientHeight;

    let centerNode = this.diagramParent.querySelector("[data-id='centerNode']");
    if (centerNode) {
        this.centerNode = centerNode;
        if (this.isFlip) {
            centerNode.style.bottom = "unset";
            centerNode.style.top = "0px";
        } else {
            centerNode.style.bottom = "0px";
            centerNode.style.top = "unset";
        }
        // centerNode.style.height = this.heightRadius - 150 + "px";
        centerNode.style.width = this.heightRadius * this.commonNodeSizeRatio + "px";
        centerNode.style.height = (this.heightRadius / 2) * this.commonNodeSizeRatio + "px";
        this.centerNodeRect = {
            x: centerNode.offsetLeft,
            y: centerNode.offsetTop,
            width: centerNode.clientWidth,
            height: centerNode.clientHeight,
        };
    }

    let circleSvg = this.diagramParent.querySelector("[id='svgbase']");
    if (circleSvg) {
        DiagramNodeUtils.assignSVGNodeAttributes(circleSvg, { width: this.diagramParent.clientWidth, height: this.diagramParent.clientHeight });
        this.drawArc(circleSvg);
    }
};

LinearHalfCircleRingDiagram.prototype.drawArc = function (svg) {
    if (!svg) return;
    svg.setAttribute("opacity", 1);
    var path = svg.querySelector('path');
    if (!path) {
        path = DiagramNodeUtils.createSVGElement("path");
        svg.appendChild(path);
    }

    DiagramNodeUtils.assignSVGNodeAttributes(path, {
        d: this.circlePathWithAngle(
            this.centerX,
            this.centerY,
            this.heightRadius,
            this.heightRadius,
            this.isFlip ? 180 : 0,
            this.isReverse
        ),
        stroke: "rgba(var(--secondary-color-rgb), 0.15)",
        fill: "none",
        'stroke-width': this.strokeWidth+"px",
        class: "moodanimation",
        "data-animation": "itembg",
        opacity: 1
    });

    this.alignNodesInHalfEllipse(path);
};

LinearHalfCircleRingDiagram.prototype.setDiagramSpecficOption = function (obj) {
    LinearHalfCircleDiagram.prototype.setDiagramSpecficOption.call(this, obj);
    delete obj.dpcontent.floatdiagramsettings.arcflip;
    delete obj.dpcontent.floatdiagramsettings.graphiclogosize;
};

LinearHalfCircleRingDiagram.prototype.getHeightRatio = function () {
    return 0.16
};
/**
 * Author:    Krishna
 * Created:   18/5/2022
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function EllipseDiagram(diagramParent, diagramData, nodeProps, moodData = {}) {
    LinearCircularDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.isReverse = false;
    this.isLineConnector = false;
    this.strech = 0;
}

EllipseDiagram.prototype = Object.create(LinearCircularDiagram.prototype);
EllipseDiagram.prototype.constructor = EllipseDiagram;

EllipseDiagram.prototype.initDiagramCreation = function () {
    this.diagramData.properties.hasconnector = true;
    this.diagramData.properties.connector = true;
    if (this.diagramData.properties.islineconnector) this.isLineConnector = this.diagramData.properties.islineconnector;
    LinearCircularDiagram.prototype.initDiagramCreation.call(this);
};

EllipseDiagram.prototype.updateElements = function (defaultproperties) {
    if (this.diagramParent?.dataset?.strech) this.strech = parseInt(this.diagramParent.dataset.strech);
    LinearCircularDiagram.prototype.updateElements.call(this, defaultproperties);
};

EllipseDiagram.prototype.resetLayout = function () {
    this.updateNodePosition();
    LinearDiagram.prototype.resetLayout.call(this);
};

EllipseDiagram.prototype.updateNodePosition = function () {
    this.createMarker();
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    let iconRation = Math.min(this.slideHeight, this.slideWidth) * 0.08; //(height*2)*0.3//46*(this.slideWidth/1280);
    iconRation = this.arrDiagramNode.length > 6 ? iconRation * 0.75 : iconRation;
    nodesHolder.style.setProperty("--nodeWidth", "200px");
    nodesHolder.style.setProperty("--contentwidth", iconRation * this.getSizeForHolderType() + "px", "important");

    let [height, { x, y }] = this.getDimension();
    this.heightRadius = height;
    this.widthRadius = this.heightRadius;
    this.centerX = x;
    this.centerY = y;

    if (this.centerNode) {
        this.centerNode.style.width = this.heightRadius * this.commonNodeSizeRatio + "px";
        this.centerNode.style.height = this.centerNode.style.width;
        this.centerNode.style.left = this.centerX - this.centerNode.clientWidth / 2 + "px";
        this.centerNode.style.top = this.centerY - this.centerNode.clientHeight / 2 + "px";
        this.centerNode.style.transform = this.isLineConnector && this.arrDiagramNode.length == 3 ? `scale(0.6)` : "";
    }

    let circleSvg = this.diagramParent.querySelector("[id='svgbase']");
    if (circleSvg) {
        DiagramNodeUtils.assignSVGNodeAttributes(circleSvg, { width: this.diagramParent.clientWidth, height: this.diagramParent.clientHeight });
        this.drawArc(circleSvg);
    }

    // this.updateTextNodes();
};

EllipseDiagram.prototype.getCenterHolderSize = function () {
    return { width: 100, height: 100 };
};

EllipseDiagram.prototype.drawArc = function (svg) {
    this.createMarker();
    if (!svg) return;
    svg.setAttribute("opacity", 1);
    var path = svg.querySelector("path");
    if (!path) {
        path = DiagramNodeUtils.createSVGElement("path");
        svg.appendChild(path);
    }

    let selectedStrech = parseInt(this.diagramData.properties.strech);
    let availableStrecth = this.diagramParent.clientWidth / 2 - this.heightRadius - (this.isOnlyContent() ? 50 : 140);
    availableStrecth = Math.min(availableStrecth, selectedStrech || 400);

    DiagramNodeUtils.assignSVGNodeAttributes(path, {
        d: this.circlePathWithAngle(parseInt(this.centerX), parseInt(this.centerY), parseInt(this.widthRadius + availableStrecth), parseInt(this.heightRadius), this.arrDiagramNode.length == 2 ? 0 : 90, this.isReverse),
        stroke: this.arrowColor,
        fill: "none",
        "stroke-width": "2px",
        opacity: 0,
        id: "circle-path",
    });

    //var(--timeline-stroke-color)
    //rgba(var(--secondary-color-rgb), 0.5)

    this.alignNodesInEllipse(path, svg, availableStrecth);
    this.drawArrow(svg);

    if (this.centerNode) {
        this.centerNode.style.width = (this.widthRadius + availableStrecth) * this.commonNodeSizeRatio + "px";
        this.centerNode.style.height = this.heightRadius * this.commonNodeSizeRatio + "px";
        this.centerNode.style.left = this.centerX - this.centerNode.clientWidth / 2 + "px";
        this.centerNode.style.top = this.centerY - this.centerNode.clientHeight / 2 + "px";
    }

    return { path: path };
};

EllipseDiagram.prototype.getHeightRatio = function () {
    switch (this.diagramData.nodes.length) {
        case 2:
            return 1;
        case 3:
        case 4:
            return 1;
        case 5:
            return 0.8;
        case 6:
            return 0.7;
        case 7:
            return 0.6;
        case 8:
            return 0.5;
        default:
            return 0.2;
    }
};

EllipseDiagram.prototype.drawArrow = function (svg) {};

EllipseDiagram.prototype.setNodeWidth = function (node) {};

EllipseDiagram.prototype.alignNodesInEllipse = function (path, svg = null, availableStrecth = 0) {
    let totalLength = path.getTotalLength();
    let nodeGap = totalLength / this.arrDiagramNode.length;
    let nodeCount = this.arrDiagramNode.length;

    this.arrDiagramNode.forEach((node, i) => {
        let length = nodeGap * i;
        length = length == 0 ? 0.00001 : length;
        let point = path.getPointAtLength(length);
        point.x = parseInt(point.x);
        point.y = parseInt(point.y);
        let nodeParent = node.parentNode.parentElement;
        nodeParent.classList.remove("clsHalfCircularNode");
        nodeParent.classList.add("clsHalfCircularNode");
        let contentNode = nodeParent.querySelector("[name='contentNode']");
        let title = nodeParent.querySelector("[data-id='primaryText']");
        let subtitle = nodeParent.querySelector("[data-id='secondaryTextItem']");

        let titleLineHeight = 35;
        let subtitleLineHeight = 28;

        //Find the angle at which the node located
        let angle = Math.atan2(this.centerX - point.x, this.centerY - point.y) * (180 / Math.PI) + 90;
        angle = angle < 0 ? 360 + angle : angle;
        nodeParent.setAttribute("data-angle", angle.toFixed(2));
        nodeParent.setAttribute("data-nodecx", point.x.toFixed(2));
        nodeParent.setAttribute("data-nodecy", point.y.toFixed(2));

        //Setting class for node depend on the location
        var position = angle < 92 && angle > 88 ? "top" : "bottom";
        position = angle > 92 && angle < 270 ? "left" : position;
        position = (angle > 270 && angle < 360) || angle < 90 ? "right" : position;
        position = angle > 268 && angle < 272 ? "bottom" : position;
        nodeParent.setAttribute("data-nodealign", position);

        let heightRation = this.getHeightRatio();
        let height = this.heightRadius * heightRation;
        nodeParent.style.height = height + "px";
        nodeParent.style.maxHeight = height + "px";

        //Setting the width of the node depend on the available space
        let contentWidth = contentNode?.clientWidth || 0;
        if (position == "top" || position == "bottom") {
            nodeParent.style.width = this.diagramParent.clientWidth / 2 + "px";
            let height = this.diagramParent.clientHeight / 2 - this.heightRadius + contentWidth / 2;
            height = [3, 5, 7].includes(nodeCount) ? height + (this.diffValue || 0) : height;
            let minHeight = titleLineHeight + subtitleLineHeight * 2 + contentWidth;
            nodeParent.style.height = height + "px"; //Math.max(height, minHeight) + "px";
            nodeParent.style.maxHeight = nodeParent.style.height;
        } else if (position == "left") {
            nodeParent.style.width = point.x + contentWidth / 2 + "px";
            // nodeParent.style.height = titleLineHeight + subtitleLineHeight * getLineCountBasedOnNodeCount(nodeCount) + "px";
            nodeParent.style.left = "0px";
        } else if (position == "right") {
            nodeParent.style.width = this.diagramParent.clientWidth - (point.x - contentWidth / 2) + "px";
            // nodeParent.style.height = titleLineHeight + subtitleLineHeight * getLineCountBasedOnNodeCount(nodeCount) + "px";
        }

        //Position the node after width change
        if (contentNode) {
            nodeParent.style.left = point.x + "px";
            nodeParent.style.top = point.y + "px";
            let contentRect = DiagramNodeUtils.getOffsetRectByParent(nodeParent, contentNode);
            nodeParent.style.left = point.x - contentRect.x - contentRect.width / 2 + "px";
            nodeParent.style.top = point.y - contentRect.y - contentRect.height / 2 + "px";
        } else {
            nodeParent.style.left = point.x - nodeParent.clientWidth / 2 + "px";
            nodeParent.style.top = point.y - nodeParent.clientHeight / 2 + "px";
        }

        if (this.isLineConnector) {
            //Used to draw line connector
            if (i > 0) this.setupConnectingPointForLineConnector(i - 1, i, svg);
            if (i == this.arrDiagramNode.length - 1) this.setupConnectingPointForLineConnector(i, 0, svg);
        } else {
            //Used to draw curve connectors
            this.setupConnectingPointForCurvedConnector(point, contentWidth, i, angle, nodeParent, svg, availableStrecth);
        }
    });

    function getLineCountBasedOnNodeCount(count) {
        switch (count) {
            case 6:
            case 7:
            case 8:
                return 2;
            default:
                return 3;
        }
    }
};

EllipseDiagram.prototype.circlePathWithAngle = function (cx, cy, rx, ry, deg = 0, isReverse = false) {
    var theta = (deg * Math.PI) / 180,
        dx = rx * Math.cos(theta),
        dy = -ry * Math.sin(theta);
    let directionFlag = isReverse ? 0 : 1;
    let firstHalf = `m${dx + cx},${dy + cy} a${rx},${ry} 0 1,${directionFlag} ${-2 * dx},${-2 * dy}`;
    let secondHalf = `a${rx},${ry} 0 1,${directionFlag} ${2 * dx},${2 * dy}`;
    return firstHalf + secondHalf;
};

EllipseDiagram.prototype.getArrowScale = function (count) {
    return 0.4;
};

EllipseDiagram.prototype.setDiagramSpecficOption = function (obj) {
    let availableStrecth = this.diagramParent.clientWidth / 2 - this.heightRadius - (this.isOnlyContent() ? 50 : 140);
    availableStrecth = Math.min(availableStrecth, 100);
    LinearCircularDiagram.prototype.setDiagramSpecficOption.call(this, obj);
    let strechslider = { minval: 1, maxval: availableStrecth, value: this.strech, property: "strectchange" };
    obj.dpcontent.floatdiagramsettings.strechslider = strechslider;
    let circleconnectortype = { value: this.isLineConnector, property: "circleconnectortype" };
    obj.dpcontent.floatdiagramsettings.circleconnectortype = circleconnectortype;
    this.addArrowSetting(obj);
    this.addReversOption(obj);

    delete obj.dpcontent.floatdiagramsettings.graphiclogosize;
};

EllipseDiagram.prototype.addConnectorSettings = function (obj) {
    this.addLineSetting(obj);
};

EllipseDiagram.prototype.updateStrech = function (obj) {
    this.strech = parseInt(obj.value);
    if (!obj.dragging) this.diagramParent.setAttribute("data-strech", this.strech);
    this.diagramData.properties.strech = this.strech;
    this.updateNodePosition();

    let contentType = this.centerNode.firstElementChild.dataset.contentType;
    let imageNode = this.centerNode.querySelector("img[data-id='imageNode'],img[data-id='logoNode']");
    if (imageNode) CommonImageUtils.updateImageBounds(imageNode, { islogofit: contentType == "logo", contenttype: contentType }, 1);

    if (obj.hasOwnProperty("dragging") && !obj.dragging) {
        this.updateTextNodes();
    }
};

EllipseDiagram.prototype.getDimension = function () {
    let avilableHeight = this.diagramParent.clientHeight / 2;
    let [nodeMinHeight, nodeMaxHeight] = getTextHeight(this);
    let [, ratio] = this.isHeightReductionRequired();

    let centerX = this.diagramParent.clientWidth / 2;
    let centerY = this.diagramParent.clientHeight / 2;

    let node = this.arrDiagramNode[0].parentNode.parentElement;
    let contentNodeHeight = node.querySelector("[name='contentNode']")?.offsetHeight || 0;
    let height = avilableHeight * 0.62 - contentNodeHeight / 2;

    if ([3, 5, 7].includes(this.arrDiagramNode.length)) {
        let diff = (avilableHeight - contentNodeHeight / 2 - height) / 2;
        centerY = diff + centerY;
        height = height + diff / 2;
        this.diffValue = diff;
    }

    return [height, { x: centerX, y: centerY }];

    function getTextHeight(data) {
        let tMin = 20;
        let tMax = 30;
        let sMin = 15;
        let sMax = 25;
        let textMin = data.diagramData.properties.secondarytext ? tMin + sMin : tMin;
        let textMax = data.diagramData.properties.secondarytext ? tMax + sMax : tMax;

        let node = data.arrDiagramNode[0].parentNode.parentElement;
        let contentNodeHeight = node.querySelector("[name='contentNode']")?.offsetHeight || 0;
        let nodeMinHeight = textMin + contentNodeHeight;
        let nodeMaxHeight = textMax + contentNodeHeight;

        return [nodeMinHeight, nodeMaxHeight];
    }
};

EllipseDiagram.prototype.isOnlyContent = function () {
    return !this.diagramData.properties.primarytext && !this.diagramData.properties.secondarytext;
};

EllipseDiagram.prototype.isHeightReductionRequired = function () {
    let nodeCount = this.arrDiagramNode.length;
    let boolReduce = nodeCount != 2;
    let reductionRatio = nodeCount == 4 || nodeCount == 6 || nodeCount == 8 ? 1 : 2;
    return [boolReduce, reductionRatio];
};

EllipseDiagram.prototype.updateDirection = function (obj) {
    this.doReversDirection(obj);
};

EllipseDiagram.prototype.setupConnectingPointForCurvedConnector = function (point, contentWidth, i, angle, nodeParent, svg, availableStrecth = 0) {
    let resultCircle = Intersection.intersectCircleEllipse({ x: point.x, y: point.y }, contentWidth / 2 + 20, { x: this.centerX, y: this.centerY }, this.widthRadius + availableStrecth, this.heightRadius);
    this.addPointDiv(resultCircle.points.flat(2), i, angle, nodeParent, svg, availableStrecth);
};

EllipseDiagram.prototype.setupConnectingPointForLineConnector = function (sIndex, dIndex, svg) {
    let preNode = this.arrDiagramNode[sIndex].parentNode.parentElement;
    let curNode = this.arrDiagramNode[dIndex].parentNode.parentElement;
    let target = "contentNode";
    let preTarget = preNode.querySelector("[name='" + target + "']");
    let curTarget = curNode.querySelector("[name='" + target + "']");

    let p1 = { x: parseFloat(preNode.dataset.nodecx), y: parseFloat(preNode.dataset.nodecy) };
    let p2 = { x: parseFloat(curNode.dataset.nodecx), y: parseFloat(curNode.dataset.nodecy) };
    let line = { p1: p1, p2: p2 };
    let circle = { center: p1, radius: preTarget.clientWidth / 2 };
    let resultPreNode = DiagramUtils.lineIntersectionOnCircle(circle, line, 8);
    circle = { center: p2, radius: curTarget.clientWidth / 2 };
    let resultCurNode = DiagramUtils.lineIntersectionOnCircle(circle, line, 8);

    curNode.setAttribute("data-aspx", resultCurNode[0].x);
    curNode.setAttribute("data-aspy", resultCurNode[0].y);
    preNode.setAttribute("data-aepx", resultPreNode[0].x);
    preNode.setAttribute("data-aepy", resultPreNode[0].y);

    this.drawLineConnector(sIndex, dIndex, svg);
};

EllipseDiagram.prototype.addPointDiv = function (arrPoints, nodeIndex, angle, nodeParent, svg, availableStrecth) {
    arrPoints.forEach((point, i, arr) => {
        // let id = `ellipseConnectorPoint-${nodeIndex},${i}`;
        // let div = this.diagramParent.querySelector(`[id='${id}']`) || document.createElement("div");
        // div.id = id;
        // div.style.width = "5px";
        // div.style.height = "5px";
        // div.style.position = "absolute";
        // div.style.backgroundColor = "gray";
        // this.diagramParent.appendChild(div);
        // div.style.top = point.y - (div.clientHeight / 2) + "px";
        // div.style.left = point.x - (div.clientWidth / 2) + "px";

        let dotAngle = parseInt(Math.atan2(this.centerX - point.x, this.centerY - point.y) * (180 / Math.PI) + 90);
        dotAngle = dotAngle < 0 ? 360 + dotAngle : dotAngle;

        if (i == 1) {
            let prePoint = arr[0];
            let precAngle = parseInt(Math.atan2(this.centerX - prePoint.x, this.centerY - prePoint.y) * (180 / Math.PI) + 90);
            precAngle = precAngle < 0 ? 360 + precAngle : precAngle;

            if (angle < precAngle && angle < dotAngle) {
                angle = 1000;
            }
            if (angle > 340 && dotAngle > 310 && precAngle < 10) {
                let name = this.isReverse ? "aep" : "asp";
                nodeParent.setAttribute("data-" + name + "x", prePoint.x.toFixed(2));
                nodeParent.setAttribute("data-" + name + "y", prePoint.y.toFixed(2));
            }
        }

        let pointName = angle < dotAngle ? (this.isReverse ? "aep" : "asp") : this.isReverse ? "asp" : "aep";
        nodeParent.setAttribute("data-" + pointName + "x", point.x.toFixed(2));
        nodeParent.setAttribute("data-" + pointName + "y", point.y.toFixed(2));
    });
    if (nodeIndex > 0) {
        this.drawConnector(nodeIndex - 1, nodeIndex, svg, availableStrecth);
    }
    if (nodeIndex == this.arrDiagramNode.length - 1) {
        this.drawConnector(nodeIndex, 0, svg, availableStrecth);
    }
};

EllipseDiagram.prototype.drawConnector = function (sIndex, dIndex, svg, availableStrecth) {
    let preNode = this.arrDiagramNode[sIndex].parentNode.parentElement;
    let curNode = this.arrDiagramNode[dIndex].parentNode.parentElement;
    let sp = { x: preNode.dataset.aepx, y: preNode.dataset.aepy };
    let ep = { x: curNode.dataset.aspx, y: curNode.dataset.aspy };
    let rx = this.widthRadius + availableStrecth;
    let ry = this.heightRadius;
    let flip = this.isReverse ? 0 : 1;
    let d = ` M${sp.x},${sp.y} A${rx},${ry} 0 0,${flip} ${ep.x},${ep.y}`;

    let arcId = "arrow-path-" + sIndex;
    var path = svg.querySelector(`[id='${arcId}']`);
    if (!path) {
        path = DiagramNodeUtils.createSVGElement("path");
        svg.appendChild(path);
    }

    DiagramNodeUtils.assignSVGNodeAttributes(path, {
        d: d,
        stroke: this.arrowColor,
        fill: "none",
        opacity: 1,
        id: arcId,
        "stroke-width": this.diagramParent.dataset.strokewidth || "3",
        "stroke-dasharray": this.diagramParent.dataset.dasharray || "0",
        id: arcId,
        class: "arrow-path moodanimation",
        "data-animation": "connector",
        "marker-end": `url(#markerend-${this.diagramParent.dataset.connectorend})`,
        "marker-start": `url(#markerstart-${this.diagramParent.dataset.connectorstart})`,
    });
};

EllipseDiagram.prototype.drawLineConnector = function (sIndex, dIndex, svg) {
    let sNode = this.arrDiagramNode[sIndex].parentNode.parentElement;
    let dNode = this.arrDiagramNode[dIndex].parentNode.parentElement;
    let p1 = { x: sNode.dataset.aepx, y: sNode.dataset.aepy };
    let p2 = { x: dNode.dataset.aspx, y: dNode.dataset.aspy };

    let arcId = "arrow-path-" + sIndex;
    var line = svg.querySelector(`[id='${arcId}']`);
    if (line && line.tagName != "line") {
        line.remove();
        line = null;
    }

    if (!line) {
        line = DiagramNodeUtils.createSVGElement("line");
        svg.appendChild(line);
    }

    DiagramNodeUtils.assignSVGNodeAttributes(line, {
        x1: p1.x,
        y1: p1.y,
        x2: p2.x,
        y2: p2.y,
        stroke: this.arrowColor,
        fill: "none",
        opacity: 1,
        id: arcId,
        "stroke-width": this.diagramParent.dataset.strokewidth || "2",
        "stroke-dasharray": this.diagramParent.dataset.dasharray || "0",
        id: arcId,
        class: "arrow-path moodanimation",
        "data-animation": "connector",
        "marker-end": `url(#markerend-${this.diagramParent.dataset.connectorend})`,
        "marker-start": `url(#markerstart-${this.diagramParent.dataset.connectorstart})`,
    });
};

EllipseDiagram.prototype.updateConnectorType = function (obj) {
    this.clearOldPath();
    this.isLineConnector = obj.value;
    this.diagramParent.setAttribute("data-islineconnector", this.isLineConnector);
    this.diagramData.properties.islineconnector = this.isLineConnector;
    this.updateNodePosition();
};

// Animation related functions

EllipseDiagram.prototype.setupAnimation = function (animationType = "one", callback) {
    this.arrArrowPath = Array.from(this.diagramParent.querySelectorAll(".arrow-path"));
    this.arrArrowPath.map((path) => (path.style.opacity = 0));
    this.centerNode.style.opacity = 0;
    let moodAnimationDisable = this.diagramParent.parentElement.dataset.moodanimation;
    this.animationFactor = moodAnimationDisable && moodAnimationDisable == "none" ? 0 : 1;
    LinearCircularDiagram.prototype.setupAnimation.call(this, animationType, callback);
};

EllipseDiagram.prototype.animateAfterMoodDelay = function () {
    this.diagramParent.style.opacity = 1;
    this.centerNode.style.transition = `all ${0.3 * this.animationFactor}s`;
    this.centerNode.style.opacity = 1;

    if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
};

EllipseDiagram.prototype.animateArrowForward = function (index) {
    if (this.animationIndex > 0) {
        this.arrArrowPath[this.animationIndex - 1].style.opacity = 1;
        if (this.animationIndex == this.arrArrowPath.length - 1) {
            this.arrArrowPath[this.arrArrowPath.length - 1].style.opacity = 1;
            this.arrArrowPath[this.arrArrowPath.length - 1].style.transition = `all ${0.5 * this.animationFactor}s`;
        }
    }
};

EllipseDiagram.prototype.animateArrowBackward = function (index) {
    if (index == this.arrArrowPath.length - 1) {
        this.arrArrowPath[index].style.opacity = 0;
        this.arrArrowPath[index - 1].style.opacity = 0;
    } else if (index > 0) {
        this.arrArrowPath[index - 1].style.opacity = 0;
    }
};

/**
 * Author:    Krishna
 * Created:   19/5/2022
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function EllipticalSpokesDiagram(diagramParent, diagramData, nodeProps, moodData = {}) {
    EllipseDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.isReverse = false;
    this.strech = 0;
}

EllipticalSpokesDiagram.prototype = Object.create(EllipseDiagram.prototype);
EllipticalSpokesDiagram.prototype.constructor = EllipticalSpokesDiagram;

EllipticalSpokesDiagram.prototype.drawArc = function (svg) {
    if (!svg) return;
    svg.setAttribute("opacity", 1);
    var path = svg.querySelector("path");
    if (!path) {
        path = DiagramNodeUtils.createSVGElement("path");
        svg.appendChild(path);
    }

    let selectedStrech = parseInt(this.diagramData.properties.strech);
    let availableStrecth = this.diagramParent.clientWidth / 2 - this.heightRadius - (this.isOnlyContent() ? 50 : 140);
    availableStrecth = Math.min(availableStrecth, selectedStrech || 400);

    DiagramNodeUtils.assignSVGNodeAttributes(path, {
        d: this.circlePathWithAngle(parseInt(this.centerX), parseInt(this.centerY), parseInt(this.widthRadius + availableStrecth), parseInt(this.heightRadius), this.arrDiagramNode.length == 2 ? 0 : 90, this.isReverse),
        stroke: this.arrowColor,
        fill: "none",
        "stroke-width": "2px",
        opacity: 0,
    });

    // if (this.centerNode) {
    //     this.centerNode.style.width = ((this.widthRadius + availableStrecth) * this.commonNodeSizeRatio) + "px";
    //     this.centerNode.style.height = (this.heightRadius * this.commonNodeSizeRatio) + "px";
    //     this.centerNode.style.left = this.centerX - (this.centerNode.clientWidth / 2) + "px";
    //     this.centerNode.style.top = this.centerY - (this.centerNode.clientHeight / 2) + "px";
    // }

    this.alignNodesInEllipse(path, svg);
    this.drawArrow(svg);
};

EllipticalSpokesDiagram.prototype.drawArrow = function (svg) {
    let centerNodeCx = this.centerNode.offsetLeft + this.centerNode.clientWidth / 2;
    let centerNodeCy = this.centerNode.offsetTop + this.centerNode.clientHeight / 2;

    this.arrDiagramNode.forEach((node, i) => {
        let nodeParent = node.parentNode.parentElement;
        let contentNode = nodeParent.querySelector("[name='contentNode']");
        let targetNode = contentNode || nodeParent;
        let contentRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent, targetNode);

        let startPointNew = DiagramUtils.lineIntersectionOnEllipse(
            centerNodeCx,
            centerNodeCy,
            this.centerNode.clientWidth / 2,
            this.centerNode.clientHeight / 2,
            centerNodeCx,
            centerNodeCy,
            contentRect.x + contentRect.width / 2,
            contentRect.y + contentRect.height / 2,
            30
        );

        let endPointNew = DiagramUtils.lineIntersectionOnEllipse(
            contentRect.x + contentRect.width / 2,
            contentRect.y + contentRect.height / 2,
            contentRect.width / 2,
            contentRect.height / 2,
            centerNodeCx,
            centerNodeCy,
            contentRect.x + contentRect.width / 2,
            contentRect.y + contentRect.height / 2,
            -20
        );

        let endPoint = { x: startPointNew[0][0], y: startPointNew[0][1] };
        let startPoint = { x: endPointNew[0][0], y: endPointNew[0][1] };

        let line = this.diagramParent.querySelector("#arrow-path-" + i);
        if (!line) {
            line = DiagramNodeUtils.createSVGElement("line");
            svg.appendChild(line);
        }

        DiagramNodeUtils.assignSVGNodeAttributes(line, {
            x1: startPoint.x,
            y1: startPoint.y,
            x2: endPoint.x,
            y2: endPoint.y,
            stroke: this.arrowColor,
            fill: "none",
            "stroke-width": this.diagramParent.dataset.strokewidth || "2",
            "stroke-dasharray": this.diagramParent.dataset.dasharray || "0",
            id: "arrow-path-" + i,
            class: "arrow-path moodanimation",
            "data-animation": "connector",
            "marker-end": `url(#markerend-${this.diagramParent.dataset.connectorend})`,
            "marker-start": `url(#markerstart-${this.diagramParent.dataset.connectorstart})`,
        });
    });
};

EllipticalSpokesDiagram.prototype.addConnectorSettings = function (obj) {
    this.addLineSetting(obj);
    this.addArrowSetting(obj);
};

EllipticalSpokesDiagram.prototype.addPointDiv = function (arrPoints, nodeIndex, angle, nodeParent, svg) {};

EllipticalSpokesDiagram.prototype.setDiagramSpecficOption = function (obj) {
    EllipseDiagram.prototype.setDiagramSpecficOption.call(this, obj);
    let value = this.diagramData.properties.commonnodesize || this.diagramParent.dataset.commonnodesize || 0.3;
    let commongraphicsize = { visible: true, minval: 0.3, maxval: 0.5, value: parseFloat(value), property: "commonnodesizechange" };
    obj.dpcontent.floatdiagramsettings.commongraphicsize = commongraphicsize;
    delete obj.dpcontent.floatdiagramsettings.circleconnectortype;
    delete obj.dpcontent.floatdiagramsettings.graphiclogosize;
};
// Animation related functions

EllipticalSpokesDiagram.prototype.setupAnimation = function (animationType = "one", callback) {
    this.arrArrowPath = Array.from(this.diagramParent.querySelectorAll(".arrow-path"));
    this.arrArrowPath.map((path) => (path.style.opacity = 0));
    this.centerNode.style.opacity = 0;
    let moodAnimationDisable = this.diagramParent.parentElement.dataset.moodanimation;
    this.animationFactor = moodAnimationDisable && moodAnimationDisable == "none" ? 0 : 1;
    EllipseDiagram.prototype.setupAnimation.call(this, animationType, callback);
};

EllipticalSpokesDiagram.prototype.animateAfterMoodDelay = function () {
    this.diagramParent.style.opacity = 1;
    this.centerNode.style.transition = `all ${0.3 * this.animationFactor}s`;
    this.centerNode.style.opacity = 1;

    if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
};

EllipticalSpokesDiagram.prototype.animateArrowForward = function (index) {
    this.arrArrowPath[index].style.opacity = 1;
    this.arrArrowPath[index].style.transition = `all ${0.3 * this.animationFactor}s ${0.1 * this.animationFactor}s`;
};

EllipticalSpokesDiagram.prototype.animateArrowBackward = function (index) {
    this.arrArrowPath[index].style.opacity = 0;
};

/**
 * Author:    Krishna
 * Created:   20/5/2022 
 *
 * (c) Copyright by Gs.
 **/

"use strict"

function SemiEllipseDiagram(diagramParent, diagramData, nodeProps, moodData = {}) {
    EllipseDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.isReverse = false;
    this.strech = 0;
}

SemiEllipseDiagram.prototype = Object.create(EllipseDiagram.prototype);
SemiEllipseDiagram.prototype.constructor = SemiEllipseDiagram;

SemiEllipseDiagram.prototype.drawArc = function (svg) {
    let { path } = EllipseDiagram.prototype.drawArc.call(this, svg);
    path.setAttribute("marker-start", "url(#semiellipsedot)");
    path.setAttribute("marker-end", "url(#semiellipsedot)");
};

SemiEllipseDiagram.prototype.circlePathWithAngle = function (cx, cy, rx, ry, deg = 0, isReverse = false) {
    var theta = (90 * Math.PI) / 180,
        dx = rx * Math.cos(theta),
        dy = -ry * Math.sin(theta);
    let directionFlag = isReverse ? 0 : 1
    let firstHalf = `m${dx + cx},${dy + cy} a${rx},${ry} 0 1,${directionFlag} ${-2 * dx},${-2 * dy}`;
    return firstHalf;
};

SemiEllipseDiagram.prototype.alignNodesInEllipse = function (path) {
    let offsetLength = 70;
    let totalLength = path.getTotalLength() - offsetLength;
    let nodeGap = totalLength / this.arrDiagramNode.length;

    this.arrDiagramNode.forEach((node, i) => {
        let length = (nodeGap * (i + 1)) - (nodeGap / 2) + (offsetLength / 2);
        let point = path.getPointAtLength(length);
        point.x = parseInt(point.x);
        point.y = parseInt(point.y);
        let nodeParent = node.parentNode.parentElement;
        nodeParent.classList.remove("clsHalfCircularNode");
        nodeParent.classList.add("clsHalfCircularNode");
        let contentNode = nodeParent.querySelector("[name='contentNode']");
        if (contentNode) {
            nodeParent.style.left = point.x + "px";
            nodeParent.style.top = point.y + "px";
            let contentRect = DiagramNodeUtils.getOffsetRectByParent(nodeParent, contentNode);
            nodeParent.style.left = point.x - contentRect.x - (contentRect.width / 2) + "px";
            nodeParent.style.top = point.y - contentRect.y - (contentRect.height / 2) + "px";
            this.setNodeWidth(nodeParent, point, contentRect);
        } else {
            nodeParent.style.left = point.x - (nodeParent.clientWidth / 2) + "px";
            nodeParent.style.top = point.y - (nodeParent.clientHeight / 2) + "px";
            this.setNodeWidth(nodeParent, point);
        }

        let angle = Math.atan2(this.centerX - point.x, this.centerY - point.y) * (180 / Math.PI) + 90;
        angle = angle < 0 ? 360 + angle : angle;
        nodeParent.setAttribute("data-angle", angle.toFixed(2));

        nodeParent.classList.remove("clsSemiEllipseNodeRightAlign");
        nodeParent.classList.remove("clsSemiEllipseNodeLeftAlign");
        nodeParent.classList.add(this.isReverse ? "clsSemiEllipseNodeRightAlign" : "clsSemiEllipseNodeLeftAlign");
    })
};

SemiEllipseDiagram.prototype.setNodeWidth = function (node, point, contentRect) {
    let contentWidth = contentRect?.width || 0;
    if (!this.isReverse) {
        node.style.width = this.diagramParent.clientWidth - (point.x - (contentWidth / 2)) + "px";
    } else {
        node.style.width = point.x + (contentWidth / 2) + "px";
        node.style.left = "0px";
    }
};

SemiEllipseDiagram.prototype.createMarker = function () {
    let marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
    marker.innerHTML = '<circle cx="6" cy="6" r="6"></circle>';
    marker.firstElementChild.setAttribute("style", "transform: scale(" + this.getArrowScale() + ")");

    DiagramNodeUtils.assignSVGNodeAttributes(marker, {
        id: "semiellipsedot",
        markerWidth: 12,
        markerHeight: 12,
        refX: this.getArrowScale() * 6,
        refY: this.getArrowScale() * 6,
        orient: "auto",
        fill: "rgba(var(--secondary-color-rgb), 1)"
    })

    let ldef = DiagramNodeUtils.getDocumentDefs(this.diagramParent, true);
    let defs = ldef;
    let arrMarker = Array.from(defs.querySelectorAll("marker"));
    arrMarker.map((marker) => {
        marker.parentElement.removeChild(marker);
    });

    defs.appendChild(marker);
};
/**
 * Author:    Krishna
 * Created:   12 thu Nov 2020
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function CircularColorRingDiagram(diagramParent, diagramData, nodeProps, moodData = {}) {
    LinearCircularDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "clsCircularNewDiagram";
    this.diagramParent.setAttribute("data-toggleassets", "true");
    this.diagramParent.setAttribute("data-togglecategory", "circular6thmodel");
    this.centerNodeClass = "CommonDiagramNode";
}

CircularColorRingDiagram.prototype = Object.create(LinearCircularDiagram.prototype);
CircularColorRingDiagram.prototype.constructor = LinearCircularDiagram;

CircularColorRingDiagram.prototype.setupLinearCircularDiagram = function (parent, data, iconChangeCallback, textBoxData) {
    let oldBase = this.diagramParent.querySelector("[id='circularbase']");
    if (oldBase) this.diagramParent.removeChild(oldBase);

    let baseDiv = document.createElement("div");
    baseDiv.className = "circularbase clsMultiColorParent accent1 ";
    baseDiv.id = "circularbase";
    baseDiv.setAttribute("data-displayname", "circular");
    this.diagramParent.appendChild(baseDiv);
    this.circleParent = baseDiv;

    let svg = DiagramNodeUtils.createSVGElement("svg");
    svg.setAttribute("width", baseDiv.clientWidth);
    svg.setAttribute("height", baseDiv.clientHeight);
    svg.setAttribute("id", "svgbase");
    svg.setAttribute("class", "svgbase");
    // svg.setAttribute("opacity", 0);
    baseDiv.appendChild(svg);

    let path = DiagramNodeUtils.createSVGElement("path");
    let svgRect = { width: baseDiv.clientWidth, height: baseDiv.clientHeight };
    let { radius, centerX, centerY } = this.getCircleRadius(svgRect);
    let d = DiagramNodeUtils.circlePathWithAngle(centerX, centerY, radius, 0);
    path.setAttribute("d", d);
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", "gray");
    path.setAttribute("stroke-width", "2");
    path.setAttribute("opacity", 0);
    svg.appendChild(path);

    if (this.nodeProps.centernodevisible && this.nodeProps.centernodevisible == "true") {
        let div = this.setCenterPlaceHolder(baseDiv, this.getCenterHolderSize());
        this.centerNode = div;
        div.style.top = centerY - div.offsetHeight / 2 + "px";
    }

    this.updateNodePosition();

    let ringRadius = radius - 50;
    let offset = 360 / this.arrDiagramNode.length / 2;
    let gap = 5;
    this.arrDiagramNode.map(
        function (node, i) {
            let nodeparent = node.getNodeParent().parentElement;
            let angle = parseFloat(nodeparent.dataset.angle);

            let startAngle = angle - offset + gap / 2;
            let endAngle = angle + offset - gap / 2;

            let startPoint = this.polarToCartesian(centerX, centerY, ringRadius, startAngle);
            let endPoint = this.polarToCartesian(centerX, centerY, ringRadius, endAngle);

            this.drawConnector(svg, startAngle, endAngle, ringRadius, startPoint, endPoint, i);
        }.bind(this)
    );

    return;
};

CircularColorRingDiagram.prototype.getCenterHolderSize = function () {
    let baseDiv = this.diagramParent.querySelector("#circularbase");
    if (baseDiv) {
        let svgRect = { width: baseDiv.clientWidth, height: baseDiv.clientHeight };
        let { radius } = this.getCircleRadius(svgRect);
        let centerSize = radius * this.commonNodeSizeRatio;
        return { width: centerSize, height: centerSize };
    }
    return { width: 100, height: 100 };
};

CircularColorRingDiagram.prototype.updateNodePosition = function () {
    let baseDiv = this.diagramParent.querySelector("[id='circularbase']");
    if (!baseDiv) return;

    let centerNode = baseDiv.querySelector("[data-id='centerNode']");
    if (centerNode) {
        let size = this.getCenterHolderSize();
        centerNode.style.width = size.width + "px";
        centerNode.style.height = size.height + "px";

        let centerHolder = this.diagramParent.querySelector("[name='centerHolderParent']");
        let contentType = centerHolder.dataset.type;
        let imageNode = centerHolder.querySelector("img[data-id='imageNode'],img[data-id='logoNode']");
        if (imageNode) CommonImageUtils.updateImageBounds(imageNode, { islogofit: contentType == "logo", contenttype: contentType }, 1);
    }

    let svgRect = { width: baseDiv.clientWidth, height: baseDiv.clientHeight };
    let { radius, centerX, centerY } = this.getCircleRadius(svgRect);
    if (this.centerNode) this.centerNode.style.top = centerY - this.centerNode.offsetHeight / 2 + "px";

    let count = this.diagramData.nodes.length;
    let angleDif = 360 / count;
    let arrAlignClassname = ["circularAlignLeft", "circularAlignRight", "circularAlignTop"];
    let arrTextAlignClassname = ["circularTextAlignTop", "circularTextAlignBottom"];

    let pathOffset = 10;

    let top = 0;
    let bottom = 0;

    this.arrDiagramNode.map(
        function (nodeObj, i) {
            let node = nodeObj.getNodeParent().parentElement;
            if (node) {
                let angle = angleDif * i + this.getAngleBaseOnNodeCount();
                let iconCenterPoint = this.polarToCartesian(centerX, centerY, radius, angle);
                node.setAttribute("data-angle", angle);

                let contentNode = node.querySelector("[name='contentNode']");
                let point = this.intersection(centerX, centerY, radius, iconCenterPoint.x, iconCenterPoint.y, contentNode.clientHeight / 2 + pathOffset);
                node.setAttribute("data-arfx", point[1]);
                node.setAttribute("data-arfy", point[3]);
                node.setAttribute("data-arbx", point[0]);
                node.setAttribute("data-arby", point[2]);

                let nodeGroup = node.querySelector("[name='nodeGroup']");
                arrAlignClassname.map((className) => {
                    nodeGroup.classList.remove(className);
                });

                let heightRation = this.getHeightRatio();
                let height = radius * heightRation;
                node.style.height = height + "px";

                if (angle > 0 && angle < 180) nodeGroup.classList.add("circularAlignRight");
                else if (angle > 180 && angle < 360) nodeGroup.classList.add("circularAlignLeft");
                else if (angle == 0) {
                    nodeGroup.classList.add("circularAlignTopCenter");
                }

                let data = { left: iconCenterPoint.x, top: iconCenterPoint.y };
                node.style.width = 100 + "px";

                if (angle == 0 || angle == 180) {
                    node.style.height = this.diagramParent.clientHeight * 0.17 + "px";
                    node.style.width = this.diagramParent.clientWidth / 2 + "px";
                }

                node.style.top = data.top + "px";
                if (angle > 0 && angle < 180) {
                    let startx = parseFloat(data.left);
                    let starty = parseFloat(data.top) - this.getTopFactor(node, data);
                    node.style.top = starty + "px";
                    node.style.left = startx + "px";
                } else if (angle > 180 && angle < 360) {
                    let startx = parseFloat(data.left) - node.clientWidth;
                    let starty = parseFloat(data.top) - this.getTopFactor(node, data);
                    node.style.top = starty + "px";
                    node.style.left = startx + "px";
                } else {
                    let startx = parseFloat(data.left) - node.clientWidth / 2;
                    let starty = parseFloat(data.top);
                    starty = angle > 270 || angle < 90 ? starty - node.clientHeight : starty;
                    node.style.top = starty + "px";
                    node.style.left = startx + "px";
                }

                node.style.setProperty("--secContentHeight", node.style.height);
                node.style.setProperty("max-height", node.style.height);

                top = Math.min(top, node.offsetTop);
                bottom = Math.max(bottom, node.offsetTop + node.offsetHeight);

                this.checkForIntersection(baseDiv, node, angle);

                if (angle > 0 && angle < 180) {
                    node.style.width = this.diagramParent.clientWidth - node.offsetLeft + "px";
                } else if (angle > 180 && angle < 360) {
                    node.style.width = node.offsetLeft + node.clientWidth + "px";
                    node.style.left = "0px";
                }
            }
        }.bind(this)
    );
};

CircularColorRingDiagram.prototype.drawConnector = function (svg, startAngle, endAngle, radius, start, end, i) {
    let largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";

    let d = ["M", start.x, start.y, "A", radius, radius, 0, largeArcFlag, 1, end.x, end.y].join(" ");
    let path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("fill", "none");
    path.setAttribute("stroke-width", "15");
    path.setAttribute("class", "arrow-path clsMultiColorParent clsAccentStroke moodanimation");
    DiagramUtils.setCustomItemColor(path, this.arrTintArray, i, i + 1);
    path.setAttribute("data-animation", "itemshape");
    path.setAttribute("d", d);
    svg.appendChild(path);
    this.arrArrowPath.push(path);
};

CircularColorRingDiagram.prototype.getTopFactor = function (div, data) {
    return div.clientHeight / 2;
};

CircularColorRingDiagram.prototype.updateConnector = function () {};

CircularColorRingDiagram.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    LinearCircularDiagram.prototype.floaterOption(this, elTarget, strSelectionType, dict);
    let centerNode = this.diagramParent.querySelector("[data-id='centerNode']");
    let isCenterChild = centerNode ? this.isChildOfParent(elTarget, centerNode) : false;

    if (isCenterChild) {
        let { options, selectedindex } = this.getSeletion(this.centerNode.firstElementChild.dataset.contentType, "centerNode");
        dict.contentswap = {
            dpsource: options,
            selectedindex: selectedindex,
            floaterproperty: "contentChange",
            visible: options.length > 1 ? true : false,
        };
        elTarget.setAttribute("data-focus-parent", "centerHolderParent");
    }

    delete dict.textalign;
};

CircularColorRingDiagram.prototype.getNodeData = function (centerNode) {
    if (!centerNode) return this.diagramData ? this.diagramData.properties.customproperties : null;
    let contentNode = centerNode.firstElementChild;

    contentNode = Array.from(contentNode.children).filter((node) => window.getComputedStyle(node).display != "none")[0];
    if (contentNode && contentNode.dataset && contentNode.dataset.contentType) {
        let contentType = contentNode.dataset.contentType;
        let node;
        let data = {};
        let dataRef = {};
        node = contentNode.querySelector("[data-id='" + contentType + "Node']");
        switch (contentType) {
            case "image":
            case "logo":
                dataRef = { imageURL: node.src };
                if (node.dataset.csstext) dataRef.cropStyle = node.dataset.csstext;
                if (node.dataset.style) dataRef.cropData = node.dataset.style;
                data = { type: "image", value: node.src, dataRef: dataRef, contenttype: contentType };
                break;
            case "icon":
                let iconid = node.getAttribute("iconid");
                let path = node.getAttribute("iconpath");
                dataRef.name = iconid;
                data = { type: "icon", value: path, id: iconid, dataRef: dataRef, contenttype: contentType };
                break;
            case "text":
            case "number":
            case "microchart":
                let strValue = node.textContent.replace("%", "");
                data = { type: "text", value: strValue, contenttype: contentType };
                break;
            case "checklist":
                data = { type: "text", value: node.dataset.ischecked, contenttype: contentType };
                break;
            default:
                data = { type: "text", value: "", contenttype: contentType };
                break;
        }
        return data;
    } else {
        return { type: "text", value: "" };
    }
};

CircularColorRingDiagram.prototype.slideDimensionChange = function () {
    this.setupLinearCircularDiagram();
    this.resetNodeAttributes();
};

CircularColorRingDiagram.prototype.setDiagramSpecficOption = function (obj) {
    let value = this.diagramData.properties.commonnodesize || this.diagramParent.dataset.commonnodesize || 0.3;
    value = value > 0.7 ? 0.7 : value;
    let commongraphicsize = { visible: true, minval: 0.3, maxval: 0.7, value: parseFloat(value), property: "commonnodesizechange" };
    obj.dpcontent.floatdiagramsettings.commongraphicsize = commongraphicsize;

    delete obj.dpcontent.floatdiagramsettings.separator;
    delete obj.dpcontent.floatdiagramsettings.graphiclogosize;
};

CircularColorRingDiagram.prototype.commonNodeSizeChange = function (obj) {
    let val = parseFloat(obj.value);
    val = val > 0.7 ? 0.7 : val;
    val = val < 0.3 ? 0.3 : val;
    obj.value = val;
    LinearCircularDiagram.prototype.commonNodeSizeChange.call(this, obj);
};

CircularColorRingDiagram.prototype.checkForIntersection = function (circleBase, nodeItem, angle) {
    let target = nodeItem;
    let targetRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent, target);
    var circle = {
        radius: this.circleRadius,
        center: { x: circleBase.offsetLeft + circleBase.offsetWidth / 2, y: circleBase.offsetTop + circleBase.offsetHeight / 2 },
    };
    var topLine = {
        p1: { x: targetRect.left, y: targetRect.top },
        p2: { x: targetRect.left + targetRect.width, y: targetRect.top },
    };

    var bottomLine = {
        p1: { x: targetRect.left, y: targetRect.top + targetRect.height },
        p2: { x: targetRect.left + targetRect.width, y: targetRect.top + targetRect.height },
    };

    var centerLine = {
        p1: { x: targetRect.left, y: targetRect.top + targetRect.height / 2 },
        p2: { x: targetRect.left + targetRect.width, y: targetRect.top + targetRect.height / 2 },
    };

    let topIntersetPoint = DiagramUtils.findCircleLineIntersections(circle, topLine);
    let bottomIntersetpoint = DiagramUtils.findCircleLineIntersections(circle, bottomLine);
    let centerIntersetpoint = DiagramUtils.findCircleLineIntersections(circle, centerLine);

    let topX = topIntersetPoint[0] ? topIntersetPoint[0].x : 0;
    let bottomX = bottomIntersetpoint[0] ? bottomIntersetpoint[0].x : 0;
    let centterX = centerIntersetpoint[0] ? centerIntersetpoint[0].x : 0;
    let x = Math.max(topX, bottomX);

    if (angle == 90) {
        x = centterX == 0 ? targetRect.left : centterX;
    } else if (angle == 270) {
        x = centterX == 0 ? target.left + targetRect.width : centterX;
    }

    let isRightItem = angle > 0 && angle < 180;
    let isLeftItem = angle > 180 && angle < 360;

    let nodeOffset = 10; //this.diagramData.properties.customproperties.nodeitemoffset;
    x = x == 0 && isRightItem ? targetRect.left : x;
    x = x == 0 && isLeftItem ? targetRect.left + targetRect.width : x;
    let rightX = x + nodeOffset;
    let leftX = x - nodeOffset - targetRect.width;

    target.style.setProperty("margin-left", 0 + "px", "important");
    nodeItem.style.left = isRightItem ? rightX + "px" : nodeItem.style.left;
    nodeItem.style.left = isLeftItem ? leftX + "px" : nodeItem.style.left;
};

CircularColorRingDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable = [...new Set(mainProperties.floateroptionsdisable.concat(this.floateroptionsdisable()))];
    } else mainProperties.floateroptionsdisable = this.floateroptionsdisable();
    DiagramUtils.removeElementFromArray("fontresize", mainProperties.floateroptionsdisable);
    if (mainProperties?.floateroptionsdisable?.includes?.("content")) mainProperties.floateroptionsdisable.splice(mainProperties.floateroptionsdisable.indexOf("content"), 1);
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

CircularColorRingDiagram.prototype.floateroptionsdisable = function () {
    return [
        "textposition",
        "arrowboth",
        "arrowcurved",
        "arrowbackandforth",
        "iconsize",
        "sequencetext",
        "graphicmicrochart",
        "graphiclogo",
        "graphictext",
        "graphicnumber",
        "notequal",
        "equal",
        "divide",
        "multiply",
        "minus",
        "plus",
        "animateoneatatime",
        "arrange",
        "greyscale",
        "crossout",
        "fontresize",
        "iconsize",
        "logosize",
        "numbersize",
        "swap",
        "imagesize",
    ];
};

// CircularColorRingDiagram.prototype.getHeightRatio = function () {
//     switch (this.diagramData.nodes.length) {
//         case 2:
//             return 0.7;
//         case 3:
//         case 4:
//             return 0.35;
//         case 5:
//             return 0.3;
//         case 6:
//             return 0.25;
//     }
// };

CircularColorRingDiagram.prototype.getCircleRadius = function (svgRect) {
    let heightRadius = (svgRect.height || svgRect.clientHeight) / 2;
    let widthRadius = (svgRect.width || svgRect.clientWidth) / 4;
    let radius = Math.min(heightRadius, widthRadius);
    if (this.diagramData.nodes.length == 3 || this.diagramData.nodes.length == 5) radius = radius * 0.7;
    else radius = radius * 0.75;

    let contentNodeHeight = this.arrDiagramNode?.[0]?.parentNode.querySelector("[name='contentNode']")?.clientHeight || 0;
    let centerX = this.diagramParent.clientWidth / 2;
    let centerY = this.diagramParent.clientHeight / 2;

    if ([3, 5].includes(this.arrDiagramNode.length)) {
        let diff = this.diagramParent.clientHeight / 2 - radius;
        centerY = centerY + contentNodeHeight / 2 + 20;
    }

    this.radius = radius;
    this.circleRadius = radius;
    return { radius: parseInt(radius), centerX: centerX, centerY: centerY };
};

CircularColorRingDiagram.prototype.checkNumberFormat = function (target, diagramParent, moodData, nodeProps) {};

CircularColorRingDiagram.prototype.updateConnetorStart = function () {};

CircularColorRingDiagram.prototype.updateConnetorEnd = function () {};

CircularColorRingDiagram.prototype.setupAnimation = function (animationType = "one", callback) {
    this.arrArrowPath = Array.from(this.diagramParent.querySelectorAll(".arrow-path"));
    this.arrArrowPath.map((path) => (path.style.opacity = 0));
    if (this.centerNode) this.centerNode.style.opacity = 0;
    LinearCircularDiagram.prototype.setupAnimation.call(this, animationType, callback);
};

CircularColorRingDiagram.prototype.animateAfterMoodDelay = function () {
    this.diagramParent.style.opacity = 1;
    if (this.centerNode) this.centerNode.style.transition = "all 0.3s";
    if (this.centerNode) this.centerNode.style.opacity = 1;

    if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
};

CircularColorRingDiagram.prototype.animateArrowForward = function (index) {
    if (this.animationIndex >= 0) {
        this.arrArrowPath[this.animationIndex].style.opacity = 1;
    }
};

CircularColorRingDiagram.prototype.animateArrowBackward = function (index) {
    this.arrArrowPath[index].style.opacity = 0;
};

/**
 * Author:    Krishna
 * Created:   17 tus Nov 2020
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function CircularMultiNodeDiagram(diagramParent, diagramData, nodeProps, moodData = {}) {
    LinearCircularDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "clsCircularMultiNodeDiagram";
    this.diagramParent.setAttribute("data-toggleassets", "true");
    this.diagramParent.setAttribute("data-togglecategory", "circular4thmodel");
    this.centerNodeClass = "CommonDiagramNode";
}

CircularMultiNodeDiagram.prototype = Object.create(LinearCircularDiagram.prototype);
CircularMultiNodeDiagram.prototype.constructor = LinearCircularDiagram;

CircularMultiNodeDiagram.prototype.setupLinearCircularDiagram = function (parent, data, iconChangeCallback, textBoxData) {
    let oldBase = this.diagramParent.querySelector("[id='circularbase']");
    if (oldBase) this.diagramParent.removeChild(oldBase);

    let baseDiv = document.createElement("div");
    baseDiv.className = "circularbase clsMultiColorParent accent1  ";
    baseDiv.id = "circularbase";
    baseDiv.setAttribute("data-displayname", "circular");
    this.diagramParent.appendChild(baseDiv);
    this.circleParent = baseDiv;

    let svg = DiagramNodeUtils.createSVGElement("svg");
    svg.setAttribute("width", baseDiv.clientWidth);
    svg.setAttribute("height", baseDiv.clientHeight);
    svg.setAttribute("id", "svgbase");
    svg.setAttribute("class", "svgbase");
    // svg.setAttribute("opacity", 0);
    baseDiv.appendChild(svg);

    let path = DiagramNodeUtils.createSVGElement("path");
    let svgRect = { width: baseDiv.clientWidth, height: baseDiv.clientHeight };
    let radius = Math.min((svgRect.height * 0.8) / 2, (svgRect.width * 0.4) / 2);
    let centerX = svgRect.width / 2;
    let centerY = svgRect.height / 2;
    let d = DiagramNodeUtils.circlePathWithAngle(centerX, centerY, radius, 0);
    path.setAttribute("d", d);
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", "gray");
    path.setAttribute("stroke-width", "2");
    path.setAttribute("opacity", 0);
    svg.appendChild(path);

    let outerRadius = radius - 30;
    let innerRadius = radius / 2;
    let centerRadius = outerRadius - (outerRadius - innerRadius) / 2;
    let circleRotation = this.getAngleForNodeCount();

    let outerPath = DiagramNodeUtils.createSVGElement("path");
    d = DiagramNodeUtils.circlePathWithAngle(centerX, centerY, outerRadius, circleRotation);
    outerPath.setAttribute("d", d);
    outerPath.setAttribute("stroke", "gray");
    outerPath.setAttribute("stroke-width", "2");
    outerPath.setAttribute("opacity", 0);
    svg.appendChild(outerPath);

    let centerPath = DiagramNodeUtils.createSVGElement("path");
    d = DiagramNodeUtils.circlePathWithAngle(centerX, centerY, centerRadius, circleRotation);
    centerPath.setAttribute("d", d);
    centerPath.setAttribute("stroke", "gray");
    centerPath.setAttribute("stroke-width", "2");
    centerPath.setAttribute("opacity", 0);
    svg.appendChild(centerPath);

    let innerPath = DiagramNodeUtils.createSVGElement("path");
    d = DiagramNodeUtils.circlePathWithAngle(centerX, centerY, innerRadius, circleRotation);
    innerPath.setAttribute("d", d);
    innerPath.setAttribute("stroke", "gray");
    innerPath.setAttribute("stroke-width", "2");
    innerPath.setAttribute("opacity", 0);
    svg.appendChild(innerPath);

    if (this.nodeProps.centernodevisible && this.nodeProps.centernodevisible == "true") {
        let div = this.setCenterPlaceHolder(baseDiv, this.getCenterHolderSize());
    }
    this.drawBgShape(outerPath, innerPath, centerPath, svg, outerRadius, innerRadius);
    this.updateNodePosition();
    return;
};

CircularMultiNodeDiagram.prototype.getAngleForNodeCount = function () {
    switch (this.arrDiagramNode.length) {
        case 2:
        case 4:
        case 6:
            return 90;
        case 3:
            return 150;
        case 5:
            return 127;
    }
};

CircularMultiNodeDiagram.prototype.drawBgShape = function (outerCircle, innerCircle, centerCircle, svg, outerRadius, innerRadius) {
    let outerPathLength = outerCircle.getTotalLength();
    let innerPathLength = innerCircle.getTotalLength();
    let centPathLength = centerCircle.getTotalLength();
    let outerGap = outerPathLength / this.arrDiagramNode.length;
    let innerGap = innerPathLength / this.arrDiagramNode.length;
    let centerGap = centPathLength / this.arrDiagramNode.length;
    let offset = 5;
    this.arrArrowPath = [];
    this.arrDiagramNode.map(
        function (node, i) {
            let point1 = outerCircle.getPointAtLength(outerPathLength - (outerGap * i + 0.01 + offset));
            let point2 = outerCircle.getPointAtLength(outerPathLength - (outerGap * (i + 1) - offset));
            let point3 = innerCircle.getPointAtLength(innerPathLength - (innerGap * (i + 1) - offset));
            let point4 = innerCircle.getPointAtLength(innerPathLength - (innerGap * i + 0.01 + offset));
            let center = centPathLength - (centerGap * i + 0.01) - centerGap / 2;
            let shapeCenter = centerCircle.getPointAtLength(center);
            let shapePath = DiagramNodeUtils.createSVGElement("path");

            if (i < 6) {
                let d = ["M", point1.x, point1.y, "A", outerRadius, outerRadius, 0, 0, 1, point2.x, point2.y, "L", point3.x, point3.y, "A", innerRadius, innerRadius, 0, 0, 0, point4.x, point4.y, "Z"].join(" ");
                shapePath.setAttribute("d", d);
                shapePath.setAttribute("id", "ringShape-" + (i + 1));
                shapePath.setAttribute("data-cx", shapeCenter.x);
                shapePath.setAttribute("data-cy", shapeCenter.y);
                shapePath.setAttribute("data-size", outerRadius - innerRadius);
                shapePath.setAttribute("class", "clsMultiColorParent clsAccentfill moodanimation");
                shapePath.setAttribute("data-animation", "itemshape");
                DiagramUtils.setCustomItemColor(shapePath, this.arrTintArray, i, i + 1);
                shapePath.setAttribute("stroke-width", "2");
                svg.appendChild(shapePath);
                this.addAsClipPath(shapePath, svg, i);
                this.arrArrowPath.push(shapePath);
            }
        }.bind(this)
    );
};

CircularMultiNodeDiagram.prototype.addAsClipPath = function (path, svg, i) {
    let svgPath = this.diagramParent.querySelector("#clipsvg");
    if (!svgPath) {
        svgPath = DiagramNodeUtils.createSVGElement("svg");
        svgPath.setAttribute("id", "clipsvg");
        svgPath.setAttribute("style", "position:absolute");
        this.diagramParent.appendChild(svgPath);
    }
    let defs = svgPath.querySelector("#ringDefs");
    if (!defs) {
        defs = DiagramNodeUtils.createSVGElement("defs");
        defs.setAttribute("id", "ringDefs");
        svgPath.appendChild(defs);
    }

    let clipPath = DiagramNodeUtils.createSVGElement("clipPath");
    clipPath.setAttribute("id", "ringClip-" + (i + 1));
    let oldPath = defs.querySelector("#ringClip-" + (i + 1) + "");
    if (oldPath) defs.removeChild(oldPath);
    defs.appendChild(clipPath);

    let clipRect = path.getBBox();
    let clip = path.cloneNode(true);
    clip.setAttribute("id", "clip-" + (i + 1));
    clip.setAttribute("transform", "translate(-" + clipRect.x + " -" + clipRect.y + ")");
    clipPath.appendChild(clip);
};

CircularMultiNodeDiagram.prototype.getCenterHolderSize = function () {
    let baseDiv = this.diagramParent.querySelector("#circularbase");
    if (baseDiv) {
        let svgRect = { width: baseDiv.clientWidth, height: baseDiv.clientHeight };
        let radius = Math.min((svgRect.height * 0.8) / 2, (svgRect.width * 0.4) / 2);
        let size = radius * this.commonNodeSizeRatio;
        return { width: size, height: size };
    }
    return { width: 100, height: 100 };
};

CircularMultiNodeDiagram.prototype.updateNodePosition = function () {
    let baseDiv = this.diagramParent.querySelector("[id='circularbase']");
    if (!baseDiv) return;

    let centerNode = baseDiv.querySelector("[data-id='centerNode']");
    if (centerNode) {
        let size = this.getCenterHolderSize();
        centerNode.style.width = size.width + "px";
        centerNode.style.height = size.height + "px";

        let centerHolder = this.diagramParent.querySelector("[name='centerHolderParent']");
        let contentType = centerHolder.dataset.type;
        let imageNode = centerHolder.querySelector("img[data-id='imageNode'],img[data-id='logoNode']");
        if (imageNode) CommonImageUtils.updateImageBounds(imageNode, { islogofit: contentType == "logo", contenttype: contentType }, 1);
    }

    let svgRect = { width: baseDiv.clientWidth, height: baseDiv.clientHeight };
    let radius = Math.min((svgRect.height * 0.8) / 2, (svgRect.width * 0.4) / 2);

    this.circleRadius = radius;
    let centerX = svgRect.width / 2;
    let centerY = svgRect.height / 2;

    let count = this.diagramData.nodes.length;
    let angleDif = 360 / count;
    let arrAlignClassname = ["circularAlignLeft", "circularAlignRight", "circularAlignTop"];

    let top = 0;
    let bottom = 0;

    this.arrShape = Array.from(baseDiv.querySelectorAll("[id*='ringShape']"));

    this.arrDiagramNode.map(
        function (nodeObj, i) {
            let node = nodeObj.getNodeParent().parentElement;
            let shape = this.arrShape[i];

            if (node) {
                let angle = angleDif * i + this.getAngleBaseOnNodeCount();
                let iconCenterPoint = this.polarToCartesian(centerX, centerY, radius, angle);
                node.setAttribute("data-angle", angle);

                let nodeGroup = node.querySelector("[name='nodeGroup']");
                arrAlignClassname.map((className) => {
                    nodeGroup.classList.remove(className);
                });

                let heightRation = this.getHeightRatio();
                let height = this.diagramParent.clientHeight * heightRation;
                node.style.height = height + "px";
                node.style.width = "200px";

                if (angle > 0 && angle < 180) {
                    nodeGroup.classList.add("circularAlignRight");
                } else if (angle > 180 && angle < 360) {
                    nodeGroup.classList.add("circularAlignLeft");
                } else if (angle == 0) {
                    nodeGroup.classList.add("circularAlignTopCenter");
                    node.style.width = this.diagramParent.clientWidth * 0.5 + "px";
                }

                let data = { left: iconCenterPoint.x, top: iconCenterPoint.y };

                if (angle == 0 || angle == 180) {
                    node.style.height = this.diagramParent.clientHeight * 0.17 + "px";
                }

                node.style.top = data.top + "px";
                if (angle > 0 && angle < 180) {
                    let startx = parseFloat(data.left);
                    let starty = parseFloat(data.top) - this.getTopFactor(node, data);
                    node.style.top = starty + "px";
                    node.style.left = startx + "px";
                } else if (angle > 180 && angle < 360) {
                    let startx = parseFloat(data.left) - node.clientWidth;
                    let starty = parseFloat(data.top) - this.getTopFactor(node, data);
                    node.style.top = starty + "px";
                    node.style.left = startx + "px";
                } else {
                    let startx = parseFloat(data.left) - node.clientWidth / 2;
                    let starty = parseFloat(data.top);
                    starty = angle > 270 || angle < 90 ? starty - node.clientHeight : starty;
                    node.style.top = starty + "px";
                    node.style.left = startx + "px";
                }

                let content = node.querySelector("[data-id='diagramContentNode']");
                let isShapeCenter = !content.dataset.contentType || content.dataset.contentType == "icon";

                node.style.setProperty("--secContentHeight", node.style.height);
                node.style.setProperty("max-height", node.style.height);

                top = Math.min(top, node.offsetTop);
                bottom = Math.max(bottom, node.offsetTop + node.offsetHeight);

                this.checkForIntersection(baseDiv, node, angle);

                if (angle > 0 && angle < 180) {
                    node.style.width = this.diagramParent.clientWidth - node.offsetLeft + "px";
                } else if (angle > 180 && angle < 360) {
                    node.style.width = node.offsetLeft + node.clientWidth + "px";
                    node.style.left = "0px";
                }

                if (content && shape && !isShapeCenter) {
                    let rect = shape.getBBox();
                    let left = rect.x - node.offsetLeft;
                    let top = rect.y - node.offsetTop;

                    content.style.position = "absolute";
                    content.style.left = left + "px";
                    content.style.top = top + "px";
                    content.style.width = rect.width + "px";
                    content.style.height = rect.height + "px";
                    content.style.clipPath = "url(#ringClip-" + (i + 1) + ")";
                } else if (content && shape && isShapeCenter) {
                    let left = shape.dataset.cx - node.offsetLeft - shape.dataset.size / 2;
                    let top = shape.dataset.cy - node.offsetTop - shape.dataset.size / 2;

                    content.style.position = "absolute";
                    content.style.left = left + "px";
                    content.style.top = top + "px";
                    content.style.width = shape.dataset.size + "px";
                    content.style.height = shape.dataset.size + "px";
                }
            }
        }.bind(this)
    );

    let totalHeight = bottom + top;
    let remainingSpace = this.diagramParent.offsetHeight - totalHeight;
    this.diagramParent.style.top = this.diagramData.nodes.length == 3 || this.diagramData.nodes.length == 5 ? remainingSpace / 2 + "px" : "0px";

    this.resetNodeAttributes();
};

CircularMultiNodeDiagram.prototype.checkForIntersection = function (circleBase, nodeItem, angle) {
    let target = nodeItem;
    let targetRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent, target);
    var circle = {
        radius: this.circleRadius,
        center: { x: circleBase.offsetLeft + circleBase.offsetWidth / 2, y: circleBase.offsetTop + circleBase.offsetHeight / 2 },
    };
    var topLine = {
        p1: { x: targetRect.left, y: targetRect.top },
        p2: { x: targetRect.left + targetRect.width, y: targetRect.top },
    };

    var bottomLine = {
        p1: { x: targetRect.left, y: targetRect.top + targetRect.height },
        p2: { x: targetRect.left + targetRect.width, y: targetRect.top + targetRect.height },
    };

    var centerLine = {
        p1: { x: targetRect.left, y: targetRect.top + targetRect.height / 2 },
        p2: { x: targetRect.left + targetRect.width, y: targetRect.top + targetRect.height / 2 },
    };

    let topIntersetPoint = DiagramUtils.findCircleLineIntersections(circle, topLine);
    let bottomIntersetpoint = DiagramUtils.findCircleLineIntersections(circle, bottomLine);
    let centerIntersetpoint = DiagramUtils.findCircleLineIntersections(circle, centerLine);

    let topX = topIntersetPoint[0] ? topIntersetPoint[0].x : 0;
    let bottomX = bottomIntersetpoint[0] ? bottomIntersetpoint[0].x : 0;
    let centterX = centerIntersetpoint[0] ? centerIntersetpoint[0].x : 0;
    let x = Math.max(topX, bottomX);

    if (angle == 90) {
        x = centterX == 0 ? targetRect.left : centterX;
    } else if (angle == 270) {
        x = centterX == 0 ? target.left + targetRect.width : centterX;
    }

    let isRightItem = angle > 0 && angle < 180;
    let isLeftItem = angle > 180 && angle < 360;

    let nodeOffset = 0; //this.diagramData.properties.customproperties.nodeitemoffset;
    x = x == 0 && isRightItem ? targetRect.left : x;
    x = x == 0 && isLeftItem ? targetRect.left + targetRect.width : x;
    let rightX = x + nodeOffset;
    let leftX = x - nodeOffset - targetRect.width;

    target.style.setProperty("margin-left", 0 + "px", "important");
    nodeItem.style.left = isRightItem ? rightX + "px" : nodeItem.style.left;
    nodeItem.style.left = isLeftItem ? leftX + "px" : nodeItem.style.left;
};

CircularMultiNodeDiagram.prototype.drawConnector = function (svg, startAngle, endAngle, radius, start, end, i) {
    let largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";

    let d = ["M", start.x, start.y, "A", radius, radius, 0, largeArcFlag, 1, end.x, end.y, "L"].join(" ");
    let path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("fill", "none");
    path.setAttribute("stroke-width", "10");
    path.setAttribute("class", "arrow-path clsMultiColorParent clsAccentfill moodanimation");
    DiagramUtils.setCustomItemColor(path, this.arrTintArray, i, i + 1);
    path.setAttribute("data-animation", "connector");
    path.setAttribute("d", d);
    svg.appendChild(path);
    this.arrArrowPath.push(path);
};

CircularMultiNodeDiagram.prototype.getTopFactor = function (div, data) {
    return div.clientHeight / 2;
};

CircularMultiNodeDiagram.prototype.updateConnector = function () {};

CircularMultiNodeDiagram.prototype.setupAnimation = function (animationType = "one", callback) {
    LinearCircularDiagram.prototype.setupAnimation.call(this, animationType, callback);
    this.arrArrowPath = Array.from(this.diagramParent.querySelectorAll("[id*='ringShape-']"));
    this.arrArrowPath.map((path) => (path.style.opacity = 0));
    if (this.centerNode) this.centerNode.style.opacity = 0;

    this.isReversAnimation = this.checkForArrowReverseAnimation();

    if (this.isReversAnimation) {
        if (this.arrArrowPath) {
            this.arrArrowPath.reverse();
            this.arrArrowPath.push(this.arrArrowPath.shift());
        }
    }
};

CircularMultiNodeDiagram.prototype.animateAfterMoodDelay = function () {
    this.diagramParent.style.opacity = 1;
    if (this.centerNode) this.centerNode.style.transition = "all 0.3s";
    if (this.centerNode) this.centerNode.style.opacity = 1;

    if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
};

CircularMultiNodeDiagram.prototype.animateArrowForward = function (index) {
    if (this.animationIndex >= 0) {
        this.arrArrowPath[this.animationIndex].style.opacity = 1;
    }
};

CircularMultiNodeDiagram.prototype.animateArrowBackward = function (index) {
    this.arrArrowPath[index].style.opacity = 0;
};

CircularMultiNodeDiagram.prototype.slideDimensionChange = function () {
    this.setupLinearCircularDiagram();
    this.resetNodeAttributes();
};

CircularMultiNodeDiagram.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    LinearCircularDiagram.prototype.floaterOption(this, elTarget, strSelectionType, dict);
    let centerNode = this.diagramParent.querySelector("[data-id='centerNode']");
    let isCenterChild = centerNode ? this.isChildOfParent(elTarget, centerNode) : false;

    if (isCenterChild) {
        let { options, selectedindex } = this.getSeletion(this.centerNode.firstElementChild.dataset.contentType, "centerNode");
        dict.contentswap = {
            dpsource: options,
            selectedindex: selectedindex,
            floaterproperty: "contentChange",
            visible: options.length > 1 ? true : false,
        };
        elTarget.setAttribute("data-focus-parent", "centerHolderParent");
    }
};

CircularMultiNodeDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearVerticalDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable = [...new Set(mainProperties.floateroptionsdisable.concat(this.floateroptionsdisable()))];
    } else mainProperties.floateroptionsdisable = this.floateroptionsdisable();
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

CircularMultiNodeDiagram.prototype.floateroptionsdisable = function () {
    return [
        "textposition",
        "arrowboth",
        "arrowcurved",
        "arrowbackandforth",
        "iconsize",
        "sequencetext",
        "graphicmicrochart",
        "graphiclogo",
        "graphictext",
        "graphicnumber",
        "notequal",
        "equal",
        "divide",
        "multiply",
        "minus",
        "plus",
        "contentoptions",
        "animateoneatatime",
        "arrange",
        "greyscale",
        "crossout",
        "fontresize",
        "iconsize",
        "logosize",
        "numbersize",
        "swap",
        "imagesize",
    ];
};

/**
 * Author:    Bala Krishnan K.
 * Created:   25.3.2020
 * Cleaned up
 * for node:  07.4.2021
 **/

"use strict";

function SimpleImageGrid(nodeParent, nodeProps = {}, appStaticURL = "", defaultData = {}, logoListObj, index = 0, completeCallback) {
    this.diagramLogoParent = nodeParent;
    this.nodeProps = nodeProps;
    this.logoListObj = logoListObj;
    this.appStaticURL = appStaticURL;
    this.defaultData = defaultData;
    this.componentType = logoListObj?.componentType || "logo";
    this.index = index;
    this.completeCallback = completeCallback;
    let defaultNode = { type: "image", contenttype: this.componentType, logocontrast: false };
    this.getPlaceholderValue(defaultNode, defaultData, 0, index);
    this.gridimages = [defaultNode];
    this.gap = 2;
    this.allowLayout = nodeProps.allowLayout ? nodeProps.allowLayout : true;
    if (this.allowLayout && this.componentType == "logo") {
        this.imageLayoutManager = new window[nodeProps.layout ? nodeProps.layout : "SimpleLayoutManager"]();
        this.imageLayoutManager.arrImageFinalData = [];
    }
    this.updateSingleNode = this.updateSingleNode.bind(this);
    this.imageLoadCallBack = this.imageLoadCallBack.bind(this);
}

SimpleImageGrid.prototype.getPlaceholderValue = function (nodeData, defaultData, index, startIndex = 0) {
    let arrKeys = defaultData;
    if (arrKeys.length > 0) {
        index = startIndex + index;
        let randomIndex = index < arrKeys.length ? index : Math.floor(Math.random() * (arrKeys.length - 1));
        nodeData.value = DiagramUtils.checkAppStaticUrl(arrKeys[randomIndex].value, this.appStaticURL);
        nodeData.assetText = "";
        nodeData.logodata = null;
        nodeData.dataRef = null;
    } else {
        nodeData.value = this.appStaticURL + Constants.Value.placeholder_logopath;
    }
};

SimpleImageGrid.prototype.changeLogoSizeOnSlider = function (targetNode, value, isDragging, nodeOriginalHeight) {
    if (targetNode) {
        if (!targetNode.parentElement.hasAttribute("data-originalsize")) targetNode.parentElement.setAttribute("data-originalsize", parseFloat(nodeOriginalHeight));
        let originalSize = targetNode.parentElement.getAttribute("data-originalsize");
        let finalHeight = originalSize * value;
        targetNode.parentElement.setAttribute("data-scaledheight", parseFloat(finalHeight));
        let arrNodes = targetNode.parentElement.querySelectorAll("[data-id='contentlogoparent']");
        let pushImgNodes = this.imageLayoutManager?.arrImageFinalData.length == 0;
        for (let a = 0; a < arrNodes.length; a++) {
            arrNodes[a].style.height = finalHeight + "px";
            this.gridimages[a].scaledHeight = finalHeight;
            if (pushImgNodes) {
                let imageNode = arrNodes[a].querySelector("[data-id='logoNode']");
                let width = imageNode.dataset.nwidth || imageNode.naturalWidth || imageNode.dataset.width;
                let height = imageNode.dataset.nheight || imageNode.naturalHeight || imageNode.dataset.height;
                this.imageLayoutManager?.arrImageFinalData.push({
                    image: imageNode,
                    ratio: height / width,
                    width: width,
                    height: height,
                });
            }
        }
        if (!pushImgNodes) {
            this.imageLayoutManager?.arrImageFinalData.forEach((element) => {
                let width = element.image.dataset.nwidth || element.image.naturalWidth || element.image.dataset.width;
                let height = element.image.dataset.nheight || element.image.naturalHeight || element.image.dataset.height;
                element.ratio = height / width;
                element.width = width;
                element.height = height;
            });
        }
        if (this.imageLayoutManager) {
            targetNode.parentElement.style.setProperty("--logoheight", finalHeight + "px");
            // targetNode.parentElement.parentElement.style.setProperty("--logoheight", finalHeight + "px");
            targetNode.parentElement.style.height = finalHeight + "px";
            this.imageLayoutManager.updateLayout(targetNode.parentElement);
            let marginTop = parseFloat(window.getComputedStyle(targetNode.parentElement).marginTop);
            targetNode.parentElement.parentElement.style.minHeight = finalHeight + (!isNaN(marginTop) ? marginTop : 0) + "px";
        }
        if (!isDragging && this.fitLogoGridImages) this.fitLogoGridImages();
    }
};

SimpleImageGrid.prototype.changeLogoGridContrast = function (logoNode, value, selectedNodeIndex) {
    // Change logo grid items contrast through operation. - balakumar
    // TO-DO - props need to save for save reopen - balakrishnan
    if (logoNode && this.componentType == "logo") {
        logoNode.classList.add(!value ? "logoBrightnessDiagramUnset" : "logoBrightnessDiagram");
        logoNode.classList.remove(!value ? "logoBrightnessDiagram" : "logoBrightnessDiagramUnset");
        logoNode.parentElement.setAttribute("data-logocontrast", value);
        if (selectedNodeIndex != null && selectedNodeIndex != undefined) this.gridimages[selectedNodeIndex].logocontrast = value;
    }
};

SimpleImageGrid.prototype.updateImageEditData = function (logoNode, selectedNodeIndex, value) {
    if (logoNode && value) {
        logoNode.setAttribute("data-style", value.cropData);
        logoNode.setAttribute("data-csstext", value.cropStyle);
        logoNode.style.cssText = value.cropStyle;
        if (selectedNodeIndex != null && selectedNodeIndex != undefined) this.gridimages[selectedNodeIndex].dataRef = value;
    }
};

SimpleImageGrid.prototype.changeLogoGridStyle = function (valueObj, nodeIndex) {
    this.gridimages?.forEach((gridImage, gridIndex) => {
        let logodata = gridImage?.logodata?.logos;
        // logodata = DiagramUtils.getSampleLogoData();
        let type = DiagramUtils.getLogoStyle(this.nodeProps?.logostyle || "logo", valueObj.value);
        this.nodeProps.logostyle = type;
        logodata?.forEach((logo) => {
            if (logo.type && logo.type.toLowerCase() == type) {
                let targetNode = this.diagramLogoParent?.querySelector("[id='imageHolder" + gridIndex + "-gridNode" + nodeIndex + "']");
                if (targetNode) DiagramUtils.setLogoStyle(targetNode, logo);
            }
        });
    });
};

SimpleImageGrid.prototype.updateLogoLink = function (parent, valueObj) {
    DiagramUtils.updateNodeLink(parent, valueObj);
};

SimpleImageGrid.prototype.updateSingleNode = function (imageNode) {
    if (this.imageLayoutManager) {
        let imageStyle = getComputedStyle(imageNode.parentElement.parentElement);
        let nodeheight = imageNode.parentElement.parentElement.getAttribute("data-scaledheight") || imageStyle.getPropertyValue("--logoheight") || 40;
        let logogap = imageStyle.getPropertyValue("--logogap") || "0px";
        let imageLayoutManager = this.imageLayoutManager;
        let fnUpdateLogoSize = this.updateSqureLogoSize;
        let diagramParent = this.diagramLogoParent;
        let completeCallback = this.completeCallback;
        imageNode.addEventListener(
            "load",
            function (e) {
                e.target.setAttribute("data-nwidth", e.target.naturalWidth);
                e.target.setAttribute("data-nheight", e.target.naturalHeight);
                let imageData = { image: e.target, ratio: e.target.dataset.nheight / e.target.dataset.nwidth, width: e.target.dataset.nwidth, height: e.target.dataset.nheight };
                nodeheight = fnUpdateLogoSize(diagramParent, nodeheight, imageData);
                imageLayoutManager.updateNode(imageData, nodeheight, logogap);
                if (completeCallback) completeCallback(diagramParent);
            },
            { once: true }
        );
        imageNode.src = imageNode.src;
    }
};

SimpleImageGrid.prototype.updateSqureLogoSize = function (diagramLogoParent, nodeheight, imageData) {
    let isAutoResize = diagramLogoParent?.getAttribute("data-logoautoresize") == "true";
    let targetNode = imageData?.image;
    if (targetNode && isAutoResize && diagramLogoParent?.parentElement?.hasAttribute("data-logoimagesize")) {
        let scaleValue = diagramLogoParent.parentElement.getAttribute("data-logoimagesize");
        let ratio = imageData.ratio;
        let updateSize = -1;
        if (ratio >= 1.1) updateSize = 0.85;
        else if (ratio >= 0.9 && ratio < 1.1) updateSize = 0.85;
        else if (ratio >= 0.25 && ratio < 0.9) updateSize = 0.45;
        else if (ratio <= 0.25) updateSize = 0.35;

        if (updateSize > 0) {
            let newValue = nodeheight / scaleValue;
            nodeheight = parseFloat(newValue) * updateSize;
            diagramLogoParent.parentElement.setAttribute("data-logoimagesize", updateSize);
            let nodeParent = targetNode?.parentElement?.parentElement;
            nodeParent?.style?.removeProperty("height");
            nodeParent?.setAttribute("data-scaledheight", nodeheight);
            nodeParent?.style.setProperty("--logoheight", nodeheight + "px");
        }
    }
    return nodeheight;
};

SimpleImageGrid.prototype.updateLogoNodeData = function (parentNode) {
    if (this.imageLayoutManager) {
        this.imageLayoutManager.arrImageFinalData = [];
    }
};

SimpleImageGrid.prototype.updateGridSize = function () {
    let gridParent = this.diagramLogoParent.querySelector("[name='nodesImageHolder']");
    this.imageLayoutManager?.updateLayout(gridParent, gridParent.parentElement.clientWidth, gridParent.parentElement.clientHeight, this.gap);
};

SimpleImageGrid.prototype.imageLoadCallBack = function (imageNode) {
    this.imageLayoutManager?.arrImageFinalData?.push({
        image: imageNode,
        ratio: imageNode.dataset.nheight / imageNode.dataset.nwidth,
        width: imageNode.dataset.nwidth,
        height: imageNode.dataset.nheight,
    });
    if (this.imageLayoutManager && this.imageLayoutManager.arrImageFinalData.length >= this.gridimages.length) {
        this.adjustLayout();
        if (this.completeCallback) this.completeCallback(this.diagramLogoParent);
        if (this.fitLogoGridImages) this.fitLogoGridImages();
    }
};

SimpleImageGrid.prototype.adjustLayout = function () {
    let gridParent = this.diagramLogoParent.querySelector("[name='nodesImageHolder']");
    this.imageLayoutManager?.updateLayout(gridParent, this.diagramLogoParent);
    if (gridParent.clientHeight > 0) this.updateFocusCallBack();
};

SimpleImageGrid.prototype.initDiagramCreationNode = function (index, objData, nodeParent) {
    let gridParent = document.createElement("div");
    gridParent.className = "clsImageGridNode moodanimation";
    gridParent.setAttribute("id", DiagramNodeUtils.uuidv4());
    gridParent.setAttribute("name", "imageGridNode");
    gridParent.setAttribute("data-animation", "gridholder");
    gridParent.setAttribute("data-component-type", "grid");
    gridParent.setAttribute("data-index", index);
    nodeParent.appendChild(gridParent);
    DiagramUtils.addClassesFromMenu(objData.objClass, gridParent);

    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsImagesHolder";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("data-index", index);
    pattenDiv.setAttribute("name", "nodesImageHolder");
    if (this.nodeProps.logoHeight) pattenDiv.style.setProperty("--logoheight", this.nodeProps.logoHeight);
    // if (this.nodeProps.logoHeight) pattenDiv.parentElement.style.setProperty("--logoheight", this.nodeProps.logoHeight);
    gridParent.appendChild(pattenDiv);
    DiagramUtils.addClassesFromMenu(objData.objClass, pattenDiv);

    if (objData.mincount && objData.mincount > 1 && this.gridimages.length < objData.mincount) {
        for (let gridIndex = 1; gridIndex < objData.mincount; gridIndex++) {
            let newObj = JSON.parse(JSON.stringify(this.gridimages[0]));
            newObj.logocontrast = false;
            this.getPlaceholderValue(newObj, this.defaultData, gridIndex, index);
            this.gridimages.push(newObj);
        }
    }
    if (objData.maxcount && this.gridimages.length > objData.maxcount) {
        this.gridimages = this.gridimages.splice(0, objData.maxcount);
    }

    if (this.gridimages[0]?.scaledHeight) pattenDiv.setAttribute("data-scaledheight", this.gridimages[0].scaledHeight);

    this.createImageNodes(pattenDiv, index);
};

SimpleImageGrid.prototype.createImageNodes = function (pattenDiv, index) {
    let nodeCount = this.gridimages.length;
    for (let j = 0; j < nodeCount; j++) {
        let nodeData = this.gridimages[j];
        try {
            if (this.diagramParent && this.diagramParent.dataset.floateroptionsdisable && this.diagramParent.dataset.floateroptionsdisable.includes("logocontrast")) {
                this.logoListObj.disablelogocontrast = true;
            }
        } catch (error) {}
        let imageHolder = DiagramCreateUtil.createImageNode(pattenDiv, nodeData, "imageHolder", j, "secondary", [], null, null, this.allowLayout ? this.imageLoadCallBack : null, this.logoListObj, this.appStaticURL, true);
        imageHolder.setAttribute("data-component-type", "grid");
        imageHolder.setAttribute("id", "imageHolder" + j + "-gridNode" + index);
        imageHolder.setAttribute("data-imagegrid-index", j);
        imageHolder.setAttribute("data-index", index);
        imageHolder.setAttribute("data-haslinksupport", "true");
        imageHolder.classList.remove("clsimageHolder");
        imageHolder.classList.add("clsimageGridHolder");
        imageHolder.classList.add("slideGraphicElementTransformHoverState");
        let assetText = nodeData.assetText;
        let assetNode = imageHolder.querySelector("[data-id='logoNode']") || imageHolder.querySelector("[data-id='imageNode']") || imageHolder.querySelector("[data-id='iconNode']");
        if (assetNode) {
            this.changeLogoGridContrast(assetNode, nodeData.logocontrast);
        }
        if (nodeData.link) {
            imageHolder.setAttribute("data-navigate-to-slide-on-click", nodeData.link.url);
            imageHolder.setAttribute("data-linktype", nodeData.link.type);
        }
        if (assetNode && assetNode.parentElement && nodeData.needAssetUpdate && assetText) {
            nodeData.needAssetUpdate = false;
            imageHolder.setAttribute("data-node-graphic-text", assetText);
            let type = imageHolder.dataset.nodeContentType;
            DiagramUtils.searchAIcall(type, nodeData, assetText, this.nodeProps, this.globalMoodData, assetNode, this.nodeIndex, this.searchIconCallBack, appBaseURL, this.appStaticURL);
        }
    }
};

SimpleImageGrid.prototype.fitLogoGridImages = function () {
    let imageGridNode = this.diagramLogoParent.querySelector("[name='nodesImageHolder']");
    let arrImagesNodes = imageGridNode?.querySelectorAll("[name='imageHolder']");
    if (arrImagesNodes.length > 1) {
        let parentNode = arrImagesNodes[0].parentElement;
        parentNode.style.height = "auto";
        for (let a = 0; a < arrImagesNodes.length; a++) {
            let imgNode = arrImagesNodes[a];
            let parentTop = parseFloat(window.getComputedStyle(parentNode).marginTop);
            let imgOffsetTop = imgNode.offsetTop - (!isNaN(parentTop) ? parentTop : 0) + imgNode.offsetHeight;
            let parentHeight = parentNode.offsetHeight;
            if (imgOffsetTop > parentHeight && arrImagesNodes[a - 1]) {
                let newTop = arrImagesNodes[a - 1].offsetTop - (!isNaN(parentTop) ? parentTop : 0) + arrImagesNodes[a - 1].offsetHeight;
                parentNode.style.height = newTop + "px";
                a = 100;
            }
        }
    }
};

SimpleImageGrid.prototype.addLogoNode = function (index = 0, gridIndex = 0, hasData = false) {
    let nodeData = JSON.parse(JSON.stringify(this.gridimages[0]));
    this.getPlaceholderValue(nodeData, this.defaultData, parseInt(gridIndex) + 1, index);
    if (!hasData) this.gridimages.splice(parseInt(gridIndex) + 1, 0, nodeData);
    let pattenDiv = this.diagramLogoParent.querySelector("[name='nodesImageHolder'][data-index='" + index + "']");
    pattenDiv.innerHTML = "";
    this.createImageNodes(pattenDiv, index);
    this.updateLogoNodeData(pattenDiv);
};

SimpleImageGrid.prototype.deleteLogoNode = function (index = 0, gridIndex) {
    this.gridimages.splice(gridIndex, 1);
    let pattenDiv = this.diagramLogoParent.querySelector("[name='nodesImageHolder'][data-index='" + index + "']");
    pattenDiv.innerHTML = "";
    this.createImageNodes(pattenDiv, index);
    this.updateLogoNodeData(pattenDiv);
};

SimpleImageGrid.prototype.changeImageNode = function (targetId, index, src, searchText) {
    let target = this.diagramLogoParent.querySelector("[id='" + targetId + "']");
    // index = target.dataset.imagegridIndex;
    if (index != null && this.gridimages[index]) this.gridimages[index].value = src;
    if (target) {
        let element = target.querySelector("[data-id*='Node']");
        if (element) element.setAttribute("src", src);
        this.updateSingleNode(element);
        if (searchText) {
            element.parentElement.setAttribute("data-node-graphic-text", searchText);
            if (this.gridimages?.[index] && target.getElementsByTagName("img").length > 0) this.gridimages[index].logodata = DiagramNodeUtils.getLogoStyle(target.getElementsByTagName("img")[0]);
        }
        this.updatePropsCallBack();
    }
};

SimpleImageGrid.prototype.getLogoListData = function (node) {
    let arrgridimages = [];
    if (!node) return arrgridimages;
    let gridImages = node.querySelectorAll("[data-component-type='grid'][name='imageHolder']");
    gridImages.forEach((element) => {
        let logoNode = element.querySelector("[data-id='" + this.componentType + "Node']");
        let assetText = logoNode.parentElement.getAttribute("data-node-graphic-text") || "";
        let src = logoNode.getAttribute("src");
        src = src.substring(src.lastIndexOf("/") + 1).includes(".") || logoNode.getAttribute("src").includes("blob:") ? src : this.appStaticURL + Constants.Value.placeholder_logopath;
        let dataRef = { imageURL: src };
        if (logoNode.dataset.csstext) dataRef.cropStyle = logoNode.dataset.csstext;
        if (logoNode.dataset.style) dataRef.cropData = logoNode.dataset.style;
        arrgridimages.push({
            type: "image",
            contenttype: this.componentType,
            value: src,
            assetText: assetText,
            scaledHeight: logoNode.parentElement.parentElement.dataset.scaledheight,
            logocontrast: logoNode.parentElement.dataset.logocontrast && logoNode.parentElement.dataset.logocontrast == "true",
            link: DiagramUtils.getLinkData(element),
            logodata: DiagramNodeUtils.getLogoStyle(logoNode),
            dataRef: dataRef,
        });
    });
    return arrgridimages;
};

SimpleImageGrid.prototype.swapNodes = function (objData, swapNodeIndex) {
    let target = this.diagramLogoParent.querySelector("[id='" + objData.targetid + "']");
    if (target) {
        let index = parseInt(target.dataset.index);
        let imagegridIndex = parseInt(target.dataset.imagegridIndex);
        let swapIndex = imagegridIndex + swapNodeIndex;
        let swapTarget = this.diagramLogoParent.querySelector("[id='imageHolder" + swapIndex + "-gridNode" + index + "']");
        target.remove();
        target.setAttribute("id", "imageHolder" + swapIndex + "-gridNode" + index);
        target.setAttribute("data-imagegrid-index", swapIndex);

        swapTarget.parentElement.insertBefore(target, swapNodeIndex == 1 ? swapTarget.nextSibling : swapTarget);
        swapTarget.setAttribute("id", "imageHolder" + imagegridIndex + "-gridNode" + index);
        swapTarget.setAttribute("data-imagegrid-index", imagegridIndex);

        this.gridimages = DiagramUtils.swapArrayElements(this.gridimages, imagegridIndex, swapIndex);
        this.updatePropsCallBack();
    }
};

SimpleImageGrid.prototype.updatePropsCallBack = function () {
    if (this.updateCallBack && this.updateCallBack.func) {
        this.updateCallBack.func(this.updateCallBack.params);
    }
};

SimpleImageGrid.prototype.updateFocusCallBack = function () {
    if (this.focusCallBack && this.focusCallBack.func) {
        this.focusCallBack.func(this.focusCallBack.params);
    }
};

/**
 * Author:    Krishna
 * Created:
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function BaseTableDiagram(diagramParent, tableData, nodeProps = {}, moodData = {}) {
    this.tableParent = diagramParent;
    this.moodData = moodData;
    this.nodeProps = {};
    this.eventManagerXY = new window["DiagramEventManager"]();
    this.appStaticURL = "";
    this.appmode = "";
    this.moodName = "";
    this.arrTableNode = [];
    this.slideScale = 1;
    this.mainTime = new Date().getTime();
    this.isWidget = "";
    this.slideID = "";
    this.defaultCellData = { type: "text", value: "" };
    this.observer = null;
    this.maxRow = 15;
    this.maxCol = 15;
    this.optionOffset = 0;
    this.defaultRow = 2;
    this.defaultCol = 2;
    this.defaultCellWidth = "100px";
    this.defaultCellHeight = "60px";

    let time = new Date();
    this.id = `create time ${time.getSeconds()}:${time.getMilliseconds().toFixed(3)}`;

    this.defaultFoucsOut = this.defaultFoucsOut.bind(this);
    this.defaultFoucsIn = this.defaultFoucsIn.bind(this);
    this.defaultCheckBoxEvent = this.defaultCheckBoxEvent.bind(this);
    this.textHighlightMouseUpEvent = this.textHighlightMouseUpEvent.bind(this);
    this.diagramPasteHandler = this.diagramPasteHandler.bind(this);

    this.rowCount = this.tableParent.dataset.rowCount || 2;
    this.colCount = this.tableParent.dataset.colCount || 2;

    this.setNodeProps(tableData);
    // Default class names to be added.
    this.tableParent.className = this.nodeProps.parentStyle || "clsTableModel1";
    this.tableParent.parentElement.className = "clsElementDiv commonallmood ";
}

BaseTableDiagram.prototype.initDiagramCreation = function (isDirectInsert = false) {
    this.mainTime = new Date().getTime();
    this.tableParent.innerHTML = "";
    this.arrTableNode = [];
    this.setMoodClassNames();
    this.tableParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.initialRender = true;
    this.createSetupTable();
    this.slideDimensionChange();
    this.diagramRenderComplete();
};

BaseTableDiagram.prototype.setMoodClassNames = function () {
    if (this.moodName != "") {
        this.tableParent.parentElement.classList.add("common" + this.moodName);
        this.tableParent.parentElement.classList.add(this.moodName + "table");
    }
};

BaseTableDiagram.prototype.diagramRenderComplete = function () {
    if (this.completeCallBack && this.completeCallBack.func) {
        this.completeCallBack.func(this.completeCallBack.params);
        this.completeCallBack = null;
    }
};

BaseTableDiagram.prototype.createSetupTable = function (isDirectInsert = false) {
    this.createElements();
};

BaseTableDiagram.prototype.createElements = function () {
    this.createTable();
    this.updateEvents();
};

BaseTableDiagram.prototype.createTable = function () {
    let contentTextColor = this.globalMoodData?.theme?.textcolormapping?.heading;
    if (contentTextColor) this.tableParent.style.setProperty("--contentCellText", contentTextColor);

    this.arrTableNode = [];
    let oldTable = this.tableParent.querySelector("table");
    if (oldTable) oldTable.parentElement.removeChild(oldTable);

    let btnOldRow = this.tableParent.querySelector(".btnAddRowParent");
    if (btnOldRow) btnOldRow.parentElement.removeChild(btnOldRow);

    let btnOldCol = this.tableParent.querySelector(".btnAddColParent");
    if (btnOldCol) btnOldCol.parentElement.removeChild(btnOldCol);

    let table = document.createElement("table");
    table.className = "clsTable";
    table.setAttribute("id", DiagramNodeUtils.uuidv4());
    table.setAttribute("name", "table");
    this.tableParent.appendChild(table);

    let btnAddRowParent = document.createElement("div");
    btnAddRowParent.className = "btnAddRowParent";
    this.tableParent.appendChild(btnAddRowParent);

    let btnAddRow = document.createElement("button");
    btnAddRow.className = "btnAddRow";
    btnAddRow.textContent = "+";
    btnAddRowParent.appendChild(btnAddRow);

    let tableHead = document.createElement("thead");
    table.appendChild(tableHead);
    let headRow = document.createElement("tr");
    tableHead.appendChild(headRow);

    let tableBody = document.createElement("tbody");
    table.appendChild(tableBody);

    let btnAddColParent = document.createElement("div");
    btnAddColParent.className = "btnAddColParent";
    this.tableParent.appendChild(btnAddColParent);

    let btnAddCol = document.createElement("button");
    btnAddCol.className = "btnAddCol";
    btnAddCol.textContent = "+";
    btnAddColParent.appendChild(btnAddCol);

    let oldwidthResizer = this.tableParent.querySelector("#widthResizer");
    if (oldwidthResizer) oldwidthResizer.parentElement.removeChild(oldwidthResizer);

    // let widthResizer = document.createElement("div");
    // widthResizer.className = "width-resizer";
    // widthResizer.id = "widthResizer";
    // widthResizer.textContent = "...";
    // widthResizer.setAttribute("data-name", "resizer");
    // widthResizer.setAttribute("data-type", "width");
    // this.tableParent.appendChild(widthResizer);

    let oldheightResizer = this.tableParent.querySelector("#heightResizer");
    if (oldheightResizer) oldheightResizer.parentElement.removeChild(oldheightResizer);

    // let heightResizer = document.createElement("div");
    // heightResizer.className = "height-resizer";
    // heightResizer.id = "heightResizer";
    // heightResizer.textContent = "...";
    // heightResizer.setAttribute("data-name", "resizer");
    // heightResizer.setAttribute("data-type", "height");
    // this.tableParent.appendChild(heightResizer);

    function defaultRowColumnCount(inst, defaultRow, defaultCol) {
        inst.initialRender = false;
        while (inst.tableData.nodes.length < defaultRow) {
            inst.tableData.nodes[inst.tableData.nodes.length] = [];
        }

        inst.tableData.nodes.forEach((row) => {
            while (row.length < defaultCol) {
                row.push(JSON.parse(JSON.stringify(inst.defaultCellData)));
            }
        });
    }

    if (!this.tableParent.dataset.hasOwnProperty("tableAltered")) defaultRowColumnCount(this, this.defaultRow, this.defaultCol);
    this.setCellFormatData();

    this.rowCount = this.tableData.nodes.length;
    this.colCount = this.tableData.nodes[0].length;

    for (var i = 0; i < this.colCount + 1; i++) {
        this.createColumnOperationCell(headRow, i);
    }

    for (var i = 0; i < this.rowCount; i++) {
        this.addRowOperation(i);
    }

    this.setCellClass();
    this.setSizeVariable();
    if (!this.tableData.nodes?.[0]?.[0]?.contentsize) this.resizeOption({ value: "fill" });
};

BaseTableDiagram.prototype.addRowOperation = function (i = 0) {
    let tableBody = this.tableParent.querySelector("tbody");
    let row = document.createElement("tr");
    row.setAttribute("data-row-index", i);
    tableBody.appendChild(row);
    for (var j = 0; j < this.colCount + 1; j++) {
        this.addColumnOperation(i, j, row);
    }
};

BaseTableDiagram.prototype.addColumnOperation = function (i = 0, j = 0, row) {
    let cell = document.createElement("td");

    if (j == 0) {
        row.appendChild(this.createRowOperationCell(cell, i));
        return;
    }

    row.appendChild(cell);
    cell.setAttribute("data-cell-index", `${i},${j - 1}`);
    cell.setAttribute("data-name", "datacell");
    cell.setAttribute("id", "datacell-" + `${i},${j - 1}`);

    let div = document.createElement("div");
    div.className = "td-container";
    div.setAttribute("data-cell-index", `${i},${j - 1}`);
    cell.appendChild(div);

    let nodeInstace = new window[this.nodeProps.nodeclassName](this.tableData.nodes[i][j - 1], div, [i, j - 1], this);
    nodeInstace.diagramParent = this.tableParent;
    this.assignCallbacksToNode(nodeInstace);
    nodeInstace.initCreation();

    this.arrTableNode[i] ? this.arrTableNode[i].splice(j, 0, nodeInstace) : this.arrTableNode.push([nodeInstace]);
};

BaseTableDiagram.prototype.createColumnOperationCell = function (headRow, i) {
    let cell = document.createElement("td");
    cell.className = "colOperationCell";
    cell.setAttribute("data-name", "coloperationcell");
    cell.setAttribute("data-type", "coloperationcell");
    cell.id = "colOption-" + (i - 1);
    headRow.appendChild(cell);

    let headerContainer = document.createElement("div");
    headerContainer.className = "headerContainer";
    cell.appendChild(headerContainer);

    let headerText = document.createElement("div");
    headerText.className = "headerText";
    headerText.textContent = String.fromCharCode(97 + (i - 1));
    headerContainer.appendChild(headerText);

    // this.addResizer(headerContainer, i, "col");
};

BaseTableDiagram.prototype.createRowOperationCell = function (cell, i) {
    cell.className = "rowOperationCell";
    cell.setAttribute("data-name", "rowoperationcell");
    cell.setAttribute("data-type", "rowoperationcell");
    cell.id = "rowOption-" + i;
    let headerContainer = document.createElement("div");
    headerContainer.className = "headerContainer";
    cell.appendChild(headerContainer);

    let headerText = document.createElement("div");
    headerText.className = "headerText";
    headerText.innerHTML = `<div>${i + 1}</div>`;
    headerContainer.appendChild(headerText);

    // this.addResizer(headerContainer, i, "row");

    return cell;
};

BaseTableDiagram.prototype.addResizer = function (headerContainer, i, type) {
    let resizer = document.createElement("div");
    resizer.className = "resizer";
    resizer.setAttribute("data-index", i);
    resizer.setAttribute("data-name", "resizer");
    resizer.setAttribute("data-type", type);
    headerContainer.appendChild(resizer);
};

BaseTableDiagram.prototype.addRow = function () {
    if (!this.isHeightAvailable()) return;
    if (this.tableData.nodes.length >= this.maxRow) return;
    this.rowCount += 1;
    this.tableData.nodes[this.rowCount - 1] = [];
    while (this.tableData.nodes[this.tableData.nodes.length - 1].length < this.colCount) {
        this.tableData.nodes[this.tableData.nodes.length - 1].push(JSON.parse(JSON.stringify(this.defaultCellData)));
    }

    this.setCellFormatData();
    this.addRowOperation(this.rowCount - 1);
    this.updateEvents();
    this.tableParent.setAttribute("data-table-Altered", "");
    this.setCellClass();
    this.setSizeVariable();
};

BaseTableDiagram.prototype.addColumn = function () {
    if (!this.isWidthAvailable()) return;
    if (this.tableData.nodes[0].length >= this.maxCol) return;
    let table = this.tableParent.querySelector("table");
    let arrRows = Array.from(table.querySelectorAll("tr"));
    this.colCount += 1;
    this.tableData.nodes.forEach((row, i) => {
        row.push(JSON.parse(JSON.stringify(this.defaultCellData)));
    });

    arrRows.forEach(
        function (tr, i) {
            if (i == 0) this.createColumnOperationCell(tr, this.colCount);
            else {
                // 0th tr belongs to thead so we have to - 1 from tr index for properly update data
                this.addColumnOperation(i - 1, this.colCount, tr);
            }
        }.bind(this)
    );
    this.updateEvents();
    this.setCellClass();
    this.setSizeVariable();
    this.tableParent.setAttribute("data-table-Altered", "");
};

BaseTableDiagram.prototype.deletColumn = function (index) {
    this.tableData.nodes.map((row) => {
        row.splice(index, 1);
    });
    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
};

BaseTableDiagram.prototype.deleteRow = function (index) {
    this.tableData.nodes.splice(index, 1);
    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
};

BaseTableDiagram.prototype.insertRowAt = function (index) {
    if (!this.isHeightAvailable()) return;
    this.tableData.nodes.splice(index, 0, []);
    while (this.tableData.nodes[index].length < this.colCount) {
        this.tableData.nodes[index].push(JSON.parse(JSON.stringify(this.defaultCellData)));
    }
    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
};

BaseTableDiagram.prototype.insertColAt = function (index) {
    if (!this.isWidthAvailable()) return;
    this.tableData.nodes.forEach((row) => {
        row.splice(index, 0, JSON.parse(JSON.stringify(this.defaultCellData)));
    });
    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
};

//Row and Column related function
BaseTableDiagram.prototype.rowContentChange = function (operation, rowIndex) {
    this.arrTableNode[rowIndex].forEach((cell) => (cell.nodeData.type != operation.value ? cell.changeContentType(operation) : ""));
};

BaseTableDiagram.prototype.columnContentChange = function (operation, colIndex) {
    this.arrTableNode.forEach((row) => {
        let cell = row[colIndex];
        cell.nodeData.type != operation.value ? cell.changeContentType(operation) : "";
    });
};

BaseTableDiagram.prototype.rowOperation = function (operation, rowIndex) {
    switch (operation.value) {
        case "deleterow":
            this.deleteRow(rowIndex);
            break;
        case "insertrowbefore":
            this.insertRowAt(rowIndex, rowIndex);
            break;
        case "insertrowafter":
            this.insertRowAt(rowIndex + 1, rowIndex);
            break;
        case "splitequally":
            this.splitRowEqually();
            break;
        case "swaptop":
        case "swapbottom":
            this.swapRow(operation, rowIndex);
            break;
        case "highlight":
            this.updateRowHighlight(rowIndex);
            break;
        default:
            break;
    }
};

BaseTableDiagram.prototype.splitRowEqually = function () {
    let cellSpace = (this.tableParent.clientWidth - this.optionOffset) / this.arrTableNode[0].length;
    this.arrTableNode[0].forEach((cell, i) => {
        this.tableParent.style.setProperty("--width" + i, cellSpace - 20 + "px");
    });
};

BaseTableDiagram.prototype.updateRowHighlight = function (rowIndex) {
    let colHeader = this.nodeProps?.colheader || "false";
    this.tableData.nodes?.[rowIndex]?.forEach((node, i) => {
        if (colHeader == "true" && i == 0) return;
        let highlight = node.rowhighlight || "";
        if (highlight == "") highlight = "row";
        else if (highlight.includes("row")) highlight = highlight.replaceAll("row", "").replaceAll(",", "");
        else highlight = highlight + ",row";

        if (highlight && highlight == "") delete node.highlight;
        else node.rowhighlight = highlight;
    });
    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
};

BaseTableDiagram.prototype.columnOperation = function (operation, colIndex) {
    switch (operation.value) {
        case "deletecol":
            this.deletColumn(parseInt(colIndex));
            break;
        case "insertcolbefore":
            this.insertColAt(colIndex, colIndex);
            break;
        case "insertcolafter":
            this.insertColAt(colIndex + 1, colIndex);
            break;
        case "splitequally":
            this.splitColEqually();
            break;
        case "highlight":
            this.updateColHighlight(colIndex);
            break;
        default:
            break;
    }
};

BaseTableDiagram.prototype.splitColEqually = function () {
    let cellSpace = (this.tableParent.parentElement.clientHeight - this.optionOffset) / this.arrTableNode.length;
    this.arrTableNode.forEach((cell, i) => {
        this.tableParent.style.setProperty("--height" + i, cellSpace - 20 + "px");
    });
};

BaseTableDiagram.prototype.updateColHighlight = function (colIndex) {
    let rowHeader = this.nodeProps?.rowheader || "false";
    this.tableData.nodes.forEach((node, i) => {
        if (rowHeader == "true" && i == 0) return;
        let highlight = node[colIndex].colhighlight || "";
        if (highlight == "") highlight = "col";
        else if (highlight.includes("col")) highlight = highlight.replaceAll("col", "").replaceAll(",", "");
        else highlight = highlight + ",col";

        if (highlight && highlight == "") delete node[colIndex].highlight;
        else node[colIndex].colhighlight = highlight;
    });
    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
};

// End of row and column relarted function

BaseTableDiagram.prototype.defaultFoucsIn = function (event) {
    event.target.dataset.oldtext = event.target.innerHTML;
    // let nodeInstance = this.getInstanseOfElement(event.target);
    // if (nodeInstance) {
    //     nodeInstance.oldNodeData = nodeInstance.getJSONData();
    // }
};

BaseTableDiagram.prototype.defaultFoucsOut = function (event) {
    let typedText = event.target.dataset && event.target.dataset.oldtext ? event.target.dataset.oldtext : "";
    if (event.target.innerHTML != typedText && this.appmode != "PRESENT") {
        this.eventManagerXY.dispatch("focusout", event.target);
        event.target.dataset.oldtext = event.target.innerHTML;
        this.updatePropsCallBack(event.target.id);
        this.updateJSONData();
        let nodeInstance = this.getInstanseOfElement(event.target);
        if (nodeInstance) nodeInstance?.updateOnFocusOut?.(event.target);
    }
};

BaseTableDiagram.prototype.textHighlightMouseUpEvent = function (event) {
    this.eventManagerXY.dispatch("mouseup", event);
};

BaseTableDiagram.prototype.addListener = function (event, callback) {
    this.eventManagerXY.addListener(event, callback);
};

BaseTableDiagram.prototype.updateEvents = function () {
    if (this.observer) this.observer.disconnect();
    this.eventManagerXY.clear();
    if (this.appmode.toLowerCase() == "present") return;

    for (let j = 0; j < this.arrTableNode.length; j++) {
        let row = this.arrTableNode[j];
        for (let i = 0; i < row.length; i++) {
            let node = row[i];
            let nodeParent = row[i].nodeParent;
            let arrChildNodes = Array.from(nodeParent.querySelectorAll("[data-default-event='true']"));

            node.observer.disconnect();
            node.observer = new MutationObserver(node.mutationCallBack);
            node.observer.mytargets = [];

            for (let k = 0; k < arrChildNodes.length; k++) {
                this.eventManagerXY.addEvent(arrChildNodes[k], "focusout", this.defaultFoucsOut);
                this.eventManagerXY.addEvent(arrChildNodes[k], "focusout", node.onFocusOut);
                this.eventManagerXY.addEvent(arrChildNodes[k], "focusin", this.defaultFoucsIn);
                this.eventManagerXY.addEvent(arrChildNodes[k], "paste", this.diagramPasteHandler);

                if (arrChildNodes[k].getAttribute("data-observer") && arrChildNodes[k].getAttribute("data-observer") == "true") {
                    node.observer.observe(arrChildNodes[k], { childList: true });
                    node.observer.mytargets.push(arrChildNodes[k]);
                }
            }

            // For Text Highlight
            let arrHighLightNodes = nodeParent.querySelectorAll("[data-highlight-event='true']");
            for (let j = 0; j < arrHighLightNodes.length; j++) {
                this.eventManagerXY.addEvent(arrHighLightNodes[j], "mouseup", this.textHighlightMouseUpEvent);
            }

            let checklistNodes = nodeParent.querySelectorAll("[data-checkbox-event='true']");
            for (let j = 0; j < checklistNodes.length; j++) {
                this.eventManagerXY.addEvent(checklistNodes[j], "mousedown", this.defaultCheckBoxEvent);
            }

            let microchartNode = nodeParent.querySelectorAll("[data-id='microchartNode']");
            if (microchartNode && microchartNode.length > 0) {
                microchartNode.forEach((element) => {
                    this.eventManagerXY.addEvent(element, "focusout", node.microChartFoucsOut);
                    this.eventManagerXY.addEvent(element, "focusin", node.microChartFoucsIn);
                });
            }

            let microchartNodeCircle = nodeParent.querySelectorAll("[id*='clsCircleBG']");
            if (microchartNodeCircle && microchartNodeCircle.length > 0 && this.nodeProps?.microStyle && this.nodeProps?.microStyle == "clsRatingMicro") {
                microchartNodeCircle.forEach((element) => {
                    this.eventManagerXY.addEvent(element, "click", node.microChartClickEvent);
                });
            }

            let arrPriorityNodeHolder = nodeParent.querySelectorAll("[id*='priorityNodeHolder']");
            arrPriorityNodeHolder?.forEach((element) => {
                this.eventManagerXY.addEvent(element, "click", node.priorityClickEvent);
            });
        }
    }

    let btnAddColumn = this.tableParent.querySelector(".btnAddCol");
    if (btnAddColumn) this.eventManagerXY.addEvent(btnAddColumn, "click", this.addColumn.bind(this));

    let btnAddRow = this.tableParent.querySelector(".btnAddRow");
    if (btnAddRow) this.eventManagerXY.addEvent(btnAddRow, "click", this.addRow.bind(this));

    let arrColOpBtn = this.tableParent.querySelectorAll("[data-name='coloperation']");
    for (let i = 0; i < arrColOpBtn.length; i++) {
        this.eventManagerXY.addEvent(
            arrColOpBtn[i],
            "click",
            function (e) {
                this.deletColumn(e.target.dataset.index - 1);
            }.bind(this)
        );
    }

    let arrRowOpBtn = this.tableParent.querySelectorAll("[data-name='rowoperation']");
    for (let i = 0; i < arrRowOpBtn.length; i++) {
        this.eventManagerXY.addEvent(
            arrRowOpBtn[i],
            "click",
            function (e) {
                this.deleteRow(e.target.dataset.index);
            }.bind(this)
        );
    }

    let widthResizer = this.tableParent.querySelector("#widthResizer");
    let heightResizer = this.tableParent.querySelector("#heightResizer");

    let table = this.tableParent.querySelector("[name='table']");
    this.observer = new ResizeObserver((enter) => {
        let rect = enter[0].target == table ? enter[0].contentRect : { width: table.clientWidth, height: table.clientHeight };
        btnAddRow.parentElement.style.top = table.offsetTop + rect.height + "px";
        btnAddRow.parentElement.style.left = table.offsetLeft + "px";

        btnAddColumn.parentElement.style.top = table.offsetTop + "px";
        btnAddColumn.parentElement.style.left = table.offsetLeft + rect.width + "px";

        // widthResizer.style.left = table.offsetLeft + rect.width + "px";
        // heightResizer.style.top = table.offsetTop + rect.height + "px";
        this.tableSizeChangeHandler?.(rect);
    });
    this.observer.observe(table);
    this.observer.observe(table.parentElement);

    //update callback listeners
    if (this.focusoutTextEvent) {
        this.addListener("focusout", this.focusoutTextEvent);
    }
    if (this.mousedownTextEvent) {
        this.addListener("mousedown", this.mousedownTextEvent);
    }
    if (this.mouseupSelectionEvent) {
        this.addListener("mouseup", this.mouseupSelectionEvent);
    }
    if (this.keyupSelectionEvent) {
        this.addListener("keyup", this.keyupSelectionEvent);
    }
    if (this.keypressEvent) {
        this.addListener("keypress", this.keypressEvent);
    }

    this.eventManagerXY.addEvent(this.tableParent, "mousedown", this.setUpResizeListner.bind(this));
};

BaseTableDiagram.prototype.defaultCheckBoxEvent = function (event) {
    event.preventDefault();
    event.slideID = this.slideID;
    this.eventManagerXY.dispatch("mousedown", event);
};

BaseTableDiagram.prototype.searchIconCallBack = function (content, type, index, id) {
    this.updateNodeData(content, type, index.split(","), id);
    this.updatePropsCallBack(id);
};

BaseTableDiagram.prototype.updatePropsCallBack = function (targetid) {
    if (this.updateCallBack && this.updateCallBack.func) {
        this.updateCallBack.func(this.updateCallBack.params, targetid);
    }
};

BaseTableDiagram.prototype.diagramPasteHandler = function (event) {
    event.preventDefault();
    try {
        let strUnformattedText = (event.clipboardData || event.originalEvent.clipboardData).getData("text/plain");
        document.execCommand("insertText", false, strUnformattedText);
    } catch (error) {
        console.log("Text Paste Error");
    }
};

BaseTableDiagram.prototype.getProperties = function (defaultproperties = {}) {
    let mainProperties = defaultproperties; //this.tableData && this.tableData.properties ? this.tableData.properties : defaultproperties;
    this.getPropertiesFromConstants(mainProperties, JSON.parse(JSON.stringify(Constants.Value.tableProperties)));
    mainProperties.isAltered = this.tableParent.dataset.hasOwnProperty("tableAltered");
    return mainProperties;
};

BaseTableDiagram.prototype.getNodeProperties = function () {
    if (this.nodeProps == null) this.nodeProps = {};
    let arrNodeProperties = { nodeclassName: "TableNode" };
    this.getPropertiesFromConstants(this.nodeProps, JSON.parse(JSON.stringify(arrNodeProperties)));
};

BaseTableDiagram.prototype.getPropertiesFromConstants = function (mainObj, constArrProperties, extraAttrib = "") {
    for (var property in constArrProperties) {
        let propValue = this.tableParent.dataset[extraAttrib + property.toLowerCase()];
        if (property.includes("json")) {
            property = property.substring(4);
            propValue = this.tableParent.dataset[extraAttrib + property.toLowerCase()];
            try {
                mainObj[property] = propValue ? JSON.parse(propValue) : constArrProperties["json" + property];
            } catch (error) {
                mainObj[property] = propValue ? propValue : constArrProperties["json" + property];
            }
        } else if (property.includes("bool")) {
            property = property.substring(4);
            propValue = this.tableParent.dataset[extraAttrib + property.toLowerCase()];
            mainObj[property] = propValue && (propValue == "true" || propValue == true) ? true : false;
        } else if (property.includes("arr")) {
            property = property.substring(3);
            propValue = this.tableParent.dataset[extraAttrib + property.toLowerCase()];
            let arrRes = propValue && propValue != "" ? JSON.parse(propValue) : constArrProperties[property];
            mainObj[property] = arrRes; //arrRes?.map((item) => parseInt(item)) || constArrProperties[property];
        } else {
            mainObj[property] = propValue || constArrProperties[property];
        }
    }
};

BaseTableDiagram.prototype.updateProperties = function (properties) {
    this.setPropertiesFromConstants(properties, JSON.parse(JSON.stringify(Constants.Value.tableProperties)));
    this.setNodeProps(null);
    if (this.tableData) this.tableData.properties = this.getProperties();
};

BaseTableDiagram.prototype.updateMoodProperties = function () {
    let properties = {
        ...(this.globalMoodData.imageoverlayproperties && { isoverlaysupport: this.globalMoodData.imageoverlayproperties.support }),
        ...(this.globalMoodData.imageoverlayproperties && { isoverlay: this.globalMoodData.imageoverlayproperties.enable }),
    };
    if (Object.keys(properties).length > 0) this.updateProperties(properties);
};

BaseTableDiagram.prototype.setPropertiesFromConstants = function (mainObj, constArrProperties, extraAttrib = "") {
    for (var property in constArrProperties) {
        let jsonFormat = property.includes("json");
        let boolFormat = property.includes("bool");
        let boolArrFormat = property.includes("arr");
        property = jsonFormat || boolFormat ? property.substring(4) : property;
        if (jsonFormat) {
            let value = mainObj[property] ? JSON.stringify(mainObj[property]) : null;
            if (mainObj[property] && value != null) this.tableParent.setAttribute("data-" + property, value);
        } else if (boolFormat) {
            let value = mainObj.hasOwnProperty(property) ? mainObj[property] : this.nodeProps?.[property];
            if (value) this.tableParent.setAttribute("data-" + property, value);
            else if (this.tableParent.hasAttribute("data-" + property)) this.tableParent.removeAttribute("data-" + property);
        } else if (boolArrFormat) {
            property = property.replace("arr", "");
            let value = mainObj.hasOwnProperty(property) ? JSON.stringify(mainObj[property]) : this.nodeProps?.[property];
            if (value) this.tableParent.setAttribute("data-" + property, value);
            else if (this.tableParent.hasAttribute("data-" + property)) this.tableParent.removeAttribute("data-" + property);
        } else {
            let value = mainObj.hasOwnProperty(property) ? mainObj[property] : this.nodeProps?.[property];
            if (value) this.tableParent.setAttribute("data-" + property, value);
            else if (this.tableParent.hasAttribute("data-" + property)) this.tableParent.removeAttribute("data-" + property);
        }
    }
};

BaseTableDiagram.prototype.getOutlineMatrix = function () {
    const properties = this.getProperties();
    let rowMatrix = this.tableData.nodes.map((data) => {
        return { matrix: data };
    });
    return {
        subtype: "table",
        outlinetype: "table",
        properties: properties,
        matrix: rowMatrix,
    };
};

BaseTableDiagram.prototype.initDiagramCreationOutline = function (outlineData, data) {
    let nodes = [];
    let properties = data.properties || {};
    let maxColCount = 0;

    if (outlineData && outlineData.matrix) {
        for (let i = 0; i < outlineData.matrix.length; i++) {
            let rowData = outlineData.matrix[i];
            nodes.push(rowData.matrix);
            maxColCount = Math.max(maxColCount, rowData.matrix.length);
        }
    }

    // to maintain same column count
    nodes.map((row) => {
        let diffCount = maxColCount - row.length;
        for (var i = 0; i < diffCount; i++) {
            row.push({ type: "text", value: "text" });
        }
    });

    this.tableData = { properties: properties, nodes: nodes };
};

BaseTableDiagram.prototype.slideDimensionChange = function () {
    let table = this.tableParent.querySelector("[name='table']");
    if (table && this.tableParent.clientWidth - this.optionOffset < table.clientWidth) this.splitRowEqually();
    if (table && this.tableParent.clientHeight - this.optionOffset < table.clientHeight) this.splitColEqually();
};

BaseTableDiagram.prototype.setSlideScale = function () {
    this.slideScale = DiagramUtils.calcSlideScale(this.tableParent.parentElement.parentElement, this.appmode);
};

BaseTableDiagram.prototype.setSlideWidthHeight = function (width, height) {
    this.slideWidth = width;
    this.slideHeight = height;
    Constants.Value = { ...Constants.Value, slideWidth: width, slideHeight: height };
};

BaseTableDiagram.prototype.updateNodeData = function (nodeData, type, index, parentId, componentType) {
    if (this.arrTableNode) {
        this.arrTableNode[index[0]][index[1]].updateContentData(nodeData, type, parentId);
    }
};

BaseTableDiagram.prototype.updateGridListData = function (obj) {
    if (this.arrTableNode) {
        let node = this.arrTableNode[index[0]][index[1]];
        node.gridInstance?.changeImageNode(strImageCropID, gridIndex, imageURL, nodeData.searchText);
    }
};

BaseTableDiagram.prototype.getOldTablePropertyValue = function (property, valueObj) {
    return DiagramUtils.getOldTablePropertyValue(property, valueObj, this.tableParent, this);
};

BaseTableDiagram.prototype.setTableOperationProperty = function (property, valueObj) {
    DiagramUtils.setTableOperationProperty(property, valueObj, this.tableParent, this);
};

BaseTableDiagram.prototype.updateElements = function () {
    this.eventManagerXY.clear();
    this.clear();
    this.recreateElementData();
    this.updateJSONData();
    this.updateEvents();

    let table = this.tableParent.querySelector("[name='table']");
    if (table) {
        let wT = this.tableParent.clientWidth;
        let wH = this.tableParent.clientHeight;
        let wt = table.clientWidth;
        let wh = table.clientHeight;

        if (wt > wT) this.rowOperation({ value: "splitequally" });
        if (wh > wH) this.columnOperation({ value: "splitequally" });
    }
};

BaseTableDiagram.prototype.updateJSONData = function () {
    this.tableData = this.getJSONData();
};

BaseTableDiagram.prototype.getJSONData = function (defaultproperties) {
    if (this.arrTableNode.length == 0) return this.tableData || { properties: this.getProperties(defaultproperties) };
    let arrNodeData = [];
    for (let i = 0; i < this.arrTableNode.length; i++) {
        let arrRow = [];
        for (let j = 0; j < this.arrTableNode[i].length; j++) {
            let nodeData = this.arrTableNode[i][j].getJSONData(this.tableParent);
            arrRow.push(nodeData);
            this.arrTableNode[i][j].nodeData = nodeData; // Added to store data in nodeinstance also
        }
        arrNodeData.push(arrRow);
    }
    return { properties: this.getProperties(defaultproperties), nodes: arrNodeData };
};

BaseTableDiagram.prototype.recreateElementData = function () {
    this.setMoodClassNames();
    let tbody = this.tableParent.querySelector("tbody");
    let arrRows = Array.from(tbody.querySelectorAll("tr"));
    this.arrTableNode = [];
    let nodesData = [];
    for (let i = 0; i < arrRows.length; i++) {
        let arrCells = arrRows[i].querySelectorAll("td");
        let arr = [];
        let node = [];
        for (let j = 1; j < arrCells.length; j++) {
            let nodeItem = arrCells[j];
            let nodeInstace = new window[this.nodeProps.nodeclassName]({}, nodeItem.firstElementChild, [i, j - 1], this);
            this.assignCallbacksToNode(nodeInstace);
            nodeInstace.nodeData = nodeInstace.getJSONData();
            arr.push(nodeInstace);
            node.push(nodeInstace.nodeData);
        }
        this.arrTableNode.push(arr);
        nodesData.push(node);
    }
    this.tableData = { properties: {}, nodes: nodesData };
    this.rowCount = this.tableData.nodes.length;
    this.colCount = this.tableData.nodes[0].length;
    this.setSizeVariable();
};

BaseTableDiagram.prototype.clear = function () {
    this.eventManagerXY.clear();
    this.arrTableNode = [];
};

BaseTableDiagram.prototype.clearEvents = function () {
    this.eventManagerXY.clear();
};

BaseTableDiagram.prototype.abort = function () {
    try {
        this.clear();
        this.completeCallBack = null;
        this.tableParent.innerHTML = "";
    } catch (error) {
        console.log(error);
    }
};

BaseTableDiagram.prototype.applyMiltiColorForColumnItem = function () {
    this.arrTableNode.forEach((row, i) => {
        row.forEach((cell, j) => {
            let useNode = cell.nodeParent.querySelector("#useNode");
            useNode && DiagramUtils.setCustomItemColor(useNode, this.arrTintArray, j, j + 1);
        });
    });
};

BaseTableDiagram.prototype.setNodeProps = function (menuData, arrRequiredProperty = []) {
    this.nodeProps = {};
    arrRequiredProperty = this.arrSupportednodeProps();
    for (const property in menuData) {
        if (arrRequiredProperty.includes(property)) {
            let value = this.tableParent.dataset[property] || menuData[property];
            if (value) {
                this.nodeProps[property] = JSON.parse(JSON.stringify(value));
                this.tableParent.dataset[property] = JSON.parse(JSON.stringify(value));
            } else if (this.tableParent.dataset[property]) {
                delete this.tableParent.dataset[property];
            }
        }
    }
    if (menuData == null) {
        arrRequiredProperty.forEach(
            function (property) {
                if (this.tableParent.dataset[property]) this.nodeProps[property] = this.tableParent.dataset[property];
            }.bind(this)
        );
    }
};

BaseTableDiagram.prototype.setCellFormatData = function () {
    return;
    switch (this.nodeProps.parentStyle) {
        case "clsTableModel9":
        case "clsTableModel10":
            this.tableData.nodes.forEach((row, i) => {
                if (i > 0) {
                    row.forEach((cell, j) => {
                        if (j == 0) {
                            cell.secContent = true;
                            cell.type = "icon";
                        }
                    });
                }
            });
            break;
        case "clsTableModel11":
            this.tableData.nodes.forEach((row, i) => {
                row.forEach((cell, j) => {
                    if (j == 0) {
                        cell.secContent = true;
                        cell.type = "icon";
                    }
                });
            });
            break;
    }
};

BaseTableDiagram.prototype.setCellClass = function () {
    return;
    switch (this.nodeProps.parentStyle) {
        case "clsTableModel1":
        case "clsTableModel4":
        case "clsTableModel9":
        case "clsTableModel10":
            this.arrTableNode.forEach((row, i) => {
                row.forEach((cell, j) => {
                    if (i == 0) {
                        cell.addClassName("colHeaderCell");
                        cell.addClassName("h8");
                    } else if (j == 0) {
                        cell.addClassName("rowHearderCell");
                        cell.addClassName("h8");
                    } else {
                        cell.addClassName("contentCell");
                        cell.mainParent.style.setProperty("--cellColor", `rgba(var(--item${j + 1}-color-rgb), 1)`);
                        cell.addClassName("p6");
                    }
                });
            });
            break;
        case "clsTableModel2":
        case "clsTableModel3":
        case "clsTableModel5":
        case "clsTableModel6":
            this.arrTableNode.forEach((row, i) => {
                row.forEach((cell, j) => {
                    if (i == 0) {
                        cell.addClassName("colHeaderCell");
                        cell.addClassName("h8");
                    } else {
                        cell.addClassName("contentCell");
                        cell.mainParent.style.setProperty("--cellColor", `rgba(var(--item${j + 1}-color-rgb), 1)`);
                        cell.addClassName("p6");
                    }
                });
            });
            break;
        case "clsTableModel11":
            this.arrTableNode.forEach((row, i) => {
                row.forEach((cell, j) => {
                    if (j == 0) {
                        cell.addClassName("rowHearderCell");
                        cell.addClassName("h8");
                    } else {
                        cell.addClassName("contentCell");
                        cell.mainParent.style.setProperty("--cellColor", `rgba(var(--item${j + 1}-color-rgb), 1)`);
                        cell.addClassName("p6");
                    }
                });
            });
            break;
        case "clsTableModel7":
            this.arrTableNode.forEach((row, i) => {
                row.forEach((cell, j) => {
                    if (i == this.arrTableNode.length - 1) {
                        cell.addClassName("colHeaderCell");
                        cell.addClassName("h8");
                    } else {
                        cell.addClassName("contentCell");
                        cell.mainParent.style.setProperty("--cellColor", `rgba(var(--item${j + 1}-color-rgb), 1)`);
                        cell.addClassName("p6");
                    }
                });
            });
            break;
        case "clsTableModel8":
            this.arrTableNode.forEach((row, i) => {
                row.forEach((cell, j) => {
                    if (i == this.arrTableNode.length - 1 || i == 0) {
                        cell.addClassName("colHeaderCell");
                        cell.addClassName("h8");
                    } else {
                        cell.addClassName("contentCell");
                        cell.mainParent.style.setProperty("--cellColor", `rgba(var(--item${j}-color-rgb), 1)`);
                        cell.addClassName("p6");
                    }
                });
            });
            break;
    }
};

BaseTableDiagram.prototype.setSizeVariable = function () {
    this.arrTableNode.forEach((row, i) => {
        row.forEach((cell, j) => {
            this.addSizeVariable(i, j, cell);
        });
    });
};

BaseTableDiagram.prototype.getInstanseOfElement = function (element) {
    let arrIndex = element.id.split("-")[1].split(",");
    if (this.arrTableNode.length > 0) {
        return this.arrTableNode[arrIndex[0]][arrIndex[1]];
    }
    return null;
};

BaseTableDiagram.prototype.addSizeVariable = function (i, j, cell) {
    let cellContentWidth = cell.nodeData?.contentsize?.width || this.tableParent.style.getPropertyValue("--width" + j) || this.defaultCellWidth;
    let cellContentHeight = cell.nodeData?.contentsize?.height || this.tableParent.style.getPropertyValue("--height" + i) || this.defaultCellHeight;

    this.tableParent.style.setProperty("--width" + j, cellContentWidth);
    this.tableParent.style.setProperty("--height" + i, cellContentHeight);
    cell.nodeParent.style.width = `var(--width${j})`;
    cell.nodeParent.style.height = `var(--height${i})`;
};

BaseTableDiagram.prototype.setUpResizeListner = function (event) {
    let target = event.target;
    let resizer = target.dataset?.name || "";
    if (resizer != "resizer") return;
    let index = parseInt(target.dataset.index);
    let type = target.dataset.type;
    var dataNode = null;
    var contentNode = null;
    var initialWidth = 0;
    var initialHeight = 0;

    if (!isNaN(index)) {
        dataNode = type == "col" ? this.arrTableNode[0][index - 1] : this.arrTableNode[index][0];
        contentNode = dataNode.nodeParent;
        initialWidth = contentNode.clientWidth;
        initialHeight = contentNode.clientHeight;
    }

    let tableParent = this.tableParent;
    let table = this.tableParent.querySelector("[name='table'");

    let initialX = event.clientX;
    let initialY = event.clientY;

    let arrWidth = this.arrTableNode[0].map((cell) => cell.nodeParent.clientWidth);
    let arrHeight = this.arrTableNode.map((row) => row[0].nodeParent.clientHeight);

    pauseEvent(event);

    let mousemove = (event) => {
        let diffX = event.clientX - initialX;
        let diffY = event.clientY - initialY;
        let availableWidth = tableParent.clientWidth - this.optionOffset - table.clientWidth;
        let availableHeight = tableParent.clientHeight - this.optionOffset - table.clientHeight;

        if (type == "col" && (availableWidth > 0 || diffX < 0)) {
            tableParent.style.setProperty("--width" + (index - 1), Math.max(initialWidth + diffX, 50) + "px");
        } else if (type == "row" && (availableHeight > 0 || diffY < 0)) {
            tableParent.style.setProperty("--height" + index, initialHeight + diffY + "px");
        } else if (type == "width" && (availableWidth > 0 || diffX < 0)) {
            this.arrTableNode[0].map((cell, i, arr) => {
                this.tableParent.style.setProperty("--width" + i, Math.max(arrWidth[i] + diffX / (arr.length / 2), 50) + "px");
            });
        } else if (type == "height" && (availableHeight > 0 || diffY < 0)) {
            this.arrTableNode.map((cell, i, arr) => {
                this.tableParent.style.setProperty("--height" + i, arrHeight[i] + diffY / (arr.length / 2) + "px");
            });
        }
    };

    let mouseup = (event) => {
        this.updatePropsCallBack(event.target.id);
        this.updateTextNodes?.();
        clear();
    };

    function pauseEvent(e) {
        if (e.stopPropagation) e.stopPropagation();
        if (e.preventDefault) e.preventDefault();
        e.cancelBubble = true;
        e.returnValue = false;
        return false;
    }

    function clear() {
        window.removeEventListener("mousemove", mousemove);
        window.removeEventListener("mouseup", mouseup);
    }

    window.addEventListener("mousemove", mousemove);
    window.addEventListener("mouseup", mouseup);
};

BaseTableDiagram.prototype.isWidthAvailable = function () {
    let availableWidth = this.tableParent.clientWidth - this.optionOffset - this.tableParent.firstElementChild.clientWidth;
    if (availableWidth < 150) {
        this.appDispatcher.dispatch({ type: "ALERT_MESSAGE", title: "Invalid Data", message: "There is not enough space to add more nodes!" });
        return false;
    }
    return true;
};

BaseTableDiagram.prototype.isHeightAvailable = function () {
    let availableHeight = this.tableParent.clientHeight - this.optionOffset - this.tableParent.firstElementChild.clientHeight;
    if (availableHeight < 60) {
        this.appDispatcher.dispatch({ type: "ALERT_MESSAGE", title: "Invalid Data", message: "There is not enough space to add more nodes!" });
        return false;
    }
    return true;
};

BaseTableDiagram.prototype.resizeOption = function (obj) {
    switch (obj.value) {
        case "reset":
            this.arrTableNode.forEach((cell, i) => {
                this.tableParent.style.setProperty("--height" + i, this.defaultCellHeight);
            });
            this.arrTableNode[0].forEach((cell, i) => {
                this.tableParent.style.setProperty("--width" + i, this.defaultCellWidth);
            });
            break;
        case "fill":
            this.columnOperation({ value: "splitequally" });
            this.rowOperation({ value: "splitequally" });
            break;
    }
};

BaseTableDiagram.prototype.swapColumn = function (obj) {};

BaseTableDiagram.prototype.swapRow = function (obj, index) {
    let destinationIndex = obj.value.includes("top") ? index + 1 : index - 1;
    let source = this.tableData.nodes[index];
    let destination = this.tableData.nodes[destinationIndex];
    this.tableData.nodes[index] = destination;
    this.tableData.nodes[destinationIndex] = source;
    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
};

BaseTableDiagram.prototype.initPresent = function (currentSlide, boolNoAnimation = false) {
    // this.tableParent.classList.add("moodanimation");
    // this.tableParent.dataset.animation = "item";

    if (boolNoAnimation) return { isTitleAnimation: false, isGraphicAnimation: false };
    this.tableParent.style.opacity = 0;
    return { isTitleAnimation: true, isGraphicAnimation: true };
};

BaseTableDiagram.prototype.arrSupportednodeProps = function () {
    return [
        "nodeclassName", //
        "version",
        "style",
        "parentStyle",
        "innerColor",
        "name",
        "parentClassName",
        "checkBG",
        "uncheckBG",
        "colordata",
        "microStyle",
        "colheader",
        "numbering",
        "rowheader",
        "colfooter",
        "tableresize",
        "sequencetextstart",
        "ignorefirstrow",
        "rowhighlightindex",
        "colhighlightindex",
        "cellhighlightindex",
    ];
};

BaseTableDiagram.prototype.assignCallbacksToNode = function (nodeInstace) {
    nodeInstace.dInst = this;
    nodeInstace.moodData = this.moodData;
    nodeInstace.fontClassList = this.fontClassList;
    nodeInstace.moodName = this.moodName;
    nodeInstace.arrTintArray = this.arrTintArray;
    nodeInstace.appStaticURL = this.appStaticURL;
    nodeInstace.updateCallBack = this.updateCallBack;
    nodeInstace.globalMoodData = this.globalMoodData;
    nodeInstace.manifestUpdater = this.manifestUpdater;
    nodeInstace.searchIconCallBack = this.searchIconCallBack.bind(this);
};

BaseTableDiagram.prototype.setupInLineFloaterOption = function (eltarget, type, obj) {};

BaseTableDiagram.prototype.clear = function () {
    LinearDiagram.prototype.clear.call(this);
    this.observer?.disconnect();
    this.observer = null;
};

BaseTableDiagram.prototype.checkForLightText = function (nodeParent, properties, type) {
    try {
        let index = nodeParent.dataset.index;
        let isheader = properties.rowheader || properties.colheader;
        let isBgBox = nodeParent.classList.contains("clsBackgroundGroupBoxed");
        let isLightText = !isBgBox && isheader;
        if (isLightText) nodeParent.dataset.disablecontrast = true;
        else if (index == "0,0" && type == "row" && !properties.colheader) delete nodeParent.dataset.disablecontrast;
        else if (index == "0,0" && type == "col" && !properties.rowheader) delete nodeParent.dataset.disablecontrast;
        else delete nodeParent.dataset.disablecontrast;
    } catch (error) {
        console.log(error);
    }
};

//Module private function
function tableResiz() {
    let btnAddRow = this.tableParent.querySelector(".btnAddRowParent");
    let btnAddCol = this.tableParent.querySelector(".btnAddColParent");

    return function (e) {
        console.log(e);
    };
}

"use strict";

function MultiContentTable(diagramParent, tableData, nodeProps = {}, moodData = {}) {
    BaseTableDiagram.call(this, diagramParent, tableData, nodeProps, moodData);
    // this.tableParent.className = this.nodeProps?.parentClassName || "clsMultiContentTable";
    this.tableParent.className = this.nodeProps?.parentStyle || "clsMultiContentTable";
    if (!this.tableParent.classList.contains("moodanimation")) this.tableParent.classList.add("moodanimation");
    this.tableParent.dataset.animation = "item";
    this.defaultCellData = {
        titleHolder: {
            type: "text",
            value: "Close to the metal",
            textproperties: {
                letterspacing: null,
                lineheight: null,
                texttransform: "none",
                textopacity: "1",
                textclassname: "auto",
                textsize: "22px",
            },
        },
        subTitleHolder: {
            sublist: "none",
            items: [
                {
                    type: "text",
                    value: "From direct integrations with card networks and banks to checkout flows in the browser, we operate on and optimize at every level of the financial stack.",
                    index: 0,
                    content: null,
                },
            ],
            textproperties: {
                letterspacing: null,
                lineheight: null,
                texttransform: "none",
                textopacity: "1",
                textsize: "18px",
            },
        },
        cellproperties: {
            highlight: false,
            emphasize: false,
            sublist: "none",
            ischecked: false,
        },
    };
    this.optionOffset = 0;
}

MultiContentTable.prototype = Object.create(BaseTableDiagram.prototype);
MultiContentTable.prototype.constructor = MultiContentTable;

MultiContentTable.prototype.initDiagramCreation = function (isDirectInsert = false) {
    this.mainTime = new Date().getTime();
    this.tableParent.innerHTML = "";
    this.arrTableNode = [];
    this.setMoodClassNames();
    this.tableParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.initialRender = true;
    this.createSetupTable();
    this.slideDimensionChange();
    this.diagramRenderComplete();
};

MultiContentTable.prototype.diagramRenderComplete = function () {
    BaseTableDiagram.prototype.diagramRenderComplete.call(this);
    if (this.appmode.toLowerCase() != "present") {
        this.updateTextNodes();
    }
};

MultiContentTable.prototype.initDiagramCreationOutline = function (outlineData, data) {
    let nodes = [];
    let properties = data.properties || {};
    let maxColCount = 0;

    if (outlineData && outlineData.matrix) {
        for (let i = 0; i < outlineData.matrix.length; i++) {
            let rowData = outlineData.matrix[i];
            nodes.push({ cells: rowData.matrix, rowproperties: rowData.rowproperties || {} });
            maxColCount = Math.max(maxColCount, rowData.matrix.length);
        }
    }

    // to maintain same column count
    nodes.map((row) => {
        let diffCount = maxColCount - row.length;
        for (var i = 0; i < diffCount; i++) {
            row.push({ type: "text", value: "text" });
        }
    });

    this.tableData = { properties: properties, nodes: nodes };
};

MultiContentTable.prototype.getOutlineMatrix = function () {
    const properties = this.getProperties();
    let rowMatrix = this.tableData.nodes.map((data) => {
        return { matrix: data.cells };
    });
    let data = this.getJSONData();

    return {
        subtype: "table",
        outlinetype: "table",
        properties: properties,
        matrix: rowMatrix,
        multicontent: true,
    };
};

MultiContentTable.prototype.updateElements = function () {
    this.eventManagerXY.clear();
    this.clear();
    this.recreateElementData();
    this.updateJSONData();
    this.updateEvents();
    this.callTableFillIfNeed?.();
};

MultiContentTable.prototype.createTable = function () {
    let contentTextColor = this.globalMoodData?.theme?.textcolormapping?.heading;
    if (contentTextColor) this.tableParent.style.setProperty("--contentCellText", contentTextColor);

    this.arrTableNode = [];
    let oldTable = this.tableParent.querySelector("table");
    if (oldTable) oldTable.parentElement.removeChild(oldTable);

    let btnOldRow = this.tableParent.querySelector(".btnAddRowParent");
    if (btnOldRow) btnOldRow.parentElement.removeChild(btnOldRow);

    let btnOldCol = this.tableParent.querySelector(".btnAddColParent");
    if (btnOldCol) btnOldCol.parentElement.removeChild(btnOldCol);

    let table = document.createElement("table");
    table.className = "clsTable";
    table.setAttribute("id", DiagramNodeUtils.uuidv4());
    table.setAttribute("name", "table");
    this.tableParent.appendChild(table);

    let btnAddRowParent = document.createElement("div");
    btnAddRowParent.className = "btnAddRowParent";
    this.tableParent.appendChild(btnAddRowParent);

    let btnAddRow = document.createElement("button");
    btnAddRow.className = "btnAddRow";
    btnAddRow.id = "btnAddRow";
    btnAddRow.textContent = "+";
    btnAddRowParent.appendChild(btnAddRow);

    let tableHead = document.createElement("thead");
    table.appendChild(tableHead);
    let headRow = document.createElement("tr");
    tableHead.appendChild(headRow);

    let tableBody = document.createElement("tbody");
    table.appendChild(tableBody);

    let btnAddColParent = document.createElement("div");
    btnAddColParent.className = "btnAddColParent";
    this.tableParent.appendChild(btnAddColParent);

    let btnAddCol = document.createElement("button");
    btnAddCol.className = "btnAddCol";
    btnAddCol.id = "btnAddCol";
    btnAddCol.textContent = "+";
    btnAddColParent.appendChild(btnAddCol);

    let oldwidthResizer = this.tableParent.querySelector("#widthResizer");
    if (oldwidthResizer) oldwidthResizer.parentElement.removeChild(oldwidthResizer);

    // let widthResizer = document.createElement("div");
    // widthResizer.className = "width-resizer";
    // widthResizer.id = "widthResizer";
    // widthResizer.textContent = "...";
    // widthResizer.setAttribute("data-name", "resizer");
    // widthResizer.setAttribute("data-type", "width");
    // this.tableParent.appendChild(widthResizer);

    let oldheightResizer = this.tableParent.querySelector("#heightResizer");
    if (oldheightResizer) oldheightResizer.parentElement.removeChild(oldheightResizer);

    // let heightResizer = document.createElement("div");
    // heightResizer.className = "height-resizer";
    // heightResizer.id = "heightResizer";
    // heightResizer.textContent = "...";
    // heightResizer.setAttribute("data-name", "resizer");
    // heightResizer.setAttribute("data-type", "height");
    // this.tableParent.appendChild(heightResizer);

    function defaultRowColumnCount(inst, defaultRow, defaultCol) {
        inst.initialRender = false;
        while (inst.tableData.nodes.length < defaultRow) {
            inst.tableData.nodes[inst.tableData.nodes.length] = [];
        }

        inst.tableData.nodes.forEach((row) => {
            while (row.length < defaultCol) {
                row.push(JSON.parse(JSON.stringify(inst.defaultCellData)));
            }
        });
    }

    this.setCellFormatData();

    this.rowCount = this.tableData.nodes.length;
    this.colCount = this.tableData.nodes[0].cells.length;

    for (var i = 0; i < this.colCount + 1; i++) {
        this.createColumnOperationCell(headRow, i);
    }

    for (var i = 0; i < this.rowCount; i++) {
        this.addRowOperation(i);
    }

    this.setCellClass();
    this.setSizeVariable();
};

MultiContentTable.prototype.addRow = function () {
    if (this.tableData.nodes.length >= this.maxRow) return;
    let index = this.tableData.nodes.length;
    this.insertRowAt(index, index - 1, true);
    this.updateTextNodes?.();
};

MultiContentTable.prototype.addColumn = function () {
    if (this.tableData.nodes[0].cells.length >= this.maxCol) return;
    let index = this.tableData.nodes[0].cells.length;
    const disableId = this.getDisableOption();
    let isLastColAddDisable = disableId.split(",").at(1) == this.arrTableNode[0].length - 1;
    if (isLastColAddDisable) index -= 1;
    this.insertColAt(index, index - 1, true);
    this.updateTextNodes?.();
};

MultiContentTable.prototype.addColumnOperation = function (i = 0, j = 0, row) {
    let cell = document.createElement("td");

    if (j == 0) {
        row.appendChild(this.createRowOperationCell(cell, i));
        return;
    }

    let index = `${i},${j - 1}`;
    cell.setAttribute("data-cell-index", index);
    cell.setAttribute("data-name", "datacell");
    cell.setAttribute("id", "datacell-" + index);

    let div = document.createElement("div");
    div.className = "td-container";
    div.setAttribute("data-cell-index", index);
    cell.appendChild(div);
    row.appendChild(cell);

    let nodeData = this.tableData.nodes[i].cells[j - 1] || this.getDefaultNodeData();
    let nodeInstace = new window[this.nodeProps.nodeclassName](div, this.tableData.properties, nodeData, this.eventManagerXY, index, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.tableParent, this);
    this.assignCallbacksToNode(nodeInstace);
    nodeInstace.initCreation();
    nodeInstace.updateNodeAttributes(i, j - 1);
    nodeInstace.nodeData = nodeInstace.getJSONData();

    if (this.tableParent.dataset.rowheader == "true" && i == 0) {
        cell.setAttribute("data-rowheader", "true");
        this.checkForLightText(div.firstElementChild, { rowheader: true }, "row");
    }
    if (this.tableParent.dataset.colheader == "true" && j - 1 == 0) {
        cell.setAttribute("data-colheader", "true");
        this.checkForLightText(div.firstElementChild, { colheader: true }, "col");
    }

    this.arrTableNode[i] ? this.arrTableNode[i].splice(j, 0, nodeInstace) : this.arrTableNode.push([nodeInstace]);
};

MultiContentTable.prototype.deletColumn = function (index) {
    if (this.arrTableNode[0].length <= 1) {
        this.appDispatcher.dispatch({ type: "ALERT_MESSAGE", title: "Invalid Data", message: "Last column can't be delete" });
        return;
    }
    this.tableData.nodes.map((row) => {
        row.cells.splice(index, 1);
    });
    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
    this.updateTextNodes?.();
};

MultiContentTable.prototype.deleteRow = function (index) {
    if (this.arrTableNode.length <= 1) {
        this.appDispatcher.dispatch({ type: "ALERT_MESSAGE", title: "Invalid Data", message: "Last row can't be delete" });
        return;
    }
    this.tableData.nodes.splice(index, 1);
    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
    this.updateTextNodes?.();
};

MultiContentTable.prototype.insertColAt = function (index, sourceIndex, isRegester = false) {
    if (!this.isWidthAvailable()) return;
    if (isRegester) this.registerOperation?.(this.slideID, "addcol", { data: this.tableData, target: "add-0" });
    this.tableData.nodes.forEach((row) => {
        row.cells.splice(index, 0, JSON.parse(JSON.stringify(row.cells[sourceIndex])));
    });
    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
    this.updateTextNodes?.();
};

MultiContentTable.prototype.insertRowAt = function (index, sourceIndex, isRegester = false) {
    if (!this.isHeightAvailable()) return;
    if (isRegester) this.registerOperation?.(this.slideID, "addcol", { data: this.tableData, target: "add-0" });
    this.tableData.nodes.splice(index, 0, JSON.parse(JSON.stringify(this.tableData.nodes[sourceIndex])));
    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
    this.updateTextNodes?.();
};

MultiContentTable.prototype.recreateElementData = function () {
    this.setMoodClassNames();
    this.setNodeProps(null);
    let tbody = this.tableParent.querySelector("tbody");
    let arrRows = Array.from(tbody.querySelectorAll("tr"));
    let properties = this.getProperties();
    this.arrTableNode = [];
    let nodesData = [];
    for (let i = 0; i < arrRows.length; i++) {
        let arrCells = arrRows[i].querySelectorAll("td");
        let arr = [];
        let node = [];
        for (let j = 1; j < arrCells.length; j++) {
            let index = `${i},${j - 1}`;
            let nodeItem = arrCells[j];
            let nodeInstace = new window[this.nodeProps.nodeclassName](nodeItem.firstElementChild, properties, null, this.eventManagerXY, index, nodeItem.getAttribute("data-parent-id"), this.objStyleData, this.appStaticURL, this.nodeProps, this.tableParent, this);
            nodeInstace.parentNode = nodeItem;
            nodeInstace.nodeGroup = nodeItem.querySelector("[name='nodeGroup']");
            this.assignCallbacksToNode(nodeInstace);
            nodeInstace.objData = nodeInstace.getJSONData();
            nodeInstace.nodeData = nodeInstace.objData;
            nodeInstace.updateNodeAttributes(i, j - 1);
            arr.push(nodeInstace);
            node.push(nodeInstace.nodeData);
        }
        this.arrTableNode.push(arr);
        nodesData.push({ cells: node, rowproperties: {} });
    }
    this.tableData = { properties: {}, nodes: nodesData };
    this.rowCount = this.tableData.nodes.length;
    this.colCount = this.tableData.nodes[0].cells.length;
    this.setSizeVariable();
    setTimeout(() => {
        this.updateJSONData();
    }, 500);
};

MultiContentTable.prototype.getJSONData = function (defaultproperties) {
    if (this.arrTableNode.length == 0) return this.tableData || { properties: this.getProperties(defaultproperties) };
    let arrNodeData = [];
    for (let i = 0; i < this.arrTableNode.length; i++) {
        let arrRow = [];
        for (let j = 0; j < this.arrTableNode[i].length; j++) {
            let nodeData = this.arrTableNode[i][j].getJSONData(this.tableParent);
            arrRow.push(nodeData);
            this.arrTableNode[i][j].nodeData = nodeData; // Added to store data in nodeinstance also
        }
        arrNodeData.push({ cells: arrRow, rowproperties: {} });
    }
    this.tableData = { properties: this.getProperties(defaultproperties), nodes: arrNodeData };
    return this.tableData;
};

MultiContentTable.prototype.textResize = function (targetid, size, objDetails) {
    let target = this.tableParent.querySelector("[name='" + objDetails.contenttype + "']");
    if (!target) target = this.tableParent.querySelector("[id*='" + objDetails.contenttype + "']");
    if (objDetails.contenttype == "numberNode") target = this.tableParent.querySelector("[name='numberNode']");

    if (target) {
        this.textResizeForTarget(target.getAttribute("name"), size);
    }
};

MultiContentTable.prototype.textResizeForTarget = function (targetId, size) {
    this.arrDiagramNode.forEach((element) => {
        let multiTextParent = element.parentNode.querySelector("[name='" + targetId + "']");
        if (!multiTextParent) return;
        TextHighLightUtils.removeFontClassName(multiTextParent, this.fontClassList);
        if (size.includes("auto")) multiTextParent.classList.add(multiTextParent.getAttribute("original-fontclass"));
        else multiTextParent.classList.add(size);
        multiTextParent.setAttribute("data-fontresize", size);
        element.updateOnFocusOut(multiTextParent);
    });
    this.tableData.properties.fontresize[targetId] = size;
    this.updateProperties(this.tableData.properties);
    this.tableParent.setAttribute("data-fontresize-" + targetId.toLowerCase(), size);
    this.updatePropsCallBack(targetId);
};

MultiContentTable.prototype.addSizeVariable = function (i, j, cell) {
    let width = cell.nodeData?.cellproperties?.width ? cell.nodeData.cellproperties.width + "px" : null;
    let cellContentWidth = width || this.tableParent.style.getPropertyValue("--width" + j) || this.defaultCellWidth;

    let height = cell.nodeData?.cellproperties?.height ? cell.nodeData.cellproperties.height + "px" : null;
    let cellContentHeight = height || this.tableParent.style.getPropertyValue("--height" + i) || this.defaultCellHeight;

    this.tableParent.style.setProperty("--width" + j, cellContentWidth);
    this.tableParent.style.setProperty("--height" + i, cellContentHeight);
    cell.nodeParent.style.width = `var(--width${j})`;
    cell.nodeParent.style.height = `var(--height${i})`;
};

MultiContentTable.prototype.getDisableOption = function () {
    switch (this.tableParent.dataset.name) {
        case "tbl-sty-a-54":
            return "0";
        case "tbl-sty-a-51":
            return "0,0";
        case "tbl-sty-a-52":
            return "0,0";
        case "tbl-sty-a-53":
            return "0,0";
        case "tbl-sty-a-55":
            return "0,0";
        case "tbl-sty-a-56":
            return "0,0";
        case "tbl-sty-a-58":
            return "0,0";
        case "tbl-sty-a-57":
            return "0," + String(this.arrTableNode[0].length - 1);
        default:
            return "0";
    }
};

MultiContentTable.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dictProps) {
    if (elTarget.id.includes("gridNode")) {
        let index = elTarget.dataset.index;
        if (index?.includes?.(",")) {
            let [row, col] = index.split(",");
            let nodeInstace = this.arrTableNode[row][col];
            let totalgrids = Number(nodeInstace?.gridInstance?.gridimages?.length) || 0;
            let gridIndex = Number(elTarget.dataset.imagegridIndex);

            if (gridIndex > 0 && totalgrids > 1) {
                //show previouse swap
                dictProps.swapprevious = { floaterproperty: "swapprevious", index: gridIndex };
            }
            if (gridIndex < totalgrids - 1) {
                //show nex swap
                dictProps.swapnext = { floaterproperty: "swapnext", index: gridIndex };
            }
        }
    }
    delete dictProps.fontsize;
};

MultiContentTable.prototype.getDefaultNodeData = function () {
    return { titleHolder: { type: "text", value: "", textproperties: {} } };
};

MultiContentTable.prototype.splitRowEqually = function () {
    let cellSpace = (this.tableParent.parentElement.clientWidth - this.optionOffset) / this.arrTableNode[0].length;
    this.arrTableNode[0].forEach((cell, i) => {
        this.tableParent.style.setProperty("--width" + i, cellSpace + "px");
    });
};

MultiContentTable.prototype.splitColEqually = function () {
    let cellSpace = (this.tableParent.parentElement.clientHeight - this.optionOffset) / this.arrTableNode.length;
    this.arrTableNode.forEach((cell, i) => {
        this.tableParent.style.setProperty("--height" + i, cellSpace + "px");
    });
};

MultiContentTable.prototype.updateColHighlight = function (colIndex) {
    let rowHeader = this.tableData?.properties?.rowheader || this.nodeProps?.rowheader || "false";
    this.tableData.nodes.forEach((node, i) => {
        if ((rowHeader == true || rowHeader == "true") && i == 0) return;
        let highlight = node.cells[colIndex].cellproperties.highlight || "";
        if (highlight == "") {
            highlight = "col";
            if (this.tableData.properties.colhighlightindex) this.tableData.properties.colhighlightindex.add(colIndex);
            else this.tableData.properties.colhighlightindex = [colIndex];
        } else if (highlight.includes("col")) highlight = highlight.replaceAll("col", "").replaceAll(",", "");
        else highlight = highlight + ",col";

        if (highlight == "") {
            delete node.cells[colIndex].cellproperties.highlight;
            delete this.tableData.properties.colhighlightindex?.remove?.(colIndex);
        } else node.cells[colIndex].cellproperties.highlight = highlight;
    });
    this.updateProperties(this.tableData.properties);
    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
};

MultiContentTable.prototype.updateRowHighlight = function (rowIndex) {
    let colHeader = this.tableData?.properties?.colheader || this.nodeProps?.colheader || "false";
    this.tableData.nodes?.[rowIndex]?.cells?.forEach((node, i) => {
        if ((colHeader == true || colHeader == "true") && i == 0) return;
        let highlight = node.cellproperties.highlight || "";
        if (highlight == "") {
            highlight = "row";
            if (this.tableData.properties.rowhighlightindex) this.tableData.properties.rowhighlightindex.add(rowIndex);
            else this.tableData.properties.rowhighlightindex = [rowIndex];
        } else if (highlight.includes("row")) highlight = highlight.replaceAll("row", "").replaceAll(",", "");
        else highlight = highlight + ",row";

        if (highlight == "") {
            delete node.cellproperties.highlight;
            delete this.tableData.properties.rowhighlightindex?.remove(rowIndex);
        } else node.cellproperties.highlight = highlight;
    });
    this.updateProperties(this.tableData.properties);
    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
};

MultiContentTable.prototype.changeContentType = function (valueObj, id, arrIndex) {
    let rowHeader = this.tableData?.properties?.rowheader || this.nodeProps?.rowheader || "false";
    let colHeader = this.tableData?.properties?.colheader || this.nodeProps?.colheader || "false";

    if (id.includes("colOption")) {
        this.arrTableNode.forEach((row, i) => {
            if ((rowHeader == true || rowHeader == "true" || this.tableData.properties.numbering) && i == 0) return;
            row[arrIndex[0]].changeContentType(valueObj);
        });
    } else {
        this.arrTableNode[arrIndex[0]].forEach((cell, i) => {
            if ((colHeader == true || colHeader == "true" || this.tableData.properties.numbering) && i == 0) return;
            cell.changeContentType(valueObj);
        });
    }
};

MultiContentTable.prototype.changeValueFormat = function (valueObj, id, arrIndex) {
    if (id.includes("colOption")) {
        this.arrTableNode.forEach((row, i) => {
            let cell = row[arrIndex[0]];
            let valueNode = cell.mainParent.querySelector("[data-valuetype]");
            if (valueNode) {
                valueObj.targetid = valueNode.firstElementChild.id;
                cell.updateValueFormat(valueObj);
            }
        });
    } else {
        this.arrTableNode[arrIndex[0]].forEach((cell, i) => {
            let valueNode = cell.mainParent.querySelector("[data-valuetype]");
            if (valueNode) {
                valueObj.targetid = valueNode.firstElementChild.id;
                cell.updateValueFormat(valueObj);
            }
        });
    }
};

MultiContentTable.prototype.updateTextNodes = function (index = 0) {
    this.arrTableNode[0]?.[0]?.updateOnFocusOut?.();
};

MultiContentTable.prototype.changeSecondaryType = function (valueObj, arrIndex) {
    let secondaryType = valueObj.property == "textlistbullet" ? "disc" : "decimal";
    secondaryType = valueObj.property == "textlistpara" ? "none" : secondaryType;
    secondaryType = valueObj.selected ? secondaryType : "none";
    this.arrTableNode[arrIndex[0]][arrIndex[1]].changeSecondaryType(secondaryType);
};

MultiContentTable.prototype.showHideOverlay = function (obj) {
    this.tableData.properties.isoverlay = obj.value;
    this.updateProperties(this.tableData.properties);
};

MultiContentTable.prototype.updateNumberStart = function (obj) {
    this.tableData.properties.sequencetextstart = obj.value;
    this.updateProperties(this.tableData.properties);
    this.arrTableNode.forEach((row) => {
        let node = row[0];
        if (node) {
            node.mainParent.innerHTML = "";
            node.properties = this.tableData.properties;
            node.initCreation();
        }
    });
};

MultiContentTable.prototype.igonreFirstRow = function (obj) {
    this.tableData.properties.ignorefirstrow = obj.value;
    this.updateProperties(this.tableData.properties);
    let node = this.arrTableNode[0]?.[0];
    if (node) node.mainParent.parentElement.style.visibility = obj.value ? `hidden` : `visible`;
    if (this.tableData.properties.numbering)
        this.arrTableNode.forEach((row) => {
            let node = row[0];
            if (node) {
                node.mainParent.innerHTML = "";
                node.properties = this.tableData.properties;
                node.initCreation();
            }
        });
};

MultiContentTable.prototype.setFontStyle = function (obj, index, id) {
    if (id.includes("colOption")) {
        this.arrTableNode.forEach((row, i) => {
            row[index[0]].setFontStyle(obj);
        });
    } else {
        this.arrTableNode[index[0]].forEach((cell, i) => {
            cell.setFontStyle(obj);
        });
    }
};

MultiContentTable.prototype.clear = function () {
    BaseTableDiagram.prototype.clear.call(this);
};

Array.prototype.remove = function (item) {
    let index = this.indexOf(item);
    if (index > -1) {
        this.splice(index, 1);
    }
};

Array.prototype.add = function (item) {
    if (!this.includes(item)) this.push(item);
};

"use strict";

function TableWithMergeOption(diagramParent, tableData, nodeProps = {}, moodData = {}) {
    BaseTableDiagram.call(this, diagramParent, tableData, nodeProps, moodData);
    this.defaultRow = 1;
    this.defaultCol = 1;
}

TableWithMergeOption.prototype = Object.create(BaseTableDiagram.prototype);
TableWithMergeOption.prototype.constructor = TableWithMergeOption;

TableWithMergeOption.prototype.createTable = function () {
    let contentTextColor = this.globalMoodData?.theme?.textcolormapping?.heading;
    if (contentTextColor) this.tableParent.style.setProperty("--contentCellText", contentTextColor);

    this.arrTableNode = [];
    let oldTable = this.tableParent.querySelector("table");
    if (oldTable) oldTable.parentElement.removeChild(oldTable);

    let btnOldRow = this.tableParent.querySelector(".btnAddRowParent");
    if (btnOldRow) btnOldRow.parentElement.removeChild(btnOldRow);

    let btnOldCol = this.tableParent.querySelector(".btnAddColParent");
    if (btnOldCol) btnOldCol.parentElement.removeChild(btnOldCol);

    let table = document.createElement("table");
    table.className = "clsTable";
    table.setAttribute("id", DiagramNodeUtils.uuidv4());
    table.setAttribute("name", "table");
    this.tableParent.appendChild(table);

    let btnAddRowParent = document.createElement("div");
    btnAddRowParent.className = "btnAddRowParent";
    this.tableParent.appendChild(btnAddRowParent);

    let btnAddRow = document.createElement("button");
    btnAddRow.className = "btnAddRow";
    btnAddRow.textContent = "+";
    btnAddRowParent.appendChild(btnAddRow);

    let tableHead = document.createElement("thead");
    table.appendChild(tableHead);
    let headRow = document.createElement("tr");
    tableHead.appendChild(headRow);

    let tableBody = document.createElement("tbody");
    table.appendChild(tableBody);

    let btnAddColParent = document.createElement("div");
    btnAddColParent.className = "btnAddColParent";
    this.tableParent.appendChild(btnAddColParent);

    let btnAddCol = document.createElement("button");
    btnAddCol.className = "btnAddCol";
    btnAddCol.textContent = "+";
    btnAddColParent.appendChild(btnAddCol);

    let oldwidthResizer = this.tableParent.querySelector("#widthResizer");
    if (oldwidthResizer) oldwidthResizer.parentElement.removeChild(oldwidthResizer);

    let widthResizer = document.createElement("div");
    widthResizer.className = "width-resizer";
    widthResizer.id = "widthResizer";
    widthResizer.textContent = "...";
    widthResizer.setAttribute("data-name", "resizer");
    widthResizer.setAttribute("data-type", "width");
    this.tableParent.appendChild(widthResizer);

    let oldheightResizer = this.tableParent.querySelector("#heightResizer");
    if (oldheightResizer) oldheightResizer.parentElement.removeChild(oldheightResizer);

    let heightResizer = document.createElement("div");
    heightResizer.className = "height-resizer";
    heightResizer.id = "heightResizer";
    heightResizer.textContent = "...";
    heightResizer.setAttribute("data-name", "resizer");
    heightResizer.setAttribute("data-type", "height");
    this.tableParent.appendChild(heightResizer);

    function defaultRowColumnCount(inst, defaultRow, defaultCol) {
        inst.initialRender = false;
        while (inst.tableData.nodes.length < defaultRow) {
            inst.tableData.nodes[inst.tableData.nodes.length] = [];
        }

        inst.tableData.nodes.forEach((row) => {
            while (row.length < defaultCol) {
                row.push(JSON.parse(JSON.stringify(inst.defaultCellData)));
            }
        });
    }

    if (!this.tableParent.dataset.hasOwnProperty("tableAltered")) defaultRowColumnCount(this, this.defaultRow, this.defaultCol);
    this.setCellFormatData();

    this.rowCount = this.tableData.nodes.length;
    this.colCount = this.tableData.nodes[0].length;

    for (var i = 0; i < this.colCount + 1; i++) {
        this.createColumnOperationCell(headRow, i);
    }

    for (var i = 0; i < this.rowCount; i++) {
        this.addRowOperation(i);
    }

    this.setCellClass();
    this.setSizeVariable();
    if (!this.tableData.nodes?.[0]?.[0]?.contentsize) this.resizeOption({ value: "fill" });
};

TableWithMergeOption.prototype.initDiagramCreationOutline = function (outlineData, data) {
    let nodes = [];
    let properties = data.properties || {};
    let maxColCount = 0;

    if (outlineData && outlineData.matrix) {
        for (let i = 0; i < outlineData.matrix.length; i++) {
            let rowData = outlineData.matrix[i];
            nodes.push(rowData.matrix);
            maxColCount = Math.max(maxColCount, rowData.matrix.length);
        }
    }

    this.tableData = { properties: properties, nodes: nodes };
};

TableWithMergeOption.prototype.addRowOperation = function (i = 0) {
    let tableBody = this.tableParent.querySelector("tbody");
    let row = document.createElement("tr");
    row.setAttribute("data-row-index", i);
    let colCount = this.tableData.nodes[i].length;
    for (var j = 0; j < colCount + 1; j++) {
        this.addColumnOperation(i, j, row);
    }
    tableBody.appendChild(row);
};

TableWithMergeOption.prototype.updateMerge = function (obj, [rowIndex, colIndex]) {
    rowIndex = Number(rowIndex);
    colIndex = Number(colIndex);
    let nodeData = this.tableData.nodes[rowIndex][colIndex];
    switch (obj.property) {
        case "mergenext":
            let colspan = Number(nodeData.colspan) || 1;
            let rowspan = Number(nodeData.rowspan) || 1;
            let nextColData = this.tableData.nodes[rowIndex]?.[colIndex + 1];
            if (nextColData) {
                let nextColspan = Number(nextColData.colspan) || 1;
                nodeData.colspan = colspan + nextColspan;
                this.tableData.nodes[rowIndex].splice(colIndex + 1, 1);
                for (let i = 1; i < rowspan; i++) {
                    this.tableData.nodes[rowIndex + i].splice(colIndex, 1);
                }
                this.createSetupTable();
            }
            break;
        case "mergebottom": {
            let colspan = Number(nodeData.colspan) || 1;
            let rowspan = Number(nodeData.rowspan) || 1;
            
            let bottomRow = this.tableData.nodes[rowIndex + rowspan];
            let bottomColData = bottomRow?.[colIndex];

            if (bottomColData) {
                let bottomColspan = Number(bottomColData.colspan) || 1;
                let bottomRowspan = Number(bottomColData.rowspan) || 1;
                bottomRow.splice(colIndex, colspan);
                nodeData.rowspan = rowspan + bottomRowspan;
                // if (bottomColspan > colspan) {
                //     this.tableData.nodes[rowIndex].splice(colIndex + 1, bottomColspan - colspan);
                //     nodeData.colspan = colspan + (bottomColspan - colspan);
                // }
                this.createSetupTable();
            }
            
            break;
        }
        default:
            break;
    }
};

TableWithMergeOption.prototype.addColumnOperation = function (i = 0, j = 0, row) {
    let cell = document.createElement("td");

    if (j == 0) {
        row.appendChild(this.createRowOperationCell(cell, i));
        return;
    }

    cell.setAttribute("data-cell-index", `${i},${j - 1}`);
    cell.setAttribute("data-name", "datacell");
    cell.setAttribute("id", "datacell-" + `${i},${j - 1}`);

    let div = document.createElement("div");
    div.setAttribute("data-cell-index", `${i},${j - 1}`);
    cell.appendChild(div);

    let nodeData = this.tableData.nodes[i][j - 1];
    if (nodeData.colspan) {
        cell.setAttribute("colspan", nodeData.colspan);
    }
    if (nodeData.rowspan) {
        cell.setAttribute("rowspan", nodeData.rowspan);
    }

    let nodeInstace = new window[this.nodeProps.nodeclassName](nodeData, div, [i, j - 1], this);
    nodeInstace.diagramParent = this.tableParent;
    this.assignCallbacksToNode(nodeInstace);
    nodeInstace.initCreation();

    this.arrTableNode[i] ? this.arrTableNode[i].splice(j, 0, nodeInstace) : this.arrTableNode.push([nodeInstace]);

    row.appendChild(cell);
};

function PresetTable(diagramParent, tableData, nodeProps = {}, moodData = {}) {
    MultiContentTable.call(this, diagramParent, tableData, nodeProps, moodData);
    this.optionOffset = 115;
    this.updateButtonFrame = this.updateButtonFrameInit.call(this);
    this.imageDoubleClickHandler = this.imageDoubleClickHandler.bind(this);
}

PresetTable.prototype = Object.create(MultiContentTable.prototype);
PresetTable.prototype.constructor = PresetTable;

PresetTable.prototype.createTable = function () {
    let contentTextColor = this.globalMoodData?.theme?.textcolormapping?.heading;
    if (contentTextColor) this.tableParent.style.setProperty("--contentCellText", contentTextColor);

    this.arrTableNode = [];
    let oldTable = this.tableParent.querySelector("table");
    if (oldTable) oldTable.parentElement.removeChild(oldTable);

    let btnOldRow = this.tableParent.querySelector(".btnAddRowParent");
    if (btnOldRow) btnOldRow.parentElement.removeChild(btnOldRow);

    let btnOldCol = this.tableParent.querySelector(".btnAddColParent");
    if (btnOldCol) btnOldCol.parentElement.removeChild(btnOldCol);

    let table = document.createElement("table");
    table.className = "clsTable";
    table.setAttribute("id", DiagramNodeUtils.uuidv4());
    table.setAttribute("name", "table");
    this.tableParent.appendChild(table);

    let btnAddRowParent = document.createElement("div");
    btnAddRowParent.className = "btnAddRowParent";
    this.tableParent.appendChild(btnAddRowParent);

    let btnAddRow = document.createElement("button");
    btnAddRow.className = "btnAddRow";
    btnAddRow.id = "btnAddRow";
    btnAddRow.dataset.type = "btnAddRow";
    btnAddRow.textContent = "+";
    btnAddRowParent.appendChild(btnAddRow);

    let tableHead = document.createElement("thead");
    table.appendChild(tableHead);
    let headRow = document.createElement("tr");
    tableHead.appendChild(headRow);

    let tableBody = document.createElement("tbody");
    table.appendChild(tableBody);

    let btnAddColParent = document.createElement("div");
    btnAddColParent.className = "btnAddColParent";
    this.tableParent.appendChild(btnAddColParent);

    let btnAddCol = document.createElement("button");
    btnAddCol.className = "btnAddCol";
    btnAddCol.id = "btnAddCol";
    btnAddCol.dataset.type = "btnAddCol";
    btnAddCol.textContent = "+";
    btnAddColParent.appendChild(btnAddCol);

    let oldwidthResizer = this.tableParent.querySelector("#widthResizer");
    if (oldwidthResizer) oldwidthResizer.parentElement.removeChild(oldwidthResizer);

    // let widthResizer = document.createElement("div");
    // widthResizer.className = "width-resizer";
    // widthResizer.id = "widthResizer";
    // widthResizer.textContent = "...";
    // widthResizer.setAttribute("data-name", "resizer");
    // widthResizer.setAttribute("data-type", "width");
    // this.tableParent.appendChild(widthResizer);

    let oldheightResizer = this.tableParent.querySelector("#heightResizer");
    if (oldheightResizer) oldheightResizer.parentElement.removeChild(oldheightResizer);

    // let heightResizer = document.createElement("div");
    // heightResizer.className = "height-resizer";
    // heightResizer.id = "heightResizer";
    // heightResizer.textContent = "...";
    // heightResizer.setAttribute("data-name", "resizer");
    // heightResizer.setAttribute("data-type", "height");
    // this.tableParent.appendChild(heightResizer);

    this.updateButtonFrame = this.updateButtonFrameInit.call(this);
    this.setCellFormatData();

    this.rowCount = this.tableData.nodes.length;
    this.colCount = this.tableData.nodes[0].cells.length;

    let seqClass = this.tableData.nodes?.[0]?.cells?.[0]?.nodeStyleClass || "";
    if (this.tableData.properties.numbering == true && seqClass != "clsPlainNumbering") {
        this.tableData.nodes.forEach((row) => {
            row.cells.splice(0, 0, this.defaultNumberData());
        });
        this.colCount++;
    }

    for (var i = 0; i < this.colCount + 1; i++) {
        this.createColumnOperationCell(headRow, i);
    }

    for (var i = 0; i < this.rowCount; i++) {
        this.addRowOperation(i);
    }

    this.getJSONData();
    this.setCellClass();
    this.setSizeVariable();
    this.callTableFillIfNeed();
    this.setScrollVariableIfNeed();
};

PresetTable.prototype.updateElements = function () {
    if (this.appmode.toLowerCase() == "present") this.optionOffset = 60;
    MultiContentTable.prototype.updateElements.call(this);
};

PresetTable.prototype.updateEvents = function () {
    if (this.observer) this.observer.disconnect();
    this.eventManagerXY.clear();
    if (this.appmode.toLowerCase() == "present") return;

    for (let j = 0; j < this.arrTableNode.length; j++) {
        let row = this.arrTableNode[j];
        for (let i = 0; i < row.length; i++) {
            let node = row[i];
            let nodeParent = row[i].nodeParent;
            let arrChildNodes = Array.from(nodeParent.querySelectorAll("[data-default-event='true']"));

            node.observer.disconnect();
            node.observer = new MutationObserver(node.mutationCallBack);
            node.observer.mytargets = [];

            for (let k = 0; k < arrChildNodes.length; k++) {
                this.eventManagerXY.addEvent(arrChildNodes[k], "focusout", this.defaultFoucsOut);
                this.eventManagerXY.addEvent(arrChildNodes[k], "focusout", node.onFocusOut);
                this.eventManagerXY.addEvent(arrChildNodes[k], "focusin", this.defaultFoucsIn);
                this.eventManagerXY.addEvent(arrChildNodes[k], "paste", this.diagramPasteHandler);

                if (arrChildNodes[k].getAttribute("data-observer") && arrChildNodes[k].getAttribute("data-observer") == "true") {
                    node.observer.observe(arrChildNodes[k], { childList: true });
                    node.observer.mytargets.push(arrChildNodes[k]);
                }
            }

            // For Text Highlight
            let arrHighLightNodes = nodeParent.querySelectorAll("[data-highlight-event='true']");
            for (let j = 0; j < arrHighLightNodes.length; j++) {
                this.eventManagerXY.addEvent(arrHighLightNodes[j], "mouseup", this.textHighlightMouseUpEvent);
            }

            let checklistNodes = nodeParent.querySelectorAll("[data-checkbox-event='true']");
            for (let j = 0; j < checklistNodes.length; j++) {
                this.eventManagerXY.addEvent(checklistNodes[j], "mousedown", this.defaultCheckBoxEvent);
            }

            let microchartNode = nodeParent.querySelectorAll("[data-id='microchartNode']");
            if (microchartNode && microchartNode.length > 0) {
                microchartNode.forEach((element) => {
                    this.eventManagerXY.addEvent(element, "focusout", node.microChartFoucsOut);
                    this.eventManagerXY.addEvent(element, "focusin", node.microChartFoucsIn);
                });
            }

            let microchartNodeCircle = nodeParent.querySelectorAll("[id*='clsCircleBG']");
            if (microchartNodeCircle && microchartNodeCircle.length > 0 && this.nodeProps?.microStyle && this.nodeProps?.microStyle == "clsRatingMicro") {
                microchartNodeCircle.forEach((element) => {
                    this.eventManagerXY.addEvent(element, "click", node.microChartClickEvent);
                });
            }

            // For Image Node
            let allImgNodes = nodeParent.querySelectorAll("img[data-id='imageNode'],img[data-id='logoNode']");

            allImgNodes.forEach((element) => {
                let isLogoList = element.parentElement.dataset.componentType && element.parentElement.dataset.componentType == "grid";
                if (!isLogoList) this.eventManagerXY.addEvent(element.parentElement, "dblclick", this.imageDoubleClickHandler);
            });

            node.addMicroChartEventIfneed?.(this.eventManagerXY);

            let arrPriorityNodeHolder = nodeParent.querySelectorAll("[id*='priorityNodeHolder']");
            arrPriorityNodeHolder?.forEach((element) => {
                this.eventManagerXY.addEvent(element, "click", node.priorityClickEvent);
            });
        }
    }

    let arrColOpBtn = this.tableParent.querySelectorAll("[data-name='coloperation']");
    for (let i = 0; i < arrColOpBtn.length; i++) {
        this.eventManagerXY.addEvent(
            arrColOpBtn[i],
            "click",
            function (e) {
                this.deletColumn(e.target.dataset.index - 1);
            }.bind(this)
        );
    }

    let arrRowOpBtn = this.tableParent.querySelectorAll("[data-name='rowoperation']");
    for (let i = 0; i < arrRowOpBtn.length; i++) {
        this.eventManagerXY.addEvent(
            arrRowOpBtn[i],
            "click",
            function (e) {
                this.deleteRow(e.target.dataset.index);
            }.bind(this)
        );
    }

    let table = this.tableParent.querySelector("[name='table']");
    this.observer = new ResizeObserver((enter) => {
        let rect = enter[0].target == table ? enter[0].contentRect : { width: table.clientWidth, height: table.clientHeight };
        setTimeout(() => {
            this.setScrollVariableIfNeed(rect);
        }, 0);
    });
    this.observer.observe(table);
    this.observer.observe(this.tableParent);

    //update callback listeners
    if (this.focusoutTextEvent) {
        this.addListener("focusout", this.focusoutTextEvent);
    }
    if (this.doubleclickEvent) {
        this.addListener("dblclick", this.doubleclickEvent);
    }
    if (this.mousedownTextEvent) {
        this.addListener("mousedown", this.mousedownTextEvent);
    }
    if (this.mouseupSelectionEvent) {
        this.addListener("mouseup", this.mouseupSelectionEvent);
    }
    if (this.keyupSelectionEvent) {
        this.addListener("keyup", this.keyupSelectionEvent);
    }
    if (this.keypressEvent) {
        this.addListener("keypress", this.keypressEvent);
    }

    this.eventManagerXY.addEvent(this.tableParent, "mousedown", this.setUpResizeListner.bind(this));
};

PresetTable.prototype.updateButtonFrameInit = function () {
    let widthResizer = this.tableParent?.querySelector("#widthResizer");
    let heightResizer = this.tableParent?.querySelector("#heightResizer");
    let btnAddColumn = this.tableParent?.querySelector(".btnAddCol");
    let btnAddRow = this.tableParent?.querySelector(".btnAddRow");
    let table = this.tableParent?.querySelector("[name='table']");

    let updateFunction = function (rect) {
        btnAddRow.parentElement.style.top = table.offsetTop + rect.height + "px";
        btnAddRow.parentElement.style.left = table.offsetLeft + "px";

        btnAddColumn.parentElement.style.top = table.offsetTop + "px";
        btnAddColumn.parentElement.style.left = table.offsetLeft + rect.width + "px";

        // widthResizer.style.left = table.offsetLeft + rect.width + "px";
        // heightResizer.style.top = table.offsetTop + rect.height + "px";
    };
    return btnAddColumn ? updateFunction : null;
};

PresetTable.prototype.addSizeVariable = function (i, j, cell) {};

PresetTable.prototype.setUpResizeListner = function (event) {
    let target = event.target;
    let resizer = target.dataset?.name || "";
    if (resizer != "resizer") return;
    let index = parseInt(target.dataset.index);
    let type = target.dataset.type;
    var dataNode = null;
    var contentNode = null;
    var initialWidth = 0;
    var initialHeight = 0;

    if (!isNaN(index)) {
        dataNode = type == "col" ? this.arrTableNode[0][index - 1] : this.arrTableNode[index][0];
        contentNode = dataNode.nodeParent;
        initialWidth = contentNode.clientWidth;
        initialHeight = contentNode.clientHeight;
    }

    let tableParent = this.tableParent;
    let table = this.tableParent.querySelector("[name='table'");
    let tableWidth = table.clientWidth;
    let tableHeight = table.clientHeight;

    let initialX = event.clientX;
    let initialY = event.clientY;

    let arrWidth = this.arrTableNode[0].map((cell) => cell.nodeParent.clientWidth);
    let arrHeight = this.arrTableNode.map((row) => row[0].nodeParent.clientHeight);

    pauseEvent(event);

    let mousemove = (event) => {
        let diffX = (event.clientX - initialX) / this.slideScale;
        let diffY = (event.clientY - initialY) / this.slideScale;
        let availableWidth = tableParent.clientWidth - this.optionOffset - table.clientWidth;
        let availableHeight = tableParent.clientHeight - this.optionOffset - table.clientHeight;

        if (type == "col") {
            tableParent.style.setProperty("--width" + (index - 1), Math.max(initialWidth + diffX, 50) + "px");
        } else if (type == "row") {
            tableParent.style.setProperty("--height" + index, initialHeight + diffY + "px");
        } else if (type == "width") {
            this.arrTableNode[0].map((cell, i, arr) => {
                this.tableParent.style.setProperty("--width" + i, Math.max(arrWidth[i] + diffX / (arr.length / 2), 50) + "px");
            });
        } else if (type == "height") {
            this.arrTableNode.map((cell, i, arr) => {
                this.tableParent.style.setProperty("--height" + i, arrHeight[i] + diffY / (arr.length / 2) + "px");
            });
        }
    };

    let mouseup = (event) => {
        this.updatePropsCallBack(event.target.id);
        clear();
    };

    function pauseEvent(e) {
        if (e.stopPropagation) e.stopPropagation();
        if (e.preventDefault) e.preventDefault();
        e.cancelBubble = true;
        e.returnValue = false;
        return false;
    }

    function clear() {
        window.removeEventListener("mousemove", mousemove);
        window.removeEventListener("mouseup", mouseup);
    }

    window.addEventListener("mousemove", mousemove);
    window.addEventListener("mouseup", mouseup);
};

PresetTable.prototype.addRow = function (obj) {
    let newRow = new Array(this.colCount).fill(JSON.parse(JSON.stringify(obj.data)));
    this.tableData.nodes.splice(this.tableData.nodes.length, 0, { cells: newRow, rowproperties: {} });
    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
    this.callTableFillIfNeed();
};

PresetTable.prototype.addColumn = function (obj) {
    this.tableData.nodes.forEach((row) => {
        row.cells.splice(row.cells.length, 0, JSON.parse(JSON.stringify(obj.data)));
    });
    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
    this.callTableFillIfNeed();
};

PresetTable.prototype.insertColAt = function (index, sourceIndex, isRegester = false) {
    let defaultData = defaultNodeData();
    this.tableData.nodes.forEach((row) => {
        row.cells.splice(index, 0, JSON.parse(JSON.stringify(defaultData)));
    });
    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
};

PresetTable.prototype.insertRowAt = function (index, sourceIndex, isRegester = false) {
    let defaultData = defaultNodeData();
    let newRow = new Array(this.colCount).fill(JSON.parse(JSON.stringify(defaultData)));
    this.tableData.nodes.splice(index, 0, { cells: newRow, rowproperties: {} });
    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
};

PresetTable.prototype.copy = function (obj) {
    let isCol = obj.property.includes("COL");
    let index = isCol ? this.colCount : this.rowCount;
    let sourceIndex = isCol ? index - 1 : index - 1;
    if (isCol) {
        this.tableData.nodes.forEach((row) => {
            row.cells.splice(index, 0, JSON.parse(JSON.stringify(row.cells[sourceIndex])));
        });
        this.tableParent.setAttribute("data-table-Altered", "");
        this.createSetupTable();
    } else {
        this.tableData.nodes.splice(index, 0, JSON.parse(JSON.stringify(this.tableData.nodes[sourceIndex])));
        this.tableParent.setAttribute("data-table-Altered", "");
        this.createSetupTable();
    }
    this.callTableFillIfNeed();
};

PresetTable.prototype.addColWithContent = function (obj) {
    this.copy({ property: "COL" });
    this.changeContentType(obj, "colOption", [this.colCount - 1]);
};

PresetTable.prototype.addRowWithContent = function (obj) {
    this.copy({ property: "ROW" });
    this.changeContentType(obj, "rowOption", [this.rowCount - 1]);
};

PresetTable.prototype.updateHeader = function (obj) {
    let properties = this.tableData?.properties || {};
    if (obj.property == "col header") {
        this.tableParent.dataset.colheader = obj.value;
        properties.colheader = obj.value;
        this.arrTableNode.forEach((row, i) => {
            let td = row[0].mainParent.parentElement;
            td.dataset.colheader = obj.value;
            this.checkForLightText(row[0].nodeParent.firstElementChild, properties, "col");
        });
    } else if (obj.property == "row header") {
        this.tableParent.dataset.rowheader = obj.value;
        properties.rowheader = obj.value;
        this.arrTableNode[0].forEach((cell, i) => {
            let td = cell.mainParent.parentElement;
            td.dataset.rowheader = obj.value;
            this.checkForLightText(cell.nodeParent.firstElementChild, properties, "row");
        });
    }

    this.updateProperties(properties);
};

PresetTable.prototype.updateNumbering = function (obj) {
    if (this.tableData.properties.numbering == true && obj.value == true) return;

    this.tableData.properties.numbering = obj.value;
    this.tableParent.dataset.numbering = obj.value;

    let seqHolder = this.arrTableNode[0]?.[0]?.mainParent?.querySelector("[name='seqTitleHolder']") || null;

    if ((obj.value == true || obj.value == "true") && !seqHolder) {
        this.tableData.nodes.forEach((row) => {
            row.cells.splice(0, 0, this.defaultNumberData());
        });
    } else if (seqHolder) {
        this.tableData.nodes.forEach((row) => {
            row.cells.splice(0, 1);
        });
    } else return;

    this.tableParent.setAttribute("data-table-Altered", "");
    this.createSetupTable();
};

PresetTable.prototype.defaultNumberData = function () {
    return {
        contentNode: { subNodes: { seqTitleHolder: { type: "sequence", contenttype: "sequence" } } },
        cellproperties: { width: 70, height: 120 },
        nodeStyleClass: "clsPlainNumbering",
    };
};

PresetTable.prototype.textStyleOperation = function (obj, arrIndex) {
    let isCol = obj.targetid?.includes("col");
    if (isCol) {
        this.tableData.nodes.forEach((row) => {
            console.log(row.cells[arrIndex]);
        });
    } else {
    }
};

PresetTable.prototype.fillAuto = function (obj, setwidth = true, setheight = true) {
    this.arrTableNode.forEach((row, i) => {
        if (setheight) this.tableParent.style.setProperty("--height" + i, "auto");
        row.forEach((cell, j) => {
            if (setwidth) this.tableParent.style.setProperty("--width" + j, "auto");
            cell.autoDimension(setwidth, setheight);
        });
    });
};

//fill table to parent size if table size less than parent size or it find the bigger cell and apply the size to all cell
PresetTable.prototype.fillTable = function (obj) {
    let curFill = this.tableParent.dataset.filltype || "auto";
    this.autoFill();
    this.fillTableWidth(false);
    this.fillTableHeight(false);
};

//fill table to parent size if table size less than parent size in ratio
PresetTable.prototype.fillTableRatio = function (obj) {
    this.fillAuto();
    this.fillTableWidthRatio(false);
    this.fillTableHeightRatio(false);
};

//Set auto to cell size
PresetTable.prototype.autoFill = function (setWidth = true, setHeight = true) {
    this.arrTableNode.forEach((row, i) => {
        if (setHeight) this.tableParent.style.setProperty("--height" + i, "auto");
        row.forEach((cell, j) => {
            if (setWidth) this.tableParent.style.setProperty("--width" + j, "auto");
            cell.setAutoSize(setWidth, setHeight); //set auto to min width/height
        });
    });
};

//Iterate cell to find max-width and apply it to all cell width (like splity width equally)
PresetTable.prototype.fillTableWidth = function (isAutoFill = true) {
    if (isAutoFill) this.autoFill(true, false);
    let { cellWidth, cellHeight } = this.getFillSizeForCell();
    let { maxWidth } = this.getMaxCellSize(cellWidth, cellHeight);
    this.arrTableNode[0].forEach((node, i) => {
        this.tableParent.style.setProperty("--width" + i, maxWidth + "px");
    });
    this.setScrollVariableIfNeed();
};

//Iterate cell to find max-height and apply it to all cell height (like split height equally)
PresetTable.prototype.fillTableHeight = function (isAutoFill = true) {
    if (isAutoFill) this.autoFill(false, true);
    let { cellWidth, cellHeight } = this.getFillSizeForCell();
    let { maxHeight } = this.getMaxCellSize(cellWidth, cellHeight);
    this.arrTableNode.forEach((node, i) => {
        this.tableParent.style.setProperty("--height" + i, maxHeight + "px");
    });
    this.setScrollVariableIfNeed();
};

//Iterate cell to find width and apply it to all cell width (like split height with ratio)
PresetTable.prototype.fillTableWidthRatio = function (isAutoFill = true) {
    if (isAutoFill) this.fillAuto(null, true, false);
    if (this.tableParent.clientWidth > this.tableParent.parentElement.clientWidth - this.optionOffset) return;
    let arrRatio = this.arrTableNode[0].map((cell) => {
        let nodeParent = cell.nodeParent.parentElement;
        return nodeParent.offsetWidth / this.tableParent.clientWidth;
    });

    arrRatio.forEach((ratio, i) => {
        this.tableParent.style.setProperty("--width" + i + "", (this.tableParent.parentElement.clientWidth - this.optionOffset / 2) * ratio + "px");
    });
    this.setScrollVariableIfNeed();
};

//Iterate cell to find height and apply it to all cell height (like split height with ratio)
PresetTable.prototype.fillTableHeightRatio = function (isAutoFill = true) {
    if (isAutoFill) this.fillAuto(null, false, true);
    if (this.tableParent.clientHeight > this.tableParent.parentElement.clientHeight - this.optionOffset) return;
    let arrRatio = this.arrTableNode.map((row) => {
        let nodeParent = row[0].nodeParent.parentElement;
        return nodeParent.offsetHeight / this.tableParent.clientHeight;
    });

    arrRatio.forEach((ratio, i) => {
        this.tableParent.style.setProperty("--height" + i + "", (this.tableParent.parentElement.clientHeight - this.optionOffset / 2) * ratio + "px");
    });

    this.setScrollVariableIfNeed();
};

PresetTable.prototype.callTableFillIfNeed = function () {
    // if (this.appmode == "PRESENT") return;
    switch (this.tableData.properties.tableresize) {
        case "auto":
            this.fillAuto();
            break;
        case "fill":
            this.fillTable();
            break;
        case "aspect-fill":
            this.fillTableRatio();
            break;
        default:
            break;
    }
};

PresetTable.prototype.getMaxCellSize = function (maxWidth = 0, maxHeight = 0) {
    this.arrTableNode.forEach((node) => {
        node.forEach((cell) => {
            let nodeParent = cell.nodeParent.firstElementChild;
            maxWidth = Math.max(maxWidth, nodeParent.clientWidth);
            maxHeight = Math.max(maxHeight, nodeParent.clientHeight);
        });
    });

    return { maxWidth, maxHeight };
};

PresetTable.prototype.getFillSizeForCell = function () {
    let elementDiv = this.tableParent.parentElement;
    let cellWidth = (elementDiv.clientWidth - this.optionOffset) / this.arrTableNode[0].length;
    let cellHeight = (elementDiv.clientHeight - this.optionOffset) / this.arrTableNode.length;
    return { cellWidth, cellHeight };
};

PresetTable.prototype.getRowMaxHeight = function () {};

PresetTable.prototype.getRowMaxHeight = function () {};

PresetTable.prototype.getOutlineMatrix = function () {
    const properties = this.getProperties();
    let rowMatrix = this.tableData.nodes.map((data) => {
        return { matrix: data.cells };
    });

    let headerColumnMatrix;
    let headerRowMatrix;
    if (this.tableData.properties.rowheader) {
        let copyMatrix = JSON.parse(JSON.stringify(rowMatrix));
        headerColumnMatrix = copyMatrix.splice(0, 1);
    }
    if (this.tableData.properties.colheader) {
        let copyMatrix = JSON.parse(JSON.stringify(rowMatrix));
        headerRowMatrix = copyMatrix.map((row) => row.matrix.splice(0, 1)[0]);
    }

    return {
        subtype: "table",
        outlinetype: "table",
        properties: properties,
        matrix: rowMatrix,
        ...(headerColumnMatrix && { headercolumnmatrix: headerColumnMatrix }),
        ...(headerRowMatrix && { headerrowmatrix: { matrix: headerRowMatrix } }),
        multicontent: true,
    };
};

PresetTable.prototype.initDiagramCreationOutline = function (outlineData, data) {
    let nodes = [];
    let properties = data.properties || {};
    properties.isoverlay = this.globalMoodData.imageoverlayproperties?.enable;
    properties.isoverlaysupport = data.hasOwnProperty("isoverlaysupport") ? data.isoverlaysupport : this.globalMoodData.imageoverlayproperties?.support;

    this.updateProperties(properties);
    let maxColCount = 0;

    if (outlineData && outlineData.matrix) {
        for (let i = 0; i < outlineData.matrix.length; i++) {
            let rowData = outlineData.matrix[i];
            for (let j = 0; j < rowData.matrix.length; j++) {
                let cellData = rowData.matrix[j];
                if (cellData.assetText?.primary && cellData.value != "") {
                    let titleHolder = DiagramUtils.getChildObjectByName(cellData, "titleHolder");
                    if (titleHolder) {
                        titleHolder.value = cellData.tempText?.primary || cellData.value;
                        cellData.value = "";
                        delete cellData.tempText?.primary;
                    }
                }
                if (cellData.assetText?.secondary && cellData.value != "") {
                    let subTitleHolder = DiagramUtils.getChildObjectByName(cellData, "subTitleHolder");
                    if (subTitleHolder) {
                        subTitleHolder.items[0].value = cellData.tempText?.secondary || cellData.value;
                        cellData.value = "";
                        delete cellData.tempText?.secondary;
                    }
                }
            }
            nodes.push({ cells: rowData.matrix, rowproperties: rowData.rowproperties || {} });
            maxColCount = Math.max(maxColCount, rowData.matrix.length);
        }
    }

    // let rowHeader = outlineData.headercolumnmatrix?.matrix || null;
    // if (rowHeader) {
    //     nodes.splice(0, 0, { cells: rowHeader, rowproperties: {} });
    //     this.updateHeader({ property: "row header", value: true });
    // }

    // let colHeader = outlineData.headerrowmatrix?.matrix || null;
    // if (colHeader) {
    //     colHeader.forEach((cell, i) => {
    //         nodes[i].cells.splice(0, 0, cell);
    //     });
    //     this.updateHeader({ property: "col header", value: true });
    // }

    // to maintain same column count
    nodes.map((row) => {
        let diffCount = maxColCount - row.length;
        for (var i = 0; i < diffCount; i++) {
            row.push({ type: "text", value: "text" });
        }
    });

    this.tableData = { properties: properties, nodes: nodes };
};

PresetTable.prototype.setScrollVariableIfNeed = function (rect) {
    let tx = this.tableParent.offsetLeft;
    let ty = this.tableParent.offsetTop;
    let tw = this.tableParent.clientWidth;
    let th = this.tableParent.clientHeight;
    let tableRect = { x: tx, y: ty, width: tw, height: th, left: tx, top: ty, right: tx + tw, bottom: ty + th };
    rect = rect || tableRect;
    this.updateButtonFrame?.(rect);
    let elementDiv = this.tableParent.parentElement;
    elementDiv.dataset.scrollEnableH = false;
    elementDiv.dataset.scrollEnableV = false;
    elementDiv.dataset.scrollEnableH = elementDiv.clientWidth < elementDiv.scrollWidth - 3;
    elementDiv.dataset.scrollEnableV = elementDiv.clientHeight < elementDiv.scrollHeight - 3;
    this.updateButtonFrame?.(rect);
};

PresetTable.prototype.changeNodeAlign = function (obj, arrIndex) {
    let isCol = obj.targetid?.includes("col");
    if (isCol) {
        this.arrTableNode.forEach((row) => {
            row[arrIndex].changeNodeAlign(obj);
        });
    } else {
        this.arrTableNode[arrIndex].forEach((cell) => {
            cell.changeNodeAlign(obj);
        });
    }
};

PresetTable.prototype.defaultFoucsOut = function (event) {
    let typedText = event.target.dataset && event.target.dataset.oldtext ? event.target.dataset.oldtext : "";
    if (event.target.innerHTML != typedText && this.appmode != "PRESENT") {
        this.eventManagerXY.dispatch("focusout", event.target);
        event.target.dataset.oldtext = event.target.innerHTML;
        this.updateJSONData();
    }
};

PresetTable.prototype.initPresent = function (currentSlide, boolNoAnimation = false) {
    if (boolNoAnimation) return { isTitleAnimation: false, isGraphicAnimation: false };
    return { isTitleAnimation: true, isGraphicAnimation: true };
};

PresetTable.prototype.imageDoubleClickHandler = function (event) {
    this.eventManagerXY.dispatch("dblclick", event.currentTarget.id, event.currentTarget.dataset.contentType);
};

PresetTable.prototype.updateTextNodes = function (index = 0) {};

PresetTable.prototype.resizeOption = function (obj) {};

PresetTable.prototype.updateTextNodes = function (index = 0) {};

PresetTable.prototype.splitRowEqually = function () {};

PresetTable.prototype.splitColEqually = function () {};

PresetTable.prototype.slideDimensionChange = function () {
    BaseTableDiagram.prototype.slideDimensionChange.call(this);
    this.callTableFillIfNeed();
};

PresetTable.prototype.updateResize = function (obj) {
    switch (obj.value) {
        case "filltable":
        case "fill":
            this.tableParent.dataset.tableresize = "fill";
            this.tableData.properties.tableresize = "fill";
            this.fillTable?.(obj);
            return;
        case "filltableratio":
        case "aspect-fill":
            this.tableParent.dataset.tableresize = "aspect-fill";
            this.tableData.properties.tableresize = "aspect-fill";
            this.fillTableRatio?.(obj);
            return;
        case "filltablewidth":
            this.fillTableWidth?.(obj);
            return;
        case "filltableheight":
            this.fillTableHeight?.(obj);
            return;
        case "filltablewidthratio":
            this.fillTableWidthRatio?.(obj);
            return;
        case "filltableheightratio":
            this.fillTableHeightRatio?.(obj);
            return;
        case "filltableauto":
        case "auto":
            this.tableParent.dataset.tableresize = "auto";
            this.tableData.properties.tableresize = "auto";
            this.fillAuto?.(obj);
            return;
    }
};

function sampleColMatrix() {
    return {
        matrix: [
            {
                nodeproperties: {
                    highlight: false,
                    emphasize: false,
                    sublist: "none",
                    ischecked: false,
                },
                titleHolder: {
                    type: "text",
                    value: " ",
                    textproperties: {},
                    contenttype: "text",
                    valuetype: "text",
                },
                cellproperties: {
                    width: 196,
                    height: 41,
                },
                value: "",
            },
            {
                nodeproperties: {
                    highlight: false,
                    emphasize: false,
                    sublist: "none",
                    ischecked: false,
                },
                contentNode: {
                    subNodes: {
                        imageHolder: {
                            type: "image",
                            value: "http://localhost:8080/assets/projectresources/genericassets/images/app/google.png",
                            contenttype: "image",
                        },
                    },
                },
                cellproperties: {
                    width: 132,
                    height: 44,
                },
                value: "",
            },
            {
                nodeproperties: {
                    highlight: false,
                    emphasize: false,
                    sublist: "none",
                    ischecked: false,
                },
                contentNode: {
                    subNodes: {
                        imageHolder: {
                            type: "image",
                            value: "http://localhost:8080/assets/projectresources/genericassets/images/app/adobe.png",
                            contenttype: "image",
                        },
                    },
                },
                cellproperties: {
                    width: 132,
                    height: 44,
                },
                value: "",
            },
            {
                nodeproperties: {
                    highlight: false,
                    emphasize: false,
                    sublist: "none",
                    ischecked: false,
                },
                contentNode: {
                    subNodes: {
                        imageHolder: {
                            type: "image",
                            value: "http://localhost:8080/assets/projectresources/genericassets/images/app/twitter.png",
                            contenttype: "image",
                        },
                    },
                },
                cellproperties: {
                    width: 132,
                    height: 44,
                },
                value: "",
            },
            {
                nodeproperties: {
                    highlight: false,
                    emphasize: false,
                    sublist: "none",
                    ischecked: false,
                },
                contentNode: {
                    subNodes: {
                        imageHolder: {
                            type: "image",
                            value: "http://localhost:8080/assets/projectresources/genericassets/images/app/loom.png",
                            contenttype: "image",
                        },
                    },
                },
                cellproperties: {
                    width: 132,
                    height: 44,
                },
                value: "",
            },
        ],
    };
}

function sampleRowMatrix() {
    return {
        matrix: [
            {
                nodeproperties: {
                    highlight: false,
                    emphasize: false,
                    sublist: "none",
                    ischecked: false,
                },
                titleHolder: {
                    type: "text",
                    value: " ",
                    textproperties: {},
                    contenttype: "text",
                    valuetype: "text",
                },
                cellproperties: {
                    width: 196,
                    height: 41,
                },
                value: "",
            },
            {
                nodeproperties: {
                    highlight: false,
                    emphasize: false,
                    sublist: "none",
                    ischecked: false,
                },
                secContentNode: {
                    subNodes: {
                        titleHolder: {
                            type: "text",
                            value: "Population",
                            textproperties: {},
                            contenttype: "text",
                            valuetype: "text",
                        },
                    },
                },
                cellproperties: {
                    width: 196,
                    height: 41,
                },
                value: "",
            },
            {
                nodeproperties: {
                    highlight: false,
                    emphasize: false,
                    sublist: "none",
                    ischecked: false,
                },
                secContentNode: {
                    subNodes: {
                        titleHolder: {
                            type: "text",
                            value: "Fy 19-20 Food",
                            textproperties: {},
                            contenttype: "text",
                            valuetype: "text",
                        },
                    },
                },
                cellproperties: {
                    width: 196,
                    height: 41,
                },
                value: "",
            },
            {
                nodeproperties: {
                    highlight: false,
                    emphasize: false,
                    sublist: "none",
                    ischecked: false,
                },
                secContentNode: {
                    subNodes: {
                        titleHolder: {
                            type: "text",
                            value: "Order Value",
                            textproperties: {},
                            contenttype: "text",
                            valuetype: "text",
                        },
                    },
                },
                cellproperties: {
                    width: 196,
                    height: 41,
                },
                value: "",
            },
            {
                nodeproperties: {
                    highlight: false,
                    emphasize: false,
                    sublist: "none",
                    ischecked: false,
                },
                secContentNode: {
                    subNodes: {
                        titleHolder: {
                            type: "text",
                            value: "Off Premise",
                            textproperties: {},
                            contenttype: "text",
                            valuetype: "text",
                        },
                    },
                },
                cellproperties: {
                    width: 196,
                    height: 41,
                },
                value: "",
            },
            {
                nodeproperties: {
                    highlight: false,
                    emphasize: false,
                    sublist: "none",
                    ischecked: false,
                },
                secContentNode: {
                    subNodes: {
                        titleHolder: {
                            type: "text",
                            value: "Online %of Food",
                            textproperties: {},
                            contenttype: "text",
                            valuetype: "text",
                        },
                    },
                },
                cellproperties: {
                    width: 196,
                    height: 41,
                },
                value: "",
            },
            {
                nodeproperties: {
                    highlight: false,
                    emphasize: false,
                    sublist: "none",
                    ischecked: false,
                },
                secContentNode: {
                    subNodes: {
                        titleHolder: {
                            type: "text",
                            value: "Online %of Food",
                            textproperties: {},
                            contenttype: "text",
                            valuetype: "text",
                        },
                    },
                },
                cellproperties: {
                    width: 196,
                    height: 41,
                },
                value: "",
            },
        ],
    };
}

function defaultNodeData() {
    return {
        subTitleHolder: {
            sublist: "none",
            items: [
                {
                    type: "text",
                    value: "content",
                    index: 0,
                    content: null,
                },
            ],
            textproperties: {},
        },
    };
}

/**
 * Author:    Bala Krishnan K.
 * Created:   16.7.2020
 *
 **/

"use strict";

function SimpleImageSplitGridDiagram(diagramParent, diagramData, nodeProps, moodData = {}) {
    LinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    diagramParent.setAttribute("data-diagramtype", "horizontal");
    this.adjustValue = [0, 40, 40, 40, 90, 130, 150];
}

SimpleImageSplitGridDiagram.prototype = Object.create(LinearDiagram.prototype);
SimpleImageSplitGridDiagram.prototype.constructor = SimpleImageSplitGridDiagram;

SimpleImageSplitGridDiagram.prototype.createElements = function () {
    // this.diagramData.properties.isimagefit = true;
    // this.diagramParent.setAttribute("data-isimagefit", "true");
    const nodeCount = this.diagramData.nodes.length;
    let gridObj = this.nodeProps.grid;
    let pattenDiv = document.createElement("div");
    let centerNodeStyle = this.nodeProps.centerNodeStyle || "";
    pattenDiv.className = "clsImageSplitGrid " + centerNodeStyle;
    // pattenDiv.className = "clsNodesHolder";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.setAttribute("data-type", gridObj.type);
    this.diagramParent.setAttribute("data-arrangement", gridObj.arrangement);
    this.diagramParent.appendChild(pattenDiv);
    pattenDiv.setAttribute("data-length", nodeCount);
    pattenDiv.style.setProperty("--grid-gap", gridObj.gap);
    pattenDiv.style.setProperty("--grid-columns", gridObj.columns == "auto" ? 6 : gridObj.columns);
    pattenDiv.style.setProperty("--grid-rows", gridObj.rows == "auto" ? 6 : gridObj.rows);

    let gap = DiagramNodeUtils.getGapForMathSymbols(this.nodeProps, nodeCount, this.diagramParent);

    pattenDiv.style.setProperty("--awardContentHeight", 200 - nodeCount > this.adjustValue.length ? this.adjustValue[6] + "px" : this.adjustValue[nodeCount] + "px");

    pattenDiv.style.setProperty("--nodeWidth", "calc(1/" + nodeCount + "*100% - (1 - 1/" + nodeCount + ")*" + gap + "px)");
    pattenDiv.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    pattenDiv.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    pattenDiv.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    pattenDiv.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    pattenDiv.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");

    let arrowStyle = this.nodeProps?.connector?.style;
    if (arrowStyle) {
        this.diagramData.properties.connectorstyle = arrowStyle;
        this.diagramParent.setAttribute("data-connectorstyle", arrowStyle);
    }

    this.updateImageRatio();

    this.createNodeInstances(nodeCount, pattenDiv);
};

SimpleImageSplitGridDiagram.prototype.insertSvgBackground = function () {};

SimpleImageSplitGridDiagram.prototype.updateImageRatio = function () {
    if (this.nodeProps.imageRatio && this.nodeProps.imageRatio.type) {
        let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
        const nodeCount = this.diagramData.nodes.length;
        const gap = DiagramNodeUtils.getGapForMathSymbols(this.nodeProps, nodeCount, this.diagramParent);
        const widthPercent = this.nodeProps.imageRatio.value ? this.nodeProps.imageRatio.value : 100;
        const holderWidth = (nodesHolder.offsetWidth - (nodeCount - 1) * gap) / nodeCount;
        const imageHolderWidth = (holderWidth / 100) * widthPercent;
        let percentImageHolderWidth = imageHolderWidth;
        let percentImageHolderHeight = (imageHolderWidth / 16) * 9;
        if (this.nodeProps.imageRatio.type == "sqr") {
            percentImageHolderWidth = imageHolderWidth;
            percentImageHolderHeight = imageHolderWidth;
        } else if (this.nodeProps.imageRatio.type == "pot") {
            percentImageHolderWidth = imageHolderWidth;
            percentImageHolderHeight = (imageHolderWidth / 3) * 4;
        }

        nodesHolder.style.setProperty("--percentWidth", percentImageHolderWidth + "px");
        nodesHolder.style.setProperty("--percentHeight", percentImageHolderHeight + "px");
    }
};

SimpleImageSplitGridDiagram.prototype.resetHolderWidth = function () {
    this.updateImageRatio();
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    let nodeCount = this.diagramData.nodes.length;
    let gap = DiagramNodeUtils.getGapForMathSymbols(this.nodeProps, nodeCount, this.diagramParent);

    nodesHolder.style.setProperty("--nodeWidth", "calc(1/" + nodeCount + "*100% - (1 - 1/" + nodeCount + ")*" + gap + "px)");
    nodesHolder.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    nodesHolder.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    nodesHolder.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    nodesHolder.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    nodesHolder.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");
    this.resetNodeAttributes();
};

SimpleImageSplitGridDiagram.prototype.addNode = function (nodeJSON, index,isFromUndo = false) {
    LinearDiagram.prototype.addNode.call(this, nodeJSON, index,isFromUndo);
    let nodeCount = this.arrDiagramNode.length;
    let pattenDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    // pattenDiv.style.setProperty("--awardContentHeight", 200 - (nodeCount > this.adjustValue.length ? this.adjustValue[6] + "px" : this.adjustValue[nodeCount] + "px"));
    // this.updateImageRatio();
    pattenDiv.setAttribute("data-length", nodeCount);
    this.initDiagramCreation();
    this.updateEvents();
    // this.resetNodeAttributes();
};

SimpleImageSplitGridDiagram.prototype.deleteNode = function (targetIndex) {
    LinearDiagram.prototype.deleteNode.call(this, targetIndex);
    let pattenDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    let nodeCount = this.arrDiagramNode.length;
    // pattenDiv.style.setProperty("--awardContentHeight", 200 - (nodeCount > this.adjustValue.length ? this.adjustValue[6] + "px" : this.adjustValue[nodeCount] + "px"));
    // this.updateImageRatio();
    pattenDiv.setAttribute("data-length", nodeCount);
    this.initDiagramCreation();
    this.updateEvents();
    // this.resetNodeAttributes();
};

SimpleImageSplitGridDiagram.prototype.setHighlightPosition = function (node, parent) {
    let nodeParent = node.parentElement;
    let element = nodeParent.querySelector("[data-id='diagramContentNode']");
    if (!element || element.clientWidth == 0) element = node;
    return { element: element, alignment: "horizontal" };
};

/**
 * Author:    Krishna
 * Created:   20 fri march 2020
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function HighlightTest(diagramParent, diagramData, targetRect, moodData = {}) {
    this.data = diagramData;
    this.isLooped = false;
    this.primaryAlign = "";
    this.secondaryAlign = "";

    let CalloutParent = diagramParent.parentElement.parentElement.parentElement;
    this.clearOldHighlightIfNeeded(CalloutParent);

    this.diagramParent = diagramParent;
    this.maxSize = { width: 400, height: 300 };

    this.target = document.createElement("div");
    this.target.id = "target";
    this.target.className = "target";

    if (targetRect) this.targetRect = targetRect;
    this.viewRect = DiagramNodeUtils.getOffsetRectByParent(CalloutParent, diagramParent.parentElement.parentElement.parentElement);

    this.callOutDiv = document.createElement("div");
    this.callOutDiv.style.maxWidth = this.maxSize.width + "px";
    this.callOutDiv.style.maxHeight = this.maxSize.height + "px";
    this.callOutDiv.className = "callOut";
    this.callOutDiv.id = "callOut";
    this.callOutDiv.style.zIndex = "500";
    this.callOutDiv.setAttribute("data-animation", "highlightshape");
    this.callOutDiv.setAttribute("data-alignment", "rightmiddle");
    CalloutParent.appendChild(this.callOutDiv);

    let data = {
        content: { type: "image" },
        title: "You're off to great places, today is your day.",
        subtitle: "Hello world",
    };
    data = diagramData;

    this.offset = 0;
    this.position = { primary: "auto", secondary: "auto" };
    if (data.position) this.position = data.position;

    if (diagramParent.parentElement.dataset.hasOwnProperty("oneattimeanimationtype")) {
        if (diagramParent.parentElement.dataset.oneattimeanimationtype.includes("fullscreen")) this.position["primary"] = "auto";
        if (data.hasOwnProperty("index") && data.index == 0 && diagramParent.parentElement.dataset.oneattimeanimationtype.includes("horizontalscale")) this.position["primary"] = "auto";
    }

    this.isAnimtion = !data.hasOwnProperty("animatable") || (data.hasOwnProperty("animatable") && data.animatable == true) ? true : false;

    // this.createTarget(CalloutParent);
    this.createCallOut(this.callOutDiv, data);
    this.adjustFontClip(this.callOutDiv);
    this.callOutFrame(this.targetRect, this.viewRect, this.callOutDiv, this.position);

    if (this.constructor.name == "HighlightTest" && data.getAnimationData) {
        this.callOutDiv.style.opacity = data.animationtype != "show" ? "1" : "0";
        let alignment = this.callOutDiv.getAttribute("data-alignment");
        let animationData = data.getAnimationData(alignment, data.animationtype);
        this.setupAnimation(animationData);
    }

    return this.callOutDiv;
}

HighlightTest.prototype.createCallOut = function (parent, data) {
    let mainParent = document.createElement("div");
    mainParent.id = "callout-mainparent";
    mainParent.className = "callout-mainparent";
    parent.appendChild(mainParent);

    let pointHolder = document.createElement("div");
    pointHolder.className = "callout-pointholder";
    mainParent.appendChild(pointHolder);

    this.pointerDiv = document.createElement("div");
    this.pointerDiv.className = "callout-pointer";
    pointHolder.appendChild(this.pointerDiv);

    if (data.content && data.content.type && data.content.type != "none") {
        let contentParent = document.createElement("div");
        contentParent.id = "callout-contentparent";
        contentParent.className = "callout-contentparent";
        contentParent.setAttribute("data-type", data.content.type);
        // contentParent.style.marginLeft = data.content.type == "icon" ? "20px" : "0px";
        mainParent.appendChild(contentParent);

        let contentHolder = document.createElement("div");
        contentHolder.id = "callout-contentparent";
        contentHolder.className = data.content.type == "icon" ? "callout-icon" : "callout-image";
        contentParent.appendChild(contentHolder);

        if (data.content.type == "icon" && data.content.value) {
            let id = data.content.value.split("/").pop().replace(".svg", "");
            let svg = DiagramNodeUtils.createSVGDataNode("callout-icon clsMultiColorParent", id, data.content.value, 0, "callout-icon");
            svg.setAttribute("data-animation", "highlighticon");
            contentHolder.appendChild(svg);
        } else if (data.content.value) {
            let image = document.createElement("img");
            image.className = data.content.type == "logo" || data.content.type == "team" ? "callout-logo" : "callout-image";
            image.id = "callout-image";
            image.src = data.content.value;
            image.setAttribute("data-animation", "highlightimage");
            contentHolder.appendChild(image);
        }
    }

    let textParent = document.createElement("div");
    textParent.id = "callout-textparent";
    textParent.className = "callout-textparent";
    mainParent.appendChild(textParent);

    if (data.title) {
        let title = document.createElement("div");
        title.id = "callout-title";
        title.className = "callout-title h9";
        title.innerText = data.title;
        title.setAttribute("data-animation", "highlightshape");
        textParent.appendChild(title);
    }

    if (data.subtitle) {
        let subtitle = document.createElement("div");
        subtitle.id = "callout-subtitle";
        subtitle.className = "callout-subtitle p4";
        subtitle.innerText = data.subtitle;
        subtitle.setAttribute("data-animation", "highlightshape");
        textParent.appendChild(subtitle);
    }
};

HighlightTest.prototype.callOutFrame = function (targetRect, viewRect, callout, position = { primary: "vertical", secondary: "auto" }) {
    let calloutRect = { width: callout.clientWidth, height: callout.clientHeight };

    let topGap = targetRect.y - viewRect.y;
    let leftGap = targetRect.x - viewRect.x;
    let rightGap = viewRect.x + viewRect.width - (targetRect.x + targetRect.width);
    let bottomGap = viewRect.y + viewRect.height - (targetRect.y + targetRect.height);
    let gapInfo = { top: topGap, left: leftGap, right: rightGap, bottom: bottomGap };
    let targetRectInfo = {
        top: targetRect.top,
        left: targetRect.left,
        right: targetRect.left + targetRect.width,
        bottom: targetRect.y + targetRect.height,
        width: targetRect.width,
        height: targetRect.height,
    };

    callout.style.top = "unset";
    callout.style.left = "unset";

    if (position.primary == "auto") {
        this.autoPosition(calloutRect, callout, gapInfo, targetRectInfo, position);
    } else if (position.primary == "horizontal") {
        this.autoPositionHorizontal(calloutRect, callout, gapInfo, targetRectInfo, position);
    } else if (position.primary == "vertical") {
        this.autoPositionVertical(calloutRect, callout, gapInfo, targetRectInfo, position);
    } else if (position.primary == "top") {
        this.calloutTopSetup(callout, targetRectInfo, position);
    } else if (position.primary == "bottom") {
        this.calloutBottomSetup(callout, targetRectInfo, position);
    } else if (position.primary == "right") {
        this.calloutRigthSetup(callout, targetRectInfo, position);
    } else if (position.primary == "left") {
        this.calloutLeftSetup(callout, targetRectInfo, position);
    }

    let callStyle = window.getComputedStyle(this.callOutDiv);
    let leftPadding = parseFloat(callStyle.paddingLeft);
    let rightPadding = parseFloat(callStyle.paddingRight);
    callout.style.minWidth = callout.clientWidth - leftPadding - rightPadding + "px";
};

HighlightTest.prototype.autoPosition = function (calloutRect, callout, gapInfo, targetRectInfo, position) {
    if (calloutRect.width < gapInfo.right) {
        this.calloutRigthSetup(callout, targetRectInfo, position);
    } else if (calloutRect.width + this.offset < gapInfo.left) {
        this.calloutLeftSetup(callout, targetRectInfo, position);
    } else if (calloutRect.height + this.offset < gapInfo.top) {
        this.calloutTopSetup(callout, targetRectInfo, position);
    } else if (calloutRect.height + this.offset < gapInfo.bottom) {
        this.calloutBottomSetup(callout, targetRectInfo, position);
    }
};

HighlightTest.prototype.autoPositionVertical = function (calloutRect, callout, gapInfo, targetRectInfo, position) {
    if (calloutRect.height + this.offset < gapInfo.top) {
        this.calloutTopSetup(callout, targetRectInfo, position);
    } else if (calloutRect.height + this.offset < gapInfo.bottom) {
        this.calloutBottomSetup(callout, targetRectInfo, position);
    } else {
        this.calloutTopSetup(callout, targetRectInfo, position);
    }
    // else if (!this.isLooped) {
    //     let availableMaxSpace = Math.max(gapInfo.top,gapInfo.bottom);
    //     callout.style.maxHeight = availableMaxSpace-50+"px";
    //     this.isLooped = true;
    //     let newCalloutRect = { width: callout.clientWidth, height: callout.clientHeight };
    //     this.autoPositionVertical(newCalloutRect, callout, gapInfo, targetRectInfo, position);
    // }
};

HighlightTest.prototype.autoPositionHorizontal = function (calloutRect, callout, gapInfo, targetRectInfo, position) {
    if (calloutRect.width < gapInfo.right) {
        this.calloutRigthSetup(callout, targetRectInfo, position);
    } else if (calloutRect.width + this.offset < gapInfo.left) {
        this.calloutLeftSetup(callout, targetRectInfo, position);
    } else if (calloutRect.width + this.offset == gapInfo.right || calloutRect.width + this.offset == gapInfo.left) {
        this.calloutRigthSetup(callout, targetRectInfo, position);
    } else if (!this.isLooped) {
        let availableMaxSpace = Math.max(gapInfo.right, gapInfo.left);
        callout.style.maxWidth = availableMaxSpace + "px";
        this.isLooped = true;
        let newCalloutRect = { width: availableMaxSpace, height: callout.clientHeight };
        this.autoPositionHorizontal(newCalloutRect, callout, gapInfo, targetRectInfo, position);
    }
};

HighlightTest.prototype.calloutRigthSetup = function (callOutDiv, gapInfo, position) {
    this.primaryAlign = "right";
    this.setAlignment(callOutDiv, true, gapInfo, position);
    callOutDiv.style.left = gapInfo.right + "px";

    let gropParent = callOutDiv.querySelector("#callout-mainparent");
    gropParent.classList.remove("leftAlign");
    gropParent.classList.add("rightAlign");
};

HighlightTest.prototype.calloutLeftSetup = function (callOutDiv, gapInfo, position) {
    this.primaryAlign = "left";
    this.setAlignment(callOutDiv, true, gapInfo, position);
    callOutDiv.style.left = gapInfo.left - callOutDiv.clientWidth + "px";

    let gropParent = callOutDiv.querySelector("#callout-mainparent");
    gropParent.classList.remove("rightAlign");
    gropParent.classList.add("leftAlign");
};

HighlightTest.prototype.calloutTopSetup = function (callOutDiv, gapInfo, position) {
    this.primaryAlign = "top";
    this.setAlignment(callOutDiv, false, gapInfo, position);
    // if (position.secondary == "auto")
    this.adjustClip(callOutDiv, gapInfo, false);
    callOutDiv.style.top = gapInfo.top - callOutDiv.clientHeight + "px";
    this.clearAlignClass(callOutDiv);

    let gropParent = callOutDiv.querySelector("#callout-mainparent");
    gropParent.classList.add("rightAlign");
};

HighlightTest.prototype.calloutBottomSetup = function (callOutDiv, gapInfo, position) {
    this.primaryAlign = "bottom";
    this.setAlignment(callOutDiv, false, gapInfo, position);
    // if (position.secondary == "auto")
    this.adjustClip(callOutDiv, gapInfo, false);
    callOutDiv.style.top = gapInfo.bottom + "px";
    this.clearAlignClass(callOutDiv);

    let gropParent = callOutDiv.querySelector("#callout-mainparent");
    gropParent.classList.add("rightAlign");
};

HighlightTest.prototype.setAlignment = function (callOutDiv, isVertical, gapInfo, position) {
    if (isVertical) {
        let start = gapInfo.top + "px";
        let center = gapInfo.top + gapInfo.height / 2 - callOutDiv.clientHeight / 2 + "px";
        let end = gapInfo.top + gapInfo.height - callOutDiv.clientHeight + "px";
        let align = position.secondary == "start" ? start : center;
        align = position.secondary == "end" ? end : align;
        callOutDiv.style.top = align;

        this.secondaryAlign = position.secondary == "start" ? "top" : "middle";
        this.secondaryAlign = position.secondary == "end" ? "bottom" : this.secondaryAlign;
    } else {
        let start = gapInfo.left + "px";
        let center = gapInfo.left + gapInfo.width / 2 - callOutDiv.clientWidth / 2 + "px";
        let end = gapInfo.left + gapInfo.width + "px";
        let align = position.secondary == "start" ? start : center;
        align = position.secondary == "end" ? end : align;
        callOutDiv.style.left = align;

        this.secondaryAlign = position.secondary == "start" ? "left" : "center";
        this.secondaryAlign = position.secondary == "end" ? "right" : this.secondaryAlign;
    }

    console.log("position - " + this.primaryAlign + this.secondaryAlign);
    this.callOutDiv.className = "callOut " + this.primaryAlign + this.secondaryAlign;
    this.callOutDiv.setAttribute("data-alignment", this.primaryAlign + this.secondaryAlign);
};

HighlightTest.prototype.adjustClip = function (callOutDiv, gapInfo, isVertical = false) {
    if (isVertical) {
    } else {
        let startPosition = parseFloat(callOutDiv.style.left);
        let endPosition = parseFloat(callOutDiv.style.left) + callOutDiv.clientWidth;
        if (startPosition < 0) {
            this.secondaryAlign = "left";
            callOutDiv.style.left = gapInfo.left + "px";
        } else if (endPosition > this.viewRect.width) {
            this.secondaryAlign = "right";
            callOutDiv.style.left = gapInfo.right - callOutDiv.clientWidth + "px";
        }
    }

    console.log("position - " + this.primaryAlign + this.secondaryAlign);
    this.callOutDiv.className = "callOut " + this.primaryAlign + this.secondaryAlign;
    this.callOutDiv.setAttribute("data-alignment", this.primaryAlign + this.secondaryAlign);
};

HighlightTest.prototype.clearAlignClass = function (callOutDiv) {
    let gropParent = callOutDiv.querySelector("#callout-mainparent");
    // gropParent.classList.remove("rightAlign");
    gropParent.classList.remove("leftAlign");
};

HighlightTest.prototype.clearOldHighlightIfNeeded = function (parent) {
    let oldHighlight = parent.querySelector("#callOut");
    let oldTarget = parent.querySelector("#target");

    if (oldHighlight && oldHighlight.parentElement) oldHighlight.parentElement.removeChild(oldHighlight);
    if (oldTarget && oldTarget.parentElement) oldTarget.parentElement.removeChild(oldTarget);
};

HighlightTest.prototype.adjustFontClip = function (callOut) {
    let title = callOut.querySelector("#callout-title");
    if (!title) return;
    title.style.maxHeight = "unset";

    let titleStyleObj = window.getComputedStyle(title);
    let lineHeight = parseFloat(titleStyleObj.lineHeight).toFixed(2);
    let titleHeight = parseFloat(titleStyleObj.height).toFixed(2);
    let noOfLines = title.clientHeight > title.scrollHeight ? (titleHeight / lineHeight).toFixed() : parseInt((titleHeight / lineHeight).toFixed(2));
    title.style.maxHeight = parseFloat(lineHeight * noOfLines) + "px";
};

HighlightTest.prototype.clearDefaultAnimationProperty = function () {
    this.callOutDiv.setAttribute("data-animation", "highlightshape");
    this.callOutDiv.removeAttribute("data-animation");
    let arrChild = Array.from(this.callOutDiv.querySelectorAll("data-animation"));
    arrChild.map((child) => child.removeAttribute("data-animation"));
};

HighlightTest.prototype.createTarget = function (parent) {
    let div = document.createElement("div");
    div.id = "refTarget";
    div.style.position = "absolute";
    div.style.top = this.targetRect.top + "px";
    div.style.left = this.targetRect.left + "px";
    div.style.width = this.targetRect.width + "px";
    div.style.height = this.targetRect.height + "px";
    div.style.backgroundColor = "gray";
    div.style.zIndex = "100";
    parent.appendChild(div);

    setTimeout(() => {
        div.remove();
    }, 3000);
};

HighlightTest.prototype.setupAnimation = function (animationData) {
    DiagramAnimateUtil.setHighlightAnimation(this.callOutDiv.parentElement, this.callOutDiv.parentElement, animationData, this.data.animationtype, this.isAnimtion);
    setTimeout(() => {
        this.data?.callback?.();
    }, 1600 * (this.isAnimtion ? 1 : 0));
};

/**
 * Author:    Krishna
 * Created:   24 Thu Sep 2020
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function CalloutModel1(diagramParent, data, targetRect, moodData = {}) {
    let callOut = HighlightTest.call(this, diagramParent, data, targetRect, moodData);
    this.clearDefaultAnimationProperty();
    this.borderLine = null;
    this.svg = null;
    this.bgShape = null;
    this.pointer = null;
    this.isShow = false;
    this.borderWidth = 5;
    this.calloutAlignment = this.primaryAlign + this.secondaryAlign;
    this.padding = parseFloat(window.getComputedStyle(callOut).padding);
    this.setupBgShape();

    // return callOut;
    this.setupAnimation(data.animationtype);
    setTimeout(() => {
        this.animate();
    }, 0);
    
    if(data.assettype!="chart"){
        return callOut;
    }
}

CalloutModel1.prototype = Object.create(HighlightTest.prototype);
CalloutModel1.prototype.constructor = CalloutModel1;

CalloutModel1.prototype.createCallOut = function (parent, data) {
    let clipDiv = document.createElement("div");
    clipDiv.style.overflow = "hidden";

    let mainParent = document.createElement("div");
    mainParent.id = "callout-mainparent";
    mainParent.className = "callout-mainparent";
    mainParent.style.overflow = "hidden";
    mainParent.style.zIndex = 1;
    clipDiv.appendChild(mainParent);
    parent.appendChild(clipDiv);
    this.textParent = mainParent;

    if (data.content && data.content.type&& data.content.type != "none") {
        let contentParent = document.createElement("div");
        contentParent.id = "callout-contentparent";
        contentParent.className = "callout-contentparent";
        contentParent.setAttribute("data-type", data.content.type);
        // contentParent.style.marginLeft = data.content.type == "icon" ? "20px" : "0px";
        mainParent.appendChild(contentParent);

        let contentHolder = document.createElement("div");
        contentHolder.id = "callout-contentparent";
        contentHolder.className = data.content.type == "icon" ? "callout-icon" : "callout-image";
        contentParent.appendChild(contentHolder);

        if (data.content.type == "icon" && data.content.value) {
            let id = data.content.value.split("/").pop().replace(".svg", "");
            let svg = DiagramNodeUtils.createSVGDataNode("callout-icon", id, data.content.value, 0, "callout-icon");
            // svg.setAttribute("data-animation", "highlighticon");
            contentHolder.appendChild(svg);
        } else if (data.content.value) {
            let image = document.createElement("img");
            image.className = data.content.type == "logo" || data.content.type == "team" ? "callout-logo" : "callout-image";
            image.id = "callout-image";
            image.src = data.content.value;
            // image.setAttribute("data-animation", "highlightimage");
            contentHolder.appendChild(image);
        }
    }

    let textParent = document.createElement("div");
    textParent.id = "callout-textparent";
    textParent.className = "callout-textparent";
    mainParent.appendChild(textParent);

    if (data.title) {
        let title = document.createElement("div");
        title.id = "callout-title";
        title.className = "callout-title h9";
        title.innerText = data.title;
        // title.setAttribute("data-animation", "highlightshape");
        textParent.appendChild(title);
    }

    if (data.subtitle) {
        let subtitle = document.createElement("div");
        subtitle.id = "callout-subtitle";
        subtitle.className = "callout-subtitle p4";
        subtitle.innerText = data.subtitle;
        // subtitle.setAttribute("data-animation", "highlightshape");
        textParent.appendChild(subtitle);
    }
};

CalloutModel1.prototype.setupBgShape = function () {
    let svg = DiagramNodeUtils.createSVGElement("svg");
    let width = this.callOutDiv.clientWidth - this.padding * 2;
    let height = this.callOutDiv.clientHeight - this.padding * 2;
    DiagramNodeUtils.assignAttributes(svg, { width: width, height: height, style: "position:absolute; top:" + this.padding + "px; left:" + this.padding + "px; z-index:0; overflow:visible; " });
    this.callOutDiv.appendChild(svg);
    this.svg = svg;

    let point1 = { x: 0, y: 0 };
    let point2 = { x: width, y: 0 };
    let point3 = { x: width, y: height };
    let point4 = { x: 0, y: height };

    let pathSvg = DiagramNodeUtils.createSVGElement("svg");
    DiagramNodeUtils.assignAttributes(pathSvg, { style: "overflow: hidden;"});
    let path = DiagramNodeUtils.createSVGElement("path");
    let d = DiagramNodeUtils.createRoundedPathString([point1, point2, point3, point4]);
    path.setAttribute("d", d);
    path.setAttribute("class", "callout-bg");
    pathSvg.appendChild(path);
    svg.appendChild(pathSvg);
    this.bgShape = path;

    let pointerSvg = DiagramNodeUtils.createSVGElement("svg");
    DiagramNodeUtils.assignAttributes(pointerSvg, { style: "overflow: visible;" });
    let pointer = DiagramNodeUtils.createSVGElement("path");
    d = DiagramNodeUtils.createRoundedPathString(this.getPointerPoints({ width: width, height: height }));
    pointer.setAttribute("d", d);
    pointer.setAttribute("class", "callout-pointer");
    pointerSvg.appendChild(pointer);
    
    let overlayPointer = pointer.cloneNode(true);
    overlayPointer.setAttribute("class", "pointer-overlay");
    pointerSvg.appendChild(overlayPointer);
    svg.appendChild(pointerSvg);
    this.pointer = pointerSvg;

    let lineSvg = DiagramNodeUtils.createSVGElement("svg");
    DiagramNodeUtils.assignAttributes(lineSvg, { style: "overflow: visible;"});
    let line = this.drawLine({ width: width, height: height });
    line.setAttribute("class", "callout-line");
    lineSvg.appendChild(line);

    let overlayLine = line.cloneNode(true);
    overlayLine.setAttribute("class", "line-overlay");
    lineSvg.appendChild(overlayLine)
    svg.appendChild(lineSvg);
};

CalloutModel1.prototype.getPointerPoints = function (rect) {
    let offset = 15;
    let point1 = { x: -offset, y: rect.height / 2 };
    let point2 = { x: 0, y: rect.height / 2 - offset };
    let point3 = { x: 0, y: rect.height / 2 + offset };

    if (this.calloutAlignment.includes("bottom")) {
        point1 = { x: rect.width / 2, y: -offset };
        point2 = { x: rect.width / 2 + offset, y: 0 };
        point3 = { x: rect.width / 2 - offset, y: 0 };
    }else if (this.calloutAlignment.includes("top")) {
        point1 = { x: rect.width / 2, y: rect.height + offset };
        point2 = { x: rect.width / 2 + offset, y: rect.height };
        point3 = { x: rect.width / 2 - offset, y: rect.height };
    }else if (this.calloutAlignment.includes("left")) {
        point1 = { x: rect.width + offset, y: rect.height / 2 };
        point2 = { x: rect.width, y: rect.height / 2 - offset };
        point3 = { x: rect.width, y: rect.height / 2 + offset };
    } 
    return [point1, point2, point3];
};

CalloutModel1.prototype.drawLine = function (rect) {
    let offset = this.borderWidth / 2;
    let point1 = { x: 0 - offset, y: 0 };
    let point2 = { x: 0 - offset, y: rect.height };

    if (this.calloutAlignment.includes("bottom")) {
        point1 = { x: 0, y: 0 - offset };
        point2 = { x: rect.width, y: 0 - offset };
    }else if (this.calloutAlignment.includes("top")) {
        point1 = { x: 0, y: rect.height + offset };
        point2 = { x: rect.width, y: rect.height + offset };
    } else if (this.calloutAlignment.includes("left")) {
        point1 = { x: rect.width + offset, y: 0 };
        point2 = { x: rect.width + offset, y: rect.height };
    } 

    return this.createLine(point1, point2);
};

CalloutModel1.prototype.createLine = function (startPoint, endPoint) {
    let line = DiagramNodeUtils.createSVGElement("line");
    DiagramNodeUtils.assignSVGNodeAttributes(line, { x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y, "stroke-width": 5 });
    return line;
};

CalloutModel1.prototype.setupAnimation = function (type = "show") {
    if (type == "show") {
        this.isShow = true;
        this.setupShowAnimation();
    }
};

CalloutModel1.prototype.setupShowAnimation = function () {
    let rect = this.svg.getBBox();
    this.svg.setAttribute("transform", "scale(1 0)");
    // this.svg.setAttribute("opacity", "0");
    this.bgShape.setAttribute("transform", "translate(-" + rect.width + " 0)");
    this.textParent.style.transform = "translate(-" + rect.width + "px, 0px)";
    if (this.calloutAlignment.includes("bottom")) {
        this.svg.setAttribute("transform", "scale(0 1)");
        this.bgShape.setAttribute("transform", "translate(0 -" + rect.height + ")");
        this.textParent.style.transform = "translate(0px, -" + rect.height + "px)";
    } else if (this.calloutAlignment.includes("top")) {
        this.svg.setAttribute("transform", "scale(0 1)");
        this.bgShape.setAttribute("transform", "translate(0 " + rect.height + ")");
        this.textParent.style.transform = "translate(0px, " + rect.height + "px)";
    } else if (this.calloutAlignment.includes("left")) {
        this.svg.setAttribute("transform", "scale(1 0)");
        this.bgShape.setAttribute("transform", "translate(" + rect.width + " 0)");
        this.textParent.style.transform = "translate(" + rect.width + "px, 0px)";
    } 
};

CalloutModel1.prototype.setupHideAnimation = function (isAnimatable = true) {
    let rect = this.svg.getBBox();
    
    if (this.isAnimtion) {
        this.textParent.style.transition = "all 0.5s";
        let style = this.bgShape.getAttribute("style") || "";
        this.bgShape.setAttribute("style", style + "transition: all 0.5s 0.1s;");
        style = this.svg.getAttribute("style") || "";
        this.svg.setAttribute("style", style + "transition: all 0.5s;");
    }

    this.bgShape.setAttribute("transform", "translate(-" + rect.width + " 0)");
    this.textParent.style.transform = "translate(-" + rect.width + "px, 0px)";
    if (this.calloutAlignment.includes("bottom")) {
        this.bgShape.setAttribute("transform", "translate(0 -" + rect.height + ")");
        this.textParent.style.transform = "translate(0px, -" + rect.height + "px)";
    } else if (this.calloutAlignment.includes("top")) {
        this.bgShape.setAttribute("transform", "translate(0 " + rect.height + ")");
        this.textParent.style.transform = "translate(0px, " + rect.height + "px)";
    } else if (this.calloutAlignment.includes("left")) {
        this.bgShape.setAttribute("transform", "translate(" + rect.width + " 0)");
        this.textParent.style.transform = "translate(" + rect.width + "px, 0px)";
    }

    setTimeout(() => {
        this.svg.setAttribute("transform", "scale(1 0)");
        this.svg.setAttribute("opacity", "0");
        if (this.calloutAlignment.includes("bottom")) {
            this.svg.setAttribute("transform", "scale(0 1)");
        }else if (this.calloutAlignment.includes("top")) {
            this.svg.setAttribute("transform", "scale(0 1)");
        } else if (this.calloutAlignment.includes("left")) {
            this.svg.setAttribute("transform", "scale(1 0)");
        } 
        setTimeout(() => {
            this.data?.callback?.()
        }, this.isAnimtion ? 500 : 0);
    }, this.isAnimtion ? 500 : 0);
};

CalloutModel1.prototype.animate = function () {
    if (this.isShow) {
        let style = this.svg.getAttribute("style") || "";
        if (this.isAnimtion) this.svg.setAttribute("style", style + "transition: all 0.5s;");
        this.svg.setAttribute("transform", "scale(1 1)");
        this.svg.setAttribute("opacity", "1");

        setTimeout(() => {
            style = this.bgShape.getAttribute("style") || "";
            if (this.isAnimtion) this.bgShape.setAttribute("style", style + "transition: all 0.5s;");
            this.bgShape.setAttribute("transform", "translate(0 0)");
            if (this.isAnimtion) this.textParent.style.transition = "all 0.5s 0.1s";
            this.textParent.style.transform = "translate(0px, 0px)";
            setTimeout(() => {
                this.data?.callback?.()
            }, this.isAnimtion ? 500 : 0);
        }, this.isAnimtion ? 500 : 0);
    }else{
        this.setupHideAnimation();
    }
};

/**
 * Author:    Krishna
 * Created:   24 Thu Sep 2020
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function CalloutModel2(diagramParent, data, targetRect, moodData = {}) {
    let callOut = HighlightTest.call(this, diagramParent, data, targetRect, moodData);
    this.calloutAlignment = this.primaryAlign + this.secondaryAlign;
    this.setPadding();
    this.clearDefaultAnimationProperty();
    this.borderLine = null;
    this.svg = null;
    this.bgShape = null;
    this.pointer = null;
    this.isShow = false;
    this.borderWidth = 5;
    this.padding = parseFloat(window.getComputedStyle(callOut).padding);

    // return callOut;
    this.setupAnimation(data.animationtype);
    setTimeout(() => {
        this.animate();
        if(data.assettype=="chart"){
            this?.callOutDiv?.style.removeProperty("opacity")
            callOut?.style.removeProperty("opacity");
            this?.callOutDiv?.classList.remove("baselineopacity")
            this?.callOutDiv?.classList.add("baselineopacity")
            callOut?.classList.remove("baselineopacity")
            callOut?.classList.add("baselineopacity")
        }
    }, 0);
    
    if(data.assettype!="chart"){
        return callOut;
    }
}

CalloutModel2.prototype = Object.create(HighlightTest.prototype);
CalloutModel2.prototype.constructor = CalloutModel2;

CalloutModel2.prototype.createCallOut = function (parent, data) {
    let clipDiv = document.createElement("div");
    clipDiv.style.overflow = "hidden";

    let pointer = document.createElement("div");
    pointer.className = "callout-pointer";
    pointer.innerHTML = this.svg();
    this.callOutDiv.appendChild(pointer);

    let mainParent = document.createElement("div");
    mainParent.id = "callout-mainparent";
    mainParent.className = "callout-mainparent";
    mainParent.style.overflow = "hidden";
    mainParent.style.zIndex = 1;
    clipDiv.appendChild(mainParent);
    parent.appendChild(clipDiv);
    this.textParent = mainParent;

    if (data.content && data.content.type&& data.content.type != "none") {
        let contentParent = document.createElement("div");
        contentParent.id = "callout-contentparent";
        contentParent.className = "callout-contentparent";
        contentParent.setAttribute("data-type", data.content.type);
        // contentParent.style.marginLeft = data.content.type == "icon" ? "20px" : "0px";
        mainParent.appendChild(contentParent);

        let contentHolder = document.createElement("div");
        contentHolder.id = "callout-contentparent";
        contentHolder.className = data.content.type == "icon" ? "callout-icon" : "callout-image";
        contentParent.appendChild(contentHolder);

        if (data.content.type == "icon" && data.content.value) {
            let id = data.content.value.split("/").pop().replace(".svg", "");
            let svg = DiagramNodeUtils.createSVGDataNode("callout-icon", id, data.content.value, 0, "callout-icon");
            // svg.setAttribute("data-animation", "highlighticon");
            contentHolder.appendChild(svg);
        } else if (data.content.value) {
            let image = document.createElement("img");
            image.className = data.content.type == "logo" || data.content.type == "team" ? "callout-logo" : "callout-image";
            image.id = "callout-image";
            image.src = data.content.value;
            // image.setAttribute("data-animation", "highlightimage");
            contentHolder.appendChild(image);
        }
    }

    let textParent = document.createElement("div");
    textParent.id = "callout-textparent";
    textParent.className = "callout-textparent";
    mainParent.appendChild(textParent);

    if (data.title) {
        let title = document.createElement("div");
        title.id = "callout-title";
        title.className = "callout-title h9";
        title.innerText = data.title;
        // title.setAttribute("data-animation", "highlightshape");
        textParent.appendChild(title);
    }

    if (data.subtitle) {
        let subtitle = document.createElement("div");
        subtitle.id = "callout-subtitle";
        subtitle.className = "callout-subtitle p4";
        subtitle.innerText = data.subtitle;
        // subtitle.setAttribute("data-animation", "highlightshape");
        textParent.appendChild(subtitle);
    }
};

CalloutModel2.prototype.setupAnimation = function (type = "show") {
    if (type == "show") {
        this.isShow = true;
        this.setupShowAnimation();
    }
};

CalloutModel2.prototype.setupShowAnimation = function () {
    this.callOutDiv.style.transform = "rotate(20deg)";
    this.callOutDiv.style.transformOrigin = "left";
    this.callOutDiv.style.opacity = 0;
    if (this.calloutAlignment.includes("left")) {
        this.callOutDiv.style.transform = "rotate(-20deg)";
        this.callOutDiv.style.transformOrigin = "right";
    } else if (this.calloutAlignment.includes("bottom")) {
        this.callOutDiv.style.transformOrigin = "top";
        this.callOutDiv.style.transform = "rotate(20deg)";
    } else if (this.calloutAlignment.includes("top")) {
        this.callOutDiv.style.transformOrigin = "bottom";
        this.callOutDiv.style.transform = "rotate(-20deg)";
    }
};

CalloutModel2.prototype.setupHideAnimation = function () {
    this.callOutDiv.style.transformOrigin = "left";
    if (this.isAnimtion) this.callOutDiv.style.transition = "transform 0.3s, opacity 0.3s";
    this.callOutDiv.style.transform = "rotate(20deg)";
    this.callOutDiv.style.opacity = 0;
    if (this.calloutAlignment.includes("left")) {
        this.callOutDiv.style.transformOrigin = "right";
        this.callOutDiv.style.transform = "rotate(-20deg)";
    } else if (this.calloutAlignment.includes("bottom")) {
        this.callOutDiv.style.transformOrigin = "top";
        this.callOutDiv.style.transform = "rotate(20deg)";
    } else if (this.calloutAlignment.includes("top")) {
        this.callOutDiv.style.transformOrigin = "bottom";
        this.callOutDiv.style.transform = "rotate(-20deg)";
    }
    setTimeout(() => {
        this.data?.callback?.()
    }, this.isAnimtion ? 500 : 0);
};

CalloutModel2.prototype.animate = function () {
    if (this.isShow) {
        if (this.isAnimtion) this.callOutDiv.style.transition = "all 0.3s";
        this.callOutDiv.style.opacity = 1;
        this.callOutDiv.style.transform = "rotate(0deg)";
        setTimeout(() => {
            this.data?.callback?.()
        }, this.isAnimtion ? 500 : 0);
    } else {
        this.setupHideAnimation();
    }
};

CalloutModel2.prototype.svg = function () {
    return '<svg id="pointer-Layer_1" data-name="Layer 1"xmlns="http://www.w3.org/2000/svg" viewBox="0 0 46 42"><path d="M0,12.7S22.5,27,46,0V42.3S4,32.2,0,12.7Z" stroke="none"/></svg>';
};

CalloutModel2.prototype.setPadding = function() {
    if (this.calloutAlignment.includes("left")) {
        this.callOutDiv.style.left = parseFloat(this.callOutDiv.style.left) - 40 + "px";
    }else if (this.calloutAlignment.includes("top")) {
        this.callOutDiv.style.top = parseFloat(this.callOutDiv.style.top) - 40 + "px";
    }
    this.callOutDiv.style.setProperty("--calloutPadding", "40px");
};

/**
 * Author:    Krishna
 * Created:   24 Thu Sep 2020
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function CalloutModel3(diagramParent, data, targetRect, moodData = {}) {
    data.position.secondary = "start";
    let callOut = HighlightTest.call(this, diagramParent, data, targetRect, moodData);
    this.callOutDiv.style.setProperty("--calloutPadding", "0px");
    this.calloutAlignment = this.primaryAlign + this.secondaryAlign;
    this.clearDefaultAnimationProperty();
    this.borderLine = null;
    this.svg = null;
    this.bgShape = null;
    this.pointer = null;
    this.isShow = false;
    this.borderOffset = 10;

    this.setupBgShape();
    this.setPadding();

    // return callOut;
    this.setupAnimation(data.animationtype);
    setTimeout(() => {
        this.animate();
    }, 0);
    
    if(data.assettype!="chart"){
        return callOut;
    }
}

CalloutModel3.prototype = Object.create(HighlightTest.prototype);
CalloutModel3.prototype.constructor = CalloutModel3;

CalloutModel3.prototype.createCallOut = function (parent, data) {
    parent.style.setProperty("--calloutPadding", "0px");
    let clipDiv = document.createElement("div");
    clipDiv.style.overflow = "hidden";
    clipDiv.style.padding = "0px 5px";
    clipDiv.style.width = "100%";

    let mainParent = document.createElement("div");
    mainParent.id = "callout-mainparent";
    mainParent.className = "callout-mainparent";
    mainParent.style.overflow = "hidden";
    mainParent.style.opacity = 1;
    mainParent.style.zIndex = 1;
    clipDiv.appendChild(mainParent);
    parent.appendChild(clipDiv);
    this.textParent = mainParent;

    if (data.content && data.content.type && data.content.type != "none") {
        let contentParent = document.createElement("div");
        contentParent.id = "callout-contentparent";
        contentParent.className = "callout-contentparent";
        contentParent.setAttribute("data-type", data.content.type);
        mainParent.appendChild(contentParent);

        let contentHolder = document.createElement("div");
        contentHolder.id = "callout-contentparent";
        contentHolder.className = data.content.type == "icon" ? "callout-icon" : "callout-image";
        contentParent.appendChild(contentHolder);

        if (data.content.type == "icon" && data.content.value) {
            let id = data.content.value.split("/").pop().replace(".svg", "");
            let svg = DiagramNodeUtils.createSVGDataNode("callout-icon", id, data.content.value, 0, "callout-icon");
            contentHolder.appendChild(svg);
        } else if (data.content.value) {
            let image = document.createElement("img");
            image.className = data.content.type == "logo" || data.content.type == "team" ? "callout-logo" : "callout-image";
            image.id = "callout-image";
            image.src = data.content.value;
            contentHolder.appendChild(image);
        }
    }

    let textParent = document.createElement("div");
    textParent.id = "callout-textparent";
    textParent.className = "callout-textparent";
    mainParent.appendChild(textParent);

    if (data.title) {
        let title = document.createElement("div");
        title.id = "callout-title";
        title.className = "callout-title h9";
        title.innerText = data.title;
        textParent.appendChild(title);
    }

    if (data.subtitle) {
        let subtitle = document.createElement("div");
        subtitle.id = "callout-subtitle";
        subtitle.className = "callout-subtitle p4";
        subtitle.innerText = data.subtitle;
        textParent.appendChild(subtitle);
    }

    let textNode = this.callOutDiv.querySelector("#callout-title");
    this.splitTolines(textNode);
    this.adjustFontClip(this.callOutDiv);
    this.callOutDiv.style.maxWidth = "unset";
};

CalloutModel3.prototype.setupBgShape = function () {
    let svg = DiagramNodeUtils.createSVGElement("svg");
    let width = this.callOutDiv.clientWidth; //+ this.borderOffset * 2;
    let height = this.callOutDiv.clientHeight; //+ this.borderOffset * 2;
    let totalOffsetLeft = 0; //this.borderOffset;
    let totalOffsetTop = 0; //this.borderOffset;
    DiagramNodeUtils.assignAttributes(svg, {
        width: width,
        height: height,
        style: "position:absolute; top:" + totalOffsetTop + "px; left:" + totalOffsetLeft + "px; z-index:0; overflow:visible; ",
        class: "bgsvg",
    });
    this.callOutDiv.appendChild(svg);
    this.svg = svg;

    this.createLine(svg, { x: 0, y: 0, width: width, height: height });
    this.createPointer();
};

CalloutModel3.prototype.createLine = function (svg, svgRect) {
    let lineOffset = 25;

    let l1Svg = DiagramNodeUtils.createSVGElement("g");
    svg.appendChild(l1Svg);
    let p1 = { x: lineOffset, y: 0 };
    let p2 = { x: 0, y: 0 };
    let p3 = { x: 0, y: svgRect.height / 2 };
    let p4 = { x: 0, y: svgRect.height };
    let p5 = { x: lineOffset, y: svgRect.height };
    let l1Top = this.createPath([p2, p3], svg);
    l1Top.id = "l1Top";
    l1Svg.appendChild(l1Top);
    let l1Bot = this.createPath([p3, p4], svg);
    l1Bot.id = "l1Bot";
    l1Svg.appendChild(l1Bot);

    let l2Svg = DiagramNodeUtils.createSVGElement("g");
    l2Svg.id = "endSection";
    l2Svg.setAttribute("class", "endSection");
    svg.appendChild(l2Svg);
    p1 = { x: svgRect.width - lineOffset, y: 0 };
    p2 = { x: svgRect.width, y: 0 };
    p3 = { x: svgRect.width, y: svgRect.height / 2 };
    p4 = { x: svgRect.width, y: svgRect.height };
    p5 = { x: svgRect.width - lineOffset, y: svgRect.height };
    let l2Top = this.createPath([p1, p2, p3], svg);
    l2Top.id = "l2Top";
    l2Svg.appendChild(l2Top);
    let l2Bot = this.createPath([p3, p4, p5], svg);
    l2Bot.id = "l2Bot";
    l2Svg.appendChild(l2Bot);
};

CalloutModel3.prototype.createPath = function (arrpoints, svg) {
    var polyline = DiagramNodeUtils.createSVGElement("polyline");
    polyline.setAttribute("stroke", "rgba(var(--item1-color-rgb), 1)");
    polyline.setAttribute("stroke-width", "2");
    polyline.setAttribute("fill", "none");
    arrpoints.map(function (line) {
        var point = svg.createSVGPoint();
        point.x = line.x;
        point.y = line.y;
        polyline.points.appendItem(point);
    });
    return polyline;
};

CalloutModel3.prototype.createPointer = function () {
    let svgRect = this.svg.getBBox();
    let pointerHeight = svgRect.height / 2;
    let p2 = { x: -15, y: svgRect.height / 2 };
    let p1 = { x: -50, y: svgRect.height / 2 + pointerHeight };
    let p3 = { x: 0, y: svgRect.height / 2 };

    let pointerLine = this.createPath([p1, p2, p3], this.svg);
    pointerLine.id = "pointerLine";
    this.svg.appendChild(pointerLine);

    let dotGrop = DiagramNodeUtils.createSVGElement("g");
    DiagramNodeUtils.assignAttributes(dotGrop, { id: "dot" });
    let dot = DiagramNodeUtils.createSVGElement("circle");
    DiagramNodeUtils.assignAttributes(dot, { cx: p1.x, cy: p1.y, r: 7, stroke: "rgba(var(--item1-color-rgb), 1)", id: "dot" });
    dotGrop.appendChild(dot);

    let dotIn = DiagramNodeUtils.createSVGElement("circle");
    DiagramNodeUtils.assignAttributes(dotIn, { cx: p1.x, cy: p1.y, r: 3, fill: "rgba(var(--item1-color-rgb), 1)" });
    dotGrop.appendChild(dotIn);
    this.svg.appendChild(dotGrop);

    if (this.primaryAlign.includes("left")) {
        this.callOutDiv.style.top = this.callOutDiv.offsetTop - pointerHeight + "px";
    } else if (this.primaryAlign.includes("bottom")) {
        this.callOutDiv.style.top = this.callOutDiv.offsetTop + 20 + "px";
    } else if (this.primaryAlign.includes("top")) {
        this.callOutDiv.style.top = this.callOutDiv.offsetTop - 20 + "px";
    } else {
        this.callOutDiv.style.top = this.callOutDiv.offsetTop - pointerHeight + "px";
    }
};

CalloutModel3.prototype.setupAnimation = function (type = "show") {
    if (type == "show") {
        this.isShow = true;
        this.setupShowAnimation();
    }
};

CalloutModel3.prototype.setupShowAnimation = function () {
    let arrTopLine = Array.from(this.svg.querySelectorAll("[id*='Top']"));
    arrTopLine.map(function (line) {
        line.setAttribute("stroke-dasharray", line.getTotalLength());
        line.setAttribute("stroke-dashoffset", -line.getTotalLength());
    });

    let arrBotLine = Array.from(this.svg.querySelectorAll("[id*='Bot']"));
    arrBotLine.map(function (line) {
        line.setAttribute("stroke-dasharray", line.getTotalLength());
        line.setAttribute("stroke-dashoffset", line.getTotalLength());
    });

    let endLine = this.svg.querySelector("[id='endSection']");
    let transX = this.svg.getBBox().width - endLine.getBBox().width * 6;
    endLine.setAttribute("style", "transform: translateX(-" + transX + "px)");

    let pointerLine = this.svg.querySelector("[id='pointerLine']");
    pointerLine.setAttribute("stroke-dasharray", pointerLine.getTotalLength());
    pointerLine.setAttribute("stroke-dashoffset", pointerLine.getTotalLength());

    let holder = this.callOutDiv.querySelector("[id='callout-mainparent']");
    let arrLines = Array.from(this.callOutDiv.querySelectorAll(".calloutline"));
    arrLines.map(function (line, i) {
        line.style.transform = "translateX(-" + (holder.clientWidth + 10) + "px)";
    });

    let dot = this.callOutDiv.querySelector("#dot");
    if (dot) {
        dot.style.opacity = "0";
    }

    let content = this.callOutDiv.querySelector("#callout-contentparent");
    if (content) {
        content.style.opacity = 0;
    }

    if (this.primaryAlign.includes("left")) {
        let arrLines = Array.from(this.callOutDiv.querySelectorAll(".calloutline"));
        arrLines.map(function (line, i) {
            line.style.transform = "translateX(" + (holder.clientWidth + 10) + "px)";
        });
    } else if (this.primaryAlign.includes("bottom")) {
    } else if (this.primaryAlign.includes("top")) {
    }
};

CalloutModel3.prototype.setupHideAnimation = function () {
    let duration = this.isAnimtion ? 0.5 : 0;
    let pointerDuration = this.isAnimtion ? 0.5 : 0;
    let animationFactor = this.isAnimtion ? 1 : 0;

    let endLine = this.svg.querySelector("[id='endSection']");
    let transX = this.svg.getBBox().width - endLine.getBBox().width * 6;
    endLine.setAttribute("style", "transform: translateX(-" + transX + "px); transition:all " + duration + "s;");

    let holder = this.callOutDiv.querySelector("[id='callout-mainparent']");
    holder.style.transition = "all " + duration + "s";
    // holder.style.transform = "translateX(-" + (holder.clientWidth + 10) + "px)";

    let arrLines = Array.from(this.callOutDiv.querySelectorAll(".calloutline"));
    arrLines.reverse().map(function (line, i) {
        line.style.transition = "all " + duration + "s " + (0.1 * (i + 1) * animationFactor) + "s";
        line.style.transform = "translateX(-" + (holder.clientWidth + 10) + "px)";
        line.style.opacity = animationFactor;
    });

    let lineDelay = (duration + (0.1 * arrLines.length - 1)) * animationFactor;

    setTimeout(() => {
        let content = this.callOutDiv.querySelector("#callout-contentparent");
        if (content) {
            content.style.transition = "all " + duration + "s";
            content.style.opacity = 0;
        }
    }, lineDelay + duration * 1000);

    setTimeout(() => {
        let arrTopLine = Array.from(this.svg.querySelectorAll("[id*='Top']"));
        arrTopLine.map(function (line) {
            line.setAttribute("style", "transition:all " + duration + "s;");
            line.setAttribute("stroke-dasharray", line.getTotalLength());
            line.setAttribute("stroke-dashoffset", -line.getTotalLength());
        });
        let arrBotLine = Array.from(this.svg.querySelectorAll("[id*='Bot']"));
        arrBotLine.map(function (line) {
            line.setAttribute("style", "transition:all " + duration + "s;");
            line.setAttribute("stroke-dasharray", line.getTotalLength());
            line.setAttribute("stroke-dashoffset", line.getTotalLength());
        });
    }, lineDelay + duration + duration * 1000);

    setTimeout(() => {
        let pointerLine = this.svg.querySelector("[id='pointerLine']");
        pointerLine.setAttribute("style", "transition:all " + pointerDuration + "s;");
        pointerLine.setAttribute("stroke-dasharray", pointerLine.getTotalLength());
        pointerLine.setAttribute("stroke-dashoffset", pointerLine.getTotalLength());
    }, (lineDelay + duration + duration + duration) * 1000);

    if (this.primaryAlign.includes("left")) {
        let arrLines = Array.from(this.callOutDiv.querySelectorAll(".calloutline"));
        arrLines.reverse().map(function (line, i) {
            line.style.transition = "all " + duration + "s " + (0.1 * (i + 1) * animationFactor) + "s";
            line.style.transform = "translateX(" + (holder.clientWidth + 10) + "px)";
            line.style.opacity = animationFactor;
        });
    } else if (this.primaryAlign.includes("bottom")) {
    } else if (this.primaryAlign.includes("top")) {
    }
    setTimeout(() => {
        let dot = this.callOutDiv.querySelector("#dot");
        if (dot) {
            dot.style.transition = `all ${0.2*animationFactor}s`//"all 0.2s";
            dot.style.opacity = "0";
        }
        this.data?.callback?.();
    }, (duration + duration + pointerDuration) * 1000 * animationFactor);
};

CalloutModel3.prototype.animate = function () {
    if (this.isShow) {
        let pointerDuration = this.isAnimtion ? 0.5 : 0;
        let duration = this.isAnimtion ? 0.5 : 0;
        let animationFactor = this.isAnimtion ? 1 : 0;

        let dot = this.callOutDiv.querySelector("#dot");
        if (dot) {
            dot.style.transition = `all ${animationFactor*0.2}s`//"all 0.2s";
            dot.style.opacity = 1;
        }
        let pointerLine = this.svg.querySelector("[id='pointerLine']");
        pointerLine.setAttribute("style", "transition:all " + pointerDuration + "s; stroke-dashoffset:0");

        setTimeout(() => {
            let content = this.callOutDiv.querySelector("#callout-contentparent");
            if (content) {
                content.style.transition = "all " + duration + "s";
                content.style.opacity = 1;
            }
        }, pointerDuration * 1000);

        setTimeout(() => {
            let arrLines = Array.from(this.svg.querySelectorAll("[id*='l']"));
            arrLines.map(function (line) {
                line.setAttribute("style", "transition:all " + duration + "s; stroke-dashoffset:0");
            });
        }, pointerDuration * 1000);

        setTimeout(() => {
            let endLine = this.svg.querySelector("[id='endSection']");
            endLine.setAttribute("style", "transition:all " + duration + "s; transform: translateX(0px)");

            let arrLines = Array.from(this.callOutDiv.querySelectorAll(".calloutline"));
            arrLines.map(function (line, i) {
                line.style.transition = "all " + duration + "s " + (0.1 * (i + 1) * animationFactor) + "s";
                line.style.transform = "translateX(0px)";
            });
        }, (duration + pointerDuration) * 1000 * animationFactor);
        setTimeout(() => {
            this.data?.callback?.();
        }, (duration + duration + pointerDuration) * 1000 * animationFactor);
    } else {
        this.setupHideAnimation();
    }
};

CalloutModel3.prototype.setPadding = function () {
    if (this.primaryAlign.includes("left")) {
        this.callOutDiv.style.left = parseFloat(this.callOutDiv.style.left) - 65 + "px";
    } else if (this.primaryAlign.includes("top")) {
        this.callOutDiv.style.left = parseFloat(this.callOutDiv.style.left) + 65 + this.targetRect.width / 2 + "px";
    } else if (this.primaryAlign.includes("bottom")) {
        this.callOutDiv.style.left = parseFloat(this.callOutDiv.style.left) + 65 + this.targetRect.width / 2 + "px";
    } else if (this.primaryAlign.includes("right")) {
        this.callOutDiv.style.left = parseFloat(this.callOutDiv.style.left) + 65 + "px";
    }
};

CalloutModel3.prototype.splitLines = function (textNode) {
    let lastText = textNode.innerHTML.split("</div>");
    if (!!lastText[lastText.length - 1] && !lastText[lastText.length - 1].includes("<div")) {
        let dummeyElement = document.createElement("div");
        dummeyElement.innerHTML = lastText[lastText.length - 1];
        textNode.insertBefore(dummeyElement, textNode.children[0]);
        lastText[lastText.length - 1] = "<div>" + lastText[lastText.length - 1];
        textNode.innerHTML = lastText.join("</div>");
    }
    let newText = textNode.innerHTML.split("<div");
    if (!!newText[0] && !newText[0].includes("<div")) {
        let dummeyElement = document.createElement("div");
        dummeyElement.innerHTML = newText[0];
        textNode.insertBefore(dummeyElement, textNode.children[0]);
        newText[0] = "<div>" + newText[0] + "</div>";
        textNode.innerHTML = newText.join("<div");
    }
};

CalloutModel3.prototype.adjustFontClip = function (callOut) {
    let title = callOut.querySelector("#callout-title");
    if (!title) return;
    title.style.maxHeight = "unset";

    let titleStyleObj = window.getComputedStyle(title);
    let lineHeight = parseFloat(titleStyleObj.lineHeight).toFixed(2);
    let titleHeight = parseFloat(titleStyleObj.height).toFixed(2);
    let noOfLines = title.clientHeight > title.scrollHeight ? (titleHeight / lineHeight).toFixed() : parseInt((titleHeight / lineHeight).toFixed(2));
    title.style.maxHeight = parseFloat(lineHeight * noOfLines) + (noOfLines * 2) + "px";
};

//Alignment functionality

CalloutModel3.prototype.calloutTopSetup = function (callOutDiv, gapInfo, position) {
    this.primaryAlign = "top";
    this.setAlignment(callOutDiv, false, gapInfo, position);
    // if (position.secondary == "auto")
    this.adjustClip(callOutDiv, gapInfo, false);
    callOutDiv.style.top = gapInfo.top - callOutDiv.clientHeight + "px";
    this.clearAlignClass(callOutDiv);

    let gropParent = callOutDiv.querySelector("#callout-mainparent");
    gropParent.classList.add("rightAlign");
};

CalloutModel3.prototype.setAlignment = function (callOutDiv, isVertical, gapInfo, position) {
    if (isVertical) {
        let start = gapInfo.top + "px";
        let center = gapInfo.top + gapInfo.height / 2 - callOutDiv.clientHeight / 2 + "px";
        let end = gapInfo.top + gapInfo.height - callOutDiv.clientHeight + "px";
        let align = position.secondary == "start" ? start : center;
        align = position.secondary == "end" ? end : align;
        callOutDiv.style.top = align;

        this.secondaryAlign = position.secondary == "start" ? "top" : "middle";
        this.secondaryAlign = position.secondary == "end" ? "bottom" : this.secondaryAlign;
    } else {
        let start = gapInfo.left + "px";
        let center = gapInfo.left + gapInfo.width / 2 - callOutDiv.clientWidth / 2 + "px";
        let end = gapInfo.left + gapInfo.width + "px";
        let align = position.secondary == "start" ? start : center;
        align = position.secondary == "end" ? end : align;
        callOutDiv.style.left = start;

        this.secondaryAlign = position.secondary == "start" ? "left" : "center";
        this.secondaryAlign = position.secondary == "end" ? "right" : this.secondaryAlign;
    }

    console.log("position - " + this.primaryAlign + this.secondaryAlign);
    this.callOutDiv.className = "callOut " + this.primaryAlign + this.secondaryAlign;
    this.callOutDiv.setAttribute("data-alignment", this.primaryAlign + this.secondaryAlign);
};

CalloutModel3.prototype.splitTolines = function (TextDiv) {
    let textContent = TextDiv.innerText;
    let arrLine = textContent.split("\n");
    let divDummy = TextDiv.cloneNode(true);
    divDummy.style.width = "auto";
    divDummy.style.maxWidth = "unset";
    divDummy.style.position = "absolute";
    divDummy.innerText = "";
    this.callOutDiv.parentElement.appendChild(divDummy);

    let maxWidth = parseFloat(window.getComputedStyle(TextDiv).maxWidth);
    if (isNaN(maxWidth)) maxWidth = TextDiv.clientWidth;
    TextDiv.innerText = "";

    let content = this.callOutDiv.querySelector("#callout-contentparent");
    if (content) maxWidth = maxWidth - 30 //content padding

    for (let l = 0; l < arrLine.length; l++) {
        let arrWords = arrLine[l].split(" ");
        let subDiv = this.createSplitLine(l == 0, divDummy, "calloutline");

        if (arrLine[l] == "") {
            subDiv.textContent = "";
            subDiv.setAttribute("newLine", "true");
            subDiv.setAttribute("fill", "none");
            subDiv.setAttribute("fill-opacity", "0");
            subDiv.setAttribute("text-shadow", "");
            arrWords = [];
        }

        for (let w = 0; w < arrWords.length; w++) {
            if (w == 0) {
                subDiv.setAttribute("newLine", "true");
                subDiv.textContent = arrWords[0];
            } else {
                subDiv.textContent = subDiv.textContent + (arrWords[w] != " " ? " " : "") + arrWords[w];
            }

            if (subDiv.clientWidth > maxWidth && subDiv.textContent.split(" ").length < 2) {
                subDiv = this.createSplitLine(false, divDummy, "calloutline");
            } else if (subDiv.clientWidth > maxWidth && subDiv.textContent.split(" ").length > 1) {
                let arrCurrentWords = subDiv.textContent.split(" ");
                let lastWord = arrCurrentWords[arrCurrentWords.length - 1];
                subDiv.textContent = subDiv.textContent.substring(0, subDiv.textContent.length - lastWord.length);
                subDiv = this.createSplitLine(false, divDummy, "calloutline");
                subDiv.textContent = lastWord;
                if (subDiv.clientWidth > maxWidth) {
                    subDiv = this.createSplitLine(false, divDummy, "calloutline");
                }
            }
        }
    }

    TextDiv.innerHTML = divDummy.innerHTML;
    divDummy.parentElement.removeChild(divDummy);
};

CalloutModel3.prototype.createSplitLine = function (isFirstLine, parent, lineClass) {
    let subDiv = document.createElement("div");
    subDiv.className = lineClass;
    parent.appendChild(subDiv);
    return subDiv;
};

/**
 * Author:    Krishna Prabhu M
 * Created:   20 May 2020
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function LinearHorizontalTimeline(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "horizontaltimeline";
    this.fontClassName = "timeline";
    this.pageIndex = 1;
    this.totalPage = 1;
    this.itemPerPage = 4;
    this.splitLine = null;
    this.endElement = null;
    this.allAtOnceIndex = 0;
    this.endElementWidth = 0;
    this.animationIndex = 0;
    this.navigationIndex = 0;
    this.startelement = null;
    this.startelementWidth = 0;
    this.animationLine = null;
    this.animateItemCount = 0;
    this.currentPageIndex = 0;
    this.isForwardAnimation = 0;
    this.isReversAnimation = 0;
    this.isStartEnable = true;
    this.isEndEnable = true;
    this.arrConnectorPoints = null;

    this.padding = 0;
    this.cubicPath = "";
    this.pageEpsilon = 0.1;
    this.isRenderComplete = false;
    this.animationFactor = 1;

    this.diagramParent.setAttribute("data-toggleassets", "true");
    this.diagramParent.setAttribute("data-togglecategory", "hor-timeline-tx-sty-a-1-sec");
    this.diagramParent.setAttribute("data-currencyformat", "disable");
}

LinearHorizontalTimeline.prototype = Object.create(SimpleLinearDiagram.prototype);
LinearHorizontalTimeline.prototype.constructor = LinearHorizontalTimeline;

LinearHorizontalTimeline.prototype.initDiagramCreation = function () {
    this.diagramParent.parentElement.style.overflow = "hidden";
    this.diagramParent.parentElement.removeAttribute("graphicanimateid");
    this.diagramParent.parentElement.setAttribute("data-ismultislide", "true");

    this.diagramParent.innerHTML = "";
    this.diagramParent.style.setProperty("--contentResizeMH", "unset");
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.createPatternBackGround();
    this.diagramRenderComplete();
};

LinearHorizontalTimeline.prototype.updateElements = function (defaultproperties) {
    SimpleLinearDiagram.prototype.updateElements.call(this, defaultproperties);

    let timelineId = "timeline-" + this.diagramParent.getAttribute("parent-Id");
    let timelineElement = this.diagramParent.parentElement.querySelector("[id='" + timelineId + "']");

    this.totalPage = 1;
    this.pageIndex = 1;
    this.allAtOnceIndex = 0;
    this.animationIndex = 0;
    this.navigationIndex = 0;
    this.currentPageIndex = 0;
    this.isForwardAnimation = 0;
    this.isReversAnimation = 0;
    this.pageEpsilon = 0.1;

    if (timelineElement) {
        this.splitLine = timelineElement.firstElementChild;
        // this.splitLine.setAttribute("data-create", Math.random());
        this.arrConnectorPoints = Array.from(this.splitLine.querySelectorAll("[id='connectorpoint']"));

        this.animationLine = timelineElement.querySelector("[id='animationLine']");
        this.startElement = timelineElement.querySelector("[id='timelinestartelement']");
        this.endElement = timelineElement.querySelector("[id='timelineendelement']");

        this.totalPage = Math.ceil(this.splitLine.parentElement.offsetWidth / this.diagramParent.parentElement.offsetWidth - this.pageEpsilon);
        this.diagramParent.style.transform = "translateX(0px)";
        this.splitLine.parentElement.style.transform = "translateX(0px)";

        this.isStartEnable = this.diagramParent.dataset.isstartenable && this.diagramParent.dataset.isstartenable == "false" ? false : true;
        this.isEndEnable = this.diagramParent.dataset.isendenable && this.diagramParent.dataset.isendenable == "false" ? false : true;

        this.updateTimelineElements();
        this.setDiagramWidth();
        this.currentPageIndex = 0;
    }
};

LinearHorizontalTimeline.prototype.recreateElementData = function () {
    SimpleLinearDiagram.prototype.recreateElementData.call(this);
    let timelineId = "timeline-" + this.diagramParent.getAttribute("parent-Id");
    let timelineElement = this.diagramParent.parentElement.querySelector("[id='" + timelineId + "']");
    if (timelineElement) {
        this.splitLine = timelineElement.firstElementChild;
        this.arrConnectorPoints = Array.from(this.splitLine.querySelectorAll("[id='connectorpoint']"));

        this.animationLine = timelineElement.querySelector("[id='animationLine']");
        this.startElement = timelineElement.querySelector("[id='timelinestartelement']");
        this.endElement = timelineElement.querySelector("[id='timelineendelement']");

        this.totalPage = Math.ceil(this.splitLine.parentElement.offsetWidth / this.diagramParent.parentElement.offsetWidth - this.pageEpsilon);
        this.diagramParent.style.transform = "translateX(0px)";
        this.splitLine.parentElement.style.transform = "translateX(0px)";
    }
};

LinearHorizontalTimeline.prototype.addNode = function (nodeData, index, isFromUndo = false) {
    SimpleLinearDiagram.prototype.addNode.call(this, nodeData, index, isFromUndo);
    this.drawTimeline();
    this.setDiagramWidth();
    this.resetHolderWidth();
    this.totalPage = Math.ceil(this.splitLine.parentElement.offsetWidth / this.diagramParent.parentElement.offsetWidth - this.pageEpsilon);
    this.currentPageIndex = this.totalPage - 1;
    if (this.createZigZagPath) this.createZigZagPath();
    this.gotoPage(this.currentPageIndex);
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
};

LinearHorizontalTimeline.prototype.swapNodes = function (objData, swapNodeIndex) {
    SimpleLinearDiagram.prototype.swapNodes.call(this, objData, swapNodeIndex);
    let pIndex = this.currentPageIndex;
    this.drawTimeline();
    this.setDiagramWidth();
    if (this.createZigZagPath) this.createZigZagPath();
    this.currentPageIndex = pIndex;
    this.gotoPage(pIndex);
};

LinearHorizontalTimeline.prototype.setDiagramWidth = function () {
    this.startElementPadding = this.isStartEnable ? 0 : 0;
    this.endElementPadding = this.isEndEnable ? 0 : 0;
    this.startElement.style.display = this.isStartEnable ? "flex" : "none";
    this.endElement.style.display = this.isEndEnable ? "flex" : "none";

    this.diagramParent.setAttribute("data-isstartenable", this.isStartEnable);
    this.diagramParent.setAttribute("data-isendenable", this.isEndEnable);

    this.diagramParent.style.setProperty("--commonnodeitemwidth", "calc(100% - 20px)", "important");
    this.diagramParent.style.setProperty("--timelinecintentwidth", this.diagramParent.clientHeight * 0.166 + "px", "important");

    let nodeOrder = this.getNodePostion();
    let arr = this.splitArrayWithOrder(nodeOrder, this.arrDiagramNode);
    let widthObj = this.setNodelWidth(arr);

    let parentStyle = window.getComputedStyle(this.diagramParent);
    let paddigleft = parseFloat(parentStyle.paddingLeft);
    let paddingright = parseFloat(parentStyle.paddingRight);

    this.diagramParent.style.minWidth = widthObj.parentWidth + "px";
    this.diagramParent.style.width = widthObj.parentWidth + paddigleft + paddingright + "px";
    this.splitLine.parentElement.style.width = widthObj.parentWidth + paddigleft + paddingright + this.startElementPadding + this.endElementPadding + "px";

    this.totalPage = Math.ceil(this.splitLine.parentElement.offsetWidth / this.diagramParent.parentElement.offsetWidth - this.pageEpsilon);

    let secContentMaxHeight = this.diagramParent.clientHeight / 2 - 30; //30 dot size + sec padding
    this.diagramParent.style.setProperty("--secContentMaxHeight", secContentMaxHeight + "px");

    this.updateTimelineElements();

    //below block of code is to set the animation line width dependes on the start and end element
    {
        let arrPoints = Array.from(this.splitLine.querySelectorAll("[id='connectorpoint']"));
        let startPoint = arrPoints.at(0);
        let endPoint = arrPoints.at(-1);
        let startRect = DiagramNodeUtils.getOffsetRectByParent(this.splitLine, startPoint);
        let endRect = DiagramNodeUtils.getOffsetRectByParent(this.splitLine, endPoint);

        this.animationLine.style.width = "100%";

        if (this.isStartEnable) {
            this.animationLine.style.left = "0px";
        } else {
            this.animationLine.style.left = startRect.x + startRect.width / 2 + "px";
            this.animationLine.style.width = "calc(100% - " + (startRect.x + startRect.width / 2) + "px)";
        }

        if (this.isEndEnable) {
            this.animationLine.style.width = this.isStartEnable ? "100%" : "calc(100% - " + (startRect.x + startRect.width / 2) + "px)";
        } else {
            let diff = Math.abs(this.splitLine.clientWidth - endRect.x);
            this.animationLine.style.width = this.animationLine.clientWidth - diff + "px";
        }
    }

    this.setOffsetLeftTop();
};

LinearHorizontalTimeline.prototype.setNodelWidth = function (arrOrderedNodes) {
    let parentStyle = window.getComputedStyle(this.diagramParent);
    let paddigleft = parseFloat(parentStyle.paddingLeft);
    let paddingright = parseFloat(parentStyle.paddingRight);

    let firstSlideOffsetWidth = this.isStartEnable ? paddigleft : 0;
    let lastSlideOffsetWidth = this.isEndEnable ? paddingright : 0;
    firstSlideOffsetWidth = arrOrderedNodes.length == 1 ? firstSlideOffsetWidth + lastSlideOffsetWidth : firstSlideOffsetWidth;

    let marginLeft = parseFloat(parentStyle.marginLeft);
    let marginRight = parseFloat(parentStyle.marginRight);

    let slideEndPadding = arrOrderedNodes.length > 1 ? marginLeft : 0;
    let padding = arrOrderedNodes.length > 1 ? marginLeft : marginLeft + marginRight;
    let firstSlideWidth = this.diagramParent.parentElement.clientWidth - padding - firstSlideOffsetWidth - slideEndPadding;
    let centerSlideWidth = this.diagramParent.parentElement.clientWidth - slideEndPadding * 2;
    let lastSlideWidth = this.diagramParent.parentElement.clientWidth - padding - lastSlideOffsetWidth - slideEndPadding;
    let totalWidth = 0;
    let diffWidth = 0;
    let firstNodeWidth = 0;

    for (var i = 0; i < arrOrderedNodes.length; i++) {
        if (i == 0) {
            //first slide
            let nodeWidth = firstSlideWidth / arrOrderedNodes[i].length;
            firstNodeWidth = nodeWidth;
            this.updateSlideBasedNodeWidth(arrOrderedNodes[i], nodeWidth, slideEndPadding, "start");
            totalWidth = totalWidth + firstSlideWidth + slideEndPadding;
        } else if (i == arrOrderedNodes.length - 1) {
            //last slide
            let nodeWidth = lastSlideWidth / arrOrderedNodes[i].length;
            let diffWidthCount = arrOrderedNodes[i].length - arrOrderedNodes[i].length;
            diffWidth = nodeWidth * diffWidthCount;
            this.updateSlideBasedNodeWidth(arrOrderedNodes[i], nodeWidth, slideEndPadding, "end");
            totalWidth = totalWidth + lastSlideWidth + slideEndPadding;
        } else {
            //remaining slide
            let nodeWidth = centerSlideWidth / arrOrderedNodes[i].length;
            this.updateSlideBasedNodeWidth(arrOrderedNodes[i], nodeWidth, slideEndPadding, "mid");
            totalWidth = totalWidth + centerSlideWidth + slideEndPadding * 2;
        }
    }

    let timelineWidth = totalWidth - diffWidth;

    return { parentWidth: totalWidth, timelineWidth: timelineWidth, nodeWidth: firstNodeWidth };
};

LinearHorizontalTimeline.prototype.deleteNode = function (targetIndex) {
    SimpleLinearDiagram.prototype.deleteNode.call(this, targetIndex);
    this.drawTimeline();
    this.setDiagramWidth();
    if (this.createZigZagPath) this.createZigZagPath();
    this.gotoPage(this.pageIndex);
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
};

LinearHorizontalTimeline.prototype.getCustomProperties = function () {
    let props = {
        timeline: {
            type: this.diagramParent.dataset.timelinetype || "horizontal",
            style: this.diagramParent.dataset.timelinestyle || "strigntline",
            startelement: this.diagramParent.dataset.startelement && this.diagramParent.dataset.startelement == "false" ? false : true,
            endelement: this.diagramParent.dataset.endelement && this.diagramParent.dataset.endelement == "false" ? false : true,
            isstartenable: this.diagramParent.dataset.isstartenable && this.diagramParent.dataset.isstartenable == "false" ? false : true,
            isendenable: this.diagramParent.dataset.isendenable && this.diagramParent.dataset.isendenable == "false" ? false : true,
            position: this.diagramParent.dataset.timelineposition || "middle",
            element: this.diagramParent.dataset.timelineelement || "diagramContentNode",
        },
        nodeconnector: {
            visible: this.diagramParent.dataset.connectorvisible && this.diagramParent.dataset.connectorvisible == "false" ? false : true,
            connectorline: true,
            connectingobject: this.diagramParent.dataset.connectorconnectingobject || "diagramContentNode",
            position: this.diagramData?.properties?.connectorposition || "middle",
        },
        node: {
            position: "middle",
            positionoffset: 50,
            split: true,
            splitalign: "alternate",
            splitorder: "order1",
            splitgap: this.diagramParent.dataset.connectorgap || Math.min(this.diagramParent.clientHeight * 0.2, 100),
        },
    };
    return props;
};

LinearHorizontalTimeline.prototype.setGroupWidth = function () {
    // return
    let pattenDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    if (pattenDiv) {
        pattenDiv.style.setProperty("--contentWidth", "100px");
        try {
            if (this.arrDiagramNode[0].getNodeParent().querySelector("[data-id='diagramContentNode']").querySelector("[data-id='contentnumberparent']")) {
                pattenDiv.style.setProperty("--contentWidth", "170px");
            }
        } catch (error) {
            console.log("LinearHorizontalTimeline.prototype.setGroupWidth " + error);
        }
    }
};

// primaryTextNode secondaryTextNode diagramContentNode sequenceTextNode
LinearHorizontalTimeline.prototype.customproperties = function () {
    return {
        isstartenable: !this.diagramParent.dataset.hasOwnProperty("isstartenable") || this.diagramParent.dataset.isstartenable == "true",
        isendenable: !this.diagramParent.dataset.hasOwnProperty("isendenable") || this.diagramParent.dataset.isendenable == "true",
        isyearenable: !this.diagramParent.dataset.hasOwnProperty("isyearenable") || this.diagramParent.dataset.isyearenable == "true",
    };
};

LinearHorizontalTimeline.prototype.getProperties = function (defaultproperties = {}) {
    let properties = SimpleLinearDiagram.prototype.getProperties.call(this, defaultproperties);
    properties.customproperties = this.customproperties();
    return properties;
};

LinearHorizontalTimeline.prototype.setPropertiesFromConstants = function (mainObj, constArrProperties, extraAttrib = "") {
    SimpleLinearDiagram.prototype.setPropertiesFromConstants.call(this, mainObj, constArrProperties, extraAttrib);
    if (this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.hasOwnProperty("isstartenable")) {
        this.diagramParent.setAttribute("data-isstartenable", this.diagramData.properties.customproperties.isstartenable);
    }
    if (this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.hasOwnProperty("isendenable")) {
        this.diagramParent.setAttribute("data-isendenable", this.diagramData.properties.customproperties.isendenable);
    }
    if (this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.hasOwnProperty("isyearenable")) {
        this.diagramParent.setAttribute("data-isyearenable", this.diagramData.properties.customproperties.isyearenable);
    }
};

// ****** Timeline related function

LinearHorizontalTimeline.prototype.drawTimeline = function () {
    this.arrConnectorPoints = [];
    let oldTimeline = this.diagramParent.parentElement.querySelector(".timeline");
    if (oldTimeline) {
        oldTimeline.parentElement.removeChild(oldTimeline);
        this.splitLine = null;
    }

    this.totalPage = 1;
    this.currentPageIndex = 0;
    this.diagramParent.style.transform = "translateX(0px)";

    let timeline = document.createElement("div");
    timeline.className = "timeline" + " " + (this.nodeProps?.timelineclass || "");
    timeline.id = "timeline-" + this.diagramParent.getAttribute("parent-Id");
    timeline.setAttribute("data-id", "timeline");
    this.diagramParent.parentElement.appendChild(timeline);

    let splitLine = document.createElement("div");
    splitLine.className = "splitline clsMultiColorParent";
    splitLine.id = "splitline";
    timeline.appendChild(splitLine);
    this.splitLine = splitLine;
    this.splitLine.setAttribute("data-create", Math.random());

    let animationLine = document.createElement("div");
    animationLine.className = "animationline clsNodeAccentbg";
    DiagramUtils.setCustomItemColor(animationLine, this.arrTintArray, 0, 1);
    animationLine.id = "animationLine";
    splitLine.appendChild(animationLine);
    this.animationLine = animationLine;

    let startElement = document.createElement("div");
    startElement.className = "timelinestartelement theme-border-color secondary-color p5";
    startElement.id = "timelinestartelement";
    startElement.innerText = "START";
    timeline.appendChild(startElement);
    this.startElement = startElement;

    let endElement = document.createElement("div");
    endElement.className = "timelineendelement theme-border-color secondary-color p5";
    endElement.id = "timelineendelement";
    endElement.innerText = "END";
    timeline.appendChild(endElement);
    this.endElement = endElement;

    if (this.diagramData.properties.customproperties.hasOwnProperty("isyearenable")) {
        this.diagramParent.style.setProperty("--yearDisplay", this.diagramData.properties.customproperties.isyearenable ? "flex" : "none");
        if (this.isNumberStyle()) {
            this.splitLine.style.setProperty("--pointerlineOpacity", this.diagramData.properties.customproperties.isyearenable ? "1" : "0");
        } else this.splitLine.style.setProperty("--pointerlineOpacity", "1");
    }
};

LinearHorizontalTimeline.prototype.isNumberStyle = function () {
    let arrContent = this.nodeProps.supportedNodes.filter((node) => node.name == "contentNode");
    if (arrContent.length > 0 && arrContent[0].subNodes.length > 0 && arrContent[0].subNodes[0].name == "valueTitleHolder") {
        return true;
    }
    return false;
};

LinearHorizontalTimeline.prototype.updateTimelineElements = function () {
    this.timelinePosition();
    this.updateConnectorPoints();
    this.arrDiagramNode?.[0]?.updateTextSingleLineHeight?.();
    this.updateNodePosition();
    if (this.getCustomProperties().nodeconnector.connectorline == true) this.updateConnectorLine();
    if (this.diagramParent.dataset.projectionindex) this.setProjection(this.diagramParent.dataset.projectionindex);
};

LinearHorizontalTimeline.prototype.showHideStartEnd = function (operation) {
    if (operation.property == "start") {
        this.isStartEnable = operation.value;
        this.diagramParent.setAttribute("data-isstartenable", operation.value);
        this.diagramData.properties.customproperties.isstartenable = operation.value;
    } else if (operation.property == "end") {
        this.isEndEnable = operation.value;
        this.diagramParent.setAttribute("data-isendenable", operation.value);
        this.diagramData.properties.customproperties.isendenable = operation.value;
    }

    this.setDiagramWidth();
    if (this.createZigZagPath) this.createZigZagPath();
};

LinearHorizontalTimeline.prototype.showHideYear = function (operation) {
    this.diagramParent.setAttribute("data-isyearenable", operation.value);
    this.diagramData.properties.customproperties.isyearenable = operation.value;
    this.diagramParent.style.setProperty("--yearDisplay", operation.value ? "flex" : "none");
    if (this.isNumberStyle()) {
        this.splitLine.style.setProperty("--pointerlineOpacity", operation.value ? "1" : "0");
    } else this.splitLine.style.setProperty("--pointerlineOpacity", "1");

    this.resetLayout();
};

LinearHorizontalTimeline.prototype.timelinePosition = function () {
    switch (this.getCustomProperties().timeline.position) {
        case "top":
            this.splitLine.parentElement.style.top = 0;
            break;
        case "middle":
            this.splitLine.parentElement.style.top = this.diagramParent.clientHeight / 2 - this.splitLine.parentElement.clientHeight / 2 + "px";
            break;
        case "bottom":
            this.splitLine.parentElement.style.bottom = 0;
            break;
    }
};

// ****** Connector related function

LinearHorizontalTimeline.prototype.updateConnectorPoints = function () {
    if (this.splitLine == null || this.getCustomProperties().nodeconnector.visible == false) return;

    while (this.arrConnectorPoints.length < this.arrDiagramNode.length) {
        let connectorPoint = document.createElement("div");
        connectorPoint.className = "connectorpoint theme-border-color";
        connectorPoint.id = "connectorpoint";
        this.splitLine.appendChild(connectorPoint);

        if (this.getCustomProperties().nodeconnector.connectorline == true) {
            let connectorLine = document.createElement("div");
            connectorLine.className = "connectorline";
            connectorLine.id = "connectorline";
            connectorPoint.appendChild(connectorLine);

            let svg = this.createSvgElement("svg", { style: "width:100%; height:100%" });
            connectorLine.appendChild(svg);
            let path = this.createSvgElement("path", {});
            path.setAttribute("stroke", "var(--timeline-stroke-color)");
            path.setAttribute("stroke-dasharray", "4");
            path.setAttribute("class", "connector-path");
            svg.appendChild(path);
        }

        this.arrConnectorPoints.push(connectorPoint);
    }

    while (this.arrConnectorPoints.length > this.arrDiagramNode.length) {
        let point = this.arrConnectorPoints[this.arrConnectorPoints.length - 1];
        point.parentElement.removeChild(point);
        this.arrConnectorPoints.pop();
    }

    let connectorPosition = this.getCustomProperties().nodeconnector.position || "middle";
    let arrPoints = this.splitLine.querySelectorAll("[id='connectorpoint']");
    this.arrDiagramNode.map(
        function (node, i) {
            let point = arrPoints[i];
            let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
            let nodeRect = DiagramNodeUtils.getOffsetRectByParent(nodeHolder, node.nodeGroup);

            let centerX = nodeRect.x; //+ nodeRect.width / 2;
            centerX = centerX; //- point.offsetWidth / 2;
            if (connectorPosition == "middle") {
                centerX = nodeRect.x + nodeRect.width / 2;
                centerX = centerX - point.offsetWidth / 2;
            } else if (connectorPosition == "right") {
                centerX = nodeRect.x + nodeRect.width;
                centerX = centerX - point.offsetWidth;
            }

            if (point) point.style.left = `calc(${centerX}px - var(--timelinestartwidth, 0px))`;
        }.bind(this)
    );
};

LinearHorizontalTimeline.prototype.updateConnectorLine = function () {
    this.arrConnectorPoints.map(
        function (connector, index) {
            let targetNodeId = this.getCustomProperties().nodeconnector.connectingobject;
            let node = this.arrDiagramNode[index].nodeGroup;
            let timelineobj = node.querySelector("[data-id*='" + targetNodeId + "']");
            let timelineobjRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, timelineobj); //timelineobj.getBoundingClientRect();
            let connectorRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, connector); //connector.getBoundingClientRect();

            let splitPosition = this.getCustomProperties().node.splitalign;
            let nodePosition = this.getCustomProperties().node.position;
            let isApplySplit = this.getCustomProperties().node.split;
            nodePosition = isApplySplit ? splitPosition : nodePosition;

            let height = 30;
            switch (nodePosition) {
                case "top":
                    height = connectorRect.top - (timelineobjRect.top + timelineobjRect.height);
                    connector.firstElementChild.style.top = "unset";
                    connector.firstElementChild.style.bottom = connector.clientHeight + "px";
                    this.updateDottedLineHeight(connector, height);
                    break;
                case "bottom":
                    height = timelineobjRect.top - (connectorRect.top + connectorRect.height);
                    connector.firstElementChild.style.bottom = "unset";
                    connector.firstElementChild.style.top = connector.clientHeight + "px";
                    this.updateDottedLineHeight(connector, height, false);
                    break;
                case "alternate":
                    if (index % 2 == 0) {
                        height = connectorRect.top - (timelineobjRect.top + timelineobjRect.height);
                        connector.firstElementChild.style.top = "unset";
                        connector.firstElementChild.style.bottom = connector.clientHeight + "px";
                        this.updateDottedLineHeight(connector, height);
                    } else {
                        height = timelineobjRect.top - (connectorRect.top + connectorRect.height);
                        connector.firstElementChild.style.bottom = "unset";
                        connector.firstElementChild.style.top = connector.clientHeight + "px";
                        this.updateDottedLineHeight(connector, height, false);
                    }
                    break;
            }
        }.bind(this)
    );
};

LinearHorizontalTimeline.prototype.updateDottedLineHeight = function (connector, height, isTop = true) {
    connector.firstElementChild.style.height = Math.abs(height) + "px";
    connector.firstElementChild.setAttribute("data-height", connector.firstElementChild.style.height);
    let svg = connector.firstElementChild.firstElementChild;
    let svgRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, connector.firstElementChild); //connector.firstElementChild.getBoundingClientRect();
    let d = "M" + svgRect.width / 2 + " 5  L" + svgRect.width / 2 + " " + (svgRect.height - 10) + "";
    d = isTop ? d : "M" + svgRect.width / 2 + " 10  L" + svgRect.width / 2 + " " + (svgRect.height - 5) + "";
    svg.firstElementChild.setAttribute("d", d);
    svg.firstElementChild.setAttribute("stroke-width", connector.firstElementChild.clientWidth);
};

LinearHorizontalTimeline.prototype.createSvgElement = function (tag, attrs) {
    var el = document.createElementNS("http://www.w3.org/2000/svg", tag);
    for (var k in attrs) {
        if (k == "xlink:href") {
            el.setAttributeNS("http://www.w3.org/1999/xlink", "href", attrs[k]);
        } else {
            el.setAttribute(k, attrs[k]);
        }
    }
    return el;
};

// ******* Node Position related function

LinearHorizontalTimeline.prototype.updateNodePosition = function () {
    let isApplySplit = this.getCustomProperties().node.split;
    switch (this.getCustomProperties().node.position) {
        case "top":
            this.nodeAlignTop();
            break;
        case "bottom":
            this.nodeAlignBottom();
            break;
        case "alternate":
            this.nodeAlignAlternate();
            break;
        case "middle":
            isApplySplit ? this.nodeAlignSplit() : this.nodeAlignMiddle();
            break;
    }
};

LinearHorizontalTimeline.prototype.nodeAlignTop = function () {
    this.arrDiagramNode.map(
        function (node, index) {
            let center = this.splitLine.parentElement.offsetTop + this.splitLine.parentElement.offsetHeight / 2;
            let offset = this.getCustomProperties().node.positionoffset;
            node.nodeGroup.style.bottom = center + offset + "px";
            node.nodeGroup.setAttribute("data-align-position", "top");
        }.bind(this)
    );
};

LinearHorizontalTimeline.prototype.nodeAlignBottom = function () {
    this.arrDiagramNode.map(
        function (node, index) {
            let center = this.splitLine.parentElement.offsetTop + this.splitLine.parentElement.offsetHeight / 2;
            let offset = this.getCustomProperties().node.positionoffset;
            node.nodeGroup.style.top = center + offset + "px";
            node.nodeGroup.setAttribute("data-align-position", "bottom");
        }.bind(this)
    );
};

LinearHorizontalTimeline.prototype.nodeAlignMiddle = function () {
    this.arrDiagramNode.map(
        function (node, index) {
            this.alternateOrder(node.nodeGroup, index);
            let targetId = this.getCustomProperties().timeline.element;
            let nodeItem = node.nodeGroup;
            let targetObj = node.nodeGroup.querySelector("[id*='" + targetId + "']");

            let timelineRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, this.splitLine); //this.splitLine.getBoundingClientRect();
            let timelineCenter = timelineRect.top + timelineRect.height / 2;

            let targetObjRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, targetObj); //targetObj.getBoundingClientRect();
            let targetObjCenter = targetObjRect.top + targetObjRect.height / 2;

            let centerDiff = timelineCenter - targetObjCenter;
            nodeItem.style.top = nodeItem.offsetTop + centerDiff + "px";
        }.bind(this)
    );
};

LinearHorizontalTimeline.prototype.nodeAlignAlternate = function () {
    this.arrDiagramNode.map(
        function (node, index) {
            let center = this.splitLine.parentElement.offsetTop + this.splitLine.parentElement.offsetHeight / 2;
            let offset = this.getCustomProperties().node.positionoffset;
            if (index % 2 == 0) {
                node.nodeGroup.style.top = "unset";
                node.nodeGroup.style.bottom = center + offset + "px";
                node.nodeGroup.setAttribute("data-align-position", "top");
            } else {
                node.nodeGroup.style.bottom = "unset";
                node.nodeGroup.style.top = center + offset + "px";
                node.nodeGroup.setAttribute("data-align-position", "bottom");
            }
        }.bind(this)
    );
};

LinearHorizontalTimeline.prototype.unsetSequenceTextMargin = function () {
    this.arrDiagramNode.map(function (node) {
        let sequenceText = node.nodeGroup.querySelector("[id*='sequenceTextNode']");
        if (sequenceText) sequenceText.style.setProperty("margin", 0, "important");
    });
};

LinearHorizontalTimeline.prototype.nodeAlignSplit = function () {
    this.arrDiagramNode.map(
        function (node, index) {
            let targetId = this.getCustomProperties().timeline.element;
            let nodeItem = node.nodeGroup;
            let targetObj = node.nodeGroup.querySelector("[data-id*='" + targetId + "']");

            let splitGap = parseFloat(this.getCustomProperties().node.splitgap);
            let splitAlign = this.getCustomProperties().node.splitalign;

            targetObj.style.marginTop = "unset";
            targetObj.style.marginBottom = "unset";

            // let secContentNode = node.nodeGroup.querySelector("[name='secContentNode']");
            // if (secContentNode) {
            //     secContentNode.style.maxHeight = this.splitLine.parentElement.offsetTop + this.splitLine.parentElement.clientHeight / 2 - 14 + "px";
            // }

            switch (splitAlign) {
                case "top":
                    targetObj.style.marginBottom = splitGap + "px";
                    targetObj.style.setProperty("margin-bottom", splitGap + "px", "important");
                    this.alignTimelineElement(nodeItem, targetObj, splitGap);
                    break;
                case "bottom":
                    targetObj.style.marginTop = splitGap + "px";
                    targetObj.style.setProperty("margin-top", splitGap + "px", "important");
                    this.alignTimelineElement(nodeItem, targetObj, splitGap, "bottom");
                    break;
                case "alternate":
                    this.alternateOrder(node.nodeGroup, index);
                    if (index % 2 == 0) {
                        targetObj.style.marginBottom = splitGap + "px";
                        targetObj.style.setProperty("margin-bottom", splitGap + "px", "important");
                        this.alignTimelineElement(nodeItem, targetObj, splitGap);
                    } else {
                        targetObj.style.marginTop = splitGap + "px";
                        targetObj.style.setProperty("margin-top", splitGap + "px", "important");
                        this.alignTimelineElement(nodeItem, targetObj, splitGap, "bottom");
                    }
            }
        }.bind(this)
    );
};

LinearHorizontalTimeline.prototype.alternateOrder = function (node, index) {
    let arrOrder = [
        [2, 1, 3, 0],
        [1, 2, 0, 3],
    ];

    let primary = node.querySelector("[data-id*='primaryTextNode']");
    let number = node.querySelector("[data-id*='contentnumberparent']");
    let secondary = node.querySelector("[data-id*='secondaryTextNode']");
    let content = node.querySelector("[data-id*='diagramContentNode']");

    primary.style.order = arrOrder[index % 2][0];
    if (number) number.style.order = arrOrder[index % 2][1];
    secondary.style.order = arrOrder[index % 2][2];
    content.style.order = arrOrder[index % 2][3];
};

LinearHorizontalTimeline.prototype.alignTimelineElement = function (nodeItem, targetObj, splitGap = 0, align = "top") {
    nodeItem.style.bottom = "unset";
    nodeItem.style.top = "unset";
    let timelineRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, this.splitLine); //this.splitLine.getBoundingClientRect();
    let timelineCenter = timelineRect.top + timelineRect.height / 2;

    nodeItem.parentElement.setAttribute("data-align-position", align);
    let targetObjRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, targetObj); //targetObj.getBoundingClientRect();
    let connector = this.arrConnectorPoints[0];
    let connectorHeight = connector ? connector.clientHeight : 0;

    if (align == "top") {
        // nodeItem.style.bottom = "unset";
        let targetObjCenter = targetObjRect.top + targetObjRect.height;
        let centerDiff = timelineCenter - targetObjCenter;
        nodeItem.style.top = nodeItem.offsetTop + centerDiff - (splitGap - connectorHeight) + "px";
    } else {
        // nodeItem.style.top = "unset";
        let targetObjCenter = targetObjRect.top;
        let centerDiff = timelineCenter - targetObjCenter;
        // nodeItem.style.top = nodeItem.offsetTop + centerDiff + (splitGap - connectorHeight / 1.5);
        let objTop = nodeItem.offsetTop + centerDiff + (splitGap - connectorHeight);
        let objBottom = nodeItem.parentElement.clientHeight - (objTop + nodeItem.clientHeight);
        nodeItem.style.bottom = objBottom + "px";
    }
    this.setValueAlign(nodeItem, align);
};

LinearHorizontalTimeline.prototype.setValueAlign = function (node, align) {
    let primaryContent = node.querySelector("[data-id='diagramContentNode']");
    if (primaryContent) {
        let valText = primaryContent.querySelector("[name='numberNode']");
        if (valText) primaryContent.style.alignItems = align == "top" ? "flex-end" : "flex-start";
    }
};

// LinearHorizontalTimeline.prototype.focusCallBack = function(event) {
//     let index = event.target.dataset.index;
//     let nodeItem = this.diagramParent.querySelector("[id='nodeitem" + index + "']");
//     if (event.type == "focusin") {
//     } else if (event.type == "focusout") {
//         if (event.target.getAttribute("data-node-type") == "content") {
//             return;
//         }
//         this.resizeConnectors();
//         this.resetNodeAttributes();
//         DiagramResizeUtils.resetFontSizeForType(this.diagramParent, event.target.dataset.id);
//         this.searchIcon(event.target.innerText, nodeItem, event.target.dataset.index, this.diagramData.properties.contenttype);
//     }
// };

LinearHorizontalTimeline.prototype.setupAnimation = function (animationType, callback) {
    this.animationCompleteCallback = callback;
    this.animationType = animationType;
    this.highlightIndex = -1;

    this.diagramParent.style.transform = "translateX(0px)";

    this.pageIndex = 0;
    this.totalPage = Math.ceil(this.splitLine.parentElement.offsetWidth / this.diagramParent.parentElement.offsetWidth - this.pageEpsilon);
    this.animationIndex = 0;
    this.currentPageIndex = 0;
    this.animateItemCount = 0;
    this.allAtOnceIndex = 0;
    this.nodeAnimationTime = animationType == "all" ? 6 : 1;
    this.animationFactor = this.diagramParent.parentElement.dataset.moodanimation && this.diagramParent.parentElement.dataset.moodanimation == "none" ? 0 : 1;

    this.diagramParent.style.transform = "translateX(0px)";
    this.splitLine.parentElement.style.transform = "translateX(0px)";

    if (this.animationType == "none" || this.moodData.animationData.multislideAnimation) {
        this.diagramParent.style.opacity = 1;
        this.splitLine = this.diagramParent.parentElement.querySelector("[id='splitline']");
        if (this.splitLine && this.splitLine.parentElement) this.splitLine.parentElement.style.opacity = 1;
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return;
    }

    this.arrDiagramNode.map(
        function (node, index) {
            let nodeItem = node.nodeGroup;
            let connector = this.arrConnectorPoints[index];
            this.hideAnimation(nodeItem.parentElement, connector, 0, false);
            this.animationLine.style.transition = "";
            this.animationLine.style.width = "0px";
            this.startElement.style.transition = "";
            this.startElement.style.transform = "scale(0)";
            this.endElement.style.transition = "";
            this.endElement.style.transform = "scale(0)";
        }.bind(this)
    );

    this.diagramParent.style.transition = `all ${0.3 * this.animationFactor}s`;
    this.diagramParent.style.opacity = 1;

    setTimeout(() => {
        if (animationType == "all") this.playAllAtOnce();
        else this.animationCompleteCallback?.fn?.(this.animationCompleteCallback.params);
    }, 100);
};

LinearHorizontalTimeline.prototype.playNext = function (index, isAllAtOnce = false) {
    this.updateAnimationPath("show");
    if (this.arrDiagramNode.length == this.animationIndex) {
        if (this.moodData.animationData.isHideAnimation) {
            this.diagramParent.style.transition = "all 0.2s " + this.cubicPath;
            this.diagramParent.style.opacity = 0;
            this.splitLine.parentElement.style.transition = "all 0.2s " + this.cubicPath;
            this.splitLine.parentElement.style.opacity = 0;
        }
        // if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return false;
    }

    this.diagramParent.style.opacity = 1;
    this.splitLine.parentElement.style.opacity = 1;

    if (this.isReversAnimation) {
        this.animationIndex += 1;
        this.isReversAnimation = false;
    }

    let node = this.arrDiagramNode[this.animationIndex].getNodeParent();
    if (node.dataset.highlight && node.dataset.highlight == "true") {
        this.isShowHighlight = true;
        this.highlightIndex = parseInt(node.dataset.index);
    }

    this.isForwardAnimation = true;
    let delay = 0;
    if (this.startElement.style.transform == "scale(0)" && this.isStartEnable) {
        this.startElement.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        this.startElement.style.transform = "scale(1)";
        delay = delay + 0.4;
    }

    let nodeItem = this.arrDiagramNode[this.animationIndex].nodeGroup;
    let connector = this.arrConnectorPoints[this.animationIndex];

    if ((this.animationIndex > 0 && !this.isStartEnable) || this.isStartEnable) {
        this.animationLine.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.4;
        let animationLineWidth = connector.offsetLeft + connector.clientWidth / 2 - this.animationLine.offsetLeft;
        animationLineWidth = animationLineWidth < 0 ? 0 : animationLineWidth;
        this.animationLine.style.width = animationLineWidth + "px";

        let isInside = DiagramNodeUtils.isRectCenterInSideRectHorizontaly(this.diagramParent.parentElement, nodeItem);
        if (!isInside) {
            this.pageIndex = this.pageIndex < this.totalPage - 1 ? this.pageIndex + 1 : this.pageIndex;
            this.moveNext(true);
        }
    }

    delay = this.showAnimation(nodeItem.parentElement, connector, delay * this.animationFactor, this.animationIndex);
    if (this.animationIndex == this.arrDiagramNode.length - 1 && (this.moodData.animationData.multislideAnimation || this.endElement.style.transform == "scale(0)") && this.isEndEnable) {
        let width = this.isStartEnable ? "100%" : "calc(100% - " + this.animationLine.offsetLeft + "px)";
        setTimeout(() => {
            this.animationLine.style.width = width;
        }, delay * 1000 * this.animationFactor);
        delay = delay + 0.4;
        this.endElement.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        this.endElement.style.transform = "scale(1)";
    }
    setTimeout(() => {
        if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, delay * 1000);
    this.animationIndex += 1;

    return true;
};

LinearHorizontalTimeline.prototype.playPrevious = function (index, isAllAtOnce = false) {
    this.updateAnimationPath("hide");

    if (this.animationIndex == -1) {
        this.diagramParent.style.transition = "all 0.2s " + this.cubicPath;
        this.diagramParent.style.opacity = 0;
        this.splitLine.parentElement.style.transition = "all 0.2s " + this.cubicPath;
        this.splitLine.parentElement.style.opacity = 0;
        // if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return false;
    }
    this.diagramParent.style.opacity = 1;
    this.splitLine.parentElement.style.opacity = 1;
    if (this.isForwardAnimation) {
        this.isForwardAnimation = false;
        this.animationIndex -= 1;
    }

    this.isReversAnimation = true;
    let delay = 0;

    let nodeItem = this.arrDiagramNode[this.animationIndex].nodeGroup;
    if (this.endElement.style.transform == "scale(1)") {
        this.endElement.style.transition = "all " + 0.3 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        this.endElement.style.transform = "scale(0)";
        let connector = this.arrConnectorPoints[this.animationIndex];
        this.animationLine.style.transition = "all " + 0.3 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.3;
        let animationLineWidth = this.isStartEnable ? connector.offsetLeft + connector.clientWidth / 2 : this.animationLine.clientWidth - nodeItem.parentElement.parentElement.clientWidth / 2;
        animationLineWidth = animationLineWidth < 0 ? 0 : animationLineWidth;
        this.animationLine.style.width = animationLineWidth + "px";

        setTimeout(() => {
            this.playPrevious();
        }, delay * this.animationFactor * 1000);
        return true;
    }

    // let nodeItem = this.arrDiagramNode[this.animationIndex].nodeGroup;
    let connector = this.arrConnectorPoints[this.animationIndex];
    delay = this.hideAnimation(nodeItem.parentElement, connector, delay * this.animationFactor, this.animationFactor == 1);
    if (this.animationIndex == 0 && this.endElement.style.transform == "scale(1)") {
        this.animationLine.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        this.animationLine.style.width = "0px";
        this.endElement.style.transform = "scale(0)";
    }
    this.animationIndex -= 1;
    if (this.animationIndex >= 0) {
        let connector = this.arrConnectorPoints[this.animationIndex];
        this.animationLine.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        let animationLineWidth = connector.offsetLeft + connector.clientWidth / 2 - this.animationLine.offsetLeft;
        animationLineWidth = animationLineWidth < 0 ? 0 : animationLineWidth;
        this.animationLine.style.width = animationLineWidth + "px";

        let previousIndex = this.animationIndex > 0 ? this.animationIndex : 0;
        let prevoiuseNode = this.arrDiagramNode[previousIndex].nodeGroup;
        let isInside = DiagramNodeUtils.isRectCenterInSideRectHorizontaly(this.diagramParent.parentElement, prevoiuseNode, "previous");
        if (!isInside) {
            this.movePrevious(true);
            this.pageIndex = this.pageIndex > 0 ? this.pageIndex - 1 : this.pageIndex;
        }
    } else if (this.isStartEnable) {
        this.animationLine.style.transition = "all " + 0.3 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.4;
        this.animationLine.style.width = "0px";
        this.startElement.style.transition = "all " + 0.3 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        this.startElement.style.transform = "scale(0)";
    }

    setTimeout(() => {
        if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, delay * 1000);
    return true;
};

LinearHorizontalTimeline.prototype.moveNext = function (isAnimate = false) {
    this.diagramParent.style.transition = isAnimate ? "all " + 1.2 * this.animationFactor + "s " + this.cubicPath : "";
    this.splitLine.parentElement.style.transition = isAnimate ? "all " + 1.2 * this.animationFactor + "s " + this.cubicPath : "";

    this.gotoPage(this.pageIndex);
};

LinearHorizontalTimeline.prototype.movePrevious = function (isAnimate = false) {
    let translateX = parseFloat(window.getComputedStyle(this.diagramParent).transform.replace("matrix(", "").split(",")[4]);
    translateX = Math.abs(translateX);

    this.diagramParent.style.transition = isAnimate ? "all " + 1.4 * this.animationFactor + "s " + this.cubicPath : "";
    this.splitLine.parentElement.style.transition = isAnimate ? "all " + 1.4 * this.animationFactor + "s " + this.cubicPath : "";
    this.gotoPage(this.pageIndex - 1);
};

// primaryTextNode secondaryTextNode diagramContentNode sequenceTextNode
LinearHorizontalTimeline.prototype.hideAnimation = function (nodeItem, connector, delay, isAnimate = true) {
    let targetId = this.getCustomProperties().timeline.element;

    let durationFactor = isAnimate ? "" : "no";
    let delayFactor = isAnimate ? 1 : 0;

    let targetObj = nodeItem.querySelector("[data-id*='" + targetId + "']");
    if (targetObj) {
        targetObj.style.transition = "";
        targetObj.style.transition = "all 0.2" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        // delay = delay + 0.1;
        targetObj.style.transform = "scale(0)";
    }

    let positionY = nodeItem.dataset.alignPosition && nodeItem.dataset.alignPosition == "top" ? "40px" : "-40px";

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    if (seconday) {
        seconday.style.transition = "";
        seconday.style.transition = "all 0.2" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        seconday.style.transform = "translateY(" + positionY + ")";
        seconday.style.setProperty("opacity", 0, "important");
    }

    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    if (primary) {
        primary.style.transition = "";
        primary.style.transition = "all 0.2" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        primary.style.transform = "translateY(" + positionY + ")";
        primary.style.setProperty("opacity", 0, "important");
    }

    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "";
        number.style.transition = "all 0.2" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        number.style.transform = "translateY(" + positionY + ")";
        number.style.setProperty("opacity", 0, "important");
    }

    let secContentNode = nodeItem.querySelector("[name='secContentNode']");
    if (secContentNode) {
        secContentNode.style.transition = "";
        secContentNode.style.transition = "all 0.2" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        secContentNode.style.transform = "translateY(" + positionY + ")";
        secContentNode.style.setProperty("opacity", 0, "important");
    }

    if (connector) {
        connector.firstElementChild.style.transition = "";
        connector.firstElementChild.style.transition = "all 0.2" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        connector.firstElementChild.style.height = "0px";

        connector.style.transition = "";
        connector.style.transition = "all 0.2" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        connector.style.transform = "scale(0)";
    }

    return delay;
};

LinearHorizontalTimeline.prototype.showAnimation = function (nodeItem, connector, delay, index) {
    if (connector) {
        connector.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.4;
        connector.style.transform = "scale(1)";
        connector.firstElementChild.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        connector.firstElementChild.style.height = connector.firstElementChild.dataset.height;
    }

    let targetId = this.getCustomProperties().timeline.element;
    let targetObj = nodeItem.querySelector("[data-id*='" + targetId + "']");
    if (targetObj) {
        targetObj.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        // delay = delay + 0.1;
        targetObj.style.transform = "scale(1)";
    }

    let secContentNode = nodeItem.querySelector("[name='secContentNode']");
    if (secContentNode) {
        secContentNode.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        secContentNode.style.transform = "translateY(0px)";
        secContentNode.style.setProperty("opacity", 1, "important");
    }

    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        number.style.transform = "translateY(0px)";
        number.style.setProperty("opacity", 1, "important");
    }

    let content = nodeItem.querySelector("[data-id*='diagramContentNode']");
    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    if (primary) {
        primary.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        primary.style.transform = "translateY(0px)";
        primary.style.setProperty("opacity", 1, "important");
    }

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    if (seconday) {
        seconday.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        seconday.style.transform = "translateY(0px)";
        seconday.style.setProperty("opacity", 1, "important");
    }

    return delay;
};

LinearHorizontalTimeline.prototype.navigation = function (navigation) {
    if (navigation.direction == "next") {
        // this.moveNext();
        if (this.currentPageIndex == this.totalPage - 1) return false;
        this.currentPageIndex += 1;
        this.gotoPage(this.currentPageIndex);
    } else {
        // this.movePrevious();
        if (this.currentPageIndex == 0) return false;
        this.currentPageIndex -= 1;
        this.gotoPage(this.currentPageIndex);
    }
    return true;
};

LinearHorizontalTimeline.prototype.addFocus = function (index) {
    this.totalPage = Math.ceil(this.splitLine.parentElement.offsetWidth / this.diagramParent.parentElement.offsetWidth - this.pageEpsilon);
    this.currentPageIndex = this.totalPage - 1;

    let primaryTextNode = this.diagramParent.querySelector("[data-id='primaryTextNode'][data-index='" + index + "']");
    this.gotoPage(this.currentPageIndex);
    setTimeout(() => {
        if (primaryTextNode) primaryTextNode.firstElementChild.focus();
    }, 0);
    // primaryTextNode.firstElementChild.focus();
};

LinearHorizontalTimeline.prototype.gotoPage = function (pageIndex) {
    let slideWidth = this.diagramParent.parentElement.offsetWidth;
    let diagramWidth = this.splitLine.parentElement.offsetWidth;
    let translateX = 0;
    if (this.splitLine && diagramWidth > slideWidth) {
        let pagePositionX = slideWidth * pageIndex;
        let calWidth = diagramWidth - slideWidth;

        if (pagePositionX <= calWidth) {
            translateX = pagePositionX;
        } else {
            translateX = calWidth;
        }
        translateX = pagePositionX;
        this.diagramParent.style.transform = "translateX(" + -translateX + "px)";
        this.splitLine.parentElement.style.transform = "translateX(" + -translateX + "px)";
    }

    this.setOffsetLeftTop();
};

LinearHorizontalTimeline.prototype.playAllAtOnce = function () {
    this.itemPerPage = this.getNodePostion()[this.allAtOnceIndex];
    if (!this.itemPerPage) return false;
    this.playNext(0, true);
    this.animateItemCount = 1;
    var interval = setInterval(() => {
        this.playNext(0, true);
        this.animateItemCount += 1;
        if (this.animationCompleteCallback && this.animateItemCount == this.itemPerPage) {
            setTimeout(() => {
                this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
            }, 1000 * this.animationFactor);
            clearInterval(interval);
        }
    }, 1000 * this.animationFactor);
    this.allAtOnceIndex += 1;
    return true;
};

LinearHorizontalTimeline.prototype.playAllAtOnceReverse = function () {
    this.itemPerPage = this.getNodePostion()[this.allAtOnceIndex - 1];
    if (!this.itemPerPage) return false;

    this.playPrevious(0, true);
    this.animateItemCount = 1;
    var interval = setInterval(() => {
        this.playPrevious(0, true);
        this.animateItemCount += 1;
        if (this.animationCompleteCallback && this.animateItemCount == this.itemPerPage) {
            this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
            clearInterval(interval);
        }
    }, 1000 * this.animationFactor);
    this.allAtOnceIndex -= 1;
    return true;
};

LinearHorizontalTimeline.prototype.updateCropPosition = function (node) {
    let contentNode = node.querySelector("[data-id='diagramContentNodeGroup']");
    let imageNode = contentNode.getElementsByTagName("img")[0];

    if (imageNode) {
        let position = DiagramNodeUtils.getOffsetLeftTop(contentNode);
        imageNode.setAttribute("data-x", position.x);
        imageNode.setAttribute("data-y", position.y);
        imageNode.setAttribute("data-width", contentNode.clientWidth);
        imageNode.setAttribute("data-height", contentNode.clientHeight);
    }
};

LinearHorizontalTimeline.prototype.splitArray = function (splitCount, array) {
    if (splitCount >= array.length) return [JSON.parse(JSON.stringify(array))];

    let arr = [];
    let tempArr = [];
    for (var i = 0; i < array.length; i++) {
        if (i % splitCount == 0) {
            tempArr = [];
            arr.push(tempArr);
        }

        tempArr.push(array[i]);
    }

    return arr;
};

LinearHorizontalTimeline.prototype.getNodePostion = function () {
    switch (this.diagramData.nodes.length) {
        case 1:
            return [1];
        case 2:
            return [2];
        case 3:
            return [3];
        case 4:
            return [4];
        case 5:
            return [3, 2];
        case 6:
            return [3, 3];
        case 7:
            return [4, 3];
        case 8:
            return [4, 4];
        case 9:
            return [3, 3, 3];
        case 10:
            return [3, 4, 3];
        case 11:
            return [4, 4, 3];
        case 12:
            return [4, 4, 4];
    }
};

LinearHorizontalTimeline.prototype.splitArrayWithOrder = function (arrSplitOrder, array) {
    let tempArr = [];
    let nodeArr = [];
    let nodeCount = arrSplitOrder[0];
    for (var i = 0; i < array.length + 1; i++) {
        if (nodeArr.length == nodeCount) {
            tempArr.push(nodeArr);
            nodeArr = [];
            nodeCount = arrSplitOrder[tempArr.length];
        }
        if (array[i] == null) continue;
        nodeArr.push(array[i]);
    }
    return tempArr;
};

// LinearHorizontalTimeline.prototype.updateSlideBasedNodeWidth = function (arrNodes, width) {
//     arrNodes.map(function (node) {
//         node.getNodeParent().parentElement.style.setProperty("flex", "unset", "important");
//         node.getNodeParent().parentElement.style.width = width + "px";
//     });
// };

LinearHorizontalTimeline.prototype.updateSlideBasedNodeWidth = function (arrNodes, width, padding, pos) {
    arrNodes.map(
        function (node, i) {
            let parentNode = node.getNodeParent().parentElement;
            parentNode.style.setProperty("flex", "unset", "important");
            parentNode.style.minWidth = width + "px";
            parentNode.style.maxWidth = width + "px";
            parentNode.style.marginRight = "";
            parentNode.style.marginLeft = "";
            if (pos == "start" && i == arrNodes.length - 1) {
                parentNode.style.marginRight = padding + "px";
            } else if (pos == "end" && i == 0) {
                parentNode.style.marginLeft = padding + "px";
            } else if (pos == "mid") {
                if (i == 0) parentNode.style.marginLeft = padding + "px";
                if (i == arrNodes.length - 1) parentNode.style.marginRight = padding + "px";
            }
        }.bind(this)
    );
};

LinearHorizontalTimeline.prototype.updateAnimationPath = function (type) {
    this.cubicPath = "";
    try {
        this.cubicPath = this.moodData.animationData[type].animation.all.effect;
    } catch (error) {
        this.cubicPath = "";
        console.log("Erro accessind timeline animation data LinearHorizontalTimeline.js");
    }
};

LinearHorizontalTimeline.prototype.slideDimensionChange = function () {
    this.setDiagramWidth();
    this.setGroupWidth();
};

LinearHorizontalTimeline.prototype.setDiagramSpecficOption = function (obj) {
    let startendelementoption = {};
    startendelementoption.start = {};
    startendelementoption.end = {};
    startendelementoption.start.isOn = this.isStartEnable != null ? this.isStartEnable : false;
    startendelementoption.end.isOn = this.isEndEnable != null ? this.isEndEnable : false;
    obj.dpcontent.floatdiagramsettings.startendelementoption = startendelementoption;

    let valueTitleHolder = this.diagramParent.querySelector("[name='valueTitleHolder']");
    if (valueTitleHolder) {
        obj.dpcontent.floatdiagramsettings.year = { isOn: this.diagramData.properties.customproperties.isyearenable, property: "Year", label: "Year" };
        obj.dpcontent.floatdiagramsettings.dateformat = DiagramUtils.getDateFormatInlineData(this);
    }
    obj.dpcontent.slidecomponent = { bgImage: false, takeAwayText: false };
    obj.isDisableLayoutOption = "true";

    delete obj.dpcontent.floatdiagramsettings.graphicvalueformat;

    LinearDiagram.prototype.setDiagramSpecficOption.call(this, obj);
};

LinearHorizontalTimeline.prototype.setupNavigation = function (navigationContent) {
    if (this.splitLine) {
        navigationContent.imagelist = [];
        let splitLineWidth = this.splitLine.parentElement.clientWidth;
        if (this.diagramData.properties.diagramtype && this.diagramData.properties.diagramtype.includes("horizontal")) {
            let pageCount = Math.ceil(splitLineWidth / this.diagramParent.parentElement.clientWidth - this.pageEpsilon);
            for (var i = 0; i < pageCount; i++) {
                navigationContent.imagelist.push({});
            }
        }
        navigationContent.imagestackselectedindex = this.currentPageIndex ? this.currentPageIndex : 0;
    }
    return navigationContent;
};

LinearHorizontalTimeline.prototype.initPresent = function (currentSlideData) {
    this.diagramParent = currentSlideData.querySelector("[id='diagramparent']");
    this.splitLine = currentSlideData.querySelector("[id='splitline']");

    if (this.diagramParent.parentElement.dataset.animationtype && this.diagramParent.parentElement.dataset.animationtype == "none") return { isTitleAnimation: false, isGraphicAnimation: false };
    let moodanimation = this.diagramParent.parentElement.dataset.moodanimation;
    if (moodanimation && moodanimation == "none") {
        if (this.diagramParent) this.diagramParent.style.opacity = 1;
        if (this.splitLine && this.splitLine.parentElement) this.splitLine.parentElement.style.opacity = 1;
        return { isTitleAnimation: false, isGraphicAnimation: false };
    }

    if (this.diagramParent) this.diagramParent.style.opacity = 0;
    if (this.splitLine && this.splitLine.parentElement) this.splitLine.parentElement.style.opacity = 0;

    return { isTitleAnimation: true, isGraphicAnimation: false };
};

LinearHorizontalTimeline.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsTimelineNodesHolder";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.appendChild(pattenDiv);

    this.updateImageRatio();

    this.createNodeInstances(nodeCount, pattenDiv);
    this.setGroupWidth();

    this.diagramData.properties.customproperties = this.diagramData.properties.customproperties ? this.diagramData.properties.customproperties : this.customproperties();

    this.isStartEnable = this.diagramData.properties.customproperties.isstartenable == undefined ? true : this.diagramData.properties.customproperties.isstartenable;
    this.isEndEnable = this.diagramData.properties.customproperties.isendenable == undefined ? true : this.diagramData.properties.customproperties.isendenable;
    this.drawTimeline();
    this.setDiagramWidth();
    if (this.createZigZagPath) this.createZigZagPath();
    this.currentPageIndex = 0;
    this.isRenderComplete = true;
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
    // this.diagramRenderComplete();
};

LinearHorizontalTimeline.prototype.diagramRenderComplete = function () {
    if (this.completeCallBack && this.completeCallBack.func && this.isRenderComplete) {
        SimpleLinearDiagram.prototype.diagramRenderComplete.call(this);
    }
    this.diagramParent.style.opacity = 1;
};

LinearHorizontalTimeline.prototype.setOffsetLeftTop = function () {
    let slide = this.diagramParent;
    while (slide) {
        if (slide.dataset.type == "SLIDE") break;
        slide = slide.parentElement;
    }
    if (!slide) return;
    let slideX = slide.getBoundingClientRect().x;
    let slideY = slide.getBoundingClientRect().y;
    this.arrDiagramNode.map(function (node) {
        let nodeParent = node.getNodeParent();
        if (nodeParent) {
            let contentNode = nodeParent.querySelector("[data-id='contentimageparent']");
            if (contentNode) {
                let imageNode = contentNode.querySelector("[data-id='imageNode']");
                let imageX = imageNode.getBoundingClientRect().x;
                let imageY = imageNode.getBoundingClientRect().y;
                let x = imageX - slideX;
                let y = imageY - slideY;
            }
        }
    });
};

LinearHorizontalTimeline.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    let disableProperties = ["graphicnone", "sequencetext", "iconsize", "imagesize", "logosize"];
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable = [...mainProperties.floateroptionsdisable, ...disableProperties];
    } else mainProperties.floateroptionsdisable = disableProperties;
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

LinearHorizontalTimeline.prototype.setProjection = function (projectionIndex) {
    let index = projectionIndex;
    this.arrDiagramNode.map(
        function (node, i) {
            let nodeParent = node.parentNode.parentElement;
            let isProjectionEnable = parseInt(nodeParent.dataset.index) >= parseInt(index);
            isProjectionEnable ? nodeParent.classList.add("clstimelineprojection") : nodeParent.classList.remove("clstimelineprojection");
            let connertorPoint = this.arrConnectorPoints[i];
            if (connertorPoint) isProjectionEnable ? connertorPoint.classList.add("clstimelineprojection") : connertorPoint.classList.remove("clstimelineprojection");
        }.bind(this)
    );

    let oldSvg = this.animationLine.querySelector("#projectionSvg");
    if (oldSvg) oldSvg.parentElement.removeChild(oldSvg);
    let svg = DiagramNodeUtils.createSVGElement("svg");
    DiagramNodeUtils.assignAttributes(svg, { id: "projectionSvg", width: "100%", height: "100%", style: "top:0px; position:absolute;" });
    this.animationLine.appendChild(svg);

    let connertorPoint = this.arrConnectorPoints[index];
    let node = this.arrDiagramNode[0];
    let nodeParent = node.parentNode;
    let offset = this.isStartEnable ? 0 : nodeParent.offsetWidth / 2;
    if (!connertorPoint) return;
    let point1 = { x: connertorPoint.offsetLeft + connertorPoint.clientWidth / 2 - offset, y: this.animationLine.clientHeight / 2 };
    let point2 = { x: this.animationLine.clientWidth, y: point1.y };
    let line = this.createLine(point1, point2);
    DiagramNodeUtils.assignAttributes(line, { "stroke-width": 10, "stroke-dasharray": 10, stroke: "rgba(var(--secondary-color-rgb), 1)" });
    let bgLine = line.cloneNode(true);
    DiagramNodeUtils.assignAttributes(bgLine, { stroke: "rgba(var(--single-bg-color-rgb), 1)", "stroke-width": 10, "stroke-dasharray": 0, class: "clstimelineprojection" });
    svg.appendChild(bgLine);
    svg.appendChild(line);
};

LinearHorizontalTimeline.prototype.createLine = function (startPoint, endPoint) {
    let line = DiagramNodeUtils.createSVGElement("line");
    DiagramNodeUtils.assignSVGNodeAttributes(line, { x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y, "stroke-width": 5 });
    return line;
};

LinearHorizontalTimeline.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    dict["crossout"] = null;
    if (elTarget.getAttribute("name") && elTarget.getAttribute("name") == "secondaryTextItem") return;
    var tlIndex = elTarget.dataset.index;
    let val = this.diagramParent.dataset.projectionindex && this.diagramParent.dataset.projectionindex == tlIndex;
    dict["projection"] = { visible: true, value: val, floaterproperty: "projection" };
    if (strSelectionType == "primaryText" || strSelectionType == "numberNode") this.getFontSizeDataForInlineFloater(dict, elTarget);
};

LinearHorizontalTimeline.prototype.projection = function (property) {
    var index = property.targetid.replace(/\D/g, "").split().shift();
    property.value ? this.diagramParent.setAttribute("data-projectionindex", index) : this.diagramParent.removeAttribute("data-projectionindex");
    this.setProjection(property.value ? index : 100);
};

LinearHorizontalTimeline.prototype.updateDateFormat = function (obj) {
    this.arrDiagramNode.forEach((node) => node.updateDateFormat?.(obj));
    this.resetHolderWidth();
};

function SingleNodeTimeline(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    LinearHorizontalTimeline.call(this, diagramParent, diagramData, nodeProps, moodData);
    diagramParent.parentElement.dataset.animationtype = "oaa";
}

SingleNodeTimeline.prototype = Object.create(LinearHorizontalTimeline.prototype);
SingleNodeTimeline.prototype.constructor = SingleNodeTimeline;

SingleNodeTimeline.prototype.getNodePostion = function () {
    switch (this.diagramData.nodes.length) {
        case 1:
            return [1];
        case 2:
            return [1, 1];
        case 3:
            return [1, 1, 1];
        case 4:
            return [1, 1, 1, 1];
        case 5:
            return [1, 1, 1, 1, 1];
        case 6:
            return [1, 1, 1, 1, 1, 1];
        case 7:
            return [1, 1, 1, 1, 1, 1, 1];
        case 8:
            return [4, 4];
        case 9:
            return [3, 3, 3];
        case 10:
            return [3, 4, 3];
        case 11:
            return [4, 4, 3];
        case 12:
            return [4, 4, 4];
    }
};

SingleNodeTimeline.prototype.setupAnimation = function (animationType, callback) {
    this.animationCompleteCallback = callback;
    this.animationType = animationType;
    this.highlightIndex = -1;

    this.diagramParent.style.transform = "translateX(0px)";

    this.pageIndex = 0;
    this.totalPage = Math.ceil(this.splitLine.parentElement.offsetWidth / this.diagramParent.parentElement.offsetWidth - this.pageEpsilon);
    this.animationIndex = 0;
    this.currentPageIndex = 0;
    this.animateItemCount = 0;
    this.allAtOnceIndex = 0;
    this.nodeAnimationTime = animationType == "all" ? 6 : 1;
    this.animationFactor = this.diagramParent.parentElement.dataset.moodanimation && this.diagramParent.parentElement.dataset.moodanimation == "none" ? 0 : 1;

    this.diagramParent.style.transform = "translateX(0px)";
    this.splitLine.parentElement.style.transform = "translateX(0px)";

    if (this.animationType == "none" || this.moodData.animationData.multislideAnimation) {
        this.diagramParent.style.opacity = 1;
        this.splitLine = this.diagramParent.parentElement.querySelector("[id='splitline']");
        if (this.splitLine && this.splitLine.parentElement) this.splitLine.parentElement.style.opacity = 1;
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return;
    }

    this.arrDiagramNode.map(
        function (node, index) {
            let nodeItem = node.nodeGroup;
            let connector = this.arrConnectorPoints[index];
            this.hideAnimation(nodeItem.parentElement, connector, 0, false);
            this.animationLine.style.transition = "";
            this.animationLine.style.width = "0px";
            this.startElement.style.transition = "";
            this.startElement.style.transform = "scale(0)";
            this.endElement.style.transition = "";
            this.endElement.style.transform = "scale(0)";
        }.bind(this)
    );

    this.diagramParent.style.transition = `all ${0.3 * this.animationFactor}s`;
    this.diagramParent.style.opacity = 1;

    setTimeout(() => {
        this.playNext();
    }, 100);
};

/**
 * Author:    Krishna Prabhu M
 * Created:   20 May 2020
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function LinearPinMarkerDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    LinearHorizontalTimeline.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "pinmarker";
    this.diagramParent.setAttribute("data-togglecategory", "pin-timeline");
    this.diagramParent.setAttribute("data-currencyformat", "disable");
}

LinearPinMarkerDiagram.prototype = Object.create(LinearHorizontalTimeline.prototype);

LinearPinMarkerDiagram.prototype.constructor = LinearPinMarkerDiagram;

LinearPinMarkerDiagram.prototype.initDiagramCreation = function () {
    this.diagramParent.parentElement.style.overflow = "hidden";
    this.diagramParent.parentElement.removeAttribute("graphicanimateid");
    this.diagramParent.parentElement.setAttribute("data-ismultislide", "true");

    LinearHorizontalTimeline.prototype.initDiagramCreation.call(this);
};

LinearPinMarkerDiagram.prototype.getCustomProperties = function () {
    let props = {
        timeline: {
            type: this.diagramParent.dataset.timelinetype || "horizontal",
            style: this.diagramParent.dataset.timelinestyle || "strigntline",
            startelement: this.diagramParent.dataset.startelement && this.diagramParent.dataset.startelement == "false" ? false : true,
            endelement: this.diagramParent.dataset.endelement && this.diagramParent.dataset.endelement == "false" ? false : true,
            isstartendenable: this.diagramParent.dataset.isstartendenable && this.diagramParent.dataset.isstartendenable == "false" ? false : true,
            position: this.diagramParent.dataset.timelineposition || "middle",
            element: this.diagramParent.dataset.timelineelement || "diagramContentNode",
        },
        nodeconnector: {
            visible: this.diagramParent.dataset.connectorvisible && this.diagramParent.dataset.connectorvisible == "false" ? false : true,
            connectorline: false,
            connectingobject: this.diagramParent.dataset.connectorconnectingobject || "diagramContentNode",
        },
        node: {
            position: "middle",
            positionoffset: 10,
            split: true,
            splitalign: "top",
            splitorder: "order1",
            splitgap: this.diagramParent.dataset.connectorgap || 30,
        },
    };
    return props;
};

LinearPinMarkerDiagram.prototype.hideAnimation = function (nodeItem, connector, delay, isAnimate = true) {
    let targetId = this.getCustomProperties().timeline.element;

    let durationFactor = isAnimate ? "" : "no";
    let delayFactor = isAnimate ? 1 : 0;

    let targetObj = nodeItem.querySelector("[data-id*='" + targetId + "']");
    if (targetObj) {
        targetObj.style.transition = "";
        targetObj.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        // delay = delay + 0.2;
        targetObj.style.transform = "scale(0)";
    }

    let positionY = nodeItem.dataset.alignPosition && nodeItem.dataset.alignPosition == "top" ? "40px" : "-40px";

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    seconday.style.transition = "";
    seconday.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    seconday.style.transform = "translateY(" + positionY + ")";
    seconday.style.setProperty("opacity", 0, "important");

    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    primary.style.transition = "";
    primary.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    primary.style.transform = "translateY(" + positionY + ")";
    primary.style.setProperty("opacity", 0, "important");

    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "";
        number.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        number.style.transform = "translateY(" + positionY + ")";
        number.style.setProperty("opacity", 0, "important");
    }

    connector.style.transition = "";
    connector.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    connector.style.transform = "scale(0)";

    return delay;
};

LinearPinMarkerDiagram.prototype.showAnimation = function (nodeItem, connector, delay, index) {
    connector.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    delay = delay + 0.4;
    connector.style.transform = "scale(1)";

    let targetId = this.getCustomProperties().timeline.element;
    let targetObj = nodeItem.querySelector("[data-id*='" + targetId + "']");
    if (targetObj) {
        targetObj.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        targetObj.style.transform = "scale(1)";
    }

    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        number.style.transform = "translateY(0px)";
        number.style.setProperty("opacity", 1, "important");
    }

    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    primary.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    primary.style.transform = "translateY(0px)";
    primary.style.setProperty("opacity", 1, "important");

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    seconday.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    seconday.style.transform = "translateY(0px)";
    seconday.style.setProperty("opacity", 1, "important");

    return delay * this.animationFactor;
};

/**
 * Author:    Krishna Prabhu M
 * Created:   11 March 2021
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function LinearBarConnectorTimeline(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    LinearHorizontalTimeline.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "bartimeline";
    this.contentOffset = 15;
    this.diagramParent.setAttribute("data-togglecategory", "bar-timeline");
    this.diagramParent.setAttribute("data-currencyformat", "disable");
}

LinearBarConnectorTimeline.prototype = Object.create(LinearHorizontalTimeline.prototype);
LinearBarConnectorTimeline.prototype.constructor = LinearBarConnectorTimeline;

LinearBarConnectorTimeline.prototype.initDiagramCreation = function () {
    LinearHorizontalTimeline.prototype.initDiagramCreation.call(this);
};

LinearBarConnectorTimeline.prototype.setDiagramWidth = function () {
    this.startEndBorderPadding = 0;
    this.diagramParent.style.setProperty("--commonnodeitemwidth", "calc(100% - 20px)", "important");
    this.diagramParent.style.setProperty("--timelinecintentwidth", this.diagramParent.clientHeight * 0.166 + "px", "important");
    this.diagramParent.parentElement.style.setProperty("--timelinepadding", 50 + "px", "important");
    let nodeOrder = this.getNodePostion();
    let arr = this.splitArrayWithOrder(nodeOrder, this.arrDiagramNode);
    let widthObj = this.setNodelWidth(arr);

    this.diagramParent.style.width = widthObj.parentWidth + "px";
    this.splitLine.parentElement.style.width = widthObj.parentWidth + this.startElement.clientWidth + this.endElement.clientWidth + "px";

    this.totalPage = Math.ceil(this.splitLine.parentElement.offsetWidth / this.diagramParent.parentElement.offsetWidth - this.pageEpsilon);
    this.currentPageIndex = this.totalPage - 1;

    let secContentMaxHeight = this.diagramParent.clientHeight - this.splitLine.parentElement.offsetTop - 5;
    this.diagramParent.style.setProperty("--secContentMaxHeight", secContentMaxHeight + "px");

    this.updateTimelineElements();
    this.setOffsetLeftTop();
    this.checkForPadding();
};

LinearBarConnectorTimeline.prototype.updateTimelineElements = function () {
    this.timelinePosition();
    this.updateConnectorPoints();
    this.updateNodePosition();
    if (this.getCustomProperties().nodeconnector.connectorline == true) this.updateConnectorLine();
    this.diagramParent.style.setProperty("margin-left", this.startElement.clientWidth + "px");
    this.diagramParent.style.setProperty("margin-right", this.endElement.clientWidth + "px");
    if (this.diagramParent.dataset.projectionindex) this.setProjection(this.diagramParent.dataset.projectionindex);
};

LinearBarConnectorTimeline.prototype.setGroupWidth = function () {
    let pattenDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    if (pattenDiv) {
        pattenDiv.style.setProperty("--contentWidth", "100px");
        try {
            if (this.arrDiagramNode[0].getNodeParent().querySelector("[data-id='diagramContentNode']").querySelector("[data-id='contentnumberparent']")) {
                pattenDiv.style.setProperty("--contentWidth", "170px");
            }
        } catch (error) {
            console.log("LinearVerticalTimeline.prototype.setGroupWidth " + error);
        }
    }
};

LinearBarConnectorTimeline.prototype.drawTimeline = function () {
    this.arrConnectorPoints = [];
    let oldTimeline = this.diagramParent.parentElement.querySelector("[data-id='timeline']");
    if (oldTimeline) {
        oldTimeline.parentElement.removeChild(oldTimeline);
        this.splitLine = null;
    }

    this.totalPage = 1;
    this.currentPageIndex = 0;
    this.diagramParent.style.transform = "translateX(0px)";

    let timeline = document.createElement("div");
    timeline.className = "barconnectortimeline clsMultiColorParent";
    timeline.id = "timeline-" + this.diagramParent.getAttribute("parent-Id");
    timeline.setAttribute("data-id", "timeline");
    this.diagramParent.parentElement.appendChild(timeline);

    let splitLine = document.createElement("div");
    splitLine.className = "splitline clsMultiColorParent";
    splitLine.id = "splitline";
    timeline.appendChild(splitLine);
    this.splitLine = splitLine;
    this.splitLine.setAttribute("data-create", Math.random());

    let animationLine = document.createElement("div");
    animationLine.className = "animationline";
    animationLine.id = "animationLine";
    splitLine.appendChild(animationLine);
    this.animationLine = animationLine;

    let startElement = document.createElement("div");
    startElement.className = "timelinestartelement clsNodeAccentbg clsMultiColorParent";
    startElement.id = "timelinestartelement";
    timeline.appendChild(startElement);
    DiagramUtils.setCustomItemColor(startElement, this.arrTintArray, 0, 1);
    this.startElement = startElement;

    let endElement = document.createElement("div");
    endElement.className = "timelineendelement clsNodeAccentbg clsMultiColorParent";
    DiagramUtils.setCustomItemColor(endElement, this.arrTintArray, this.arrDiagramNode.length - 1, this.arrDiagramNode.length);
    endElement.id = "timelineendelement";
    timeline.appendChild(endElement);
    this.endElement = endElement;

    if (this.diagramData.properties.customproperties.hasOwnProperty("isyearenable")) {
        this.diagramParent.style.setProperty("--yearDisplay", this.diagramData.properties.customproperties.isyearenable ? "flex" : "none");
        if (this.isNumberStyle()) {
            this.splitLine.style.setProperty("--pointerlineOpacity", this.diagramData.properties.customproperties.isyearenable ? "1" : "0");
        } else this.splitLine.style.setProperty("--pointerlineOpacity", "1");
    }
};

LinearBarConnectorTimeline.prototype.updateConnectorPoints = function () {
    if (this.splitLine == null || this.getCustomProperties().nodeconnector.visible == false) return;
    let i = 0;
    while (this.arrConnectorPoints.length < this.arrDiagramNode.length) {
        let connectorPoint = document.createElement("div");
        connectorPoint.className = "connectorpoint clsNodeAccentbg clsMultiColorParent";
        connectorPoint.id = "connectorpoint";
        this.splitLine.appendChild(connectorPoint);
        DiagramUtils.setCustomItemColor(connectorPoint, this.arrTintArray, i, i + 1);

        if (this.getCustomProperties().nodeconnector.connectorline == true) {
            let connectorLine = document.createElement("div");
            connectorLine.className = "connectorline clsNodeAccentbg clsMultiColorParent";
            connectorLine.id = "connectorline";
            connectorPoint.appendChild(connectorLine);
            DiagramUtils.setCustomItemColor(connectorLine, this.arrTintArray, i, i + 1);
            connectorLine.setAttribute("data-height", connectorPoint.clientHeight + "px");

            let svg = this.createSvgElement("svg", { style: "width:100%; height:100%; position:absolute; opacity:0" });
            connectorLine.appendChild(svg);
            let path = this.createSvgElement("path", {});
            path.setAttribute("stroke", "rgba(var(--tertiary-color-rgb), 1)");
            svg.appendChild(path);

            let connectorDot = document.createElement("div");
            connectorDot.className = "connectorDot clsBorderAccent clsNodeBackgroundbg clsMultiColorParent";
            connectorDot.id = "connectorDot";
            connectorLine.appendChild(connectorDot);
            DiagramUtils.setCustomItemColor(connectorDot, this.arrTintArray, i, i + 1);
            i % 2 == 0 ? (connectorDot.style.top = "0px") : "unset";
            i % 2 != 0 ? (connectorDot.style.bottom = "0px") : "unset";

        }
        i += 1;
        this.arrConnectorPoints.push(connectorPoint);
    }

    while (this.arrConnectorPoints.length > this.arrDiagramNode.length) {
        let point = this.arrConnectorPoints[this.arrConnectorPoints.length - 1];
        point.parentElement.removeChild(point);
        this.arrConnectorPoints.pop();
    }

    let arrPoints = this.splitLine.querySelectorAll("[id='connectorpoint']");
    this.arrDiagramNode.map(
        function (node, i) {
            let point = arrPoints[i];
            let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
            let nodeRect = DiagramNodeUtils.getOffsetRectByParent(nodeHolder, node.nodeGroup);
            let centerX = nodeRect.x + nodeRect.width / 2;
            centerX = centerX - this.padding - point.clientWidth / 2 - 7;
            if (point) point.style.left = centerX + "px";
            let margin = 0;

            point.style.position = "relative";
            if (node.parentNode.parentElement.style.marginLeft != "") {
                margin = parseInt(node.parentNode.parentElement.style.marginLeft);
                point.style.width = node.parentNode.parentElement.clientWidth + margin + "px";
                point.firstElementChild.style.left = point.clientWidth / 2 - point.firstElementChild.clientWidth / 2 + margin / 2 + "px";
            } else if (node.parentNode.parentElement.style.marginRight != "") {
                margin = parseInt(node.parentNode.parentElement.style.marginRight);
                point.style.width = node.parentNode.parentElement.clientWidth + margin + "px";
                point.firstElementChild.style.left = point.clientWidth / 2 - point.firstElementChild.clientWidth / 2 - margin / 2 + "px";
            } else {
                point.style.width = node.parentNode.parentElement.clientWidth + margin + "px";
            }


        }.bind(this)
    );
};

LinearBarConnectorTimeline.prototype.setNodelWidth = function (arrOrderedNodes) {
    let offsetWidth = arrOrderedNodes.length > 1 ? this.startElement.clientWidth : this.startElement.clientWidth + this.endElement.clientWidth;
    offsetWidth = offsetWidth;

    let slideEndPadding = arrOrderedNodes.length > 1 ? 85 : 0;
    let firstSlideWidth = this.diagramParent.parentElement.clientWidth - offsetWidth - slideEndPadding;
    let centerSlideWidth = this.diagramParent.parentElement.clientWidth - slideEndPadding * 2;
    let lastSlideWidth = this.diagramParent.parentElement.clientWidth - offsetWidth - slideEndPadding;
    let totalWidth = 0;
    let diffWidth = 0;
    let firstNodeWidth = 0;

    for (var i = 0; i < arrOrderedNodes.length; i++) {
        if (i == 0) {
            //first slide
            let nodeWidth = firstSlideWidth / arrOrderedNodes[i].length;
            firstNodeWidth = nodeWidth;
            this.updateSlideBasedNodeWidth(arrOrderedNodes[i], nodeWidth, slideEndPadding, "start");
            totalWidth = totalWidth + firstSlideWidth + slideEndPadding;
        } else if (i == arrOrderedNodes.length - 1) {
            //last slide
            let nodeWidth = lastSlideWidth / arrOrderedNodes[i].length;
            let diffWidthCount = arrOrderedNodes[i].length - arrOrderedNodes[i].length;
            diffWidth = nodeWidth * diffWidthCount;
            this.updateSlideBasedNodeWidth(arrOrderedNodes[i], nodeWidth, slideEndPadding, "end");
            totalWidth = totalWidth + lastSlideWidth + slideEndPadding;
        } else {
            //remaining slide
            let nodeWidth = centerSlideWidth / arrOrderedNodes[i].length;
            this.updateSlideBasedNodeWidth(arrOrderedNodes[i], nodeWidth, slideEndPadding, "mid");
            totalWidth = totalWidth + centerSlideWidth + slideEndPadding * 2;
        }
    }

    let timelineWidth = totalWidth - diffWidth;

    return { parentWidth: totalWidth, timelineWidth: timelineWidth, nodeWidth: firstNodeWidth };
};

LinearBarConnectorTimeline.prototype.updateSlideBasedNodeWidth = function (arrNodes, width, padding, pos) {
    arrNodes.map(
        function (node, i) {
            let parentNode = node.getNodeParent().parentElement;
            parentNode.style.marginRight = padding + "px";
            parentNode.style.setProperty("flex", "unset", "important");
            parentNode.style.minWidth = width + "px";
            parentNode.style.marginRight = "";
            parentNode.style.marginLeft = "";
            if (pos == "start" && i == arrNodes.length - 1) {
                parentNode.style.marginRight = padding + "px";
            } else if (pos == "end" && i == 0) {
                parentNode.style.marginLeft = padding + "px";
            } else if (pos == "mid") {
                if (i == 0) parentNode.style.marginLeft = padding + "px";
                if (i == arrNodes.length - 1) parentNode.style.marginRight = padding + "px";
            }
        }.bind(this)
    );
};

LinearBarConnectorTimeline.prototype.slideDimensionChange = function () {
    this.setDiagramWidth();
    this.setGroupWidth();
};

LinearBarConnectorTimeline.prototype.getCustomProperties = function () {
    let props = {
        timeline: {
            type: this.diagramParent.dataset.timelinetype || "horizontal",
            style: this.diagramParent.dataset.timelinestyle || "strigntline",
            startelement: this.diagramParent.dataset.startelement && this.diagramParent.dataset.startelement == "false" ? false : true,
            endelement: this.diagramParent.dataset.endelement && this.diagramParent.dataset.endelement == "false" ? false : true,
            isstartendenable: this.diagramParent.dataset.isstartendenable && this.diagramParent.dataset.isstartendenable == "false" ? false : true,
            position: this.diagramParent.dataset.timelineposition || "middle",
            element: this.diagramParent.dataset.timelineelement || "diagramContentNode",
        },
        nodeconnector: {
            visible: this.diagramParent.dataset.connectorvisible && this.diagramParent.dataset.connectorvisible == "false" ? false : true,
            connectorline: true,
            connectingobject: this.diagramParent.dataset.connectorconnectingobject || "diagramContentNode",
        },
        node: {
            position: "middle",
            positionoffset: 50,
            split: true,
            splitalign: "alternate",
            splitorder: "order1",
            splitgap: Math.min(this.diagramParent.clientHeight * 0.2, 50),
        },
    };
    return props;
};

LinearBarConnectorTimeline.prototype.updateConnectorLine = function () {
    this.arrConnectorPoints.map(
        function (connector, index) {
            let targetNodeId = this.getCustomProperties().nodeconnector.connectingobject;
            let node = this.arrDiagramNode[index].nodeGroup;
            let timelineobj = node.querySelector("[data-id*='" + targetNodeId + "']");
            let timelineobjRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, timelineobj); //timelineobj.getBoundingClientRect();
            let connectorRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, connector); //connector.getBoundingClientRect();

            let splitPosition = this.getCustomProperties().node.splitalign;
            let nodePosition = this.getCustomProperties().node.position;
            let isApplySplit = this.getCustomProperties().node.split;
            nodePosition = isApplySplit ? splitPosition : nodePosition;

            let height = 30;
            switch (nodePosition) {
                case "top":
                    height = connectorRect.top - (timelineobjRect.top + timelineobjRect.height);
                    connector.firstElementChild.style.top = "unset";
                    connector.firstElementChild.style.bottom = connector.clientHeight + "px";
                    this.updateDottedLineHeight(connector, height);
                    break;
                case "bottom":
                    height = timelineobjRect.top - (connectorRect.top + connectorRect.height);
                    connector.firstElementChild.style.bottom = "unset";
                    connector.firstElementChild.style.top = connector.clientHeight + "px";
                    this.updateDottedLineHeight(connector, height, false);
                    break;
                case "alternate":
                    if (index % 2 == 0) {
                        height = connectorRect.top - (timelineobjRect.top + timelineobjRect.height + 10);
                        connector.firstElementChild.style.top = "unset";
                        connector.firstElementChild.style.bottom = connector.clientHeight + "px";
                        this.updateDottedLineHeight(connector, height);
                    } else {
                        height = timelineobjRect.top - (connectorRect.top + connectorRect.height + 10);
                        connector.firstElementChild.style.bottom = "unset";
                        connector.firstElementChild.style.top = connector.clientHeight + "px";
                        this.updateDottedLineHeight(connector, height, false);
                    }
                    break;
            }
        }.bind(this)
    );
};

LinearBarConnectorTimeline.prototype.nodeAlignSplit = function () {
    this.arrDiagramNode.map(
        function (node, index) {
            let targetId = this.getCustomProperties().timeline.element;
            let nodeItem = node.nodeGroup;
            let targetObj = node.nodeGroup.querySelector("[data-id*='" + targetId + "']");

            let splitGap = parseFloat(this.getCustomProperties().node.splitgap);

            targetObj.style.marginTop = "unset";
            targetObj.style.marginBottom = "unset";

            this.alternateOrder(node.nodeGroup, index);
            if (index % 2 == 0) {
                targetObj.style.marginBottom = splitGap + "px";
                targetObj.style.setProperty("margin-bottom", splitGap + this.contentOffset + "px", "important");
                this.alignTimelineElement(nodeItem, targetObj, splitGap);
            } else {
                targetObj.style.marginTop = splitGap + "px";
                targetObj.style.setProperty("margin-top", splitGap + this.contentOffset + "px", "important");
                this.alignTimelineElement(nodeItem, targetObj, splitGap, "bottom");
            }
        }.bind(this)
    );
};

LinearBarConnectorTimeline.prototype.alignTimelineElement = function (nodeItem, targetObj, splitGap = 0, align = "top") {
    nodeItem.style.bottom = "unset";
    nodeItem.style.top = "unset";
    let timelineRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, this.splitLine);
    let targetObjRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, targetObj);

    nodeItem.parentElement.setAttribute("data-align-position", align);
    if (align == "top") {
        nodeItem.style.top = timelineRect.y - targetObjRect.height - splitGap - this.contentOffset + "px";
    } else {
        let centerDiff = timelineRect.y + timelineRect.height - (targetObjRect.y + targetObjRect.height);
        let objTop = centerDiff + targetObjRect.height + splitGap + this.contentOffset;
        let objBottom = nodeItem.parentElement.clientHeight - (objTop + nodeItem.clientHeight);
        nodeItem.style.bottom = objBottom + "px";
    }
    this.setValueAlign(nodeItem, align);
};

LinearBarConnectorTimeline.prototype.hideAnimation = function (nodeItem, connector, delay, isAnimate = true) {
    let targetId = this.getCustomProperties().timeline.element;

    let durationFactor = isAnimate ? "" : "no";
    let delayFactor = isAnimate ? 1 : 0;

    let targetObj = nodeItem.querySelector("[data-id*='" + targetId + "']");
    targetObj.style.transition = "";
    targetObj.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    // delay = delay + 0.2;
    targetObj.style.transform = "scale(0)";

    let positionY = nodeItem.dataset.alignPosition && nodeItem.dataset.alignPosition == "top" ? "40px" : "-40px";
    let content = nodeItem.querySelector("[data-id*='diagramContentNode']");

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    seconday.style.transition = "";
    seconday.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    seconday.style.transform = "translateY(" + positionY + ")";
    seconday.style.setProperty("opacity", 0, "important");

    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    primary.style.transition = "";
    primary.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    primary.style.transform = "translateY(" + positionY + ")";
    primary.style.setProperty("opacity", 0, "important");

    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "";
        number.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        // delay = delay + 0.2;
        number.style.transform = "translateY(" + positionY + ")";
        number.style.setProperty("opacity", 0, "important");
    }

    let dot = connector.querySelector("#connectorDot");
    if (dot) {
        delay = delay + 0.2;
        dot.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        dot.style.transform = "scale(0)";
    }

    connector.firstElementChild.style.transition = "";
    connector.firstElementChild.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    connector.firstElementChild.style.height = "0px";

    connector.style.transition = "";
    connector.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    connector.style.transform = "scale(0, 1)";

    return delay;
};

LinearBarConnectorTimeline.prototype.showAnimation = function (nodeItem, connector, delay, index) {
    connector.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    delay = delay + 0.4;
    connector.style.transform = "scale(1,1)";
    connector.firstElementChild.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    connector.firstElementChild.style.height = connector.firstElementChild.dataset.height;

    let dot = connector.querySelector("#connectorDot");
    if (dot) {
        dot.style.transition = "all 0.5" + this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        dot.style.transform = "scale(1)";
    }

    let targetId = this.getCustomProperties().timeline.element;
    let targetObj = nodeItem.querySelector("[data-id*='" + targetId + "']");
    targetObj.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    // delay = delay + 0.2;
    targetObj.style.transform = "scale(1)";

    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        number.style.transform = "translateY(0px)";
        number.style.setProperty("opacity", 1, "important");
    }

    let content = nodeItem.querySelector("[data-id*='diagramContentNode']");
    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    primary.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    primary.style.transform = "translateY(0px)";
    primary.style.setProperty("opacity", 1, "important");

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    seconday.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    seconday.style.transform = "translateY(0px)";
    seconday.style.setProperty("opacity", 1, "important");

    return delay;
};

LinearBarConnectorTimeline.prototype.setProjection = function (projectionIndex) {
    let index = projectionIndex;;
    this.arrDiagramNode.map(
        function (node, i) {
            let nodeParent = node.parentNode.parentElement;
            let isProjectionEnable = parseInt(nodeParent.dataset.index) >= parseInt(index);
            isProjectionEnable ? nodeParent.classList.add("clstimelineprojection") : nodeParent.classList.remove("clstimelineprojection");
            let connertorPoint = this.arrConnectorPoints[i];
            if (connertorPoint) isProjectionEnable ? connertorPoint.classList.add("clstimelineprojection") : connertorPoint.classList.remove("clstimelineprojection");
        }.bind(this)
    );
};

LinearBarConnectorTimeline.prototype.checkForPadding = function () {
    if (this.arrDiagramNode.length > 0) {
        let nodeItem = this.arrDiagramNode[0].parentNode;

        let secContent = nodeItem.querySelector("[name='secContentNode']");
        if (secContent) {
            let valueText = secContent.querySelector("[name='valueTitleHolder']");
            if (!valueText) this.diagramParent.style.setProperty("--primarypadding", "70px")
            else this.diagramParent.style.setProperty("--primarypadding", "20px")
        }

    }
};

LinearBarConnectorTimeline.prototype.createElements = function () {
    LinearHorizontalTimeline.prototype.createElements.call(this);
    this.setGroupWidth();
};

LinearBarConnectorTimeline.prototype.setDiagramSpecficOption = function (obj) {
    obj.dpcontent.floatdiagramsettings.year = { isOn: this.diagramData.properties.customproperties.isyearenable, property: "Year", label: "Year" };
};

LinearBarConnectorTimeline.prototype.emphasize = function (emphasizeData) {
    LinearDiagram.prototype.emphasize.call(this, emphasizeData);
    this.updateShapeEmphasis();
}

LinearBarConnectorTimeline.prototype.updateEmphasize = function () {
    LinearHorizontalTimeline.prototype.updateEmphasize.call(this);
    this.updateShapeEmphasis();
};

LinearBarConnectorTimeline.prototype.updateShapeEmphasis = function () {
    let enableClass = "clsTimelineEmphasisEnable";
    let disableClass = "clsTimelineEmphasisDisable";
    this.arrDiagramNode.map(function (node, i) {
        let point = this.arrConnectorPoints[i];
        if (point && point.classList) {
            point.classList.remove(enableClass);
            point.classList.remove(disableClass);
            let nodeParent = node.parentNode.parentElement;
            if (nodeParent.classList.contains("clsEmphasisEnabled")) {
                point.classList.add(enableClass)
            } else if (nodeParent.classList.contains("clsEmphasisDisabled")) {
                point.classList.add(disableClass)
            }
        }
    }.bind(this))
};

// deleting the below function will crash
LinearBarConnectorTimeline.prototype.updateDottedLineHeight = function (connector, height, isTop = true) { };
/**
 * Author:    Krishna Prabhu M
 * Created:   15 March 2021
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function LinearBarArrowTimeline(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    LinearBarConnectorTimeline.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "bartimeline";
    this.contentOffset = 0;
    this.diagramParent.setAttribute("data-togglecategory", "arrow-timeline");
    this.diagramParent.setAttribute("data-currencyformat", "disable");
}

LinearBarArrowTimeline.prototype = Object.create(LinearBarConnectorTimeline.prototype);
LinearBarArrowTimeline.prototype.constructor = LinearBarArrowTimeline;

LinearBarArrowTimeline.prototype.drawTimeline = function () {
    this.arrConnectorPoints = [];
    let oldTimeline = this.diagramParent.parentElement.querySelector("[data-id='timeline']");
    if (oldTimeline) {
        oldTimeline.parentElement.removeChild(oldTimeline);
        this.splitLine = null;
    }

    this.totalPage = 1;
    this.currentPageIndex = 0;
    this.diagramParent.style.transform = "translateX(0px)";

    let timeline = document.createElement("div");
    timeline.className = "bararrowtimeline clsMultiColorParent";
    timeline.id = "timeline-" + this.diagramParent.getAttribute("parent-Id");
    timeline.setAttribute("data-id", "timeline");
    this.diagramParent.parentElement.appendChild(timeline);

    let splitLine = document.createElement("div");
    splitLine.className = "splitline clsMultiColorParent";
    splitLine.id = "splitline";
    timeline.appendChild(splitLine);
    this.splitLine = splitLine;
    this.splitLine.setAttribute("data-create", Math.random());

    let animationLine = document.createElement("div");
    animationLine.className = "animationline";
    animationLine.id = "animationLine";
    splitLine.appendChild(animationLine);
    this.animationLine = animationLine;

    let startElement = document.createElement("div");
    startElement.className = "timelinestartelement clsNodeAccentbg clsMultiColorParent";
    startElement.id = "timelinestartelement";
    timeline.appendChild(startElement);
    DiagramUtils.setCustomItemColor(startElement, this.arrTintArray, 0, 1);
    this.startElement = startElement;

    let endElement = document.createElement("div");
    endElement.className = "timelineendelement clsNodeAccentbg clsMultiColorParent";
    DiagramUtils.setCustomItemColor(endElement, this.arrTintArray, this.arrDiagramNode.length - 1, this.arrDiagramNode.length);
    endElement.id = "timelineendelement";
    timeline.appendChild(endElement);
    this.endElement = endElement;

    if (this.diagramData.properties.customproperties.hasOwnProperty("isyearenable")) {
        this.diagramParent.style.setProperty("--yearDisplay", this.diagramData.properties.customproperties.isyearenable ? "flex" : "none");
    }
};

LinearBarArrowTimeline.prototype.updateConnectorPoints = function () {
    if (this.splitLine == null || this.getCustomProperties().nodeconnector.visible == false) return;
    let i = 0;
    while (this.arrConnectorPoints.length < this.arrDiagramNode.length) {
        let connectorPoint = document.createElement("div");
        connectorPoint.className = "connectorpoint clsNodeAccentbg clsMultiColorParent";
        connectorPoint.id = "connectorpoint";
        this.splitLine.appendChild(connectorPoint);
        DiagramUtils.setCustomItemColor(connectorPoint, this.arrTintArray, i, i + 1);

        if (this.getCustomProperties().nodeconnector.connectorline == true) {
            let connectorLine = document.createElement("div");
            connectorLine.className = "connectorline clsNodeAccentbg clsMultiColorParent";
            connectorLine.id = "connectorline";
            connectorPoint.appendChild(connectorLine);
            DiagramUtils.setCustomItemColor(connectorLine, this.arrTintArray, i, i + 1);
        }
        i += 1;
        this.arrConnectorPoints.push(connectorPoint);
    }

    while (this.arrConnectorPoints.length > this.arrDiagramNode.length) {
        let point = this.arrConnectorPoints[this.arrConnectorPoints.length - 1];
        point.parentElement.removeChild(point);
        this.arrConnectorPoints.pop();
    }

    let arrPoints = this.splitLine.querySelectorAll("[id='connectorpoint']");
    this.arrDiagramNode.map(
        function (node, i) {
            let point = arrPoints[i];
            let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
            let nodeRect = DiagramNodeUtils.getOffsetRectByParent(nodeHolder, node.nodeGroup);
            let centerX = nodeRect.x + nodeRect.width / 2;
            centerX = centerX - this.padding - point.clientWidth / 2 - 7;
            if (point) point.style.left = centerX + "px";
            let margin = 0;
            
            point.style.position = "relative";
            if (node.parentNode.parentElement.style.marginLeft != ""){
                margin = parseInt(node.parentNode.parentElement.style.marginLeft);
                point.style.width = node.parentNode.parentElement.clientWidth + margin + "px";
                point.firstElementChild.style.left = point.clientWidth/2 - point.firstElementChild.clientWidth/2 + margin/2 + "px";
            }else if (node.parentNode.parentElement.style.marginRight != ""){
                margin = parseInt(node.parentNode.parentElement.style.marginRight);
                point.style.width = node.parentNode.parentElement.clientWidth + margin + "px";
                point.firstElementChild.style.left = point.clientWidth/2 - point.firstElementChild.clientWidth/2 - margin/2 + "px";
            }else {
                point.style.width = node.parentNode.parentElement.clientWidth + margin + "px";
            }
        }.bind(this)
    );
};

LinearBarArrowTimeline.prototype.getCustomProperties = function () {
    let props = {
        timeline: {
            type: this.diagramParent.dataset.timelinetype || "horizontal",
            style: this.diagramParent.dataset.timelinestyle || "strigntline",
            startelement: this.diagramParent.dataset.startelement && this.diagramParent.dataset.startelement == "false" ? false : true,
            endelement: this.diagramParent.dataset.endelement && this.diagramParent.dataset.endelement == "false" ? false : true,
            isstartendenable: this.diagramParent.dataset.isstartendenable && this.diagramParent.dataset.isstartendenable == "false" ? false : true,
            position: this.diagramParent.dataset.timelineposition || "middle",
            element: this.diagramParent.dataset.timelineelement || "diagramContentNode",
        },
        nodeconnector: {
            visible: this.diagramParent.dataset.connectorvisible && this.diagramParent.dataset.connectorvisible == "false" ? false : true,
            connectorline: true,
            connectingobject: this.diagramParent.dataset.connectorconnectingobject || "diagramContentNode",
        },
        node: {
            position: "middle",
            positionoffset: 50,
            split: true,
            splitalign: "alternate",
            splitorder: "order1",
            splitgap: Math.min(this.diagramParent.clientHeight * 0.2, 20),
        },
    };
    return props;
};

LinearBarArrowTimeline.prototype.updateConnectorLine = function () {
    this.arrConnectorPoints.map(
        function (connector, index) {
            
            if (index % 2 != 0) {
                connector.firstElementChild.style.bottom = "unset";
                connector.firstElementChild.style.top =  - connector.firstElementChild.clientHeight/2 + "px";
            } else {
                connector.firstElementChild.style.top = "unset";
                connector.firstElementChild.style.bottom = - connector.firstElementChild.clientHeight/2 + "px";
            }

        }.bind(this)
    );
};

LinearBarArrowTimeline.prototype.hideAnimation = function (nodeItem, connector, delay, isAnimate = true) {
    let targetId = this.getCustomProperties().timeline.element;

    let durationFactor = isAnimate ? "" : "no";
    let delayFactor = isAnimate ? 1 : 0;

    let targetObj = nodeItem.querySelector("[data-id*='" + targetId + "']");
    targetObj.style.transition = "";
    targetObj.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    // delay = delay + 0.2;
    targetObj.style.transform = "scale(0)";

    let positionY = nodeItem.dataset.alignPosition && nodeItem.dataset.alignPosition == "top" ? "40px" : "-40px";
    let content = nodeItem.querySelector("[data-id*='diagramContentNode']");

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    seconday.style.transition = "";
    seconday.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    seconday.style.transform = "translateY(" + positionY + ")";
    seconday.style.setProperty("opacity", 0, "important");

    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    primary.style.transition = "";
    primary.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    primary.style.transform = "translateY(" + positionY + ")";
    primary.style.setProperty("opacity", 0, "important");

    connector.firstElementChild.style.transition = "";
    connector.firstElementChild.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    connector.firstElementChild.style.transform = "scale(0) rotate(45deg)";

    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "";
        number.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        // delay = delay + 0.2;
        number.style.transform = "translateY(" + positionY + ")";
        number.style.setProperty("opacity", 0, "important");
    }

    connector.style.transition = "";
    connector.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    connector.style.transform = "scale(0, 1)";

    return delay;
};

LinearBarArrowTimeline.prototype.showAnimation = function (nodeItem, connector, delay, index) {
    connector.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    delay = delay + 0.4;
    connector.style.transform = "scale(1,1)";

    let targetId = this.getCustomProperties().timeline.element;
    let targetObj = nodeItem.querySelector("[data-id*='" + targetId + "']");
    targetObj.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    // delay = delay + 0.2;
    targetObj.style.transform = "scale(1)";

    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        number.style.transform = "translateY(0px)";
        number.style.setProperty("opacity", 1, "important");
    }

    connector.firstElementChild.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    connector.firstElementChild.style.transform = "scale(1) rotate(45deg)";

    let content = nodeItem.querySelector("[data-id*='diagramContentNode']");
    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    primary.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    primary.style.transform = "translateY(0px)";
    primary.style.setProperty("opacity", 1, "important");

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    seconday.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    seconday.style.transform = "translateY(0px)";
    seconday.style.setProperty("opacity", 1, "important");

    return delay;
};

/**
 * Author:    Krishna Prabhu M
 * Created:   16 March 2021
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function CurvedTimelineDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "curvedtimelineparent";
    this.arrPaths = [];
    this.arrNodePoints = [];
    this.arrDotPoint = [];
    this.isForwardAnimation = true;
    this.isReversAnimation = false;
    this.animationFactor = 1;
    this.isStartEndEnable = true;
    this.currentPageIndex = 0;
    this.diagramParent.parentElement.setAttribute("data-ismultislide", true);
    this.diagramParent.setAttribute("data-currencyformat", "disable");
    this.isTitleAnimation = "show";
    // this.diagramParent.parentElement.setAttribute("data-customtitleanimation", true);
}

CurvedTimelineDiagram.prototype = Object.create(SimpleLinearDiagram.prototype);
CurvedTimelineDiagram.prototype.constructor = CurvedTimelineDiagram;

CurvedTimelineDiagram.prototype.createElements = function () {
    SimpleLinearDiagram.prototype.createElements.call(this);
    this.diagramData.properties.customproperties = this.diagramData.properties.customproperties || this.customproperties();
    this.isStartEnable = this.diagramData.properties.customproperties.isstartenable == undefined ? true : this.diagramData.properties.customproperties.isstartenable;
    this.isEndEnable = this.diagramData.properties.customproperties.isendenable == undefined ? true : this.diagramData.properties.customproperties.isendenable;
    this.diagramData.properties.customproperties.isstartenable = this.isStartEnable;
    this.diagramData.properties.customproperties.isendenable = this.isEndEnable;
    this.diagramParent.setAttribute("data-isstartenable", this.isStartEnable);
    this.diagramParent.setAttribute("data-isendenable", this.isEndEnable);
    this.drawTimeline();
    this.currentPageIndex = 0;
    this.gotoPage(this.currentPageIndex + 1);
};

CurvedTimelineDiagram.prototype.addNode = function (nodeData, index, isFromUndo = false) {
    SimpleLinearDiagram.prototype.addNode.call(this, nodeData, index, isFromUndo);
    this.drawTimeline();
    this.arrDiagramNode.length > this.getItemCountForPage(1) ? this.gotoPage(2) : this.gotoPage(1);
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
};

CurvedTimelineDiagram.prototype.deleteNode = function (targetIndex) {
    SimpleLinearDiagram.prototype.deleteNode.call(this, targetIndex);
    this.drawTimeline();
    this.arrDiagramNode.length > this.getItemCountForPage(1) ? this.gotoPage(2) : this.gotoPage(1);
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
};

CurvedTimelineDiagram.prototype.updateElements = function (defaultproperties) {
    SimpleLinearDiagram.prototype.updateElements.call(this, defaultproperties);

    this.totalPage = 1;
    this.pageIndex = 1;
    this.allAtOnceIndex = 0;
    this.animationIndex = 0;
    this.navigationIndex = 0;
    this.currentPageIndex = 0;
    this.isForwardAnimation = true;
    this.isReversAnimation = false;
    this.pageEpsilon = 0.1;

    let timelineElement = this.diagramParent.parentElement.querySelector("#timelineparent");

    if (timelineElement) {
        this.startElement = timelineElement.querySelector("[id='timelinestartelement']");
        this.endElement = timelineElement.querySelector("[id='timelineendelement']");
        this.arrDotPoint = Array.from(timelineElement.querySelectorAll(".dot"));
        this.arrDotPoint.sort(function (dot1, dot2) {
            return parseInt(dot1.dataset.index) - parseInt(dot2.dataset.index);
        });
        this.arrPaths = Array.from(timelineElement.querySelectorAll("#animatepath"));
        this.gotoPage(this.currentPageIndex + 1);
    }
};

CurvedTimelineDiagram.prototype.drawTimeline = function () {
    let oldSvg = this.diagramParent.querySelector("#timelineparent");
    if (oldSvg) this.diagramParent.removeChild(oldSvg);

    let timelineParent = document.createElement("div");
    timelineParent.className = "timelineparent" + " " + (this.nodeProps?.timelineclass || "");
    timelineParent.id = "timelineparent";
    this.diagramParent.appendChild(timelineParent);

    let svg = DiagramNodeUtils.createSVGElement("svg");
    svg.setAttribute("class", "curvedtimelinesvg");
    svg.setAttribute("id", "curvedtimelinesvg");
    timelineParent.appendChild(svg);

    let startElement = document.createElement("div");
    startElement.className = "timelinestartelement  clsMultiColorParent secondary-color h9";
    startElement.id = "timelinestartelement";
    startElement.innerText = "START";
    timelineParent.appendChild(startElement);
    this.startElement = startElement;

    let endElement = document.createElement("div");
    endElement.className = "timelineendelement  clsMultiColorParent secondary-color h9";
    endElement.id = "timelineendelement";
    endElement.innerText = "END";
    timelineParent.appendChild(endElement);
    this.endElement = endElement;

    this.updatePathBasedOnNodes();
    if (this.diagramParent.dataset.projectionindex) this.setProjection(this.diagramParent.dataset.projectionindex);
    this.updateStartEndYear();
};

CurvedTimelineDiagram.prototype.updatePathBasedOnNodes = function () {
    let svg = this.diagramParent.querySelector("#curvedtimelinesvg");
    if (!svg) return;

    let slideOffset = this.slideHeight * 0.1388888889;
    let title = this.diagramParent.parentElement.parentElement.parentElement.querySelector("#TITLE");
    let titleOffset = title ? title.offsetTop + title.offsetHeight + (slideOffset/2) : slideOffset;

    this.arrPaths = [];
    this.arrDotPoint = [];
    this.arrNodePoints = [];
    let noOfSection = this.arrDiagramNode.length > 6 ? 6 : 3;
    let startendOffset = 100;
    let offsetTop = titleOffset;
    let sectionGap = (this.diagramParent.parentElement.clientHeight - offsetTop) / 3;
    let sectionLength = this.diagramParent.parentElement.clientWidth - startendOffset;
    let pathString = "";
    let isCurved = false;
    let index = 0;
    noOfSection % 2 == 0 ? (this.endElement.style.left = 0 + "px") : (this.endElement.style.left = this.diagramParent.clientWidth - this.endElement.offsetWidth + "px");
    this.diagramParent.style.height = noOfSection > 3 ? this.diagramParent.parentElement.clientHeight * 2 + "px" : this.diagramParent.parentElement.clientHeight * +"px";

    for (var i = 0; i < noOfSection; i++) {
        let startPoint = {};
        let endPoint = {};

        if (i % 2 == 0) {
            startPoint.x = (sectionGap / 2);
            startPoint.y = offsetTop + 50 + sectionGap * i;
            endPoint.x = this.diagramParent.clientWidth - (sectionGap / 2);
            endPoint.y = startPoint.y;
        } else {
            endPoint.x = (sectionGap / 2);
            endPoint.y = offsetTop + 50 + sectionGap * i;
            startPoint.x = this.diagramParent.clientWidth - (sectionGap / 2);
            startPoint.y = endPoint.y;
        }

        if (i == 0) {
            startPoint.x = this.startElement.offsetWidth;
        } else if (i == noOfSection - 1) {
            if (noOfSection % 2 != 0) endPoint.x = this.diagramParent.clientWidth - this.endElement.offsetWidth;
            else endPoint.x = this.endElement.offsetWidth;
        }

        if (i >= 3) {
            startPoint.y = startPoint.y + 50;
            endPoint.y = startPoint.y;
        }

        if (i == 0) {
            this.startElement.style.top = startPoint.y - this.startElement.offsetHeight / 2 + "px";
        }

        index = i;
        let arrInterPoint = this.nodesToPoints(i, startPoint, endPoint, this.nodeCountForSection()[i], startendOffset, sectionLength, sectionGap);
        arrInterPoint.map(
            function (point, j) {
                pathString = pathString + (!isCurved ? (j == 0 ? " M" : " L") + point.x + " " + point.y : "");
                if (isCurved && j > 0) {
                    pathString = pathString + " L" + point.x + " " + point.y;
                    this.drawPath(svg, pathString);
                    pathString = " M" + point.x + " " + point.y;
                    isCurved = false;
                    this.endElement.style.top = point.y - this.endElement.offsetHeight / 2 + "px";
                } else if (j > 0 && j < arrInterPoint.length - 1) {
                    this.drawPath(svg, pathString);
                    pathString = " M" + point.x + " " + point.y;
                    this.endElement.style.top = point.y - this.endElement.offsetHeight / 2 + "px";
                } else if (index == noOfSection - 1 && j == arrInterPoint.length - 1) {
                    this.drawPath(svg, pathString);
                    this.endElement.style.top = point.y - this.endElement.offsetHeight / 2 + "px";
                }
            }.bind(this)
        );

        if (i != noOfSection - 1) {
            let radius = sectionGap / 2;
            let largeArcFlag = i % 2 == 0 ? 1 : 0;
            let pageoffset = noOfSection > 3 && i == 2 ? 50 : 0;
            pathString = pathString + " A" + radius + " " + radius + " " + 0 + " " + 0 + " " + largeArcFlag + " " + endPoint.x + " " + (endPoint.y + sectionGap + pageoffset);
            isCurved = true;
        }
    }

    this.arrDotPoint.map(function (point, i) {
        point.setAttribute("data-index", i);
    });
    this.arrDotPoint.sort(function (dot1, dot2) {
        return parseInt(dot1.dataset.index) - parseInt(dot2.dataset.index);
    });
    this.arrPaths.map(
        function (path, i) {
            path.setAttribute("data-index", i);
            if (i == 0) path.setAttribute("class", "start");
            if (i == this.arrPaths.length - 1) path.setAttribute("class", "end");
        }.bind(this)
    );
    this.updateNodePosition(sectionLength - sectionGap, sectionGap);
};

CurvedTimelineDiagram.prototype.updateNodePosition = function (sectionWidth, sectionGap) {
    this.arrDiagramNode.map(
        function (node, i) {
            let nodeParent = node.parentNode.parentElement;
            let previousPoint = this.arrNodePoints[i - 1];
            let point = this.arrNodePoints[i];
            let nextPoint = this.arrNodePoints[i + 1];

            if (point) {
                let widthFactor = 3;
                if (!previousPoint && nextPoint && nextPoint.y != point.y) widthFactor = 1.5;
                else if (previousPoint && nextPoint && previousPoint.y != point.y && nextPoint.y != point.y) widthFactor = 1.5;
                else if (!nextPoint && previousPoint && previousPoint.y != point.y) widthFactor = 1.5;
                let nodeWidth = sectionWidth / widthFactor;
                let nodeHeight = sectionGap - 40;
                nodeParent.style.width = nodeWidth + "px";
                nodeParent.style.height = nodeHeight + "px";

                let contentNode = nodeParent.querySelector("[name='contentNode']");
                let contentHeight = contentNode?.clientHeight + 20 || 40;
                nodeParent.style.top = point.y - contentHeight + "px";
                nodeParent.style.left = point.x - nodeParent.clientWidth / 2 + "px";
            }
        }.bind(this)
    );
};

CurvedTimelineDiagram.prototype.nodesToPoints = function (index, startPoint, endPoint, noOfNodes, startendOffset, sectionLength) {
    let timelineParent = this.diagramParent.querySelector("#timelineparent");
    let nodeGap = sectionLength / (noOfNodes + 1);
    let arrInterPoint = [startPoint];
    let arrPoint = [];
    let arrDots = [];
    for (var i = 1; i < noOfNodes + 1; i++) {
        let point = {};
        point.x = startendOffset / 2 + nodeGap * i;
        point.y = startPoint.y;
        arrPoint.push(point);

        let div = document.createElement("div");
        div.className = "dot clsNodeBackgroundbg clsBorderAccent clsMultiColorParent";
        timelineParent.appendChild(div);
        div.style.left = point.x - div.offsetWidth / 2 + "px";
        div.style.top = point.y - div.offsetHeight / 2  + "px";
        arrDots.push(div);
    }
    if (index % 2 != 0) {
        arrPoint = arrPoint.reverse();
        arrDots = arrDots.reverse();
    }
    this.arrDotPoint = this.arrDotPoint.concat(arrDots);
    this.arrNodePoints = this.arrNodePoints.concat(arrPoint);
    arrInterPoint = arrInterPoint.concat(arrPoint);
    arrInterPoint.push(endPoint);
    return arrInterPoint;
};

CurvedTimelineDiagram.prototype.drawPath = function (svg, pathString) {
    let path = DiagramNodeUtils.createSVGElement("path");
    path.setAttribute("d", pathString);
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", "var(--timeline-stroke-color)");
    path.setAttribute("stroke-width", "var(--timelinestroke)");
    path.setAttribute("id", "animatepath");
    svg.appendChild(path);

    this.arrPaths.push(path);
};

CurvedTimelineDiagram.prototype.nodeCountForSection = function () {
    switch (this.arrDiagramNode.length) {
        case 3:
            return [1, 1, 1];
        case 4:
            return [1, 2, 1];
        case 5:
            return [2, 2, 1];
        case 6:
            return [2, 2, 2];
        case 7:
            return [1, 2, 1, 1, 1, 1];
        case 8:
            return [1, 2, 1, 1, 2, 1];
        case 9:
            return [2, 2, 1, 1, 2, 1];
        case 10:
            return [2, 2, 1, 2, 2, 1];
        case 11:
            return [2, 2, 2, 2, 2, 1];
        case 12:
            return [2, 2, 2, 2, 2, 2];
    }
};

CurvedTimelineDiagram.prototype.getItemCountForPage = function (pageNumber) {
    if (this.arrDiagramNode.length <= 6 && pageNumber == 1) return this.arrDiagramNode.length;
    else if (this.arrDiagramNode.length <= 6 && pageNumber == 2) return 0;

    let arrSetionPoint = this.nodeCountForSection();
    const firstHalf = arrSetionPoint.splice(0, 3);
    const firstPageCount = firstHalf.reduce(function (a, b) {
        return a + b;
    }, 0);

    if (pageNumber == 1) return firstPageCount;
    if (pageNumber == 2) return this.arrDiagramNode.length - firstPageCount;
};

CurvedTimelineDiagram.prototype.slideDimensionChange = function () {
    this.drawTimeline();
};

CurvedTimelineDiagram.prototype.setDiagramSpecficOption = function (obj) {
    let startendelementoption = {};
    startendelementoption.start = {};
    startendelementoption.end = {};
    startendelementoption.start.isOn = this.diagramData.properties.customproperties.isstartenable;
    startendelementoption.end.isOn = this.diagramData.properties.customproperties.isendenable;
    obj.dpcontent.floatdiagramsettings.startendelementoption = startendelementoption;
    obj.dpcontent.floatdiagramsettings.year = { isOn: this.diagramData.properties.customproperties.isyearenable, property: "Year", label: "Year" };
    obj.dpcontent.slidecomponent = { bgImage: false, takeAwayText: false };
    obj.isDisableLayoutOption = "true";

    delete obj.dpcontent.floatdiagramsettings.graphicvalueformat;
    obj.dpcontent.floatdiagramsettings.dateformat = DiagramUtils.getDateFormatInlineData(this);
};

CurvedTimelineDiagram.prototype.showHideStartEnd = function (operation) {
    let timeline = this.diagramParent.querySelector("#timelineparent");
    if (operation.property == "start") {
        this.isStartEnable = operation.value;
        this.diagramParent.setAttribute("data-isstartenable", operation.value);
        timeline.style.setProperty("--startOpacity", operation.value ? "visible" : "hidden");
        this.diagramData.properties.customproperties.isstartenable = operation.value;
    } else if (operation.property == "end") {
        this.isEndEnable = operation.value;
        this.diagramParent.setAttribute("data-isendenable", operation.value);
        timeline.style.setProperty("--endOpacity", operation.value ? "visible" : "hidden");
        this.diagramData.properties.customproperties.isendenable = operation.value;
    }
    this.updatePathBasedOnNodes();
};

CurvedTimelineDiagram.prototype.showHideYear = function (operation) {
    this.diagramParent.setAttribute("data-isyearenable", operation.value);
    this.diagramData.properties.customproperties.isyearenable = operation.value;
    this.diagramParent.style.setProperty("--yearDisplay", operation.value ? "visible" : "hidden");
};

CurvedTimelineDiagram.prototype.updateStartEndYear = function () {
    let timeline = this.diagramParent.querySelector("#timelineparent");
    if (timeline && this.diagramData.properties.customproperties) {
        timeline.style.setProperty("--startOpacity", this.diagramData.properties.customproperties.isstartenable ? "visible" : "hidden");
        timeline.style.setProperty("--endOpacity", this.diagramData.properties.customproperties.isendenable ? "visible" : "hidden");
    }
    if (this.diagramData.properties.customproperties) this.diagramParent.style.setProperty("--yearDisplay", this.diagramData.properties.customproperties.isyearenable ? "visible" : "hidden");
};

CurvedTimelineDiagram.prototype.customproperties = function () {
    return {
        isstartenable: !this.diagramParent.dataset.hasOwnProperty("isstartenable") || this.diagramParent.dataset.isstartenable == "true",
        isendenable: !this.diagramParent.dataset.hasOwnProperty("isendenable") || this.diagramParent.dataset.isendenable == "true",
        isyearenable: !this.diagramParent.dataset.hasOwnProperty("isyearenable") || this.diagramParent.dataset.isyearenable == "true",
    };
};

CurvedTimelineDiagram.prototype.getProperties = function (defaultproperties = {}) {
    let properties = SimpleLinearDiagram.prototype.getProperties.call(this, defaultproperties);
    properties.customproperties = this.customproperties();
    return properties;
};

CurvedTimelineDiagram.prototype.setPropertiesFromConstants = function (mainObj, constArrProperties, extraAttrib = "") {
    SimpleLinearDiagram.prototype.setPropertiesFromConstants.call(this, mainObj, constArrProperties, extraAttrib);

    let arrCusProps = ["isstartenable", "isendenable", "isyearenable"];

    arrCusProps.map((prop) => {
        if (mainObj.customproperties?.hasOwnProperty(prop)) {
            this.diagramParent.setAttribute("data-" + prop, mainObj.customproperties[prop]);
        }else if (mainObj.customproperties){
            this.diagramParent.setAttribute("data-" + prop, true);
            this.diagramData.properties.customproperties[prop] = true;
        }
    }); 
};

//Animation related functions
CurvedTimelineDiagram.prototype.initPresent = function (currentSlideData) {
    this.diagramParent = currentSlideData.querySelector("[id='diagramparent']");
    if (this.diagramParent.parentElement.dataset.animationtype && this.diagramParent.parentElement.dataset.animationtype == "none") return { isTitleAnimation: false, isGraphicAnimation: false };
    let moodanimation = this.diagramParent.parentElement.dataset.moodanimation;
    if (moodanimation && moodanimation == "none") {
        if (this.diagramParent) this.diagramParent.style.opacity = 1;
        if (this.splitLine && this.splitLine.parentElement) this.splitLine.parentElement.style.opacity = 1;
        return { isTitleAnimation: false, isGraphicAnimation: false };
    }
    if (this.diagramParent) this.diagramParent.style.opacity = 0;
    this.splitLine = currentSlideData.querySelector("[id='splitline']");
    if (this.splitLine && this.splitLine.parentElement) this.splitLine.parentElement.style.opacity = 0;
    this.arrDiagramNode.map((node, i) => {
        let nodeParent = node.getNodeParent().parentElement;
        nodeParent.removeAttribute("data-animation");
        nodeParent.classList.remove("moodanimation");
        let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
        arrObj.map((item) => {
            item.removeAttribute("data-animation");
            item.classList.remove("moodanimation");
        });
    });
    return { isTitleAnimation: false, isGraphicAnimation: false };
};

CurvedTimelineDiagram.prototype.setupAnimation = function (animationType = "one", callback) {
    this.animationIndex = 0;
    this.allAtOnceIndex = 0;
    this.animationCompleteCallback = callback;
    this.animationType = animationType;

    let moodAnimationDisable = this.diagramParent.parentElement.dataset.moodanimation;
    this.animationFactor = moodAnimationDisable && moodAnimationDisable == "none" ? 0 : 1;

    if (this.animationType == "none") {
        this.diagramParent.style.opacity = 1;
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return;
    }

    if (!this.moodData.animationData.multislideAnimation)
        this.arrDiagramNode.map(
            function (node, index) {
                let nodeItem = node.nodeGroup;
                let connector = this.arrDotPoint[index];
                this.hideAnimation(nodeItem.parentElement, connector, 0, false);
            }.bind(this)
        );

    if (!this.moodData.animationData.multislideAnimation)
        this.arrPaths.map(
            function (path, i) {
                let pathLength = path.getTotalLength();
                path.setAttribute("stroke-dasharray", pathLength);
                path.setAttribute("stroke-dashoffset", pathLength);
                path.setAttribute("data-length", pathLength);
                let animateClass = this.animationFactor == 1 ? "timelinepath" : "";
                let classname = i == 0 ? animateClass + " start" : animateClass;
                classname = i == this.arrPaths.length - 1 ? animateClass + " end" : classname;
                path.setAttribute("class", classname);
            }.bind(this)
        );

    this.arrDotPoint.sort(function (dot1, dot2) {
        return parseInt(dot1.dataset.index) - parseInt(dot2.dataset.index);
    });

    this.startElement.style.transition = "";
    this.startElement.style.transform = "scale(0)";
    this.endElement.style.transition = "";
    this.endElement.style.transform = "scale(0)";

    this.firstPageItemCount = this.getItemCountForPage(1);
    if (this.diagramParent.dataset.projectionindex) this.setProjection(this.diagramParent.dataset.projectionindex);

    this.diagramParent.style.transition = `all ${0.3 * this.animationFactor}s`;
    // this.diagramParent.style.transition = "all 0.6s";
    this.diagramParent.style.opacity = 1;
    
    if (animationType == "all") this.playAllAtOnce()
        else this.animationCompleteCallback?.fn?.(this.animationCompleteCallback.params);
};

CurvedTimelineDiagram.prototype.playNext = function (index, isAllAtOnce = false) {
    this.updateAnimationPath("show");
    if (this.arrDiagramNode.length == this.animationIndex) {
        // if (this.moodData.animationData.isHideAnimation) {
        //     this.diagramParent.style.transition = "all 1s " + this.cubicPath;
        //     this.diagramParent.style.opacity = 0;
        // }
        return false;
    }

    this.diagramParent.style.opacity = 1;
    if (!this.isForwardAnimation) this.animationIndex += 1;

    let node = this.arrDiagramNode[this.animationIndex].getNodeParent();
    if (node.dataset.highlight && node.dataset.highlight == "true") {
        this.isShowHighlight = true;
        this.highlightIndex = parseInt(node.dataset.index);
    }

    this.isForwardAnimation = true;
    let delay = 0;

    if (this.startElement.style.transform == "scale(0)" && this.isStartEndEnable) {
        this.startElement.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        this.startElement.style.transform = "scale(1)";
        delay = delay + 0.4;
    }

    let path = this.arrPaths[this.animationIndex];
    if (path) {
        path.setAttribute("style", "transition: all " + 0.5 * this.animationFactor + "s");
        setTimeout(() => {
            path.setAttribute("stroke-dashoffset", 0);
        }, delay * 1000 * this.animationFactor);

        delay = delay + 0.3;
    }

    this.animationIndex > this.firstPageItemCount - 1 ? this.gotoPage(2) : this.gotoPage(1);
    if (this.currentPageIndex == 1 && this.isTitleAnimation == "show") {
        this.titleSubtitleAnimation?.("hide");
        this.isTitleAnimation = "hide";
    }
    delay = this.showAnimation(node, this.arrDotPoint[this.animationIndex], delay);

    if (this.animationIndex == this.arrDiagramNode.length - 1) {
        let path = this.arrPaths[this.arrPaths.length - 1];
        path.setAttribute("style", "transition: all " + 0.5 * this.animationFactor + "s");
        if (path) {
            setTimeout(() => {
                path.setAttribute("stroke-dashoffset", 0);
            }, delay * 1000 * this.animationFactor);
            this.endElement.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
            this.endElement.style.transform = "scale(1)";
        }
    }

    setTimeout(() => {
        if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, delay * 1000 * this.animationFactor);
    this.animationIndex += 1;

    return true;
};

CurvedTimelineDiagram.prototype.playPrevious = function (index, isAllAtOnce = false) {
    this.updateAnimationPath("hide");
    if (this.animationIndex == -1) {
        this.diagramParent.style.transition = "all 1s " + this.cubicPath;
        this.diagramParent.style.opacity = 0;
        return false;
    }
    this.diagramParent.style.opacity = 1;

    if (this.isForwardAnimation) {
        this.isForwardAnimation = false;
        this.animationIndex -= 1;
    }

    this.isReversAnimation = true;
    let delay = 0;

    if (this.endElement.style.transform == "scale(1)") {
        this.endElement.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        this.endElement.style.transform = "scale(0)";
        delay = delay + 0.5;
        if (this.animationIndex == this.arrDiagramNode.length - 1) {
            let path = this.arrPaths[this.arrPaths.length - 1];
            if (path) {
                path.setAttribute("stroke-dashoffset", path.dataset.length);
            }
        }
        setTimeout(() => {
            this.playPrevious();
        }, delay * this.animationFactor * 1000 * this.animationFactor);
        return true;
    }

    let currentIndex = this.animationIndex;
    let nodeItem = this.arrDiagramNode[this.animationIndex].parentNode;
    let connector = this.arrDotPoint[this.animationIndex];
    delay = this.hideAnimation(nodeItem.parentElement, connector, delay * this.animationFactor, this.animationFactor == 1);

    let path = this.arrPaths[this.animationIndex];
    if (path) {
        setTimeout(() => {
            currentIndex > this.firstPageItemCount ? this.gotoPage(2) : this.gotoPage(1);
            if (this.currentPageIndex == 0 && this.isTitleAnimation == "hide") {
                this.titleSubtitleAnimation?.("show");
                this.isTitleAnimation = "show";
            }
            path.setAttribute("style", "transition: all " + 0.5 * this.animationFactor + "s");
            path.setAttribute("stroke-dashoffset", path.dataset.length);
        }, delay * 1000 * this.animationFactor);
    }

    this.animationIndex -= 1;

    if (this.animationIndex < 0) {
        delay = delay + 0.3;
        this.startElement.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        this.startElement.style.transform = "scale(0)";
    }

    setTimeout(() => {
        if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, delay * 1000 * this.animationFactor);
    return true;
};

CurvedTimelineDiagram.prototype.playAllAtOnce = function () {
    this.itemPerPage = this.getItemCountForPage(this.allAtOnceIndex + 1);
    if (!this.itemPerPage) return false;
    this.playNext(0, true);
    this.animateItemCount = 1;
    var interval = setInterval(() => {
        this.playNext(0, true);
        this.animateItemCount += 1;
        if (this.animationCompleteCallback && this.animateItemCount == this.itemPerPage) {
            this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
            clearInterval(interval);
        }
    }, 1200 * this.animationFactor);
    this.allAtOnceIndex += 1;
    return true;
};

CurvedTimelineDiagram.prototype.playAllAtOnceReverse = function () {
    this.itemPerPage = this.getItemCountForPage(this.allAtOnceIndex);
    if (!this.itemPerPage) return false;
    this.playPrevious(0, true);
    this.animateItemCount = 1;
    var interval = setInterval(() => {
        this.playPrevious(0, true);
        this.animateItemCount += 1;
        if (this.animationCompleteCallback && this.animateItemCount == this.itemPerPage) {
            this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
            clearInterval(interval);
        }
    }, 1200 * this.animationFactor);
    this.allAtOnceIndex -= 1;
    return true;
};

CurvedTimelineDiagram.prototype.updateAnimationPath = function (type) {
    this.cubicPath = "";
    try {
        this.cubicPath = this.moodData.animationData[type].animation.all.effect;
    } catch (error) {
        this.cubicPath = "";
        console.log("Erro accessind timeline animation data LinearHorizontalTimeline.js");
    }
};

CurvedTimelineDiagram.prototype.hideAnimation = function (nodeItem, connector, delay, isAnimate = true) {
    // let targetId = this.getCustomProperties().timeline.element;

    let durationFactor = isAnimate ? "" : "no";
    let delayFactor = isAnimate ? 1 : 0;

    // let targetObj = nodeItem.querySelector("[data-id*='" + targetId + "']");
    // targetObj.style.transition = "";
    // targetObj.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    // // delay = delay + 0.2;
    // targetObj.style.transform = "scale(0)";

    let positionY = "40px";

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    if (seconday) {
        seconday.style.transition = "";
        seconday.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        seconday.style.transform = "translateY(" + positionY + ")";
        seconday.style.setProperty("opacity", 0, "important");
    }

    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    if (primary) {
        primary.style.transition = "";
        primary.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        primary.style.transform = "translateY(" + positionY + ")";
        primary.style.setProperty("opacity", 0, "important");
    }

    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "";
        number.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        number.style.transform = "translateY(" + positionY + ")";
        number.style.setProperty("opacity", 0, "important");
    }

    connector.style.transition = "";
    connector.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    connector.style.transform = "scale(0)";

    return delay;
};

CurvedTimelineDiagram.prototype.showAnimation = function (nodeItem, connector, delay) {
    connector.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    delay = delay + 0.4;
    connector.style.transform = "scale(1)";

    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        number.style.transform = "translateY(0px)";
        number.style.setProperty("opacity", 1, "important");
    }

    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    if (primary) {
        primary.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        primary.style.transform = "translateY(0px)";
        primary.style.setProperty("opacity", 1, "important");
    }

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    if (seconday) {
        seconday.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        seconday.style.transform = "translateY(0px)";
        seconday.style.setProperty("opacity", 1, "important");
    }

    return delay;
};

//Page navigation related function
CurvedTimelineDiagram.prototype.gotoPage = function (pageNumber) {
    let yPosition = pageNumber == 1 ? "0px" : -this.diagramParent.parentElement.clientHeight + "px";
    this.diagramParent.style.transform = "translate(0px, " + yPosition + ")";
    this.currentPageIndex = pageNumber - 1;

    let currentSlide = this.diagramParent.parentElement.parentElement.parentElement;
    DiagramAnimateUtil.updateTitleVisiblity(currentSlide, pageNumber > 1);
};

CurvedTimelineDiagram.prototype.setupNavigation = function (navigationContent) {
    navigationContent.imagelist = [];
    let pageCount = this.arrDiagramNode.length > 6 ? 2 : 1;
    for (var i = 0; i < pageCount; i++) {
        navigationContent.imagelist.push({});
    }
    navigationContent.imagestackselectedindex = this.currentPageIndex ? this.currentPageIndex : 0;
    return navigationContent;
};

CurvedTimelineDiagram.prototype.navigation = function (navigation) {
    if (navigation.direction == "next") {
        if (this.currentPageIndex == 1 || this.arrDiagramNode.length <= 6) return false;
        this.currentPageIndex += 1;
        this.gotoPage(this.currentPageIndex + 1);
        if (this.currentPageIndex > 0) this.titleSubtitleAnimation?.("hide");
    } else {
        if (this.currentPageIndex <= 0) return false;
        this.currentPageIndex -= 1;
        this.gotoPage(this.currentPageIndex + 1);
        if (this.currentPageIndex <= 0) this.titleSubtitleAnimation?.("show");
    }
    return true;
};

//Floater related function
CurvedTimelineDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable = [...new Set(mainProperties.floateroptionsdisable.concat(this.floateroptionsdisable()))];
    } else mainProperties.floateroptionsdisable = this.floateroptionsdisable();
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

CurvedTimelineDiagram.prototype.floateroptionsdisable = function () {
    return ["swap", "contentoptions", "sequencetext", "primarytext", "arrange", "numbersize", "animateoneatatime", "highlight"];
};

CurvedTimelineDiagram.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    dict["crossout"] = null;
    if (elTarget.getAttribute("name") && elTarget.getAttribute("name") == "secondaryTextItem") return;
    var tlIndex = elTarget.dataset.index;
    let val = this.diagramParent.dataset.projectionindex && this.diagramParent.dataset.projectionindex == tlIndex;
    dict["projection"] = { visible: true, value: val, floaterproperty: "projection" };
    if (strSelectionType == "primaryText" || strSelectionType == "numberNode") this.getFontSizeDataForInlineFloater(dict, elTarget);
};

//Projection related function
CurvedTimelineDiagram.prototype.projection = function (property) {
    var index = property.targetid.replace(/\D/g, "");
    property.value ? this.diagramParent.setAttribute("data-projectionindex", index) : this.diagramParent.removeAttribute("data-projectionindex");
    this.setProjection(property.value ? index : 100);
};

CurvedTimelineDiagram.prototype.setProjection = function (projectionIndex) {
    this.removeOldProjection();
    let index = projectionIndex;
    this.arrDiagramNode.map(
        function (node, i) {
            let nodeParent = node.parentNode.parentElement;
            let isProjectionEnable = parseInt(nodeParent.dataset.index) >= parseInt(index);
            isProjectionEnable ? nodeParent.classList.add("clstimelineprojection") : nodeParent.classList.remove("clstimelineprojection");
            let connertorPoint = this.arrDotPoint[i];
            if (connertorPoint) isProjectionEnable ? connertorPoint.classList.add("clstimelineprojection") : connertorPoint.classList.remove("clstimelineprojection");
            let path = this.arrPaths[i + 1];
            if (path) {
                isProjectionEnable ? path.classList.add("clstimelineprojection") : path.classList.remove("clstimelineprojection");
                if (isProjectionEnable) {
                    let overLayPath = path.cloneNode(true);
                    overLayPath.setAttribute("id", "overlaypath");
                    overLayPath.setAttribute("stroke", "rgba(var(--single-bg-color-rgb), 1)");
                    overLayPath.setAttribute("stroke-dasharray", 10);
                    path.parentElement.appendChild(overLayPath);
                }
            }
        }.bind(this)
    );
};

CurvedTimelineDiagram.prototype.removeOldProjection = function () {
    let arrOldProjection = Array.from(this.diagramParent.querySelectorAll("#overlaypath"));
    arrOldProjection.map((projection) => projection.parentElement.removeChild(projection));
};

CurvedTimelineDiagram.prototype.updateDateFormat = function (obj) {
    this.arrDiagramNode.forEach((node) => node.updateDateFormat?.(obj));
};

/**
 * Author:    Krishna Prabhu M
 * Created:   19 April 2021
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function ZigZagTimelineDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    LinearHorizontalTimeline.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "zigzagtimeline";
    this.contentOffset = 15;
    this.padding = 50;
    this.startEndBorderPadding = 20;
    this.diagramParent.setAttribute("data-togglecategory", "zigzag-timeline");
    this.diagramParent.parentElement.setAttribute("data-ismultislide", true);
}

ZigZagTimelineDiagram.prototype = Object.create(LinearHorizontalTimeline.prototype);
ZigZagTimelineDiagram.prototype.constructor = ZigZagTimelineDiagram;

ZigZagTimelineDiagram.prototype.initDiagramCreation = function () {
    LinearHorizontalTimeline.prototype.initDiagramCreation.call(this);
};

ZigZagTimelineDiagram.prototype.setDiagramWidth = function () {
    this.startElementPadding = this.isStartEnable ? 10 : 0;
    this.endElementPadding = this.isEndEnable ? 10 : 0;
    this.startElement.style.display = this.isStartEnable ? "block" : "none";
    this.endElement.style.display = this.isEndEnable ? "block" : "none";

    this.diagramParent.style.setProperty("--commonnodeitemwidth", "calc(100% - 20px)", "important");
    this.diagramParent.style.setProperty("--timelinecintentwidth", this.diagramParent.clientHeight * 0.166 + "px", "important");
    this.diagramParent.parentElement.style.setProperty("--timelinepadding", 50 + "px", "important");
    let nodeOrder = this.getNodePostion();
    let arr = this.splitArrayWithOrder(nodeOrder, this.arrDiagramNode);
    let widthObj = this.setNodelWidth(arr);

    DiagramUtils.setCustomItemColor(this.endElement, this.arrTintArray, this.arrDiagramNode.length - 1, this.arrDiagramNode.length);
    this.diagramParent.style.minWidth = this.diagramParent.parentElement.clientWidth - this.startElement.clientWidth - this.endElement.clientWidth - this.startElementPadding - this.endElementPadding - 100 + "px";
    this.diagramParent.style.width = widthObj.parentWidth + "px";
    this.splitLine.parentElement.style.width = widthObj.parentWidth + this.startElement.clientWidth + this.endElement.clientWidth + this.startElementPadding + this.endElementPadding + "px";

    this.totalPage = Math.ceil(this.splitLine.parentElement.offsetWidth / this.diagramParent.parentElement.offsetWidth - this.pageEpsilon);


    this.updateTimelineElements();
    this.setOffsetLeftTop();
};

ZigZagTimelineDiagram.prototype.setGroupWidth = function () {
    let pattenDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    if (pattenDiv) {
        pattenDiv.style.setProperty("--contentWidth", "100px");
        try {
            if (this.arrDiagramNode[0].getNodeParent().querySelector("[data-id='diagramContentNode']").querySelector("[data-id='contentnumberparent']")) {
                pattenDiv.style.setProperty("--contentWidth", "170px");
            }
        } catch (error) {
            console.log("LinearVerticalTimeline.prototype.setGroupWidth " + error);
        }
    }
};

ZigZagTimelineDiagram.prototype.drawTimeline = function () {
    this.arrConnectorPoints = [];
    let oldTimeline = this.diagramParent.parentElement.querySelector("[data-id='timeline']");
    if (oldTimeline) {
        oldTimeline.parentElement.removeChild(oldTimeline);
        this.splitLine = null;
    }

    this.totalPage = 1;
    this.currentPageIndex = 0;
    this.diagramParent.style.transform = "translateX(0px)";

    let timeline = document.createElement("div");
    timeline.className = "zigzagtimelinebar clsMultiColorParent";
    timeline.id = "timeline-" + this.diagramParent.getAttribute("parent-Id");
    timeline.setAttribute("data-id", "timeline");
    this.diagramParent.parentElement.appendChild(timeline);

    let splitLine = document.createElement("div");
    splitLine.className = "splitline clsMultiColorParent";
    splitLine.id = "splitline";
    timeline.appendChild(splitLine);
    this.splitLine = splitLine;
    this.splitLine.setAttribute("data-create", Math.random());

    let lineSvg = DiagramNodeUtils.createSVGElement("svg");
    lineSvg.setAttribute("class", "linesvg");
    lineSvg.setAttribute("id", "linesvg");
    timeline.appendChild(lineSvg);

    let startElement = document.createElement("div");
    startElement.className = "timelinestartelement clsMultiColorParent clsBorderAccent secondary-color p3";
    startElement.id = "timelinestartelement";
    startElement.innerText = "START";
    timeline.appendChild(startElement);
    DiagramUtils.setCustomItemColor(startElement, this.arrTintArray, 0, 1);
    this.startElement = startElement;

    let endElement = document.createElement("div");
    endElement.className = "timelineendelement clsMultiColorParent clsBorderAccent secondary-color p3";
    DiagramUtils.setCustomItemColor(endElement, this.arrTintArray, this.arrDiagramNode.length - 1, this.arrDiagramNode.length);
    endElement.id = "timelineendelement";
    endElement.innerText = "END";
    timeline.appendChild(endElement);
    this.endElement = endElement;

    if (this.diagramData.properties.customproperties.hasOwnProperty("isyearenable")) {
        this.diagramParent.style.setProperty("--yearDisplay", this.diagramData.properties.customproperties.isyearenable ? "flex" : "none");
    }
};

ZigZagTimelineDiagram.prototype.updateNodePosition = function () {
    let isApplySplit = this.getCustomProperties().node.split;
    switch (this.getCustomProperties().node.position) {
        case "top":
            this.nodeAlignTop();
            break;
        case "bottom":
            this.nodeAlignBottom();
            break;
        case "alternate":
            this.nodeAlignAlternate();
            break;
        case "middle":
            isApplySplit ? this.nodeAlignSplit() : this.nodeAlignMiddle();
            break;
    }
};

ZigZagTimelineDiagram.prototype.updateConnectorPoints = function () {
    if (this.splitLine == null || this.getCustomProperties().nodeconnector.visible == false) return;
    let i = 0;
    while (this.arrConnectorPoints.length < this.arrDiagramNode.length) {
        let connectorPoint = document.createElement("div");
        connectorPoint.className = "connectorpoint clsBorderAccent clsNodeBackgroundbg clsMultiColorParent";
        connectorPoint.id = "connectorpoint";
        this.splitLine.appendChild(connectorPoint);
        DiagramUtils.setCustomItemColor(connectorPoint, this.arrTintArray, i, i + 1);
        this.arrConnectorPoints.push(connectorPoint);
        i += 1;
    }

    while (this.arrConnectorPoints.length > this.arrDiagramNode.length) {
        let point = this.arrConnectorPoints[this.arrConnectorPoints.length - 1];
        point.parentElement.removeChild(point);
        this.arrConnectorPoints.pop();
    }

    let startElement = this.diagramParent.parentElement.querySelector("#timelinestartelement");
    let arrPoints = this.splitLine.querySelectorAll("[id='connectorpoint']");
    this.arrDiagramNode.map(
        function (node, i) {
            let point = arrPoints[i];
            let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
            let nodeRect = DiagramNodeUtils.getOffsetRectByParent(nodeHolder, node.nodeGroup);
            let leftPadding = this.isStartEnable ? startElement.clientWidth : -7;
            let centerX = leftPadding + nodeRect.x + nodeRect.width / 2;
            centerX = centerX - point.clientWidth / 2;
            if (point) point.style.left = centerX + "px";
            point.style.width = node.parentNode.parentElement.clientWidth + "px";
        }.bind(this)
    );
};

ZigZagTimelineDiagram.prototype.createZigZagPath = function () {
    let svg = this.diagramParent.parentElement.querySelector("#linesvg");

    let arrOldPath = svg.querySelectorAll("#line");
    arrOldPath.forEach(path => {
        if (path.parentElement) path.parentElement.removeChild(path)
    });

    let startElement = this.diagramParent.parentElement.querySelector("#timelinestartelement");
    let endElement = this.diagramParent.parentElement.querySelector("#timelineendelement");
    endElement.style.top = "unset";
    endElement.style.bottom = "unset";
    this.arrDiagramNode.length % 2 == 0 ? endElement.style.top = "10px" : endElement.style.bottom = "10px";

    let startPoint = { x: 80, y: 80 };
    let endY = this.arrDiagramNode.length % 2 == 0 ? 70 : 80;
    let endPoint = { x: (endElement.offsetLeft - endElement.clientWidth / 2) - 5, y: endY };

    if (!this.isStartEnable) {
        let firstPoint = this.arrConnectorPoints[0];
        startPoint = { x: firstPoint.offsetLeft + (firstPoint.clientWidth / 2), y: firstPoint.offsetTop + 7 + (firstPoint.clientHeight / 2) };
    }
    if (!this.isEndEnable) {
        let lastPoint = this.arrConnectorPoints[this.arrConnectorPoints.length - 1];
        endPoint = { x: lastPoint.offsetLeft + (lastPoint.clientWidth / 2), y: lastPoint.offsetTop + 7 + (lastPoint.clientHeight / 2) };
    }

    this.arrConnectorPoints.forEach(function (point, i) {
        let yOffset = i % 2 == 0 ? 3 : 10
        let currentPoint = { x: point.offsetLeft + 7 + (point.clientWidth / 2), y: point.offsetTop + yOffset + (point.clientHeight / 2) };
        let line = this.createLine(startPoint, currentPoint, i);
        line.setAttribute("id", "line");
        svg.appendChild(line);
        startPoint = currentPoint;

        if (i == this.arrConnectorPoints.length - 1) {
            let line = this.createLine(startPoint, endPoint, this.arrConnectorPoints.length - 1);
            line.setAttribute("id", "line");
            svg.appendChild(line);
        }
    }.bind(this));

    if (this.diagramParent.dataset.projectionindex) this.setProjection(this.diagramParent.dataset.projectionindex);
};

ZigZagTimelineDiagram.prototype.createLine = function (startPoint, endPoint, i) {
    let line = DiagramNodeUtils.createSVGElement("line");
    DiagramNodeUtils.assignSVGNodeAttributes(line, { x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y, "stroke-width": 7, "class": "clsAccentStroke clsMultiColorParent svgline" });
    DiagramUtils.setCustomItemColor(line, this.arrTintArray, i, i + 1);
    return line;
};

ZigZagTimelineDiagram.prototype.updateSlideBasedNodeWidth = function (arrNodes, width) {
    arrNodes.map(
        function (node) {
            node.getNodeParent().parentElement.style.setProperty("flex", "unset", "important");
            node.getNodeParent().parentElement.style.width = width + "px";
        }.bind(this)
    );
};

ZigZagTimelineDiagram.prototype.slideDimensionChange = function () {
    this.setDiagramWidth();
    this.setGroupWidth();
};

ZigZagTimelineDiagram.prototype.getCustomProperties = function () {
    let props = {
        timeline: {
            type: this.diagramParent.dataset.timelinetype || "horizontal",
            style: this.diagramParent.dataset.timelinestyle || "strigntline",
            startelement: this.diagramParent.dataset.startelement && this.diagramParent.dataset.startelement == "false" ? false : true,
            endelement: this.diagramParent.dataset.endelement && this.diagramParent.dataset.endelement == "false" ? false : true,
            isstartendenable: this.diagramParent.dataset.isstartendenable && this.diagramParent.dataset.isstartendenable == "false" ? false : true,
            position: this.diagramParent.dataset.timelineposition || "middle",
            element: this.diagramParent.dataset.timelineelement || "diagramContentNode",
        },
        nodeconnector: {
            visible: this.diagramParent.dataset.connectorvisible && this.diagramParent.dataset.connectorvisible == "false" ? false : true,
            connectorline: true,
            connectingobject: this.diagramParent.dataset.connectorconnectingobject || "diagramContentNode",
        },
        node: {
            position: "middle",
            positionoffset: 50,
            split: true,
            splitalign: "bottom",
            splitorder: "order1",
            splitgap: 50,
        },
    };
    return props;
};

ZigZagTimelineDiagram.prototype.updateConnectorLine = function () {
    this.arrConnectorPoints.map(
        function (connector, index) {
            if (index % 2 != 0) {
                connector.style.top = "unset";
                connector.style.bottom = "0px";
            } else {
                connector.style.bottom = "unset";
                connector.style.top = "0px";
            }
        }.bind(this)
    );
};

ZigZagTimelineDiagram.prototype.nodeAlignSplit = function () {
    this.arrDiagramNode.map(
        function (node, index) {
            let targetId = this.getCustomProperties().timeline.element;
            let nodeItem = node.nodeGroup;
            let targetObj = node.nodeGroup.querySelector("[data-id*='" + targetId + "']");

            let splitGap = parseFloat(this.getCustomProperties().node.splitgap);

            targetObj.style.marginTop = "unset";
            targetObj.style.marginBottom = "unset";

            this.alternateOrder(node.nodeGroup, index);
            if (index % 2 != 0) {
                targetObj.style.marginBottom = splitGap + "px";
                targetObj.style.setProperty("margin-bottom", splitGap + "px", "important");
                this.alignTimelineElement(nodeItem, targetObj, splitGap);
            } else {
                targetObj.style.marginTop = splitGap + "px";
                targetObj.style.setProperty("margin-top", splitGap + "px", "important");
                this.alignTimelineElement(nodeItem, targetObj, splitGap, "bottom");
            }
        }.bind(this)
    );
};

ZigZagTimelineDiagram.prototype.alternateOrder = function (node, index) {
    let arrOrder = [
        [1, 2, 0, 3],
        [2, 1, 3, 0]
    ];

    let primary = node.querySelector("[data-id*='primaryTextNode']");
    let number = node.querySelector("[data-id*='contentnumberparent']");
    let secondary = node.querySelector("[data-id*='secondaryTextNode']");
    let content = node.querySelector("[data-id*='diagramContentNode']");

    primary.style.order = arrOrder[index % 2][0];
    if (number) number.style.order = arrOrder[index % 2][1];
    secondary.style.order = arrOrder[index % 2][2];
    content.style.order = arrOrder[index % 2][3];
};

ZigZagTimelineDiagram.prototype.alignTimelineElement = function (nodeItem, targetObj, splitGap = 0, align = "top") {
    nodeItem.style.bottom = "unset";
    nodeItem.style.top = "unset";
    let timelineRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, this.splitLine);
    let targetObjRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, targetObj);

    let secContent = nodeItem.querySelector("[name='secContentNode']");
    if (secContent) secContent.style.maxHeight = timelineRect.y - 20 + "px";
    nodeItem.parentElement.setAttribute("data-align-position", align);
    if (align == "top") {
        nodeItem.style.top = timelineRect.y + timelineRect.height - targetObj.clientHeight - 50 + "px";
    } else {
        nodeItem.style.bottom = this.diagramParent.clientHeight - (targetObj.clientHeight + timelineRect.y + 50) + "px";
    }
    this.setValueAlign(nodeItem, align);
};

ZigZagTimelineDiagram.prototype.initPresent = function (currentSlideData) {
    this.diagramParent = currentSlideData.querySelector("[id='diagramparent']");
    if (this.diagramParent.parentElement.dataset.animationtype && this.diagramParent.parentElement.dataset.animationtype == "none") return { isTitleAnimation: false, isGraphicAnimation: false };
    if (this.diagramParent) this.diagramParent.style.opacity = 0;
    this.splitLine = currentSlideData.querySelector("[id='splitline']");
    if (this.splitLine && this.splitLine.parentElement) this.splitLine.parentElement.style.opacity = 0;
    this.arrDiagramNode.map((node, i) => {
        let nodeParent = node.getNodeParent().parentElement;
        nodeParent.removeAttribute("data-animation");
        nodeParent.classList.remove("moodanimation");
        let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
        arrObj.map((item) => {
            item.removeAttribute("data-animation");
            item.classList.remove("moodanimation");
        });
    });

    return { isTitleAnimation: true, isGraphicAnimation: false };
};

ZigZagTimelineDiagram.prototype.setupAnimation = function (animationType = "one", callback) {
    this.animationIndex = 0;
    this.allAtOnceIndex = 0;
    this.animationCompleteCallback = callback;
    this.animationType = animationType;
    this.arrPaths = Array.from(this.diagramParent.parentElement.querySelectorAll("#line"));

    if (this.animationType == "none") {
        this.diagramParent.style.opacity = 1;
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return;
    }
    this.diagramParent.style.transition = "all 0.6s";

    this.arrDiagramNode.map(
        function (node, index) {
            let nodeItem = node.nodeGroup;
            let connector = this.arrConnectorPoints[index];
            this.hideAnimation(nodeItem.parentElement, connector, 0, false);
        }.bind(this)
    );
    this.arrPaths.map(function (path) {
        let pathLength = path.getTotalLength();
        path.setAttribute("stroke-dasharray", pathLength);
        path.setAttribute("stroke-dashoffset", pathLength);
        path.setAttribute("data-length", pathLength);
    });

    this.arrConnectorPoints.sort(function (dot1, dot2) {
        return parseInt(dot1.dataset.index) - parseInt(dot2.dataset.index)
    })

    this.startElement.style.transition = "";
    this.startElement.style.transform = "scale(0)";
    this.endElement.style.transition = "";
    this.endElement.style.transform = "scale(0)";

    if (this.diagramParent.dataset.projectionindex) this.setProjection(this.diagramParent.dataset.projectionindex);

    let moodAnimationDisable = this.diagramParent.parentElement.dataset.moodanimation;
    this.animationFactor = moodAnimationDisable && moodAnimationDisable == "none" ? 0 : 1;
    this.diagramParent.style.transition = `all ${0.3 * this.animationFactor}s`;
    this.diagramParent.style.opacity = 1;
    animationType == "all" ? this.playAllAtOnce() : this.playNext();

};

ZigZagTimelineDiagram.prototype.playNext = function (index, isAllAtOnce = false) {
    this.updateAnimationPath("show");
    if (this.arrDiagramNode.length == this.animationIndex) {
        if (this.moodData.animationData.isHideAnimation) {
            this.diagramParent.style.transition = "all 1s " + this.cubicPath;
            this.diagramParent.style.opacity = 0;
            this.splitLine.parentElement.style.transition = "all 1s " + this.cubicPath;
            this.splitLine.parentElement.style.opacity = 0;
        }
        // if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return false;
    }

    this.diagramParent.style.opacity = 1;
    this.splitLine.parentElement.style.opacity = 1;

    if (this.isReversAnimation) {
        this.animationIndex += 1;
        this.isReversAnimation = false;
    }

    let node = this.arrDiagramNode[this.animationIndex].getNodeParent();
    if (node.dataset.highlight && node.dataset.highlight == "true") {
        this.isShowHighlight = true;
        this.highlightIndex = parseInt(node.dataset.index);
    }

    this.isForwardAnimation = true;
    let delay = 0;
    if (this.startElement.style.transform == "scale(0)" && this.isStartEnable) {
        this.startElement.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        this.startElement.style.transform = "scale(1)";
        delay = delay + 0.4;
    }

    let nodeItem = this.arrDiagramNode[this.animationIndex].nodeGroup;
    let connector = this.arrConnectorPoints[this.animationIndex];

    let path = this.arrPaths[this.animationIndex];
    if (path) {
        setTimeout(() => {
            path.setAttribute("stroke-dashoffset", 0);
        }, delay * 1000);

        delay = delay + 0.3;
    }

    if ((this.animationIndex > 0 && !this.isStartEnable) || this.isStartEnable) {
        let isInside = DiagramNodeUtils.isRectInSideRectHorizontaly(this.diagramParent.parentElement, nodeItem);
        if (!isInside) {
            this.moveNext(true);
            this.pageIndex += 1;
        }
    }

    delay = this.showAnimation(nodeItem.parentElement, connector, delay * this.animationFactor, this.animationIndex);
    if (this.animationIndex == this.arrDiagramNode.length - 1 && this.endElement.style.transform == "scale(0)" && this.isEndEnable) {
        let path = this.arrPaths[this.arrPaths.length - 1];
        if (path) {
            setTimeout(() => {
                path.setAttribute("stroke-dashoffset", 0);
            }, delay * 1000);

        }
        delay = delay + 0.3;
        this.endElement.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        this.endElement.style.transform = "scale(1)";
    }
    setTimeout(() => {
        if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, delay * 1000);
    this.animationIndex += 1;

    return true;
};

ZigZagTimelineDiagram.prototype.playPrevious = function (index, isAllAtOnce = false) {
    this.updateAnimationPath("hide");

    if (this.animationIndex == -1) {
        this.diagramParent.style.transition = "all 1s " + this.cubicPath;
        this.diagramParent.style.opacity = 0;
        this.splitLine.parentElement.style.transition = "all 1s " + this.cubicPath;
        this.splitLine.parentElement.style.opacity = 0;
        // if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return false;
    }
    this.diagramParent.style.opacity = 1;
    this.splitLine.parentElement.style.opacity = 1;
    if (this.isForwardAnimation) {
        this.isForwardAnimation = false;
        this.animationIndex -= 1;
    }

    this.isReversAnimation = true;
    let delay = 0;


    if (this.endElement.style.transform == "scale(1)") {
        this.endElement.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        this.endElement.style.transform = "scale(0)";
        delay += 0.3;
        let path = this.arrPaths[this.arrPaths.length - 1];
        if (path) {
            setTimeout(() => {
                path.setAttribute("stroke-dashoffset", path.dataset.length);
            }, delay * 1000);
            delay += 0.3;
        }

        setTimeout(() => {
            this.playPrevious();
        }, delay * this.animationFactor * 1000);
        return true;
    }


    let nodeItem = this.arrDiagramNode[this.animationIndex].nodeGroup;
    let connector = this.arrConnectorPoints[this.animationIndex];
    delay = this.hideAnimation(nodeItem.parentElement, connector, delay * this.animationFactor, this.animationFactor == 1);
    if (this.animationIndex == 0 && this.endElement.style.transform == "scale(1)") {
        this.endElement.style.transform = "scale(0)";
    }
    let path = this.arrPaths[this.animationIndex];
    if (path) {
        setTimeout(() => {
            path.setAttribute("stroke-dashoffset", path.dataset.length);
        }, delay * 1000);
        delay += 0.2;
    }
    this.animationIndex -= 1;
    if (this.animationIndex >= 0) {
        let connector = this.arrConnectorPoints[this.animationIndex];

        let previousIndex = this.animationIndex > 0 ? this.animationIndex : 0;
        let prevoiuseNode = this.arrDiagramNode[previousIndex].nodeGroup;
        let isInside = DiagramNodeUtils.isRectInSideRectHorizontaly(this.diagramParent.parentElement, prevoiuseNode);
        if (!isInside) {
            this.movePrevious(true);
            this.pageIndex -= 1;
        }
    } else {
        this.startElement.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        this.startElement.style.transform = "scale(0)";
    }

    setTimeout(() => {
        if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, delay * 1000);
    return true;
};

ZigZagTimelineDiagram.prototype.updateAnimationPath = function (type) {
    this.cubicPath = "";
    try {
        this.cubicPath = this.moodData.animationData[type].animation.all.effect;
    } catch (error) {
        this.cubicPath = "";
        console.log("Erro accessind timeline animation data LinearHorizontalTimeline.js");
    }
};

ZigZagTimelineDiagram.prototype.hideAnimation = function (nodeItem, connector, delay, isAnimate = true) {
    let durationFactor = isAnimate ? "" : "no";
    let delayFactor = isAnimate ? 1 : 0;

    let positionY = "40px";
    let targetId = this.getCustomProperties().timeline.element;
    let targetObj = nodeItem.querySelector("[data-id*='" + targetId + "']");
    targetObj.style.transition = "";
    targetObj.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    // delay = delay + 0.2;
    targetObj.style.transform = "scale(0)";

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    seconday.style.transition = "";
    seconday.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    seconday.style.transform = "translateY(" + positionY + ")";
    seconday.style.setProperty("opacity", 0, "important");

    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    primary.style.transition = "";
    primary.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    primary.style.transform = "translateY(" + positionY + ")";
    primary.style.setProperty("opacity", 0, "important");

    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "";
        number.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        number.style.transform = "translateY(" + positionY + ")";
        number.style.setProperty("opacity", 0, "important");
    }

    connector.style.transition = "";
    connector.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    connector.style.transform = "scale(0)";

    return delay;
};

ZigZagTimelineDiagram.prototype.showAnimation = function (nodeItem, connector, delay) {
    connector.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    delay = delay + 0.4;
    connector.style.transform = "scale(1)";

    let targetId = this.getCustomProperties().timeline.element;
    let targetObj = nodeItem.querySelector("[data-id*='" + targetId + "']");
    targetObj.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    // delay = delay + 0.2;
    targetObj.style.transform = "scale(1)";

    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        number.style.transform = "translateY(0px)";
        number.style.setProperty("opacity", 1, "important");
    }

    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    primary.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    primary.style.transform = "translateY(0px)";
    primary.style.setProperty("opacity", 1, "important");

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    seconday.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
    delay = delay + 0.2;
    seconday.style.transform = "translateY(0px)";
    seconday.style.setProperty("opacity", 1, "important");

    return delay;
};

ZigZagTimelineDiagram.prototype.setProjection = function (projectionIndex) {
    this.arrPaths = Array.from(this.diagramParent.parentElement.querySelectorAll("#line"));
    let index = projectionIndex;;
    this.arrDiagramNode.map(
        function (node, i) {
            let nodeParent = node.parentNode.parentElement;
            let isProjectionEnable = parseInt(nodeParent.dataset.index) >= parseInt(index);
            isProjectionEnable ? nodeParent.classList.add("clstimelineprojection") : nodeParent.classList.remove("clstimelineprojection");
            let connertorPoint = this.arrConnectorPoints[i];
            if (connertorPoint) isProjectionEnable ? connertorPoint.classList.add("clstimelineprojection") : connertorPoint.classList.remove("clstimelineprojection");

            let path = this.arrPaths[i + 1];
            if (path) isProjectionEnable ? path.classList.add("clstimelineprojection") : path.classList.remove("clstimelineprojection");
        }.bind(this)
    );
};

ZigZagTimelineDiagram.prototype.checkForPadding = function () {
    if (this.arrDiagramNode.length > 0) {
        let nodeItem = this.arrDiagramNode[0].parentNode;

        let secContent = nodeItem.querySelector("[name='secContentNode']");
        if (secContent) {
            let valueText = secContent.querySelector("[name='valueTitleHolder']");
            if (!valueText) this.diagramParent.style.setProperty("--primarypadding", "70px")
            else this.diagramParent.style.setProperty("--primarypadding", "20px")
        }

    }
};

ZigZagTimelineDiagram.prototype.createElements = function () {
    LinearHorizontalTimeline.prototype.createElements.call(this);
    this.setGroupWidth();
};

ZigZagTimelineDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    LinearHorizontalTimeline.prototype.updateFloaterSettings.call(this, mainProperties);
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable.push("graphiclogo");
    } else mainProperties.floateroptionsdisable = ["graphiclogo"];
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

// deleting the below function will crash
ZigZagTimelineDiagram.prototype.updateDottedLineHeight = function (connector, height, isTop = true) { };
/**
 * Author:    Krishna Prabhu M
 * Created:   14 June 2021
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function SimpleLinearTimeline(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "simpletimeline";
    this.fontClassName = "timeline";
    this.pageIndex = 1;
    this.totalPage = 1;
    this.itemPerPage = 4;
    this.allAtOnceIndex = 0;
    this.animationIndex = 0;
    this.navigationIndex = 0;
    this.animateItemCount = 0;
    this.currentPageIndex = 0;
    this.isForwardAnimation = 0;
    this.isReversAnimation = 0;
    this.isStartEnable = true;
    this.isEndEnable = true;

    this.padding = 0;
    this.cubicPath = "";
    this.pageEpsilon = 0.1;
    this.isRenderComplete = false;
    this.animationFactor = 1;

    this.diagramParent.setAttribute("data-toggleassets", "true");
    this.diagramParent.setAttribute("data-togglecategory", "hor-timeline");
    this.diagramParent.setAttribute("data-currencyformat", "disable");
}

SimpleLinearTimeline.prototype = Object.create(SimpleLinearDiagram.prototype);
SimpleLinearTimeline.prototype.constructor = SimpleLinearTimeline;

SimpleLinearTimeline.prototype.initDiagramCreation = function () {
    this.diagramParent.parentElement.style.overflow = "hidden";
    this.diagramParent.parentElement.removeAttribute("graphicanimateid");
    this.diagramParent.parentElement.setAttribute("data-ismultislide", "true");

    this.diagramParent.innerHTML = "";
    this.diagramParent.style.transform = "unset";
    this.diagramParent.style.setProperty("--contentResizeMH", "unset");
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.createPatternBackGround();
    this.gotoPage(0);
    this.currentPageIndex = 0;
    this.diagramRenderComplete();
};

SimpleLinearTimeline.prototype.updateElements = function (defaultproperties) {
    SimpleLinearDiagram.prototype.updateElements.call(this, defaultproperties);

    this.totalPage = 1;
    this.pageIndex = 1;
    this.allAtOnceIndex = 0;
    this.animationIndex = 0;
    this.navigationIndex = 0;
    this.currentPageIndex = 0;
    this.isForwardAnimation = 0;
    this.isReversAnimation = 0;
    this.pageEpsilon = 0.1;

    this.totalPage = Math.ceil(this.diagramParent.offsetWidth / this.diagramParent.parentElement.offsetWidth - this.pageEpsilon);
    this.diagramParent.style.transform = "translateX(0px)";
    this.isStartEnable = this.diagramParent.dataset.isstartenable && this.diagramParent.dataset.isstartenable == "false" ? false : true;
    this.isEndEnable = this.diagramParent.dataset.isendenable && this.diagramParent.dataset.isendenable == "false" ? false : true;
    this.setDiagramWidth();
    this.currentPageIndex = 0;
};

SimpleLinearTimeline.prototype.recreateElementData = function () {
    SimpleLinearDiagram.prototype.recreateElementData.call(this);
    this.totalPage = Math.ceil(this.diagramParent.offsetWidth / this.diagramParent.parentElement.offsetWidth - this.pageEpsilon);
    this.diagramParent.style.transform = "translateX(0px)";
};

SimpleLinearTimeline.prototype.diagramSpecificCalculation = function () {
    SimpleLinearDiagram.prototype.diagramSpecificCalculation.call(this);
    this.setDiagramWidth();
    this.currentPageIndex = this.totalPage - 1;
    if (this.createZigZagPath) this.createZigZagPath();
    this.gotoPage(this.currentPageIndex);
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
};

SimpleLinearTimeline.prototype.swapNodes = function (objData, swapNodeIndex) {
    SimpleLinearDiagram.prototype.swapNodes.call(this, objData, swapNodeIndex);
    let pIndex = this.currentPageIndex;

    this.setDiagramWidth();
    if (this.createZigZagPath) this.createZigZagPath();
    this.currentPageIndex = pIndex;
    this.gotoPage(pIndex);
};

SimpleLinearTimeline.prototype.setDiagramWidth = function (focusLastpage = true) {
    this.diagramParent.style.setProperty("--commonnodeitemwidth", "calc(100% - 20px)", "important");
    this.diagramParent.style.setProperty("--timelinecintentwidth", this.diagramParent.clientHeight * 0.166 + "px", "important");
    this.diagramParent.parentElement.style.setProperty("--timelinepadding", 50 + "px", "important");
    let nodeOrder = this.getNodePostion();
    let arr = this.splitArrayWithOrder(nodeOrder, this.arrDiagramNode);
    let widthObj = this.setNodelWidth(arr);

    this.diagramParent.style.minWidth = this.diagramParent.parentElement.clientWidth - this.endElementPadding - 100 + "px";
    this.diagramParent.style.width = widthObj.parentWidth + "px";

    this.totalPage = Math.ceil(this.diagramParent.offsetWidth / this.diagramParent.parentElement.offsetWidth - this.pageEpsilon);
    // if (focusLastpage) this.currentPageIndex = this.totalPage - 1;
    this.setOffsetLeftTop();
};

SimpleLinearTimeline.prototype.setNodelWidth = function (arrOrderedNodes) {
    let firstSlideOffsetWidth = 0;
    let lastSlideOffsetWidth = 0;
    firstSlideOffsetWidth = arrOrderedNodes.length == 1 ? firstSlideOffsetWidth + lastSlideOffsetWidth : firstSlideOffsetWidth;

    let padding = 0; //arrOrderedNodes.length > 1 ? 50 : 100;
    let firstSlideWidth = this.diagramParent.parentElement.clientWidth - padding - firstSlideOffsetWidth;
    let centerSlideWidth = this.diagramParent.parentElement.clientWidth;
    let lastSlideWidth = this.diagramParent.parentElement.clientWidth - padding - lastSlideOffsetWidth;
    let totalWidth = 0;
    let diffWidth = 0;
    let firstNodeWidth = 0;

    for (var i = 0; i < arrOrderedNodes.length; i++) {
        if (i == 0) {
            //first slide
            let nodeWidth = firstSlideWidth / arrOrderedNodes[i].length;
            firstNodeWidth = nodeWidth;
            this.updateSlideBasedNodeWidth(arrOrderedNodes[i], nodeWidth);
            totalWidth = totalWidth + firstSlideWidth;
        } else if (i == arrOrderedNodes.length - 1) {
            //last slide
            let nodeWidth = lastSlideWidth / arrOrderedNodes[i].length;
            let diffWidthCount = arrOrderedNodes[i].length - arrOrderedNodes[i].length;
            diffWidth = nodeWidth * diffWidthCount;
            this.updateSlideBasedNodeWidth(arrOrderedNodes[i], nodeWidth);
            totalWidth = totalWidth + lastSlideWidth;
        } else {
            //remaining slide
            let nodeWidth = centerSlideWidth / arrOrderedNodes[i].length;
            this.updateSlideBasedNodeWidth(arrOrderedNodes[i], nodeWidth);
            totalWidth = totalWidth + centerSlideWidth;
        }
    }

    let timelineWidth = totalWidth - diffWidth;

    return { parentWidth: totalWidth, timelineWidth: timelineWidth, nodeWidth: firstNodeWidth };
};

SimpleLinearTimeline.prototype.defaultFoucsOut = function (event) {
    // return
    let index = event.target.dataset.index;
    if (event.target.id.includes("secondaryText")) {
        if (event.target.firstElementChild && event.target.firstElementChild.innerText.trim() == "") event.target.firstElementChild.innerHTML = "";
        this.setSecondaryIconList(event.target, index);
    }
    if (event.target.className && event.target.className.includes("clsSingleLineRestrict")) {
        event.target.innerText = DiagramUtils.removelinebreaks(event.target.textContent);
    }

    let typedText = event.target.dataset && event.target.dataset.oldtext ? event.target.dataset.oldtext : "";
    if (event.target.innerHTML != typedText && this.appmode != "PRESENT") {
        if (this.arrDiagramNode && this.arrDiagramNode[index] && this.arrDiagramNode[index].numberToggleStyle) {
            this.arrDiagramNode[index].numberToggleStyle.updateNumberToggleNodeForSign(event.target, this.arrDiagramNode[index].parentNode.parentElement);
        }
        this.eventManagerXY.dispatch("focusout", event.target);
        event.target.dataset.oldtext = event.target.innerHTML;
        this.resetImageLogoFrames();
        // this.updatePropsCallBack(event.target.id);
        this.updateJSONData();
        this.updateTextNodes(index); // need to discuss

        event.target.scrollTop = 0;
        event.target.parentNode.scrollTop = 0;
    }
    if (event.target.dataset.id == "numberNode") {
        DiagramNodeUtils.checkNumberFormat(event.target, this.diagramParent, this.globalMoodData, this.nodeProps);
        this.checkSMLOverflow();
        this.updatePropsCallBack();
        return;
    }
    this.checkContentType();
    this.updateCssAttributes();
};

// primaryTextNode secondaryTextNode diagramContentNode sequenceTextNode
SimpleLinearTimeline.prototype.customproperties = function () {
    return {
        isstartenable: !this.diagramParent.dataset.hasOwnProperty("isstartenable") || this.diagramParent.dataset.isstartenable == "true",
        isendenable: !this.diagramParent.dataset.hasOwnProperty("isendenable") || this.diagramParent.dataset.isendenable == "true",
        isyearenable: !this.diagramParent.dataset.hasOwnProperty("isyearenable") || this.diagramParent.dataset.isyearenable == "true",
    };
};

SimpleLinearTimeline.prototype.getProperties = function (defaultproperties = {}) {
    let properties = SimpleLinearDiagram.prototype.getProperties.call(this, defaultproperties);
    properties.customproperties = this.customproperties();
    return properties;
};

SimpleLinearTimeline.prototype.setPropertiesFromConstants = function (mainObj, constArrProperties, extraAttrib = "") {
    SimpleLinearDiagram.prototype.setPropertiesFromConstants.call(this, mainObj, constArrProperties, extraAttrib);
    if (this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.hasOwnProperty("isstartenable")) {
        this.diagramParent.setAttribute("data-isstartenable", this.diagramData.properties.customproperties.isstartenable);
    }
    if (this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.hasOwnProperty("isendenable")) {
        this.diagramParent.setAttribute("data-isendenable", this.diagramData.properties.customproperties.isendenable);
    }
    if (this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.hasOwnProperty("isyearenable")) {
        this.diagramParent.setAttribute("data-isyearenable", this.diagramData.properties.customproperties.isyearenable);
    }
};

// ****** Timeline related function

SimpleLinearTimeline.prototype.showHideStartEnd = function (operation) {
    if (operation.property == "start") {
        this.isStartEnable = operation.value;
        this.diagramParent.setAttribute("data-isstartenable", operation.value);
        this.diagramData.properties.customproperties.isstartenable = operation.value;
    } else if (operation.property == "end") {
        this.isEndEnable = operation.value;
        this.diagramParent.setAttribute("data-isendenable", operation.value);
        this.diagramData.properties.customproperties.isendenable = operation.value;
    }

    this.setDiagramWidth();
    if (this.createZigZagPath) this.createZigZagPath();
};

SimpleLinearTimeline.prototype.showHideYear = function (operation) {
    this.diagramParent.setAttribute("data-isyearenable", operation.value);
    this.diagramData.properties.customproperties.isyearenable = operation.value;
    this.diagramParent.style.setProperty("--yearDisplay", operation.value ? "flex" : "none");
};

// ******* Node Animation related function

SimpleLinearTimeline.prototype.setupAnimation = function (animationType, callback) {
    this.animationCompleteCallback = callback;
    this.animationType = animationType;
    this.highlightIndex = -1;

    this.diagramParent.style.transform = "translateX(0px)";

    this.pageIndex = 1;
    this.totalPage = Math.ceil(this.diagramParent.offsetWidth / this.diagramParent.parentElement.offsetWidth - this.pageEpsilon);
    this.animationIndex = 0;
    this.currentPageIndex = 0;
    this.animateItemCount = 0;
    this.allAtOnceIndex = 0;
    this.nodeAnimationTime = animationType == "all" ? 6 : 1;
    this.animationFactor = this.diagramParent.parentElement.dataset.moodanimation && this.diagramParent.parentElement.dataset.moodanimation == "none" ? 0 : 1;

    this.diagramParent.style.transform = "translateX(0px)";

    if (this.animationType == "none") {
        this.diagramParent.style.opacity = 1;
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return;
    }

    this.arrDiagramNode.map(
        function (node, index) {
            let nodeItem = node.nodeGroup;
            let nodeParent = node.parentNode.parentElement;
            nodeParent.removeAttribute("data-animation");
            nodeParent.classList.remove("moodanimation");
            this.hideAnimation(nodeItem.parentElement, null, 0, false);
        }.bind(this)
    );

    this.diagramParent.style.transition = `all ${0.3 * this.animationFactor}s`;
    this.diagramParent.style.opacity = 1;
    if (animationType == "all") this.playAllAtOnce();
    else this.animationCompleteCallback?.fn?.(this.animationCompleteCallback.params);
};

SimpleLinearTimeline.prototype.playNext = function (index, isAllAtOnce = false) {
    this.updateAnimationPath("show");
    if (this.arrDiagramNode.length == this.animationIndex) {
        if (this.moodData.animationData.isHideAnimation) {
            this.diagramParent.style.transition = `all ${1 * this.animationFactor}s ${this.cubicPath}`;
            this.diagramParent.style.opacity = 0;
        }
        // if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return false;
    }

    this.diagramParent.style.opacity = 1;

    if (this.isReversAnimation) {
        this.animationIndex += 1;
        this.isReversAnimation = false;
    }

    let node = this.arrDiagramNode[this.animationIndex].getNodeParent();
    if (node.dataset.highlight && node.dataset.highlight == "true") {
        this.isShowHighlight = true;
        this.highlightIndex = parseInt(node.dataset.index);
    }

    this.isForwardAnimation = true;
    let delay = 0;

    let nodeItem = this.arrDiagramNode[this.animationIndex].nodeGroup;

    if (this.animationIndex > 0) {
        let isInside = DiagramNodeUtils.isRectCenterInSideRectHorizontaly(this.diagramParent.parentElement, nodeItem);
        if (!isInside) {
            this.moveNext(true);
            this.pageIndex += 1;
        }
    }

    delay = this.showAnimation(nodeItem.parentElement, null, delay * this.animationFactor, this.animationIndex);
    setTimeout(() => {
        if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, delay * 1000);
    this.animationIndex += 1;

    return true;
};

SimpleLinearTimeline.prototype.playPrevious = function (index, isAllAtOnce = false) {
    this.updateAnimationPath("hide");

    if (this.animationIndex == -1) {
        this.diagramParent.style.transition = `all ${1 * this.animationFactor}s ${this.cubicPath}`;
        this.diagramParent.style.opacity = 0;
        return false;
    }

    this.diagramParent.style.opacity = 1;
    if (this.isForwardAnimation) {
        this.isForwardAnimation = false;
        this.animationIndex -= 1;
    }

    this.isReversAnimation = true;
    let delay = 0;

    let nodeItem = this.arrDiagramNode[this.animationIndex].nodeGroup;
    delay = this.hideAnimation(nodeItem.parentElement, null, delay * this.animationFactor, this.animationFactor == 1);

    this.animationIndex -= 1;
    if (this.animationIndex >= 0) {
        let previousIndex = this.animationIndex > 0 ? this.animationIndex : 0;
        let prevoiuseNode = this.arrDiagramNode[previousIndex].nodeGroup;
        let isInside = DiagramNodeUtils.isRectCenterInSideRectHorizontaly(this.diagramParent.parentElement, prevoiuseNode);
        if (!isInside) {
            this.movePrevious(true);
            this.pageIndex -= 1;
        }
    }

    setTimeout(() => {
        if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, delay * 1000);
    return true;
};

SimpleLinearTimeline.prototype.moveNext = function (isAnimate = false) {
    let slideWidth = this.diagramParent.parentElement.offsetWidth;
    let diagramWidth = this.diagramParent.parentElement.scrollWidth;

    this.diagramParent.style.transition = isAnimate ? "all " + 1.2 * this.animationFactor + "s " + this.cubicPath : "";

    let translateX = parseFloat(window.getComputedStyle(this.diagramParent).transform.replace("matrix(", "").split(",")[4]);
    translateX = Math.abs(translateX);
    let oldTransateX = translateX;
    let diffWidth = diagramWidth - translateX + 5;
    if (diffWidth - slideWidth >= slideWidth || diffWidth >= slideWidth) {
        translateX = translateX + slideWidth;
        this.diagramParent.style.transform = "translateX(" + -translateX + "px)";
        this.navigationIndex += 1;
    } else {
        translateX = translateX + (slideWidth - diffWidth);
        translateX = Math.abs(translateX);
        this.diagramParent.style.transform = "translateX(" + -translateX + "px)";
        if (oldTransateX != translateX) this.navigationIndex += 1;
    }
};

SimpleLinearTimeline.prototype.movePrevious = function (isAnimate = false) {
    let slideWidth = this.diagramParent.parentElement.offsetWidth;
    let translateX = parseFloat(window.getComputedStyle(this.diagramParent).transform.replace("matrix(", "").split(",")[4]);
    translateX = Math.abs(translateX);

    this.diagramParent.style.transition = isAnimate ? "all " + 1.4 * this.animationFactor + "s " + this.cubicPath : "";
    if (translateX > slideWidth) {
        translateX = translateX - slideWidth;
        this.diagramParent.style.transform = "translateX(" + -translateX + "px)";
        this.navigationIndex -= 1;
    } else if (translateX > 0) {
        translateX = 0;
        this.diagramParent.style.transform = "translateX(" + -translateX + "px)";
        this.navigationIndex -= 1;
    }
};

// primaryTextNode secondaryTextNode diagramContentNode sequenceTextNode
SimpleLinearTimeline.prototype.hideAnimation = function (nodeItem, connector, delay, isAnimate = true) {
    // nodeItem.style.opacity = 0;
    this.diagramParent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "hide";
    DiagramAnimateUtil.setAnimationToNodeItems(this, nodeItem, "hide", isAnimate);
};

SimpleLinearTimeline.prototype.showAnimation = function (nodeItem, connector, delay, index) {
    nodeItem.style.opacity = 1;
    this.diagramParent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "show";
    DiagramAnimateUtil.setAnimationToNodeItems(this, nodeItem, "show", this.animationFactor == 0 ? false : true);
};

SimpleLinearTimeline.prototype.navigation = function (navigation) {
    if (navigation.direction == "next") {
        // this.moveNext();
        if (this.currentPageIndex == this.totalPage - 1) return false;
        this.currentPageIndex += 1;
        this.gotoPage(this.currentPageIndex);
    } else {
        // this.movePrevious();
        if (this.currentPageIndex == 0) return false;
        this.currentPageIndex -= 1;
        this.gotoPage(this.currentPageIndex);
    }
    return true;
};

SimpleLinearTimeline.prototype.addFocus = function (index) {
    // this.totalPage = Math.ceil(this.diagramParent.offsetWidth / this.diagramParent.parentElement.offsetWidth - this.pageEpsilon);
    // this.currentPageIndex = this.totalPage - 1;
    // let primaryTextNode = this.diagramParent.querySelector("[data-id='primaryTextNode'][data-index='" + index + "']");
    // this.gotoPage(this.currentPageIndex);
    // setTimeout(() => {
    //     if (primaryTextNode) primaryTextNode.firstElementChild.focus();
    // }, 0);
    // primaryTextNode.firstElementChild.focus();
};

SimpleLinearTimeline.prototype.gotoPage = function (pageIndex) {
    let slideWidth = this.diagramParent.parentElement.offsetWidth;
    let diagramWidth = this.diagramParent.offsetWidth;
    let translateX = 0;
    if (diagramWidth > slideWidth) {
        let pagePositionX = slideWidth * pageIndex;
        let calWidth = diagramWidth - slideWidth;

        if (pagePositionX <= calWidth) {
            translateX = pagePositionX;
        } else {
            translateX = calWidth;
        }
        this.diagramParent.style.transform = "translateX(" + -translateX + "px)";
    } else {
        this.diagramParent.style.transform = "translateX(0px)";
    }

    this.setOffsetLeftTop();
};

SimpleLinearTimeline.prototype.playAllAtOnce = function () {
    this.itemPerPage = this.getNodePostion()[this.allAtOnceIndex];
    if (!this.itemPerPage) return false;
    this.playNext(0, true);
    this.animateItemCount = 1;
    var interval = setInterval(() => {
        this.playNext(0, true);
        this.animateItemCount += 1;
        if (this.animationCompleteCallback && this.animateItemCount == this.itemPerPage) {
            setTimeout(() => {
                this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
            }, 2000 * this.animationFactor);
            clearInterval(interval);
        }
    }, 1000 * this.animationFactor);
    this.allAtOnceIndex += 1;
    return true;
};

SimpleLinearTimeline.prototype.playAllAtOnceReverse = function () {
    this.itemPerPage = this.getNodePostion()[this.allAtOnceIndex - 1];
    if (!this.itemPerPage) return false;

    this.playPrevious(0, true);
    this.animateItemCount = 1;
    var interval = setInterval(() => {
        this.playPrevious(0, true);
        this.animateItemCount += 1;
        if (this.animationCompleteCallback && this.animateItemCount == this.itemPerPage) {
            this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
            clearInterval(interval);
        }
    }, 1000 * this.animationFactor);
    this.allAtOnceIndex -= 1;
    return true;
};

SimpleLinearTimeline.prototype.updateCropPosition = function (node) {
    let contentNode = node.querySelector("[data-id='diagramContentNodeGroup']");
    let imageNode = contentNode.getElementsByTagName("img")[0];

    if (imageNode) {
        let position = DiagramNodeUtils.getOffsetLeftTop(contentNode);
        imageNode.setAttribute("data-x", position.x);
        imageNode.setAttribute("data-y", position.y);
        imageNode.setAttribute("data-width", contentNode.clientWidth);
        imageNode.setAttribute("data-height", contentNode.clientHeight);
    }
};

SimpleLinearTimeline.prototype.splitArray = function (splitCount, array) {
    if (splitCount >= array.length) return [JSON.parse(JSON.stringify(array))];

    let arr = [];
    let tempArr = [];
    for (var i = 0; i < array.length; i++) {
        if (i % splitCount == 0) {
            tempArr = [];
            arr.push(tempArr);
        }

        tempArr.push(array[i]);
    }

    return arr;
};

SimpleLinearTimeline.prototype.getNodePostion = function () {
    switch (this.diagramData.nodes.length) {
        case 1:
            return [1];
        case 2:
            return [2];
        case 3:
            return [3];
        case 4:
            return [4];
        case 5:
            return [3, 2];
        case 6:
            return [3, 3];
        case 7:
            return [4, 3];
        case 8:
            return [4, 4];
        case 9:
            return [3, 3, 3];
        case 10:
            return [3, 4, 3];
        case 11:
            return [4, 4, 3];
        case 12:
            return [4, 4, 4];
    }
};

SimpleLinearTimeline.prototype.splitArrayWithOrder = function (arrSplitOrder, array) {
    let tempArr = [];
    let nodeArr = [];
    let nodeCount = arrSplitOrder[0];
    for (var i = 0; i < array.length + 1; i++) {
        if (nodeArr.length == nodeCount) {
            tempArr.push(nodeArr);
            nodeArr = [];
            nodeCount = arrSplitOrder[tempArr.length];
        }
        if (array[i] == null) continue;
        nodeArr.push(array[i]);
    }
    return tempArr;
};

SimpleLinearTimeline.prototype.updateSlideBasedNodeWidth = function (arrNodes, width) {
    arrNodes.map(function (node) {
        node.getNodeParent().parentElement.style.setProperty("flex", "unset", "important");
        node.getNodeParent().parentElement.style.width = width + "px";
    });
};

SimpleLinearTimeline.prototype.updateAnimationPath = function (type) {
    this.cubicPath = "";
    try {
        this.cubicPath = this.moodData.animationData[type].animation.all?.effect || "";
    } catch (error) {
        this.cubicPath = "";
        console.log("Erro accessind timeline animation data SimpleLinearTimeline.js");
    }
};

SimpleLinearTimeline.prototype.slideDimensionChange = function () {
    this.setDiagramWidth(false);
};

SimpleLinearTimeline.prototype.setDiagramSpecficOption = function (obj) {
    obj.isDisableLayoutOption = "true";
    delete obj.dpcontent.floatdiagramsettings.graphicvalueformat;
    obj.dpcontent.floatdiagramsettings.dateformat = DiagramUtils.getDateFormatInlineData(this);

    LinearDiagram.prototype.setDiagramSpecficOption.call(this, obj);
};

SimpleLinearTimeline.prototype.setupNavigation = function (navigationContent) {
    navigationContent.imagelist = [];
    let splitLineWidth = this.diagramParent.clientWidth;
    if (this.diagramData.properties.diagramtype && this.diagramData.properties.diagramtype.includes("horizontal")) {
        let pageCount = Math.ceil(splitLineWidth / this.diagramParent.parentElement.clientWidth - this.pageEpsilon);
        for (var i = 0; i < pageCount; i++) {
            navigationContent.imagelist.push({});
        }
    }
    navigationContent.imagestackselectedindex = this.currentPageIndex ? this.currentPageIndex : 0;

    return navigationContent;
};

SimpleLinearTimeline.prototype.initPresent = function (currentSlideData) {
    this.diagramParent = currentSlideData.querySelector("[id='diagramparent']");

    if (this.diagramParent.parentElement.dataset.animationtype && this.diagramParent.parentElement.dataset.animationtype == "none") return { isTitleAnimation: false, isGraphicAnimation: false };
    if (this.diagramParent) this.diagramParent.style.opacity = 0;

    return { isTitleAnimation: true, isGraphicAnimation: false };
};

SimpleLinearTimeline.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsTimelineNodesHolder";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.appendChild(pattenDiv);

    this.updateImageRatio();
    this.createNodeInstances(nodeCount, pattenDiv);

    this.diagramData.properties.customproperties = this.diagramData.properties.customproperties ? this.diagramData.properties.customproperties : this.customproperties();

    this.isStartEnable = this.diagramData.properties.customproperties.isstartenable == undefined ? true : this.diagramData.properties.customproperties.isstartenable;
    this.isEndEnable = this.diagramData.properties.customproperties.isendenable == undefined ? true : this.diagramData.properties.customproperties.isendenable;

    this.setDiagramWidth();
    if (this.createZigZagPath) this.createZigZagPath();
    this.currentPageIndex = 0;
    this.isRenderComplete = true;
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
    this.diagramRenderComplete();
};

SimpleLinearTimeline.prototype.diagramRenderComplete = function () {
    if (this.completeCallBack && this.completeCallBack.func && this.isRenderComplete) {
        SimpleLinearDiagram.prototype.diagramRenderComplete.call(this);
    }
    this.diagramParent.style.opacity = 1;
};

SimpleLinearTimeline.prototype.setOffsetLeftTop = function () {
    let slide = this.diagramParent;
    while (slide) {
        if (slide.dataset.type == "SLIDE") break;
        slide = slide.parentElement;
    }
    if (!slide) return;
    let slideX = slide.getBoundingClientRect().x;
    let slideY = slide.getBoundingClientRect().y;
    this.arrDiagramNode.map(function (node) {
        let nodeParent = node.getNodeParent();
        if (nodeParent) {
            let contentNode = nodeParent.querySelector("[data-id='contentimageparent']");
            if (contentNode) {
                let imageNode = contentNode.querySelector("[data-id='imageNode']");
                let imageX = imageNode.getBoundingClientRect().x;
                let imageY = imageNode.getBoundingClientRect().y;
                let x = imageX - slideX;
                let y = imageY - slideY;
            }
        }
    });
};

SimpleLinearTimeline.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    let disableProperties = ["graphicnone", "sequencetext", "contentoptions", "arrange", "iconsize", "imagesize", "logosize", "content"];
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable = [...mainProperties.floateroptionsdisable, ...disableProperties];
    } else mainProperties.floateroptionsdisable = disableProperties;
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

SimpleLinearTimeline.prototype.setProjection = function (projectionIndex) {
    let index = projectionIndex;
    this.arrDiagramNode.map(
        function (node, i) {
            let nodeParent = node.parentNode.parentElement;
            let isProjectionEnable = parseInt(nodeParent.dataset.index) >= parseInt(index);
            isProjectionEnable ? nodeParent.classList.add("clstimelineprojection") : nodeParent.classList.remove("clstimelineprojection");
            let connertorPoint = this.arrConnectorPoints[i];
            if (connertorPoint) isProjectionEnable ? connertorPoint.classList.add("clstimelineprojection") : connertorPoint.classList.remove("clstimelineprojection");
        }.bind(this)
    );

    let oldSvg = this.animationLine.querySelector("#projectionSvg");
    if (oldSvg) oldSvg.parentElement.removeChild(oldSvg);
    let svg = DiagramNodeUtils.createSVGElement("svg");
    DiagramNodeUtils.assignAttributes(svg, { id: "projectionSvg", width: "100%", height: "100%", style: "top:0px; position:absolute;" });
    this.animationLine.appendChild(svg);

    let connertorPoint = this.arrConnectorPoints[index];
    let node = this.arrDiagramNode[0];
    let nodeParent = node.parentNode;
    let offset = this.isStartEnable ? 0 : nodeParent.offsetWidth / 2;
    if (!connertorPoint) return;
    let point1 = { x: connertorPoint.offsetLeft + connertorPoint.clientWidth / 2 - offset, y: this.animationLine.clientHeight / 2 };
    let point2 = { x: this.animationLine.clientWidth, y: point1.y };
    let line = this.createLine(point1, point2);
    DiagramNodeUtils.assignAttributes(line, { "stroke-width": 10, "stroke-dasharray": 10, stroke: "rgba(var(--secondary-color-rgb), 1)" });
    let bgLine = line.cloneNode(true);
    DiagramNodeUtils.assignAttributes(bgLine, { stroke: "rgba(var(--single-bg-color-rgb), 1)", "stroke-width": 10, "stroke-dasharray": 0, class: "clstimelineprojection" });
    svg.appendChild(bgLine);
    svg.appendChild(line);
};

SimpleLinearTimeline.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    dict["crossout"] = null;
    if (elTarget.getAttribute("name") && elTarget.getAttribute("name") == "secondaryTextItem") return;
    var tlIndex = elTarget.dataset.index;
    let val = this.diagramParent.dataset.projectionindex && this.diagramParent.dataset.projectionindex == tlIndex;
    dict["projection"] = { visible: true, value: val, floaterproperty: "projection" };
    if (strSelectionType == "primaryText" || strSelectionType == "numberNode") this.getFontSizeDataForInlineFloater(dict, elTarget);
};

SimpleLinearTimeline.prototype.projection = function (property) {
    var index = property.targetid.replace(/\D/g, "");
    property.value ? this.diagramParent.setAttribute("data-projectionindex", index) : this.diagramParent.removeAttribute("data-projectionindex");
    this.setProjection(property.value ? index : 100);
};

SimpleLinearTimeline.prototype.updateDateFormat = function (obj) {
    this.arrDiagramNode.forEach((node) => node.updateDateFormat?.(obj));
};

/**
 * Author:    Krishna Prabhu
 * Created:   Tus 21 Nov 2023
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function SimpleVerticalTimeline(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearVerticalDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "verticaltimeline";
    this.pageIndex = 1;
    this.totalPage = 1;
    this.itemPerPage = 4;

    this.endElement = null;
    this.animationIndex = 0;
    this.allAtOnceIndex = 0;
    this.animateItemCount = 0;
    this.currentPageIndex = 0;

    this.isForwardAnimation = 0;
    this.isReversAnimation = 0;
    this.isStartEnable = true;
    this.isEndEnable = true;
    this.isRenderComplete = false;

    this.padding = 0;
    this.cubicPath = "";
    this.animationFactor = 1;

    this.diagramParent.setAttribute("data-toggleassets", "true");
    this.diagramParent.setAttribute("data-togglecategory", "ver-timeline-tx-sty-a-1-sec");
    this.diagramParent.setAttribute("data-currencyformat", "disable");
}

SimpleVerticalTimeline.prototype = Object.create(SimpleLinearVerticalDiagram.prototype);
SimpleVerticalTimeline.prototype.constructor = SimpleVerticalTimeline;

SimpleVerticalTimeline.prototype.initDiagramCreation = function () {
    this.diagramParent.parentElement.style.overflow = "hidden";
    this.diagramParent.parentElement.setAttribute("data-ismultislide", "true");

    this.diagramParent.innerHTML = "";
    this.diagramParent.style.setProperty("--contentResizeMH", "unset");
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.createPatternBackGround();
    this.diagramRenderComplete();
};

SimpleVerticalTimeline.prototype.updateElements = function (defaultproperties) {
    SimpleLinearVerticalDiagram.prototype.updateElements.call(this, defaultproperties);

    this.pageIndex = 1;
    this.totalPage = 1;
    this.animationIndex = 0;
    this.allAtOnceIndex = 0;
    this.navigationIndex = 0;
    this.currentPageIndex = 0;
    this.isForwardAnimation = 0;
    this.isReversAnimation = 0;

    this.totalPage = Math.ceil(this.diagramParent.offsetHeight / this.diagramParent.parentElement.offsetHeight);
    this.diagramParent.style.transform = "translateY(0px)";
    this.setDiagramHeight();
    this.currentPageIndex = 0;
};

SimpleVerticalTimeline.prototype.recreateElementData = function () {
    SimpleLinearVerticalDiagram.prototype.recreateElementData.call(this);

    this.totalPage = Math.ceil(this.diagramParent.offsetHeight / this.diagramParent.parentElement.offsetHeight);
    this.diagramParent.style.transform = "translateY(0px)";
};

SimpleVerticalTimeline.prototype.addNode = function (nodeData, index, isFromUndo = false) {
    SimpleLinearVerticalDiagram.prototype.addNode.call(this, nodeData, index, isFromUndo);
    this.setDiagramHeight();
    this.currentPageIndex = this.totalPage - 1;
    this.gotoPage(this.arrDiagramNode.length - 1);
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
};

SimpleVerticalTimeline.prototype.swapNodes = function (objData, swapNodeIndex) {
    SimpleLinearDiagram.prototype.swapNodes.call(this, objData, swapNodeIndex);
    let pIndex = this.currentPageIndex;

    this.setDiagramHeight();
    this.currentPageIndex = pIndex;
    this.gotoPage(this.currentPageIndex);
};

SimpleVerticalTimeline.prototype.setNodelWidth = function (arrOrderedNodes) {
    let slideEndPadding = 0;

    let firstSlideHeight = this.diagramParent.parentElement.clientHeight;
    let centerSlideHeight = this.diagramParent.parentElement.clientHeight;
    let lastSlideHeight = this.diagramParent.parentElement.clientHeight;
    let totalHeight = 0;
    let diffHeight = 0;
    let firstNodeHeight = 0;

    for (var i = 0; i < arrOrderedNodes.length; i++) {
        if (i == 0) {
            //first slide
            let nodeHeight = firstSlideHeight / arrOrderedNodes[i].length;
            firstNodeHeight = nodeHeight;
            this.updateSlideBasednodeHeight(arrOrderedNodes[i], nodeHeight, slideEndPadding, "start");
            totalHeight = totalHeight + firstSlideHeight + slideEndPadding;
        } else if (i == arrOrderedNodes.length - 1) {
            //last slide
            let nodeHeight = lastSlideHeight / arrOrderedNodes[i].length;
            let diffHeightCount = arrOrderedNodes[i].length - arrOrderedNodes[i].length;
            diffHeight = nodeHeight * diffHeightCount;
            this.updateSlideBasednodeHeight(arrOrderedNodes[i], nodeHeight, slideEndPadding, "end");
            totalHeight = totalHeight + lastSlideHeight + slideEndPadding;
        } else {
            //remaining slide
            let nodeHeight = centerSlideHeight / arrOrderedNodes[i].length;
            this.updateSlideBasednodeHeight(arrOrderedNodes[i], nodeHeight, slideEndPadding, "mid");
            totalHeight = totalHeight + centerSlideHeight + slideEndPadding * 2;
        }
    }

    let timelineHeight = totalHeight - diffHeight;

    return { parentHeight: totalHeight, timelineHeight: timelineHeight, nodeHeight: firstNodeHeight };
};

SimpleVerticalTimeline.prototype.setDiagramHeight = function () {
    let nodeOrder = this.getNodePostion();
    let arr = this.splitArrayWithOrder(nodeOrder, this.arrDiagramNode);
    let widthObj = this.setNodelWidth(arr);

    this.diagramParent.style.minHeight = widthObj.parentHeight + "px";
    this.diagramParent.style.height = widthObj.parentHeight + "px";
    this.totalPage = Math.ceil(this.diagramParent.offsetHeight / this.diagramParent.parentElement.offsetHeight);
};

SimpleVerticalTimeline.prototype.deleteNode = function (targetIndex) {
    SimpleLinearVerticalDiagram.prototype.deleteNode.call(this, targetIndex);
    this.setDiagramHeight();
    this.gotoPage(this.pageIndex);
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
};

SimpleVerticalTimeline.prototype.getCustomProperties = function () {
    let props = {
        timeline: {
            type: this.diagramParent.dataset.timelinetype || "horizontal",
            style: this.diagramParent.dataset.timelinestyle || "strigntline",
            startelement: this.diagramParent.dataset.startelement && this.diagramParent.dataset.startelement == "false" ? false : true,
            endelement: this.diagramParent.dataset.endelement && this.diagramParent.dataset.endelement == "false" ? false : true,
            isstartenable: this.diagramParent.dataset.isstartenable && this.diagramParent.dataset.isstartenable == "false" ? false : true,
            isendenable: this.diagramParent.dataset.isendenable && this.diagramParent.dataset.isendenable == "false" ? false : true,
            position: this.diagramParent.dataset.timelineposition || "middle",
            element: this.diagramParent.dataset.timelineelement || "diagramContentNode",
        },
        node: {
            position: "middle",
            positionoffset: 50,
            split: true,
            splitalign: "alternate",
            splitorder: "order1",
            splitgap: this.diagramParent.dataset.connectorgap || "100",
        },
    };
    return props;
};

// primaryTextNode secondaryTextNode diagramContentNode contentnumberparent
SimpleVerticalTimeline.prototype.customproperties = function () {
    return {
        isstartenable: !this.diagramParent.dataset.hasOwnProperty("isstartenable") || this.diagramParent.dataset.isstartenable == "true",
        isendenable: !this.diagramParent.dataset.hasOwnProperty("isendenable") || this.diagramParent.dataset.isendenable == "true",
        isyearenable: !this.diagramParent.dataset.hasOwnProperty("isyearenable") || this.diagramParent.dataset.isyearenable == "true",
    };
};

SimpleVerticalTimeline.prototype.getProperties = function (defaultproperties = {}) {
    let properties = SimpleLinearVerticalDiagram.prototype.getProperties.call(this, defaultproperties);
    properties.customproperties = this.customproperties();
    return properties;
};

SimpleVerticalTimeline.prototype.setPropertiesFromConstants = function (mainObj, constArrProperties, extraAttrib = "") {
    SimpleLinearVerticalDiagram.prototype.setPropertiesFromConstants.call(this, mainObj, constArrProperties, extraAttrib);
    if (this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.hasOwnProperty("isstartenable")) {
        this.diagramParent.setAttribute("data-isstartenable", this.diagramData.properties.customproperties.isstartenable);
    }
    if (this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.hasOwnProperty("isendenable")) {
        this.diagramParent.setAttribute("data-isendenable", this.diagramData.properties.customproperties.isendenable);
    }
    if (this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.hasOwnProperty("isyearenable")) {
        this.diagramParent.setAttribute("data-isyearenable", this.diagramData.properties.customproperties.isyearenable);
    }
};
// ****** Timeline related function

SimpleVerticalTimeline.prototype.showHideYear = function (operation) {
    this.diagramParent.setAttribute("data-isyearenable", operation.value);
    this.diagramData.properties.customproperties.isyearenable = operation.value;
    this.diagramParent.style.setProperty("--yearDisplay", operation.value ? "flex" : "none");
};

SimpleVerticalTimeline.prototype.isNumberStyle = function () {
    let arrContent = this.nodeProps.supportedNodes.filter((node) => node.name == "contentNode");
    if (arrContent.length > 0 && arrContent[0].subNodes.length > 0 && arrContent[0].subNodes[0].name == "valueTitleHolder") {
        return true;
    }
    return false;
};

SimpleVerticalTimeline.prototype.unsetSequenceTextMargin = function () {
    this.arrDiagramNode.map(function (node) {
        let sequenceText = node.nodeGroup.querySelector("[data-id*='contentnumberparent']");
        if (sequenceText) sequenceText.style.setProperty("margin", 0, "important");
    });
};

SimpleVerticalTimeline.prototype.setupAnimation = function (animationType, callback) {
    this.animationCompleteCallback = callback;
    this.animationType = animationType;
    this.highlightIndex = -1;

    this.pageIndex = 1;
    this.totalPage = Math.ceil(this.diagramParent.offsetHeight / this.diagramParent.parentElement.offsetHeight);
    this.animationIndex = 0;
    this.allAtOnceIndex = 0;
    this.animateItemCount = 0;
    this.currentPageIndex = 0;
    this.animationFactor = this.diagramParent.parentElement.dataset.moodanimation && this.diagramParent.parentElement.dataset.moodanimation == "none" ? 0 : 1;

    this.diagramParent.style.transform = "translateY(0px)";

    if (this.animationType == "none") {
        this.diagramParent.style.opacity = 1;
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return;
    }

    if (!this.moodData.animationData.multislideAnimation)
        this.arrDiagramNode.map(
            function (node) {
                let nodeItem = node.nodeGroup;
                let nodeParent = node.parentNode.parentElement;
                nodeParent.removeAttribute("data-animation");
                nodeParent.classList.remove("moodanimation");
                this.hideAnimation(nodeItem.parentElement, null, 0, false);
            }.bind(this)
        );

    this.diagramParent.style.transition = `all ${0.3 * this.animationFactor}s`;
    this.diagramParent.style.opacity = 1;

    setTimeout(() => {
        if (animationType == "all") this.playAllAtOnce()
        else this.animationCompleteCallback?.fn?.(this.animationCompleteCallback.params)
    }, 100);
};

SimpleVerticalTimeline.prototype.playNext = function (index, isAllAtOnce = false) {
    this.updateAnimationPath("show");
    if (this.arrDiagramNode.length == this.animationIndex) {
        if (this.moodData.animationData.isHideAnimation) {
            this.diagramParent.style.transition = "all 0.2s " + this.cubicPath;
            this.diagramParent.style.opacity = 0;
        }
        // if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return false;
    }

    this.diagramParent.style.opacity = 1;

    if (this.isReversAnimation) {
        this.animationIndex += 1;
        this.isReversAnimation = false;
    }

    this.isForwardAnimation = true;
    let delay = 0;
    let nodeItem = this.arrDiagramNode[this.animationIndex].nodeGroup;

    if (this.animationIndex > 0) {
        let isInside = DiagramNodeUtils.isRectCenterInSideRectVerticaly(this.diagramParent.parentElement, nodeItem);
        if (!isInside) {
            this.gotoPage(this.pageIndex, true, true);
            this.pageIndex += 1;
        }
    }

    delay = this.showAnimation(nodeItem.parentElement, null, delay * this.animationFactor, this.animationIndex);

    setTimeout(() => {
        if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, delay * 1000);
    this.animationIndex += 1;

    return true;
};

SimpleVerticalTimeline.prototype.playPrevious = function (index, isAllAtOnce = false) {
    this.updateAnimationPath("hide");
    if (this.animationIndex == -1) {
        this.diagramParent.style.transition = "all 0.2s " + this.cubicPath;
        this.diagramParent.style.opacity = 0;
        // if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return false;
    }

    this.diagramParent.style.opacity = 1;

    if (this.isForwardAnimation) {
        this.isForwardAnimation = false;
        this.animationIndex -= 1;
    }

    this.isReversAnimation = true;
    let delay = 0;
   

    let nodeItem = this.arrDiagramNode[this.animationIndex].nodeGroup;
    delay = this.hideAnimation(nodeItem.parentElement, null, delay * this.animationFactor, this.animationFactor == 1);
    this.animationIndex -= 1;
    if (this.animationIndex >= 0) {
        let previousIndex = this.animationIndex > 0 ? this.animationIndex : 0;
        let prevoiuseNode = this.arrDiagramNode[previousIndex].nodeGroup;
        let isInside = DiagramNodeUtils.isRectCenterInSideRectVerticaly(this.diagramParent.parentElement, prevoiuseNode);
        if (!isInside) {
            this.pageIndex -= 1;
            this.gotoPage(this.pageIndex - 1, true);
        }
    } 
    setTimeout(() => {
        if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, delay * 1000);
    return true;
};

SimpleVerticalTimeline.prototype.moveNext = function (isAnimate = false) {
    let slideHeight = this.diagramParent.parentElement.offsetHeight;
    let diagramHeight = this.diagramParent.parentElement.scrollHeight;

    if (slideHeight == diagramHeight) return;
    this.diagramParent.style.transition = isAnimate ? "all " + 1.2 * this.animationFactor + "s " + this.cubicPath : "";

    let translateY = parseFloat(window.getComputedStyle(this.diagramParent).transform.replace("matrix(", "").split(",")[5]);
    translateY = Math.abs(translateY);
    let oldTransateY = translateY;
    let diffHeight = diagramHeight - translateY;
    if (diffHeight - slideHeight >= slideHeight || diffHeight == slideHeight) {
        translateY = translateY + slideHeight;
        this.diagramParent.style.transform = "translateY(" + -translateY + "px)";
        this.navigationIndex += 1;
    } else {
        translateY = translateY + (slideHeight - diffHeight);
        translateY = Math.abs(translateY);
        this.diagramParent.style.transform = "translateY(" + -translateY + "px)";
        if (oldTransateY != translateY) this.navigationIndex += 1;
    }
};

SimpleVerticalTimeline.prototype.movePrevious = function (isAnimate = false) {
    let slideHeight = this.diagramParent.parentElement.offsetHeight;
    let translateY = parseFloat(window.getComputedStyle(this.diagramParent).transform.replace("matrix(", "").split(",")[5]);
    translateY = Math.abs(translateY);

    this.diagramParent.style.transition = isAnimate ? "all " + 1.2 * this.animationFactor + "s " + this.cubicPath : "";
    if (translateY > slideHeight) {
        translateY = translateY - slideHeight;
        this.diagramParent.style.transform = "translateY(" + -translateY + "px)";
        this.navigationIndex -= 1;
    } else if (translateY > 0) {
        translateY = 0;
        this.diagramParent.style.transform = "translateY(" + -translateY + "px)";
        this.navigationIndex -= 1;
    }
};

SimpleVerticalTimeline.prototype.hideAnimation = function (nodeItem, connector, delay, isAnimate = true) {
    this.diagramParent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "hide";
    DiagramAnimateUtil.setAnimationToNodeItems(this, nodeItem, "hide", isAnimate);
};

SimpleVerticalTimeline.prototype.showAnimation = function (nodeItem, connector, delay, index) {
    nodeItem.style.opacity = 1;
    
    this.diagramParent.parentElement.parentElement.parentElement.dataset.showhidegraphic = "show";
    DiagramAnimateUtil.setAnimationToNodeItems(this, nodeItem, "show", this.animationFactor == 0 ? false : true);
};

SimpleVerticalTimeline.prototype.navigation = function (navigation) {
    if (navigation.direction == "next") {
        // this.moveNext();
        if (this.currentPageIndex == this.totalPage - 1) return false;
        this.currentPageIndex += 1;
        this.gotoPage(this.currentPageIndex);
    } else {
        // this.movePrevious();
        if (this.currentPageIndex == 0) return false;
        this.currentPageIndex -= 1;
        this.gotoPage(this.currentPageIndex);
    }
    return true;
};

SimpleVerticalTimeline.prototype.addFocus = function (index) {
    this.totalPage = Math.ceil(this.diagramParent.offsetHeight / this.diagramParent.parentElement.offsetHeight);
    this.currentPageIndex = this.totalPage - 1;

    let primaryTextNode = this.diagramParent.querySelector("[data-id='primaryTextNode'][data-index='" + index + "']");
    this.gotoPage(this.currentPageIndex);
    setTimeout(() => {
        if (primaryTextNode) primaryTextNode.firstElementChild.focus();
    }, 0);
    // primaryTextNode.firstElementChild.focus();
};

SimpleVerticalTimeline.prototype.gotoPage = function (pageIndex, isAnimate = false, isNext = false) {
    let slideHeight = this.diagramParent.parentElement.offsetHeight;
    let diagramHeight = this.diagramParent.offsetHeight;
    let translateY = 0;
    if (diagramHeight > slideHeight) {
        let pagePositionY = slideHeight * pageIndex;
        let calHeight = diagramHeight - slideHeight;

        if (pagePositionY <= calHeight) {
            translateY = pagePositionY;
        } else {
            translateY = calHeight;
        }

        this.diagramParent.style.transition = isAnimate ? "all " + 1.2 * this.animationFactor + "s " + this.cubicPath : "";
        this.diagramParent.style.transform = "translateY(" + -translateY + "px)";
    }
};

SimpleVerticalTimeline.prototype.playAllAtOnce = function () {
    this.itemPerPage = this.getNodePostion()[this.allAtOnceIndex];
    if (!this.itemPerPage) return false;
    this.playNext(0, true);
    this.animateItemCount = 1;
    if (this.itemPerPage > 1) {
        var interval = setInterval(() => {
            this.playNext(0, true);
            this.animateItemCount += 1;
            if (this.animationCompleteCallback && this.animateItemCount == this.itemPerPage) {
                this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
                clearInterval(interval);
            }
        }, 1000 * this.animationFactor);
    } else {
        this.animationCompleteCallback.fn?.(this.animationCompleteCallback.params);
    }

    this.allAtOnceIndex += 1;
    return true;
};

SimpleVerticalTimeline.prototype.playAllAtOnceReverse = function () {
    this.itemPerPage = this.getNodePostion()[this.allAtOnceIndex - 1];
    if (!this.itemPerPage) return false;
    this.playPrevious(0, true);
    this.animateItemCount = 1;
    if (this.itemPerPage > 1) {
        var interval = setInterval(() => {
            this.playPrevious(0, true);
            this.animateItemCount += 1;
            if (this.animationCompleteCallback && this.animateItemCount == this.itemPerPage) {
                this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
                clearInterval(interval);
            }
        }, 1200 * this.animationFactor);
    } else {
        this.animationCompleteCallback.fn?.(this.animationCompleteCallback.params);
    }

    this.allAtOnceIndex -= 1;
    return true;
};

SimpleVerticalTimeline.prototype.updateAnimationPath = function (type) {
    this.cubicPath = "";
    try {
        this.cubicPath = this.moodData.animationData[type].animation.all.effect;
    } catch (error) {
        this.cubicPath = "";
        console.log("Erro accessind timeline animation data HorizontalTimelineDiagram.js");
    }
};

SimpleVerticalTimeline.prototype.getNodePostion = function () {
    switch (this.diagramData.nodes.length) {
        case 1:
            return [1];
        case 2:
            return [2];
        case 3:
            return [2, 1];
        case 4:
            return [2, 2];
        case 5:
            return [2, 2, 1];
        case 6:
            return [2, 2, 2];
        case 7:
            return [2, 3, 2];
        case 8:
            return [2, 2, 2, 2];
        case 9:
            return [2, 2, 3, 2];
        case 10:
            return [2, 3, 3, 2];
        case 11:
            return [2, 3, 2, 2, 2];
        case 12:
            return [2, 3, 3, 2, 2];
    }
};

SimpleVerticalTimeline.prototype.splitArrayWithOrder = function (arrSplitOrder, array) {
    let tempArr = [];
    let nodeArr = [];
    let nodeCount = arrSplitOrder[0];
    for (var i = 0; i < array.length + 1; i++) {
        if (nodeArr.length == nodeCount) {
            tempArr.push(nodeArr);
            nodeArr = [];
            nodeCount = arrSplitOrder[tempArr.length];
        }
        if (array[i] == null) continue;
        nodeArr.push(array[i]);
    }
    return tempArr;
};

SimpleVerticalTimeline.prototype.updateSlideBasednodeHeight = function (arrNodes, height, padding, pos) {
    arrNodes.map(function (node, i) {
        let parentNode = node.getNodeParent().parentElement;
        parentNode.style.setProperty("flex", "unset", "important");
        parentNode.style.minHeight = height + "px";
        parentNode.style.height = height + "px";
        parentNode.style.marginBottom = "";
        parentNode.style.marginTop = "";
        if (pos == "start" && i == arrNodes.length - 1) {
            parentNode.style.marginBottom = padding + "px";
        } else if (pos == "end" && i == 0) {
            parentNode.style.marginTop = padding * 2 + "px";
        } else if (pos == "mid") {
            if (i == 0) parentNode.style.marginTop = padding * 2 + "px";
            if (i == arrNodes.length - 1) parentNode.style.marginBottom = padding + "px";
        }
    });
};

SimpleVerticalTimeline.prototype.setDiagramSpecficOption = function (obj) {
    let startendelementoption = {};
    startendelementoption.start = {};
    startendelementoption.end = {};
    startendelementoption.start.isOn = this.isStartEnable != null ? this.isStartEnable : false;
    startendelementoption.end.isOn = this.isEndEnable != null ? this.isEndEnable : false;
    obj.dpcontent.floatdiagramsettings.startendelementoption = startendelementoption;
    obj.dpcontent.slidecomponent = { bgImage: false, takeAwayText: false };
    obj.isDisableLayoutOption = "true";

    let valueTitleHolder = this.diagramParent.querySelector("[name='valueTitleHolder']");
    if (valueTitleHolder) {
        obj.dpcontent.floatdiagramsettings.year = { isOn: this.diagramData.properties.customproperties.isyearenable, property: "Year", label: "Year" };
        obj.dpcontent.floatdiagramsettings.dateformat = DiagramUtils.getDateFormatInlineData(this);
    }

    delete obj.dpcontent.floatdiagramsettings.graphicvalueformat;
    obj.dpcontent.floatdiagramsettings.dateformat = DiagramUtils.getDateFormatInlineData(this);

    LinearDiagram.prototype.setDiagramSpecficOption.call(this, obj);
};

SimpleVerticalTimeline.prototype.setupNavigation = function (navigationContent) {
    navigationContent.imagelist = [];
    let splitLineHeight = this.diagramParent.clientHeight;
    let pageCount = Math.ceil(splitLineHeight / this.diagramParent.parentElement.clientHeight);
    for (var i = 0; i < pageCount; i++) {
        navigationContent.imagelist.push({});
    }
    navigationContent.imagestackselectedindex = this.currentPageIndex ? this.currentPageIndex : 0;

    return navigationContent;
};

SimpleVerticalTimeline.prototype.slideDimensionChange = function () {
    this.setGroupWidth();
    this.setDiagramHeight();
};

SimpleVerticalTimeline.prototype.setGroupWidth = function () {
    let pattenDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    let firstNode = this.arrDiagramNode[0].parentNode;
    let contentNode = firstNode.querySelector("[data-id='diagramContentNode']");
    if (pattenDiv) {
        let splitGap = parseFloat(this.getCustomProperties().node.splitgap);
        pattenDiv.style.setProperty("--contentWidth", "100px");
        pattenDiv.style.setProperty("--groupWidth", this.diagramParent.clientWidth / 2 + contentNode.offsetWidth + splitGap - 20 + "px");
        try {
            if (this.arrDiagramNode[0].getNodeParent().querySelector("[data-id='diagramContentNode']").querySelector("[data-id='contentnumberparent']")) {
                pattenDiv.style.setProperty("--contentWidth", "170px");
                pattenDiv.style.setProperty("--groupWidth", this.diagramParent.clientWidth / 2 + contentNode.clientWidth + splitGap - 20 + "px");
            }
        } catch (error) {
            console.log("SimpleVerticalTimeline.prototype.setGroupWidth " + error);
        }
    }
};

SimpleVerticalTimeline.prototype.initPresent = function (currentSlideData) {
    this.diagramParent = currentSlideData.querySelector("[id='diagramparent']");

    if (this.diagramParent.parentElement.dataset.animationtype && this.diagramParent.parentElement.dataset.animationtype == "none") return { isTitleAnimation: false, isGraphicAnimation: false };
    let moodanimation = this.diagramParent.parentElement.dataset.moodanimation;
    if (moodanimation && moodanimation == "none") {
        if (this.diagramParent) this.diagramParent.style.opacity = 1;
        return { isTitleAnimation: false, isGraphicAnimation: false };
    }
    if (this.diagramParent) this.diagramParent.style.opacity = 0;

    return { isTitleAnimation: true, isGraphicAnimation: false };
};

SimpleVerticalTimeline.prototype.diagramRenderComplete = function () {
    if (this.completeCallBack && this.completeCallBack.func && this.isRenderComplete) {
        LinearDiagram.prototype.diagramRenderComplete.call(this);
    }
    this.diagramParent.style.opacity = 1;
};

SimpleVerticalTimeline.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsTimelineVertical";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.appendChild(pattenDiv);
    let nodealignment = this.nodeProps.nodealignment;
    this.diagramParent.setAttribute("data-node-alignment", nodealignment);
    let contentSize = (pattenDiv.offsetHeight - (nodeCount - 1) * this.nodeGap) / nodeCount;

    pattenDiv.style.setProperty("--nodeWidth", "auto");
    pattenDiv.style.setProperty("--nodeHeight", contentSize + "px");

    this.createNodeInstances(nodeCount, pattenDiv);
    this.setGroupWidth();
    this.diagramData.properties.customproperties = this.diagramData.properties.customproperties ? this.diagramData.properties.customproperties : this.customproperties();
    this.setDiagramHeight();
    this.currentPageIndex = 0;
    this.isRenderComplete = true;
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
};

SimpleVerticalTimeline.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearVerticalDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    let disableProperties = ["graphicnone", "sequencetext", "numbersize", "iconsize", "imagesize", "logosize"];
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable = [...mainProperties.floateroptionsdisable, ...disableProperties];
    } else mainProperties.floateroptionsdisable = disableProperties;
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

SimpleVerticalTimeline.prototype.setProjection = function (projectionIndex) {
    let index = projectionIndex;
    this.arrDiagramNode.map(
        function (node, i) {
            let nodeParent = node.parentNode.parentElement;
            let isProjectionEnable = parseInt(nodeParent.dataset.index) >= parseInt(index);
            isProjectionEnable ? nodeParent.classList.add("clstimelineprojection") : nodeParent.classList.remove("clstimelineprojection");
        }.bind(this)
    );
};

SimpleVerticalTimeline.prototype.createLine = function (startPoint, endPoint) {
    let line = DiagramNodeUtils.createSVGElement("line");
    DiagramNodeUtils.assignSVGNodeAttributes(line, { x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y, "stroke-width": 5 });
    return line;
};

SimpleVerticalTimeline.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    dict["crossout"] = null;
    if (elTarget.getAttribute("name") && elTarget.getAttribute("name") == "secondaryTextItem") return;
    var tlIndex = elTarget.dataset.index;
    let val = this.diagramParent.dataset.projectionindex && this.diagramParent.dataset.projectionindex == tlIndex;
    dict["projection"] = { visible: true, value: val, floaterproperty: "projection" };
    if (strSelectionType == "primaryText" || strSelectionType == "numberNode") this.getFontSizeDataForInlineFloater(dict, elTarget);
};

SimpleVerticalTimeline.prototype.projection = function (property) {
    var index = property.targetid.replace(/\D/g, "");
    property.value ? this.diagramParent.setAttribute("data-projectionindex", index) : this.diagramParent.removeAttribute("data-projectionindex");
    this.setProjection(property.value ? index : 100);
};

SimpleVerticalTimeline.prototype.updateDateFormat = function (obj) {
    this.arrDiagramNode.forEach((node) => node.updateDateFormat?.(obj));
};

/**
 * Author:    Krishna Prabhu M
 * Created:   20 May 2020
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function PositionableHTimeline(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    LinearHorizontalTimeline.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.observer = null;
}

PositionableHTimeline.prototype = Object.create(LinearHorizontalTimeline.prototype);
PositionableHTimeline.prototype.constructor = PositionableHTimeline;

PositionableHTimeline.prototype.updateEvents = function () {
    LinearDiagram.prototype.updateEvents.call(this);
    let cusProps = this.getCustomProperties();
    let { position, positionoffset } = cusProps.node;

    if (position == "alternate") return;
    let nodeHolder = this.diagramParent?.querySelector("[name='nodesHolder']");
    if (nodeHolder) {
        if (this.observer) {
            this.observer.disconnect();
            this.observer = null;
        }

        this.observer = new ResizeObserver((mutation) => {
            let target = mutation[0].target;
            let offsetTop = position == "bottom" ? target.offsetTop - this.splitLine.parentElement.clientHeight : target.offsetTop;
            offsetTop = position == "top" ? target.offsetTop + target.clientHeight : offsetTop;
            if (this.splitLine) this.splitLine.parentElement.style.top = offsetTop + "px";
        });
        this.observer.observe(nodeHolder);
    }
};

PositionableHTimeline.prototype.getCustomProperties = function () {
    let props = {
        timeline: {
            type: this.diagramParent.dataset.timelinetype || "horizontal",
            style: this.diagramParent.dataset.timelinestyle || "strigntline",
            startelement: this.diagramParent.dataset.startelement && this.diagramParent.dataset.startelement == "false" ? false : true,
            endelement: this.diagramParent.dataset.endelement && this.diagramParent.dataset.endelement == "false" ? false : true,
            isstartenable: this.diagramParent.dataset.isstartenable && this.diagramParent.dataset.isstartenable == "false" ? false : true,
            isendenable: this.diagramParent.dataset.isendenable && this.diagramParent.dataset.isendenable == "false" ? false : true,
            position: this.diagramParent.dataset.timelineposition || "50px",
            element: this.diagramParent.dataset.timelineelement || "diagramContentNode",
        },
        nodeconnector: {
            visible: this.diagramParent.dataset.connectorvisible && this.diagramParent.dataset.connectorvisible == "false" ? false : true,
            connectorline: true,
            connectingobject: this.diagramParent.dataset.connectorconnectingobject || "diagramContentNode",
            position: this.diagramData?.properties?.connectorposition || "middle",
        },
        node: {
            position: this.nodeProps?.nodeposition || "alternate",
            positionoffset: parseInt(this.nodeProps?.nodegap || 20),
            split: false,
            splitalign: "top",
            splitorder: "order1",
            splitgap: Math.min(this.diagramParent.clientHeight * 0.2, 50),
        },
    };
    return props;
};

PositionableHTimeline.prototype.updateNodePosition = function () {
    let cusProps = this.getCustomProperties();
    let { position, positionoffset } = cusProps.node;
    let nodeHolder = this.diagramParent?.querySelector("[name='nodesHolder']");
    nodeHolder.setAttribute("data-nodeposition", position);
    switch (position) {
        case "top":
            nodeHolder.style.marginBottom = this.splitLine.parentElement.clientHeight + "px";
            this.arrDiagramNode.forEach((node) => {
                node.parentNode.setAttribute("data-align-position", "bottom");
                let contentNode = node.parentNode.querySelector("[name='contentNode']");
                let contentHeight = contentNode?.clientHeight || 0;
                let secHeight = this.diagramParent.clientHeight - contentHeight - this.splitLine.parentElement.clientHeight - 50;
                this.diagramParent.style.setProperty("--secContentMaxHeight", secHeight + "px");
            });
            break;
        case "bottom":
            nodeHolder.style.marginTop = this.splitLine.parentElement.clientHeight + "px";
            this.arrDiagramNode.forEach((node) => {
                node.parentNode.setAttribute("data-align-position", "top");
                let contentNode = node.parentNode.querySelector("[name='contentNode']");
                let contentHeight = contentNode?.clientHeight || 0;
                let secHeight = this.diagramParent.clientHeight - contentHeight - this.splitLine.parentElement.clientHeight - 50;
                this.diagramParent.style.setProperty("--secContentMaxHeight", secHeight + "px");
            });
            break;
        case "alternate":
            this.nodeAlignAlternate();
            break;
        case "middle":
            break;
    }

    this.updateTimelinePosition(nodeHolder);
};

PositionableHTimeline.prototype.nodeAlignAlternate = function () {
    let cusProps = this.getCustomProperties();
    let { positionoffset } = cusProps.node;

    let topX = this.splitLine.parentElement.offsetTop;
    let bottomX = this.splitLine.parentElement.offsetTop + this.splitLine.parentElement.clientHeight;

    this.arrDiagramNode.forEach((node, index) => {
        node.parentNode.style.maxHeight = `calc(${topX}px + var(--nodeOffset, 0px))`;
        node.nodeGroup.style.maxHeight = `calc(${topX}px + var(--nodeOffset, 0px))`;

        let connector = this.arrConnectorPoints[i];
        if (index % 2 == 0) {
            node.parentNode.style.bottom = this.diagramParent.clientHeight - topX + positionoffset + "px";
            node.parentNode.setAttribute("data-align-position", "bottom");
            if (connector) connector.dataset.alignPosition = "bottom";
        } else {
            node.parentNode.style.top = bottomX + positionoffset + "px";
            node.parentNode.setAttribute("data-align-position", "top");
            if (connector) connector.dataset.alignPosition = "top";
        }
    });
};

PositionableHTimeline.prototype.clear = function () {
    this.eventManagerXY.clear();
    if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
    }
};

PositionableHTimeline.prototype.updateConnectorLine = function () {};

PositionableHTimeline.prototype.updateTimelinePosition = function (target) {
    if (!target) target = this.diagramParent?.querySelector("[name='nodesHolder']");
    if (!target) return;
    let cusProps = this.getCustomProperties();
    let { position } = cusProps.node;

    this.splitLine.parentElement.style.top = "unset";
    if (position == "alternate") return;
    let offsetTop = position == "bottom" ? target.offsetTop - this.splitLine.parentElement.clientHeight : target.offsetTop;
    offsetTop = position == "top" ? target.offsetTop + target.clientHeight : offsetTop;
    if (this.splitLine) this.splitLine.parentElement.style.top = `calc(${offsetTop}px + var(--timelineOffset, 0px))`;
};

PositionableHTimeline.prototype.slideDimensionChange = function () {
    this.setDiagramWidth();
    this.setGroupWidth();
    let cusProps = this.getCustomProperties();
    let { position } = cusProps.node;
    if (position == "alternate") return;
    this.splitLine.parentElement.style.top = "unset";
    let nodeHolder = this.diagramParent?.querySelector("[name='nodesHolder']");
    let target = nodeHolder;
    let offsetTop = position == "bottom" ? target.offsetTop - this.splitLine.parentElement.clientHeight : target.offsetTop;
    offsetTop = position == "top" ? target.offsetTop + target.clientHeight : offsetTop;
    if (this.splitLine) this.splitLine.parentElement.style.top = offsetTop + "px";
};

function InlineHTimeline(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    PositionableHTimeline.call(this, diagramParent, diagramData, nodeProps, moodData);
}

InlineHTimeline.prototype = Object.create(PositionableHTimeline.prototype);
InlineHTimeline.prototype.constructor = InlineHTimeline;

InlineHTimeline.prototype.updateEvents = function () {
    LinearDiagram.prototype.updateEvents.call(this);
    let nodeHolder = this.diagramParent?.querySelector("[name='nodesHolder']");
    if (nodeHolder) {
        if (this.observer) {
            this.observer.disconnect();
            this.observer = null;
        }

        this.observer = new ResizeObserver((mutation) => {
            let target = mutation[0].target;
            this.updateTimelinePosition(target);
        });
        this.observer.observe(nodeHolder);
    }
};

InlineHTimeline.prototype.getCustomProperties = function () {
    let props = {
        timeline: {
            type: this.diagramParent.dataset.timelinetype || "horizontal",
            style: this.diagramParent.dataset.timelinestyle || "strigntline",
            startelement: this.diagramParent.dataset.startelement && this.diagramParent.dataset.startelement == "false" ? false : true,
            endelement: this.diagramParent.dataset.endelement && this.diagramParent.dataset.endelement == "false" ? false : true,
            isstartenable: this.diagramParent.dataset.isstartenable && this.diagramParent.dataset.isstartenable == "false" ? false : true,
            isendenable: this.diagramParent.dataset.isendenable && this.diagramParent.dataset.isendenable == "false" ? false : true,
            position: this.diagramParent.dataset.timelineposition || "50px",
            element: this.diagramParent.dataset.timelineelement || "diagramContentNode",
        },
        nodeconnector: {
            visible: this.diagramParent.dataset.connectorvisible && this.diagramParent.dataset.connectorvisible == "false" ? false : true,
            connectorline: true,
            connectingobject: this.diagramParent.dataset.connectorconnectingobject || "diagramContentNode",
            position: this.diagramData?.properties?.connectorposition || "middle",
        },
        node: {
            position: this.nodeProps?.nodeposition || "alternate",
            positionoffset: parseInt(this.nodeProps?.nodegap || 0),
            split: false,
            splitalign: "top",
            splitorder: "order1",
            splitgap: Math.min(this.diagramParent.clientHeight * 0.2, 50),
        },
    };
    return props;
};

InlineHTimeline.prototype.updateNodePosition = function () {
    let contentNode = this.diagramParent.querySelector("[name='contentNode']");
    let cusProps = this.getCustomProperties();
    let { position, positionoffset } = cusProps.node;
    let nodeHolder = this.diagramParent?.querySelector("[name='nodesHolder']");
    nodeHolder.setAttribute("data-nodeposition", position);
    switch (position) {
        case "top":
            this.arrDiagramNode.forEach((node) => {
                node.parentNode.setAttribute("data-align-position", "bottom");
                let contentHeight = contentNode?.clientHeight || 0;
                let secHeight = this.diagramParent.clientHeight - contentHeight - this.splitLine.parentElement.clientHeight - 50;
                this.diagramParent.style.setProperty("--secContentMaxHeight", secHeight + "px");
            });
            break;
        case "bottom":
            this.arrDiagramNode.forEach((node) => {
                node.parentNode.setAttribute("data-align-position", "top");
                let contentHeight = contentNode?.clientHeight || 0;
                let secHeight = this.diagramParent.clientHeight - contentHeight - this.splitLine.parentElement.clientHeight - 50;
                this.diagramParent.style.setProperty("--secContentMaxHeight", secHeight + "px");
            });
            break;
        case "alternate":
            this.nodeAlignAlternate(contentNode);
            break;
        case "middle":
            break;
    }

    this.updateTimelinePosition(nodeHolder);
};

InlineHTimeline.prototype.nodeAlignAlternate = function (contentNode) {
    let contentHeight = contentNode?.clientHeight || 0;
    let maxheight = this.diagramParent.clientHeight / 2;
    this.arrDiagramNode.forEach((node, index) => {
        node.parentNode.style.maxHeight = maxheight + "px";
        node.nodeGroup.style.maxHeight = maxheight + "px";
        let connector = this.arrConnectorPoints[i];
        if (index % 2 == 0) {
            node.parentNode.style.bottom = this.diagramParent.clientHeight / 2 - contentHeight / 2 + "px";
            node.parentNode.setAttribute("data-align-position", "top");
            if (connector) connector.dataset.alignPosition = "top";
        } else {
            node.parentNode.style.top = this.diagramParent.clientHeight / 2 - contentHeight / 2 + "px";
            node.parentNode.setAttribute("data-align-position", "bottom");
            if (connector) connector.dataset.alignPosition = "bottom";
        }
    });
};

InlineHTimeline.prototype.updateTimelinePosition = function (target) {
    let cusProps = this.getCustomProperties();
    let { positionoffset } = cusProps.node;
    let contentNode = target.querySelector("[name='contentNode']");
    let contentRect = DiagramNodeUtils.getElementRectByOffserParent(this.diagramParent, contentNode);
    let offsetTop = contentRect.top + contentRect.height / 2 - this.splitLine.parentElement.clientHeight / 2 + positionoffset;
    if (this.splitLine) this.splitLine.parentElement.style.top = offsetTop + "px";
};

InlineHTimeline.prototype.slideDimensionChange = function () {
    this.setDiagramWidth();
    this.setGroupWidth();
    let cusProps = this.getCustomProperties();
    let { position } = cusProps.node;
    if (position == "alternate") return;
    this.splitLine.parentElement.style.top = "unset";
    let nodeHolder = this.diagramParent?.querySelector("[name='nodesHolder']");
    let target = nodeHolder;
    this.updateTimelinePosition(target);
};

function BarTimeline(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    PositionableHTimeline.call(this, diagramParent, diagramData, nodeProps, moodData);
}

BarTimeline.prototype = Object.create(PositionableHTimeline.prototype);
BarTimeline.prototype.constructor = BarTimeline;

BarTimeline.prototype.updateEvents = function () {
    LinearDiagram.prototype.updateEvents.call(this);
    let nodeHolder = this.diagramParent?.querySelector("[name='nodesHolder']");
    if (nodeHolder) {
        if (this.observer) {
            this.observer.disconnect();
            this.observer = null;
        }

        this.observer = new ResizeObserver((mutation) => {
            let target = mutation[0].target;
            this.updateTimelinePosition(target);
        });
        this.observer.observe(nodeHolder);
    }
};

BarTimeline.prototype.drawTimeline = function () {
    let timeline = this.diagramParent.parentElement.querySelector("[data-id='timeline']");
    timeline?.remove();
    LinearHorizontalTimeline.prototype.drawTimeline.call(this);
    timeline = this.diagramParent.parentElement.querySelector("[data-id='timeline']");
    timeline.className = "barconnectortimeline" + " " + (this.nodeProps?.timelineclass || "");
};

BarTimeline.prototype.getCustomProperties = function () {
    let props = {
        timeline: {
            type: this.diagramParent.dataset.timelinetype || "horizontal",
            style: this.diagramParent.dataset.timelinestyle || "strigntline",
            startelement: this.diagramParent.dataset.startelement && this.diagramParent.dataset.startelement == "false" ? false : true,
            endelement: this.diagramParent.dataset.endelement && this.diagramParent.dataset.endelement == "false" ? false : true,
            isstartenable: this.diagramParent.dataset.isstartenable && this.diagramParent.dataset.isstartenable == "false" ? false : true,
            isendenable: this.diagramParent.dataset.isendenable && this.diagramParent.dataset.isendenable == "false" ? false : true,
            position: this.diagramParent.dataset.timelineposition || "50px",
            element: this.diagramParent.dataset.timelineelement || "diagramContentNode",
        },
        nodeconnector: {
            visible: this.diagramParent.dataset.connectorvisible && this.diagramParent.dataset.connectorvisible == "false" ? false : true,
            connectorline: true,
            connectingobject: this.diagramParent.dataset.connectorconnectingobject || "diagramContentNode",
            position: this.diagramData?.properties?.connectorposition || "middle",
        },
        node: {
            position: this.nodeProps?.nodeposition || "alternate",
            positionoffset: parseInt(this.nodeProps?.nodegap || 20),
            split: false,
            splitalign: "top",
            splitorder: "order1",
            splitgap: Math.min(this.diagramParent.clientHeight * 0.2, 50),
        },
    };
    return props;
};

BarTimeline.prototype.updateNodePosition = function () {
    let cusProps = this.getCustomProperties();
    let { position, positionoffset } = cusProps.node;
    let nodeHolder = this.diagramParent?.querySelector("[name='nodesHolder']");
    nodeHolder.setAttribute("data-nodeposition", position);
    switch (position) {
        case "top":
            this.arrDiagramNode.forEach((node) => {
                node.parentNode.setAttribute("data-align-position", "bottom");
                let contentNode = node.parentNode.querySelector("[name='contentNode']");
                let contentHeight = contentNode?.clientHeight || 0;
                let secHeight = this.diagramParent.clientHeight - contentHeight - this.splitLine.parentElement.clientHeight - 50;
                this.diagramParent.style.setProperty("--secContentMaxHeight", secHeight + "px");
            });
            break;
        case "bottom":
            this.arrDiagramNode.forEach((node) => {
                node.parentNode.setAttribute("data-align-position", "top");
                let contentNode = node.parentNode.querySelector("[name='contentNode']");
                let contentHeight = contentNode?.clientHeight || 0;
                let secHeight = this.diagramParent.clientHeight - contentHeight - this.splitLine.parentElement.clientHeight - 50;
                this.diagramParent.style.setProperty("--secContentMaxHeight", secHeight + "px");
            });
            break;
        case "alternate":
            this.nodeAlignAlternate();
            break;
        case "middle":
            break;
    }

    this.updateTimelinePosition(nodeHolder);
};

BarTimeline.prototype.updateConnectorPoints = function () {
    if (this.splitLine == null || this.getCustomProperties().nodeconnector.visible == false) return;
    let i = 0;
    while (this.arrConnectorPoints.length < this.arrDiagramNode.length) {
        let connectorPoint = document.createElement("div");
        connectorPoint.className = "connectorpoint clsNodeAccentbg clsMultiColorParent";
        connectorPoint.id = "connectorpoint";
        this.splitLine.appendChild(connectorPoint);
        DiagramUtils.setCustomItemColor(connectorPoint, this.arrTintArray, i, i + 1);

        if (this.getCustomProperties().nodeconnector.connectorline == true) {
            let connectorLine = document.createElement("div");
            connectorLine.className = "connectorline clsNodeAccentbg clsMultiColorParent";
            connectorLine.id = "connectorline";
            connectorPoint.appendChild(connectorLine);
            DiagramUtils.setCustomItemColor(connectorLine, this.arrTintArray, i, i + 1);
            connectorLine.setAttribute("data-height", connectorPoint.clientHeight + "px");

            let svg = this.createSvgElement("svg", { style: "width:100%; height:100%; position:absolute; opacity:0" });
            connectorLine.appendChild(svg);
            let path = this.createSvgElement("path", {});
            path.setAttribute("stroke", "rgba(var(--tertiary-color-rgb), 1)");
            svg.appendChild(path);

            let connectorDot = document.createElement("div");
            connectorDot.className = "connectorDot clsBorderAccent clsNodeBackgroundbg clsMultiColorParent";
            connectorDot.id = "connectorDot";
            connectorLine.appendChild(connectorDot);
            DiagramUtils.setCustomItemColor(connectorDot, this.arrTintArray, i, i + 1);
            i % 2 == 0 ? (connectorDot.style.top = "0px") : "unset";
            i % 2 != 0 ? (connectorDot.style.bottom = "0px") : "unset";
        }
        i += 1;
        this.arrConnectorPoints.push(connectorPoint);
    }

    while (this.arrConnectorPoints.length > this.arrDiagramNode.length) {
        let point = this.arrConnectorPoints[this.arrConnectorPoints.length - 1];
        point.parentElement.removeChild(point);
        this.arrConnectorPoints.pop();
    }

    let arrPoints = this.splitLine.querySelectorAll("[id='connectorpoint']");
    this.arrDiagramNode.map(
        function (node, i) {
            let point = arrPoints[i];
            let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
            let nodeRect = DiagramNodeUtils.getOffsetRectByParent(nodeHolder, node.nodeGroup);
            let centerX = nodeRect.x + nodeRect.width / 2;
            centerX = centerX - this.padding - point.clientWidth / 2 - 7;
            if (point) point.style.left = centerX + "px";
            let margin = 0;

            point.style.position = "relative";
            if (node.parentNode.parentElement.style.marginLeft != "") {
                margin = parseInt(node.parentNode.parentElement.style.marginLeft);
                point.style.width = node.parentNode.parentElement.clientWidth + margin + "px";
                point.firstElementChild.style.left = point.clientWidth / 2 - point.firstElementChild.clientWidth / 2 + margin / 2 + "px";
            } else if (node.parentNode.parentElement.style.marginRight != "") {
                margin = parseInt(node.parentNode.parentElement.style.marginRight);
                point.style.width = node.parentNode.parentElement.clientWidth + margin + "px";
                point.firstElementChild.style.left = point.clientWidth / 2 - point.firstElementChild.clientWidth / 2 - margin / 2 + "px";
            } else {
                point.style.width = node.parentNode.parentElement.clientWidth + margin + "px";
            }
        }.bind(this)
    );
};

BarTimeline.prototype.hideAnimation = function (nodeItem, connector, delay, isAnimate = true) {
    let targetId = this.getCustomProperties().timeline.element;

    let durationFactor = isAnimate ? "" : "no";
    let delayFactor = isAnimate ? 1 : 0;

    let targetObj = nodeItem.querySelector("[data-id*='" + targetId + "']");
    if (targetObj) {
        targetObj.style.transition = "";
        targetObj.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        // delay = delay + 0.2;
        targetObj.style.transform = "scale(0)";
    }

    let positionY = nodeItem.dataset.alignPosition && nodeItem.dataset.alignPosition == "top" ? "40px" : "-40px";

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    if (seconday) {
        seconday.style.transition = "";
        seconday.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        seconday.style.transform = "translateY(" + positionY + ")";
        seconday.style.setProperty("opacity", 0, "important");
    }

    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    if (primary) {
        primary.style.transition = "";
        primary.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        primary.style.transform = "translateY(" + positionY + ")";
        primary.style.setProperty("opacity", 0, "important");
    }

    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "";
        number.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        // delay = delay + 0.2;
        number.style.transform = "translateY(" + positionY + ")";
        number.style.setProperty("opacity", 0, "important");
    }

    let dot = connector.querySelector("#connectorDot");
    if (dot) {
        delay = delay + 0.2;
        dot.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        dot.style.transform = "scale(0)";
    }

    if (connector) {
        connector.firstElementChild.style.transition = "";
        connector.firstElementChild.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        connector.firstElementChild.style.height = "0px";

        connector.style.transition = "";
        connector.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        connector.style.transform = "scale(0, 1)";
    }

    return delay;
};

BarTimeline.prototype.showAnimation = function (nodeItem, connector, delay, index) {
    if (connector) {
        connector.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.4;
        connector.style.transform = "scale(1,1)";
        connector.firstElementChild.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        connector.firstElementChild.style.height = connector.firstElementChild.dataset.height;
    }

    let dot = connector?.querySelector("#connectorDot");
    if (dot) {
        dot.style.transition = "all 0.5" + this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        dot.style.transform = "scale(1)";
    }

    let targetId = this.getCustomProperties().timeline.element;
    let targetObj = nodeItem.querySelector("[data-id*='" + targetId + "']");
    if (targetObj) {
        targetObj.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        // delay = delay + 0.2;
        targetObj.style.transform = "scale(1)";
    }
    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        number.style.transform = "translateY(0px)";
        number.style.setProperty("opacity", 1, "important");
    }

    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    if (primary) {
        primary.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        primary.style.transform = "translateY(0px)";
        primary.style.setProperty("opacity", 1, "important");
    }

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    if (seconday) {
        seconday.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        seconday.style.transform = "translateY(0px)";
        seconday.style.setProperty("opacity", 1, "important");
    }

    return delay;
};

function BarArrowTimeline(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    BarTimeline.call(this, diagramParent, diagramData, nodeProps, moodData);
}

BarArrowTimeline.prototype = Object.create(BarTimeline.prototype);
BarArrowTimeline.prototype.constructor = BarArrowTimeline;

BarArrowTimeline.prototype.drawTimeline = function () {
    let timeline = this.diagramParent.parentElement.querySelector("[data-id='timeline']");
    timeline?.remove();
    LinearHorizontalTimeline.prototype.drawTimeline.call(this);
    timeline = this.diagramParent.parentElement.querySelector("[data-id='timeline']");
    timeline.className = "bararrowtimeline" + " " + (this.nodeProps?.timelineclass || "");
};

BarArrowTimeline.prototype.updateConnectorPoints = function () {
    if (this.splitLine == null || this.getCustomProperties().nodeconnector.visible == false) return;
    let i = 0;
    while (this.arrConnectorPoints.length < this.arrDiagramNode.length) {
        let connectorPoint = document.createElement("div");
        connectorPoint.className = "connectorpoint clsNodeAccentbg clsMultiColorParent";
        connectorPoint.id = "connectorpoint";
        this.splitLine.appendChild(connectorPoint);
        DiagramUtils.setCustomItemColor(connectorPoint, this.arrTintArray, i, i + 1);

        if (this.getCustomProperties().nodeconnector.connectorline == true) {
            let connectorLine = document.createElement("div");
            connectorLine.className = "connectorline clsNodeAccentbg clsMultiColorParent";
            connectorLine.id = "connectorline";
            connectorPoint.appendChild(connectorLine);
            DiagramUtils.setCustomItemColor(connectorLine, this.arrTintArray, i, i + 1);
        }
        i += 1;
        this.arrConnectorPoints.push(connectorPoint);
    }

    while (this.arrConnectorPoints.length > this.arrDiagramNode.length) {
        let point = this.arrConnectorPoints[this.arrConnectorPoints.length - 1];
        point.parentElement.removeChild(point);
        this.arrConnectorPoints.pop();
    }

    let arrPoints = this.splitLine.querySelectorAll("[id='connectorpoint']");
    this.arrDiagramNode.map(
        function (node, i) {
            let point = arrPoints[i];
            let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
            let nodeRect = DiagramNodeUtils.getOffsetRectByParent(nodeHolder, node.nodeGroup);
            let centerX = nodeRect.x + nodeRect.width / 2;
            centerX = centerX - this.padding - point.clientWidth / 2 - 7;
            if (point) point.style.left = centerX + "px";
            let margin = 0;

            point.style.position = "relative";
            if (node.parentNode.parentElement.style.marginLeft != "") {
                margin = parseInt(node.parentNode.parentElement.style.marginLeft);
                point.style.width = node.parentNode.parentElement.clientWidth + margin + "px";
                point.firstElementChild.style.left = point.clientWidth / 2 - point.firstElementChild.clientWidth / 2 + margin / 2 + "px";
            } else if (node.parentNode.parentElement.style.marginRight != "") {
                margin = parseInt(node.parentNode.parentElement.style.marginRight);
                point.style.width = node.parentNode.parentElement.clientWidth + margin + "px";
                point.firstElementChild.style.left = point.clientWidth / 2 - point.firstElementChild.clientWidth / 2 - margin / 2 + "px";
            } else {
                point.style.width = node.parentNode.parentElement.clientWidth + margin + "px";
            }
        }.bind(this)
    );
};

BarArrowTimeline.prototype.getCustomProperties = function () {
    let props = {
        timeline: {
            type: this.diagramParent.dataset.timelinetype || "horizontal",
            style: this.diagramParent.dataset.timelinestyle || "strigntline",
            startelement: this.diagramParent.dataset.startelement && this.diagramParent.dataset.startelement == "false" ? false : true,
            endelement: this.diagramParent.dataset.endelement && this.diagramParent.dataset.endelement == "false" ? false : true,
            isstartenable: this.diagramParent.dataset.isstartenable && this.diagramParent.dataset.isstartenable == "false" ? false : true,
            isendenable: this.diagramParent.dataset.isendenable && this.diagramParent.dataset.isendenable == "false" ? false : true,
            position: this.diagramParent.dataset.timelineposition || "50px",
            element: this.diagramParent.dataset.timelineelement || "diagramContentNode",
        },
        nodeconnector: {
            visible: this.diagramParent.dataset.connectorvisible && this.diagramParent.dataset.connectorvisible == "false" ? false : true,
            connectorline: true,
            connectingobject: this.diagramParent.dataset.connectorconnectingobject || "diagramContentNode",
            position: this.diagramData?.properties?.connectorposition || "middle",
        },
        node: {
            position: this.nodeProps?.nodeposition || "alternate",
            positionoffset: parseInt(this.nodeProps?.nodegap || 20),
            split: false,
            splitalign: "top",
            splitorder: "order1",
            splitgap: Math.min(this.diagramParent.clientHeight * 0.2, 50),
        },
    };
    return props;
};

BarArrowTimeline.prototype.hideAnimation = function (nodeItem, connector, delay, isAnimate = true) {
    let targetId = this.getCustomProperties().timeline.element;

    let durationFactor = isAnimate ? "" : "no";
    let delayFactor = isAnimate ? 1 : 0;

    let targetObj = nodeItem.querySelector("[data-id*='" + targetId + "']");
    if (targetObj) {
        targetObj.style.transition = "";
        targetObj.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        // delay = delay + 0.2;
        targetObj.style.transform = "scale(0)";
    }

    let positionY = nodeItem.dataset.alignPosition && nodeItem.dataset.alignPosition == "top" ? "40px" : "-40px";

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    if (seconday) {
        seconday.style.transition = "";
        seconday.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        seconday.style.transform = "translateY(" + positionY + ")";
        seconday.style.setProperty("opacity", 0, "important");
    }

    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    if (primary) {
        primary.style.transition = "";
        primary.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        primary.style.transform = "translateY(" + positionY + ")";
        primary.style.setProperty("opacity", 0, "important");
    }

    if (connector) {
        connector.firstElementChild.style.transition = "";
        connector.firstElementChild.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        connector.firstElementChild.style.transform = "scale(0) rotate(45deg)";
    }

    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "";
        number.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        // delay = delay + 0.2;
        number.style.transform = "translateY(" + positionY + ")";
        number.style.setProperty("opacity", 0, "important");
    }

    if (connector) {
        connector.style.transition = "";
        connector.style.transition = "all 0.5" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        connector.style.transform = "scale(0, 1)";
    }

    return delay;
};

BarArrowTimeline.prototype.showAnimation = function (nodeItem, connector, delay, index) {
    if (connector) {
        connector.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.4;
        connector.style.transform = "scale(1,1)";
    }

    let targetId = this.getCustomProperties().timeline.element;
    let targetObj = nodeItem.querySelector("[data-id*='" + targetId + "']");
    if (targetObj) {
        targetObj.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        // delay = delay + 0.2;
        targetObj.style.transform = "scale(1)";
    }
    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        number.style.transform = "translateY(0px)";
        number.style.setProperty("opacity", 1, "important");
    }

    if (connector) {
        connector.firstElementChild.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        connector.firstElementChild.style.transform = "scale(1) rotate(45deg)";
    }

    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    if (primary) {
        primary.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        primary.style.transform = "translateY(0px)";
        primary.style.setProperty("opacity", 1, "important");
    }
    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    if (seconday) {
        seconday.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.2;
        seconday.style.transform = "translateY(0px)";
        seconday.style.setProperty("opacity", 1, "important");
    }

    return delay;
};

/**
 * Author:    Krishna Prabhu
 * Created:   Tus 26 May 2020
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function LinearVerticalTimeline(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearVerticalDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "verticaltimeline";

    this.pageIndex = 1;
    this.totalPage = 1;
    this.itemPerPage = 4;
    this.splitLine = null;
    this.endElement = null;
    this.animationIndex = 0;
    this.allAtOnceIndex = 0;
    this.startElement = true;
    this.animateItemCount = 0;
    this.currentPageIndex = 0;
    this.animationLine = null;
    this.isForwardAnimation = 0;
    this.isReversAnimation = 0;
    this.isStartEnable = true;
    this.isEndEnable = true;
    this.arrConnectorPoints = null;
    this.isRenderComplete = false;

    this.padding = 0;
    this.cubicPath = "";
    this.animationFactor = 1;

    this.diagramParent.setAttribute("data-toggleassets", "true");
    this.diagramParent.setAttribute("data-togglecategory", "ver-timeline-tx-sty-a-1-sec");
    this.diagramParent.setAttribute("data-currencyformat", "disable");
}

LinearVerticalTimeline.prototype = Object.create(SimpleLinearVerticalDiagram.prototype);

LinearVerticalTimeline.prototype.constructor = LinearVerticalTimeline;

LinearVerticalTimeline.prototype.initDiagramCreation = function () {
    this.diagramParent.parentElement.style.overflow = "hidden";
    this.diagramParent.parentElement.setAttribute("data-ismultislide", "true");

    this.diagramParent.innerHTML = "";
    this.diagramParent.style.setProperty("--contentResizeMH", "unset");
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.createPatternBackGround();
    this.diagramRenderComplete();
};

LinearVerticalTimeline.prototype.updateElements = function (defaultproperties) {
    SimpleLinearVerticalDiagram.prototype.updateElements.call(this, defaultproperties);

    let timelineId = "timeline-" + this.diagramParent.getAttribute("parent-id");
    let timelineElement = this.diagramParent.parentElement.querySelector("[id='" + timelineId + "']");

    this.pageIndex = 1;
    this.totalPage = 1;
    this.animationIndex = 0;
    this.allAtOnceIndex = 0;
    this.navigationIndex = 0;
    this.currentPageIndex = 0;
    this.isForwardAnimation = 0;
    this.isReversAnimation = 0;

    if (timelineElement) {
        this.splitLine = timelineElement.firstElementChild;
        this.arrConnectorPoints = Array.from(this.splitLine.querySelectorAll("[id='connectorpoint']"));

        this.animationLine = timelineElement.querySelector("[id='animationLine']");
        this.startElement = timelineElement.querySelector("[id='timelinestartelement']");
        this.endElement = timelineElement.querySelector("[id='timelineendelement']");

        this.totalPage = Math.ceil(this.splitLine.parentElement.offsetHeight / this.diagramParent.parentElement.offsetHeight);
        this.diagramParent.style.transform = "translateY(0px)";
        this.splitLine.parentElement.style.transform = "translateY(0px)";

        this.isStartEnable = this.diagramParent.dataset.isstartenable && this.diagramParent.dataset.isstartenable == "false" ? false : true;
        this.isEndEnable = this.diagramParent.dataset.isendenable && this.diagramParent.dataset.isendenable == "false" ? false : true;

        this.updateTimelineElements();
        this.setDiagramHeight();
        this.currentPageIndex = 0;
    }
};

LinearVerticalTimeline.prototype.recreateElementData = function () {
    SimpleLinearVerticalDiagram.prototype.recreateElementData.call(this);

    let timelineId = "timeline-" + this.diagramParent.getAttribute("parent-id");
    let timelineElement = this.diagramParent.parentElement.querySelector("[id='" + timelineId + "']");

    if (timelineElement) {
        this.splitLine = timelineElement.firstElementChild;
        this.arrConnectorPoints = Array.from(this.splitLine.querySelectorAll("[id='connectorpoint']"));

        this.animationLine = timelineElement.querySelector("[id='animationLine']");
        this.startElement = timelineElement.querySelector("[id='timelinestartelement']");
        this.endElement = timelineElement.querySelector("[id='timelineendelement']");

        this.totalPage = Math.ceil(this.splitLine.parentElement.offsetHeight / this.diagramParent.parentElement.offsetHeight);
        this.diagramParent.style.transform = "translateY(0px)";
        this.splitLine.parentElement.style.transform = "translateY(0px)";
    }
};

LinearVerticalTimeline.prototype.addNode = function (nodeData, index, isFromUndo = false) {
    SimpleLinearVerticalDiagram.prototype.addNode.call(this, nodeData, index, isFromUndo);
    this.drawTimeline();
    this.setDiagramHeight();
    this.currentPageIndex = this.totalPage - 1;
    this.gotoPage(this.currentPageIndex);
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
};

LinearVerticalTimeline.prototype.swapNodes = function (objData, swapNodeIndex) {
    SimpleLinearDiagram.prototype.swapNodes.call(this, objData, swapNodeIndex);
    let pIndex = this.currentPageIndex;
    this.drawTimeline();
    this.setDiagramHeight();
    this.currentPageIndex = pIndex;
    this.gotoPage(this.currentPageIndex);
};

LinearVerticalTimeline.prototype.setNodelWidth = function (arrOrderedNodes) {
    let firstSlideOffsetHeight = this.isStartEnable ? this.startElement.clientHeight : 0;
    let lastSlideOffsetHeight = this.isEndEnable ? this.endElement.clientHeight : 0;
    firstSlideOffsetHeight = arrOrderedNodes.length == 1 ? firstSlideOffsetHeight + lastSlideOffsetHeight : firstSlideOffsetHeight;

    let parentStyle = window.getComputedStyle(this.diagramParent);
    let marginTop = parseFloat(parentStyle.marginTop);
    let marginBottom = parseFloat(parentStyle.marginBottom);

    let slideEndPadding = arrOrderedNodes.length > 1 ? marginTop : 0;
    let padding = arrOrderedNodes.length > 1 ? marginTop : marginTop + marginBottom;
    let firstSlideHeight = this.diagramParent.parentElement.clientHeight - padding - firstSlideOffsetHeight - slideEndPadding;
    let centerSlideHeight = this.diagramParent.parentElement.clientHeight - slideEndPadding * 2;
    let lastSlideHeight = this.diagramParent.parentElement.clientHeight - padding - lastSlideOffsetHeight - slideEndPadding;
    let totalHeight = 0;
    let diffHeight = 0;
    let firstNodeHeight = 0;

    for (var i = 0; i < arrOrderedNodes.length; i++) {
        if (i == 0) {
            //first slide
            let nodeHeight = firstSlideHeight / arrOrderedNodes[i].length;
            firstNodeHeight = nodeHeight;
            this.updateSlideBasednodeHeight(arrOrderedNodes[i], nodeHeight, slideEndPadding, "start");
            totalHeight = totalHeight + firstSlideHeight + slideEndPadding;
        } else if (i == arrOrderedNodes.length - 1) {
            //last slide
            let nodeHeight = lastSlideHeight / arrOrderedNodes[i].length;
            let diffHeightCount = arrOrderedNodes[i].length - arrOrderedNodes[i].length;
            diffHeight = nodeHeight * diffHeightCount;
            this.updateSlideBasednodeHeight(arrOrderedNodes[i], nodeHeight, slideEndPadding, "end");
            totalHeight = totalHeight + lastSlideHeight + slideEndPadding;
        } else {
            //remaining slide
            let nodeHeight = centerSlideHeight / arrOrderedNodes[i].length;
            this.updateSlideBasednodeHeight(arrOrderedNodes[i], nodeHeight, slideEndPadding, "mid");
            totalHeight = totalHeight + centerSlideHeight + slideEndPadding * 2;
        }
    }

    let timelineHeight = totalHeight - diffHeight;

    return { parentHeight: totalHeight, timelineHeight: timelineHeight, nodeHeight: firstNodeHeight };
};

LinearVerticalTimeline.prototype.setDiagramHeight = function () {
    this.startElementPadding = this.isStartEnable ? 0 : 50;
    this.endElementPadding = this.isEndEnable ? 0 : 50;
    this.startElement.style.display = this.isStartEnable ? "flex" : "none";
    this.endElement.style.display = this.isEndEnable ? "flex" : "none";

    this.diagramParent.setAttribute("data-isstartenable", this.isStartEnable);
    this.diagramParent.setAttribute("data-isendenable", this.isEndEnable);

    this.diagramParent.style.setProperty("--commonnodeitemheight", "calc(100% - " + 20 + "px)", "important");
    this.diagramParent.style.setProperty("--timelinecintentheight", this.diagramParent.clientHeight * 0.166 + "px", "important");

    let nodeOrder = this.getNodePostion();
    let arr = this.splitArrayWithOrder(nodeOrder, this.arrDiagramNode);
    let widthObj = this.setNodelWidth(arr);

    this.diagramParent.style.minHeight = widthObj.parentHeight + "px";
    this.diagramParent.style.height = widthObj.parentHeight + "px";
    this.splitLine.parentElement.style.height = widthObj.parentHeight + this.startElement.clientHeight + this.endElement.clientHeight + this.startElementPadding + this.endElementPadding + "px";

    this.totalPage = Math.ceil(this.splitLine.parentElement.offsetHeight / this.diagramParent.parentElement.offsetHeight);

    this.updateTimelineElements();

    //below block of code is to set the animation line width dependes on the start and end element
    {
        let arrPoints = Array.from(this.splitLine.querySelectorAll("[id='connectorpoint']"));
        let startPoint = arrPoints.at(0);
        let endPoint = arrPoints.at(-1);
        let startRect = DiagramNodeUtils.getOffsetRectByParent(this.splitLine, startPoint);
        let endRect = DiagramNodeUtils.getOffsetRectByParent(this.splitLine, endPoint);

        this.animationLine.style.height = "100%";

        if (this.isStartEnable) {
            this.animationLine.style.top = "0px";
        } else {
            this.animationLine.style.top = startRect.y + startRect.height / 2 + "px";
            this.animationLine.style.height = "calc(100% - " + startRect.y + "px)";
        }

        if (this.isEndEnable) {
            this.animationLine.style.height = this.isStartEnable ? "100%" : "calc(100% - " + (startRect.y + startRect.height / 2) + "px)";
        } else {
            let diff = Math.abs(this.splitLine.clientHeight - endRect.y);
            this.animationLine.style.height = this.animationLine.clientHeight - diff + "px";
        }
    }
};

LinearVerticalTimeline.prototype.deleteNode = function (targetIndex) {
    SimpleLinearVerticalDiagram.prototype.deleteNode.call(this, targetIndex);
    this.drawTimeline();
    this.setDiagramHeight();
    this.gotoPage(this.pageIndex);
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
};

LinearVerticalTimeline.prototype.getCustomProperties = function () {
    let props = {
        timeline: {
            type: this.diagramParent.dataset.timelinetype || "horizontal",
            style: this.diagramParent.dataset.timelinestyle || "strigntline",
            startelement: this.diagramParent.dataset.startelement && this.diagramParent.dataset.startelement == "false" ? false : true,
            endelement: this.diagramParent.dataset.endelement && this.diagramParent.dataset.endelement == "false" ? false : true,
            isstartenable: this.diagramParent.dataset.isstartenable && this.diagramParent.dataset.isstartenable == "false" ? false : true,
            isendenable: this.diagramParent.dataset.isendenable && this.diagramParent.dataset.isendenable == "false" ? false : true,
            position: this.diagramParent.dataset.timelineposition || "middle",
            element: this.diagramParent.dataset.timelineelement || "diagramContentNode",
        },
        nodeconnector: {
            visible: this.diagramParent.dataset.connectorvisible && this.diagramParent.dataset.connectorvisible == "false" ? false : true,
            connectorline: this.diagramParent.dataset.connectorlinevisible && this.diagramParent.dataset.connectorlinevisible == "false" ? false : true,
            connectingobject: this.diagramParent.dataset.connectorconnectingobject || "diagramContentNode",
            position: this.diagramData?.properties?.connectorposition || "middle",
        },
        node: {
            position: "middle",
            positionoffset: 50,
            split: true,
            splitalign: "alternate",
            splitorder: "order1",
            splitgap: this.diagramParent.dataset.connectorgap || "100",
        },
    };
    return props;
};

// primaryTextNode secondaryTextNode diagramContentNode contentnumberparent
LinearVerticalTimeline.prototype.customproperties = function () {
    return {
        isstartenable: !this.diagramParent.dataset.hasOwnProperty("isstartenable") || this.diagramParent.dataset.isstartenable == "true",
        isendenable: !this.diagramParent.dataset.hasOwnProperty("isendenable") || this.diagramParent.dataset.isendenable == "true",
        isyearenable: !this.diagramParent.dataset.hasOwnProperty("isyearenable") || this.diagramParent.dataset.isyearenable == "true",
    };
};

LinearVerticalTimeline.prototype.getProperties = function (defaultproperties = {}) {
    let properties = SimpleLinearVerticalDiagram.prototype.getProperties.call(this, defaultproperties);
    properties.customproperties = this.customproperties();
    return properties;
};

LinearVerticalTimeline.prototype.setPropertiesFromConstants = function (mainObj, constArrProperties, extraAttrib = "") {
    SimpleLinearVerticalDiagram.prototype.setPropertiesFromConstants.call(this, mainObj, constArrProperties, extraAttrib);
    if (this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.hasOwnProperty("isstartenable")) {
        this.diagramParent.setAttribute("data-isstartenable", this.diagramData.properties.customproperties.isstartenable);
    }
    if (this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.hasOwnProperty("isendenable")) {
        this.diagramParent.setAttribute("data-isendenable", this.diagramData.properties.customproperties.isendenable);
    }
    if (this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.hasOwnProperty("isyearenable")) {
        this.diagramParent.setAttribute("data-isyearenable", this.diagramData.properties.customproperties.isyearenable);
    }
};
// ****** Timeline related function

LinearVerticalTimeline.prototype.drawTimeline = function () {
    this.arrConnectorPoints = [];
    let oldTimline = this.diagramParent.parentElement.querySelector("[class*='timelineelement']");
    if (oldTimline) {
        oldTimline.parentElement.removeChild(oldTimline);
        this.splitLine = null;
    }

    this.totalPage = 1;
    this.currentPageIndex = 0;
    this.diagramParent.style.transform = "translateY(0px)";

    let timeline = document.createElement("div");
    timeline.className = "timelineelement" + " " + (this.nodeProps?.timelineclass || "");
    timeline.id = "timeline-" + this.diagramParent.getAttribute("parent-Id");
    timeline.setAttribute("data-id", "timeline");
    this.diagramParent.parentElement.appendChild(timeline);

    let splitLine = document.createElement("div");
    splitLine.className = "splitline clsMultiColorParent";
    splitLine.id = "splitline";
    timeline.appendChild(splitLine);
    this.splitLine = splitLine;

    let animationLine = document.createElement("div");
    animationLine.className = "animationline clsNodeAccentbg";
    DiagramUtils.setCustomItemColor(animationLine, this.arrTintArray, 0, 1);
    animationLine.id = "animationLine";
    splitLine.appendChild(animationLine);
    this.animationLine = animationLine;

    let startElement = document.createElement("div");
    startElement.className = "timelinestartelement theme-border-color secondary-color p5";
    startElement.id = "timelinestartelement";
    startElement.innerText = "START";
    timeline.appendChild(startElement);
    this.startElement = startElement;

    let endElement = document.createElement("div");
    endElement.className = "timelineendelement theme-border-color secondary-color p5";
    endElement.id = "timelineendelement";
    endElement.innerText = "END";
    timeline.appendChild(endElement);
    this.endElement = endElement;

    if (this.diagramData.properties.customproperties.hasOwnProperty("isyearenable")) {
        this.diagramParent.style.setProperty("--yearDisplay", this.diagramData.properties.customproperties.isyearenable ? "flex" : "none");
        if (this.isNumberStyle()) {
            this.splitLine.style.setProperty("--pointerlineOpacity", this.diagramData.properties.customproperties.isyearenable ? "1" : "0");
        } else this.splitLine.style.setProperty("--pointerlineOpacity", "1");
    }

    this.updateTimelineElements();
};

LinearVerticalTimeline.prototype.showHideStartEnd = function (operation) {
    if (operation.property == "start") {
        this.isStartEnable = operation.value;
        this.diagramParent.setAttribute("data-isstartenable", operation.value);
        this.diagramData.properties.customproperties.isstartenable = operation.value;
    } else if (operation.property == "end") {
        this.isEndEnable = operation.value;
        this.diagramParent.setAttribute("data-isendenable", operation.value);
        this.diagramData.properties.customproperties.isendenable = operation.value;
    }
    this.setDiagramHeight();
};

LinearVerticalTimeline.prototype.showHideYear = function (operation) {
    this.diagramParent.setAttribute("data-isyearenable", operation.value);
    this.diagramData.properties.customproperties.isyearenable = operation.value;
    this.diagramParent.style.setProperty("--yearDisplay", operation.value ? "flex" : "none");
    if (this.isNumberStyle()) {
        this.splitLine.style.setProperty("--pointerlineOpacity", operation.value ? "1" : "0");
    } else this.splitLine.style.setProperty("--pointerlineOpacity", "1");
};

LinearVerticalTimeline.prototype.isNumberStyle = function () {
    let arrContent = this.nodeProps.supportedNodes.filter((node) => node.name == "contentNode");
    if (arrContent.length > 0 && arrContent[0].subNodes.length > 0 && arrContent[0].subNodes[0].name == "valueTitleHolder") {
        return true;
    }
    return false;
};

LinearVerticalTimeline.prototype.unsetSequenceTextMargin = function () {
    this.arrDiagramNode.map(function (node) {
        let sequenceText = node.nodeGroup.querySelector("[data-id*='contentnumberparent']");
        if (sequenceText) sequenceText.style.setProperty("margin", 0, "important");
    });
};

LinearVerticalTimeline.prototype.updateTimelineElements = function () {
    this.timelinePosition();
    this.updateConnectorPoints();
    this.updateNodePosition();
    if (this.getCustomProperties().nodeconnector.connectorline == true) this.updateConnectorLine();
    if (this.diagramParent.dataset.projectionindex) this.setProjection(this.diagramParent.dataset.projectionindex);
};

LinearVerticalTimeline.prototype.timelinePosition = function () {
    switch (this.getCustomProperties().timeline.position) {
        case "top":
            this.splitLine.parentElement.style.left = 0;
            break;
        case "middle":
            this.splitLine.parentElement.style.left = this.diagramParent.clientWidth / 2 - this.splitLine.parentElement.clientWidth / 2 + "px";
            break;
        case "bottom":
            this.splitLine.parentElement.style.right = 0;
            break;
    }
};

// ****** Connector related function

LinearVerticalTimeline.prototype.updateConnectorPoints = function () {
    if (this.splitLine == null || this.getCustomProperties().nodeconnector.visible == false) return;

    while (this.arrConnectorPoints.length < this.arrDiagramNode.length) {
        let connectorPoint = document.createElement("div");
        connectorPoint.className = "connectorpoint theme-border-color";
        connectorPoint.id = "connectorpoint";
        this.splitLine.appendChild(connectorPoint);

        if (this.getCustomProperties().nodeconnector.connectorline == true) {
            let connectorLine = document.createElement("div");
            connectorLine.className = "connectorline";
            connectorLine.id = "connectorline";
            connectorPoint.appendChild(connectorLine);

            let svg = this.createSvgElement("svg", { style: "width:100%; height:100%; position:absolute;" });
            connectorLine.appendChild(svg);
            let path = this.createSvgElement("path", {});
            path.setAttribute("stroke", "var(--timeline-stroke-color)");
            path.setAttribute("stroke-dasharray", "4");
            svg.appendChild(path);
        }

        this.arrConnectorPoints.push(connectorPoint);
    }

    while (this.arrConnectorPoints.length > this.arrDiagramNode.length) {
        let point = this.arrConnectorPoints[this.arrConnectorPoints.length - 1];
        point.parentElement.removeChild(point);
        this.arrConnectorPoints.pop();
    }

    let connectorPosition = this.getCustomProperties().nodeconnector.position || "middle";
    let arrPoints = this.splitLine.querySelectorAll("[id='connectorpoint']");
    this.arrDiagramNode.map(
        function (node, i) {
            let point = arrPoints[i];
            let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
            let nodeRect = DiagramNodeUtils.getOffsetRectByParent(nodeHolder, node.nodeGroup);

            let centerY = nodeRect.y;
            centerY = centerY;
            if (connectorPosition == "middle") {
                centerY = nodeRect.y + nodeRect.height / 2;
                centerY = centerY - point.offsetHeight / 2;
            } else if (connectorPosition == "right") {
                centerY = nodeRect.y + nodeRect.height;
                centerY = centerY - point.offsetHeight;
            }
            if (point) point.style.top = centerY + "px";
        }.bind(this)
    );
};

LinearVerticalTimeline.prototype.updateConnectorLine = function () {
    this.arrConnectorPoints.map(
        function (connector, index) {
            let targetNodeId = this.getCustomProperties().nodeconnector.connectingobject;
            let node = this.arrDiagramNode[index].nodeGroup;
            let timelineobj = node.querySelector("[data-id*='" + targetNodeId + "']");
            let timelineobjRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, timelineobj); //timelineobj.getBoundingClientRect();
            let connectorRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, connector); //connector.getBoundingClientRect();

            let splitPosition = this.getCustomProperties().node.splitalign;
            let nodePosition = this.getCustomProperties().node.position;
            let isApplySplit = this.getCustomProperties().node.split;
            nodePosition = isApplySplit ? splitPosition : nodePosition;

            let width = 30;
            switch (nodePosition) {
                case "top":
                    width = connectorRect.left - (timelineobjRect.left + timelineobjRect.width);
                    connector.firstElementChild.style.left = "unset";
                    connector.firstElementChild.style.right = connector.clientWidth + "px";
                    this.updateDottedLineWidth(connector, width);
                    break;
                case "bottom":
                    width = timelineobjRect.left - (connectorRect.left + connectorRect.width);
                    connector.firstElementChild.style.right = "unset";
                    connector.firstElementChild.style.left = connector.clientWidth + "px";
                    this.updateDottedLineWidth(connector, width, false);
                    break;
                case "alternate":
                    if (index % 2 == 0) {
                        width = connectorRect.left - (timelineobjRect.left + timelineobjRect.width);
                        connector.firstElementChild.style.left = "unset";
                        connector.firstElementChild.style.right = connector.clientWidth + "px";
                        this.updateDottedLineWidth(connector, width);
                    } else {
                        width = timelineobjRect.left - (connectorRect.left + connectorRect.width);
                        connector.firstElementChild.style.right = "unset";
                        connector.firstElementChild.style.left = connector.clientWidth + "px";
                        this.updateDottedLineWidth(connector, width, false);
                    }
                    break;
            }
        }.bind(this)
    );
};

LinearVerticalTimeline.prototype.updateDottedLineWidth = function (connector, width, isTop = true) {
    connector.firstElementChild.style.width = Math.abs(width) + "px";
    connector.firstElementChild.setAttribute("data-width", connector.firstElementChild.style.width);
    let svg = connector.firstElementChild.firstElementChild;
    let svgRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, connector.firstElementChild); //connector.firstElementChild.getBoundingClientRect();
    let d = "M 5 " + svgRect.height / 2 + "  L " + (svgRect.width - 10) + " " + svgRect.height / 2 + "";
    d = isTop ? d : "M 10 " + svgRect.height / 2 + "  L " + (svgRect.width - 5) + " " + svgRect.height / 2 + "";
    svg.firstElementChild.setAttribute("d", d);
    svg.firstElementChild.setAttribute("stroke-width", connector.firstElementChild.clientHeight);
};

LinearVerticalTimeline.prototype.createSvgElement = function (tag, attrs) {
    var el = document.createElementNS("http://www.w3.org/2000/svg", tag);
    for (var k in attrs) {
        if (k == "xlink:href") {
            el.setAttributeNS("http://www.w3.org/1999/xlink", "href", attrs[k]);
        } else {
            el.setAttribute(k, attrs[k]);
        }
    }
    return el;
};

// ******* Node Position related function

LinearVerticalTimeline.prototype.updateNodePosition = function () {
    let isApplySplit = this.getCustomProperties().node.split;
    switch (this.getCustomProperties().node.position) {
        case "top":
            this.nodeAlignTop();
            break;
        case "bottom":
            this.nodeAlignBottom();
            break;
        case "alternate":
            this.nodeAlignAlternate();
            break;
        case "middle":
            isApplySplit ? this.nodeAlignSplit() : this.nodeAlignMiddle();
            break;
    }
};

LinearVerticalTimeline.prototype.nodeAlignTop = function () {
    this.arrDiagramNode.map(
        function (node, index) {
            let center = this.splitLine.parentElement.offsetLeft + this.splitLine.parentElement.offsetWidth / 2;
            let offset = this.getCustomProperties().node.positionoffset;
            node.nodeGroup.style.right = center + offset + "px";
        }.bind(this)
    );
};

LinearVerticalTimeline.prototype.nodeAlignBottom = function () {
    this.arrDiagramNode.map(
        function (node, index) {
            let center = this.splitLine.parentElement.offsetLeft + this.splitLine.parentElement.offsetWidth / 2;
            let offset = this.getCustomProperties().node.positionoffset;
            node.nodeGroup.style.left = center + offset + "px";
        }.bind(this)
    );
};

LinearVerticalTimeline.prototype.nodeAlignMiddle = function () {
    this.arrDiagramNode.map(
        function (node, index) {
            this.alternateOrder(node.nodeGroup, index);
            let targetId = this.getCustomProperties().timeline.element;
            let nodeItem = node.nodeGroup;
            let targetObj = node.nodeGroup.querySelector("[data-id*='" + targetId + "']");

            let timelineRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, this.splitLine); //this.splitLine.getBoundingClientRect();
            let timelineCenter = timelineRect.left + timelineRect.width / 2;

            let targetObjRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, targetObj); //targetObj.getBoundingClientRect();
            let targetObjCenter = targetObjRect.left + targetObjRect.width / 2;

            let centerDiff = timelineCenter - targetObjCenter;
            nodeItem.style.left = nodeItem.offsetLeft + centerDiff;
        }.bind(this)
    );
};

LinearVerticalTimeline.prototype.nodeAlignAlternate = function () {
    this.arrDiagramNode.map(
        function (node, index) {
            // let vlText = node.parentNode.querySelector(".clsSingleLineRestrict");
            // if (vlText) vlText.classList.remove("clsSingleLineRestrict");

            let center = this.splitLine.parentElement.offsetLeft + this.splitLine.parentElement.offsetWidth / 2;
            let offset = this.getCustomProperties().node.positionoffset;
            if (index % 2 == 0) {
                node.nodeGroup.style.left = "unset";
                node.nodeGroup.style.right = center + offset + "px";
                this.setTextAlign(node.nodeGroup, "right");
            } else {
                node.nodeGroup.style.right = "unset";
                node.nodeGroup.style.left = center + offset + "px";
                this.setTextAlign(node.nodeGroup, "left");
            }
        }.bind(this)
    );
};

LinearVerticalTimeline.prototype.nodeAlignSplit = function () {
    this.arrDiagramNode.map(
        function (node, index) {
            // let vlText = node.parentNode.querySelector(".clsSingleLineRestrict");
            // if (vlText) vlText.classList.remove("clsSingleLineRestrict");

            let targetId = this.getCustomProperties().timeline.element;
            let nodeItem = node.nodeGroup;
            let targetObj = node.nodeGroup.querySelector("[data-id*='" + targetId + "']");

            let splitGap = parseFloat(this.getCustomProperties().node.splitgap);
            let splitAlign = this.getCustomProperties().node.splitalign;

            let secContentNode = node.nodeGroup.querySelector("[name='secContentNode']");
            if (secContentNode) {
                // secContentNode.style.maxHeight = "200px";
                secContentNode.style.overflow = "hidden";
            }

            switch (splitAlign) {
                case "top":
                    targetObj.style.marginRight = splitGap + "px";
                    targetObj.style.setProperty("margin-right", splitGap + "px", "important");
                    this.alignTimelineElement(nodeItem, targetObj, splitGap);
                    break;
                case "bottom":
                    targetObj.style.marginLeft = splitGap + "px";
                    targetObj.style.setProperty("margin-left", splitGap + "px", "important");
                    this.alignTimelineElement(nodeItem, targetObj, splitGap, "bottom");
                    break;
                case "alternate":
                    this.alternateOrder(node.nodeGroup, index);
                    if (index % 2 == 0) {
                        targetObj.style.marginLeft = "unset";
                        targetObj.style.marginRight = splitGap + "px";
                        targetObj.style.setProperty("margin-right", splitGap + "px", "important");
                        this.alignTimelineElement(nodeItem, targetObj, splitGap);
                    } else {
                        targetObj.style.marginRight = "unset";
                        targetObj.style.marginLeft = splitGap + "px";
                        targetObj.style.setProperty("margin-left", splitGap + "px", "important");
                        this.alignTimelineElement(nodeItem, targetObj, splitGap, "bottom");
                    }
            }
        }.bind(this)
    );
};

LinearVerticalTimeline.prototype.alternateOrder = function (node, index) {
    let arrOrder = [
        [2, 1, 3, 0],
        [0, 2, 0, 3],
    ];

    let primary = node.querySelector("[data-id*='primaryTextNode']");
    let number = node.querySelector("[data-id*='contentnumberparent']");
    let secondary = node.querySelector("[data-id*='secondaryTextNode']");
    let content = node.querySelector("[data-id*='diagramContentNode']");

    primary.style.order = arrOrder[index % 2][0];
    if (number) number.style.order = arrOrder[index % 2][1];
    secondary.style.order = arrOrder[index % 2][2];
    content.style.order = arrOrder[index % 2][3];
};

LinearVerticalTimeline.prototype.alignTimelineElement = function (nodeItem, targetObj, splitGap = 0, align = "top") {
    nodeItem.style.right = "unset";
    nodeItem.style.left = "unset";
    let timelineRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, this.splitLine); //this.splitLine.getBoundingClientRect();
    let timelineCenter = timelineRect.left + timelineRect.width / 2;

    let targetObjRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent.parentElement, targetObj); //targetObj.getBoundingClientRect();
    let connector = this.arrConnectorPoints[0];
    let connectorWidth = connector ? connector.clientWidth : 0;

    if (align == "top") {
        let targetObjCenter = targetObjRect.left + targetObjRect.width;
        let centerDiff = timelineCenter - targetObjCenter;
        nodeItem.style.left = nodeItem.offsetLeft + centerDiff - (splitGap - connectorWidth) + "px";
        this.setTextAlign(nodeItem, "left");
        nodeItem.parentElement.setAttribute("data-align-position", "left");
    } else {
        let targetObjCenter = targetObjRect.left;
        let centerDiff = timelineCenter - targetObjCenter;
        // nodeItem.style.top = nodeItem.offsetTop + centerDiff + (splitGap - connectorWidth / 1.5);
        let objTop = nodeItem.offsetLeft + centerDiff + (splitGap - connectorWidth);
        let objBottom = nodeItem.parentElement.clientWidth - (objTop + nodeItem.clientWidth);
        nodeItem.style.right = objBottom + "px";
        this.setTextAlign(nodeItem, "right");
        nodeItem.parentElement.setAttribute("data-align-position", "right");
    }
};

// LinearVerticalTimeline.prototype.focusCallBack = function(event) {
//     Diagram.prototype.focusCallBack.call(this, event);
//     let index = event.target.dataset.index;
//     let nodeItem = this.diagramParent.querySelector("[id='nodeitem" + index + "']");
//     if (event.type == "focusin") {
//     } else if (event.type == "focusout") {
//         if (event.target.getAttribute("data-node-type") == "content") {
//             return;
//         }
//         this.resizeConnectors();
//         this.resetNodeAttributes();
//         DiagramResizeUtils.resetFontSizeForType(this.diagramParent, event.target.dataset.id);
//         this.searchIcon(event.target.innerText, nodeItem, event.target.dataset.index, this.diagramData.properties.contenttype);
//     }
// };

LinearVerticalTimeline.prototype.setTextAlign = function (node, textAlign, vertiacalAlign = "center") {
    let primaryContent = node.querySelector("[data-id='diagramContentNode']");
    if (primaryContent) {
        let valText = primaryContent.querySelector("[name='numberNode']");
        if (valText) valText.style.setProperty("text-align", textAlign == "right" ? "left" : "right", "important");
    }

    let textParent = node.querySelector("[name='secContentNode']");
    textParent.style.justifyContent = vertiacalAlign;
    if (!textParent) return;
    let title = node.querySelector("[data-id*='primaryTextNode']");
    let subtitle = node.querySelector("[data-id*='secondaryTextNode']");
    let number = node.querySelector("[data-id*='contentnumberparent']");

    title.style.textAlign = textAlign;
    title.style.setProperty("text-align", textAlign, "important");
    if (number) number.style.setProperty("text-align", textAlign, "important");

    let contentAlignment = textAlign == "center" ? "center" : "flex-start";
    contentAlignment = textAlign == "right" ? "flex-end" : contentAlignment;
    subtitle.style.alignItems = contentAlignment;
    subtitle.style.setProperty("align-items", contentAlignment, "important");

    subtitle.className = subtitle.className.replace(" right", "").replace(" left", "").replace(" center", "");
    subtitle.className = subtitle.className + " " + textAlign;
};

LinearVerticalTimeline.prototype.setupAnimation = function (animationType, callback) {
    this.animationCompleteCallback = callback;
    this.animationType = animationType;
    this.highlightIndex = -1;

    this.pageIndex = 1;
    this.totalPage = Math.ceil(this.splitLine.parentElement.offsetHeight / this.diagramParent.parentElement.offsetHeight);
    this.animationIndex = 0;
    this.allAtOnceIndex = 0;
    this.animateItemCount = 0;
    this.currentPageIndex = 0;
    this.animationFactor = this.diagramParent.parentElement.dataset.moodanimation && this.diagramParent.parentElement.dataset.moodanimation == "none" ? 0 : 1;

    this.diagramParent.style.transform = "translateY(0px)";
    this.splitLine.parentElement.style.transform = "translateY(0px)";

    if (this.animationType == "none") {
        this.diagramParent.style.opacity = 1;
        this.splitLine = this.diagramParent.parentElement.querySelector("[id='splitline']");
        if (this.splitLine && this.splitLine.parentElement) this.splitLine.parentElement.style.opacity = 1;
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return;
    }

    if (!this.moodData.animationData.multislideAnimation)
        this.arrDiagramNode.map(
            function (node, index) {
                let nodeItem = node.nodeGroup;
                let connector = this.arrConnectorPoints[index];
                this.animationLine.style.transition = "all 0s";
                this.animationLine.style.height = "0px";
                this.hideAnimation(node.nodeGroup, connector, 0, false);
                this.startElement.style.transition = "";
                this.startElement.style.transform = "scale(0)";
                this.endElement.style.transition = "";
                this.endElement.style.transform = "scale(0)";
            }.bind(this)
        );

    this.diagramParent.style.transition = `all ${0.3 * this.animationFactor}s`;
    this.diagramParent.style.opacity = 1;

    setTimeout(() => {
        if (animationType == "all") this.playAllAtOnce();
        else this.animationCompleteCallback?.fn?.(this.animationCompleteCallback.params);
    }, 100);
};

LinearVerticalTimeline.prototype.playNext = function (index, isAllAtOnce = false) {
    this.updateAnimationPath("show");
    if (this.arrDiagramNode.length == this.animationIndex) {
        if (this.moodData.animationData.isHideAnimation) {
            this.diagramParent.style.transition = "all 0.2s " + this.cubicPath;
            this.diagramParent.style.opacity = 0;
            this.splitLine.parentElement.style.transition = "all 0.2s " + this.cubicPath;
            this.splitLine.parentElement.style.opacity = 0;
        }
        // if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return false;
    }

    this.diagramParent.style.opacity = 1;
    this.splitLine.parentElement.style.opacity = 1;

    if (this.isReversAnimation) {
        this.animationIndex += 1;
        this.isReversAnimation = false;
    }

    this.isForwardAnimation = true;
    let delay = 0;
    if (this.startElement.style.transform == "scale(0)" && this.isStartEnable) {
        this.startElement.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        this.startElement.style.transform = "scale(1)";
        delay = delay + 0.1;
    }

    let nodeItem = this.arrDiagramNode[this.animationIndex].nodeGroup;
    let connector = this.arrConnectorPoints[this.animationIndex];

    if ((this.animationIndex > 0 && !this.isStartEnable) || this.isStartEnable) {
        this.animationLine.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        let animationLineHeight = connector.offsetTop + connector.clientHeight / 2 - this.animationLine.offsetTop;
        animationLineHeight = animationLineHeight < 0 ? 0 : animationLineHeight;
        this.animationLine.style.height = animationLineHeight + "px";

        let isInside = DiagramNodeUtils.isRectInSideRectVerticaly(this.diagramParent.parentElement, nodeItem);
        if (!isInside) {
            this.gotoPage(this.pageIndex, true, true);
            this.pageIndex += 1;
        }
    }

    delay = this.showAnimation(nodeItem.parentElement, connector, delay * this.animationFactor, this.animationIndex);
    if (this.animationIndex == this.arrDiagramNode.length - 1 && (this.moodData.animationData.multislideAnimation || this.endElement.style.transform == "scale(0)") && this.isEndEnable) {
        let height = this.isStartEnable ? "100%" : "calc(100% - " + this.animationLine.offsetTop + "px)";
        setTimeout(() => {
            this.animationLine.style.height = height;
        }, delay * 1000);

        this.endElement.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        this.endElement.style.transform = "scale(1)";
    }

    setTimeout(() => {
        if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, delay * 1000);
    this.animationIndex += 1;

    return true;
};

LinearVerticalTimeline.prototype.playPrevious = function (index, isAllAtOnce = false) {
    this.updateAnimationPath("hide");
    if (this.animationIndex == -1) {
        this.diagramParent.style.transition = "all 0.2s " + this.cubicPath;
        this.diagramParent.style.opacity = 0;
        this.splitLine.parentElement.style.transition = "all 0.2s " + this.cubicPath;
        this.splitLine.parentElement.style.opacity = 0;
        // if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return false;
    }

    this.diagramParent.style.opacity = 1;
    this.splitLine.parentElement.style.opacity = 1;

    if (this.isForwardAnimation) {
        this.isForwardAnimation = false;
        this.animationIndex -= 1;
    }

    this.isReversAnimation = true;
    let delay = 0;
    if (this.endElement.style.transform == "scale(1)") {
        this.endElement.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        this.endElement.style.transform = "scale(0)";
        let connector = this.arrConnectorPoints[this.animationIndex];
        this.animationLine.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.3;
        let animationLineHeight = connector.offsetTop + connector.clientHeight / 2 - this.animationLine.offsetTop;
        animationLineHeight = animationLineHeight < 0 ? 0 : animationLineHeight;
        this.animationLine.style.height = animationLineHeight + "px";

        setTimeout(() => {
            this.playPrevious();
        }, delay * this.animationFactor * 1000);
        return true;
    }

    let nodeItem = this.arrDiagramNode[this.animationIndex].nodeGroup;
    let connector = this.arrConnectorPoints[this.animationIndex];
    delay = this.hideAnimation(nodeItem.parentElement, connector, delay * this.animationFactor, this.animationFactor == 1);
    if (this.animationIndex == 0 && this.endElement.style.transform == "scale(1)") {
        this.animationLine.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        this.animationLine.style.height = "0px";
        this.endElement.style.transform = "scale(0)";
    }
    this.animationIndex -= 1;
    if (this.animationIndex >= 0) {
        let connector = this.arrConnectorPoints[this.animationIndex];
        this.animationLine.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        let animationLineHeight = connector.offsetTop + connector.clientHeight / 2 - this.animationLine.offsetTop;
        animationLineHeight = animationLineHeight < 0 ? 0 : animationLineHeight;
        this.animationLine.style.height = animationLineHeight + "px";

        let previousIndex = this.animationIndex > 0 ? this.animationIndex : 0;
        let prevoiuseNode = this.arrDiagramNode[previousIndex].nodeGroup;
        let isInside = DiagramNodeUtils.isRectInSideRectVerticaly(this.diagramParent.parentElement, prevoiuseNode);
        if (!isInside) {
            this.pageIndex -= 1;
            this.gotoPage(this.pageIndex - 1, true);
        }
    } else {
        this.animationLine.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        this.animationLine.style.height = "0px";
        this.startElement.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        this.startElement.style.transform = "scale(0)";
    }

    setTimeout(() => {
        if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, delay * 1000);
    return true;
};

LinearVerticalTimeline.prototype.moveNext = function (isAnimate = false) {
    let slideHeight = this.diagramParent.parentElement.offsetHeight;
    let diagramHeight = this.diagramParent.parentElement.scrollHeight;

    if (slideHeight == diagramHeight) return;
    this.diagramParent.style.transition = isAnimate ? "all " + 1.2 * this.animationFactor + "s " + this.cubicPath : "";
    this.splitLine.parentElement.style.transition = isAnimate ? "all " + 1.2 * this.animationFactor + "s " + this.cubicPath : "";

    let translateY = parseFloat(window.getComputedStyle(this.diagramParent).transform.replace("matrix(", "").split(",")[5]);
    translateY = Math.abs(translateY);
    let oldTransateY = translateY;
    let diffHeight = diagramHeight - translateY;
    if (diffHeight - slideHeight >= slideHeight || diffHeight == slideHeight) {
        translateY = translateY + slideHeight;
        this.diagramParent.style.transform = "translateY(" + -translateY + "px)";
        this.splitLine.parentElement.style.transform = "translateY(" + -translateY + "px)";
        this.navigationIndex += 1;
    } else {
        translateY = translateY + (slideHeight - diffHeight);
        translateY = Math.abs(translateY);
        this.diagramParent.style.transform = "translateY(" + -translateY + "px)";
        this.splitLine.parentElement.style.transform = "translateY(" + -translateY + "px)";
        if (oldTransateY != translateY) this.navigationIndex += 1;
    }
};

LinearVerticalTimeline.prototype.movePrevious = function (isAnimate = false) {
    let slideHeight = this.diagramParent.parentElement.offsetHeight;
    let translateY = parseFloat(window.getComputedStyle(this.diagramParent).transform.replace("matrix(", "").split(",")[5]);
    translateY = Math.abs(translateY);

    this.diagramParent.style.transition = isAnimate ? "all " + 1.2 * this.animationFactor + "s " + this.cubicPath : "";
    this.splitLine.parentElement.style.transition = isAnimate ? "all " + 1.2 * this.animationFactor + "s " + this.cubicPath : "";
    if (translateY > slideHeight) {
        translateY = translateY - slideHeight;
        this.diagramParent.style.transform = "translateY(" + -translateY + "px)";
        this.splitLine.parentElement.style.transform = "translateY(" + -translateY + "px)";
        this.navigationIndex -= 1;
    } else if (translateY > 0) {
        translateY = 0;
        this.diagramParent.style.transform = "translateY(" + -translateY + "px)";
        this.splitLine.parentElement.style.transform = "translateY(" + -translateY + "px)";
        this.navigationIndex -= 1;
    }
};

LinearVerticalTimeline.prototype.hideAnimation = function (nodeItem, connector, delay, isAnimate = true) {
    let durationFactor = isAnimate ? "" : "no";
    let delayFactor = isAnimate ? 1 : 0;

    let targetId = this.getCustomProperties().timeline.element;
    let targetObj = nodeItem.querySelector("[data-id*='" + targetId + "']");
    if (targetObj) {
        targetObj.style.transition = "";
        targetObj.style.transition = "all 0.2" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        targetObj.style.transform = "scale(0)";
    }

    let positionX = nodeItem.dataset.alignPosition && nodeItem.dataset.alignPosition == "left" ? "50px" : "-50px";

    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    if (primary) {
        primary.style.transition = "";
        primary.style.transition = "all 0.2" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        primary.style.transform = "translateX(" + positionX + ")";
        primary.style.setProperty("opacity", 0, "important");
    }

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    if (seconday) {
        seconday.style.transition = "";
        seconday.style.transition = "all 0.2" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        seconday.style.transform = "translateX(" + positionX + ")";
        seconday.style.setProperty("opacity", 0, "important");
    }

    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "";
        number.style.transition = "all 0.2" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        number.style.transform = "translateX(" + positionX + ")";
        number.style.setProperty("opacity", 0, "important");
    }

    let secContentNode = nodeItem.querySelector("[name='secContentNode']");
    if (secContentNode) {
        secContentNode.style.transition = "";
        secContentNode.style.transition = "all 0.2" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        secContentNode.style.transform = "translateX(" + positionX + ")";
        secContentNode.style.setProperty("opacity", 0, "important");
    }

    if (connector) {
        connector.style.transition = "";
        connector.style.transition = "all 0.2" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        connector.firstElementChild.style.width = "0px";

        connector.firstElementChild.style.transition = "";
        connector.firstElementChild.style.transition = "all 0.2" + durationFactor + "s " + delay * delayFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        connector.style.transform = "scale(0)";
    }

    return delay;
};

LinearVerticalTimeline.prototype.showAnimation = function (nodeItem, connector, delay, index) {
    if (connector) {
        connector.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        connector.style.transform = "scale(1)";

        connector.firstElementChild.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        connector.firstElementChild.style.width = connector.firstElementChild.dataset.width;
    }

    let targetId = this.getCustomProperties().timeline.element;
    let targetObj = nodeItem.querySelector("[data-id*='" + targetId + "']");
    if (targetObj) {
        targetObj.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        // delay = delay + 0.1;
        targetObj.style.transform = "scale(1)";
    }

    let secContentNode = nodeItem.querySelector("[name='secContentNode']");
    if (secContentNode) {
        secContentNode.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        secContentNode.style.transform = "translateX(0px)";
        secContentNode.style.setProperty("opacity", 1, "important");
    }

    let number = nodeItem.querySelector("[data-id*='contentnumberparent']");
    if (number) {
        number.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        number.style.transform = "translateX(0px)";
        number.style.setProperty("opacity", 1, "important");
    }

    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    if (primary) {
        primary.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        primary.style.transform = "translateX(0px)";
        primary.style.setProperty("opacity", 1, "important");
    }

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    if (seconday) {
        seconday.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        seconday.style.transform = "translateX(0px)";
        seconday.style.setProperty("opacity", 1, "important");
    }

    return delay * this.animationFactor;
};

LinearVerticalTimeline.prototype.navigation = function (navigation) {
    if (navigation.direction == "next") {
        // this.moveNext();
        if (this.currentPageIndex == this.totalPage - 1) return false;
        this.currentPageIndex += 1;
        this.gotoPage(this.currentPageIndex);
    } else {
        // this.movePrevious();
        if (this.currentPageIndex == 0) return false;
        this.currentPageIndex -= 1;
        this.gotoPage(this.currentPageIndex);
    }
    return true;
};

LinearVerticalTimeline.prototype.addFocus = function (index) {
    this.totalPage = Math.ceil(this.splitLine.parentElement.offsetHeight / this.diagramParent.parentElement.offsetHeight);
    this.currentPageIndex = this.totalPage - 1;

    let primaryTextNode = this.diagramParent.querySelector("[data-id='primaryTextNode'][data-index='" + index + "']");
    this.gotoPage(this.currentPageIndex);
    setTimeout(() => {
        if (primaryTextNode) primaryTextNode.firstElementChild.focus();
    }, 0);
    // primaryTextNode.firstElementChild.focus();
};

LinearVerticalTimeline.prototype.gotoPage = function (pageIndex, isAnimate = false, isNext = false) {
    let slideHeight = this.diagramParent.parentElement.offsetHeight;
    let diagramHeight = this.splitLine.parentElement.offsetHeight;
    let translateY = 0;
    if (this.splitLine && diagramHeight > slideHeight) {
        let pagePositionY = slideHeight * pageIndex;
        let calHeight = diagramHeight - slideHeight;

        if (pagePositionY <= calHeight) {
            translateY = pagePositionY;
        } else {
            translateY = calHeight;
        }

        let delay = isNext ? "0" : "1";
        this.diagramParent.style.transition = isAnimate ? "all " + 1.2 * this.animationFactor + "s " + this.cubicPath : "";
        this.splitLine.parentElement.style.transition = isAnimate ? "all " + 1.2 * this.animationFactor + "s " + this.cubicPath : "";

        this.diagramParent.style.transform = "translateY(" + -translateY + "px)";
        this.splitLine.parentElement.style.transform = "translateY(" + -translateY + "px)";
    }
};

LinearVerticalTimeline.prototype.playAllAtOnce = function () {
    this.itemPerPage = this.getNodePostion()[this.allAtOnceIndex];
    if (!this.itemPerPage) return false;
    this.playNext(0, true);
    this.animateItemCount = 1;
    if (this.itemPerPage > 1) {
        var interval = setInterval(() => {
            this.playNext(0, true);
            this.animateItemCount += 1;
            if (this.animationCompleteCallback && this.animateItemCount == this.itemPerPage) {
                this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
                clearInterval(interval);
            }
        }, 1000 * this.animationFactor);
    } else {
        this.animationCompleteCallback.fn?.(this.animationCompleteCallback.params);
    }

    this.allAtOnceIndex += 1;
    return true;
};

LinearVerticalTimeline.prototype.playAllAtOnceReverse = function () {
    this.itemPerPage = this.getNodePostion()[this.allAtOnceIndex - 1];
    if (!this.itemPerPage) return false;
    this.playPrevious(0, true);
    this.animateItemCount = 1;
    if (this.itemPerPage > 1) {
        var interval = setInterval(() => {
            this.playPrevious(0, true);
            this.animateItemCount += 1;
            if (this.animationCompleteCallback && this.animateItemCount == this.itemPerPage) {
                this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
                clearInterval(interval);
            }
        }, 1200 * this.animationFactor);
    } else {
        this.animationCompleteCallback.fn?.(this.animationCompleteCallback.params);
    }

    this.allAtOnceIndex -= 1;
    return true;
};

LinearVerticalTimeline.prototype.updateAnimationPath = function (type) {
    this.cubicPath = "";
    try {
        this.cubicPath = this.moodData.animationData[type].animation.all.effect;
    } catch (error) {
        this.cubicPath = "";
        console.log("Erro accessind timeline animation data HorizontalTimelineDiagram.js");
    }
};

LinearVerticalTimeline.prototype.getNodePostion = function () {
    switch (this.diagramData.nodes.length) {
        case 1:
            return [1];
        case 2:
            return [2];
        case 3:
            return [2, 1];
        case 4:
            return [2, 2];
        case 5:
            return [2, 2, 1];
        case 6:
            return [2, 2, 2];
        case 7:
            return [2, 3, 2];
        case 8:
            return [2, 2, 2, 2];
        case 9:
            return [2, 2, 3, 2];
        case 10:
            return [2, 3, 3, 2];
        case 11:
            return [2, 3, 2, 2, 2];
        case 12:
            return [2, 3, 3, 2, 2];
    }
};

LinearVerticalTimeline.prototype.splitArrayWithOrder = function (arrSplitOrder, array) {
    let tempArr = [];
    let nodeArr = [];
    let nodeCount = arrSplitOrder[0];
    for (var i = 0; i < array.length + 1; i++) {
        if (nodeArr.length == nodeCount) {
            tempArr.push(nodeArr);
            nodeArr = [];
            nodeCount = arrSplitOrder[tempArr.length];
        }
        if (array[i] == null) continue;
        nodeArr.push(array[i]);
    }
    return tempArr;
};

LinearVerticalTimeline.prototype.updateSlideBasednodeHeight = function (arrNodes, height, padding, pos) {
    arrNodes.map(function (node, i) {
        let parentNode = node.getNodeParent().parentElement;
        parentNode.style.setProperty("flex", "unset", "important");
        parentNode.style.minHeight = height + "px";
        parentNode.style.height = height + "px";
        parentNode.style.marginBottom = "";
        parentNode.style.marginTop = "";
        if (pos == "start" && i == arrNodes.length - 1) {
            parentNode.style.marginBottom = padding + "px";
        } else if (pos == "end" && i == 0) {
            parentNode.style.marginTop = padding * 2 + "px";
        } else if (pos == "mid") {
            if (i == 0) parentNode.style.marginTop = padding * 2 + "px";
            if (i == arrNodes.length - 1) parentNode.style.marginBottom = padding + "px";
        }
    });
};

LinearVerticalTimeline.prototype.setDiagramSpecficOption = function (obj) {
    let startendelementoption = {};
    startendelementoption.start = {};
    startendelementoption.end = {};
    startendelementoption.start.isOn = this.isStartEnable != null ? this.isStartEnable : false;
    startendelementoption.end.isOn = this.isEndEnable != null ? this.isEndEnable : false;
    obj.dpcontent.floatdiagramsettings.startendelementoption = startendelementoption;
    obj.dpcontent.slidecomponent = { bgImage: false, takeAwayText: false };
    obj.isDisableLayoutOption = "true";

    let valueTitleHolder = this.diagramParent.querySelector("[name='valueTitleHolder']");
    if (valueTitleHolder) {
        obj.dpcontent.floatdiagramsettings.year = { isOn: this.diagramData.properties.customproperties.isyearenable, property: "Year", label: "Year" };
        obj.dpcontent.floatdiagramsettings.dateformat = DiagramUtils.getDateFormatInlineData(this);
    }

    delete obj.dpcontent.floatdiagramsettings.graphicvalueformat;
    obj.dpcontent.floatdiagramsettings.dateformat = DiagramUtils.getDateFormatInlineData(this);

    LinearDiagram.prototype.setDiagramSpecficOption.call(this, obj);
};

LinearVerticalTimeline.prototype.setupNavigation = function (navigationContent) {
    if (this.splitLine) {
        navigationContent.imagelist = [];
        let splitLineHeight = this.splitLine.parentElement.clientHeight;
        let pageCount = Math.ceil(splitLineHeight / this.diagramParent.parentElement.clientHeight);
        for (var i = 0; i < pageCount; i++) {
            navigationContent.imagelist.push({});
        }
        navigationContent.imagestackselectedindex = this.currentPageIndex ? this.currentPageIndex : 0;
    }
    return navigationContent;
};

LinearVerticalTimeline.prototype.slideDimensionChange = function () {
    this.setGroupWidth();
    this.setDiagramHeight();
};

LinearVerticalTimeline.prototype.setGroupWidth = function () {
    let pattenDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    let firstNode = this.arrDiagramNode[0].parentNode;
    let contentNode = firstNode.querySelector("[data-id='diagramContentNode']");
    if (pattenDiv) {
        let splitGap = parseFloat(this.getCustomProperties().node.splitgap);
        pattenDiv.style.setProperty("--contentWidth", "100px");
        pattenDiv.style.setProperty("--groupWidth", this.diagramParent.clientWidth / 2 + contentNode.offsetWidth + splitGap - 20 + "px");
        try {
            if (this.arrDiagramNode[0].getNodeParent().querySelector("[data-id='diagramContentNode']").querySelector("[data-id='contentnumberparent']")) {
                pattenDiv.style.setProperty("--contentWidth", "170px");
                pattenDiv.style.setProperty("--groupWidth", this.diagramParent.clientWidth / 2 + contentNode.clientWidth + splitGap - 20 + "px");
            }
        } catch (error) {
            console.log("LinearVerticalTimeline.prototype.setGroupWidth " + error);
        }
    }
};

LinearVerticalTimeline.prototype.initPresent = function (currentSlideData) {
    this.diagramParent = currentSlideData.querySelector("[id='diagramparent']");

    if (this.diagramParent.parentElement.dataset.animationtype && this.diagramParent.parentElement.dataset.animationtype == "none") return { isTitleAnimation: false, isGraphicAnimation: false };
    let moodanimation = this.diagramParent.parentElement.dataset.moodanimation;
    if (moodanimation && moodanimation == "none") {
        if (this.diagramParent) this.diagramParent.style.opacity = 1;
        if (this.splitLine && this.splitLine.parentElement) this.splitLine.parentElement.style.opacity = 1;
        return { isTitleAnimation: false, isGraphicAnimation: false };
    }
    if (this.diagramParent && !this.moodData?.animationData.multislideAnimation) this.diagramParent.style.opacity = 0;

    this.splitLine = currentSlideData.querySelector("[id='splitline']");
    if (this.splitLine && this.splitLine.parentElement && !this.moodData?.animationData.multislideAnimation) this.splitLine.parentElement.style.opacity = 0;

    return { isTitleAnimation: true, isGraphicAnimation: false };
};

LinearVerticalTimeline.prototype.diagramRenderComplete = function () {
    if (this.completeCallBack && this.completeCallBack.func && this.isRenderComplete) {
        LinearDiagram.prototype.diagramRenderComplete.call(this);
    }
    this.diagramParent.style.opacity = 1;
};

LinearVerticalTimeline.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsTimelineVertical";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.appendChild(pattenDiv);
    let nodealignment = this.nodeProps.nodealignment;
    this.diagramParent.setAttribute("data-node-alignment", nodealignment);
    let contentSize = (pattenDiv.offsetHeight - (nodeCount - 1) * this.nodeGap) / nodeCount;

    pattenDiv.style.setProperty("--nodeWidth", "auto");
    pattenDiv.style.setProperty("--nodeHeight", contentSize + "px");

    this.createNodeInstances(nodeCount, pattenDiv);
    this.setGroupWidth();

    this.diagramData.properties.customproperties = this.diagramData.properties.customproperties ? this.diagramData.properties.customproperties : this.customproperties();
    this.isStartEnable = this.diagramData.properties.customproperties.isstartenable == undefined ? true : this.diagramData.properties.customproperties.isstartenable;
    this.isEndEnable = this.diagramData.properties.customproperties.isendenable == undefined ? true : this.diagramData.properties.customproperties.isendenable;
    this.drawTimeline();
    this.setDiagramHeight();
    this.currentPageIndex = 0;
    this.isRenderComplete = true;
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
    // this.diagramRenderComplete();
};

LinearVerticalTimeline.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearVerticalDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    let disableProperties = ["graphicnone", "sequencetext", "numbersize", "iconsize", "imagesize", "logosize"];
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable = [...mainProperties.floateroptionsdisable, ...disableProperties];
    } else mainProperties.floateroptionsdisable = disableProperties;
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

LinearVerticalTimeline.prototype.setProjection = function (projectionIndex) {
    let index = projectionIndex;
    this.arrDiagramNode.map(
        function (node, i) {
            let nodeParent = node.parentNode.parentElement;
            let isProjectionEnable = parseInt(nodeParent.dataset.index) >= parseInt(index);
            isProjectionEnable ? nodeParent.classList.add("clstimelineprojection") : nodeParent.classList.remove("clstimelineprojection");
            let connertorPoint = this.arrConnectorPoints[i];
            if (connertorPoint) isProjectionEnable ? connertorPoint.classList.add("clstimelineprojection") : connertorPoint.classList.remove("clstimelineprojection");
        }.bind(this)
    );

    let oldSvg = this.animationLine.querySelector("#projectionSvg");
    if (oldSvg) oldSvg.parentElement.removeChild(oldSvg);
    let svg = DiagramNodeUtils.createSVGElement("svg");
    DiagramNodeUtils.assignAttributes(svg, { id: "projectionSvg", width: "100%", height: "100%", style: "top:0px; position:absolute;" });
    this.animationLine.appendChild(svg);

    let connertorPoint = this.arrConnectorPoints[index];
    let node = this.arrDiagramNode[0];
    let nodeParent = node.parentNode;
    let offset = this.isStartEnable ? 0 : nodeParent.offsetHeight / 2;
    if (!connertorPoint) return;
    let point1 = { x: this.animationLine.clientWidth / 2, y: connertorPoint.offsetTop + connertorPoint.offsetHeight / 2 - offset };
    let point2 = { x: point1.x, y: this.animationLine.clientHeight };
    let line = this.createLine(point1, point2);
    DiagramNodeUtils.assignAttributes(line, { "stroke-width": 10, "stroke-dasharray": 10, stroke: "rgba(var(--secondary-color-rgb), 1)" });
    let bgLine = line.cloneNode(true);
    DiagramNodeUtils.assignAttributes(bgLine, { stroke: "rgba(var(--single-bg-color-rgb), 1)", "stroke-width": 10, "stroke-dasharray": 0, class: "clstimelineprojection" });
    svg.appendChild(bgLine);
    svg.appendChild(line);
};

LinearVerticalTimeline.prototype.createLine = function (startPoint, endPoint) {
    let line = DiagramNodeUtils.createSVGElement("line");
    DiagramNodeUtils.assignSVGNodeAttributes(line, { x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y, "stroke-width": 5 });
    return line;
};

LinearVerticalTimeline.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    dict["crossout"] = null;
    if (elTarget.getAttribute("name") && elTarget.getAttribute("name") == "secondaryTextItem") return;
    var tlIndex = elTarget.dataset.index;
    let val = this.diagramParent.dataset.projectionindex && this.diagramParent.dataset.projectionindex == tlIndex;
    dict["projection"] = { visible: true, value: val, floaterproperty: "projection" };
    if (strSelectionType == "primaryText" || strSelectionType == "numberNode") this.getFontSizeDataForInlineFloater(dict, elTarget);
};

LinearVerticalTimeline.prototype.projection = function (property) {
    var index = property.targetid.replace(/\D/g, "");
    property.value ? this.diagramParent.setAttribute("data-projectionindex", index) : this.diagramParent.removeAttribute("data-projectionindex");
    this.setProjection(property.value ? index : 100);
};

LinearVerticalTimeline.prototype.updateDateFormat = function (obj) {
    this.arrDiagramNode.forEach((node) => node.updateDateFormat?.(obj));
};

/**
 * Author:    Krishna Prabhu M
 * Created:   20 May 2020
 *
 * (c) Copyright by Gs.
 **/
//test
"use strict";

function PositionableVTimeline(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    LinearVerticalTimeline.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.observer = null;
}

PositionableVTimeline.prototype = Object.create(LinearVerticalTimeline.prototype);
PositionableVTimeline.prototype.constructor = PositionableVTimeline;

PositionableVTimeline.prototype.updateEvents = function () {
    LinearDiagram.prototype.updateEvents.call(this);
    let cusProps = this.getCustomProperties();
    let { position, positionoffset } = cusProps.node;

    if (position == "alternate") return;
    let nodeHolder = this.diagramParent?.querySelector("[name='nodesHolder']");
    if (nodeHolder) {
        if (this.observer) {
            this.observer.disconnect();
            this.observer = null;
        }
        this.observer = new ResizeObserver((mutation) => {
            let target = mutation[0].target;
            this.updateTimelinePosition(target);
        });
        this.observer.observe(nodeHolder);
    }
};

PositionableVTimeline.prototype.getCustomProperties = function () {
    let props = {
        timeline: {
            type: this.diagramParent.dataset.timelinetype || "horizontal",
            style: this.diagramParent.dataset.timelinestyle || "strigntline",
            startelement: this.diagramParent.dataset.startelement && this.diagramParent.dataset.startelement == "false" ? false : true,
            endelement: this.diagramParent.dataset.endelement && this.diagramParent.dataset.endelement == "false" ? false : true,
            isstartenable: this.diagramParent.dataset.isstartenable && this.diagramParent.dataset.isstartenable == "false" ? false : true,
            isendenable: this.diagramParent.dataset.isendenable && this.diagramParent.dataset.isendenable == "false" ? false : true,
            position: this.diagramParent.dataset.timelineposition || "50px",
            element: this.diagramParent.dataset.timelineelement || "diagramContentNode",
        },
        nodeconnector: {
            visible: this.diagramParent.dataset.connectorvisible && this.diagramParent.dataset.connectorvisible == "false" ? false : true,
            connectorline: true,
            connectingobject: this.diagramParent.dataset.connectorconnectingobject || "diagramContentNode",
            position: this.diagramData?.properties?.connectorposition || "middle",
        },
        node: {
            position: this.nodeProps?.nodeposition || "alternate",
            positionoffset: parseInt(this.nodeProps?.nodegap || 20),
            split: false,
            splitalign: "top",
            splitorder: "order1",
            splitgap: Math.min(this.diagramParent.clientHeight * 0.2, 50),
        },
    };
    return props;
};

PositionableVTimeline.prototype.updateNodePosition = function () {
    let cusProps = this.getCustomProperties();
    let { position, positionoffset } = cusProps.node;
    let nodeHolder = this.diagramParent?.querySelector("[name='nodesHolder']");
    nodeHolder.setAttribute("data-nodeposition", position);
    this.splitLine.parentElement.style.left = "unset";
    this.splitLine.parentElement.style.width = positionoffset + "px";
    switch (position) {
        case "left":
            nodeHolder.style.marginRight = this.splitLine.parentElement.clientWidth + "px";
            this.arrDiagramNode.forEach((node, i) => {
                node.parentNode.setAttribute("data-align-position", "right");
                node.parentNode.style.maxWidth = this.diagramParent.clientWidth - this.splitLine.parentElement.clientWidth - 40 + "px";
                if (this.arrConnectorPoints[i]) this.arrConnectorPoints[i].setAttribute("data-align-position", "right");
            });
            break;
        case "right":
            nodeHolder.style.marginLeft = this.splitLine.parentElement.clientWidth + "px";
            this.arrDiagramNode.forEach((node, i) => {
                node.parentNode.setAttribute("data-align-position", "left");
                node.parentNode.style.maxWidth = this.diagramParent.clientWidth - this.splitLine.parentElement.clientWidth - 40 + "px";
                if (this.arrConnectorPoints[i]) this.arrConnectorPoints[i].setAttribute("data-align-position", "left");
            });
            break;
        case "alternate":
            this.nodeAlignAlternate();
            break;
        case "middle":
            break;
    }
    this.updateTimelinePosition(nodeHolder);
};

PositionableVTimeline.prototype.nodeAlignAlternate = function () {
    let cusProps = this.getCustomProperties();
    let { positionoffset } = cusProps.node;

    let leftX = this.splitLine.parentElement.offsetLeft;
    let rightX = this.splitLine.parentElement.offsetLeft + this.splitLine.parentElement.clientWidth;

    this.arrDiagramNode.forEach((node, index) => {
        node.parentNode.style.maxWidth = leftX - 10 + "px";
        if (index % 2 == 0) {
            node.parentNode.style.right = this.diagramParent.clientWidth - leftX + "px";
            node.parentNode.setAttribute("data-align-position", "right");
        } else {
            node.parentNode.style.left = rightX + "px";
            node.parentNode.setAttribute("data-align-position", "left");
        }
    });
};

PositionableVTimeline.prototype.clear = function () {
    this.eventManagerXY.clear();
    if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
    }
};

PositionableVTimeline.prototype.updateConnectorLine = function () {};

PositionableVTimeline.prototype.updateTimelinePosition = function (target) {
    if (!target) target = this.diagramParent?.querySelector("[name='nodesHolder']");
    if (!target) return;

    let cusProps = this.getCustomProperties();
    let { position } = cusProps.node;
    this.splitLine.parentElement.style.left = "unset";
    if (position == "alternate") return;

    let offsetLeft = position == "right" ? target.offsetLeft - this.splitLine.parentElement.clientWidth : target.offsetLeft;
    offsetLeft = position == "left" ? target.offsetLeft + target.clientWidth : offsetLeft;
    if (this.splitLine) this.splitLine.parentElement.style.left = `calc(${offsetLeft}px + var(--timelineOffset, 0px))`; //offsetLeft + "px";
};

PositionableVTimeline.prototype.slideDimensionChange = function () {
    this.setGroupWidth();
    this.setDiagramHeight();
    let cusProps = this.getCustomProperties();
    let { position } = cusProps.node;
    if (position == "alternate") return;
    this.splitLine.parentElement.style.left = "unset";
    let nodeHolder = this.diagramParent?.querySelector("[name='nodesHolder']");
    let target = nodeHolder;
    let offsetLeft = position == "right" ? target.offsetLeft - this.splitLine.parentElement.clientWidth : target.offsetLeft;
    offsetLeft = position == "left" ? target.offsetLeft + target.clientWidth : offsetLeft;
    if (this.splitLine) this.splitLine.parentElement.style.left = offsetLeft + "px";
};

function InlineVTimeline(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    PositionableVTimeline.call(this, diagramParent, diagramData, nodeProps, moodData);
}

InlineVTimeline.prototype = Object.create(PositionableVTimeline.prototype);
InlineVTimeline.prototype.constructor = InlineVTimeline;

InlineVTimeline.prototype.updateEvents = function () {
    LinearDiagram.prototype.updateEvents.call(this);
    let cusProps = this.getCustomProperties();
    let { position } = cusProps.node;
    let nodeHolder = this.diagramParent?.querySelector("[name='nodesHolder']");
    if (nodeHolder) {
        if (this.observer) {
            this.observer.disconnect();
            this.observer = null;
        }
        this.observer = new ResizeObserver((mutation) => {
            let target = mutation[0].target;
            this.updateTimelinePosition(target);
        });
        this.observer.observe(nodeHolder);
    }
};

InlineVTimeline.prototype.getCustomProperties = function () {
    let props = {
        timeline: {
            type: this.diagramParent.dataset.timelinetype || "horizontal",
            style: this.diagramParent.dataset.timelinestyle || "strigntline",
            startelement: this.diagramParent.dataset.startelement && this.diagramParent.dataset.startelement == "false" ? false : true,
            endelement: this.diagramParent.dataset.endelement && this.diagramParent.dataset.endelement == "false" ? false : true,
            isstartenable: this.diagramParent.dataset.isstartenable && this.diagramParent.dataset.isstartenable == "false" ? false : true,
            isendenable: this.diagramParent.dataset.isendenable && this.diagramParent.dataset.isendenable == "false" ? false : true,
            position: this.diagramParent.dataset.timelineposition || "50px",
            element: this.diagramParent.dataset.timelineelement || "diagramContentNode",
        },
        nodeconnector: {
            visible: this.diagramParent.dataset.connectorvisible && this.diagramParent.dataset.connectorvisible == "false" ? false : true,
            connectorline: true,
            connectingobject: this.diagramParent.dataset.connectorconnectingobject || "diagramContentNode",
        },
        node: {
            position: this.nodeProps?.nodeposition || "alternate",
            positionoffset: parseInt(this.nodeProps?.nodegap || 0),
            split: false,
            splitalign: "top",
            splitorder: "order1",
            splitgap: Math.min(this.diagramParent.clientHeight * 0.2, 50),
        },
    };
    return props;
};

InlineVTimeline.prototype.updateNodePosition = function () {
    let contentNode = this.diagramParent.querySelector("[name='contentNode']");
    let cusProps = this.getCustomProperties();
    let { position, positionoffset } = cusProps.node;
    let nodeHolder = this.diagramParent?.querySelector("[name='nodesHolder']");
    nodeHolder.setAttribute("data-nodeposition", position);
    this.splitLine.parentElement.style.left = "unset";
    this.splitLine.parentElement.style.width = positionoffset + "px";
    switch (position) {
        case "left":
            this.arrDiagramNode.forEach((node) => {
                node.parentNode.setAttribute("data-align-position", "left");
                node.parentNode.style.maxWidth = this.diagramParent.clientWidth - this.splitLine.parentElement.clientWidth - 40 + "px";
            });
            break;
        case "right":
            this.arrDiagramNode.forEach((node) => {
                node.parentNode.setAttribute("data-align-position", "right");
                node.parentNode.style.maxWidth = this.diagramParent.clientWidth - this.splitLine.parentElement.clientWidth - 40 + "px";
            });
            break;
        case "alternate":
            this.nodeAlignAlternate(contentNode);
            break;
        case "middle":
            break;
    }

    this.updateTimelinePosition(nodeHolder);
};

InlineVTimeline.prototype.nodeAlignAlternate = function (contentNode) {
    let contentWidth = contentNode?.clientWidth || 0;
    let maxwidth = this.diagramParent.clientWidth / 2;
    this.arrDiagramNode.forEach((node, index) => {
        node.parentNode.style.maxWidth = maxwidth + "px";
        if (index % 2 == 0) {
            node.parentNode.style.right = this.diagramParent.clientWidth / 2 - contentWidth / 2 + "px";
            node.parentNode.setAttribute("data-align-position", "left");
        } else {
            node.parentNode.style.left = this.diagramParent.clientWidth / 2 - contentWidth / 2 + "px";
            node.parentNode.setAttribute("data-align-position", "right");
        }
    });
};

InlineVTimeline.prototype.updateTimelinePosition = function (target) {
    let cusProps = this.getCustomProperties();
    let { positionoffset } = cusProps.node;
    let contentNode = target.querySelector("[name='contentNode']");
    let contentRect = DiagramNodeUtils.getElementRectByOffserParent(this.diagramParent, contentNode);
    let offsetLeft = contentRect.left + contentRect.width / 2 - this.splitLine.parentElement.clientWidth / 2 + positionoffset;
    if (this.splitLine) this.splitLine.parentElement.style.left = offsetLeft + "px";
};

InlineVTimeline.prototype.slideDimensionChange = function () {
    this.setGroupWidth();
    this.setDiagramHeight();
    let cusProps = this.getCustomProperties();
    let { position } = cusProps.node;
    if (position == "alternate") return;
    this.splitLine.parentElement.style.left = "unset";
    let nodeHolder = this.diagramParent?.querySelector("[name='nodesHolder']");
    let target = nodeHolder;
    this.updateTimelinePosition(target);
};

function DynamicTimeline(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    PositionableVTimeline.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.visibleNodes = [];
    this.clippedNodesIndex = 0;
}

DynamicTimeline.prototype = Object.create(PositionableVTimeline.prototype);
DynamicTimeline.prototype.constructor = DynamicTimeline;

DynamicTimeline.prototype.updateEvents = function () {
    LinearDiagram.prototype.updateEvents.call(this);
    let nodeHolder = this.diagramParent?.querySelector("[name='nodesHolder']");
    if (this.appmode != "DESIGN") return;
    if (nodeHolder) {
        if (this.observer) {
            this.observer.disconnect();
            this.observer = null;
        }

        this.observer = new ResizeObserver((mutation) => {
            let target = mutation[0].target;
            this.updateTimelinePosition(target);
        });
        this.observer.observe(nodeHolder);
    }
};

DynamicTimeline.prototype.updateSlideBasednodeHeight = function (arrNodes, height, padding, pos) {
    arrNodes.map(function (node, i) {
        let parentNode = node.getNodeParent().parentElement;
        parentNode.style.setProperty("flex", "unset", "important");
        parentNode.style.marginBottom = "";
        parentNode.style.marginTop = "";
        if (pos == "start" && i == arrNodes.length - 1) {
            parentNode.style.marginBottom = padding + "px";
        } else if (pos == "end" && i == 0) {
            parentNode.style.marginTop = padding * 2 + "px";
        } else if (pos == "mid") {
            if (i == 0) parentNode.style.marginTop = padding * 2 + "px";
            if (i == arrNodes.length - 1) parentNode.style.marginBottom = padding + "px";
        }
    });
};

DynamicTimeline.prototype.updateTimelinePosition = function (target) {
    if (!target) target = this.diagramParent?.querySelector("[name='nodesHolder']");
    if (!target) return;
    PositionableVTimeline.prototype.updateTimelinePosition.call(this, target);
    this.diagramParent.style.minHeight = `calc(100% - var(--mood-padding-top, 0px) - var(--mood-padding-bottom, 0px) - var(--timelinestartheight, 0px) - var(--timelineendheight, 0px))`;
    this.splitLine.parentElement.style.minHeight = `calc(100% - var(--mood-padding-top, 0px) - var(--mood-padding-bottom, 0px))`;
    let height = target.clientHeight + "px";
    this.diagramParent.parentElement.style.setProperty("--diagramParentHeight", height);
    this.diagramParent.parentElement.style.setProperty("--timelineHeight", height);
    this.updateConnectorPoints();
    this.updateAnimateLineHeight();
};

DynamicTimeline.prototype.setNodelWidth = function () {
    this.diagramParent.style.minHeight = `calc(100% - var(--mood-padding-top) - var(--mood-padding-bottom))`;
    this.splitLine.parentElement.style.minHeight = `calc(100% - var(--mood-padding-top) - var(--mood-padding-bottom))`;
    return 0;
};

DynamicTimeline.prototype.getCustomProperties = function () {
    let props = {
        timeline: {
            type: this.diagramParent.dataset.timelinetype || "horizontal",
            style: this.diagramParent.dataset.timelinestyle || "strigntline",
            startelement: this.diagramParent.dataset.startelement && this.diagramParent.dataset.startelement == "false" ? false : true,
            endelement: this.diagramParent.dataset.endelement && this.diagramParent.dataset.endelement == "false" ? false : true,
            isstartenable: this.diagramParent.dataset.isstartenable && this.diagramParent.dataset.isstartenable == "false" ? false : true,
            isendenable: this.diagramParent.dataset.isendenable && this.diagramParent.dataset.isendenable == "false" ? false : true,
            position: this.diagramParent.dataset.timelineposition || "50px",
            element: this.diagramParent.dataset.timelineelement || "diagramContentNode",
        },
        nodeconnector: {
            visible: this.diagramParent.dataset.connectorvisible && this.diagramParent.dataset.connectorvisible == "false" ? false : true,
            connectorline: true,
            connectingobject: this.diagramParent.dataset.connectorconnectingobject || "diagramContentNode",
            position: this.diagramData?.properties?.connectorposition || "middle",
        },
        node: {
            position: this.nodeProps?.nodeposition || "alternate",
            positionoffset: parseInt(this.nodeProps?.nodegap || 20),
            split: false,
            splitalign: "top",
            splitorder: "order1",
            splitgap: Math.min(this.diagramParent.clientHeight * 0.2, 50),
        },
    };
    return props;
};

DynamicTimeline.prototype.nodeAlignAlternate = function () {
    this.arrDiagramNode.forEach((node, index) => {
        if (index % 2 == 0) {
            node.parentNode.setAttribute("data-align-position", "right");
            if (this.arrConnectorPoints[index]) this.arrConnectorPoints[index].setAttribute("data-align-position", "right");
        } else {
            node.parentNode.setAttribute("data-align-position", "left");
            if (this.arrConnectorPoints[index]) this.arrConnectorPoints[index].setAttribute("data-align-position", "left");
        }
    });
};

DynamicTimeline.prototype.getVisibleNodes = function (arrNode, clipParent = null) {
    let parentRect = clipParent.getBoundingClientRect();
    let visibleNodes = arrNode.filter((node) => {
        let nodeRect = node.parentNode.parentElement.getBoundingClientRect();
        return nodeRect.top > parentRect.top && nodeRect.top + nodeRect.height < parentRect.top + parentRect.height;
    });
    return visibleNodes;
};

DynamicTimeline.prototype.getClippedNode = function (arrNode, clipParent = null, direction = "next") {
    let arrVisibleNodes = this.getVisibleNodes(arrNode, clipParent);
    let refNode = arrVisibleNodes[direction == "next" ? arrVisibleNodes.length - 1 : 0];
    if (!refNode) return null;
    let refNodeIndex = parseInt(refNode.parentNode.parentElement.dataset.index);
    let clippedNode = arrNode[direction == "next" ? refNodeIndex + 1 : refNodeIndex - 1];
    return clippedNode ? clippedNode.parentNode.parentElement : refNode.parentNode.parentElement;
};

DynamicTimeline.prototype.navigation = function (navigation, isAnimatable = true) {
    let clippedNode = this.getClippedNode(this.arrDiagramNode, this.diagramParent.parentElement, navigation.direction);
    if (!clippedNode) return false;
    this.totalPages = Math.ceil(this.splitLine.parentElement.offsetHeight / this.diagramParent.parentElement.clientHeight);
    let marginTop = parseInt(getComputedStyle(this.diagramParent).marginTop) || 0;

    if (navigation.direction == "next") {
        let reSpace = this.diagramParent.parentElement.scrollTop + this.diagramParent.parentElement.clientHeight - this.diagramParent.parentElement.scrollHeight;
        if (reSpace >= -5 && reSpace <= 5) return false; //move to next slide
        let scrollValue = clippedNode.offsetTop + marginTop - 50;
        this.diagramParent.parentElement.scrollTo({ top: scrollValue, behavior: isAnimatable ? "smooth" : "auto" });

        //below two lines are added to fix the export pdf issue
        this.diagramParent.dataset.exporttop = -this.diagramParent.parentElement.scrollTop + "px";
        this.splitLine.parentElement.dataset.exporttop = -this.diagramParent.parentElement.scrollTop + "px";
    } else {
        let sTop = this.diagramParent.parentElement.scrollTop;
        if (sTop >= -5 && sTop <= 5) return false;
        let scrollValue = clippedNode.offsetTop + clippedNode.clientHeight - this.diagramParent.parentElement.clientHeight + marginTop + 50;
        this.diagramParent.parentElement.scrollTo({ top: scrollValue, behavior: isAnimatable ? "smooth" : "auto" });
    }
    // this.animationCompleteCallback?.fn?.(this.animationCompleteCallback.params);
    return true;
};

DynamicTimeline.prototype.gotoPage = function (pageIndex, isAnimate = false, isNext = false) {};

DynamicTimeline.prototype.setupAnimation = function (animationType, callback) {
    LinearVerticalTimeline.prototype.setupAnimation.call(this, animationType, callback);
    this.currentPageIndex = this.animationType == "none" ? 0 : 1;
};

DynamicTimeline.prototype.playNext = function (index, isAllAtOnce = false) {
    this.updateAnimationPath("show");
    if (this.arrDiagramNode.length == this.animationIndex) {
        let returnValue = this.navigation({ direction: "next" }, this.animationFactor != 0);
        if (this.moodData.animationData.isHideAnimation && !returnValue) {
            this.diagramParent.style.transition = "all 0.2s " + this.cubicPath;
            this.diagramParent.style.opacity = 0;
            this.splitLine.parentElement.style.transition = "all 0.2s " + this.cubicPath;
            this.splitLine.parentElement.style.opacity = 0;
        }
        if (this.animationCompleteCallback && returnValue) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return returnValue;
    }

    this.diagramParent.style.opacity = 1;
    this.splitLine.parentElement.style.opacity = 1;

    this.isForwardAnimation = true;
    let delay = 0;
    if (this.startElement.style.transform == "scale(0)" && this.isStartEnable) {
        this.startElement.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        this.startElement.style.transform = "scale(1)";
        delay = delay + 0.1;
    }

    let nodeItem = this.arrDiagramNode[this.animationIndex].nodeGroup;
    let connector = this.arrConnectorPoints[this.animationIndex];

    if ((this.animationIndex > 0 && !this.isStartEnable) || this.isStartEnable) {
        this.animationLine.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        let animationLineHeight = connector.offsetTop + connector.clientHeight / 2 - this.animationLine.offsetTop;
        animationLineHeight = animationLineHeight < 0 ? 0 : animationLineHeight;
        this.animationLine.style.height = animationLineHeight + "px";

        let parentRect = this.diagramParent.parentElement.getBoundingClientRect();
        let nodeRect = nodeItem.parentElement.parentElement.getBoundingClientRect();
        let isInside = nodeRect.top + nodeRect.height < parentRect.top + parentRect.height;
        if (!isInside) {
            this.navigation({ direction: "next" }, this.animationFactor != 0);
        }
    }

    delay = this.showAnimation(nodeItem.parentElement, connector, delay * this.animationFactor, this.animationIndex);
    if (this.animationIndex == this.arrDiagramNode.length - 1 && (this.moodData.animationData.multislideAnimation || this.endElement.style.transform == "scale(0)") && this.isEndEnable) {
        let height = this.isStartEnable ? "100%" : "calc(100% - " + this.animationLine.offsetTop + "px)";
        setTimeout(() => {
            this.animationLine.style.height = height;
        }, delay * 1000);

        this.endElement.style.transition = "all " + 0.5 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        this.endElement.style.transform = "scale(1)";
    }

    setTimeout(() => {
        if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, delay * 1000);
    this.animationIndex += 1;

    return true;
};

DynamicTimeline.prototype.playPrevious = function (index, isAllAtOnce = false) {
    this.updateAnimationPath("hide");
    if (this.animationIndex == 0 && this.startElement.style.transform == "scale(0)") {
        this.diagramParent.style.transition = "all 0.2s " + this.cubicPath;
        this.diagramParent.style.opacity = 0;
        this.splitLine.parentElement.style.transition = "all 0.2s " + this.cubicPath;
        this.splitLine.parentElement.style.opacity = 0;
        this.currentPageIndex = 0;
        return this.navigation({ direction: "previous" }, this.animationFactor != 0);
        return false;
    }

    this.diagramParent.style.opacity = 1;
    this.splitLine.parentElement.style.opacity = 1;

    if (this.isForwardAnimation) {
        this.isForwardAnimation = false;
        this.animationIndex -= 1;
    }

    if (this.animationIndex == 1) this.navigation({ direction: "previous" }, this.animationFactor != 0);

    this.isReversAnimation = true;
    let delay = 0;
    if (this.endElement.style.transform == "scale(1)") {
        this.endElement.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        this.endElement.style.transform = "scale(0)";
        let connector = this.arrConnectorPoints[this.animationIndex];
        this.animationLine.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.3;
        let animationLineHeight = connector.offsetTop + connector.clientHeight / 2 - this.animationLine.offsetTop;
        animationLineHeight = animationLineHeight < 0 ? 0 : animationLineHeight;
        this.animationLine.style.height = animationLineHeight + "px";

        setTimeout(() => {
            this.playPrevious();
        }, delay * this.animationFactor * 1000);
        return true;
    }

    let nodeItem = this.arrDiagramNode[this.animationIndex].nodeGroup;
    let connector = this.arrConnectorPoints[this.animationIndex];
    delay = this.hideAnimation(nodeItem.parentElement, connector, delay * this.animationFactor, this.animationFactor == 1);
    if (this.animationIndex == 0 && this.endElement.style.transform == "scale(1)") {
        this.animationLine.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        this.animationLine.style.height = "0px";
        this.endElement.style.transform = "scale(0)";
    }
    this.animationIndex -= 1;
    if (this.animationIndex >= 0) {
        let connector = this.arrConnectorPoints[this.animationIndex];
        this.animationLine.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        let animationLineHeight = connector.offsetTop + connector.clientHeight / 2 - this.animationLine.offsetTop;
        animationLineHeight = animationLineHeight < 0 ? 0 : animationLineHeight;
        this.animationLine.style.height = animationLineHeight + "px";

        let previousIndex = this.animationIndex > 0 ? this.animationIndex : 0;
        let prevoiuseNode = this.arrDiagramNode[previousIndex].nodeGroup;
        let parentRect = this.diagramParent.parentElement.getBoundingClientRect();
        let nodeRect = prevoiuseNode.parentElement.parentElement.getBoundingClientRect();
        let isInside = nodeRect.top > parentRect.top;
        if (!isInside) {
            this.navigation({ direction: "previous" }, this.animationFactor != 0);
        }
    }
    if (this.animationIndex < 0) {
        this.animationLine.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        this.animationLine.style.height = "0px";
        this.startElement.style.transition = "all " + 0.2 * this.animationFactor + "s " + delay * this.animationFactor + "s " + this.cubicPath;
        delay = delay + 0.1;
        this.startElement.style.transform = "scale(0)";
    }
    this.animationIndex = this.animationIndex < 0 ? 0 : this.animationIndex;

    setTimeout(() => {
        if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, delay * 1000);
    return true;
};

DynamicTimeline.prototype.playAllAtOnce = function () {
    if (this.exit) {
        let returnValue = this.navigation({ direction: "next" }, this.animationFactor != 0);
        if (returnValue) this.animationCompleteCallback.fn?.(this.animationCompleteCallback.params);
        return returnValue;
    }
    if (this.allAtOnceIndex > 0) this.navigation({ direction: "next" }, this.animationFactor != 0);
    setTimeout(() => {
        let arrNode = this.getVisibleNodes(this.arrDiagramNode, this.diagramParent.parentElement);
        let targetNode = arrNode[arrNode.length - 1].parentNode.parentElement;
        let targetNodeIndex = parseInt(targetNode.dataset.index);
        this.itemPerPage = targetNodeIndex - this.animationIndex + 1;
        if (this.itemPerPage == 0 || targetNodeIndex + 1 == this.animationIndex) {
            this.animationCompleteCallback.fn?.(this.animationCompleteCallback.params);
            this.exit = true;
            return false;
        }
        this.playNext(0, true);
        this.animateItemCount = 1;
        if (this.itemPerPage > 1) {
            this.exitPrev = false;
            var interval = setInterval(() => {
                this.playNext(0, true);
                this.animateItemCount += 1;
                if (this.animationCompleteCallback && this.animateItemCount == this.itemPerPage) {
                    this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
                    clearInterval(interval);
                }
                if (targetNodeIndex + 1 == this.arrDiagramNode.length) this.exit = true;
            }, 1000 * this.animationFactor);
        } else {
            this.exit = true;
            this.animationCompleteCallback.fn?.(this.animationCompleteCallback.params);
        }
    }, 700 * this.animationFactor);

    this.allAtOnceIndex += 1;
    return true;
};

DynamicTimeline.prototype.playAllAtOnceReverse = function () {
    if (this.exitPrev) {
        // if (this.startElement.style.transform == "scale(1)") {
        //     this.playPrevious(0, true);
        //     return true;
        // }
        // return this.navigation({ direction: "previous" }, this.animationFactor != 0);
        return false;
    }
    let arrNode = this.getVisibleNodes(this.arrDiagramNode, this.diagramParent.parentElement);
    let targetNode = arrNode[arrNode.length - 1].parentNode.parentElement;
    let targetNodeIndex = parseInt(targetNode.dataset.index);
    console.log("targetNodeIndex - ", targetNodeIndex, " animationIndex - ", this.animateItemCount);
    this.itemPerPage = arrNode.length;

    this.playPrevious(0, true);
    this.animateItemCount = 1;
    if (this.itemPerPage > 1) {
        this.exit = false;
        var interval = setInterval(() => {
            this.playPrevious(0, true);
            this.animateItemCount += 1;
            if (this.animationCompleteCallback && this.animateItemCount == this.itemPerPage) {
                this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
                if (this.animationIndex <= 0) this.exitPrev = true;
                else this.navigation({ direction: "previous" }, this.animationFactor != 0);
                clearInterval(interval);
            }
        }, 1200 * this.animationFactor);
    } else {
        this.exitPrev = true;
        this.animationCompleteCallback.fn?.(this.animationCompleteCallback.params);
    }

    this.allAtOnceIndex -= 1;
    return true;
};

DynamicTimeline.prototype.setDiagramHeight = function () {
    this.startElementPadding = this.isStartEnable ? 0 : 50;
    this.endElementPadding = this.isEndEnable ? 0 : 50;
    this.startElement.style.display = this.isStartEnable ? "flex" : "none";
    this.endElement.style.display = this.isEndEnable ? "flex" : "none";

    this.updateTimelineElements();
    //below block of code is to set the animation line width dependes on the start and end element
    this.updateAnimateLineHeight();
};

DynamicTimeline.prototype.updateAnimateLineHeight = function () {
    let arrPoints = Array.from(this.splitLine.querySelectorAll("[id='connectorpoint']"));
    let startPoint = arrPoints.at(0);
    let endPoint = arrPoints.at(-1);
    let startRect = DiagramNodeUtils.getOffsetRectByParent(this.splitLine, startPoint);
    let endRect = DiagramNodeUtils.getOffsetRectByParent(this.splitLine, endPoint);

    this.animationLine.style.height = "100%";

    if (this.isStartEnable) {
        this.animationLine.style.top = "0px";
    } else {
        this.animationLine.style.top = startRect.y + startRect.height / 2 + "px";
        this.animationLine.style.height = `${endRect.y - startRect.y}px`;
    }

    if (this.isEndEnable) {
        this.animationLine.style.height = this.isStartEnable ? "100%" : "calc(100% - " + (startRect.y + startRect.height / 2) + "px)";
    } else {
        if (!this.isStartEnable) {
            this.animationLine.style.height = `${endRect.y - startRect.y}px`;
        } else {
            let diff = Math.abs(this.splitLine.clientHeight - endRect.y);
            this.animationLine.style.height = this.animationLine.clientHeight - diff + "px";
        }
    }
};

DynamicTimeline.prototype.resetHolderWidth = function () {
    PositionableVTimeline.prototype.resetHolderWidth.call(this);
    this.updateTimelinePosition();
};

DynamicTimeline.prototype.setupNavigation = function (navigationContent) {
    return {};
};

//

function BarTimelineVertical(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    PositionableVTimeline.call(this, diagramParent, diagramData, nodeProps, moodData);
}

BarTimelineVertical.prototype = Object.create(PositionableVTimeline.prototype);
BarTimelineVertical.prototype.constructor = BarTimelineVertical;

BarTimelineVertical.prototype.updateEvents = function () {
    LinearDiagram.prototype.updateEvents.call(this);
    let nodeHolder = this.diagramParent?.querySelector("[name='nodesHolder']");
    if (nodeHolder) {
        if (this.observer) {
            this.observer.disconnect();
            this.observer = null;
        }

        this.observer = new ResizeObserver((mutation) => {
            let target = mutation[0].target;
            this.updateTimelinePosition(target);
        });
        this.observer.observe(nodeHolder);
    }
};

BarTimelineVertical.prototype.drawTimeline = function () {
    let timeline = this.diagramParent.parentElement.querySelector("[data-id='timeline']");
    timeline?.remove();
    LinearVerticalTimeline.prototype.drawTimeline.call(this);
    timeline = this.diagramParent.parentElement.querySelector("[data-id='timeline']");
    timeline.className = "timelinebararrow-vertical" + " " + (this.nodeProps?.timelineclass || "");
};

BarTimelineVertical.prototype.getCustomProperties = function () {
    let props = {
        timeline: {
            type: this.diagramParent.dataset.timelinetype || "horizontal",
            style: this.diagramParent.dataset.timelinestyle || "strigntline",
            startelement: this.diagramParent.dataset.startelement && this.diagramParent.dataset.startelement == "false" ? false : true,
            endelement: this.diagramParent.dataset.endelement && this.diagramParent.dataset.endelement == "false" ? false : true,
            isstartenable: this.diagramParent.dataset.isstartenable && this.diagramParent.dataset.isstartenable == "false" ? false : true,
            isendenable: this.diagramParent.dataset.isendenable && this.diagramParent.dataset.isendenable == "false" ? false : true,
            position: this.diagramParent.dataset.timelineposition || "50px",
            element: this.diagramParent.dataset.timelineelement || "diagramContentNode",
        },
        nodeconnector: {
            visible: this.diagramParent.dataset.connectorvisible && this.diagramParent.dataset.connectorvisible == "false" ? false : true,
            connectorline: true,
            connectingobject: this.diagramParent.dataset.connectorconnectingobject || "diagramContentNode",
            position: this.diagramData?.properties?.connectorposition || "middle",
        },
        node: {
            position: this.nodeProps?.nodeposition || "alternate",
            positionoffset: parseInt(this.nodeProps?.nodegap || 20),
            split: false,
            splitalign: "top",
            splitorder: "order1",
            splitgap: Math.min(this.diagramParent.clientHeight * 0.2, 50),
        },
    };
    return props;
};

BarTimelineVertical.prototype.updateConnectorPoints = function () {
    if (this.splitLine == null || this.getCustomProperties().nodeconnector.visible == false) return;

    while (this.arrConnectorPoints.length < this.arrDiagramNode.length) {
        let connectorPoint = document.createElement("div");
        connectorPoint.className = "connectorpoint theme-border-color";
        connectorPoint.id = "connectorpoint";
        this.splitLine.appendChild(connectorPoint);

        if (this.getCustomProperties().nodeconnector.connectorline == true) {
            let connectorLine = document.createElement("div");
            connectorLine.className = "connectorline";
            connectorLine.id = "connectorline";
            connectorPoint.appendChild(connectorLine);

            let svg = this.createSvgElement("svg", { style: "width:100%; height:100%; position:absolute;" });
            connectorLine.appendChild(svg);
            let path = this.createSvgElement("path", {});
            path.setAttribute("stroke", "var(--timeline-stroke-color)");
            path.setAttribute("stroke-dasharray", "4");
            svg.appendChild(path);
        }

        this.arrConnectorPoints.push(connectorPoint);
    }

    while (this.arrConnectorPoints.length > this.arrDiagramNode.length) {
        let point = this.arrConnectorPoints[this.arrConnectorPoints.length - 1];
        point.parentElement.removeChild(point);
        this.arrConnectorPoints.pop();
    }

    let connectorPosition = this.getCustomProperties().nodeconnector.position || "middle";
    let arrPoints = this.splitLine.querySelectorAll("[id='connectorpoint']");
    let margin = 0;
    this.arrDiagramNode.map(
        function (node, i) {
            let point = arrPoints[i];
            let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
            let nodeRect = DiagramNodeUtils.getOffsetRectByParent(nodeHolder, node.nodeGroup);

            let centerY = nodeRect.y;
            centerY = centerY;
            if (connectorPosition == "middle") {
                centerY = nodeRect.y + nodeRect.height / 2;
                centerY = centerY - point.offsetHeight / 2;
            } else if (connectorPosition == "right") {
                centerY = nodeRect.y + nodeRect.height;
                centerY = centerY - point.offsetHeight;
            }
            if (point) point.style.top = centerY + "px";

            point.style.position = "relative";
            if (node.parentNode.parentElement.style.marginLeft != "") {
                margin = parseInt(node.parentNode.parentElement.style.marginLeft);
                point.style.height = node.parentNode.parentElement.clientHeight + margin + "px";
                point.firstElementChild.style.left = point.clientHeight / 2 - point.firstElementChild.clientHeight / 2 + margin / 2 + "px";
            } else if (node.parentNode.parentElement.style.marginRight != "") {
                margin = parseInt(node.parentNode.parentElement.style.marginRight);
                point.style.height = node.parentNode.parentElement.clientHeight + margin + "px";
                point.firstElementChild.style.left = point.clientHeight / 2 - point.firstElementChild.clientHeight / 2 - margin / 2 + "px";
            } else {
                point.style.height = node.parentNode.parentElement.clientHeight + margin + "px";
            }
        }.bind(this)
    );
};

/**
 * Author:    Krishna
 * Created:   5 Jun 2020
 *
 * (c) Copyright by Krishna.
 **/

"use strict";

function PyramidHorizontalFlow(diagramParent, diagramData, nodeProps, moodData = {}) {
    SimpleLinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "pyramidhorizontalflow";
    this.pyramidOffsetTop = 40;
    this.topArroelineColorClass = "tertiary-";

    // let slide = document.querySelector(".clsSlide");
    // if (slide) slide.classList.remove("commonLayout");
}

PyramidHorizontalFlow.prototype = Object.create(SimpleLinearDiagram.prototype);
PyramidHorizontalFlow.prototype.constructor = PyramidHorizontalFlow;

PyramidHorizontalFlow.prototype.createElements = function() {
    SimpleLinearDiagram.prototype.createElements.call(this);

    let nodeparent = this.diagramParent.querySelector("[name='nodesHolder']");
    let holder = document.createElement("div");
    holder.className = "pyramidholder";
    holder.id = "pyramidholder";
    nodeparent.appendChild(holder);
    nodeparent.style.setProperty("--pyramidwidth", nodeparent.clientWidth+"px");
    nodeparent.style.setProperty("--pyramidheight", (nodeparent.clientHeight * 0.6)+"px");
    nodeparent.style.setProperty("--pyramidoffsettop", this.pyramidOffsetTop+"px");

    if (holder.clientWidth == 0) return;
    this.drawPyramid(holder);
    this.setupInputArrow();
    this.setupInputOutText();
};

PyramidHorizontalFlow.prototype.slideDimensionChange = function() {
    let holder = this.diagramParent.querySelector("[id='pyramidholder']");
    if (holder) this.drawPyramid(holder);
};

PyramidHorizontalFlow.prototype.addNode = function() {
    SimpleLinearDiagram.prototype.addNode.call(this);
    let holder = this.diagramParent.querySelector("[id='pyramidholder']");
    if (holder) this.drawPyramid(holder);
};

PyramidHorizontalFlow.prototype.deleteNode = function(targetIndex) {
    SimpleLinearDiagram.prototype.deleteNode.call(this, targetIndex);
    let holder = this.diagramParent.querySelector("[id='pyramidholder']");
    if (holder) this.drawPyramid(holder);
};

PyramidHorizontalFlow.prototype.drawPyramid = function(holderDiv) {
    let oldSvg = holderDiv.querySelector("[id='pyramidsvg']");
    if (oldSvg) holderDiv.removeChild(oldSvg);

    let svg = DiagramNodeUtils.createSVGElement("svg");
    DiagramNodeUtils.assignSVGNodeAttributes(svg, { class: "pyramidsvg", id: "pyramidsvg", width: holderDiv.clientWidth, height: holderDiv.clientHeight });
    holderDiv.appendChild(svg);

    let arrShapePoints = this.getTriangleShapePoints(svg, false, 0);

    arrShapePoints.map(
        function(arrPoints, i) {
            let strD = this.getPathString(arrPoints);
            let path = DiagramNodeUtils.createSVGElement("path");
            let group = DiagramNodeUtils.createSVGElement("g");
            let colorIndex = arrShapePoints.length - i;
            group.setAttribute("id", "pyramid-point" + colorIndex);
            DiagramNodeUtils.assignSVGNodeAttributes(path, { d: strD, class: "accent" + colorIndex + "-fill shapepath moodanimation", "data-animation": "itemshape" });
            group.appendChild(path);
            svg.appendChild(group);
        }.bind(this)
    );

    this.updateFrame();
    this.diagramParent.style.setProperty("--iconnodewidth", "70%");
    this.diagramParent.style.setProperty("--iconnodeheight", "70%");
};

PyramidHorizontalFlow.prototype.getTriangleShapePoints = function(svg, isInverse = false, funnelGap = 0) {
    let arrLines = Array.from(svg.querySelectorAll("line"));
    arrLines.map((line) => svg.removeChild(line));

    let svgRect = { x: 0, y: 0, width: svg.parentElement.offsetWidth, height: svg.parentElement.offsetHeight };
    let l1 = this.createLine({ x: svgRect.width / 2 - funnelGap / 2, y: 0 }, { x: 0, y: svgRect.height });
    let l2 = this.createLine({ x: svgRect.width / 2 + funnelGap / 2, y: 0 }, { x: svgRect.width, y: svgRect.height });
    let toplineOffset = 20;
    let l3 = this.createLine({ x: 0, y: -toplineOffset }, { x: svgRect.width, y: svgRect.height / 2 - toplineOffset });
    l3.setAttribute("class", this.topArroelineColorClass + "stroke toparrowline moodanimation");
    l3.setAttribute("data-animation", "itemshape");
    this.createMarker(svg, l3);

    l1 = this.createLine({ x: 0, y: 0 }, { x: svgRect.width, y: svgRect.height / 2 });
    l2 = this.createLine({ x: 0, y: svgRect.height }, { x: svgRect.width, y: svgRect.height / 2 });

    if (isInverse) {
        l1 = this.createLine({ x: 0, y: 0 }, { x: svgRect.width / 2 - funnelGap / 2, y: svgRect.height });
        l2 = this.createLine({ x: svgRect.width, y: 0 }, { x: svgRect.width / 2 + funnelGap / 2, y: svgRect.height });
    }

    svg.appendChild(l1);
    svg.appendChild(l2);
    svg.appendChild(l3);

    let count = this.arrDiagramNode.length;
    let nodeHeight = svgRect.height / count;
    nodeHeight = svgRect.width / count;
    let arrNodeShapePoints = [];
    for (var i = count - 1; i >= 0; i--) {
        let arrPathPoints = [];
        let line = this.createLine({ x: 0, y: nodeHeight * i }, { x: svgRect.width, y: nodeHeight * i });
        line = this.createLine({ x: nodeHeight * i, y: 0 }, { x: nodeHeight * i, y: svgRect.height });
        svg.appendChild(line);

        if (i == count - 1) {
            arrPathPoints.push({ x: svgRect.width, y: svgRect.height / 2 });
            arrPathPoints.push({ x: svgRect.width, y: svgRect.height / 2 });
            const point3 = this.checkIntersection(
                l2.x1.baseVal.value,
                l2.y1.baseVal.value,
                l2.x2.baseVal.value,
                l2.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point3.x, y: point3.y });
            const point4 = this.checkIntersection(
                l1.x1.baseVal.value,
                l1.y1.baseVal.value,
                l1.x2.baseVal.value,
                l1.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point4.x, y: point4.y });
        } else {
            let arrPoints = arrNodeShapePoints[arrNodeShapePoints.length - 1];
            arrPathPoints.push(JSON.parse(JSON.stringify(arrPoints[3])));
            arrPathPoints.push(JSON.parse(JSON.stringify(arrPoints[2])));
            const point3 = this.checkIntersection(
                l2.x1.baseVal.value,
                l2.y1.baseVal.value,
                l2.x2.baseVal.value,
                l2.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point3.x, y: point3.y });
            const point4 = this.checkIntersection(
                l1.x1.baseVal.value,
                l1.y1.baseVal.value,
                l1.x2.baseVal.value,
                l1.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point4.x, y: point4.y });
        }
        svg.removeChild(line);
        arrNodeShapePoints.push(arrPathPoints);
    }
    svg.removeChild(l1);
    svg.removeChild(l2);
    return arrNodeShapePoints;
};

PyramidHorizontalFlow.prototype.createLine = function(startPoint, endPoint) {
    let line = DiagramNodeUtils.createSVGElement("line");
    DiagramNodeUtils.assignSVGNodeAttributes(line, { x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y, stroke: "none", "stroke-width": 2 });
    return line;
};

PyramidHorizontalFlow.prototype.checkIntersection = function(x1, y1, x2, y2, x3, y3, x4, y4) {
    var ua,
        ub,
        denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    if (denom == 0) {
        return null;
    }
    ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
    ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
    return {
        x: x1 + ua * (x2 - x1),
        y: y1 + ua * (y2 - y1),
        seg1: ua >= 0 && ua <= 1,
        seg2: ub >= 0 && ub <= 1,
    };
};

PyramidHorizontalFlow.prototype.getPathString = function(arrPoints) {
    let pointString = "";
    arrPoints.map((point, i) => {
        let pathComponent = i == 0 ? "M" : "L";
        pointString = pointString + (i == 0 ? "" + pathComponent : " " + pathComponent) + point.x + "," + point.y;
    });
    return pointString + " Z";
};

PyramidHorizontalFlow.prototype.updateFrame = function() {
    let pyramidHolder = this.diagramParent.querySelector("[id='pyramidholder']");
    let arrPaths = Array.from(pyramidHolder.querySelectorAll("path")).reverse();

    arrPaths.map(
        function(path, i) {
            let node = this.arrDiagramNode[i];
            if (node) {
                let nodeParent = this.arrDiagramNode[i].getNodeParent();
                let groupNode = nodeParent.querySelector("[data-name='nodeGroup']");
                if (groupNode) {
                    let pathRect = path.getBBox();
                    let maxHeight = this.diagramParent.clientHeight - (this.pyramidOffsetTop + pathRect.y + pathRect.height) + "px";
                    groupNode.style.setProperty("margin-top", pathRect.y + pathRect.height + this.pyramidOffsetTop + 10 + "px");
                    // groupNode.style.setProperty("max-height", maxHeight);
                    if (i == 0) this.diagramParent.style.setProperty("--groupnodemaxheight", maxHeight);
                }
            }
        }.bind(this)
    );
};

PyramidHorizontalFlow.prototype.createMarker = function(svg, line) {
    let defs = svg.querySelector("defs");
    if (!defs) {
        defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        svg.appendChild(defs);
    }

    let marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
    let marker1randomId = Math.random().toString();
    let refy = this.getArrowScale() * 6;
    let refx = this.getArrowScale() * 6;
    marker.setAttribute("id", marker1randomId);
    marker.setAttribute("markerWidth", "12");
    marker.setAttribute("markerHeight", "12");
    marker.setAttribute("refX", refx);
    marker.setAttribute("refY", refy);
    marker.setAttribute("orient", "auto");
    marker.innerHTML = '<polygon points="0 0 0 12 8 5.5 0 0"></polygon>';
    marker.firstElementChild.setAttribute("style", "transform: scale(" + this.getArrowScale() + ")");
    marker.firstElementChild.setAttribute("class", this.topArroelineColorClass + "fill");

    let arrMarker = Array.from(defs.querySelectorAll("marker"));
    arrMarker.map((marker) => {
        marker.parentElement.removeChild(marker);
    });

    defs.appendChild(marker);
    line.setAttribute("marker-end", "url(#" + marker1randomId + ")");
};

PyramidHorizontalFlow.prototype.getArrowScale = function() {
    return 0.6;
};

PyramidHorizontalFlow.prototype.createArrow = function(parent) {
    let heightOffset = 10;
    let arrowHeadOffset = 30;

    let div = document.createElement("div");
    div.className = "arrowHolder moodanimation";
    div.setAttribute("data-animation", "itemshape");
    parent.appendChild(div);

    let point1 = { x: 0, y: div.clientHeight / 2 - heightOffset };
    let point2 = { x: div.clientWidth - arrowHeadOffset, y: div.clientHeight / 2 - heightOffset };
    let point3 = { x: point2.x, y: 0 };
    let point4 = { x: div.clientWidth, y: div.clientHeight / 2 };
    let point5 = { x: point2.x, y: div.clientHeight };
    let point6 = { x: point2.x, y: div.clientHeight / 2 + heightOffset };
    let point7 = { x: 0, y: point6.y };
    let arrArrowPoints = [point1, point2, point3, point4, point5, point6, point7];
    let d = this.getPathString(arrArrowPoints);

    let svg = DiagramNodeUtils.createSVGElement("svg");
    svg.setAttribute("class", "arrowsvg");
    div.appendChild(svg);
    let arrowPath = DiagramNodeUtils.createSVGElement("path");
    arrowPath.setAttribute("d", d);
    svg.appendChild(arrowPath);
};

PyramidHorizontalFlow.prototype.setupInputArrow = function() {
    let arrowHolderParent = document.createElement("div");
    arrowHolderParent.className = "arrowparentholder";
    arrowHolderParent.id = "arrowparentholder";
    this.diagramParent.appendChild(arrowHolderParent);

    let nodeparent = this.diagramParent.querySelector("[name='nodesHolder']");
    let pyramidholder = nodeparent.querySelector("[id='pyramidholder']");
    arrowHolderParent.style.top = pyramidholder.offsetTop + "px";
    arrowHolderParent.style.left = nodeparent.offsetLeft - arrowHolderParent.clientWidth - 10 + "px";
    arrowHolderParent.style.height = pyramidholder.clientHeight + "px";

    for (var i = 0; i < 3; i++) {
        this.createArrow(arrowHolderParent);
    }
};

PyramidHorizontalFlow.prototype.setupInputOutText = function() {
    let nodeParent = this.diagramParent.querySelector("[name='nodesHolder']");
    let arrowParentHolder = this.diagramParent.querySelector("[id='arrowparentholder']");

    let inputTextParent = document.createElement("div");
    inputTextParent.className = "inputtextparent";
    this.diagramParent.appendChild(inputTextParent);

    let inputText = document.createElement("div");
    inputText.className = "inputText h5 moodanimation";
    inputText.setAttribute("data-animation", "primarytext");
    inputText.id = "inputText";
    inputText.contentEditable = true;
    let text = this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.inputtext ? this.diagramData.properties.customproperties.inputtext : "";
    inputText.innerText = text;
    inputText.setAttribute("data-prompt-text", "Input Text");
    inputTextParent.appendChild(inputText);

    let outputTextParent = document.createElement("div");
    outputTextParent.className = "outputtextparent";
    this.diagramParent.appendChild(outputTextParent);

    let outputText = document.createElement("div");
    outputText.className = "outputText h5 moodanimation";
    outputText.setAttribute("data-animation", "primarytext");
    outputText.id = "outputText";
    outputText.contentEditable = true;
    text = this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.outputtext ? this.diagramData.properties.customproperties.inputtext : "";
    outputText.innerText = text;
    outputText.setAttribute("data-prompt-text", "Output Text");
    outputTextParent.appendChild(outputText);

    outputTextParent.style.top = arrowParentHolder.offsetTop + "px";
    outputTextParent.style.height = arrowParentHolder.clientHeight + "px";
    outputTextParent.style.left = nodeParent.offsetLeft + nodeParent.clientWidth + "px";
    outputTextParent.style.width = this.diagramParent.clientWidth - (nodeParent.offsetLeft + nodeParent.clientWidth) + "px";

    inputTextParent.style.left = "0px";
    inputTextParent.style.top = arrowParentHolder.offsetTop + "px";
    inputTextParent.style.height = arrowParentHolder.clientHeight + "px";
    inputTextParent.style.width = arrowParentHolder.offsetLeft + "px";
};

PyramidHorizontalFlow.prototype.updateEvents = function() {
    SimpleLinearDiagram.prototype.updateEvents.call(this);

    let inputText = this.diagramParent.querySelector("[id='inputText']");
    let outputText = this.diagramParent.querySelector("[id='outputText']");

    if (inputText && outputText) {
        this.eventManagerXY.addEvent(inputText, "focusout", this.defaultFoucsOut);
        this.eventManagerXY.addEvent(outputText, "focusout", this.defaultFoucsOut);
    }
};

PyramidHorizontalFlow.prototype.defaultFoucsOut = function(event) {
    if (event.target.innerText == "") event.target.innerHTML = "";
    let typedText = event.target.dataset && event.target.dataset.oldtext ? event.target.dataset.oldtext : "";
    if (event.target.innerText != typedText && this.appmode != "PRESENT") {
        this.eventManagerXY.dispatch("focusout", event.target);
        event.target.dataset.oldtext = event.target.innerHTML;
        this.updatePropsCallBack();
    }
};

PyramidHorizontalFlow.prototype.getProperties = function(defaultproperties = {}) {
    let properties = SimpleLinearDiagram.prototype.getProperties.call(this, defaultproperties);
    properties.customproperties = this.getInputOutTextData();
    return properties;
};

PyramidHorizontalFlow.prototype.updateCustomProperties = function(customproperties) {
    let pyramidProps = customproperties ? customproperties : {};
    this.diagramParent.setAttribute("data-inputtext", pyramidProps.inputtext || "");
    this.diagramParent.setAttribute("data-outputtext", pyramidProps.inputtext || "");
    let inputText = this.diagramParent.querySelector("[id='inputText']");
};

PyramidHorizontalFlow.prototype.getInputOutTextData = function() {
    let cusProperties = {};
    let inputText = this.diagramParent.querySelector("[id='inputText']");
    let outputText = this.diagramParent.querySelector("[id='outputText']");

    if (inputText) {
        cusProperties.inputtext = inputText.innerText;
    }
    if (outputText) {
        cusProperties.outputtext = outputText.inputTextParent;
    }
    return cusProperties;
};

/**
 * Author:    Krishna
 * Created:   9 Jun 2020
 *
 * (c) Copyright by Krishna.
 **/

"use strict";

function FlowDiagram(diagramParent, diagramData, nodeProps, moodData = {}) {
    SimpleLinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "flowDiagram";
    this.topArroelineColorClass = "tertiary-";
    this.yPosition = this.diagramParent.clientHeight * 0.5;
    this.arrCommonNodes = [];
    this.isRenderComplete = false;

    this.diagramParent.parentElement.setAttribute("data-allowdefaultanimation", "true");
    // let slide = document.querySelector(".clsSlide");
    // if (slide) slide.classList.remove("commonLayout");
}

FlowDiagram.prototype = Object.create(SimpleLinearDiagram.prototype);
FlowDiagram.prototype.constructor = FlowDiagram;

FlowDiagram.prototype.createElements = function () {
    SimpleLinearDiagram.prototype.createElements.call(this);

    let nodeparent = this.diagramParent.querySelector("[name='nodesHolder']");
    let holder = document.createElement("div");
    holder.className = "svgHolder";
    holder.id = "svgHolder";
    this.diagramParent.appendChild(holder);
    nodeparent.style.setProperty("--svgholderwidth", nodeparent.clientWidth + "px");
    nodeparent.style.setProperty("--svgholderheight", nodeparent.clientHeight * 0.6 + "px");

    this.drawSvgSetup(holder);
    this.setupInputOutContent();
    this.isRenderComplete = true;
    this.diagramRenderComplete();
};

FlowDiagram.prototype.diagramRenderComplete = function () {
    if (!this.isRenderComplete) return;
    LinearDiagram.prototype.diagramRenderComplete.call(this);
};

FlowDiagram.prototype.addNode = function (nodeJSON, index, isFromUndo = false) {
    SimpleLinearDiagram.prototype.addNode.call(this, nodeJSON, index, isFromUndo);
    let holder = this.diagramParent.querySelector("[id='svgHolder']");
    if (holder) this.drawSvgSetup(holder);
};

FlowDiagram.prototype.deleteNode = function (targetIndex) {
    SimpleLinearDiagram.prototype.deleteNode.call(this, targetIndex);
    let holder = this.diagramParent.querySelector("[id='svgHolder']");
    if (holder) this.drawSvgSetup(holder);
};

FlowDiagram.prototype.drawSvgSetup = function (holderDiv) {
    this.yPosition = this.diagramParent.clientHeight * 0.5;
    let nodeparent = this.diagramParent.querySelector("[name='nodesHolder']");
    nodeparent.style.setProperty("--svgholderwidth", nodeparent.clientWidth + "px");
    nodeparent.style.setProperty("--svgholderheight", nodeparent.clientHeight * 0.6 + "px");

    let oldSvg = holderDiv.querySelector("[id='splitlinesvg']");
    if (oldSvg) holderDiv.removeChild(oldSvg);

    let svg = DiagramNodeUtils.createSVGElement("svg");
    DiagramNodeUtils.assignSVGNodeAttributes(svg, { class: "splitlinesvg", id: "splitlinesvg" });
    holderDiv.appendChild(svg);

    this.arrDiagramNode.map(
        function (node, i) {
            let nodeParent = node.getNodeParent().parentElement;
            let nodeRect = DiagramNodeUtils.getOffsetRectByParent(nodeParent.parentElement, nodeParent);
            let groupNode = nodeParent.querySelector("[data-name='nodeGroup']");
            let lineOffset = !groupNode ? 0 : groupNode.offsetTop;
            if (i > 0) {
                let point1 = { x: nodeRect.x + nodeParent.parentElement.offsetLeft, y: lineOffset };
                let point2 = { x: nodeRect.x + nodeParent.parentElement.offsetLeft, y: this.diagramParent.clientHeight - lineOffset };
                let line = this.createLine(point1, point2);
                line.setAttribute("class", "moodanimation tertiary-stroke");
                line.setAttribute("data-animation", "itemshape");
                line.setAttribute("data-name", "hline");
                line.setAttribute("id", "sectionline");
                svg.appendChild(line);
                line.setAttribute("style", "stroke-dasharray:" + line.getBBox().height + "");
                line.setAttribute("data-length", line.getBBox().height);

                let dummyLine = line.cloneNode(true);
                dummyLine.setAttribute("style", "stroke: var(--alter-bg-color) !important; stroke-dasharray:5");
                dummyLine.setAttribute("id", "dummyline");
                svg.appendChild(dummyLine);
            }
        }.bind(this)
    );

    let svgRect = DiagramNodeUtils.createSVGElement("rect");
    svg.appendChild(svgRect);
    let point1 = { x: 100, y: this.yPosition };
    let point2 = { x: this.diagramParent.clientWidth - 100, y: this.yPosition };
    let line = this.createLine(point1, point2);
    line.setAttribute("class", "moodanimation tertiary-stroke");
    line.setAttribute("data-animation", "itemshape");
    line.setAttribute("id", "baseline");
    svg.appendChild(line);
    line.setAttribute("data-length", line.getBBox().width);
    line.setAttribute("style", "stroke-dasharray:" + line.getBBox().width + "");

    let dummyLine = line.cloneNode(true);
    dummyLine.setAttribute("style", "stroke: var(--alter-bg-color) !important; stroke-dasharray:5");
    dummyLine.setAttribute("id", "dummyline");
    svg.appendChild(dummyLine);

    let lineRect = line.getBBox();
    let rectHeight = 10;
    let rectY = this.yPosition - rectHeight / 2;
    DiagramNodeUtils.assignSVGNodeAttributes(svgRect, { x: lineRect.x, y: rectY, fill: "var(--alter-bg-color)", height: rectHeight, width: lineRect.width });
    this.updateCommonNodeFrame();
};

FlowDiagram.prototype.createLine = function (startPoint, endPoint) {
    let line = DiagramNodeUtils.createSVGElement("line");
    DiagramNodeUtils.assignSVGNodeAttributes(line, { x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y, stroke: "gray", "stroke-width": 2 });
    return line;
};

FlowDiagram.prototype.setupInputOutContent = function () {
    let oldStartElement = this.diagramParent.querySelector("[id='commonNodeParent0']");
    let oldEndElement = this.diagramParent.querySelector("[id='commonNodeParent1']");
    if (oldStartElement) oldStartElement.parentElement.removeChild(oldStartElement);
    if (oldEndElement) oldEndElement.parentElement.removeChild(oldEndElement);

    this.arrCommonNodes = [];
    let nodeData1 =
        this.diagramData.properties.commonnodes && this.diagramData.properties.commonnodes[0] ? this.diagramData.properties.commonnodes[0] : { content: { id: "", value: "", contenttype: "image" } };
    let nodeData2 = this.diagramData.properties.commonnodes && this.diagramData.properties.commonnodes[1] ? this.diagramData.properties.commonnodes[1] : JSON.parse(JSON.stringify(nodeData1));
    let startElement = this.createCommonNode(this.diagramParent, nodeData1, 0);
    startElement.getNodeParent().classList.add("startelement");
    let endElement = this.createCommonNode(this.diagramParent, nodeData2, 1);
    endElement.getNodeParent().classList.add("endelement");
    this.updateCommonNodeFrame();
};

FlowDiagram.prototype.updateCommonNodeFrame = function () {
    let nodeparent = this.diagramParent.querySelector("[name='nodesHolder']");
    let startCenterPoint = { x: nodeparent.offsetLeft / 2, y: this.yPosition };
    let endCenterPoint = { x: nodeparent.offsetLeft + nodeparent.clientWidth + startCenterPoint.x, y: this.yPosition };

    let startNode = this.arrCommonNodes[0];
    let endNode = this.arrCommonNodes[1];
    if (startNode) {
        let nodeParent = startNode.getNodeParent();
        nodeParent.style.top = startCenterPoint.y - nodeParent.clientHeight / 2 + "px";
        nodeParent.style.left = 0 + "px";
    }
    if (endNode) {
        let nodeParent = endNode.getNodeParent();
        nodeParent.style.top = endCenterPoint.y - nodeParent.clientHeight / 2 + "px";
        nodeParent.style.right = 0 + "px";
    }
};

FlowDiagram.prototype.getProperties = function (defaultproperties = {}) {
    let properties = SimpleLinearDiagram.prototype.getProperties.call(this, defaultproperties);
    properties.commonnodes = this.getInputOutData();
    return properties;
};

FlowDiagram.prototype.getInputOutData = function () {
    let cusProperties = [];
    this.arrCommonNodes.map(
        function (node) {
            let data = node.getJSONData();
            cusProperties.push(data);
        }.bind(this)
    );
    return cusProperties;
};

FlowDiagram.prototype.createCommonNode = function (pattenDiv, nodeData, i, isRecreate = false) {
    let id = "commonNodeParent" + i;
    if (isRecreate && !pattenDiv.querySelector("[id='" + id + "']")) return;

    let centerItem = new window["PlainDiagramNode"](pattenDiv, {}, nodeData, this.eventManagerXY, i, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
    centerItem.moodData = this.moodData;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;
    if (!isRecreate) centerItem.createCommonNode(pattenDiv, i);

    if (pattenDiv.querySelector("[id='" + id + "']")) {
        centerItem.parentNode = pattenDiv.querySelector("[id='" + id + "']");
        centerItem.parentNode.setAttribute("data-animation", "itemshape");
        centerItem.nodeGroup = centerItem.parentNode.querySelector("[name='nodeGroupCommon']");
        let contentType = centerItem.parentNode.dataset.type;
        let imageNode = centerItem.parentNode.querySelector("img[data-id='imageNode'],img[data-id='logoNode']");
        if (imageNode) CommonImageUtils.updateImageBounds(imageNode, { islogofit: contentType == "logo", contenttype: contentType }, 1);
    }

    this.arrCommonNodes.push(centerItem);
    return centerItem;
};

FlowDiagram.prototype.recreateElementData = function () {
    SimpleLinearDiagram.prototype.recreateElementData.call(this);
    let nodeparent = this.diagramParent.querySelector("[name='nodesHolder']");
    nodeparent.style.setProperty("--svgholderwidth", nodeparent.clientWidth + "px");
    nodeparent.style.setProperty("--svgholderheight", nodeparent.clientHeight * 0.6 + "px");

    let properties = this.getProperties();
    let nodeData1 = properties.commonnodes ? properties.commonnodes[0] : { id: "", value: "", contenttype: "image" };
    let nodeData2 = properties.commonnodes ? properties.commonnodes[1] : { id: "", value: "", contenttype: "image" };
    this.createCommonNode(this.diagramParent, nodeData1, 0, true);
    this.createCommonNode(this.diagramParent, nodeData2, 1, true);
};

FlowDiagram.prototype.updateNodeData = function (nodeData, type, index, parentId) {
    if (this.arrCommonNodes && this.arrCommonNodes.length > index && parentId.includes("Common")) {
        this.arrCommonNodes[index].updateContentData(nodeData, type, parentId);
    } else if (this.arrDiagramNode && this.arrDiagramNode.length > index) {
        this.arrDiagramNode[index].updateContentData(nodeData, type, parentId);
    }
};

FlowDiagram.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    if (elTarget.dataset.focusParent.includes("Common")) {
        dict[FloaterConstants.HIGHLIGHT] = null;
        dict[FloaterConstants.DELETE_ASSET] = null;
        dict[FloaterConstants.PROP_EMPHASIZE] = null;
        dict[FloaterConstants.SELECTED_TEXT_LINK] = null;
    }
};

FlowDiagram.prototype.updateLineFrame = function () {
    let holder = this.diagramParent.querySelector("[id='svgHolder']");

    if (holder) {
        let arrLine = Array.from(holder.querySelectorAll("[data-name='hline']"));
        arrLine.map(
            function (line) {
                let node = this.arrDiagramNode[0];
                if (node) {
                    let nodeParent = node.getNodeParent().parentElement;
                    let nodeRect = DiagramNodeUtils.getOffsetRectByParent(nodeParent.parentElement, nodeParent);
                    let groupNode = nodeParent.querySelector("[data-name='nodeGroup']");
                    if (groupNode) {
                        let lineOffset = groupNode.offsetTop;
                        let point1 = { x: nodeRect.x, y: lineOffset };
                        let point2 = { x: nodeRect.x, y: this.diagramParent.clientHeight - lineOffset };
                        line.setAttribute("y1", point1.y);
                        line.setAttribute("y2", point2.y);

                        if (line.id == "sectionline") {
                            line.setAttribute("style", "stroke-dasharray:" + line.getBBox().height + "");
                            line.setAttribute("data-length", line.getBBox().height);
                        }
                    }
                }
            }.bind(this)
        );
    }
};

FlowDiagram.prototype.slideDimensionChange = function () {
    try {
        let holder = this.diagramParent.querySelector("[id='svgHolder']");
        if (holder) this.drawSvgSetup(holder);
    } catch (error) {
        console.log(error);
    }
};

FlowDiagram.prototype.defaultFoucsOut = function (event) {
    SimpleLinearDiagram.prototype.defaultFoucsOut.call(this, event);
    this.updateLineFrame();
};

FlowDiagram.prototype.updateEvents = function () {
    LinearDiagram.prototype.updateEvents.call(this);
    this.arrCommonNodes.map(
        function (node) {
            let nodeParent = node.getNodeParent();
            let arrEventNodes = Array.from(nodeParent.querySelectorAll("[data-default-event='true']"));
            arrEventNodes.map(
                function (child, i) {
                    this.eventManagerXY.addEvent(child, "focusin", this.defaultFoucsIn);
                    this.eventManagerXY.addEvent(child, "focusout", this.defaultFoucsOut);
                    this.eventManagerXY.addEvent(child, "paste", this.diagramPasteHandler);
                    this.eventManagerXY.addEvent(child, "input", node.onTextChange);
                    this.eventManagerXY.addEvent(child, "focusout", node.onFocusOut);
                }.bind(this)
            );
        }.bind(this)
    );
};

FlowDiagram.prototype.initPresent = function (currentSlide, boolNoAnimation = false) {
    if (boolNoAnimation) return { isTitleAnimation: false, isGraphicAnimation: false };
    this.diagramParent = currentSlide.querySelector("[id='diagramparent']");

    let animationType = this.diagramParent.parentElement.dataset.animationtype;

    this.arrDiagramNode.map((node) => {
        let nodeParent = node.getNodeParent().parentElement;
        nodeParent.removeAttribute("data-animation");
        nodeParent.classList.remove("moodanimation");
        let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
        arrObj.map((item) => {
            item.removeAttribute("data-animation");
            item.classList.remove("moodanimation");
        });
    });

    this.arrCommonNodes.map((node) => {
        let nodeParent = node.getNodeParent();
        nodeParent.removeAttribute("data-animation");
        nodeParent.classList.remove("moodanimation");
        let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
        arrObj.map((item) => {
            item.removeAttribute("data-animation");
            item.classList.remove("moodanimation");
        });
    });

    if (this.diagramParent.parentElement.dataset.animationtype && this.diagramParent.parentElement.dataset.animationtype == "none") return { isTitleAnimation: false, isGraphicAnimation: false };
    if (this.diagramParent) this.diagramParent.style.opacity = 0;
    return { isTitleAnimation: true, isGraphicAnimation: false };
};

FlowDiagram.prototype.setupAnimation = function (animationType = "one", callback) {
    if (animationType == "none") return;
    this.animationIndex = 0;
    this.animationType = animationType;
    this.diagramParent.parentElement.setAttribute("data-animationtype", this.animationType);
    this.animationCompleteCallback = callback;

    this.arrCommonNodes.map((node) => {
        node.getNodeParent().style.transform = "scale(0)";
    });

    let pyramidsvg = this.diagramParent.querySelector("[id='splitlinesvg']");
    this.arrSectionLines = Array.from(pyramidsvg.querySelectorAll("[id='sectionline']"));
    this.baseLine = pyramidsvg.querySelector("[id='baseline']");
    this.baseLine.style.setProperty("stroke-dashoffset", this.baseLine.dataset.length);

    this.arrSectionLines.map((line) => {
        line.style.setProperty("stroke-dashoffset", line.dataset.length);
    });

    this.arrDiagramNode.map(
        function (node, i) {
            this.hideNodeAtIndex(i);
        }.bind(this)
    );

    this.animateAfterMoodDelay();
};

FlowDiagram.prototype.hideNodeAtIndex = function (i) {
    let node = this.arrDiagramNode[i];
    if (!node) return;
    let nodeParent = node.getNodeParent();
    let nodeGroup = nodeParent.querySelector("[name='nodeGroup']");
    nodeGroup.style.opacity = 0;
    nodeGroup.style.transform = "translateY(50px)";

    if (nodeParent) {
        let titleParent = nodeParent.querySelector("[data-id='primaryTextNode']");
        if (titleParent) {
            titleParent.style.opacity = 0;
            titleParent.style.transform = "translateY(50px)";
            titleParent.firstElementChild.style.opacity = 0;
            titleParent.firstElementChild.style.transform = "translateY(50px)";
        }
        let subtitleParent = nodeParent.querySelector("[data-id='secondaryTextNode']");
        if (subtitleParent) {
            subtitleParent.style.opacity = 0;
            subtitleParent.style.transform = "translateY(50px)";
        }
    }
};

FlowDiagram.prototype.showNodeAtIndex = function (i) {
    let node = this.arrDiagramNode[i];
    if (!node) return;
    let nodeParent = node.getNodeParent();
    if (nodeParent) {
        let nodeGroup = nodeParent.querySelector("[name='nodeGroup']");
        nodeGroup.style.opacity = 1;
        nodeGroup.style.transition = "all 0.5s " + 0.1 + "s";
        nodeGroup.style.transform = "translateY(0px)";

        let titleParent = nodeParent.querySelector("[data-id='primaryTextNode']");
        if (titleParent) {
            titleParent.style.opacity = 1;
            titleParent.style.transition = "all 0.5s " + 0.2 + "s";
            titleParent.style.transform = "translateY(0px)";

            titleParent.firstElementChild.style.opacity = 1;
            titleParent.firstElementChild.style.transition = "all 0.5s " + 0.2 + "s";
            titleParent.firstElementChild.style.transform = "translateY(0px)";
        }
        let subtitleParent = nodeParent.querySelector("[data-id='secondaryTextNode']");
        if (subtitleParent) {
            subtitleParent.style.opacity = 1;
            subtitleParent.style.transition = "all 0.5s " + 0.3 + "s";
            subtitleParent.style.transform = "translateY(0px)";
        }
    }
};

FlowDiagram.prototype.animateAfterMoodDelay = function () {
    this.diagramParent.style.opacity = 1;
    if (this.centerNode) this.centerNode.style.transition = "all 0.3s";
    if (this.centerNode) this.centerNode.style.opacity = 1;

    this.animationType == "all" ? this.playAllAtOnce() : this.playNext();

    if (this.animationType == "all") {
        let time = 1500 * this.arrDiagramNode.length;
        setTimeout(() => {
            if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        }, time);
    } else if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
};

FlowDiagram.prototype.showSectionLineAtIndex = function (index) {
    let line = this.arrSectionLines[index];
    if (!line) return;
    line.style.transition = "all 0.6s";
    line.style.setProperty("stroke-dashoffset", 0);
};

FlowDiagram.prototype.hideSectionLineAtIndex = function (index) {
    let line = this.arrSectionLines[index];
    if (!line) return;
    line.style.transition = "all 0.6s";
    line.style.setProperty("stroke-dashoffset", line.dataset.length);
};

FlowDiagram.prototype.showBaselineToIndex = function (index, isForward = true) {
    let node = this.arrDiagramNode[index];
    if (node) {
        let nodeParent = node.getNodeParent().parentElement;
        let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
        let baselineRect = this.baseLine.getBBox();
        let nodeRect = DiagramNodeUtils.getOffsetRectByParent(nodeHolder, nodeParent);
        let nodeCenter = nodeRect.x + nodeRect.width / 2;
        this.baseLine.style.transition = "all 0.5s";
        this.baseLine.style.setProperty("stroke-dashoffset", this.baseLine.dataset.length - (nodeCenter - baselineRect.x));
        if (index == this.arrDiagramNode.length - 1 && isForward) {
            setTimeout(() => {
                this.baseLine.style.setProperty("stroke-dashoffset", 0);
            }, 1200);

            setTimeout(() => {
                let endElement = this.arrCommonNodes[1].getNodeParent();
                endElement.style.transform = "scale(1)";
                endElement.style.transition = "all 0.5s";
            }, 1500);
        } else if (index == this.arrDiagramNode.length - 1 && !isForward) {
            let endElement = this.arrCommonNodes[1].getNodeParent();
            endElement.style.transform = "scale(0)";
            endElement.style.transition = "all 0.8s";
        }
    } else if (!isForward) {
        this.baseLine.style.setProperty("stroke-dashoffset", this.baseLine.dataset.length);
        setTimeout(() => {
            let statElement = this.arrCommonNodes[0].getNodeParent();
            statElement.style.transform = "scale(0)";
            statElement.style.transition = "all 0.5s";
        }, 500);
    }
};

FlowDiagram.prototype.playNext = function (index) {
    if (this.gotoNextSlide) return false;
    if (this.animationIndex == this.arrDiagramNode.length) {
        this.gotoNextSlide = true;
        return false;
    }
    let statElement = this.arrCommonNodes[0].getNodeParent();
    let aIndex = this.animationIndex;
    if (aIndex == 0 && statElement.style.transform == "scale(0)") {
        statElement.style.transform = "scale(1)";
        statElement.style.transition = "all 0.5s";

        setTimeout(() => {
            this.playNext();
        }, 500);
        return true;
    }
    if (this.animationIndex > 0) {
        setTimeout(() => {
            this.showSectionLineAtIndex(aIndex - 1);
        }, 300);
    }
    setTimeout(() => {
        this.showNodeAtIndex(aIndex);
    }, 300);
    this.showBaselineToIndex(this.animationIndex);
    this.animationIndex += 1;

    setTimeout(() => {
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, 1000);
    return true;
};

FlowDiagram.prototype.playPrevious = function (index) {
    this.animationIndex -= 1;
    let aIndex = this.animationIndex;
    if (aIndex < 0) return false;
    let endElement = this.arrCommonNodes[1].getNodeParent();
    if (endElement.style.transform == "scale(1)") {
        this.showBaselineToIndex(aIndex, false);
        this.animationIndex += 1;
        setTimeout(() => {
            this.playPrevious();
        }, 800);
        return true;
    }

    if (this.animationIndex > 0) {
        setTimeout(() => {
            this.hideSectionLineAtIndex(aIndex - 1);
        }, 100);
    }
    setTimeout(() => {
        this.hideNodeAtIndex(aIndex);
    }, 0);

    setTimeout(() => {
        this.showBaselineToIndex(aIndex - 1, false);
    }, 500);

    setTimeout(() => {
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, 1000);

    return true;
};

FlowDiagram.prototype.playAllAtOnce = function () {
    this.playNext();
    setTimeout(() => {
        for (var i = 0; i < this.arrDiagramNode.length; i++) {
            setTimeout(() => {
                this.playNext();
            }, 1000 * i);
        }
    }, 1500);

    return false;
};

FlowDiagram.prototype.playAllAtOnceReverse = function () {
    this.playPrevious();

    setTimeout(() => {
        for (var i = 0; i < this.arrDiagramNode.length - 1; i++) {
            setTimeout(() => {
                this.playPrevious();
            }, 1000 * i);
        }
    }, 2000);

    let time = 1500 * this.arrDiagramNode.length;
    setTimeout(() => {
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, time);
    return true;
};

FlowDiagram.prototype.animateArrowForward = function (index) {};

FlowDiagram.prototype.animateArrowBackward = function (index) {};

/**
 * Author:    Krishna
 * Created:   9 Jun 2020
 *
 * (c) Copyright by Krishna.
 **/

"use strict";

function SvgArrowFlow(diagramParent, diagramData, nodeProps, moodData = {}) {
    FlowDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "svgarrowflow";
    this.svgOffsetTop = 160;
    this.arrowGap = 8;
    this.arrowDepth = 30;
    this.rangeLineOffset = 40;
    this.topArroelineColorClass = "tertiary-";
    this.rangePoint = [2, 1];
    this.arrProjectionNode = [];
    this.centerHolderNode = "";
    this.isStartEndEnable = null;
    this.diagramParent.parentElement.setAttribute("data-allowdefaultanimation", "true");
    this.diagramParent.setAttribute("data-currencyformat", "disable");
}

SvgArrowFlow.prototype = Object.create(FlowDiagram.prototype);
SvgArrowFlow.prototype.constructor = SvgArrowFlow;

SvgArrowFlow.prototype.createElements = function () {
    SimpleLinearDiagram.prototype.createElements.call(this);
    this.arrowGap = 8 * (this.slideWidth / 1280);
    let nodeparent = this.diagramParent.querySelector("[name='nodesHolder']");
    let holder = document.createElement("div");
    holder.className = "svgHolder";
    holder.id = "svgHolder";
    nodeparent.appendChild(holder);
    nodeparent.style.setProperty("--svgwidth", nodeparent.clientWidth + "px");
    nodeparent.style.setProperty("--svgheight", 140 + "px", "important");
    nodeparent.style.setProperty("--svgoffsettop", this.svgOffsetTop + "px");
    nodeparent.style.setProperty("--contentNodeHeight", 140 + "px");
    nodeparent.style.setProperty("--subtitleMaxHeight", nodeparent.clientHeight - 300 + "px");

    if (this.diagramData?.properties?.position != "") this.diagramParent.dataset.arrowposition = this.diagramData.properties.position;

    setTimeout(() => {
        let node = this.arrDiagramNode[0].getNodeParent();
        let group = node.querySelector("[data-name='nodeGroup']");
        nodeparent.style.setProperty("--svgoffsettop", window.getComputedStyle(group).marginTop);

        this.drawSvgSetup(holder);
        this.updateFrame();
        this.isRenderComplete = true;
        this.diagramRenderComplete();
    }, 0);
};

SvgArrowFlow.prototype.updateElements = function (defaultproperties) {
    FlowDiagram.prototype.updateElements.call(this, defaultproperties);
    this.updateFrame();
};

SvgArrowFlow.prototype.diagramRenderComplete = function () {
    if (!this.isRenderComplete) return;
    LinearDiagram.prototype.diagramRenderComplete.call(this);
    this.updateFrame();
};

SvgArrowFlow.prototype.drawSvgSetup = function (holderDiv) {
    this.isStartEndEnable = this.diagramData.properties.commonnodevisible;
    let oldSvg = holderDiv.querySelector("[id='pyramidsvg']");
    if (oldSvg) holderDiv.removeChild(oldSvg);

    this.diagramParent.style.setProperty("--commonnodeoffset", this.isStartEndEnable ? "150px" : "10px");
    this.diagramParent.style.setProperty("--nodeholdewidthoffse", this.isStartEndEnable ? "200px" : "30px");

    let nodeparent = this.diagramParent.querySelector("[name='nodesHolder']");
    nodeparent.style.setProperty("--svgwidth", nodeparent.clientWidth + "px");

    let svg = DiagramNodeUtils.createSVGElement("svg");
    DiagramNodeUtils.assignSVGNodeAttributes(svg, { class: "pyramidsvg", id: "pyramidsvg" });
    holderDiv.appendChild(svg);

    let arrShapePoints = this.getShapePoints(holderDiv);

    arrShapePoints.map(
        function (arrPoints, i) {
            let strD = this.createRoundedPathString(arrPoints); //this.getPathString(arrPoints);
            let path = DiagramNodeUtils.createSVGElement("path");
            let group = DiagramNodeUtils.createSVGElement("g");
            let colorIndex = i + 1;
            group.setAttribute("id", "pyramid-point" + colorIndex);
            DiagramNodeUtils.assignSVGNodeAttributes(path, { d: strD, class: " clsMultiColorParent clsAccentfill shapepath" });
            DiagramUtils.setCustomItemColor(path, this.arrTintArray, i, i + 1);
            group.appendChild(path);
            svg.appendChild(group);
        }.bind(this)
    );

    if (this.diagramParent.dataset.projectionindex && parseInt(this.diagramParent.dataset.projectionindex) > this.arrDiagramNode.length - 1) {
        this.diagramParent.removeAttribute("data-projectionindex");
        this.setProjection(100);
    }
    this.drawRangeLines(holderDiv, svg);
    this.diagramParent.dataset.projectionindex ? this.setProjection(this.diagramParent.dataset.projectionindex) : "";
    this.diagramParent.style.setProperty("--iconnodewidth", "70%");
    this.diagramParent.style.setProperty("--iconnodeheight", "70%");
    this.updateShapeEmphasis();

    this.updateFrame();
};

SvgArrowFlow.prototype.drawRangeLines = function (holderDiv, svg) {
    this.arrLines = Array.from(svg.querySelectorAll("line"));
    this.arrLines.map((line) => line.parentElement.removeChild(line));
    let nodeWidth = holderDiv.clientWidth / this.arrDiagramNode.length;
    let pIndex = this.diagramParent.dataset.projectionindex ? parseInt(this.diagramParent.dataset.projectionindex) : -1;
    this.rangePoint = pIndex == 0 ? [pIndex] : pIndex != -1 ? [pIndex, 1] : [];
    this.rangePoint.map(
        function (poin, i) {
            if (parseInt(poin) <= this.arrDiagramNode.length) {
                let x = i == 0 ? 0 : this.rangePoint[i - 1] * nodeWidth;
                let endX = poin * nodeWidth - 15;
                endX = endX > holderDiv.clientWidth ? holderDiv.clientWidth : endX;
                endX = i == this.rangePoint.length - 1 ? holderDiv.clientWidth : endX;
                let point1 = { x: x, y: -this.rangeLineOffset };
                let point2 = { x: endX, y: -this.rangeLineOffset };
                let line = this.createLine(point1, point2);
                DiagramNodeUtils.assignSVGNodeAttributes(line, { class: "rangeline tertiary-stroke" });
                line.setAttribute("data-startx", point1.x);
                line.setAttribute("data-endx", point2.x);
                if (i > 0 || this.rangePoint.length == 1) {
                    line.setAttribute("stroke-dasharray", "5");
                } else line.setAttribute("stroke-dasharray", "none");
                svg.appendChild(line);
            }
        }.bind(this)
    );

    this.createMarker(svg);
    this.diagramParent.style.setProperty("--grouptop", holderDiv.offsetTop + "px");
    this.setupInputOutContent();
};

SvgArrowFlow.prototype.getPathString = function (arrPoints) {
    let pointString = "";
    arrPoints.map((point, i) => {
        let pathComponent = i == 0 ? "M" : "L";
        pointString = pointString + (i == 0 ? "" + pathComponent : " " + pathComponent) + point.x + "," + point.y;
    });
    return pointString + " Z";
};

SvgArrowFlow.prototype.createRoundedPathString = function (pathCoords, radius = 3) {
    const path = [];
    const curveRadius = radius;

    // Reset indexes, so there are no gaps
    pathCoords = pathCoords.slice();

    for (let i = 0; i < pathCoords.length; i++) {
        // 1. Get current coord and the next two (startpoint, cornerpoint, endpoint) to calculate rounded curve
        const c2Index = i + 1 > pathCoords.length - 1 ? (i + 1) % pathCoords.length : i + 1;
        const c3Index = i + 2 > pathCoords.length - 1 ? (i + 2) % pathCoords.length : i + 2;

        const c1 = pathCoords[i];
        const c2 = pathCoords[c2Index];
        const c3 = pathCoords[c3Index];

        // 2. For each 3 coords, enter two new path commands: Line to start of curve, bezier curve around corner.

        // Calculate curvePoint c1 -> c2
        const c1c2Distance = Math.sqrt(Math.pow(c1.x - c2.x, 2) + Math.pow(c1.y - c2.y, 2));
        const c1c2DistanceRatio = (c1c2Distance - curveRadius) / c1c2Distance;
        const c1c2CurvePoint = [((1 - c1c2DistanceRatio) * c1.x + c1c2DistanceRatio * c2.x).toFixed(1), ((1 - c1c2DistanceRatio) * c1.y + c1c2DistanceRatio * c2.y).toFixed(1)];

        // Calculate curvePoint c2 -> c3
        const c2c3Distance = Math.sqrt(Math.pow(c2.x - c3.x, 2) + Math.pow(c2.y - c3.y, 2));
        const c2c3DistanceRatio = curveRadius / c2c3Distance;
        const c2c3CurvePoint = [((1 - c2c3DistanceRatio) * c2.x + c2c3DistanceRatio * c3.x).toFixed(1), ((1 - c2c3DistanceRatio) * c2.y + c2c3DistanceRatio * c3.y).toFixed(1)];

        // If at last coord of polygon, also save that as starting point
        if (i === pathCoords.length - 1) {
            path.unshift("M" + c2c3CurvePoint.join(","));
        }

        // Line to start of curve (L endcoord)
        path.push("L" + c1c2CurvePoint.join(","));
        // Bezier line around curve (Q controlcoord endcoord)
        path.push("Q" + c2.x + "," + c2.y + "," + c2c3CurvePoint.join(","));
    }
    // Logically connect path to starting point again (shouldn't be necessary as path ends there anyway, but seems cleaner)
    path.push("Z");

    return path.join(" ");
};

SvgArrowFlow.prototype.getShapePoints = function (svgHolder) {
    let arrShapePoints = [];
    let nodeWidth = svgHolder.clientWidth / this.arrDiagramNode.length;
    this.arrDiagramNode.map(
        function (node, i) {
            let x = nodeWidth * i - this.arrowGap; // + this.arrowDepth/2;
            let width = nodeWidth; //- this.arrowDepth/2;
            let height = svgHolder.clientHeight;
            let point1 = { x: x, y: 0 };
            let point2 = { x: x + width - this.arrowGap, y: 0 };
            let point3 = { x: x + width + this.arrowDepth - this.arrowGap, y: height / 2 };
            let point4 = { x: point2.x, y: height };
            let point5 = { x: point1.x, y: height };
            let point6 = { x: i == 0 ? -this.arrowGap : point1.x + this.arrowDepth, y: point3.y };

            arrShapePoints.push([point1, point2, point3, point4, point5, point6]);
        }.bind(this)
    );
    return arrShapePoints;
};

SvgArrowFlow.prototype.createMarker = function (svg) {
    let defs = svg.querySelector("defs");
    if (!defs) {
        defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        svg.appendChild(defs);
    }

    let marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
    let marker1randomId = Math.random().toString();
    let refy = 2;
    let refx = 2;
    marker.setAttribute("id", marker1randomId);
    marker.setAttribute("markerWidth", "4");
    marker.setAttribute("markerHeight", "4");
    marker.setAttribute("refX", refx);
    marker.setAttribute("refY", refy);
    marker.innerHTML = '<circle cx="2" cy="2" r="2" fill="red" />';
    marker.firstElementChild.setAttribute("class", this.topArroelineColorClass + "fill");

    let arrMarker = Array.from(defs.querySelectorAll("marker"));
    arrMarker.map((marker) => {
        marker.parentElement.removeChild(marker);
    });

    defs.appendChild(marker);

    let arrLines = Array.from(svg.querySelectorAll("line"));
    arrLines.map((line) => {
        line.setAttribute("marker-end", "url(#" + marker1randomId + ")");
        line.setAttribute("marker-start", "url(#" + marker1randomId + ")");
    });
};

SvgArrowFlow.prototype.updateFrame = function () {
    let nodeparent = this.diagramParent.querySelector("[name='nodesHolder']");
    if (this.arrDiagramNode.length == 0) return;
    let svgMarginTop = this.diagramParent.dataset.projectionindex ? "50px" : "0px";
    nodeparent.style.setProperty("--svgLineMargin", svgMarginTop);
    let node = this.arrDiagramNode[0].getNodeParent();
    let group = node.querySelector("[data-name='nodeGroup']");

    if ((this.diagramParent.dataset.arrowposition || "") == "bottom") nodeparent.style.setProperty("--svgoffsettop", group.offsetTop + group.offsetHeight + group.parentElement.parentElement.offsetTop + "px");
    else nodeparent.style.setProperty("--svgoffsettop", group.offsetTop + group.parentElement.parentElement.offsetTop + "px");
    nodeparent.style.setProperty("--subtitleMaxHeight", nodeparent.clientHeight - 300 + "px");

    this.updateCommonNodeFrame();
};

SvgArrowFlow.prototype.updateCommonNodeFrame = function () {
    let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    let svgHolder = this.diagramParent.querySelector("[id='svgHolder']");

    let svgLabel = this.arrCommonNodes[0];
    let lineLabel = null; //this.arrCommonNodes[1];

    if (svgLabel) {
        let svgNode = svgLabel.getNodeParent();
        let x = "10px";
        let y = svgHolder.offsetTop + svgHolder.clientHeight / 2 - svgNode.clientHeight / 2 + "px";
        svgNode.style.top = y;
        svgNode.style.left = x;
        svgNode.style.height = "100px";
        svgNode.style.maxHeight = svgNode.style.height;
    }

    if (lineLabel) {
        let lineNode = lineLabel.getNodeParent();
        let x = "10px";
        let y = svgHolder.offsetTop - 20 - lineNode.clientHeight / 2 + "px";
        lineNode.style.top = y;
        lineNode.style.left = x;
        lineNode.style.visibility = "hidden";
    }

    let arrLines = Array.from(svgHolder.querySelectorAll("line"));
    arrLines.map(
        function (line, i) {
            let commonNode = this.arrProjectionNode[i];
            if (commonNode) {
                let lineRect = line.getBBox();
                let x = nodeHolder.offsetLeft + lineRect.x + lineRect.width / 2;
                let y = svgHolder.offsetTop - this.rangeLineOffset - 15;
                let commonNodeParent = commonNode.getNodeParent();
                commonNodeParent.style.width = lineRect.width + "px";
                commonNodeParent.style.left = x - commonNodeParent.clientWidth / 2 + "px";
                commonNodeParent.style.top = y - commonNodeParent.clientHeight + "px";
                commonNodeParent.style.height = "50px";
                commonNodeParent.style.maxHeight = commonNodeParent.style.height;
            }
        }.bind(this)
    );
};

SvgArrowFlow.prototype.setupInputOutContent = function () {
    let arrOldNodes = Array.from(this.diagramParent.querySelectorAll("[id*='commonNodeParent']"));
    arrOldNodes.map((oldNode) => {
        if (oldNode) oldNode.parentElement.removeChild(oldNode);
    });

    this.arrCommonNodes = [];
    this.arrProjectionNode = [];

    if (this.isStartEndEnable) {
        let nodeData1 = this.startenddata ? this.startenddata : { content: { id: "", value: "", contenttype: "text" } };
        let commonNode = this.createCommonNode(this.diagramParent, nodeData1, 0);
        if (commonNode) this.arrCommonNodes.push(commonNode);
    }

    let svg = this.diagramParent.querySelector("[id='pyramidsvg']");
    if (!svg) return;

    let arrLines = Array.from(svg.querySelectorAll("line"));
    arrLines.map(
        function (line, i) {
            let nodeData = this.projectiondata && this.projectiondata[i] ? this.projectiondata[i] : { content: { id: "", value: "", contenttype: "text" } };
            let projectionNode = this.createCommonNode(this.diagramParent, nodeData, i + 1);
            this.arrProjectionNode.push(projectionNode);
        }.bind(this)
    );

    this.updateCommonNodeFrame();
    this.updateEvents();
};

SvgArrowFlow.prototype.recreateElementData = function () {
    SimpleLinearDiagram.prototype.recreateElementData.call(this);
    this.arrCommonNodes = [];
    this.arrProjectionNode = [];

    let arrCommonNode = [...this.diagramParent.querySelectorAll("[data-id='commonNodeParent']")];
    let isCommonNode = this.diagramParent.dataset.commonnodevisible || null;
    this.arrCommonNodes = arrCommonNode.map((element, i) => this.createCommonNode(this.diagramParent, {}, !isCommonNode ? i + 1 : i, true));
    if (this.arrCommonNodes.length > 0) {
        this.startenddata = this.arrCommonNodes[0]?.getJSONData?.();
    }

    // if (this.isStartEndEnable) {
    //     let nodeData1 = this.startenddata ? this.startenddata : { content: { id: "", value: "", contenttype: "text" } };
    //     let commonNode = this.createCommonNode(this.diagramParent, nodeData1, 0, true);
    //     if (commonNode) this.arrCommonNodes.push(commonNode);
    // }

    let svg = this.diagramParent.querySelector("[id='pyramidsvg']");
    if (!svg) return;

    let arrLines = Array.from(svg.querySelectorAll("line"));
    arrLines.map(
        function (line, i) {
            let nodeData = this.projectiondata && this.projectiondata[i] ? this.projectiondata[i] : { content: { id: "", value: "", contenttype: "text" } };
            let projectionNode = this.createCommonNode(this.diagramParent, nodeData, i + 1, true);
            this.arrProjectionNode.push(projectionNode);
        }.bind(this)
    );
};

SvgArrowFlow.prototype.defaultFoucsOut = function (event) {
    SimpleLinearDiagram.prototype.defaultFoucsOut.call(this, event);
    setTimeout(() => {
        this.updateFrame();
    }, 100);
};

SvgArrowFlow.prototype.slideDimensionChange = function () {
    let holder = this.diagramParent.querySelector("#svgHolder");
    if (holder) {
        this.resetNodeAttributes();
        this.drawSvgSetup(holder);
    }
};

SvgArrowFlow.prototype.diagramPasteHandler = function (event) {
    SimpleLinearDiagram.prototype.diagramPasteHandler.call(this, event);
    this.updateFrame();
};

SvgArrowFlow.prototype.createCommonNode = function (pattenDiv, nodeData, i, isRecreate = false) {
    let id = "commonNodeParent" + i;
    if (isRecreate && !pattenDiv.querySelector("[id='" + id + "']")) return;

    let centerItem = new window["PlainDiagramNode"](pattenDiv, {}, nodeData, this.eventManagerXY, i, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
    centerItem.moodData = this.moodData;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;
    centerItem.centerNode = [{ name: "textTitleHolder" }];
    if (!isRecreate) centerItem.createCommonNode(pattenDiv, i);

    if (pattenDiv.querySelector("[id='" + id + "']")) {
        centerItem.parentNode = pattenDiv.querySelector("[id='" + id + "']");
        centerItem.parentNode.setAttribute("data-animation", "itemshape");
        centerItem.nodeGroup = centerItem.parentNode.querySelector("[name='nodeGroupCommon']");
        let contentType = centerItem.parentNode.dataset.type;
        let imageNode = centerItem.parentNode.querySelector("img[data-id='imageNode'],img[data-id='logoNode']");
        if (imageNode) CommonImageUtils.updateImageBounds(imageNode, { islogofit: contentType == "logo", contenttype: contentType }, 1);
    }

    return centerItem;
};

SvgArrowFlow.prototype.updateFloaterSettings = function (mainProperties) {
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable = [...new Set(mainProperties.floateroptionsdisable.concat(this.floateroptionsdisable()))];
    } else mainProperties.floateroptionsdisable = this.floateroptionsdisable();
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

SvgArrowFlow.prototype.floateroptionsdisable = function () {
    return ["swap", "contentoptions", "sequencetext", "primarytext", "arrange", "numbersize", "animateoneatatime", "highlight"];
};

SvgArrowFlow.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    dict["crossout"] = null;
    if (elTarget.getAttribute("name") && elTarget.getAttribute("name") == "secondaryTextItem") return;
    var tlIndex = elTarget.dataset.index;
    let val = this.diagramParent.dataset.projectionindex && this.diagramParent.dataset.projectionindex == tlIndex;
    dict["projection"] = { visible: true, value: val, floaterproperty: "projection" };
    if (strSelectionType == "primaryText" || strSelectionType == "numberNode") this.getFontSizeDataForInlineFloater(dict, elTarget);
};

SvgArrowFlow.prototype.setProjection = function (projectionIndex) {
    let index = projectionIndex;
    let arrowHolder = this.diagramParent.querySelector("[id='pyramidsvg']");
    this.arrArrows = Array.from(arrowHolder.querySelectorAll("g"));
    this.arrDiagramNode.map(
        function (node, i) {
            let nodeParent = node.parentNode.parentElement;
            let isProjectionEnable = parseInt(nodeParent.dataset.index) >= parseInt(index);
            isProjectionEnable ? nodeParent.classList.add("clstimelineprojection") : nodeParent.classList.remove("clstimelineprojection");
            let connertorPoint = this.arrArrows[i];
            if (connertorPoint) isProjectionEnable ? connertorPoint.classList.add("clstimelineprojection") : connertorPoint.classList.remove("clstimelineprojection");
        }.bind(this)
    );
};

SvgArrowFlow.prototype.projection = function (property) {
    var index = property.targetid.replace(/\D/g, "");
    property.value ? this.diagramParent.setAttribute("data-projectionindex", index) : this.diagramParent.removeAttribute("data-projectionindex");
    this.setProjection(property.value ? index : 100);

    let arrowHolder = this.diagramParent.querySelector("[id='pyramidsvg']");
    if (arrowHolder) {
        this.drawRangeLines(arrowHolder.parentElement, arrowHolder);
        this.updateFrame();
    }

    this.updateTextNodes?.();
    this.updateFrame?.();
};

SvgArrowFlow.prototype.getProjectionData = function () {
    if (this.arrProjectionNode.length > 0) {
        this.projectiondata = this.arrProjectionNode.map(function (node) {
            return node.getJSONData();
        });
        return this.projectiondata;
    } else return null;
};

SvgArrowFlow.prototype.getStartEndData = function () {
    if (this.arrCommonNodes.length > 0) {
        this.startenddata = this.arrCommonNodes[0].getJSONData();
        return this.startenddata;
    } else return null;
};

SvgArrowFlow.prototype.updateEvents = function () {
    FlowDiagram.prototype.updateEvents.call(this);
    this.arrProjectionNode.map(
        function (node) {
            let nodeParent = node.getNodeParent();
            let arrEventNodes = Array.from(nodeParent.querySelectorAll("[data-default-event='true']"));
            arrEventNodes.map(
                function (child, i) {
                    this.eventManagerXY.addEvent(child, "focusin", this.defaultFoucsIn);
                    this.eventManagerXY.addEvent(child, "focusout", this.defaultFoucsOut);
                    this.eventManagerXY.addEvent(child, "paste", this.diagramPasteHandler);
                    this.eventManagerXY.addEvent(child, "input", node.onTextChange);
                    this.eventManagerXY.addEvent(child, "focusout", node.onFocusOut);
                }.bind(this)
            );
        }.bind(this)
    );
};

SvgArrowFlow.prototype.setDiagramSpecficOption = function (obj) {
    let startendelementoption = {};
    startendelementoption.start = {};
    startendelementoption.start = { isOn: this.diagramData.properties.commonnodevisible, label: "Common Node" };
    obj.dpcontent.floatdiagramsettings.startendelementoption = startendelementoption;

    delete obj.dpcontent.floatdiagramsettings.graphicvalueformat;
    if (!this.diagramData?.properties?.floateroptionsdisable?.includes?.("date")) obj.dpcontent.floatdiagramsettings.dateformat = DiagramUtils.getDateFormatInlineData(this);
};

SvgArrowFlow.prototype.showHideStartEnd = function (operation) {
    this.isStartEndEnable = operation.value;
    this.diagramParent.setAttribute("data-commonnodevisible", operation.value);
    this.diagramData.properties.commonnodevisible = operation.value;
    let holder = this.diagramParent.querySelector("#svgHolder");
    if (holder) this.drawSvgSetup(holder);
};

//Animation FFunction
SvgArrowFlow.prototype.initPresent = function (currentSlide, boolNoAnimation = false) {
    if (boolNoAnimation) return { isTitleAnimation: false, isGraphicAnimation: false };
    this.diagramParent = currentSlide.querySelector("[id='diagramparent']");

    this.arrDiagramNode.map((node) => {
        let nodeParent = node.getNodeParent().parentElement;
        nodeParent.removeAttribute("data-animation");
        nodeParent.classList.remove("moodanimation");
        let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
        arrObj.map((item) => {
            item.removeAttribute("data-animation");
            item.classList.remove("moodanimation");
        });
    });

    this.arrCommonNodes.map((node) => {
        let nodeParent = node.getNodeParent();
        nodeParent.removeAttribute("data-animation");
        nodeParent.classList.remove("moodanimation");
        let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
        arrObj.map((item) => {
            item.removeAttribute("data-animation");
            item.classList.remove("moodanimation");
        });
    });

    if (this.diagramParent.parentElement.dataset.animationtype && this.diagramParent.parentElement.dataset.animationtype == "none") return { isTitleAnimation: false, isGraphicAnimation: false };
    if (this.diagramParent) this.diagramParent.style.opacity = 0;
    return { isTitleAnimation: true, isGraphicAnimation: false };
};

SvgArrowFlow.prototype.setupAnimation = function (animationType = "one", callback) {
    this.animationCompleteCallback = callback;
    if (animationType == "none") {
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return;
    }
    let moodAnimationDisable = this.diagramParent.parentElement.dataset.moodanimation;
    if (moodAnimationDisable && moodAnimationDisable == "none") {
        this.animationFactor = 0;
        this.diagramParent.style.opacity = 1;
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return;
    }
    this.animationFactor = 1;
    this.animationIndex = 0;
    this.allAtOnceIndex = 0;
    this.animationType = animationType;
    this.diagramParent.parentElement.setAttribute("data-animationtype", this.animationType);

    let arrowHolder = this.diagramParent.querySelector("[id='pyramidsvg']");
    this.arrArrows = Array.from(arrowHolder.querySelectorAll("g"));
    this.arrLines = Array.from(arrowHolder.querySelectorAll("line"));
    this.arrCommonNodes.map((node) => {
        node.getNodeParent().style.opacity = 0;
    });

    this.arrProjectionNode.map((node) => {
        node.getNodeParent().style.opacity = 0;
    });

    this.arrDiagramNode.map(
        function (node, i) {
            this.hideNodeAtIndex(i);
        }.bind(this)
    );

    this.arrArrows.map(function (arrow) {
        arrow.style.transform = "translateX(-50px)";
        arrow.style.opacity = 0;
    });

    this.arrLines.map(
        function (line) {
            line.style.opacity = 0;
            this.hideLine(line, 1);
        }.bind(this)
    );

    setTimeout(() => {
        this.animateAfterMoodDelay();
    }, 200);
};

SvgArrowFlow.prototype.hideNodeAtIndex = function (i) {
    let node = this.arrDiagramNode[i];
    let arrow = this.arrArrows[i];
    if (!node) return;

    if (i == this.arrDiagramNode.length - 1 && this.arrLines.length > 0 && this.arrLines[0].style.opacity == 1) {
        this.arrLines.map(
            function (line, i) {
                setTimeout(() => {
                    line.style.opacity = 0;
                }, 300);

                this.hideLine(line, 800);
            }.bind(this)
        );

        this.arrCommonNodes.map((node, i) => {
            if (i > 0) {
                node.getNodeParent().style.opacity = 0;
            }
        });

        this.arrProjectionNode.map((node, i) => {
            node.getNodeParent().style.opacity = 0;
        });

        setTimeout(() => {
            this.hideNodeAtIndex(i);
        }, 400);
        return;
    } else if (i == 0 && this.arrCommonNodes.length > 0) {
        let initialElement = this.arrCommonNodes[0].getNodeParent();
        if (initialElement.style.opacity == 1) {
            setTimeout(() => {
                initialElement.style.opacity = 0;
            }, 400);
        }
    }

    let nodeParent = node.getNodeParent();
    let nodeGroup = nodeParent.querySelector("[name='nodeGroup']");
    nodeGroup.style.transform = "translateX(-50px)";
    nodeGroup.style.opacity = 0;

    if (nodeParent) {
        let titleParent = nodeParent.querySelector("[data-id='primaryTextNode']");
        if (titleParent) {
            titleParent.style.opacity = 0;
            titleParent.style.transform = "translateX(-50px)";
            titleParent.firstElementChild.style.opacity = 0;
            titleParent.firstElementChild.style.transform = "translateX(-50px)";

            if (arrow) {
                arrow.style.opacity = 0;
                // arrow.style.transition = "all 0.5s " + 0.1 + "s";
                arrow.style.transform = "translateX(-50px)";
            }
        }
        let subtitleParent = nodeParent.querySelector("[data-id='secondaryTextNode']");
        if (subtitleParent) {
            subtitleParent.style.opacity = 0;
            subtitleParent.style.transform = "translateX(-50px)";
        }
    }
};

SvgArrowFlow.prototype.showNodeAtIndex = function (i) {
    let node = this.arrDiagramNode[i];
    let arrow = this.arrArrows[i];
    if (!node) return;
    let nodeParent = node.getNodeParent();
    if (nodeParent) {
        let nodeGroup = nodeParent.querySelector("[name='nodeGroup']");
        nodeGroup.style.opacity = 1;
        nodeGroup.style.transition = "all 0.5s " + 0.1 + "s";
        nodeGroup.style.transform = "translateX(0px)";
        nodeGroup.style.opacity = 1;

        let titleParent = nodeParent.querySelector("[data-id='primaryTextNode']");
        if (titleParent) {
            titleParent.style.opacity = 1;
            titleParent.style.transition = "all 0.5s " + 0.2 + "s";
            titleParent.style.transform = "translateX(0px)";

            titleParent.firstElementChild.style.opacity = 1;
            titleParent.firstElementChild.style.transition = "all 0.5s " + 0.2 + "s";
            titleParent.firstElementChild.style.transform = "translateX(0px)";

            arrow.style.opacity = 1;
            arrow.style.transition = "all 0.5s " + 0.1 + "s";
            arrow.style.transform = "translateX(0px)";
        }
        let subtitleParent = nodeParent.querySelector("[data-id='secondaryTextNode']");
        if (subtitleParent) {
            subtitleParent.style.opacity = 1;
            subtitleParent.style.transition = "all 0.5s " + 0.3 + "s";
            subtitleParent.style.transform = "translateX(0px)";
        }
    }

    setTimeout(() => {
        if (i == this.arrDiagramNode.length - 1) {
            this.arrLines.map(
                function (line, i) {
                    line.style.transition = "all 0.5s " + 0.1 * i + "s";
                    line.style.transform = "translateY(0px)";
                    line.style.opacity = 1;
                    this.showLine(line, 800);
                }.bind(this)
            );

            this.arrProjectionNode.map((node, i) => {
                node.getNodeParent().style.transition = "all 0.5s " + 0.1 * i + "s";
                node.getNodeParent().style.opacity = 1;
            });
        }
    }, 400);
};

SvgArrowFlow.prototype.animateAfterMoodDelay = function () {
    this.diagramParent.style.opacity = 1;
    if (this.centerNode) this.centerNode.style.transition = "all 0.3s";
    if (this.centerNode) this.centerNode.style.opacity = 1;

    if (this.animationType == "all") this.playAllAtOnce();
    else this.animationCompleteCallback?.fn?.(this.animationCompleteCallback.params);
};

SvgArrowFlow.prototype.showLine = function (line, time = 500) {
    this.animate({
        duration: time,
        timing: function (timeFraction) {
            return Math.pow(timeFraction, 2);
        },
        draw: function (progress) {
            line.x2.baseVal.value = line.x1.baseVal.value + progress * (line.dataset.endx - line.x1.baseVal.value);
        },
    });
};

SvgArrowFlow.prototype.hideLine = function (line, time = 500) {
    this.animate({
        duration: time,
        timing: function (timeFraction) {
            return Math.pow(timeFraction, 2);
        },
        draw: function (progress) {
            console.log(line.dataset.endx);
            console.log(line.x1.baseVal.value);
            console.log(progress);

            line.x2.baseVal.value = line.dataset.endx - progress * (line.dataset.endx - line.x1.baseVal.value);
        },
    });
};

SvgArrowFlow.prototype.playNext = function (index, isAllAtOnce = false) {
    if (this.gotoNextSlide) return false;
    if (this.animationIndex == this.arrDiagramNode.length) {
        this.gotoNextSlide = true;
        return false;
    }

    if (this.arrCommonNodes.length > 0) {
        let initialElement = this.arrCommonNodes[0].getNodeParent();
        if (initialElement.style.opacity == 0) {
            initialElement.style.opacity = 1;
            initialElement.style.transition = "all 0.5s";
            setTimeout(() => {
                this.playNext();
            }, 300 * this.animationFactor);
            return true;
        }
    }

    this.showNodeAtIndex(this.animationIndex);

    this.animationIndex += 1;
    setTimeout(() => {
        if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, 1000 * this.animationFactor);
    return true;
};

SvgArrowFlow.prototype.playPrevious = function (index, isAllAtOnce = false) {
    this.animationIndex -= 1;
    let aIndex = this.animationIndex;

    if (aIndex < 0) return false;

    this.hideNodeAtIndex(aIndex);
    setTimeout(() => {
        if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, 1000 * this.animationFactor);
    return true;
};

// SvgArrowFlow.prototype.playAllAtOnce = function () {
//     this.playNext();
//     setTimeout(() => {
//         for (var i = 0; i < this.arrDiagramNode.length; i++) {
//             setTimeout(() => {
//                 this.playNext();
//             }, 1500 * i);
//         }
//     }, 1500);

//     return false;
// };

SvgArrowFlow.prototype.playAllAtOnce = function () {
    if (this.allAtOnceIndex > 0) return false;
    this.playNext(0, true);
    this.animateItemCount = 1;
    var interval = setInterval(() => {
        this.playNext(0, true);
        this.animateItemCount += 1;
        if (this.animationCompleteCallback && this.animateItemCount == this.arrDiagramNode.length) {
            setTimeout(() => {
                this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
            }, 1000 * this.animationFactor);
            clearInterval(interval);
        }
    }, 1000 * this.animationFactor);
    this.allAtOnceIndex += 1;
    return true;
};

SvgArrowFlow.prototype.playAllAtOnceReverse = function () {
    this.playPrevious();

    setTimeout(() => {
        for (var i = 0; i < this.arrDiagramNode.length - 1; i++) {
            setTimeout(() => {
                this.playPrevious();
            }, 1000 * i * this.animationFactor);
        }
    }, 2000 * this.animationFactor);

    let time = 1500 * this.arrDiagramNode.length;
    setTimeout(() => {
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, time * this.animationFactor);
    return true;
};

SvgArrowFlow.prototype.animateArrowForward = function (index) {};

SvgArrowFlow.prototype.animateArrowBackward = function (index) {};

SvgArrowFlow.prototype.animate = function (options) {
    var start = performance.now();
    requestAnimationFrame(function animate(time) {
        var timeFraction = (time - start) / options.duration;
        if (timeFraction > 1) timeFraction = 1;
        var progress = options.timing(timeFraction);
        options.draw(progress);
        if (timeFraction < 1) {
            requestAnimationFrame(animate);
        }
    });
};

//emphasis related function

SvgArrowFlow.prototype.emphasize = function (emphasizeData) {
    LinearDiagram.prototype.emphasize.call(this, emphasizeData);
    this.updateShapeEmphasis();
};

SvgArrowFlow.prototype.updateEmphasize = function () {
    LinearDiagram.prototype.updateEmphasize.call(this);
    this.updateShapeEmphasis();
};

SvgArrowFlow.prototype.updateShapeEmphasis = function () {
    let centerNode = this.diagramParent.querySelector("[id='pyramidsvg']");
    if (!centerNode) return;
    let arrPath = Array.from(centerNode.querySelectorAll("path"));
    this.arrDiagramNode.map(
        function (node, i) {
            let nodeParent = node.parentNode.parentElement;
            let path = arrPath[i];
            let emphasizeEnableClass = "clsTimelineEmphasisEnable"; //this.diagramData.properties.isfillbg ? "clsEmphasisEnabledBG" : "clsEmphasisEnabled";
            let emphasizeDisableClass = "clsTimelineEmphasisDisable"; //this.diagramData.properties.isfillbg ? "clsEmphasisDisabledBG" : "clsEmphasisDisabled";
            if (path) {
                path.classList.remove(emphasizeEnableClass);
                path.classList.remove(emphasizeDisableClass);
                if (nodeParent && path && nodeParent.classList.contains("clsEmphasisEnabled")) {
                    path.classList.add(emphasizeEnableClass);
                } else if (path && nodeParent.classList.contains("clsEmphasisDisabled")) {
                    path.classList.add(emphasizeDisableClass);
                } else if (path) {
                    path.classList.remove("clsEmphasisEnabledBG");
                    path.classList.remove("clsEmphasisEnabled");
                    path.classList.remove("clsEmphasisDisabledBG");
                    path.classList.remove("clsEmphasisDisabled");
                }
            }
        }.bind(this)
    );
};

SvgArrowFlow.prototype.showHideSecondary = function (value) {
    LinearDiagram.prototype.showHideSecondary.call(this, value);
    this.updateFrame();
};

SvgArrowFlow.prototype.updateDateFormat = function (obj) {
    this.arrDiagramNode.forEach((node) => node.updateDateFormat?.(obj));
};

"use strict";

function NonlinearTimeline(diagramParent, diagramData, nodeProps, moodData = {}) {
    SimpleLinearVerticalDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "roadmaptimeline";
    this.diagramParent.parentElement.setAttribute("data-allowdefaultanimation", "true");
    this.isRenderComplete = false;
    this.diagramParent.setAttribute("data-toggleassets", "true");
    this.diagramParent.setAttribute("data-togglecategory", "hor-road-timeline-tx-sty-a-1-sec");
    this.diagramParent.setAttribute("data-currencyformat", "disable");

    if (diagramParent) diagramParent.style.opacity = 1;

    let slide = document.querySelector(".clsSlide");
    if (slide) slide.classList.remove("commonLayout");
}

NonlinearTimeline.prototype = Object.create(SimpleLinearVerticalDiagram.prototype);
NonlinearTimeline.prototype.constructor = NonlinearTimeline;

NonlinearTimeline.prototype.initDiagramCreation = function () {
    if (!this.isTempSlide) this.diagramParent.style.opacity = 0;
    this.diagramParent.innerHTML = "";
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.createPatternBackGround();
    if (this.nodeProps && this.nodeProps.name && this.nodeProps.name.split("-")[0] && this.nodeProps.name.split("-")[1]) {
        this.diagramParent.setAttribute("data-togglecategory", this.nodeProps.name.split("-")[0] + "-" + this.nodeProps.name.split("-")[1]);
    }
};

NonlinearTimeline.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    let centerNodeStyle = this.nodeProps.centerNodeStyle || "";
    pattenDiv.className = "clsNodesHolderTimeline " + centerNodeStyle;
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.appendChild(pattenDiv);

    this.createNodeInstances(nodeCount, pattenDiv);

    let svgBotttom = this.diagramParent.dataset.graphicmenuname == "flimreeltimeline" ? "unset" : "0px";
    this.diagramParent.style.setProperty("--svgbottom", svgBotttom);

    this.diagramParent.setAttribute("data-toggleassets", "true");
    this.diagramParent.setAttribute("data-togglecategory", "ver");
    this.setupSvgBase();
    if (this.nodeProps.centerShape) this.loadSvg(this.nodeProps.centerShape);
};

NonlinearTimeline.prototype.diagramRenderComplete = function () {
    if (this.completeCallBack && this.completeCallBack.func && this.isRenderComplete) {
        LinearDiagram.prototype.diagramRenderComplete.call(this);
    }
};

NonlinearTimeline.prototype.recreateElementData = function (contentData = { id: "", value: "", contenttype: "image" }) {
    SimpleLinearVerticalDiagram.prototype.recreateElementData.call(this);
    this.svgHolder = this.diagramParent.querySelector("[id='centerSvgHolder']");
    if (this.svgHolder) this.updateFrame();
};

NonlinearTimeline.prototype.loadSvg = function (centerShape) {
    if (this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.hasOwnProperty("isyearenable")) {
        this.diagramParent.style.setProperty("--yearDisplay", this.diagramData.properties.customproperties.isyearenable ? "flex" : "none");
    }

    let svgId = centerShape.id + this.arrDiagramNode.length + "node";
    let objAssets = { id: svgId, value: this.appStaticURL + centerShape.value + svgId + ".svg" };
    DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body)
        .then((svgData) => {
            let svgNode = DiagramUtils.getSVGfromString(svgData.data);
            let dimensions = DiagramNodeUtils.getAssetDimensions(svgNode);
            let svgHolder = this.diagramParent.querySelector("[id='centerSvgHolder']");
            if (svgHolder) {
                svgHolder.innerHTML = "";
                svgHolder.style.width = dimensions.width + "px";
                svgHolder.style.height = dimensions.height + "px";
                DiagramNodeUtils.applyColorToNonLinearAssets(svgNode, svgData.id, this.arrTintArray);
                svgHolder.appendChild(svgNode);
                this.svgHolder = svgHolder;
            }
            this.recreateElementData();
            this.updateFrame();
            this.updateEmphasize();
            this.isRenderComplete = true;
            this.diagramRenderComplete();
            this.diagramParent.style.opacity = 1;
        })
        .catch((error) => {
            console.log("SVG asset load fail - " + error);
            this.isRenderComplete = true;
            this.diagramRenderComplete();
        });
};

NonlinearTimeline.prototype.setupSvgBase = function () {
    let svgHolder = document.createElement("div");
    svgHolder.className = "centerSvgHolder";
    svgHolder.id = "centerSvgHolder";
    this.diagramParent.appendChild(svgHolder);
};

NonlinearTimeline.prototype.updateFrame = function () {
    let svgBotttom = this.diagramParent.dataset.graphicmenuname == "flimreeltimeline" ? "unset" : "0px";
    this.diagramParent.style.setProperty("--svgbottom", svgBotttom);

    let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    nodeHolder.style.top = this.svgHolder.offsetTop + "px";
    nodeHolder.style.left = this.svgHolder.offsetLeft + "px";
    nodeHolder.style.width = this.svgHolder.clientWidth + "px";
    nodeHolder.style.height = this.svgHolder.clientHeight + "px";

    let arrBgColorElement = Array.from(this.svgHolder.querySelectorAll("[id*='bgcolor']"));
    arrBgColorElement.map((element) => {
        element.removeAttribute("fill");
        element.setAttribute("class", "background-fill");
    });

    let arrNodeGroup = Array.from(this.svgHolder.querySelectorAll("[id*='-point']")).reverse();
    arrNodeGroup.map(
        function (point, i) {
            try {
                // point.setAttribute("class", "clsAccentfill");
                let node = this.arrDiagramNode[i];

                let nodeRect = point.getBBox();
                let svgtext = point.querySelector("[id*='-content']");
                let textRect = svgtext.getBBox();

                let name = node.parentNode.querySelector("[data-id='contenticonparent']") ? "icon" : "image";

                let svgcontent = point.querySelector("[data-name='" + name + "']"); //node.objData.content.contenttype

                if (node && svgcontent) {
                    let contentRect = svgcontent.getBBox();

                    let nodeParent = node.getNodeParent().parentElement;
                    nodeParent.style.top = nodeRect.y + "px";
                    nodeParent.style.left = nodeRect.x + "px";
                    nodeParent.style.width = nodeRect.width + "px";
                    nodeParent.style.height = nodeRect.height + "px";

                    let content = nodeParent.querySelector("[data-id='diagramContentNode']");
                    content.style.top = contentRect.y - nodeRect.y + "px";
                    content.style.left = contentRect.x - nodeRect.x + "px";
                    content.style.setProperty("--contentwidth", contentRect.width + "px");
                    content.style.setProperty("--contentheigth", contentRect.height + "px");

                    let text = nodeParent.querySelector("[name='secContentNode']");
                    text.style.top = textRect.y - nodeRect.y + "px";
                    text.style.left = textRect.x - nodeRect.x + "px";
                    text.style.width = textRect.width + "px";
                    text.style.height = textRect.height + "px";

                    nodeParent.classList.remove("clsRightAlignment");
                    nodeParent.classList.remove("clsLeftAlignment");
                    svgtext.id.includes("right") ? nodeParent.classList.add("clsRightAlignment") : nodeParent.classList.add("clsLeftAlignment");

                    if (svgcontent.firstElementChild) {
                        let clippath = svgcontent.firstElementChild.getAttribute("clip-path") || "";
                        let imgPatent = nodeParent.querySelector("[data-id='contentimageparent']");
                        if (imgPatent) {
                            imgPatent.style.setProperty("clip-path", clippath);
                            imgPatent.style.setProperty("-webkit-clip-path", clippath);
                        }
                    }

                    let arrImageDOM = point.querySelectorAll("image");
                    for (let i = 0; i < arrImageDOM.length; i++) {
                        let imageDOM = arrImageDOM[i];
                        let strAssetPrefixURL = this.appStaticURL + "genericassets/shapes/";
                        let strPath = imageDOM.getAttribute("xlink:href").replace(strAssetPrefixURL, "");
                        imageDOM.setAttribute("xlink:href", strAssetPrefixURL + strPath);
                    }

                    node.updateNodeAttributes(i);
                    this.removDefaultNodeAnimation(node);
                }
            } catch (error) {
                console.log("Erron in updateFrame - " + error);
            }
        }.bind(this)
    );
};

NonlinearTimeline.prototype.addNode = function (nodeJSON, index, isFromUndo = false) {
    SimpleLinearVerticalDiagram.prototype.addNode.call(this, nodeJSON, index, isFromUndo);
    if (this.nodeProps.centerShape) this.loadSvg(this.nodeProps.centerShape);
};

NonlinearTimeline.prototype.deleteNode = function (targetIndex) {
    SimpleLinearVerticalDiagram.prototype.deleteNode.call(this, targetIndex);
    if (this.nodeProps.centerShape) this.loadSvg(this.nodeProps.centerShape);
};

NonlinearTimeline.prototype.slideDimensionChange = function () {
    if (this.nodeProps.centerShape) this.loadSvg(this.nodeProps.centerShape);
};

NonlinearTimeline.prototype.removDefaultNodeAnimation = function (node) {
    node.getNodeParent().parentElement.removeAttribute("data-animation");
    node.getNodeParent().parentElement.classList.remove("moodanimation");
    let arrObj = Array.from(node.getNodeParent().parentElement.querySelectorAll("[data-animation]"));
    arrObj.map((item) => {
        item.removeAttribute("data-animation");
        item.classList.remove("moodanimation");
    });
};

NonlinearTimeline.prototype.setupAnimation = function (animationType, callback) {
    this.animationCompleteCallback = callback;
    this.animationType = animationType;
    this.highlightIndex = -1;

    this.animationCount = 0;
    this.diagramParent.style.opacity = 0;
    let arrShape = Array.from(this.diagramParent.querySelectorAll("[data-name='shape']"));

    arrShape.map(
        function (shape, index) {
            shape.setAttribute("style", "opacity: 0; transition:all 0s; transform: translateY(-50px)");

            let node = this.arrDiagramNode[index];
            if (node) {
                this.hideNode(node.getNodeParent().parentElement);
            }
        }.bind(this)
    );

    this.animationFactor = this.diagramParent.parentElement.dataset.moodanimation && this.diagramParent.parentElement.dataset.moodanimation == "none" ? 0 : 1;
    this.diagramParent.style.transition = "all " + 0.3 * this.animationFactor + "s";
    this.diagramParent.style.opacity = 1;

    if (animationType == "all") this.playAllAtOnce();
    else this.animationCompleteCallback?.fn?.(this.animationCompleteCallback.params);
};

NonlinearTimeline.prototype.playNext = function () {
    if (this.animationCount == this.arrDiagramNode.length) {
        if (this.moodData.animationData.isHideAnimation) {
            this.diagramParent.style.transition = "all " + this.animationFactor + "s";
            this.diagramParent.style.opacity = 0;
        }
        return false;
    }

    this.animationCount += 1;

    let arrShape = Array.from(this.diagramParent.querySelectorAll("[data-name='shape']")).reverse();
    let shape = arrShape[this.animationCount - 1];
    if (shape) {
        shape.setAttribute("style", "opacity: 1; transition:all " + 0.4 * this.animationFactor + "s; transform: translateY(0px)");
    }

    let node = this.arrDiagramNode[this.animationCount - 1];
    if (node) {
        this.showNode(node.getNodeParent().parentElement);
    }

    if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    return true;
};

NonlinearTimeline.prototype.playPrevious = function () {
    if (this.animationCount == 0) {
        this.diagramParent.style.transition = "all " + this.animationFactor + "s";
        this.diagramParent.style.opacity = 0;
        return false;
    }

    this.animationCount -= 1;

    let arrShape = Array.from(this.diagramParent.querySelectorAll("[data-name='shape']")).reverse();
    let shape = arrShape[this.animationCount];
    if (shape) {
        shape.setAttribute("style", "opacity: 0; transition:all " + 0.4 * this.animationFactor + "s; transform: translateY(-50px)");
    }

    let node = this.arrDiagramNode[this.animationCount];
    if (node) {
        this.hideNode(node.getNodeParent().parentElement, this.animationFactor == 1);
    }

    if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    return true;
};

NonlinearTimeline.prototype.playAllAtOnce = function () {
    let arrShape = Array.from(this.diagramParent.querySelectorAll("[data-name='shape']")).reverse();
    if (this.animationCount == this.arrDiagramNode.length) {
        this.diagramParent.style.transition = "all " + this.animationFactor + "s";
        this.diagramParent.style.opacity = 0;
        return false;
    }
    this.arrDiagramNode.map(
        function (node, index) {
            this.animationCount += 1;
            setTimeout(() => {
                this.showNode(node.getNodeParent().parentElement);

                let shape = arrShape[index];
                if (shape) {
                    shape.setAttribute("style", "opacity: 1; transition:all " + 0.5 * this.animationFactor + "s; transform: translateY(0px)");
                }
            }, 400 * index * this.animationFactor);
        }.bind(this)
    );

    setTimeout(() => {
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, 400 * this.arrDiagramNode.length * this.animationFactor);

    return true;
};

NonlinearTimeline.prototype.playAllAtOnceReverse = function () {
    let arrShape = Array.from(this.diagramParent.querySelectorAll("[data-name='shape']"));
    // if (this.animationCount == 0) {
    this.diagramParent.style.transition = "all " + this.animationFactor + "s";
    this.diagramParent.style.opacity = 0;
    // return false;
    // }
    this.arrDiagramNode.reverse().map(
        function (node, index) {
            this.animationCount -= 1;
            setTimeout(() => {
                this.hideNode(node.getNodeParent().parentElement, this.animationFactor == 1);

                let shape = arrShape[index];
                if (shape) {
                    shape.setAttribute("style", "opacity: 0; transition:all " + 0.5 * this.animationFactor + "s; transform: translateY(-50px)");
                }
            }, 400 * index * this.animationFactor);
        }.bind(this)
    );
    return false;
    this.arrDiagramNode.reverse();
    return true;
};

NonlinearTimeline.prototype.showNode = function (nodeItem, isAnimation = false, delay = 0) {
    let content = nodeItem.querySelector("[data-id*='diagramContentNode']");
    content.style.transition = "all " + 0.4 * this.animationFactor + "s " + delay * this.animationFactor + "s";
    delay = delay + 0.1;
    content.style.transform = "translateY(0px)";
    content.style.setProperty("opacity", 1, "important");

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    if (seconday) {
        seconday.style.transition = "all " + 0.4 * this.animationFactor + "s " + delay * this.animationFactor + "s";
        delay = delay + 0.1;
        seconday.style.transform = "translateY(0px)";
        seconday.style.setProperty("opacity", 1, "important");
    }

    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    if (primary) {
        primary.style.transition = "all " + 0.4 * this.animationFactor + "s " + delay * this.animationFactor + "s";
        delay = delay + 0.1;
        primary.style.transform = "translateY(0px)";
        primary.style.setProperty("opacity", 1, "important");
    }

    let number = nodeItem.querySelector("[data-id='numberNode']");
    if (number) {
        number.style.transition = "all " + 0.4 * this.animationFactor + "s " + delay * this.animationFactor + "s";
        delay = delay + 0.1;
        number.style.transform = "translateY(0px)";
        number.style.setProperty("opacity", 1, "important");
    }
};

NonlinearTimeline.prototype.hideNode = function (nodeItem, isAnimate = false, delay = 0) {
    let durationFactor = isAnimate ? "0.4" : "0";
    let delayFactor = isAnimate ? 1 : 0;

    let content = nodeItem.querySelector("[data-id*='diagramContentNode']");
    content.style.transition = "all " + durationFactor + "s " + delay * delayFactor + "s";
    delay = delay + 0.1;
    content.style.transform = "translateY(-50px)";
    content.style.setProperty("opacity", 0, "important");

    let number = nodeItem.querySelector("[data-id='numberNode']");
    if (number) {
        number.style.transition = "all " + durationFactor + "s " + delay * delayFactor + "s";
        delay = delay + 0.1;
        number.style.transform = "translateY(-50px)";
        number.style.setProperty("opacity", 0, "important");
    }

    let primary = nodeItem.querySelector("[data-id*='primaryTextNode']");
    if (primary) {
        primary.style.transition = "all " + durationFactor + "s " + delay * delayFactor + "s";
        delay = delay + 0.1;
        primary.style.transform = "translateY(-50px)";
        primary.style.setProperty("opacity", 0, "important");
    }

    let seconday = nodeItem.querySelector("[data-id*='secondaryTextNode']");
    if (seconday) {
        seconday.style.transition = "all " + durationFactor + "s " + delay * delayFactor + "s";
        delay = delay + 0.1;
        seconday.style.transform = "translateY(-50px)";
        seconday.style.setProperty("opacity", 0, "important");
    }
};

NonlinearTimeline.prototype.initPresent = function (currentSlideData) {
    this.diagramParent = currentSlideData.querySelector("[id='diagramparent']");

    if (this.diagramParent.parentElement.dataset.animationtype && this.diagramParent.parentElement.dataset.animationtype == "none") return { isTitleAnimation: false, isGraphicAnimation: false };

    if (this.diagramParent) this.diagramParent.style.opacity = 0;

    return { isTitleAnimation: true, isGraphicAnimation: false };
};

NonlinearTimeline.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearVerticalDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable.push("animateoneatatime");
        mainProperties.floateroptionsdisable.push("arrange");
        mainProperties.floateroptionsdisable.push("graphicnone");
        mainProperties.floateroptionsdisable.push("swap");
    } else mainProperties.floateroptionsdisable = ["animateoneatatime", "arrange", "graphicnone", "swap"];
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

NonlinearTimeline.prototype.defaultFoucsOut = function (event) {
    if (event.target.innerText.trim() == "" && !event.target.id.includes("secondaryText")) event.target.innerHTML = "";
    else if (event.target.id.includes("secondaryText")) {
        let contentNode = event.target.querySelector("[name='contentNode']");
        if (contentNode) return;
    }
    this.updateTextNodes();

    let typedText = event.target.dataset && event.target.dataset.oldtext ? event.target.dataset.oldtext : "";
    if (event.target.innerText != typedText && this.appmode != "PRESENT") {
        this.eventManagerXY.dispatch("focusout", event.target);
        event.target.dataset.oldtext = event.target.innerHTML;
        this.updatePropsCallBack();
        this.resetNodeAttributes();
    }
    if (event.target.dataset.id == "numberNode") {
        // DiagramNodeUtils.checkNumberFormat(event.target, this.diagramParent, this.moodData);
        this.updatePropsCallBack();
        return;
    }
    this.checkContentType();
    // this.searchIcon(event.target.innerText, nodeItem, event.target.dataset.index, this.diagramData.properties.contenttype);
};

NonlinearTimeline.prototype.setDiagramSpecficOption = function (obj) {
    obj.dpcontent.floatdiagramsettings.year = { isOn: this.diagramData.properties.customproperties.isyearenable, property: "Year", label: "Year" };
    obj.dpcontent.slidecomponent = { bgImage: false, takeAwayText: false };
    obj.isDisableLayoutOption = "true";

    delete obj.dpcontent.floatdiagramsettings.graphicimagesize;
    delete obj.dpcontent.floatdiagramsettings.graphicvalueformat;
    obj.dpcontent.floatdiagramsettings.dateformat = DiagramUtils.getDateFormatInlineData(this);
};

NonlinearTimeline.prototype.updateDateFormat = function (obj) {
    this.arrDiagramNode.forEach((node) => node.updateDateFormat?.(obj));
};

NonlinearTimeline.prototype.showHideYear = function (operation) {
    this.diagramParent.setAttribute("data-isyearenable", operation.value);
    this.diagramData.properties.customproperties.isyearenable = operation.value;
    this.diagramParent.style.setProperty("--yearDisplay", operation.value ? "flex" : "none");
};

NonlinearTimeline.prototype.customproperties = function () {
    return {
        isyearenable: !this.diagramParent.dataset.hasOwnProperty("isyearenable") || this.diagramParent.dataset.isyearenable == "true",
    };
};

NonlinearTimeline.prototype.getProperties = function (defaultproperties = {}) {
    let properties = SimpleLinearVerticalDiagram.prototype.getProperties.call(this, defaultproperties);
    properties.customproperties = this.customproperties();
    return properties;
};

NonlinearTimeline.prototype.setPropertiesFromConstants = function (mainObj, constArrProperties, extraAttrib = "") {
    SimpleLinearVerticalDiagram.prototype.setPropertiesFromConstants.call(this, mainObj, constArrProperties, extraAttrib);
    if (this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.hasOwnProperty("isyearenable")) {
        this.diagramParent.setAttribute("data-isyearenable", this.diagramData.properties.customproperties.isyearenable);
    }
};

NonlinearTimeline.prototype.emphasize = function (emphasizeData) {
    SimpleLinearVerticalDiagram.prototype.emphasize.call(this, emphasizeData);
    this.updateShapeEmphasis();
};

NonlinearTimeline.prototype.updateEmphasize = function () {
    SimpleLinearVerticalDiagram.prototype.updateEmphasize.call(this);
    this.updateShapeEmphasis();
};

NonlinearTimeline.prototype.updateShapeEmphasis = function () {
    let enableClass = "clsTimelineEmphasisEnable";
    let disableClass = "clsTimelineEmphasisDisable";
    this.arrDiagramNode.forEach(
        function (node, i) {
            let nodeNonlinear = this.diagramParent.querySelector("[name='nodeNonlinearMainParent'][id*='-point" + (i + 1) + "']");
            if (nodeNonlinear) {
                nodeNonlinear.classList.remove(enableClass);
                nodeNonlinear.classList.remove(disableClass);
                let nodeParent = node.parentNode.parentElement;
                if (nodeParent.classList.contains("clsEmphasisEnabled")) {
                    nodeNonlinear.classList.add(enableClass);
                } else if (nodeParent.classList.contains("clsEmphasisDisabled")) {
                    nodeNonlinear.classList.add(disableClass);
                }
            }
        }.bind(this)
    );
};

NonlinearTimeline.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    if (strSelectionType == "primaryText" || strSelectionType == "numberNode") this.getFontSizeDataForInlineFloater(dict, elTarget);

    delete dict.changesize;
};

NonlinearTimeline.prototype.allowContentResize = function () {};

NonlinearTimeline.prototype.changeSize = function () {};

/**
 * Author:    Krishna
 * Created:   1 July 2020
 *
 * (c) Copyright by Krishna.
 **/

"use strict";

function LineaerSwotDiagram(diagramParent, diagramData, nodeProps, moodData = {}) {
    SimpleLinearVerticalDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "linearswot";
    // this.diagramParent.parentElement.setAttribute("data-allowdefaultanimation", "true");

    let slide = document.querySelector(".clsSlide");
    if (slide) slide.classList.remove("commonLayout");
}

LineaerSwotDiagram.prototype = Object.create(SimpleLinearVerticalDiagram.prototype);
LineaerSwotDiagram.prototype.constructor = LineaerSwotDiagram;

LineaerSwotDiagram.prototype.initDiagramCreation = function() {
    this.diagramParent.innerHTML = "";
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.createPatternBackGround();
};

LineaerSwotDiagram.prototype.createElements = function() {
    // this.diagramParent.style.opacity = 0;
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    let centerNodeStyle = this.nodeProps.centerNodeStyle || "";
    pattenDiv.className = "clsNodesHolderSwot " + centerNodeStyle;
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.appendChild(pattenDiv);

    this.createNodeInstances(nodeCount,pattenDiv);

    this.diagramParent.setAttribute("data-toggleassets", "true");
    this.diagramParent.setAttribute("data-togglecategory", "ver");

    this.setupSwotBase();
};

LineaerSwotDiagram.prototype.setupSwotBase = function() {
    this.arrSwotItems = [];

    if (this.swotbase != null && this.swotbase.parentElement) {
        this.swotbase.parentElement.removeChild(this.swotbase);
    }

    let primaryText = this.diagramParent.querySelector("[data-id='primaryText']");

    if (!primaryText) return;

    let rgbaColor = "rgba(var(--secondary-color-rgb),0.4)";

    let swotBase = this.createDiv(this.diagramParent, "swotbase");
    swotBase.id = "swotbase";
    this.swotbase = swotBase;

    let swotItemLT = this.createDiv(swotBase, "swotitem moodanimation", "itemborder");
    swotItemLT.id = "swotItemLT";
    let lblS = this.createDiv(swotItemLT, "lbls common clsContrastColor background-item2-color h8 moodanimation", "item");
    lblS.innerText = "S";
    swotItemLT.style.borderColor = rgbaColor;
    this.arrSwotItems.push(swotItemLT);

    let swotItemRT = this.createDiv(swotBase, "swotitem moodanimation", "itemborder");
    swotItemRT.id = "swotItemRT";
    let lblW = this.createDiv(swotItemRT, "lblw common clsContrastColor background-item2-color h8 moodanimation", "item");
    lblW.innerText = "W";
    swotItemRT.style.borderColor = rgbaColor;
    this.arrSwotItems.push(swotItemRT);

    let swotItemBL = this.createDiv(swotBase, "swotitem moodanimation", "itemborder");
    swotItemBL.id = "swotItemBL";
    let lblO = this.createDiv(swotItemBL, "lblo common clsContrastColor background-item3-color h8 moodanimation", "item");
    lblO.innerText = "O";
    swotItemBL.style.borderColor = rgbaColor;
    this.arrSwotItems.push(swotItemBL);

    let swotItemBR = this.createDiv(swotBase, "swotitem moodanimation", "itemborder");
    swotItemBR.id = "swotItemBR";
    let lblT = this.createDiv(swotItemBR, "lblt common clsContrastColor background-item4-color h8 moodanimation", "item");
    lblT.innerText = "T";
    swotItemBR.style.borderColor = rgbaColor;
    this.arrSwotItems.push(swotItemBR);

    this.updateFrame();
    this.diagramRenderComplete();
};

LineaerSwotDiagram.prototype.createDiv = function(parent, className, animationName = "") {
    let div = document.createElement("div");
    div.className = className;
    div.setAttribute("data-animation", animationName);
    parent.appendChild(div);
    return div;
};

LineaerSwotDiagram.prototype.updateFrame = function(isShowLable = true) {
    this.arrSwotItems = this.diagramParent.querySelectorAll("[id*='swotItem']");
    if (this.arrSwotItems.length != this.arrDiagramNode.length) return;
    for (var i = 0; i < this.arrDiagramNode.length; i++) {
        let item = this.arrSwotItems[i];
        let node = this.arrDiagramNode[i].getNodeParent().parentElement;

        let contentNode = node.querySelector("[data-id='diagramContentNode']");
        if (contentNode) contentNode.removeAttribute("data-animation");

        let offsetX = item.offsetLeft + item.parentElement.offsetLeft + 4;
        let offsetY = item.offsetTop + item.parentElement.offsetTop + 3;

        let lblWidth = isShowLable ? item.firstElementChild.clientWidth + 20 : 20;

        let isRightSideElement = i == 1 || i == 3;
        node.style.top = offsetY + "px";
        node.style.left = isRightSideElement ? offsetX + lblWidth + "px" : offsetX + "px";
        node.style.width = (item.clientWidth - lblWidth) + "px";
        node.style.height = (item.clientHeight) + "px";
        node.className = isRightSideElement ? "clsMultiColorParent clsNodeParentMain clsRightAlignment" : "clsMultiColorParent clsNodeParentMain clsLeftAlignment";
        node.removeAttribute("data-animation");        
    }
};

LineaerSwotDiagram.prototype.slideDimensionChange = function() {
    this.updateFrame();
};

LineaerSwotDiagram.prototype.removDefaultNodeAnimation = function(node) {
    node.getNodeParent().parentElement.removeAttribute("data-animation");
    node.getNodeParent().parentElement.classList.remove("moodanimation");
    let arrObj = Array.from(node.getNodeParent().parentElement.querySelectorAll("[data-animation]"));
    arrObj.map((item) => {
        item.removeAttribute("data-animation");
        item.classList.remove("moodanimation");
    });
};

LineaerSwotDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearVerticalDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable.push("content");
        mainProperties.floateroptionsdisable.push("emphasize");
        mainProperties.floateroptionsdisable.push("arrange");
        mainProperties.floateroptionsdisable.push("swap");
    } else mainProperties.floateroptionsdisable = ["content", "emphasize", "arrange","swap"];
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};
/**
 * Author:    Krishnan M.
 * Created:   5 Aug 2020
 **/

"use strict";

function NonlinearCircleDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearVerticalDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "clsLinerDiagram nonlinearcircle";
    diagramParent.setAttribute("data-diagramtype", "vertical");
    this.isRenderComplete = false;
}

NonlinearCircleDiagram.prototype = Object.create(SimpleLinearVerticalDiagram.prototype);
NonlinearCircleDiagram.prototype.constructor = NonlinearCircleDiagram;

NonlinearCircleDiagram.prototype.initDiagramCreation = function () {
    if (!this.isTempSlide) this.diagramParent.style.opacity = 0;
    this.diagramParent.innerHTML = "";
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.createPatternBackGround();
};

NonlinearCircleDiagram.prototype.createPatternBackGround = function () {
    this.createElements();
    // DiagramUtils.searchMultipleAICall(this.arrDiagramNode,this.diagramData.properties.contenttype, this.diagramData.properties, this.globalMoodData, this.searchIconCallBack, appBaseURL, this.appStaticURL);
};

NonlinearCircleDiagram.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsNodesHolderSvg";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    pattenDiv.setAttribute("data-node", nodeCount + "nodes");
    this.diagramParent.appendChild(pattenDiv);
    this.diagramParent.setAttribute("data-parenttype", "nonlinearcircular");
    // this.diagramParent.setAttribute("data-togglelists", "true");
    let contentSize = (pattenDiv.offsetHeight - (nodeCount - 1) * this.nodeGap) / nodeCount;
    this.height = this.nodeProps.centerShape.height || 100;
    this.marginleft = this.nodeProps.centerShape.marginleft || null;
    this.align = (this.nodeProps.centerShape.position && this.nodeProps.centerShape.position.split(",")[1]) || "top";
    this.basealign = (this.nodeProps.centerShape.position && this.nodeProps.centerShape.position.split(",")[0]) || "horizontal";
    this.diagramParent.setAttribute("data-align", this.align);
    this.diagramParent.setAttribute("data-basealign", this.basealign);
    this.diagramParent.setAttribute("data-disablelinearcontent", "true");
    this.diagramParent.setAttribute("data-nonlinearcontentoptions", "true");

    pattenDiv.style.setProperty("--nodeWidth", "auto");
    pattenDiv.style.setProperty("--contentNodeWidth", "48px");
    pattenDiv.style.setProperty("--contentNodeHeight", "48px");
    pattenDiv.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    pattenDiv.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    pattenDiv.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    pattenDiv.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    pattenDiv.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");

    let circleWidth = (contentSize / 100) * 50;
    pattenDiv.style.setProperty("--circleSize", circleWidth + "px");

    this.createNodeInstances(nodeCount, pattenDiv);

    if (this.diagramData.properties.sequencetext && this.diagramData.properties.diagramcontent) this.showHideContent({ value: true });
    this.createDeviceHolder(pattenDiv, this.nodeProps.centerShape);
};

NonlinearCircleDiagram.prototype.recreateElementData = function (contentData = { id: "", value: "", contenttype: "image" }) {
    SimpleLinearVerticalDiagram.prototype.recreateElementData.call(this);
    let pattenDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    let centerItem = new window[this.nodeProps.nodeclassName](
        pattenDiv,
        {},
        // {
        //     content:
        //         this.centerholderdata && this.centerholderdata.value != ""
        //             ? this.centerholderdata
        //             : this.centerHolderNode && this.centerHolderNode.objData.content.value != ""
        //             ? this.centerHolderNode.objData.content
        //             : contentData,
        // },
        { content: this.centerholderdata ? this.centerholderdata : contentData },
        this.eventManagerXY,
        0,
        "",
        this.objStyleData,
        this.appStaticURL,
        this.nodeProps,
        this.diagramParent
    );
    let outerDiv = pattenDiv.querySelector("[data-id='outerDiv']");
    if (outerDiv) outerDiv.setAttribute("data-type", "device");
    centerItem.moodData = this.moodData;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;
    this.centerHolderNode = centerItem;
    this.centerHolderNode.parentNode = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    this.centerHolderNode.nodeGroup = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    this.centerNode = this.diagramParent.querySelector("div[data-id=deviceHolderParent]");
};

NonlinearCircleDiagram.prototype.showHideOptions = function (value) {
    let contentVisible = value != "none" && value != "sequence";
    let numberVisible = value == "sequence";
    this.diagramParent.parentElement.style.setProperty("--contentdisplay", contentVisible ? "flex" : "none");
    this.diagramParent.setAttribute("data-content", contentVisible);
    this.diagramParent.setAttribute("data-nonlinearcontent", value);
    this.diagramData.properties.nonlinearcontent = value;
    this.diagramData.properties.diagramcontent = contentVisible;
    this.diagramParent.parentElement.style.setProperty("--numberdisplay", numberVisible ? "flex" : "none");
    this.diagramData.properties.sequencetext = numberVisible;
    this.updateProperties(this.diagramData.properties);
    this.slideDimensionChange();
};

NonlinearCircleDiagram.prototype.showHideContent = function (operation) {
    this.diagramParent.parentElement.style.setProperty("--contentdisplay", !operation.value ? "none" : "flex");
    this.diagramParent.setAttribute("data-content", operation.value);
    this.diagramData.properties.diagramcontent = operation.value;

    this.diagramParent.setAttribute("data-nonlinearcontent", operation.value);
    // if (this.diagramData.properties.sequencetext == true && operation.value == true) {
    this.diagramParent.parentElement.style.setProperty("--numberdisplay", operation.value ? "none" : "flex");
    this.diagramData.properties.sequencetext = !operation.value;
    // }

    this.updateProperties(this.diagramData.properties);
    this.slideDimensionChange();
};

NonlinearCircleDiagram.prototype.showHideNumber = function (operation) {
    this.diagramParent.parentElement.style.setProperty("--numberdisplay", !operation.value ? "none" : "flex");
    this.diagramData.properties.sequencetext = operation.value;

    // if (this.diagramData.properties.diagramcontent == true && operation.value == true) {
    this.diagramParent.parentElement.style.setProperty("--contentdisplay", operation.value ? "none" : "flex");
    this.diagramParent.setAttribute("data-content", !operation.value);
    this.diagramData.properties.diagramcontent = !operation.value;
    // }

    this.updateProperties(this.diagramData.properties);
    this.slideDimensionChange();
};

NonlinearCircleDiagram.prototype.slideDimensionChange = function () {
    let svgNode = this.diagramParent.querySelector("[data-id='svgNode']");
    let parentDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    let deviceHolder = this.diagramParent.querySelector("[data-id='deviceHolder']");
    this.centerNode = this.diagramParent.querySelector("div[data-id=deviceHolderParent]");
    if (svgNode && this.diagramData && this.centerNode) {
        this.setDimensionsForNodes(deviceHolder, svgNode, parentDiv, this.nodeProps.centerShape);
        this.centerNode.style.top = "unset";
        let offset = this.diagramData.nodes.length == 3 || this.diagramData.nodes.length == 5 ? this.centerNode.offsetTop + 50 + "px" : "unset";
        this.centerNode.style.setProperty("top", offset);
        let size = Math.min(this.diagramParent.clientWidth * 0.28, this.diagramParent.clientHeight * 0.7);
        this.centerNode.style.setProperty("--size", size + "px");
        this.refreshPosition(this.centerNode);
    }
};

NonlinearCircleDiagram.prototype.createDeviceHolder = function (parentDiv, centerShape) {
    let centerHolderParent = document.createElement("div");
    centerHolderParent.setAttribute("data-id", "deviceHolderParent");
    centerHolderParent.className = "deviceHolderParent";
    parentDiv.appendChild(centerHolderParent);

    let deviceHolder = document.createElement("div");
    deviceHolder.setAttribute("data-id", "deviceHolder");
    deviceHolder.className = "deviceHolder moodanimation";
    deviceHolder.setAttribute("data-animation", "commonplaceholder");
    centerHolderParent.appendChild(deviceHolder);

    this.diagramParent.setAttribute("data-center-shape-type", centerShape.type ? centerShape.type : "svg");
    // let svgId = centerShape.id + this.arrDiagramNode.length + "node";
    let diagramstyle = DiagramUtils.checkDiagramStyle(this.globalMoodData.basicgraphics, centerShape);
    let svgId = DiagramUtils.getSvgAssetId(centerShape, this.arrDiagramNode);
    let diagramStyleValue = DiagramUtils.checkAppStaticUrl(diagramstyle + svgId + ".svg", this.appStaticURL);
    let objAssets = { id: svgId, value: diagramStyleValue };

    DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body)
        .then((svgData) => {
            let svgNode = DiagramUtils.getSVGfromString(svgData.data);
            svgNode.setAttribute("class", "svgNode accent1-fill");
            svgNode.setAttribute("data-id", "svgNode");
            svgNode.setAttribute("data-type", "svg");
            svgNode.setAttribute("data-iconpath", svgData.value);
            svgNode.setAttribute("data-iconid", svgData.id);
            deviceHolder.appendChild(svgNode);
            // DiagramNodeUtils.replaceImagePathToNonLinearAssets(svgNode, this.appStaticURL + centerShape.value);
            DiagramNodeUtils.applyColorToNonLinearAssets(svgNode, svgData.id, this.arrTintArray);
            this.setDimensionsForNodes(deviceHolder, svgNode, parentDiv, centerShape);
            this.setupCommonPointContent(deviceHolder);
            this.centerNode = centerHolderParent;
            let size = Math.min(this.diagramParent.clientWidth * 0.28, this.diagramParent.clientHeight * 0.7);
            this.centerNode.style.setProperty("--size", size + "px");

            let offset = this.diagramData.nodes.length == 3 || this.diagramData.nodes.length == 5 ? this.centerNode.offsetTop + 50 + "px" : "unset";
            this.centerNode.style.setProperty("top", offset);
            this.refreshPosition(this.centerNode);
            this.updateEvents();
            // this.createCommonText();
            this.checkCenterNodeStyle();
            this.resetHolderWidth();
            this.resetNodeAttributes();
            this.updateJSONData();
            this.updateEmphasize();
            this.updateFloaterOperations();

            this.isRenderComplete = true;
            this.diagramRenderComplete();

            // let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
            // if (lastDiv) this.updatePropsCallBack(lastDiv.id);
        })
        .catch((error) => {
            console.log("SVG asset load fail - " + error);
            this.isRenderComplete = true;
            this.diagramRenderComplete();
        });
};

NonlinearCircleDiagram.prototype.setNumberIconNodes = function (pointNode, index, objData = {}, nodeParent, alignment, isFromInsert) {
    let connectorItem = pointNode.querySelector("[id*='connectorline']");
    if (connectorItem && !this.nodeProps.name.includes("convergent") && !this.nodeProps.name.includes("divergent")) {
        if (this.diagramData.properties.sequencetext == false && this.diagramData.properties.diagramcontent == false && this.diagramData.properties.primarytext == false && this.diagramData.properties.secondarytext == false) connectorItem.style.setProperty("display", "none");
        else connectorItem.style.removeProperty("display");
    }
    this.diagramParent.setAttribute("data-innercontent", "false");
    let placeHolder = pointNode.querySelector("[id*='-placeholder']");
    if (!placeHolder) {
        if (isFromInsert) this.toggleSeqContent();
        return false;
    }
    let contentRect = placeHolder.querySelector("[id*='-content']");
    let iconRect = placeHolder.querySelector("[id*='-icon']");
    let placeholderType = this.nodeProps.centerShape.placeholdertype;
    if (contentRect) {
        let arrCoords = DiagramUtils.getAbsCoordOfElement(contentRect, this.diagramParent, this.slideScale);
        nodeParent.style.setProperty("left", arrCoords.x + "px", "important");
        nodeParent.style.setProperty("top", arrCoords.y + "px", "important");
        nodeParent.style.setProperty("width", arrCoords.width + "px", "important");
        nodeParent.style.setProperty("height", arrCoords.height + "px", "important");
        // if (alignment == "vertical") {
        // this.diagramParent.style.setProperty("--nodesMaxHeight", arrCoords.height + "px");
        let secContent = nodeParent.querySelector("[name='secContentNode']");
        if (secContent) secContent.style.setProperty("max-height", arrCoords.height + "px", "important");
        // }
        let id = contentRect.getAttribute("id");
        if (id.includes("left")) {
            nodeParent.setAttribute("data-nodealign", "right");
        } else if (id.includes("right")) {
            nodeParent.setAttribute("data-nodealign", "left");
        } else if (id.includes("top")) {
            nodeParent.setAttribute("data-nodealign", "bottom");
        } else if (id.includes("bottom")) {
            nodeParent.setAttribute("data-nodealign", "top");
        } else {
            nodeParent.setAttribute("data-nodealign", "center");
        }
        nodeParent.style.setProperty("padding", "unset", "important");
        nodeParent.style.setProperty("padding-left", "unset", "important");
        nodeParent.style.setProperty("padding-right", "unset", "important");
        nodeParent.style.setProperty("padding-top", "unset", "important");
        nodeParent.style.setProperty("padding-bottom", "unset", "important");

        // Text Highlight
        let bgShape = pointNode.querySelector("[id*='bgcolor']");
        let colorShape = pointNode.querySelector("[id*='shape']");
        let arrHightlightNodes = nodeParent.querySelectorAll("[data-highlight-event='true']");

        arrHightlightNodes.forEach((element) => {
            element.classList.remove("titleColorBg");
            element.classList.remove("subtitleColorBg");
            element.classList.remove("transparentBg");
            element.classList.add(colorShape && !bgShape ? "titleColorBg" : "transparentBg");
        });
        //  this.bgColor.includes("accent") ? " titleColorBg " : this.bgColor.includes("secondary") ? " subtitleColorBg " : " transparentBg ";

        if (!placeholderType) return true;
    }
    if (iconRect) {
        let x = iconRect.getAttribute("x");
        let y = iconRect.getAttribute("y");
        let width = iconRect.getAttribute("width");
        let height = iconRect.getAttribute("height");
        iconRect.innerHTML = "";
        placeHolder.setAttribute("class", "moodanimation");
        placeHolder.setAttribute("data-animation", "item");
        let svgNode = DiagramNodeUtils.createSVGElement("svg");
        let isInnerColor = this.nodeProps.innerColor && this.nodeProps.innerColor == "inner";
        let svgItem = placeHolder.querySelector("[id='svgItem" + index + "']");
        if (svgItem) svgItem.remove();
        DiagramNodeUtils.assignAttributes(svgNode, {
            id: "svgItem" + index,
            width: width,
            height: height,
            "data-index": index,
            x: x,
            y: y,
            "data-maxwidth": width,
            "data-maxheight": height,
            // class: "moodanimation " + (isInnerColor ? "clsContrastFill" : "clsAccentfill"),
            class: isInnerColor ? "clsContrastFill" : "clsAccentfill",
            // "data-animation": "item",
        });
        let contentChangeNode = this.nodeProps && this.nodeProps.nodeclassName && this.nodeProps.nodeclassName.includes("ContentOptionNode");
        if ((!contentChangeNode && this.diagramData.properties.sequencetext == true) || (contentChangeNode && this.diagramParent.dataset.contenttype && this.diagramParent.dataset.contenttype == "sequence")) {
            pointNode.style.pointerEvents = "none";
            let content = DiagramUtils.getSeqMoodStyle(this.globalMoodData.seqnumproperties, this.diagramData.properties, "sequencenumber", index, this.diagramParent.dataset.nodecount);
            let textNode = DiagramNodeUtils.createSVGElement("text");
            textNode.setAttribute("text-anchor", "middle");
            textNode.setAttribute("class", "n1");
            let fontSize = DiagramNodeUtils.fitFontSize(textNode, index.toString(), width, height, 100, false, this.diagramParent);
            textNode.style.fontSize = fontSize + "px";
            let tspanNode = DiagramNodeUtils.createSVGElement("tspan");
            tspanNode.setAttribute("dx", "50%");
            tspanNode.setAttribute("dy", "1em");
            tspanNode.textContent = content;
            textNode.appendChild(tspanNode);
            svgNode.appendChild(textNode);
            svgNode.style.setProperty("overflow", "unset");
            this.diagramData.properties.diagramcontent = false;
            this.diagramData.properties.contenttype = "sequence";
            this.diagramParent.setAttribute("data-contenttype", "sequence");
            this.diagramParent.setAttribute("data-diagramcontent", "false");
            this.diagramParent.setAttribute("data-innercontent", "true");
        } else if ((!contentChangeNode && this.diagramData.properties.diagramcontent == true) || (contentChangeNode && this.diagramParent.dataset.contenttype && this.diagramParent.dataset.contenttype == "icon")) {
            pointNode.style.pointerEvents = "all";
            pointNode.setAttribute("data-type", "icon");
            pointNode.setAttribute("data-index", index - 1);
            pointNode.setAttribute("data-contentType", "icon");
            pointNode.setAttribute("data-node-content-type", "icon");
            placeHolder.setAttribute("data-contentType", "icon");
            placeHolder.setAttribute("data-node-content-type", "icon");
            svgNode.setAttribute("data-focus-parent", pointNode.id);
            svgNode.setAttribute("data-id", "iconNode");
            let useNode = DiagramNodeUtils.createSVGElement("use");
            let content = objData.content && objData.content.type == "icon" && objData.content.value && objData.content.value != "" ? objData.content : DiagramNodeUtils.diagramContentData("icon", this.appStaticURL, this.arrDefaults, index);
            svgNode.setAttribute("iconpath", content.value);
            content.id = DiagramNodeUtils.getIconName(content);
            if (!content.id || content.id == "") content.id = "placeholder";
            svgNode.setAttribute("iconid", content.id);
            content.value = DiagramUtils.checkAppStaticUrl(content.value, this.appStaticURL);
            DiagramAssetLoader.oneTimeDownload(content, true, document.body);
            DiagramNodeUtils.assignAttributes(useNode, {
                "xlink:href": "#" + content.id,
                class: isInnerColor ? "clsContrastFill" : "clsAccentfill",
                "data-id": "useNode",
                iconpath: content.value,
                iconid: content.id,
            });
            content.dataRef = null;
            svgNode.appendChild(useNode);
            this.diagramData.properties.sequencetext = false;
            this.diagramData.properties.contenttype = "icon";
            this.diagramParent.setAttribute("data-contenttype", "icon");
            this.diagramParent.setAttribute("data-sequencetext", "false");
            this.diagramParent.setAttribute("data-innercontent", "true");
            DiagramCreateUtil.updateManifest(content, this.manifestUpdater, this.appStaticURL);
        }
        placeHolder.appendChild(svgNode);
        let contentType = this.diagramData.properties.contenttype;
        if (contentType && contentChangeNode) this.switchContentBetweenNodeAndSvg(contentType, index - 1);
        else this.diagramParent.setAttribute("data-nomargin", contentType == "icon" || contentType == "sequence" || contentType == "none" ? "true" : "false");
        return false;
    }
};

NonlinearCircleDiagram.prototype.changeNumberReverse = function (value) {
    LinearDiagram.prototype.changeNumberReverse.call(this, value);
    this.slideDimensionChange();
};

NonlinearCircleDiagram.prototype.changeNumberStart = function (value) {
    LinearDiagram.prototype.changeNumberStart.call(this, value);
    this.slideDimensionChange();
};

NonlinearCircleDiagram.prototype.resizeNode = function (svgNode, alignment, position, parentDiv, deviceHolder) {};

NonlinearCircleDiagram.prototype.updateNodeData = function (nodeData, type, index, parentId) {
    if (parentId && parentId.includes("IMAGE")) {
        this.centerHolderNode.objData.content = nodeData;
        this.centerholderdata = this.centerHolderNode.objData;
        let imgNode = this.diagramParent.querySelector("[id='" + parentId + "']");
        imgNode.setAttribute("xlink:href", nodeData.value);
        return;
    }
    if (parentId && parentId.includes("centerHolderParent")) {
        this.centerHolderNode.objData.content = nodeData;
        this.centerholderdata = this.centerHolderNode.objData;
        if (this.arrDiagramNode && this.arrDiagramNode.length > index) {
            this.arrDiagramNode[index].updateContentData(nodeData, type, parentId);
        }
    } else if (type.includes("icon")) {
        let parentNode = this.diagramParent.querySelector("[id='" + parentId + "']");
        if (parentNode) {
            let iconNode = parentNode.querySelector("[data-id='useNode']");
            nodeData.id = DiagramNodeUtils.getIconName(nodeData);
            iconNode.setAttribute("xlink:href", "#" + nodeData.id);
            SimpleLinearDiagram.prototype.updateNodeData.call(this, nodeData, type, parentNode.getAttribute("data-index"), parentId);
        }
    } else {
        SimpleLinearDiagram.prototype.updateNodeData.call(this, nodeData, type, index);
    }
};

NonlinearCircleDiagram.prototype.getCenterHolderData = function () {
    let objData = {};
    let parent = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    if (parent) {
        let contentType = parent.dataset.contentType || "text";
        try {
            objData = this.centerHolderNode.getJSONData();
        } catch (error) {
            console.log(error);
        }
        let contentNode = parent.querySelector("[data-id='" + contentType + "Node']");
        if (contentNode) {
            objData.content = DiagramNodeUtils.getContentDataFromNode(contentNode, contentType);
        }
        this.centerHolderNode.objData = objData;
        this.centerholderdata = this.centerHolderNode.objData;
    }
    return objData;
};

NonlinearCircleDiagram.prototype.setDimensionsForNodes = function (deviceHolder, svgNode, parentDiv, centerShape) {
    // return
    let position = centerShape.position.split(",")[0];
    let alignment = centerShape.position.split(",")[1] || "center";
    this.resizeNode(svgNode, alignment, position, parentDiv, deviceHolder);
    let maxHeight = 400;
    for (let index = 0; index < this.arrDiagramNode.length; index++) {
        let element = this.arrDiagramNode[index];
        let nodeParent = element.parentNode.parentElement;
        let pointNode = deviceHolder.querySelector("[id*='-point" + (index + 1) + "']");
        let offset = DiagramNodeUtils.calcBoundsDifference("x", deviceHolder, pointNode);
        if (alignment == "alternate") {
            nodeParent.style.left = offset / this.slideScale + "px";
            let startAlign = centerShape.position.split(",")[2] || "top";
            let startValue = startAlign == "top" ? 0 : 1;
            if (index % 2 == startValue) {
                nodeParent.style.bottom = "100%";
                nodeParent.style.paddingBottom = "24px";
                nodeParent.firstElementChild.style.alignItems = "flex-end";
            } else {
                nodeParent.style.top = "100%";
                nodeParent.style.paddingTop = "24px";
                nodeParent.firstElementChild.style.alignItems = "flex-start";
            }
        }

        this.setNumberIconNodes(pointNode, index + 1, element.objData);
        if (position == "horizontal") {
            if (index == 0) {
                let nextPointNode = deviceHolder.querySelector("[id*='-point" + (index + 2) + "']");
                let offsetNext = DiagramNodeUtils.calcBoundsDifference("x", deviceHolder, nextPointNode);
                parentDiv.style.setProperty("--nodesMaxWidth", (offsetNext - offset) / this.slideScale + "px");
                if (alignment != "alternate") {
                    let marginAdjust = pointNode.getBoundingClientRect().width / this.slideScale - (offsetNext - offset) / this.slideScale;
                    if (marginAdjust > 0) nodeParent.style.marginLeft = -marginAdjust + "px";
                }
            }
        } else if (position == "vertical") {
            let connector = pointNode.querySelector("[id*='connector" + (index + 1) + "']");
            if (connector) {
                if (index == 0) {
                    let leftArray = deviceHolder.querySelectorAll("rect[id*='left']");
                    let rightArray = deviceHolder.querySelectorAll("rect[id*='right']");
                    if (leftArray.length >= 2) {
                        maxHeight = DiagramNodeUtils.calcBoundsDifference("y", leftArray[1], leftArray[0]) / this.slideScale;
                        maxHeight = Math.abs(maxHeight);
                    } else if (rightArray.length >= 2) {
                        maxHeight = DiagramNodeUtils.calcBoundsDifference("y", rightArray[1], rightArray[0]) / this.slideScale;
                        maxHeight = Math.abs(maxHeight);
                    }
                    this.diagramParent.style.setProperty("--nodesMaxHeight", maxHeight + "px");
                }
                let rect = connector.firstElementChild;
                if (rect) {
                    let top = Math.abs(DiagramNodeUtils.calcBoundsDifference("y", rect, this.diagramParent)) / this.slideScale;
                    let left = Math.abs(DiagramNodeUtils.calcBoundsDifference("x", rect, this.diagramParent)) / this.slideScale;
                    let id = rect.getAttribute("id");
                    if (id.includes("left")) {
                        nodeParent.setAttribute("data-align", "left");
                        nodeParent.style.top = top - maxHeight / 2 + "px";
                    } else if (id.includes("right")) {
                        nodeParent.setAttribute("data-align", "right");
                        nodeParent.style.top = top - maxHeight / 2 + "px";
                    } else if (id.includes("top")) {
                        nodeParent.setAttribute("data-align", "top");
                        nodeParent.style.top = "0px";
                        element.parentNode.style.alignItems = "flex-end";
                    } else if (id.includes("bottom")) {
                        nodeParent.setAttribute("data-align", "bottom");
                        nodeParent.style.bottom = "0px";
                        element.parentNode.style.alignItems = "flex-start";
                    }
                }
            }
        }
    }
};

NonlinearCircleDiagram.prototype.diagramRenderComplete = function () {
    if (this.completeCallBack && this.completeCallBack.func && this.isRenderComplete) {
        LinearDiagram.prototype.diagramRenderComplete.call(this);
    }
    this.diagramParent.style.opacity = 1;
};

NonlinearCircleDiagram.prototype.addNode = function (nodeData, index) {
    if (this.diagramData.nodes.length > index) {
        this.diagramData.nodes.splice(index, 0, nodeData);
    } else {
        this.diagramData.nodes.push(nodeData);
    }
    this.initDiagramCreation();
    this.updateEvents();
    this.updateNodesHolderClass(this.diagramData.nodes.length);
};

NonlinearCircleDiagram.prototype.updateNodesHolderClass = function (nodeCount) {
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    nodesHolder.setAttribute("data-node", nodeCount + "nodes");
};

NonlinearCircleDiagram.prototype.deleteNode = function (targetIndex) {
    if (this.arrDiagramNode.length > targetIndex) {
        this.arrDiagramNode.splice(targetIndex, 1);
        let nodeDelete = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + targetIndex + "']");
        if (nodeDelete && nodeDelete.parentElement) {
            nodeDelete.parentElement.remove();
        }
    }
    if (this.diagramData.nodes.length > targetIndex) {
        this.diagramData.nodes.splice(targetIndex, 1);
    }
    this.initDiagramCreation();
    this.updateEvents();
    this.updateNodesHolderClass(this.diagramData.nodes.length);
};

NonlinearCircleDiagram.prototype.resetHolderWidth = function () {
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    nodesHolder.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    nodesHolder.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    nodesHolder.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    nodesHolder.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    nodesHolder.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");
};

NonlinearCircleDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearVerticalDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    let arrFloaterDisable = mainProperties.floateroptionsdisable;
    if (arrFloaterDisable) {
        arrFloaterDisable.push("arrange");
        arrFloaterDisable.push("content");
        arrFloaterDisable.push("graphicimage");
        arrFloaterDisable.push("graphiclogo");
        arrFloaterDisable.push("graphicnumber");
        arrFloaterDisable.push("graphictext");
        arrFloaterDisable.push("emphasize");
        arrFloaterDisable.push("graphicnone");
        arrFloaterDisable.push("sequencetext");
        arrFloaterDisable.push("connector");
    }
    this.diagramParent.setAttribute("data-floateroptionsdisable", arrFloaterDisable);
};

NonlinearCircleDiagram.prototype.refreshPosition = function (centerElement) {
    if (!centerElement) return;
    for (let nodes = 0; nodes < this.diagramData.nodes.length; nodes++) {
        let centerRect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent, centerElement);
        let centerX = centerRect.x + centerRect.width / 2;
        let centerY = centerRect.y + centerRect.height / 2;

        let radius = centerElement.offsetWidth / 2;
        let centerAngle = (360 / this.diagramData.nodes.length) * nodes;
        if (this.diagramData.nodes.length == 2) centerAngle = centerAngle + 90;
        if (this.diagramData.nodes.length == 4) centerAngle = centerAngle + 45;
        if (this.diagramData.nodes.length == 6) centerAngle = centerAngle + 30;

        let textCenterPoint = this.polarToCartesian(centerX, centerY, radius + 10, centerAngle);
        this.diagramData.nodes[nodes].center = textCenterPoint;
        this.diagramData.nodes[nodes].centerangle = centerAngle;
    }
    this.setItemPosition(this.diagramParent, this.diagramData, centerElement);
    this.diagramParent.style.setProperty("--nonlinearitemparentheight", "auto");
    this.resetNodeAttributes();
};

NonlinearCircleDiagram.prototype.polarToCartesian = function (centerX, centerY, radius, angleInDegrees) {
    var angleInRadians = ((angleInDegrees - 90) * Math.PI) / 180.0;

    return {
        x: centerX + radius * Math.cos(angleInRadians),
        y: centerY + radius * Math.sin(angleInRadians),
    };
};

NonlinearCircleDiagram.prototype.setItemPosition = function (parent, data, circleBase) {
    // let circlePosition = { x: circleBase.offsetLeft, y: circleBase.offsetTop };

    // circleBase.style.position = data.nodes.length == 3 || data.nodes.length == 5 ? "absolute" : "";
    // circleBase.style.bottom = data.nodes.length == 3 ? "40px" : "unset";
    // circleBase.style.bottom = data.nodes.length == 5 ? "45px" : circleBase.style.bottom;

    for (var i = 0; i < this.arrDiagramNode.length; i++) {
        let item = this.arrDiagramNode[i].getNodeParent().parentElement;
        let info = {};
        info.left = data.nodes[i].center.x;
        info.top = data.nodes[i].center.y;
        info.centerAngle = data.nodes[i].centerangle;
        this.setPosition(item, info, circleBase, i);
        this.setContentAlignment(item, info);
    }
};

NonlinearCircleDiagram.prototype.setPosition = function (div, data, circleBase, i) {
    let availableWidth = circleBase.parentElement.clientWidth - circleBase.clientWidth;
    let itemWidth = (availableWidth / 2) * 0.9;
    div.style.width = itemWidth + "px";

    let itemBase = div.querySelector("[id*='nodeitem']");

    let heightRation = this.getSizeRatio();
    let height = Math.min(circleBase.clientWidth * 0.3, this.diagramParent.clientHeight * heightRation.textHeightRatio);
    div.style.height = height + "px";
    div.style.minHeight = "90px";

    if (data.centerAngle == 0 || data.centerAngle == 180) {
        div.style.height = this.diagramParent.clientHeight * 0.15 + "px";
        // if (div.dataset.index == "0") {
        //     div.style.maxHeight = div.style.height;
        //     div.style.height = "auto";
        // }
        div.style.width = availableWidth * 0.8 + "px";
        if (itemBase) itemBase.style.width = "auto";
    } else if (data.centerAngle == 90 || data.centerAngle == 270) {
        if (itemBase) itemBase.style.width = "100%";
    } else if (data.centerAngle > 90 || data.centerAngle < 180) {
        if (itemBase) itemBase.style.width = "100%";
    } else if (itemBase) itemBase.style.width = "100%";

    div.style.top = data.top + "px";
    if (data.centerAngle > 0 && data.centerAngle < 180) {
        let startx = parseFloat(data.left);
        let starty = parseFloat(data.top) - this.getTopFactor(div, data);
        div.style.top = starty + "px";
        div.style.left = startx + "px";
    } else if (data.centerAngle > 180 && data.centerAngle < 360) {
        let startx = parseFloat(data.left) - div.clientWidth;
        let starty = parseFloat(data.top) - this.getTopFactor(div, data);
        div.style.top = starty + "px";
        div.style.left = startx + "px";
    } else {
        let startx = parseFloat(data.left) - div.clientWidth / 2;
        let starty = parseFloat(data.top);
        starty = data.centerAngle > 270 || data.centerAngle < 90 ? starty - div.clientHeight : starty;
        div.style.top = starty + "px";
        div.style.left = startx + "px";
    }

    div.style.setProperty("--secContentHeight", "90px");
    div.style.setProperty("max-height", div.style.height);
    this.checkForIntersection(circleBase, div, data.centerAngle);

    if (data.centerAngle > 0 && data.centerAngle < 180) {
        div.style.width = this.diagramParent.clientWidth - div.offsetLeft + "px";
    } else if (data.centerAngle > 180 && data.centerAngle < 360) {
        div.style.width = div.offsetLeft + div.clientWidth + "px";
        div.style.left = "0px";
    }
};

NonlinearCircleDiagram.prototype.setContentAlignment = function (div, data) {
    let groupNode = div.querySelector("[data-name='nodeGroup']");
    if (!groupNode) return;
    this.clearCustomStyle(div);
    if (data.centerAngle > 0 && data.centerAngle < 180) {
        div.classList.add("clsLeftAlignmentCircular");
        div.classList.add("groupFullWidth");
    } else if (data.centerAngle > 180 && data.centerAngle < 360) {
        div.classList.add("clsRightAlignmentCircular");
        div.classList.add("groupFullWidth");
    } else {
        let content = div.querySelector("[data-type='diagramContentNode']");
        if (content && window.getComputedStyle(content).display != "none") {
            div.classList.add("clsLeftAlignmentCircular");
        }
    }
};

NonlinearCircleDiagram.prototype.clearCustomStyle = function (div) {
    div.classList.remove("clsLeftAlignmentCircular");
    div.classList.remove("clsRightAlignmentCircular");
    div.classList.remove("groupFullWidth");
};

NonlinearCircleDiagram.prototype.getTopFactor = function (div, data) {
    return div.clientHeight / 2;
};

NonlinearCircleDiagram.prototype.getSizeRatio = function () {
    switch (this.diagramData.nodes.length) {
        case 2:
            return { heightRatio: 0.8, iconHeightRatio: 0.3, textHeightRatio: 0.5 };
        case 3:
            return { heightRatio: 0.7, iconHeightRatio: 0.27, textHeightRatio: 0.27 };
        case 4:
            return { heightRatio: 0.8, iconHeightRatio: 0.27, textHeightRatio: 0.3 };
        case 5:
            return { heightRatio: 0.7, iconHeightRatio: 0.25, textHeightRatio: 0.2 };
        case 6:
            return { heightRatio: 0.67, iconHeightRatio: 0.25, textHeightRatio: 0.25 };
    }
};

NonlinearCircleDiagram.prototype.checkForIntersection = function (circleBase, nodeItem, angle) {
    var circle = {
        radius: circleBase.clientHeight / 2,
        center: { x: circleBase.offsetLeft + circleBase.offsetWidth / 2, y: circleBase.offsetTop + circleBase.offsetHeight / 2 },
    };
    var topLine = {
        p1: { x: nodeItem.offsetLeft, y: nodeItem.offsetTop },
        p2: { x: nodeItem.offsetLeft + nodeItem.clientWidth, y: nodeItem.offsetTop },
    };

    var bottomLine = {
        p1: { x: nodeItem.offsetLeft, y: nodeItem.offsetTop + nodeItem.offsetHeight },
        p2: { x: nodeItem.offsetLeft + nodeItem.clientWidth, y: nodeItem.offsetTop + nodeItem.offsetHeight },
    };

    var centerLine = {
        p1: { x: nodeItem.offsetLeft, y: nodeItem.offsetTop + nodeItem.offsetHeight / 2 },
        p2: { x: nodeItem.offsetLeft + nodeItem.clientWidth, y: nodeItem.offsetTop + nodeItem.offsetHeight / 2 },
    };

    let topIntersetPoint = DiagramUtils.findCircleLineIntersections(circle, topLine);
    let bottomIntersetpoint = DiagramUtils.findCircleLineIntersections(circle, bottomLine);
    let centerIntersetpoint = DiagramUtils.findCircleLineIntersections(circle, centerLine);

    let topX = topIntersetPoint[0] ? topIntersetPoint[0].x : 0;
    let bottomX = bottomIntersetpoint[0] ? bottomIntersetpoint[0].x : 0;
    let centterX = centerIntersetpoint[0] ? centerIntersetpoint[0].x : 0;
    let x = Math.max(topX, bottomX);

    if (angle == 90) {
        x = centterX == 0 ? parseFloat(nodeItem.style.left) : centterX;
    } else if (angle == 270) {
        x = centterX == 0 ? parseFloat(nodeItem.style.left) + nodeItem.clientWidth : centterX;
    }

    let isRightItem = angle > 0 && angle < 180;
    let isLeftItem = angle > 180 && angle < 360;

    let nodeOffset = 20; //this.diagramData.properties.customproperties.nodeitemoffset;
    x = x == 0 && isRightItem ? parseFloat(nodeItem.style.left) : x;
    x = x == 0 && isLeftItem ? parseFloat(nodeItem.style.left) + nodeItem.clientWidth : x;
    let rightX = x + nodeOffset;
    let leftX = x - nodeOffset - nodeItem.clientWidth;

    nodeItem.style.left = isRightItem ? rightX + "px" : nodeItem.style.left;
    nodeItem.style.left = isLeftItem ? leftX + "px" : nodeItem.style.left;
};

/////////// Animation function

NonlinearCircleDiagram.prototype.setupOneAtTimeAnimation = function (animationType, callback) {
    this.isEmphasisEnable = this.diagramParent.dataset.hover && this.diagramParent.dataset.hover == "true" ? false : true;
    this.centerNode = this.diagramParent.querySelector("div[data-id=deviceHolderParent]");
    LinearDiagram.prototype.setupAnimation.call(this, animationType, callback);
    let arrPoints = Array.from(this.centerNode.querySelectorAll("[id*='-point']"));

    arrPoints.map(
        function (point) {
            point.style.transition = "all 0.5s";
            this.animateSvgShape(point, "hide");
        }.bind(this)
    );
};

NonlinearCircleDiagram.prototype.initPresent = function (currentSlide, boolNoAnimation = false) {
    if (boolNoAnimation) return { isTitleAnimation: false, isGraphicAnimation: false };
    this.diagramParent = currentSlide.querySelector("[id='diagramparent']");

    let animationType = this.diagramParent.parentElement.dataset.animationtype;
    if (animationType != "all") {
        this.arrDiagramNode.map((node) => {
            let nodeParent = node.getNodeParent().parentElement;
            nodeParent.removeAttribute("data-animation");
            nodeParent.classList.remove("moodanimation");
            let arrObj = Array.from(nodeParent.querySelectorAll("[data-animation]"));
            arrObj.map((item) => {
                item.removeAttribute("data-animation");
                item.classList.remove("moodanimation");
            });
        });

        this.centerNode = this.diagramParent.querySelector("div[data-id=deviceHolderParent]");
        let arrPoints = Array.from(this.centerNode.querySelectorAll("[id*='-point']"));
        arrPoints.map(
            function (point) {
                let connectorline = point.querySelector("[id*='-connector']");
                if (connectorline) {
                    connectorline.removeAttribute("data-animation");
                    connectorline.classList.remove("moodanimation");
                }
            }.bind(this)
        );
    }

    if (this.diagramParent.parentElement.dataset.animationtype && this.diagramParent.parentElement.dataset.animationtype == "none") return { isTitleAnimation: false, isGraphicAnimation: false };

    if (this.diagramParent) this.diagramParent.style.opacity = 0;

    if (animationType != "all") this.diagramParent.classList.add("clsNonHover");
    let isGraphicAnimation = animationType == "all" ? true : false;
    return { isTitleAnimation: true, isGraphicAnimation: true };
};

NonlinearCircleDiagram.prototype.animateAfterMoodDelay = function () {
    let moodAnimationDisable = this.diagramParent.parentElement.dataset.moodanimation;
    this.animationFactor = moodAnimationDisable && moodAnimationDisable == "none" ? 0 : 1;
    this.diagramParent.style.transition = `all ${0.3 * this.animationFactor}s`;
    this.diagramParent.style.opacity = 1;

    setTimeout(() => {
        this.playNext();
    }, 0);
};

NonlinearCircleDiagram.prototype.animateSvgShape = function (point, animation) {
    let shape = point.querySelector("[id*='-shape']");
    let connectorline = point.querySelector("[id*='-connector']");
    let icon = point.querySelector("[id*='-icon']");
    let placeholder = point.querySelector("[id*='-placeholder']");

    if (shape && this.svgPointShapAnimatable) {
        shape.style.opacity = animation == "show" ? 1 : 0;
    }
    if (connectorline) {
        connectorline.style.opacity = animation == "show" ? 1 : 0;
    }
    if (icon) {
        icon.style.opacity = animation == "show" ? 1 : 0;
    }
    if (placeholder) {
        placeholder.style.opacity = animation == "show" ? 1 : 0;
    }
};

NonlinearCircleDiagram.prototype.animateArrowForward = function (index) {
    let arrPoints = Array.from(this.centerNode.querySelectorAll("[id*='-point']"));
    let arrSelectedPoint = arrPoints.filter(
        function (point, i) {
            let isSelectedNode = point.id.includes("-point" + (index + 1) + "");
            let pointIndex = parseInt(point.id.split("-")[1].match(/\d/g)[0]);
            if (this.animationType == "one") {
                if (!this.isEmphasisEnable) {
                    point.style.filter = "url(#hoverfilter)";
                    point.style.setProperty("-webkit-filter", "url(#hoverfilter)");
                    this.arrDiagramNode[pointIndex - 1].getNodeParent().style.filter = "grayscale(1)";
                    if (isSelectedNode) {
                        point.style.filter = "none";
                        this.arrDiagramNode[pointIndex - 1].getNodeParent().style.filter = "none";
                    }
                }
                this.animateSvgShape(point, "hide");
            } else if (!this.isEmphasisEnable) {
                point.style.filter = "url(#hoverfilter)";
                this.arrDiagramNode[pointIndex - 1].getNodeParent().style.filter = "grayscale(1)";
                if (pointIndex - 1 <= index) {
                    point.style.filter = "none";
                    this.arrDiagramNode[pointIndex - 1].getNodeParent().style.filter = "none";
                }
            }
            return isSelectedNode;
        }.bind(this)
    );

    arrSelectedPoint.map(
        function (point) {
            this.animateSvgShape(point, "show");
        }.bind(this)
    );
};

NonlinearCircleDiagram.prototype.animateArrowBackward = function (index) {
    let arrPoints = Array.from(this.centerNode.querySelectorAll("[id*='-point']"));
    let arrSelectedPoint = arrPoints.filter(
        function (point) {
            let isSelectedNode = point.id.includes("-point" + (index + 1) + "");
            let pointIndex = parseInt(point.id.split("-")[1].match(/\d/g)[0]);
            if (this.animationType == "one") {
                if (!this.isEmphasisEnable) {
                    point.style.filter = "url(#hoverfilter)";
                    this.arrDiagramNode[pointIndex - 1].getNodeParent().style.filter = "grayscale(1)";
                    if (isSelectedNode) {
                        point.style.filter = "none";
                        this.arrDiagramNode[pointIndex - 1].getNodeParent().style.filter = "none";
                    }
                }
                this.animateSvgShape(point, "hide");
            } else if (!this.isEmphasisEnable) {
                point.style.filter = "url(#hoverfilter)";
                this.arrDiagramNode[pointIndex - 1].getNodeParent().style.filter = "grayscale(1)";
                if (pointIndex < index + 1) {
                    point.style.filter = "none";
                    this.arrDiagramNode[pointIndex - 1].getNodeParent().style.filter = "none";
                }
            }
            return isSelectedNode;
        }.bind(this)
    );
    arrSelectedPoint.map(
        function (point) {
            if (this.animationType == "one") this.animateSvgShape(point, "show");
            else this.animateSvgShape(point, "hide");
        }.bind(this)
    );
};

NonlinearCircleDiagram.prototype.updateAllNodesInOneAtTime = function (direction) {
    LinearDiagram.prototype.updateAllNodesInOneAtTime.call(this, direction);
    if (this.isEmphasisEnable) return;
    let arrPoints = Array.from(this.centerNode.querySelectorAll("[id*='-point']"));
    arrPoints.map(
        function (point, i) {
            point.style.filter = "none";
            this.animateSvgShape(point, "show");
            let node = this.arrDiagramNode[i].getNodeParent();
            if (node) node.style.filter = "none";
        }.bind(this)
    );
};

// Setup common point content
NonlinearCircleDiagram.prototype.setupCommonPointContent = function (mainNode) {
    let gCommonpoint = mainNode.querySelector("g[id*='commonpoint']");
    if (!gCommonpoint) return;
    let placeholder = gCommonpoint.querySelector("[id*='placeholder']");
    let contentrect = placeholder.querySelector("[clip-path]");
    if (contentrect) {
        this.createCenterHolder(mainNode, contentrect);
    }
};

NonlinearCircleDiagram.prototype.updateImageBounds = function (imageNode, imageStyle, objItemDimn, svgData) {
    let numScale, numScaleX, numScaleY;
    let numX, numY, numWidth, numHeight;
    let numXPer, numYPer, numWidthPer, numHeightPer;
    let imageWidth = imageNode.getBBox().width;
    let imageHeight = imageNode.getBBox().height;
    imageNode.setAttribute("data-imagewidth", imageWidth);
    imageNode.setAttribute("data-imageheight", imageHeight);
    if (imageNode.getAttribute("data-imagewidth")) imageWidth = Number(imageNode.getAttribute("data-imagewidth"));
    if (imageNode.getAttribute("data-imageheight")) imageHeight = Number(imageNode.getAttribute("data-imageheight"));
    if (objItemDimn && !imageStyle) {
        numScaleX = objItemDimn.width / imageWidth;
        numScaleY = objItemDimn.height / imageHeight;
        numScale = Math.max(numScaleX, numScaleY);
        numWidth = imageWidth * numScale;
        numHeight = imageHeight * numScale;
        numX = (objItemDimn.width - numWidth) / 2;
        numY = (objItemDimn.height - numHeight) / 2;
        numXPer = ((numX / objItemDimn.width) * 100).toFixed(2) + "%";
        numYPer = ((numY / objItemDimn.height) * 100).toFixed(2) + "%";
        numWidthPer = ((numWidth / objItemDimn.width) * 100).toFixed(2) + "%";
        numHeightPer = ((numHeight / objItemDimn.height) * 100).toFixed(2) + "%";
        DiagramNodeUtils.assignAttributes(imageNode, { x: numXPer, y: numYPer, width: numWidthPer, height: numHeightPer });
        DiagramNodeUtils.assignAttributes(imageNode, { "data-imagewidth": imageWidth, "data-imageheight": imageHeight });
        imageNode.style.cssText = "position:absolute;width:" + numWidthPer + ";height:" + numHeightPer + ";left:" + numXPer + ";top:" + numYPer + ";x:" + numXPer + ";y:" + numYPer + ";";

        let editRectScaleValue = Math.min(svgData.viewportElement.clientWidth / objItemDimn.viewBoxWidth, svgData.viewportElement.clientHeight / objItemDimn.viewBoxHeight);
        let rectWidth = editRectScaleValue * objItemDimn.width;
        let rectHeight = editRectScaleValue * objItemDimn.height;
        DiagramNodeUtils.assignAttributes(imageNode, { "data-width": rectWidth, "data-height": rectHeight });
    }
    if (imageStyle && imageStyle.cssText) {
        let newWidth = parseInt(imageNode.getAttribute("data-width"));
        let newHeight = parseInt(imageNode.getAttribute("data-height"));
        imageNode.style.cssText = imageStyle.cssText;
        DiagramNodeUtils.assignAttributes(imageNode, { x: imageStyle.getPropertyValue("left"), y: imageStyle.getPropertyValue("top") });
        let leftPos = Number(imageStyle.getPropertyValue("left").split("%")[0]);
        let topPos = Number(imageStyle.getPropertyValue("top").split("%")[0]);
        numScaleX = newWidth / Number(imageNode.getAttribute("data-imagewidth"));
        numScaleY = newHeight / Number(imageNode.getAttribute("data-imageheight"));
        if (imageStyle.width === "auto") {
            numScale = Math.min(numScaleX, numScaleY);
        } else numScale = Math.max(numScaleX, numScaleY);
        numWidth = Number(imageNode.getAttribute("data-imagewidth")) * numScale;
        numHeight = Number(imageNode.getAttribute("data-imageheight")) * numScale;
        numWidthPer = ((numWidth / newWidth) * 100).toFixed(2) + "%";
        numHeightPer = ((numHeight / newHeight) * 100).toFixed(2) + "%";
        let transformscale = imageStyle.getPropertyValue("transform") ? imageStyle.getPropertyValue("transform").split("(")[1].split(")")[0] : 1;

        numX = (newWidth - numWidth) / 2;
        numY = (newHeight - numHeight) / 2;
        let centerX = numX + (numWidth - numWidth * transformscale) / 2;
        let centerY = numY + (numHeight - numHeight * transformscale) / 2;
        let leftCenterPos = (centerX / (numWidth * transformscale)) * 100;
        let topCenterPos = (centerY / (numHeight * transformscale)) * 100;
        leftPos = (leftPos / transformscale + leftCenterPos).toFixed(2) + "%";
        topPos = (topPos / transformscale + topCenterPos).toFixed(2) + "%";
        DiagramNodeUtils.assignAttributes(imageNode, {
            x: leftPos,
            y: topPos,
        });
        if (imageStyle.height === "auto") {
            imageNode.setAttribute("width", "100%");
            imageNode.setAttribute("height", numHeightPer);
        } else if (imageStyle.width === "auto") {
            imageNode.setAttribute("height", "100%");
            imageNode.setAttribute("width", numWidthPer);
        } else {
            if (imageStyle.width == "") imageNode.setAttribute("width", imageNode.getAttribute("data-imagewidth"));
            else imageNode.setAttribute("width", numWidthPer);
            if (imageStyle.height == "") imageNode.setAttribute("height", imageNode.getAttribute("data-imageheight"));
            else imageNode.setAttribute("height", numHeightPer);
        }
    }
};

NonlinearCircleDiagram.prototype.setHighlightPosition = function (node, parent) {
    let nodeParent = node.parentElement;

    let element = nodeParent.querySelector("[data-id='diagramContentNode']");
    if (!element || element.clientWidth == 0) element = node;

    let alignment = "auto";
    let nodeAngle = parseInt(nodeParent.dataset.angle);
    if (nodeAngle > 0 && nodeAngle < 180) alignment = "left";
    else if (nodeAngle > 180 && nodeAngle < 360) alignment = "right";

    return { element: element, alignment: alignment };
};

NonlinearCircleDiagram.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    let centerNode = this.diagramParent.querySelector("[data-id='centerNode']");
    let isCenterChild = centerNode ? this.isChildOfParent(elTarget, centerNode) : false;

    let subNodes = this.nodeProps.supportedNodes[0];
    if ((subNodes && subNodes.subNodes && subNodes.subNodes.length <= 2) || !subNodes.subNodes) return;

    if (isCenterChild) {
        let { options, selectedindex } = this.getSeletion(this.centerNode.firstElementChild.dataset.contentType, "centerNode");
        dict.contentswap = {
            dpsource: options,
            selectedindex: selectedindex,
            floaterproperty: "contentChange",
            visible: options.length > 1 ? true : false,
        };
        elTarget.setAttribute("data-focus-parent", "centerHolderParent");
    }
    delete dict.textalign;
};

NonlinearCircleDiagram.prototype.switchContentBetweenNodeAndSvg = function (type, index) {
    let deviceHolder = this.diagramParent.querySelector("[data-id='deviceHolder']");
    if (!deviceHolder) return;
    let node = this.arrDiagramNode[index];
    let nodeParent = node.parentNode.parentElement;
    let pointNode = deviceHolder.querySelector("[id*='-point" + (index + 1) + "']");
    if (!pointNode) return;
    let placeHolder = pointNode.querySelector("[id*='-placeholder']");

    if (placeHolder) {
        placeHolder.style.display = type == "icon" || type == "sequence" ? "flex" : "none";
        let content = nodeParent.querySelector("[data-type='diagramContentNode']");
        if (content) content.style.setProperty("display", type == "icon" || type == "sequence" || type == "none" ? "none" : "flex", "important");
    } else {
        return;
    }
};

NonlinearCircleDiagram.prototype.isNonLinearAsset = function () {
    return true;
};

//CenterNode like Nonlinear Diaram
NonlinearCircleDiagram.prototype.createCenterHolder = function (pattenDiv, contentrect = null) {
    let centerItem = new window[this.nodeProps.nodeclassName](pattenDiv, {}, this.centerholderdata ? this.centerholderdata : { content: {} }, this.eventManagerXY, 0, "", this.objStyleData, this.appStaticURL, this.nodeProps, this.diagramParent);
    centerItem.moodData = this.moodData;
    centerItem.moodName = this.moodName;
    centerItem.updateCallBack = this.updateCallBack;
    centerItem.searchIconCallBack = this.searchIconCallBack;
    centerItem.bgDeviceDiv = this.bgDeviceDiv;
    centerItem.arrDefaults = this.arrDefaults;
    centerItem.globalMoodData = this.globalMoodData;
    centerItem.arrTintArray = this.arrTintArray;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;
    this.centerHolderNode = centerItem;
    let centerNode = null;
    if (contentrect) centerNode = this.createCenterImageNode(contentrect, centerItem.objData && centerItem.objData.content && centerItem.objData.content.value ? centerItem.objData.content.value : this.appStaticURL + "genericassets/placeholderimages/placeholder.png");
    else centerNode = centerItem.createCenterNode(pattenDiv);
    this.centerHolderNode.nodeGroup = this.diagramParent.querySelector("[data-id='centerHolderParent']");
    this.updatePropsCallBack();
    return centerNode;
};

NonlinearCircleDiagram.prototype.createCenterImageNode = function (contentrect, value) {
    let svgItem = contentrect.querySelector("[id='svgNode']");
    if (svgItem) svgItem.remove();
    // contentrect.style.setAttribute("-webkit-clip-path",)
    contentrect.style.setProperty("-webkit-clip-path", contentrect.getAttribute("clip-path"));
    let svgImageData = DiagramNodeUtils.createSVGElement("svg");
    DiagramNodeUtils.assignAttributes(svgImageData, {
        width: contentrect.children[0].getAttribute("width"),
        height: contentrect.children[0].getAttribute("height"),
        x: contentrect.children[0].getAttribute("x"),
        y: contentrect.children[0].getAttribute("y"),
        "data-x": contentrect.children[0].getAttribute("x"),
        "data-y": contentrect.children[0].getAttribute("y"),
        "data-animation": "commonplaceholder",
        class: "moodanimation",
        "data-id": "centerHolderParent",
        "data-content-type": "image",
        id: "svgNode",
    });
    let imageNode = DiagramNodeUtils.createSVGElement("image");
    let imageWidth = contentrect.getBoundingClientRect().width / this.slideScale;
    let imageHeight = contentrect.getBoundingClientRect().height / this.slideScale;

    DiagramNodeUtils.assignAttributes(imageNode, {
        id: "IMAGE0",
        "data-type": "IMAGE",
        "data-belongto": "node0",
        "xlink:href": value,
        "data-x": contentrect.children[0].getAttribute("x"),
        "data-y": contentrect.children[0].getAttribute("y"),
        "data-width": imageHeight,
        "data-height": imageHeight,
        "data-type": "gridimage",
        "data-id": "imageNode",
    });
    svgImageData.appendChild(imageNode);
    contentrect.appendChild(svgImageData);
    let objDimensions = new Object();
    let imagestyle = null;
    objDimensions.x = contentrect.children[0].getAttribute("x");
    objDimensions.y = contentrect.children[0].getAttribute("y");
    objDimensions.width = imageHeight;
    objDimensions.height = imageHeight;
    objDimensions.viewBoxWidth = svgImageData.getAttribute("width");
    objDimensions.viewBoxHeight = svgImageData.getAttribute("height");
    DiagramResizeUtils.updateSvgImageBounds(imageNode, imagestyle, objDimensions, svgImageData);
};

/**
 * Author:    Bala Krishnan K.
 * Created:   30.10.2020
 *
 **/
// text

"use strict";

function ZoomDiagramNew(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "clsLinerDiagram zoomdiagrambase";
    diagramParent.setAttribute("data-diagramtype", "vertical");
    this.isRenderComplete = false;
    this.dummySvg = null;
    this.pageIndex = 0;
    this.bgImage = null;
    this.nodeText = null;
    this.isScaled = false;
    this.animationIndex = 0;
    this.currentNode = null;
    this.currentImgNode = null;
    this.pointImageHolder = null;
    this.diagramParent.parentElement.setAttribute("data-ismultislide", true);
    this.diagramParent.parentElement.setAttribute("data-customtitleanimation", true);

    this.diagramParent.parentElement.setAttribute("data-animationtype", "one");
    this.diagramParent.setAttribute("data-groupname", "zoom");

    this.arrZoomImages = [];
    this.cubicPath = "cubic-bezier(.55,0,.4,1)";
    this.zoomdata = null;
    this.delayRatio = 1;
    this.durationRatio = 1.3;
    this.layerDelay = 0.06;
    this.zoomDiff = -0.12;
}

ZoomDiagramNew.prototype = Object.create(SimpleLinearDiagram.prototype);
ZoomDiagramNew.prototype.constructor = ZoomDiagramNew;

ZoomDiagramNew.prototype.createElements = function () {
    SimpleLinearDiagram.prototype.createElements.call(this);
    this.diagramParent.opacity = 1;

    this.diagramData.properties.zoomdata = this.data()[this.nodeProps.centerShape];
    this.zoomdata = this.diagramData.properties.zoomdata;

    this.loadSvg();
};

ZoomDiagramNew.prototype.updateElements = function (defaultproperties) {
    SimpleLinearDiagram.prototype.updateElements.call(this, defaultproperties);

    if (this.diagramParent) {
        this.pageIndex = 0;
        this.isScaled = false;
        this.animationIndex = 0;

        this.nodeText = null;
        this.currentNode = null;
        this.currentImgNode = null;

        this.bgImage = this.diagramParent.querySelector("[id='bgimage']");
        if (!this.bgImage) return;
        this.pointImageHolder = this.diagramParent.querySelector("[id='pointImageHolder']");
        this.arrZoomImages = Array.from(this.diagramParent.querySelectorAll("[data-id='overlayholder']"));

        this.diagramData.properties.zoomdata = this.data()[this.nodeProps.centerShape];
        this.zoomdata = this.diagramData.properties.zoomdata;

        let point = this.zoomdata.svg.type == "vary" ? this.diagramData.nodes.length + "point" : "";
        let bgSvg = this.diagramParent.querySelector("[id='" + point + this.zoomdata.assetname + "']");
        // if (bgSvg) this.selectedItemAtIndex(0, false);
        // this.updatePropsCallBack();
        // this.showHideTitle(true);
    }
};

ZoomDiagramNew.prototype.data = function () {
    return {
        imagezoom: {
            svg: { count: 1, type: "fixed" },
            bg: { type: "fixed", format: "jpg", duration: 1.5 },
            overlay: { count: 4, type: "fixed", format: "png", delay: 0.1, duration: 1.5 },
            point: { type: "vary", format: "jpg", delay: 0.1, duration: 1.5 },
            assetname: "zoom",
            nodeoverlap: "true",
        },
        mountain: {
            svg: { count: 5, type: "vary" },
            bg: { type: "fixed", format: "jpg", duration: 1.5 },
            overlay: { count: 2, type: "fixed", format: "png", delay: 0.1, duration: 1.5 },
            point: { type: "vary", format: "png", delay: 0.1, duration: 1.5 },
            assetname: "mountain",
        },
        roadway: {
            svg: { count: 5, type: "vary" },
            bg: { type: "fixed", format: "jpg", duration: 1.5 },
            overlay: { count: 1, type: "vary", format: "png", delay: 0.1, duration: 1.5 },
            point: { type: "vary", format: "png", delay: 0.1, duration: 1.5 },
            assetname: "roadway",
        },
        wallframe: {
            svg: { count: 5, type: "fixed" },
            bg: { type: "fixed", format: "jpg", duration: 1.5 },
            overlay: { count: 1, type: "fixed", format: "png", delay: 0, duration: 1.5 },
            point: { type: "fixed", format: "png", delay: 0, duration: 1.5, isallowdelay: false },
            assetname: "wallframe",
        },
    };
};

ZoomDiagramNew.prototype.loadSvg = function () {
    this.diagramParent.style.opacity = 0;
    let arrSvgData = [];
    for (var i = 2; i < this.zoomdata.svg.count + 2; i++) {
        let data = { type: "icon", value: "genericassets/shapes/" + this.zoomdata.assetname + "/" + i + "point" + this.zoomdata.assetname + ".svg", id: i + "point" + this.zoomdata.assetname };
        arrSvgData.push(data);
    }

    let assets = [{ type: "icon", value: "genericassets/shapes/" + this.zoomdata.assetname + "/" + this.zoomdata.assetname + ".svg", id: this.zoomdata.assetname }];
    if (this.zoomdata.svg.type == "vary") assets = arrSvgData;

    DiagramAssetLoader.loadAssetGroup(this.diagramParent, assets, this.appStaticURL)
        .then((data) => {
            this.setSvgBase();
            this.isRenderComplete = true;
            this.diagramRenderComplete();
            this.diagramParent.style.opacity = 1;
            this.pageIndex = 0;
            this.updatePropsCallBack();
        })
        .catch((error) => {
            console.log(error);
            this.isRenderComplete = true;
            this.diagramRenderComplete();
        });
};

ZoomDiagramNew.prototype.setSvgBase = function () {
    let parent = this.diagramParent;
    let baseHolder = parent.querySelector("[id='bgholder']");
    if (baseHolder && baseHolder.parentElement) baseHolder.parentElement.removeChild(baseHolder);

    let defs = this.diagramParent.querySelector("[id='svgDefsLocal']");
    if (defs) {
        let point = this.zoomdata.svg.type == "vary" ? this.diagramData.nodes.length + "point" : "";
        let bgSvg = defs.querySelector("[id='" + point + this.zoomdata.assetname + "']");

        if (this.dummySvg && this.dummySvg.parentElement) this.dummySvg.parentElement.removeChild(this.dummySvg);
        this.dummySvg = bgSvg.cloneNode(true);
        this.dummySvg.setAttribute("opacity", 0);
        this.diagramParent.appendChild(this.dummySvg);
        if (bgSvg) {
            this.setupbackground(this.dummySvg);
        }
    }
};

ZoomDiagramNew.prototype.setupbackground = function (bgSvg) {
    let svgRect = DiagramResizeUtils.getViewBoxRect(bgSvg);
    let baseHolder = document.createElement("div");
    baseHolder.className = "bgholder";
    baseHolder.id = "bgholder";
    baseHolder.style.width = "100%";
    baseHolder.style.height = "100%";
    this.diagramParent.appendChild(baseHolder);

    let scale = 1;
    if (svgRect.width > svgRect.height) {
        scale = this.diagramParent.clientWidth / svgRect.width;
    } else if (svgRect.width < svgRect.height) {
        scale = this.diagramParent.clientHeight / svgRect.height;
    }

    this.arrZoomImages = [];

    let bgimage = document.createElement("img");
    bgimage.style.setProperty("left", "unset", "important");
    bgimage.style.setProperty("top", "unset", "important");
    bgimage.style.width = svgRect.width + "px";
    bgimage.style.height = svgRect.height + "px";
    bgimage.className = "overlayholder";
    bgimage.id = "bgimage";
    bgimage.setAttribute("data-node-type", this.zoomdata.bg.type);
    bgimage.style.transform = "scale(" + scale + ")";

    bgimage.src = this.appStaticURL + "genericassets/shapes/" + this.zoomdata.assetname + "/bgimage." + this.zoomdata.bg.format;
    baseHolder.appendChild(bgimage);
    this.bgImage = bgimage;

    for (var i = 1; i < this.zoomdata.overlay.count; i++) {
        let overlayimage = document.createElement("img");
        overlayimage.style.setProperty("left", "unset", "important");
        overlayimage.style.setProperty("top", "unset", "important");
        overlayimage.style.width = svgRect.width + "px";
        overlayimage.style.height = svgRect.height + "px";
        overlayimage.className = "overlayholder";
        overlayimage.id = "overlayholder" + i;
        overlayimage.setAttribute("data-id", "overlayholder");
        overlayimage.setAttribute("data-node-type", this.zoomdata.overlay.type);
        let point = this.zoomdata.overlay.type == "fixed" ? "" : this.diagramData.nodes.length + "point";

        overlayimage.src = this.appStaticURL + "genericassets/shapes/" + this.zoomdata.assetname + "/" + point + "overlay" + i + "." + this.zoomdata.overlay.format;
        baseHolder.appendChild(overlayimage);
        overlayimage.style.transform = "scale(" + scale + ")";
        this.arrZoomImages.push(overlayimage);
    }

    let pointImageHolder = document.createElement("div");
    pointImageHolder.style.width = svgRect.width + "px";
    pointImageHolder.style.height = svgRect.height + "px";
    pointImageHolder.className = "overlayholder";
    pointImageHolder.id = "pointImageHolder";
    pointImageHolder.setAttribute("data-node-type", this.zoomdata.bg.type);
    pointImageHolder.style.transform = "scale(" + scale + ")";
    baseHolder.appendChild(pointImageHolder);
    this.pointImageHolder = pointImageHolder;

    let pointimage = document.createElement("img");
    pointimage.style.setProperty("left", "unset", "important");
    pointimage.style.setProperty("top", "unset", "important");
    pointimage.style.width = "100%";
    pointimage.style.height = "100%";
    pointimage.className = "overlayholder";
    pointimage.id = "pointimage";
    let index = 0;
    index = this.zoomdata.point.type == "vary" ? this.diagramData.nodes.length : "";

    // if (this.zoomdata.assetname != "roadway")
    pointimage.src = this.appStaticURL + "genericassets/shapes/" + this.zoomdata.assetname + "/point" + index + "." + this.zoomdata.point.format;
    pointImageHolder.appendChild(pointimage);

    let arrPoints = Array.from(bgSvg.querySelectorAll("[id*='-point']"));
    arrPoints.map(
        function (point, i) {
            let holder = this.creteNodeholder(pointImageHolder, point, i);
            let transform = point.getAttribute("transform");
            let trs = [];
            if (transform) {
                let arrTransform = transform.split(")");
                arrTransform.forEach(
                    function (obj) {
                        if (obj.includes("rotate")) {
                            let rotation = obj.replace("rotate(", "");
                            trs.push("rotate(" + rotation.trim() + "deg)");
                        }

                        if (obj.includes("scale")) {
                            let values = obj.replace("scale(", "").split(" ");
                            if (values.length > 0) {
                                trs.push("scale(" + values[0] + "," + values[1] + ")");
                            }
                        }
                    }.bind(this)
                );
            }
            holder.style.transform = trs.join(" ");
        }.bind(this)
    );
};

ZoomDiagramNew.prototype.creteNodeholder = function (parent, point, i) {
    let nodeRect = point.getBBox();

    let nodeHolder = document.createElement("div");
    nodeHolder.className = "nodeholder";
    nodeHolder.style.top = nodeRect.y + "px";
    nodeHolder.style.left = nodeRect.x + "px";
    nodeHolder.style.width = nodeRect.width + "px";
    nodeHolder.style.height = nodeRect.height + "px";
    nodeHolder.style.zIndex = i;
    nodeHolder.setAttribute("data-index", i);
    parent.appendChild(nodeHolder);

    let img = document.createElement("img");
    img.style.setProperty("left", "unset", "important");
    img.style.setProperty("top", "unset", "important");
    img.className = "nodebg";
    img.id = "nodebg";

    nodeHolder.appendChild(img);

    let textParent = document.createElement("div");
    textParent.id = "textHolder";
    textParent.className = "textHolder";
    nodeHolder.appendChild(textParent);

    let text = document.createElement("div");
    text.id = "text";
    textParent.appendChild(text);

    let diagramNode = this.arrDiagramNode[i];
    if (diagramNode) {
        parent.appendChild(diagramNode.getNodeParent().parentElement);
        this.updateNodeFrame(diagramNode, point, textParent);
    }
    return nodeHolder;
};

ZoomDiagramNew.prototype.updateNodeFrame = function (node, point, text) {
    let nodeParent = node.getNodeParent().parentElement;
    let nodeRect = point.getBBox();
    let zoomScale = 1;
    if (nodeRect.width > nodeRect.height) zoomScale = this.diagramParent.offsetWidth / nodeRect.width;
    else if (nodeRect.width < nodeRect.height) zoomScale = this.diagramParent.offsetHeight / nodeRect.height;

    this.svgRectToDiv(nodeParent, point, zoomScale);

    let scale = nodeRect.width / nodeParent.offsetWidth;
    nodeParent.style.setProperty("transform-origin", "left top");
    nodeParent.style.transform = "scale(" + scale + ")";

    let textHolder = point.querySelector("[id*=text]");
    if (textHolder) {
        let textParent = nodeParent.firstElementChild; //nodeParent.querySelector("[name='nodeGroup']");
        this.svgRectToDiv(textParent, textHolder, zoomScale, true, point.getBBox());

        let primaryText = textParent.querySelector("[data-id='primaryTextNode']");
        primaryText.style.maxHeight = this.diagramData.properties.secondarytext ? "60%" : "100%";

        let hAlign = textHolder.id.includes("right") ? "right" : "center";
        hAlign = textHolder.id.includes("left") ? "left" : hAlign;
        let vAlign = textHolder.id.includes("top") ? "top" : "center";
        vAlign = textHolder.id.includes("bottom") ? "bottom" : vAlign;
        this.setTextAlign(nodeParent, hAlign, vAlign, text);

        if (this.zoomdata.nodeoverlap) {
            this.createDummyDiv(primaryText.parentElement);
        }
    }
};

ZoomDiagramNew.prototype.setTextAlign = function (node, textAlign, vertiacalAlign = "center", text) {
    let textParent = node.querySelector("[name='nodeGroup']");
    let contentVAlign = vertiacalAlign == "top" ? "flex-start" : "center";
    contentVAlign = vertiacalAlign == "bottom" ? "flex-end" : contentVAlign;
    textParent.style.justifyContent = contentVAlign;
    text.style.justifyContent = contentVAlign;
    if (!textParent) return;
    let title = node.querySelector("[data-id='primaryTextNode']");
    let subtitle = node.querySelector("[data-id='secondaryTextNode']");

    title.style.textAlign = textAlign;
    text.style.textAlign = textAlign;

    let contentAlignment = textAlign == "center" ? "center" : "flex-start";
    contentAlignment = textAlign == "right" ? "flex-end" : contentAlignment;
    subtitle.style.alignItems = contentAlignment;

    subtitle.className = subtitle.className.replace(" right", "").replace(" left", "").replace(" center", "");
    subtitle.className = subtitle.className + " " + textAlign;
};

ZoomDiagramNew.prototype.svgRectToDiv = function (div, svg, scale = 1, isScalePosition = false, offset = { x: 0, y: 0 }) {
    let svgRect = svg.getBBox();

    let positionScale = isScalePosition ? scale : 1;
    div.style.left = (svgRect.x - offset.x) * positionScale + "px";
    div.style.top = (svgRect.y - offset.y) * positionScale + "px";
    div.style.width = svgRect.width * scale + "px";
    div.style.height = svgRect.height * scale + "px";
};

ZoomDiagramNew.prototype.selectedItem = function (target, isAnimation = false) {
    let durationFactor = isAnimation ? 1 * this.durationRatio : 0;
    let delayFactor = isAnimation ? 1 * this.delayRatio : 0;

    let rect = DiagramNodeUtils.getOffsetRectByParent(this.diagramParent, target);
    let parentCenter = { x: this.diagramParent.clientWidth / 2, y: this.diagramParent.clientHeight / 2 };
    let targetCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };

    let centerDiff = { x: parentCenter.x - targetCenter.x, y: parentCenter.y - targetCenter.y };
    let left = 0;
    let top = 0;
    let zoomScale = 1;

    if (target.offsetWidth > target.offsetHeight) zoomScale = this.diagramParent.offsetWidth / target.offsetWidth;
    else if (target.offsetWidth < target.offsetHeight) zoomScale = this.diagramParent.offsetHeight / target.offsetHeight;
    left = centerDiff.x * zoomScale + "px";
    top = centerDiff.y * zoomScale + "px";

    if (this.zoomdata.nodeoverlap && this.zoomdata.nodeoverlap == "true")
        this.arrDiagramNode.map(function (node) {
            let nodeParent = node.getNodeParent().parentElement;
            nodeParent.style.opacity = 0;
            nodeParent.style.zIndex = 1;
        });

    let node = this.arrDiagramNode[target.dataset.index];
    if (node) {
        let nodeParent = node.getNodeParent().parentElement;
        nodeParent.style.transition = "all " + 0.5 * durationFactor + "s " + 1.5 * delayFactor + "s " + this.cubicPath + "";
        nodeParent.style.zIndex = 2;
        nodeParent.style.opacity = 1;
        this.currentNode = nodeParent;

        let text = nodeParent.querySelector("[data-id='primaryText']");
        let sectext = nodeParent.querySelector("[data-id='secondaryTextNode']");
        let dummytext = nodeParent.querySelector("[data-id='dummytext']");

        if (dummytext) {
            text.style.opacity = 1;
            sectext.style.opacity = 1;
            dummytext.style.transition = "opacity " + 1 * durationFactor + "s " + this.cubicPath + "";
            dummytext.style.opacity = 0;
        }
    }

    this.currentImgNode = this.pointImageHolder.querySelector("[id='pointimage']");
    if (this.currentImgNode) {
        this.currentImgNode.style.transition = "all " + this.zoomdata.point.duration * durationFactor + "s " + this.cubicPath + "";
        this.currentImgNode.style.opacity = 1;
    }

    let pointDelay = 0;
    pointDelay = this.zoomdata.point.isallowdelay != null && this.zoomdata.point.isallowdelay == false ? 0 : pointDelay;
    if (this.zoomdata.assetname == "zoom") this.pointImageHolder.style.transition = "all " + this.zoomdata.point.duration * durationFactor + "s " + this.cubicPath + "";
    else this.pointImageHolder.style.transition = "all " + this.zoomdata.point.duration * durationFactor + "s " + pointDelay * delayFactor + "s " + this.cubicPath + "";

    this.pointImageHolder.style.transform = "translate(" + left + ", " + top + ") scale(" + zoomScale + ") ";
    this.isScaled = true;

    let delayIncrementer = this.zoomdata.assetname == "zoom" ? 0 : 1;
    this.arrZoomImages.reverse().map(
        function (imgHolder, i) {
            if (imgHolder) {
                imgHolder.style.transition = "all " + this.zoomdata.point.duration * durationFactor + "s " + this.layerDelay * (i + delayIncrementer) * delayFactor + "s " + this.cubicPath + "";
                imgHolder.style.transform = "translate(" + left + ", " + top + ") scale(" + zoomScale + ") ";
                pointDelay = this.layerDelay * (i + delayIncrementer) * delayFactor;
                zoomScale += this.zoomDiff;
                left = centerDiff.x * zoomScale + "px";
                top = centerDiff.y * zoomScale + "px";
            }
        }.bind(this)
    );

    this.bgImage.style.transition = "all " + this.zoomdata.point.duration * durationFactor + "s " + pointDelay * delayFactor + "s " + this.cubicPath + "";
    this.bgImage.style.transform = "translate(" + left + ", " + top + ") scale(" + zoomScale + ") ";
    this.arrZoomImages.reverse();
};

ZoomDiagramNew.prototype.resetScale = function (isAnimation = false) {
    this.diagramData.properties.zoomdata = this.data()[this.nodeProps.centerShape];
    this.zoomdata = this.diagramData.properties.zoomdata;

    let durationFactor = isAnimation ? 1 * this.durationRatio : 0;
    let delayFactor = isAnimation ? 1 * this.delayRatio : 0;

    this.isScaled = false;
    let point = this.zoomdata.svg.type == "vary" ? this.diagramData.nodes.length + "point" : "";
    let bgSvg = this.diagramParent.querySelector("[id='" + point + this.zoomdata.assetname + "']");
    let svgRect = DiagramResizeUtils.getViewBoxRect(bgSvg);
    let scale = 1;

    if (svgRect.width > svgRect.height) {
        scale = this.diagramParent.clientWidth / svgRect.width;
    } else if (svgRect.width < svgRect.height) {
        scale = this.diagramParent.clientHeight / svgRect.height;
    }

    this.bgImage.style.transition = "all " + this.zoomdata.point.duration * durationFactor + "s " + this.cubicPath + "";
    this.bgImage.style.transform = "scale(" + scale + ")";

    let pointDelay = 0;
    let lastLayerDuration = 0;
    let lastLayerDelay = 0;
    this.arrZoomImages.map(
        function (imgHolder, i) {
            if (imgHolder) {
                imgHolder.style.transition = "all " + this.zoomdata.point.duration * durationFactor + "s " + this.layerDelay * (i + 1) * delayFactor + "s " + this.cubicPath + "";
                imgHolder.style.transform = "scale(" + scale + ")";
                if (this.arrZoomImages.length - 1 == i && this.zoomdata.assetname == "zoom") {
                    lastLayerDuration = this.zoomdata.point.duration * durationFactor;
                    lastLayerDelay = this.layerDelay * (i + 1) * delayFactor;
                }
                pointDelay = this.layerDelay * (i + 1) * delayFactor;
            }
        }.bind(this)
    );

    pointDelay = this.zoomdata.point.isallowdelay != null && this.zoomdata.point.isallowdelay == false ? 0 : pointDelay;
    if (this.zoomdata.assetname == "zoom") this.pointImageHolder.style.transition = "all " + lastLayerDuration + "s " + lastLayerDelay + "s " + this.cubicPath + "";
    else this.pointImageHolder.style.transition = "all " + this.zoomdata.point.duration * durationFactor + "s " + pointDelay * delayFactor + "s " + this.cubicPath + "";
    this.pointImageHolder.style.transform = "scale(" + scale + ")";

    this.arrDiagramNode.map(
        function (node) {
            let nodeParent = node.getNodeParent().parentElement;
            nodeParent.style.opacity = this.zoomdata.assetname == "zoom" ? 0 : 1;
            let text = nodeParent.querySelector("[data-id='primaryText']");
            let sectext = nodeParent.querySelector("[data-id='secondaryTextNode']");

            let dummytext = nodeParent.querySelector("[data-id='dummytext']");
            if (dummytext) {
                text.style.opacity = 0;
                sectext.style.opacity = 0;
                dummytext.style.transition = "opacity " + 1 * durationFactor + "s " + this.cubicPath + "";
                dummytext.style.opacity = 1;
            }
        }.bind(this)
    );

    this.currentImgNode = this.pointImageHolder.querySelector("[id='pointimage']");
    if (this.currentImgNode) {
        this.currentImgNode.style.opacity = this.zoomdata.assetname == "zoom" ? 0 : 1;
    }

    if (this.currentNode) {
        this.currentNode.style.transition = "all " + this.zoomdata.point.duration * durationFactor + "s " + this.cubicPath + "";
    }
};

ZoomDiagramNew.prototype.selectedItemAtIndex = function (index, isAnimation = false) {
    if (index == 0) {
        this.resetScale(false);
        this.showHideTitle(true);
        return;
    }
    this.showHideTitle(false);
    index -= 1;
    let arrNodeHolder = Array.from(this.diagramParent.querySelectorAll(".nodeholder"));
    let nodeHolder = arrNodeHolder[index];

    this.currentImgNode = this.pointImageHolder.querySelector("[id='pointimage']");
    if (this.zoomdata.assetname != "zoom") index = this.zoomdata.point.type == "vary" ? this.diagramData.nodes.length : "";
    else index = index + 1;

    // this.currentImgNode.style.setProperty(
    //     "background-image",
    //     "url(" + this.appStaticURL + "genericassets/shapes/" + this.zoomdata.assetname + "/point" + index + "." + this.zoomdata.point.format + ")"
    // );
    // if (this.zoomdata.assetname != "roadway")
    this.currentImgNode.src = this.appStaticURL + "genericassets/shapes/" + this.zoomdata.assetname + "/point" + index + "." + this.zoomdata.point.format;
    if (nodeHolder) this.selectedItem(nodeHolder, isAnimation);
};

ZoomDiagramNew.prototype.diagramRenderComplete = function () {
    if (this.completeCallBack && this.completeCallBack.func && this.isRenderComplete) {
        LinearDiagram.prototype.diagramRenderComplete.call(this);
    }
    this.diagramParent.style.opacity = 1;
};

ZoomDiagramNew.prototype.addNode = function (nodeData, index) {
    if (this.diagramData.nodes.length > index) {
        this.diagramData.nodes.splice(index, 0, nodeData);
    } else {
        this.diagramData.nodes.push(nodeData);
    }

    this.initDiagramCreation();
    this.updateEvents();
};

ZoomDiagramNew.prototype.deleteNode = function (targetIndex) {
    if (this.arrDiagramNode.length > targetIndex) {
        this.arrDiagramNode.splice(targetIndex, 1);
        let nodeDelete = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + targetIndex + "']");
        if (nodeDelete && nodeDelete.parentElement) {
            nodeDelete.parentElement.remove();
        }
    }
    if (this.diagramData.nodes.length > targetIndex) {
        this.diagramData.nodes.splice(targetIndex, 1);
    }
    this.initDiagramCreation();
    this.updateEvents();
};

//Animation function
ZoomDiagramNew.prototype.setupAnimation = function (animationType, callback) {
    this.animationCompleteCallback = callback;
    if (animationType == "none") {
        this.diagramParent.style.opacity = 1;
        this.showHideTitle(true);
        // setTimeout(() => {
        //     if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        // }, 1000);
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return;
    }

    this.animationIndex = 0;
    this.diagramParent.style.transition = "all 0s";
    this.diagramParent.style.opacity = 0;
    this.diagramParent.style.transform = "scale(1.2)";
    this.zoomdata = this.diagramData.properties.zoomdata;

    this.arrDiagramNode.map(
        function (node) {
            let nodeParent = node.getNodeParent().parentElement;
            nodeParent.style.opacity = 0;
            let text = nodeParent.querySelector("[data-id='primaryText']");
            text.style.transition = "all 0.5s";
            let sectext = nodeParent.querySelector("[data-id='secondaryTextNode']");
            sectext.style.transition = "all 0.5s";
            let dummytext = nodeParent.querySelector("[data-id='dummytext']");
            if (dummytext) {
                dummytext.style.transition = "all 0.5s";
            }
        }.bind(this)
    );

    this.diagramParent.style.transition = "all 2s " + this.cubicPath + "";
    this.diagramParent.style.opacity = 1;
    this.diagramParent.style.transform = "scale(1)";
    this.resetScale(true);
    if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);

    this.showHideTitle(true);
};

ZoomDiagramNew.prototype.playNext = function (index) {
    if (this.gotoNextSlide) return;

    if (this.animationIndex >= this.arrDiagramNode.length) {
        // this.resetScale(true);
        this.diagramParent.style.transition = "all 1s " + this.cubicPath + "";
        // this.diagramParent.style.opacity = 0;
        // this.animationIndex = this.arrDiagramNode.length - 1;
        this.gotoNextSlide = true;
        return false;
    }
    // ;

    this.diagramParent.style.opacity = 1;
    let delay = !this.isScaled ? 0 : 2500;
    this.isScaled ? this.resetScale(true) : "";

    setTimeout(() => {
        this.selectedItemAtIndex(this.animationIndex, true);
    }, delay);

    setTimeout(() => {
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, 2500);
    this.animationIndex += 1;
    return true;
};

ZoomDiagramNew.prototype.playPrevious = function (index) {
    this.gotoNextSlide = false;

    if (this.animationIndex <= 0) {
        this.diagramParent.style.transition = "all 1s " + this.cubicPath + "";
        this.diagramParent.style.opacity = 0;
        this.resetScale(true);
        return false;
    }
    this.resetScale(true);
    setTimeout(() => {
        this.selectedItemAtIndex(this.animationIndex, true);
    }, 2500);
    setTimeout(() => {
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    }, 2500);
    this.animationIndex -= 1;
    return true;
};

ZoomDiagramNew.prototype.focusCallBack = function (event) {
    LinearDiagram.prototype.focusCallBack.call(this, event);
    let index = event.target.dataset.index;
    let nodeItem = this.diagramParent.querySelector("[id='nodeitem" + index + "']");
    if (event.type == "focusin") {
        if (event.target.getAttribute("data-node-type") == "content") return;
    } else if (event.type == "focusout") {
        if (event.target.getAttribute("data-node-type") == "content") return;
        // DiagramResizeUtils.resetFontSizeForType(this.diagramParent, event.target.dataset.id);
    }
    if (event.type == "focusout" && event.target.id.includes("primary")) {
        if (event.target.offsetParent.offsetParent && this.zoomdata.nodeoverlap) {
            this.createDummyDiv(event.target.offsetParent);
        }
    }
};

ZoomDiagramNew.prototype.fitTextInShape = function (text) {
    text.style.transform = "scale(1)";
    let fitScale = text.clientWidth / text.scrollWidth;
    text.style.transform = "scale(" + fitScale + ")";
    text.style.setProperty("transform-origin", "left");
};

ZoomDiagramNew.prototype.splitSpan = function (text) {
    let arrWords = text.innerText.split(" ");
    let firstWord = arrWords.shift();
    let remainingWords = arrWords.join(" ");

    if (arrWords.length > 0) text.innerHTML = firstWord + " " + "<span>" + remainingWords + "</span>";
    else text.innerHTML = text.innerText;
};

ZoomDiagramNew.prototype.createDummyDiv = function (textParent) {
    return;
    let oldDiv = textParent.parentElement.querySelector("[data-id='dummytext']");
    if (oldDiv) oldDiv.parentElement.removeChild(oldDiv);
    if (this.zoomdata.nodeoverlap && this.zoomdata.nodeoverlap == "true") {
        let divdummy = textParent.cloneNode(true);
        divdummy.classList.add("hidespan");
        divdummy.id = "dummytext";
        divdummy.style.position = "absolute";
        divdummy.style.pointerEvents = "none";
        divdummy.setAttribute("data-id", "dummytext");
        divdummy.style.left = textParent.offsetLeft + "px";
        divdummy.style.top = textParent.offsetTop + "px";
        divdummy.style.opacity = 0;
        textParent.parentElement.appendChild(divdummy);

        divdummy.firstElementChild.id = "dummyPrimary";
        divdummy.firstElementChild.style.pointerEvents = "none";
        // divdummy.firstElementChild.firstElementChild.style.pointerEvents = "none";
        divdummy.firstElementChild.setAttribute("data-id", "dummyPrimary");
        divdummy.lastElementChild.id = "dummySecondary";
        divdummy.lastElementChild.setAttribute("data-id", "dummySecondary");
        divdummy.lastElementChild.style.pointerEvents = "none";
        divdummy.lastElementChild.style.opacity = 0;

        let arrDummySec = Array.from(divdummy.querySelectorAll("[name='secondaryTextItem']"));
        arrDummySec.map((duSec) => duSec.removeAttribute("name"));

        // this.splitSpan(divdummy.firstElementChild.firstElementChild);
    }
};
// imagelist is a array
// imagestackselectedindex current page index
ZoomDiagramNew.prototype.setupNavigation = function (navigationContent) {
    let list = JSON.parse(JSON.stringify(this.diagramData.nodes));
    list.push(this.diagramData.nodes[0]);
    navigationContent.imagelist = list;
    navigationContent.imagestackselectedindex = this.pageIndex;
    return navigationContent;
};

ZoomDiagramNew.prototype.navigation = function (navigation) {
    if (navigation.direction == "next" && !this.gotoNextSlide) {
        this.pageIndex += 1;
        if (this.pageIndex > this.arrDiagramNode.length) return false;
    } else {
        this.pageIndex -= 1;
        if (this.pageIndex < 0) return false;
    }

    this.resetScale(false);
    this.selectedItemAtIndex(this.pageIndex, false);
    return true;
};

ZoomDiagramNew.prototype.updatePage = function (operation) {
    this.pageIndex = operation.value;
    this.resetScale(false);
    this.selectedItemAtIndex(this.pageIndex, false);
};

ZoomDiagramNew.prototype.showHideTitle = function (isShow) {
    // TITLE SUBTITLE textElementParent FOOTER SLIDE_LABEL
    if (this.appmode == "DESIGN") {
        let display = isShow ? "block" : "none";
        let slide = document.getElementById(this.slideID);
        let title = slide.querySelector("[id='TITLE']");
        if (title) title.setAttribute("ExtraTitle", "");
        if (title) title.style.display = display;

        let subtitle = slide.querySelector("[id='SUBTITLE']");
        if (subtitle) subtitle.style.display = display;

        let textElement = slide.querySelector("[id='textElementParent']");
        if (textElement) textElement.style.display = display;

        // let footer = slide.querySelector("[id='FOOTER']");
        // if (footer) footer.style.display = display;

        let slidelable = slide.querySelector("[id='SLIDE_LABEL']");
        if (slidelable) slidelable.style.display = display;
    }
};

ZoomDiagramNew.prototype.initPresent = function (currentSlideData) {
    this.diagramParent = currentSlideData.querySelector("[id='diagramparent']");
    if (this.diagramParent) this.diagramParent.style.opacity = 0;

    // let titleNode = currentSlideData.querySelector("div[id='" + "TITLE" + "']");
    // let labelNode = currentSlideData.querySelector("div[id='" + "SLIDE_LABEL" + "']");
    // let subtitleNode = currentSlideData.querySelector("div[id='" + "SUBTITLE" + "']");
    // let elementNode = currentSlideData.querySelector("div[id='" + "textElement" + "']");
    // if (titleNode) titleNode.style.display = "none";
    // if (labelNode) labelNode.style.display = "none";
    // if (subtitleNode) subtitleNode.style.display = "none";
    // if (elementNode) elementNode.style.display = "none";

    return { isTitleAnimation: false, isGraphicAnimation: false };
};

ZoomDiagramNew.prototype.animateAfterMoodDelay = function () {
    LinearDiagram.prototype.animateAfterMoodDelay(this);
};

ZoomDiagramNew.prototype.setDiagramSpecficOption = function (obj) {
    obj.dpcontent.slidecomponent = { bgImage: false, takeAwayText: false };
    obj.isDisableLayoutOption = "true";
};

ZoomDiagramNew.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable.push("content");
        mainProperties.floateroptionsdisable.push("contentoptions");
        mainProperties.floateroptionsdisable.push("arrange");
    } else mainProperties.floateroptionsdisable = ["content", "contentoptions", "arrange"];
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

/**
 * Author:    Krishnan M.
 * Created:   14 Aug 2020
 *
 **/

"use strict";

function NonLinearPyramidDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearVerticalDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "clsLinerDiagram nonlinearpyramid";
    this.isRenderComplete = false;
    this.shapeIndex = 0;
    this.funnelGap = 0;
    this.isFillBg = true;
}

NonLinearPyramidDiagram.prototype = Object.create(SimpleLinearVerticalDiagram.prototype);
NonLinearPyramidDiagram.prototype.constructor = NonLinearPyramidDiagram;

NonLinearPyramidDiagram.prototype.initDiagramCreation = function () {
    this.diagramParent.innerHTML = "";
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.createPatternBackGround();
};

NonLinearPyramidDiagram.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsNodesHolderSvg";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    pattenDiv.setAttribute("data-node", nodeCount + "nodes");
    this.diagramParent.appendChild(pattenDiv);
    this.diagramParent.setAttribute("data-parenttype", "nonlinearcircular");
    // this.diagramParent.setAttribute("data-togglelists", "true");
    let contentSize = (pattenDiv.offsetHeight - (nodeCount - 1) * this.nodeGap) / nodeCount;
    this.height = this.nodeProps.centerShape.height || 100;
    this.marginleft = this.nodeProps.centerShape.marginleft || null;
    this.align = (this.nodeProps.centerShape.position && this.nodeProps.centerShape.position.split(",")[1]) || "top";
    this.basealign = (this.nodeProps.centerShape.position && this.nodeProps.centerShape.position.split(",")[0]) || "horizontal";
    this.diagramParent.setAttribute("data-align", this.align);
    this.diagramParent.setAttribute("data-basealign", this.basealign);
    this.diagramParent.setAttribute("data-disablelinearcontent", "true");

    pattenDiv.style.setProperty("--nodeWidth", "auto");
    pattenDiv.style.setProperty("--contentNodeWidth", "48px");
    pattenDiv.style.setProperty("--contentNodeHeight", "48px");
    pattenDiv.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    pattenDiv.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    pattenDiv.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    pattenDiv.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    pattenDiv.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");

    let circleWidth = (contentSize / 100) * 50;
    pattenDiv.style.setProperty("--circleSize", circleWidth + "px");

    this.createNodeInstances(nodeCount, pattenDiv);

    // if (this.diagramData.properties.sequencetext && this.diagramData.properties.diagramcontent) this.showHideContent({value: true});
    this.createDeviceHolder(pattenDiv, this.nodeProps.centerShape);
    this.isRenderComplete = true;
    this.diagramRenderComplete();
    // let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    // if (lastDiv) this.updatePropsCallBack(lastDiv.id);
};

NonLinearPyramidDiagram.prototype.recreateElementData = function (contentData = { id: "", value: "", contenttype: "image" }) {
    SimpleLinearVerticalDiagram.prototype.recreateElementData.call(this);
    let pattenDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    let centerItem = new window[this.nodeProps.nodeclassName](
        pattenDiv,
        {},
        {
            content: this.centerholderdata && this.centerholderdata.value != "" ? this.centerholderdata : this.centerHolderNode && this.centerHolderNode.objData.content.value != "" ? this.centerHolderNode.objData.content : contentData,
        },
        // { content: this.centerholderdata ? this.centerholderdata  : contentData },
        this.eventManagerXY,
        0,
        "",
        this.objStyleData,
        this.appStaticURL,
        this.nodeProps,
        this.diagramParent
    );
    let outerDiv = pattenDiv.querySelector("[data-id='outerDiv']");
    if (outerDiv) outerDiv.setAttribute("data-type", "device");
    centerItem.moodData = this.moodData;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;
    this.centerHolderNode = centerItem;
};

NonLinearPyramidDiagram.prototype.setPropertiesFromConstants = function (mainObj, constArrProperties, extraAttrib = "") {
    SimpleLinearVerticalDiagram.prototype.setPropertiesFromConstants.call(this, mainObj, constArrProperties, extraAttrib);
    let properties = this.diagramData.properties;
    this.diagramParent.setAttribute("data-shapeindex", properties.shapeindex ? properties.shapeindex : "0");
    this.diagramParent.setAttribute("data-stepped", !properties.hasOwnProperty("stepped") || (properties.hasOwnProperty("stepped") && properties["stepped"] == false) ? false : true);
    this.diagramParent.setAttribute("data-inverted", !properties.hasOwnProperty("inverted") || (properties.hasOwnProperty("inverted") && properties["inverted"] == false) ? false : true);
    this.diagramParent.setAttribute("data-isfillbg", !properties.hasOwnProperty("isfillbg") || (properties.hasOwnProperty("isfillbg") && properties["isfillbg"] == true) ? true : false);
};

NonLinearPyramidDiagram.prototype.hasProperty = function (properties, property) {
    return !properties.hasOwnProperty(property) || (properties.hasOwnProperty(property) && properties[property] == "true") ? true : false;
};

NonLinearPyramidDiagram.prototype.getProperties = function (defaultproperties = {}) {
    defaultproperties = SimpleLinearVerticalDiagram.prototype.getProperties.call(this, defaultproperties);
    defaultproperties.shapeindex = parseInt(this.diagramParent.dataset.shapeindex) || 0;
    this.shapeIndex = defaultproperties.shapeindex;
    defaultproperties.stepped = this.diagramParent.dataset.stepped && this.diagramParent.dataset.stepped == "true" ? true : false;
    defaultproperties.inverted = this.diagramParent.dataset.inverted && this.diagramParent.dataset.inverted == "true" ? true : false;
    defaultproperties.isfillbg = this.diagramParent.dataset.isfillbg && this.diagramParent.dataset.isfillbg == "true" ? true : false;
    this.isFillBg = defaultproperties.isfillbg;
    return defaultproperties;
};

NonLinearPyramidDiagram.prototype.showHideContent = function (operation) {
    this.diagramParent.parentElement.style.setProperty("--contentdisplay", !operation.value ? "none" : "flex");
    this.diagramParent.setAttribute("data-content", operation.value);
    this.diagramData.properties.diagramcontent = operation.value;

    // this.diagramParent.parentElement.style.setProperty("--numberdisplay", operation.value ? "none" : "flex");
    // this.diagramData.properties.sequencetext = !operation.value;

    this.updateProperties(this.diagramData.properties);
    this.updateFrame();
    this.slideDimensionChange();
};

NonLinearPyramidDiagram.prototype.showHideNumber = function (operation) {
    this.diagramParent.parentElement.style.setProperty("--numberdisplay", !operation.value ? "none" : "flex");
    this.diagramData.properties.sequencetext = operation.value;

    // this.diagramParent.parentElement.style.setProperty("--contentdisplay", operation.value ? "none" : "flex");
    // this.diagramParent.setAttribute("data-content", !operation.value);
    // this.diagramData.properties.diagramcontent = !operation.value;
    this.updateProperties(this.diagramData.properties);
    this.updateFrame();
    this.slideDimensionChange();
};

NonLinearPyramidDiagram.prototype.slideDimensionChange = function () {
    let parentDiv = this.diagramParent.querySelector("[name='nodesHolder']");

    if (parentDiv) {
        parentDiv.style.setProperty("--pathanimationtime", "0s");
        this.createDeviceHolder(parentDiv);
        let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
        if (lastDiv) this.updatePropsCallBack(lastDiv.id);
        setTimeout(() => {
            parentDiv.style.setProperty("--pathanimationtime", "0.6s");
        }, 1000);
    }
};

NonLinearPyramidDiagram.prototype.createDeviceHolder = function (parentDiv) {
    let oldHolder = this.diagramParent.querySelector("[data-id='deviceHolderParent']");
    if (oldHolder && oldHolder.parentElement) oldHolder.parentElement.removeChild(oldHolder);

    let centerHolderParent = document.createElement("div");
    centerHolderParent.setAttribute("data-id", "deviceHolderParent");
    centerHolderParent.className = "pyramidholder";
    parentDiv.appendChild(centerHolderParent);
    centerHolderParent.style.width = this.diagramParent.clientHeight * 0.9 + "px";
    centerHolderParent.style.height = this.diagramParent.clientHeight * 0.9 + "px";

    this.drawPyramid(centerHolderParent);
    if (this.diagramData.properties.stepped && this.diagramData.properties.inverted) {
        this.shapeIndex = 3;
    } else if (!this.diagramData.properties.stepped && !this.diagramData.properties.inverted) {
        this.shapeIndex = 0;
    } else if (this.diagramData.properties.stepped && !this.diagramData.properties.inverted) {
        this.shapeIndex = 2;
    } else if (!this.diagramData.properties.stepped && this.diagramData.properties.inverted) {
        this.shapeIndex = 1;
    }
    this.changeShapeTo(this.shapeIndex);
    setTimeout(() => {
        this.updateFrame();
    }, 100);
    this.updateCenterNodeEmphasize();
};

NonLinearPyramidDiagram.prototype.resizeNode = function (svgNode, alignment, position, parentDiv, deviceHolder) {
    if (position == "horizontal") {
        parentDiv.style.setProperty("width", "100%");
        let maxHeight = this.diagramParent.clientHeight * 0.5;
        let height = svgNode.clientHeight < maxHeight ? svgNode.clientHeight : maxHeight;
        let divideFactor = alignment == "alternate" ? 2 : 1;
        parentDiv.style.setProperty("--nodesMaxHeight", "calc(" + (this.diagramParent.clientHeight - height) + "px / " + divideFactor + " - 28px)");
        svgNode.style.height = height + "px";
    } else if (position == "vertical") {
        parentDiv.style.setProperty("height", "100%");
        let maxWidth = this.diagramParent.clientWidth * 0.5;
        let width = svgNode.clientWidth > maxWidth ? maxWidth : svgNode.clientWidth;
        // let divideFactor = alignment == "alternate" ? 2 : 1;
        let divideFactor = 2;
        parentDiv.style.setProperty("--nodesMaxWidth", "calc(" + (this.diagramParent.clientWidth - width) + "px / " + divideFactor + " - 28px)");
        deviceHolder.parentElement.style.width = width + "px";
    }
};

NonLinearPyramidDiagram.prototype.diagramRenderComplete = function () {
    if (this.completeCallBack && this.completeCallBack.func && this.isRenderComplete) {
        LinearDiagram.prototype.diagramRenderComplete.call(this);
    }
    this.diagramParent.style.opacity = 1;
};

NonLinearPyramidDiagram.prototype.addNode = function (nodeData, index) {
    if (this.diagramData.nodes.length > index) {
        this.diagramData.nodes.splice(index, 0, nodeData);
    } else {
        this.diagramData.nodes.push(nodeData);
    }
    this.initDiagramCreation();
    this.updateEvents();
};

NonLinearPyramidDiagram.prototype.deleteNode = function (targetIndex) {
    if (this.arrDiagramNode.length > targetIndex) {
        this.arrDiagramNode.splice(targetIndex, 1);
        let nodeDelete = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + targetIndex + "']");
        if (nodeDelete && nodeDelete.parentElement) {
            nodeDelete.parentElement.remove();
        }
    }
    if (this.diagramData.nodes.length > targetIndex) {
        this.diagramData.nodes.splice(targetIndex, 1);
    }
    this.initDiagramCreation();
    this.updateEvents();
};

NonLinearPyramidDiagram.prototype.resetHolderWidth = function () {
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    nodesHolder.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    nodesHolder.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    nodesHolder.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    nodesHolder.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    nodesHolder.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");
};

NonLinearPyramidDiagram.prototype.setHighlightPosition = function (node, parent) {
    let nodeParent = node.parentElement;
    let element = nodeParent.querySelector("[data-id='diagramContentNode']");
    if (!element || element.clientWidth == 0) element = node;
    return { element: element, alignment: "vertical" };
};

//Draw Pyramid related function

NonLinearPyramidDiagram.prototype.drawPyramid = function (holderDiv) {
    let oldSvg = this.diagramParent.querySelector("[id='pyramidsvg']");
    if (oldSvg && oldSvg.parentElement) oldSvg.parentElement.removeChild(oldSvg);

    let svg = DiagramNodeUtils.createSVGElement("svg");
    DiagramNodeUtils.assignSVGNodeAttributes(svg, { class: "pyramidsvg", id: "pyramidsvg", width: holderDiv.clientWidth, height: holderDiv.clientHeight });
    holderDiv.appendChild(svg);

    let arrShapePoints = this.getTriangleShapePoints(svg, false, this.funnelGap);

    arrShapePoints.map(
        function (arrPoints, i) {
            let strD = this.getPathString(arrPoints);

            let path = DiagramNodeUtils.createSVGElement("path");
            DiagramNodeUtils.assignSVGNodeAttributes(path, { d: strD, class: "shapepath clsMultiColorParent moodanimation", "data-animation": "itemshape" });
            DiagramUtils.setCustomItemColor(path, this.arrTintArray, i, i + 1);
            svg.appendChild(path);

            let node = this.arrDiagramNode[i];
            let nodeParent = node.getNodeParent().parentElement;

            let pathRect = path.getBBox();
            let point1 = { x: pathRect.x + pathRect.width + 30, y: pathRect.y + pathRect.height };
            let point2 = { x: holderDiv.parentElement.clientWidth, y: pathRect.y + pathRect.height };
            let line = this.createLine(point1, point2);
            line.setAttribute("style", "stroke:rgba(var(--secondary-color-rgb), 1);");
            line.setAttribute("data-id", "underline" + i);
            line.setAttribute("data-animation", "itemshape");
            line.setAttribute("class", "moodanimation");

            let group = DiagramNodeUtils.createSVGElement("g");
            group.setAttribute("opacity", "0.3");
            group.appendChild(line);
            svg.appendChild(group);

            this.svgRectToDiv(nodeParent, path);
        }.bind(this)
    );

    this.updateFrame();
    this.diagramParent.style.setProperty("--iconnodewidth", "70%");
    this.diagramParent.style.setProperty("--iconnodeheight", "70%");
};

NonLinearPyramidDiagram.prototype.createLine = function (startPoint, endPoint) {
    let line = DiagramNodeUtils.createSVGElement("line");
    DiagramNodeUtils.assignSVGNodeAttributes(line, { x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y, stroke: "none", "stroke-width": 2, "data-id": "line" });
    return line;
};

NonLinearPyramidDiagram.prototype.updateUnderLineFrame = function (svg) {
    let arrPath = Array.from(svg.querySelectorAll("path"));
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    arrPath.map(
        function (path, i) {
            let pathRect = path.getBBox();
            // if (this.diagramParent.dataset.stepped == "true" && this.diagramParent.dataset.inverted == "false") {
            //     pathRect.y = pathRect.y - pathRect.height;
            // }
            let offset = 30;
            let startPoint = { x: pathRect.x + pathRect.width + offset, y: pathRect.y + pathRect.height };
            let endPoint = { x: nodesHolder.clientWidth, y: pathRect.y + pathRect.height };
            let line = svg.querySelector("[data-id='underline" + i + "']");
            if (line) {
                DiagramNodeUtils.assignSVGNodeAttributes(line, { x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y });
            }
        }.bind(this)
    );
};

NonLinearPyramidDiagram.prototype.getPolygenString = function (arrPoints) {
    let pointString = "";
    arrPoints.map((point, i) => {
        pointString = pointString + (i == 0 ? "" : " ") + point.x + "," + point.y;
    });
    return pointString;
};

NonLinearPyramidDiagram.prototype.getPathString = function (arrPoints) {
    let pointString = "";
    arrPoints.map((point, i) => {
        let pathComponent = i == 0 ? "M" : "L";
        pointString = pointString + (i == 0 ? "" + pathComponent : " " + pathComponent) + point.x + "," + point.y;
    });
    return pointString + " Z";
};

NonLinearPyramidDiagram.prototype.checkIntersection = function (x1, y1, x2, y2, x3, y3, x4, y4) {
    var ua,
        ub,
        denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    if (denom == 0) {
        return null;
    }
    ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
    ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
    return {
        x: x1 + ua * (x2 - x1),
        y: y1 + ua * (y2 - y1),
        seg1: ua >= 0 && ua <= 1,
        seg2: ub >= 0 && ub <= 1,
    };
};

NonLinearPyramidDiagram.prototype.getTriangleShapePoints = function (svg, isInverse = false, funnelGap = 0) {
    let arrLines = Array.from(svg.querySelectorAll("[data-id='line']"));
    arrLines.map((line) => svg.removeChild(line));

    let svgRect = { x: 0, y: 0, width: svg.parentElement.offsetWidth, height: svg.parentElement.offsetHeight };
    let l1 = this.createLine({ x: svgRect.width / 2 - funnelGap / 2, y: 0 }, { x: 0, y: svgRect.height });
    let l2 = this.createLine({ x: svgRect.width / 2 + funnelGap / 2, y: 0 }, { x: svgRect.width, y: svgRect.height });

    if (isInverse) {
        l1 = this.createLine({ x: 0, y: 0 }, { x: svgRect.width / 2 - funnelGap / 2, y: svgRect.height });
        l2 = this.createLine({ x: svgRect.width, y: 0 }, { x: svgRect.width / 2 + funnelGap / 2, y: svgRect.height });
    }

    svg.appendChild(l1);
    svg.appendChild(l2);

    let count = this.arrDiagramNode.length;
    let nodeHeight = svgRect.height / count;
    let arrNodeShapePoints = [];
    for (var i = 1; i <= count; i++) {
        let arrPathPoints = [];
        let line = this.createLine({ x: 0, y: nodeHeight * i }, { x: svgRect.width, y: nodeHeight * i });
        svg.appendChild(line);

        if (i == 1) {
            arrPathPoints.push({ x: isInverse ? 0 : svgRect.width / 2 - funnelGap / 2, y: 0 });
            arrPathPoints.push({ x: isInverse ? svgRect.width : svgRect.width / 2 + funnelGap / 2, y: 0 });
            const point3 = this.checkIntersection(l2.x1.baseVal.value, l2.y1.baseVal.value, l2.x2.baseVal.value, l2.y2.baseVal.value, line.x1.baseVal.value, line.y1.baseVal.value, line.x2.baseVal.value, line.y2.baseVal.value);
            arrPathPoints.push({ x: point3.x, y: point3.y });
            const point4 = this.checkIntersection(l1.x1.baseVal.value, l1.y1.baseVal.value, l1.x2.baseVal.value, l1.y2.baseVal.value, line.x1.baseVal.value, line.y1.baseVal.value, line.x2.baseVal.value, line.y2.baseVal.value);
            arrPathPoints.push({ x: point4.x, y: point4.y });
        } else if (i > 1) {
            let arrPoints = arrNodeShapePoints[i - 2];
            arrPathPoints.push(JSON.parse(JSON.stringify(arrPoints[3])));
            arrPathPoints.push(JSON.parse(JSON.stringify(arrPoints[2])));
            const point3 = this.checkIntersection(l2.x1.baseVal.value, l2.y1.baseVal.value, l2.x2.baseVal.value, l2.y2.baseVal.value, line.x1.baseVal.value, line.y1.baseVal.value, line.x2.baseVal.value, line.y2.baseVal.value);
            arrPathPoints.push({ x: point3.x, y: point3.y });
            const point4 = this.checkIntersection(l1.x1.baseVal.value, l1.y1.baseVal.value, l1.x2.baseVal.value, l1.y2.baseVal.value, line.x1.baseVal.value, line.y1.baseVal.value, line.x2.baseVal.value, line.y2.baseVal.value);
            arrPathPoints.push({ x: point4.x, y: point4.y });
        }

        arrNodeShapePoints.push(arrPathPoints);
    }

    return arrNodeShapePoints;
};

NonLinearPyramidDiagram.prototype.getSquareShapePoints = function (svg, isInverse = false, funnelGap = 0) {
    let arrLines = Array.from(svg.querySelectorAll("[data-id='line']"));
    arrLines.map((line) => svg.removeChild(line));

    let svgRect = { x: 0, y: 0, width: svg.parentElement.offsetWidth, height: svg.parentElement.offsetHeight };
    let l1 = this.createLine({ x: svgRect.width / 2 - funnelGap / 2, y: 0 }, { x: 0, y: svgRect.height });
    let l2 = this.createLine({ x: svgRect.width / 2 + funnelGap / 2, y: 0 }, { x: svgRect.width, y: svgRect.height });

    if (isInverse) {
        l1 = this.createLine({ x: 0, y: 0 }, { x: svgRect.width / 2 - funnelGap / 2, y: svgRect.height });
        l2 = this.createLine({ x: svgRect.width, y: 0 }, { x: svgRect.width / 2 + funnelGap / 2, y: svgRect.height });
    }
    // let svgRect = svg.getBoundingClientRect(); //svg.getBBox();
    // let l1 = this.createLine({ x: svgRect.width / 2, y: 0 }, { x: 0, y: svgRect.height });
    // let l2 = this.createLine({ x: svgRect.width / 2, y: 0 }, { x: svgRect.width, y: svgRect.height });

    // if (isInverse) {
    //     l1 = this.createLine({ x: 0, y: 0 }, { x: svgRect.width / 2, y: svgRect.height });
    //     l2 = this.createLine({ x: svgRect.width, y: 0 }, { x: svgRect.width / 2, y: svgRect.height });
    // }

    svg.appendChild(l1);
    svg.appendChild(l2);

    let count = this.arrDiagramNode.length;
    let nodeHeight = svgRect.height / count;
    let arrNodeShapePoints = [];
    let startValue = isInverse ? 0 : 1;
    for (var i = startValue; i <= count; i++) {
        let arrPathPoints = [];
        let line = this.createLine({ x: 0, y: nodeHeight * i }, { x: svgRect.width, y: nodeHeight * i });
        svg.appendChild(line);

        if (!isInverse) {
            const point4 = this.checkIntersection(l1.x1.baseVal.value, l1.y1.baseVal.value, l1.x2.baseVal.value, l1.y2.baseVal.value, line.x1.baseVal.value, line.y1.baseVal.value, line.x2.baseVal.value, line.y2.baseVal.value);
            arrPathPoints.push({ x: point4.x, y: point4.y - nodeHeight });

            const point3 = this.checkIntersection(l2.x1.baseVal.value, l2.y1.baseVal.value, l2.x2.baseVal.value, l2.y2.baseVal.value, line.x1.baseVal.value, line.y1.baseVal.value, line.x2.baseVal.value, line.y2.baseVal.value);
            arrPathPoints.push({ x: point3.x, y: point3.y - nodeHeight });

            arrPathPoints.push({ x: point3.x, y: point3.y });
            arrPathPoints.push({ x: point4.x, y: point4.y });
        } else {
            const point4 = this.checkIntersection(l1.x1.baseVal.value, l1.y1.baseVal.value, l1.x2.baseVal.value, l1.y2.baseVal.value, line.x1.baseVal.value, line.y1.baseVal.value, line.x2.baseVal.value, line.y2.baseVal.value);
            arrPathPoints.push({ x: point4.x, y: point4.y });

            const point3 = this.checkIntersection(l2.x1.baseVal.value, l2.y1.baseVal.value, l2.x2.baseVal.value, l2.y2.baseVal.value, line.x1.baseVal.value, line.y1.baseVal.value, line.x2.baseVal.value, line.y2.baseVal.value);
            arrPathPoints.push({ x: point3.x, y: point3.y });

            arrPathPoints.push({ x: point3.x, y: point3.y + nodeHeight });
            arrPathPoints.push({ x: point4.x, y: point4.y + nodeHeight });
        }

        arrNodeShapePoints.push(arrPathPoints);
    }

    return arrNodeShapePoints;
};

NonLinearPyramidDiagram.prototype.changePathPoints = function (svg, i, d) {
    let arrSvgPath = Array.from(svg.querySelectorAll("path"));
    let path = arrSvgPath[i];
    if (path) path.setAttribute("d", d);
};

NonLinearPyramidDiagram.prototype.changeShapeTo = function (index = 0) {
    let svg = this.diagramParent.querySelector("[id='pyramidsvg']");
    let arrShapePoints = this.getTriangleShapePoints(svg, false, this.funnelGap);
    if (index == 1) {
        arrShapePoints = this.getTriangleShapePoints(svg, true, this.funnelGap);
    } else if (index == 2) {
        arrShapePoints = this.getSquareShapePoints(svg, false, this.funnelGap);
    } else if (index == 3) {
        arrShapePoints = this.getSquareShapePoints(svg, true, this.funnelGap);
    }

    if (!svg) return;
    arrShapePoints.map(
        function (arrPoints, i) {
            let strD = this.getPathString(arrPoints);
            this.changePathPoints(svg, i, strD);
        }.bind(this)
    );
};

NonLinearPyramidDiagram.prototype.svgRectToDiv = function (div, svg) {
    let svgRect = svg.getBBox();

    let contentNode = div.querySelector("[data-id='diagramContentNode']");
    contentNode.style.width = svgRect.width + "px";
    contentNode.style.height = svgRect.height + "px";

    let content = div.querySelector("[data-id='contenticonparent']");
    content.style.bottom = "unset";
    content.style.top = "unset";

    div.classList.remove("contentoff");
    if (this.diagramData.properties.sequencetext) {
        let offset = this.diagramData.properties.diagramcontent ? 150 : 0;
        if (!this.diagramData.properties.diagramcontent) div.classList.add("contentoff");
        div.classList.remove("numberoff");
        contentNode.style.width = svgRect.width + offset + "px";
        contentNode.style.flexDirection = "row-reverse";
        let sequencetext = div.querySelector("[data-id='sequenceTextNode']");
        sequencetext.style.width = svgRect.width + "px";
        sequencetext.style.height = svgRect.height + "px";
        content.style.width = offset + "px";
    } else {
        content.style.width = svgRect.width + "px";
        div.classList.add("numberoff");
        this.diagramParent.parentElement.style.setProperty("--numberdisplay", "none");

        if (!this.diagramData.properties.stepped && !this.diagramData.properties.inverted) {
            if (div.dataset.index == 0) content.style.top = "15px";
        } else if (!this.diagramData.properties.stepped && this.diagramData.properties.inverted) {
            if (div.dataset.index == this.diagramData.nodes.length - 1) content.style.bottom = "15px";
        }
    }

    let parentOffset = 50;
    let offsetWidth = this.diagramParent.clientWidth - parentOffset - svgRect.x;
    div.style.left = svgRect.x + "px";
    div.style.width = offsetWidth + "px";
    div.style.height = svgRect.height + "px";
    div.style.maxHeight = div.style.height + "px";

    let secContent = div.querySelector("[name='secContentNode']");
    if (secContent) secContent.style.maxHeight = div.style.height + "px";
};

NonLinearPyramidDiagram.prototype.updateFrame = function () {
    let svg = this.diagramParent.querySelector("[id='pyramidsvg']");
    if (!svg) return;
    let arrPath = Array.from(svg.querySelectorAll("path"));

    arrPath.map(
        function (path, i) {
            let node = this.arrDiagramNode[i];
            if (node) {
                let nodeParent = node.getNodeParent().parentElement;
                this.svgRectToDiv(nodeParent, path);
                this.updateColor(path, i, nodeParent);
            }
        }.bind(this)
    );

    if (svg && this.isFillBg) {
        svg.classList.remove("nooutline");
        svg.classList.add("nooutline");
    } else svg.classList.remove("nooutline");
    this.updateUnderLineFrame(svg);
    this.resetNodeAttributes();
    // this.updateEvents();
};

NonLinearPyramidDiagram.prototype.setDiagramSpecficOption = function (obj) {
    let pyramidoption = {};
    pyramidoption.stepped = { visible: true, isOn: this.shapeIndex == 2 || this.shapeIndex == 3 };
    pyramidoption.inverse = { visible: true, isOn: this.shapeIndex == 1 || this.shapeIndex == 3 };
    pyramidoption.isfill = { visible: true, isOn: this.isFillBg };
    obj.dpcontent.floatdiagramsettings.pyramidoption = pyramidoption;
};

NonLinearPyramidDiagram.prototype.changeShape = function (operation) {
    if (operation.property == "stepped") {
        this.diagramData.properties.stepped = operation.value;
    } else if (operation.property == "inverted") {
        this.diagramData.properties.inverted = operation.value;
    }

    if (this.diagramData.properties.stepped && this.diagramData.properties.inverted) {
        this.shapeIndex = 3;
    } else if (!this.diagramData.properties.stepped && !this.diagramData.properties.inverted) {
        this.shapeIndex = 0;
    } else if (this.diagramData.properties.stepped && !this.diagramData.properties.inverted) {
        this.shapeIndex = 2;
    } else if (!this.diagramData.properties.stepped && this.diagramData.properties.inverted) {
        this.shapeIndex = 1;
    }

    this.diagramData.properties.shapeindex = this.shapeIndex;
    this.updateProperties(this.diagramData.properties);
    this.changeShapeTo(this.shapeIndex);
    setTimeout(() => {
        this.updateFrame();
    }, 500);
};

NonLinearPyramidDiagram.prototype.updateColor = function (path, i, node) {
    path.classList.remove("clsAccentStroke");
    path.classList.remove("clsAccentfill");
    path.classList.add("clsAccentStroke");

    if (this.isFillBg) path.classList.add("clsAccentfill");

    let iconNode = node.querySelector("[data-id='contenticonparent']");
    let use = iconNode.querySelector("[id='useNode']");
    let sequenceTextNode = node.querySelector("[data-id='sequenceTextNode']");

    if (use) {
        use.classList.remove("clsAccentfill");
        use.classList.remove("clsContrastFill");

        use.classList.add(this.isFillBg && !this.diagramData.properties.sequencetext ? "clsContrastFill" : "clsAccentfill");
    }

    if (sequenceTextNode) {
        sequenceTextNode.classList.remove("background-color");
        !this.isFillBg ? sequenceTextNode.classList.remove("background-color") : sequenceTextNode.classList.add("background-color");
        sequenceTextNode.classList.remove("inner-color");
        sequenceTextNode.classList.remove("clsAccentColor");

        sequenceTextNode.classList.add(this.isFillBg ? "inner-color" : "clsAccentColor");
    }
};

NonLinearPyramidDiagram.prototype.updateBgColor = function (operation) {
    this.isFillBg = operation.value;
    this.diagramData.properties.isfillbg = operation.value;
    this.updateProperties(this.diagramData.properties);
    this.updateFrame();
};

// NonLinearPyramidDiagram.prototype.emphasize = function(emphasizeData) {
//     LinearDiagram.prototype.emphasize.call(this, emphasizeData);
//     this.updatePyramidEmphasize();
// };

// NonLinearPyramidDiagram.prototype.updateEmphasize = function() {
//     LinearDiagram.prototype.updateEmphasize.call(this);
//     this.updatePyramidEmphasize();
// };

NonLinearPyramidDiagram.prototype.updateCenterNodeEmphasize = function () {
    // LinearDiagram.prototype.updateCenterNodeEmphasize.call(this);
    // this.updatePyramidEmphasize();
};

NonLinearPyramidDiagram.prototype.updatePyramidEmphasize = function () {
    let centerNode = this.diagramParent.querySelector("[id='pyramidholder']");
    if (!centerNode) return;
    let arrPath = Array.from(centerNode.querySelectorAll("path"));
    this.arrDiagramNode.map(
        function (node, i) {
            let nodeParent = nodeParent;
            if (nodeParent) {
                nodeParent.setAttribute("data-emphasizecontentbg", !this.diagramData.properties.sequencetext);
                nodeParent.setAttribute("data-emphasizenumberbg", true);
                let path = arrPath[i];
                if (path) {
                    path.setAttribute("data-emphasizetype", nodeParent.dataset.emphasizetype || "");
                    path.setAttribute("data-emphasize", nodeParent.dataset.emphasize || "");
                }
            }
        }.bind(this)
    );
};

NonLinearPyramidDiagram.prototype.setHighlightPosition = function (node, parent) {
    let nodeParent = node.parentElement;
    let element = nodeParent.querySelector("[data-id='diagramContentNode']");
    if (!element || element.clientWidth == 0) element = node;

    let alignment = "vertical";
    let nodeAngle = parseInt(nodeParent.dataset.angle);
    if (nodeAngle > 0 && nodeAngle < 180) alignment = "left";
    else if (nodeAngle > 180 && nodeAngle < 360) alignment = "right";

    return { element: element, alignment: alignment };
};

NonLinearPyramidDiagram.prototype.isNonLinearAsset = function () {
    return true;
};

/**
 * Author:    Krishna
 * Created:   21 Nov 2019
 *
 * (c) Copyright by Krishna.
 **/

"use strict";

function NonLinearFunnelDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    NonLinearPyramidDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.shapeIndex = 0;
    this.funnelGap = 150;
}

NonLinearFunnelDiagram.prototype = Object.create(NonLinearPyramidDiagram.prototype);
NonLinearFunnelDiagram.prototype.constructor = NonLinearFunnelDiagram;

NonLinearFunnelDiagram.prototype.initDiagramCreation = function() {
    NonLinearPyramidDiagram.prototype.initDiagramCreation.call(this);
};


NonLinearFunnelDiagram.prototype.drawPyramid = function(holderDiv) {
    let svg = DiagramNodeUtils.createSVGElement("svg");
    DiagramNodeUtils.assignSVGNodeAttributes(svg, { class: "pyramidsvg", id: "pyramidsvg" });
    holderDiv.appendChild(svg);

    let arrShapePoints = this.getTriangleShapePoints(svg, true, this.funnelGap);

    arrShapePoints.map(
        function(arrPoints, i) {
            let strD = this.getPathString(arrPoints);

            let path = DiagramNodeUtils.createSVGElement("path");
            DiagramNodeUtils.assignSVGNodeAttributes(path, { d: strD, class: "shapepath clsMultiColorParent moodanimation", "data-animation": "itemshape"});
            DiagramUtils.setCustomItemColor(path, this.arrTintArray, i, i + 1);
            svg.appendChild(path);

            let node = this.arrDiagramNode[i];
            let nodeParent = node.getNodeParent().parentElement;
            svg.parentElement.appendChild(nodeParent);

            let pathRect = path.getBBox();
            let point1 = { x: pathRect.x + pathRect.width + 30, y: pathRect.y + pathRect.height };
            let point2 = { x: holderDiv.parentElement.clientWidth, y: pathRect.y + pathRect.height };
            let line = this.createLine(point1, point2);
            line.setAttribute("style", "stroke:rgba(var(--secondary-color-rgb), 1);");
            line.setAttribute("data-id", "underline" + i);
            line.setAttribute("data-animation", "itemshape");
            line.setAttribute("class", "moodanimation");
            
            let group = DiagramNodeUtils.createSVGElement("g");
            group.setAttribute("opacity", "0.3");
            group.appendChild(line);
            svg.appendChild(group);

            this.svgRectToDiv(nodeParent, path);
        }.bind(this)
    );

    this.updateFrame();
};

NonLinearFunnelDiagram.prototype.updateElements = function(defaultproperties) {
    NonLinearPyramidDiagram.prototype.updateElements.call(this, defaultproperties);
    this.funnelGap = 150;
    if (this.diagramParent.dataset.shapeindex) {
        this.shapeIndex = parseInt(this.diagramParent.dataset.shapeindex);
    }
};

NonLinearFunnelDiagram.prototype.changeShapeTo = function(index = 0) {
    
    let svg = this.diagramParent.querySelector("[id='pyramidsvg']");
    let arrShapePoints = this.getTriangleShapePoints(svg, true, this.funnelGap);
    if (index == 1) {
        arrShapePoints = this.getTriangleShapePoints(svg, true, this.funnelGap);
    } else if (index == 2) {
        arrShapePoints = this.getSquareShapePoints(svg, true, this.funnelGap);
    } else if (index == 3) {
        arrShapePoints = this.getSquareShapePoints(svg, true, this.funnelGap);
    }

    if (!svg) return;
    arrShapePoints.map(
        function(arrPoints, i) {
            let strD = this.getPathString(arrPoints);
            this.changePathPoints(svg, i, strD);
        }.bind(this)
    );
};

NonLinearFunnelDiagram.prototype.setDiagramSpecficOption = function(obj) {
    let pyramidoption = {};
    pyramidoption.stepped = { visible: true, isOn: this.shapeIndex == 2 || this.shapeIndex == 3 };
    pyramidoption.inverse = { visible: false, isOn: this.shapeIndex == 1 || this.shapeIndex == 3 };
    pyramidoption.isfill = { visible: true, isOn: this.isFillBg};
    obj.dpcontent.floatdiagramsettings.pyramidoption = pyramidoption;
};


"use strict";

function SvgMultiSlideDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearVerticalDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "multislidediagram";
    this.multiSlideSvg = null;
    this.multiSlideSvgId = null;
    this.multiSlideType = "vertical";
    this.targetIndex = 0;
    this.isRenderComplete = false;
    this.durationFactor = 1;
    this.diagramParent.style.setProperty("--iconnodewidth", "100%");
    this.diagramParent.style.setProperty("--iconnodeheight", "100%");
    this.diagramParent.parentElement.setAttribute("data-ismultislide", true);
    this.diagramParent.parentElement.setAttribute("data-customtitleanimation", true);
    this.diagramParent.parentElement.setAttribute("data-animationtype", "one");
}

SvgMultiSlideDiagram.prototype = Object.create(SimpleLinearVerticalDiagram.prototype);
SvgMultiSlideDiagram.prototype.constructor = SvgMultiSlideDiagram;

SvgMultiSlideDiagram.prototype.initDiagramCreation = function () {
    //Minimum 2 nodes condition
    this.diagramParent.style.opacity = 0;
    if (this.diagramData.nodes.length == 1) {
        let nodeData = JSON.parse(JSON.stringify(this.diagramData.nodes[0]));
        this.diagramData.nodes.push(nodeData);
    }
    this.diagramData.properties.customproperties = this.nodeProps.centerShape; //this.diagramData.properties.customproperties ? this.diagramData.properties.customproperties : this.nodeProps.centerShape;
    this.updateCustomProperties(this.diagramData.properties.customproperties);
    this.targetIndex = 0;
    let assetStyle = this.diagramData.properties && this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.style ? this.diagramData.properties.customproperties.style : "vertical";
    this.multiSlideType = assetStyle;
    this.diagramParent.setAttribute("data-multislidetype", this.multiSlideType);
    let textStyle = this.diagramData.properties && this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.textstyle ? this.diagramData.properties.customproperties.textstyle : "";
    this.diagramParent.setAttribute("textStyle", textStyle);

    if (!this.isTempSlide) this.diagramParent.style.opacity = 0;
    this.diagramParent.innerHTML = "";
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.createPatternBackGround();
};

SvgMultiSlideDiagram.prototype.createElements = function () {
    SimpleLinearVerticalDiagram.prototype.createElements.call(this);
    this.setupSvg();
};

SvgMultiSlideDiagram.prototype.setupSvg = function () {
    let svgMainParent = document.createElement("div");
    svgMainParent.id = "svgMainParent";
    svgMainParent.className = "svgMainParent";
    svgMainParent.style.width = "100%";
    svgMainParent.style.height = "100%";
    this.diagramParent.appendChild(svgMainParent);

    let svgHolderDiv = document.createElement("div");
    svgHolderDiv.id = "svgHolderDiv";
    svgHolderDiv.className = "svgHolderDiv";
    svgHolderDiv.style.width = "auto";
    svgHolderDiv.style.height = "auto";
    if (this.multiSlideType == "horizontal") svgHolderDiv.style.display = "inline-flex";
    if (this.multiSlideType == "vertical") {
        svgHolderDiv.style.display = "flex";
        svgHolderDiv.style.flexDirection = "column";
    }
    svgMainParent.appendChild(svgHolderDiv);

    let svgDefsLocal = this.diagramParent.querySelector("[id='svgDefsLocal']");
    if (svgDefsLocal) svgDefsLocal.style.display = "block";
    this.targetIndex = 0;

    //Loading Multi slide SVG shape
    this.addSvgShape(this.diagramParent, this.diagramData);
};

SvgMultiSlideDiagram.prototype.diagramRenderComplete = function () {
    if (this.completeCallBack && this.completeCallBack.func && this.isRenderComplete) {
        LinearDiagram.prototype.diagramRenderComplete.call(this);
    }
    this.diagramParent.style.opacity = 1;
};

SvgMultiSlideDiagram.prototype.updateElements = function (defaultproperties) {
    SimpleLinearVerticalDiagram.prototype.updateElements.call(this, defaultproperties);
    if (this.diagramParent) {
        this.targetIndex = 0;
        this.doNodeAnimation(false);
    }
};

// Update custom props to diagram parent
SvgMultiSlideDiagram.prototype.updateCustomProperties = function (customproperties) {
    let multislideCustomproperties = customproperties ? customproperties : {};
    this.diagramParent.setAttribute("data-multislide-style", multislideCustomproperties.style ? multislideCustomproperties.style : "");
    this.diagramParent.setAttribute("data-multislide-textstyle", multislideCustomproperties.textstyle ? multislideCustomproperties.textstyle : "");
    if (multislideCustomproperties.innercontentdata) {
        this.diagramParent.setAttribute("data-multislide-innercontentvalue", multislideCustomproperties.innercontentdata.content.value || "");
        this.diagramParent.setAttribute("data-multislide-innercontentid", multislideCustomproperties.innercontentdata.content.id || "");
    }
};

SvgMultiSlideDiagram.prototype.setPropertiesFromConstants = function (mainObj, constArrProperties, extraAttrib = "") {
    SimpleLinearVerticalDiagram.prototype.setPropertiesFromConstants.call(this, mainObj, constArrProperties, extraAttrib);
    if (this.diagramData.properties.customproperties) {
        this.updateCustomProperties(this.diagramData.properties.customproperties);
    }
};

SvgMultiSlideDiagram.prototype.getProperties = function (defaultproperties = {}) {
    let properties = SimpleLinearVerticalDiagram.prototype.getProperties.call(this, defaultproperties);
    properties.customproperties = this.getCustomProperties();
    let contentNode = this.diagramParent.querySelector("[data-type='diagramContentNode']");
    if (contentNode && window.getComputedStyle(contentNode).display != "none" && properties.contenttype != "sequence") properties.diagramcontent = true;
    return properties;
};

// get custom props from diagram parent
SvgMultiSlideDiagram.prototype.getCustomProperties = function () {
    let customproperties = {};
    customproperties.style = this.diagramParent.dataset.multislideStyle || "";
    customproperties.textstyle = this.diagramParent.dataset.multislideTextstyle || "";
    if (customproperties.innercontentdata == null) {
        let value = this.diagramParent.dataset.multislideInnercontentvalue || "";
        let id = this.diagramParent.dataset.multislideInnercontentid || "";
        customproperties.innercontentdata = { content: { type: customproperties.innercontenttype, value: value, id: id } };
    }
    return customproperties;
};

//Load Svg object from assets using assetloader
SvgMultiSlideDiagram.prototype.addSvgShape = function (parent, data) {
    let multiSlideSvg = this.getSvgPathData(this.diagramData.nodes.length);
    if (multiSlideSvg) {
        let data = { type: "icon", value: this.appStaticURL + multiSlideSvg.path, id: multiSlideSvg.id };
        DiagramAssetLoader.oneTimeDownload(data, true, this.diagramParent)
            .then(() => {
                this.multiSlideSvg = this.diagramParent.querySelector("[id='" + multiSlideSvg.id + "']");
                this.multiSlideSvgId = multiSlideSvg.id;
                this.diagramParent.setAttribute("svgID", multiSlideSvg.id);

                // let arrImageDOM = this.multiSlideSvg.querySelectorAll("image");
                // for (let i = 0; i < arrImageDOM.length; i++) {
                //     let imageDOM = arrImageDOM[i];
                //     let strAssetPrefixURL = this.appStaticURL;
                //     // let strPath ="../assets/icons/" + imageDOM.getAttribute("xlink:href");
                //     let strPath = "genericassets/shapes/" + imageDOM.getAttribute("xlink:href");
                //     imageDOM.setAttribute("xlink:href", strAssetPrefixURL + strPath);
                // }

                this.recreateElementData();
                this.addNodeComplete();
                this.isRenderComplete = true;
                this.diagramRenderComplete();
                // let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
                // if (lastDiv) this.updatePropsCallBack(lastDiv.id);
            })
            .catch((rej) => {
                console.log(rej);
                this.isRenderComplete = true;
                this.diagramRenderComplete();
            });
    }
};

// Create svg element with group node
SvgMultiSlideDiagram.prototype.createSVG = function (svgId, groupData) {
    let svgData = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svgData.id = svgId + "-main";
    svgData.style.width = this.slideWidth + "px";
    svgData.style.height = this.slideHeight + "px";
    svgData.setAttribute("data-commonname", "svg_groups");
    svgData.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    svgData.setAttribute("stroke", "none");
    svgData.appendChild(groupData);
    return svgData;
};

//Get Full svg path id object
SvgMultiSlideDiagram.prototype.getSvgPathData = function (nodeCount) {
    // Getting svg from customprops
    let assetData = this.diagramData.properties.customproperties && this.diagramData.properties.customproperties.innercontentdata ? this.diagramData.properties.customproperties.innercontentdata.content : null;
    if (assetData) {
        let assetName = assetData.id;
        let assetUrl = "genericassets/shapes/" + assetName + ".svg";
        // let assetUrl = "../assets/icons/" + assetName + ".svg";
        let objAssetArr = {
            id: assetName,
            path: assetUrl,
            type: "icon",
        };
        return objAssetArr;
    } else return null;
};

//Add Node
SvgMultiSlideDiagram.prototype.addNodeComplete = function (index = 0) {
    this.doAddDeleteNodes(index);
    this.isRenderComplete = true;
    let svgHolderDiv = this.diagramParent.querySelector("[id='svgHolderDiv']");
    if (svgHolderDiv) svgHolderDiv.setAttribute("data-current", this.targetIndex);
};

//Delete Node
SvgMultiSlideDiagram.prototype.deleteNodeComplete = function () {
    this.doAddDeleteNodes();
};

//Add/Delete node operations
SvgMultiSlideDiagram.prototype.doAddDeleteNodes = function (index = 0) {
    this.multiSlideType = this.diagramParent.getAttribute("data-multislidetype");
    let seperators = this.diagramParent.querySelectorAll("[data-id*='separator']");
    for (let l = 0; l < seperators.length; l++) {
        seperators[l].parentElement.removeChild(seperators[l]);
        seperators = this.diagramParent.querySelectorAll("[data-id*='separator']");
        l--;
    }

    try {
        let svgHolderDiv = this.diagramParent.querySelector("[id='svgHolderDiv']");
        svgHolderDiv.style.removeProperty("transform");
        let nodeCount = this.diagramData.nodes.length;
        if (this.multiSlideSvg == null && this.diagramParent && this.diagramParent.hasAttribute("svgID")) {
            this.multiSlideSvg = this.diagramParent.querySelector("[id='" + this.diagramParent.getAttribute("svgID") + "']");
            this.multiSlideSvgId = this.multiSlideSvg.id;
        }
        if (this.multiSlideSvg && svgHolderDiv) {
            // ------------   SVG Creation Start  ------------//
            //Clear all the childs from svg parent
            this.clearChilds(svgHolderDiv);

            let startSvgGroup = this.multiSlideSvg.querySelector("[id='" + this.multiSlideSvgId + "-start']");
            let endSvgGroup = this.multiSlideSvg.querySelector("[id='" + this.multiSlideSvgId + "-end']");
            let startSvg = this.createSVG(this.multiSlideSvgId + "-start", startSvgGroup.cloneNode(true));
            let endSvg = this.createSVG(this.multiSlideSvgId + "-end", endSvgGroup.cloneNode(true));
            let arrMidSvgData = this.getMidSvgData();

            let midIndex = -1;

            var svgCounts = this.checkSvgCount(nodeCount, startSvgGroup, endSvgGroup);
            svgCounts = nodeCount == 2 ? 2 : svgCounts;

            var arrNodes = [];
            let viewBox = this.multiSlideSvg.getAttribute("viewBox");
            for (let kk = 0; kk < svgCounts; kk++) {
                if (kk == 0) {
                    svgHolderDiv.appendChild(startSvg);
                    startSvg.setAttribute("data-y", 0);
                    startSvg.setAttribute("viewBox", viewBox);
                    let maxCount = startSvg.querySelectorAll("[id*='" + this.multiSlideSvgId + "-point']").length;
                    arrNodes.push({ name: startSvg.id, maxcount: maxCount, count: 0 });
                } else if (kk == svgCounts - 1) {
                    svgHolderDiv.appendChild(endSvg);
                    endSvg.setAttribute("data-y", svgHolderDiv.children.length - 1);
                    endSvg.setAttribute("viewBox", viewBox);
                    let maxCount = endSvg.querySelectorAll("[id*='" + this.multiSlideSvgId + "-point']").length;
                    arrNodes.push({ name: endSvg.id, maxcount: maxCount, count: 0 });
                } else if (arrMidSvgData.length > 0) {
                    midIndex = arrMidSvgData[midIndex + 1] ? midIndex + 1 : 0;
                    let midSvgGroup = arrMidSvgData[midIndex].querySelector("[id*='" + this.multiSlideSvgId + "-mid']");
                    let midSvg = this.createSVG(this.multiSlideSvgId + "-mid" + kk, midSvgGroup.cloneNode(true));
                    svgHolderDiv.appendChild(midSvg);
                    midSvg.setAttribute("data-y", svgHolderDiv.children.length - 1);
                    midSvg.setAttribute("viewBox", viewBox);
                    let maxCount = midSvg.querySelectorAll("[id*='" + this.multiSlideSvgId + "-point']").length;
                    arrNodes.push({ name: midSvg.id, maxcount: maxCount, count: 0 });
                }
            }
            // ------------   SVG Creation End  ------------//

            // ------------   Text Holder Count Creation Start  ------------//
            let finalArrayNodes = assignNodes(arrNodes, nodeCount);
            // ------------   Text Holder Count Creation End  ------------//

            // ------------   Text holder positioning Start  ------------//

            let nodeParentIndex = 0;
            for (let ll = 0; ll < finalArrayNodes.length; ll++) {
                let placeholders = svgHolderDiv.querySelector("[id='" + finalArrayNodes[ll].name + "']").querySelectorAll("[id*='" + this.multiSlideSvgId + "-point']");
                let placeholdersCount = finalArrayNodes[ll].count;
                let extraHeight = svgHolderDiv.querySelector("[id='" + finalArrayNodes[ll].name + "']").dataset.y;
                extraHeight = extraHeight == null || extraHeight == undefined ? 0 : parseInt(extraHeight);
                for (let pp = 0; pp < placeholders.length; pp++) {
                    placeholders[pp].style.visibility = "hidden";
                }
                for (let kk = 0; kk < placeholdersCount; kk++) {
                    placeholders[kk].style.visibility = "visible";
                    let textPlaceholderPosition = placeholders[kk].querySelector("[id*='" + this.multiSlideSvgId + "-placeholder']");

                    let nodeParent = this.arrDiagramNode[nodeParentIndex].getNodeParent().parentElement;
                    nodeParentIndex = nodeParentIndex + 1;

                    if (textPlaceholderPosition) {
                        let text0Rect = textPlaceholderPosition.getElementsByTagName("rect")[0];
                        text0Rect.style.background = "greenyellow";
                        nodeParent.style.width = text0Rect.getAttribute("width") + "px";
                        nodeParent.style.height = text0Rect.getAttribute("height") + "px";
                        nodeParent.style.maxHeight = text0Rect.getAttribute("height") + "px";
                        nodeParent.style.left = parseFloat(text0Rect.getAttribute("x")) + extraHeight * (this.multiSlideType == "vertical" ? 0 : this.slideWidth) + "px";
                        nodeParent.style.top = parseFloat(text0Rect.getAttribute("y")) + extraHeight * (this.multiSlideType == "vertical" ? this.slideHeight : 0) + "px";

                        let bBox = DiagramUtils.getAbsCoordOfElement(text0Rect, this.diagramParent, this.slideScale);
                        nodeParent.style.width = bBox.width + "px";
                        nodeParent.style.height = bBox.height + "px";
                        nodeParent.style.maxHeight = bBox.height + "px";
                        nodeParent.style.left = bBox.x + "px";
                        nodeParent.style.top = bBox.y + "px";

                        nodeParent.setAttribute("data-originaly", parseFloat(nodeParent.style.top));
                        nodeParent.setAttribute("data-originalx", parseFloat(nodeParent.style.left));

                        this.diagramParent.style.setProperty("--diagramcontentwidth", text0Rect.getAttribute("height") + "px");

                        var [, , c1, c2, , t1, t2] = text0Rect.id.split("-");
                        let isContent = this.diagramData.properties.diagramcontent || this.diagramData.properties.sequencetext;
                        var contentAlign = isContent ? c1 + c2 : "";
                        var textAlign = !isContent ? t1 + t2 : "";

                        nodeParent.setAttribute("data-contentalign", contentAlign);
                        nodeParent.setAttribute("data-seccontentalign", textAlign);
                    }
                }
            }
            // ------------   Text holder positioning End  ------------//
        }

        let distanceValue = parseFloat(document.getElementById("nodeparent" + index + "").dataset[this.multiSlideType == "vertical" ? "originaly" : "originalx"]);
        let roundedVal = distanceValue / (this.multiSlideType == "vertical" ? this.slideHeight : this.slideWidth);
        roundedVal = isNaN(roundedVal) ? 0 : parseInt(roundedVal);
        this.targetIndex = roundedVal;
        this.doNodeAnimation(false);
        this.updateTextNodes();
    } catch (error) {
        console.log("Diagram - error = " + error);
    }
};

function assignNodes(arrNodes, userNodes) {
    while (userNodes > 0) {
        for (let i = 0; i < arrNodes.length; i++) {
            if (arrNodes[i].count < arrNodes[i].maxcount && userNodes > 0) {
                arrNodes[i].count = arrNodes[i].count + 1;
                userNodes = userNodes - 1;
            }
        }
    }
    return arrNodes;
}

// Check and get total svg count
SvgMultiSlideDiagram.prototype.checkSvgCount = function (nodeCount, startSvgGroup, endSvgGroup) {
    let startCount = startSvgGroup.querySelectorAll("[id*='" + this.multiSlideSvgId + "-point']").length;
    let endCount = endSvgGroup.querySelectorAll("[id*='" + this.multiSlideSvgId + "-point']").length;
    let arrTotalSvgMid = this.getMidSvgData();
    let midCount = arrTotalSvgMid?.[0]?.querySelectorAll("[id*='" + this.multiSlideSvgId + "-point']").length || 0;

    var totalCount = startCount + endCount + midCount;
    var totalSvgCount = 1 + 1 + 1;
    var midIndex = 0;

    while (nodeCount > totalCount) {
        totalSvgCount = totalSvgCount + 1;
        midIndex = arrTotalSvgMid[midIndex + 1] ? midIndex + 1 : 0;
        let newMidCount = arrTotalSvgMid[midIndex].querySelectorAll("[id*='" + this.multiSlideSvgId + "-point']").length;
        totalCount = totalCount + newMidCount;
    }
    return totalSvgCount;
};

// Getting multi slide mid svg's count
SvgMultiSlideDiagram.prototype.getMidSvgCount = function () {
    return this.multiSlideSvg.querySelectorAll("[id*='" + this.multiSlideSvgId + "-mid']").length;
};

// Getting multi slide mid svg's array
SvgMultiSlideDiagram.prototype.getMidSvgData = function () {
    let arrSvg = [];
    let midSvgCount = this.getMidSvgCount();
    for (let jj = 0; jj < midSvgCount; jj++) {
        let midSvgGroup = this.multiSlideSvg.querySelector("[id='" + this.multiSlideSvgId + "-mid" + (jj + 1) + "']");
        midSvgGroup = midSvgGroup == null && jj == 0 ? this.multiSlideSvg.querySelector("[id='" + this.multiSlideSvgId + "-mid']") : midSvgGroup;
        let midSvg = this.createSVG(this.multiSlideSvgId + "-mid" + (jj + 1), midSvgGroup.cloneNode(true));
        arrSvg.push(midSvg);
    }
    return arrSvg;
};

// Clear all the childs from one div
SvgMultiSlideDiagram.prototype.clearChilds = function (parentDiv) {
    try {
        if (parentDiv && parentDiv.firstChild)
            while (parentDiv.firstChild) {
                parentDiv.firstChild.remove();
            }
    } catch (error) {
        console.log("Error on clearing childs on css parent");
    }
};

// While adding title we have to navigate to first slide
SvgMultiSlideDiagram.prototype.titleAddCallBack = function () {
    this.targetIndex = 0;
    this.doNodeAnimation(false);
};

SvgMultiSlideDiagram.prototype.hideAnimation = function (completeCallBack) {
    let isHideAnimation = this.moodData.animationData.isHideAnimation;
    if (isHideAnimation != false) {
        this.diagramParent.style.opacity = 1;
        this.diagramParent.style.transition = "opacity " + this.durationFactor * 1 + "s";
        this.diagramParent.style.opacity = 0;
        setTimeout(() => {
            completeCallBack ? completeCallBack() : "";
        }, 500);
    }
};

//Before intro setting up animation.
SvgMultiSlideDiagram.prototype.initPresent = function (currentSlideData) {
    this.diagramParent = currentSlideData.querySelector("[id='diagramparent']");
    if (this.diagramParent) this.diagramParent.style.opacity = 0;

    return { isTitleAnimation: false, isGraphicAnimation: false };
};

//Intro Animation
SvgMultiSlideDiagram.prototype.setupAnimation = function (animationType, callback) {
    this.animationCompleteCallback = callback;
    let svgHolderDiv = this.diagramParent.querySelector("[id='svgHolderDiv']");
    this.animationType = animationType;
    if (animationType == "none") {
        this.diagramParent.style.opacity = 1;
        if (svgHolderDiv) svgHolderDiv.style.opacity = 1;
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return;
    }

    this.durationFactor = animationType == "none" ? 0 : 1;
    let moodAnimationDisable = this.diagramParent.parentElement.dataset.moodanimation;
    this.durationFactor = moodAnimationDisable && moodAnimationDisable == "none" ? 0 : this.durationFactor;

    let textHolders = this.diagramParent.querySelectorAll("[id*='nodeparent']");
    this.diagramParent.style.opacity = 1;
    this.diagramParent.style.transition = "all " + this.durationFactor * 1 + "s";

    if (svgHolderDiv) svgHolderDiv.style.transition = "all " + this.durationFactor * 1 + "s";
    if (svgHolderDiv) svgHolderDiv.style.opacity = 1;

    setTimeout(() => {
        let delay = 0.8;
        for (let i = 0; i < textHolders.length; i++) {
            let yVal = parseFloat(textHolders[i].parentElement.style.top);
            if (yVal <= this.slideHeight) {
                setTimeout(() => {
                    textHolders[i].parentElement.style.transition = "all " + this.durationFactor * 1 + "s";
                    if (textHolders[i].parentElement) textHolders[i].parentElement.style.opacity = 1;
                }, delay * this.durationFactor * 1000);
                delay = delay + 0.2;
            }
        }
    }, 0);
    if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
};

SvgMultiSlideDiagram.prototype.playNext = function () {
    this.targetIndex = this.targetIndex + 1;
    this.animationIndex = this.targetIndex;
    let hasMore = this.doNodeAnimation(this.animationType != "none");
    if (hasMore == true && this.animationType != "none") this.animationCompleteCallback?.fn?.(this.animationCompleteCallback.params);
    return hasMore;
};

SvgMultiSlideDiagram.prototype.playPrevious = function () {
    this.targetIndex = this.targetIndex - 1;
    this.animationIndex = this.targetIndex;
    let hasMore = this.doNodeAnimation(this.animationType != "none");
    if (hasMore == true && this.animationType != "none") this.animationCompleteCallback?.fn?.(this.animationCompleteCallback.params);
    return hasMore;
};

//Doing next and previous Animation
SvgMultiSlideDiagram.prototype.doNodeAnimation = function (doTransition = true) {
    if (this.appmode && this.appmode == "DESIGN") {
        let currentSlide = this.diagramParent.parentElement.parentElement.parentElement;
        DiagramAnimateUtil.updateTitleVisiblity(currentSlide, this.targetIndex > 0);
    }
    this.multiSlideType = this.diagramParent.getAttribute("data-multislidetype");
    let svgGroups = this.diagramParent.querySelectorAll("[data-commonname='svg_groups']");
    if (this.targetIndex >= svgGroups.length || this.targetIndex < 0) return false;
    if (this.diagramParent) {
        let svgHolderDiv = this.diagramParent.querySelector("[id='svgHolderDiv']");
        if (svgHolderDiv) {
            if (doTransition == true) {
                svgHolderDiv.style.transition = "all " + this.durationFactor * 1 + "s";
                svgHolderDiv.style.opacity = 1;
            } else svgHolderDiv.style.transition = "all 0s";
            svgHolderDiv.style.transform = this.multiSlideType == "vertical" ? "translateY(-" + this.targetIndex * this.slideHeight + "px)" : "translateX(-" + this.targetIndex * this.slideWidth + "px)";
            svgHolderDiv.setAttribute("data-current", this.targetIndex);
        }
        let textHolders = this.diagramParent.querySelectorAll("[id*='nodeparent']");
        for (let i = 0; i < textHolders.length; i++) {
            if (doTransition == true) {
                textHolders[i].parentElement.style.transition = "all " + this.durationFactor * 1 + "s";
                textHolders[i].parentElement.style.opacity = 1;
            } else textHolders[i].parentElement.style.transition = "all 0s";
            if (this.multiSlideType == "vertical") {
                let originalTop = textHolders[i].parentElement.getAttribute("data-originaly");
                textHolders[i].parentElement.style.top = parseFloat(originalTop) - this.targetIndex * this.slideHeight + "px";
            } else {
                let originalLeft = textHolders[i].parentElement.getAttribute("data-originalx");
                textHolders[i].parentElement.style.left = parseFloat(originalLeft) - this.targetIndex * this.slideWidth + "px";
            }
        }
    }
    return this.targetIndex >= svgGroups.length || this.targetIndex < 0 ? false : true;
};

SvgMultiSlideDiagram.prototype.navigation = function (navigation) {
    if (navigation.direction == "next") {
        return this.playNext();
    } else {
        return this.playPrevious();
    }
};

SvgMultiSlideDiagram.prototype.setDiagramSpecficOption = function (obj) {
    obj.isDisableLayoutOption = "true";
    obj.dpcontent.slidecomponent = { bgImage: false, takeAwayText: false };
};

SvgMultiSlideDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearVerticalDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable.push("content");
        mainProperties.floateroptionsdisable.push("arrange");
        mainProperties.floateroptionsdisable.push("sequencetext");
        mainProperties.floateroptionsdisable.push("imagesize");
        mainProperties.floateroptionsdisable.push("logosize");
        mainProperties.floateroptionsdisable.push("swap");
    } else mainProperties.floateroptionsdisable = ["content", "arrange", "sequencetext", "imagesize", "logosize", "swap"];
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

SvgMultiSlideDiagram.prototype.slideDimensionChange = function () {
    this.doAddDeleteNodes();
};

function SvgTimelineDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SvgMultiSlideDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
}

SvgTimelineDiagram.prototype = Object.create(SvgMultiSlideDiagram.prototype);
SvgTimelineDiagram.prototype.constructor = SvgTimelineDiagram;

SvgTimelineDiagram.prototype.initDiagramCreation = function () {
    this.diagramParent.dataset.contenttype = null;
    if (!this.diagramParent.dataset.contenttype) {
        this.diagramParent.setAttribute("data-contenttype", "icon");
        this.setHolderType(this.diagramData.properties.contenttype, "contentNode");
    }
    SvgMultiSlideDiagram.prototype.initDiagramCreation.call(this);
};

//Add/Delete node operations
SvgTimelineDiagram.prototype.doAddDeleteNodes = function (index = 0) {
    this.multiSlideType = this.diagramParent.getAttribute("data-multislidetype");
    let seperators = this.diagramParent.querySelectorAll("[data-id*='separator']");
    for (let l = 0; l < seperators.length; l++) {
        seperators[l].parentElement.removeChild(seperators[l]);
        seperators = this.diagramParent.querySelectorAll("[data-id*='separator']");
        l--;
    }

    try {
        let svgHolderDiv = this.diagramParent.querySelector("[id='svgHolderDiv']");
        svgHolderDiv.style.removeProperty("transform");
        let nodeCount = this.diagramData.nodes.length;
        if (this.multiSlideSvg == null && this.diagramParent && this.diagramParent.hasAttribute("svgID")) {
            this.multiSlideSvg = this.diagramParent.querySelector("[id='" + this.diagramParent.getAttribute("svgID") + "']");
            this.multiSlideSvgId = this.multiSlideSvg.id;
        }
        if (this.multiSlideSvg && svgHolderDiv) {
            // ------------   SVG Creation Start  ------------//
            //Clear all the childs from svg parent
            this.clearChilds(svgHolderDiv);

            let startSvgGroup = this.multiSlideSvg.querySelector("[id='" + this.multiSlideSvgId + "-start']");
            let endSvgGroup = this.multiSlideSvg.querySelector("[id='" + this.multiSlideSvgId + "-end']");
            let startSvg = this.createSVG(this.multiSlideSvgId + "-start", startSvgGroup.cloneNode(true));
            let endSvg = this.createSVG(this.multiSlideSvgId + "-end", endSvgGroup.cloneNode(true));
            let arrMidSvgData = this.getMidSvgData();

            let midIndex = -1;

            var svgCounts = this.checkSvgCount(nodeCount, startSvgGroup, endSvgGroup);
            svgCounts = nodeCount == 2 ? 2 : svgCounts;

            var arrNodes = [];

            for (let kk = 0; kk < svgCounts; kk++) {
                if (kk == 0) {
                    svgHolderDiv.appendChild(startSvg);
                    startSvg.setAttribute("data-y", 0);

                    let maxCount = startSvg.querySelectorAll("[id*='" + this.multiSlideSvgId + "-point']").length;
                    arrNodes.push({ name: startSvg.id, maxcount: maxCount, count: 0 });
                } else if (kk == svgCounts - 1) {
                    svgHolderDiv.appendChild(endSvg);
                    endSvg.setAttribute("data-y", svgHolderDiv.children.length - 1);

                    let maxCount = endSvg.querySelectorAll("[id*='" + this.multiSlideSvgId + "-point']").length;
                    arrNodes.push({ name: endSvg.id, maxcount: maxCount, count: 0 });
                } else {
                    midIndex = arrMidSvgData[midIndex + 1] ? midIndex + 1 : 0;
                    let midSvgGroup = arrMidSvgData[midIndex].querySelector("[id*='" + this.multiSlideSvgId + "-mid']");
                    let midSvg = this.createSVG(this.multiSlideSvgId + "-mid" + kk, midSvgGroup.cloneNode(true));
                    svgHolderDiv.appendChild(midSvg);
                    midSvg.setAttribute("data-y", svgHolderDiv.children.length - 1);

                    let maxCount = midSvg.querySelectorAll("[id*='" + this.multiSlideSvgId + "-point']").length;
                    arrNodes.push({ name: midSvg.id, maxcount: maxCount, count: 0 });
                }
            }
            // ------------   SVG Creation End  ------------//

            // ------------   Text Holder Count Creation Start  ------------//
            let finalArrayNodes = assignNodes(arrNodes, nodeCount);
            // ------------   Text Holder Count Creation End  ------------//

            // ------------   Text holder positioning Start  ------------//

            this.updateFrame();
            // ------------   Text holder positioning End  ------------//
        }

        let distanceValue = parseFloat(document.getElementById("nodeparent" + index + "").dataset[this.multiSlideType == "vertical" ? "originaly" : "originalx"]);
        let roundedVal = distanceValue / (this.multiSlideType == "vertical" ? this.slideHeight : this.slideWidth);
        roundedVal = isNaN(roundedVal) ? 0 : parseInt(roundedVal);
        this.targetIndex = roundedVal;
        this.doNodeAnimation(false);
    } catch (error) {
        console.log("Diagram - error = " + error);
    }
};

SvgTimelineDiagram.prototype.checkSvgCount = function (nodeCount, startSvgGroup, endSvgGroup) {
    let startCount = startSvgGroup.querySelectorAll("[id*='" + this.multiSlideSvgId + "-point']").length;
    let endCount = endSvgGroup.querySelectorAll("[id*='" + this.multiSlideSvgId + "-point']").length;
    let arrTotalSvgMid = this.getMidSvgData();
    let midCount = arrTotalSvgMid[0].querySelectorAll("[id*='" + this.multiSlideSvgId + "-point']").length;

    var totalCount = startCount + endCount + midCount;
    var totalSvgCount = Math.ceil(nodeCount / 2);
    var midIndex = 0;

    // while (nodeCount > totalCount) {
    //     totalSvgCount = totalSvgCount + 1;
    //     midIndex = arrTotalSvgMid[midIndex + 1] ? midIndex + 1 : 0;
    //     let newMidCount = arrTotalSvgMid[midIndex].querySelectorAll("[id*='" + this.multiSlideSvgId + "-point']").length;
    //     totalCount = totalCount + newMidCount;
    // }
    return totalSvgCount;
};

SvgTimelineDiagram.prototype.updateFrame = function () {
    let svgHolder = this.diagramParent.querySelector("[id='svgHolderDiv']");
    let groups = svgHolder.querySelectorAll("[data-commonname]");
    let index = 0;
    groups.forEach((group, j) => {
        let arrNodeGroup = Array.from(group.querySelectorAll("[id*='-point']")).reverse();
        arrNodeGroup.forEach((point, i) => {
            try {
                let node = this.arrDiagramNode[index];

                let svgtext = point.querySelector("[id*='-content']");
                let nodeRect = svgtext.parentElement.getBBox();
                let textRect = svgtext.getBBox();

                let name = node.parentNode.querySelector("[data-id='contenticonparent']") ? "icon" : "image";
                let svgcontent = point.querySelector("[data-name='" + name + "']"); 

                let shape = point.querySelector("[data-name='shape']");
                if (shape) {
                    let arrPath = shape.querySelectorAll("[data-name='path1']");
                    arrPath.forEach((path, i) => {
                        path.setAttribute("fill", "var(--accent"+(index+1)+"-color)");
                    });
                }
                let connectingShape = Array.from(point.parentElement.children).find((child) => child.getAttribute("data-name") == "shape");
                if (connectingShape) {
                    let arrPath = connectingShape.querySelectorAll("[data-name='path1']");
                    arrPath.forEach((path, i) => {
                        let fill = path.getAttribute("fill") || "";
                        if (!fill.includes("--accent")) path.setAttribute("fill", "var(--accent"+(index)+"-color)");
                    });
                }

                if (node && svgcontent) {
                    let contentRect = svgcontent.getBBox();

                    let nodeParent = node.getNodeParent().parentElement;
                    nodeParent.style.top = nodeRect.y + (j * (this.multiSlideType == "vertical" ? this.slideHeight : 0)) + "px";
                    nodeParent.style.left = nodeRect.x + "px";
                    nodeParent.style.width = nodeRect.width + "px";
                    nodeParent.style.height = nodeRect.height + "px";
                    nodeParent.setAttribute("data-originaly", parseFloat(nodeParent.style.top));
                    nodeParent.setAttribute("data-originalx", parseFloat(nodeParent.style.left));

                    let content = nodeParent.querySelector("[data-id='diagramContentNode']");
                    content.style.top = contentRect.y - nodeRect.y + "px";
                    content.style.left = contentRect.x - nodeRect.x + "px";
                    content.style.width = contentRect.width + "px";
                    content.style.height = contentRect.height + "px";
                    content.style.minWidth = contentRect.width + "px";
                    content.style.minHeight = contentRect.height + "px";
                    content.style.position = "absolute";

                    let text = nodeParent.querySelector("[name='secContentNode']");
                    text.style.top = textRect.y - nodeRect.y + "px";
                    text.style.left = textRect.x - nodeRect.x + "px";
                    text.style.width = textRect.width + "px";
                    text.style.height = textRect.height + "px";
                    text.style.position = "absolute";

                    nodeParent.classList.remove("clsRightAlignment");
                    nodeParent.classList.remove("clsLeftAlignment");
                    svgtext.id.includes("right") ? nodeParent.classList.add("clsRightAlignment") : nodeParent.classList.add("clsLeftAlignment");

                    if (svgcontent.firstElementChild) {
                        let clippath = svgcontent.firstElementChild.getAttribute("clip-path") || "";
                        let imgPatent = nodeParent.querySelector("[data-id='contentimageparent']");
                        if (imgPatent) {
                            imgPatent.style.setProperty("clip-path", clippath);
                            imgPatent.style.setProperty("-webkit-clip-path", clippath);
                        }
                    }

                    let arrImageDOM = point.querySelectorAll("image");
                    for (let i = 0; i < arrImageDOM.length; i++) {
                        let imageDOM = arrImageDOM[i];
                        let strAssetPrefixURL = this.appStaticURL + "genericassets/shapes/";
                        let strPath = imageDOM.getAttribute("xlink:href").replace(strAssetPrefixURL, "");
                        imageDOM.setAttribute("xlink:href", strAssetPrefixURL + strPath);
                    }

                    node.updateNodeAttributes(index);
                    this.removDefaultNodeAnimation(node);
                }
                index++;
            } catch (error) {
                console.log("Erron in updateFrame - " + error);
            }
        });
    });
};

SvgTimelineDiagram.prototype.removDefaultNodeAnimation = function (node) {
    node.getNodeParent().parentElement.removeAttribute("data-animation");
    node.getNodeParent().parentElement.classList.remove("moodanimation");
    let arrObj = Array.from(node.getNodeParent().parentElement.querySelectorAll("[data-animation]"));
    arrObj.map((item) => {
        item.removeAttribute("data-animation");
        item.classList.remove("moodanimation");
    });
};

/**
 * Author:    Krishna prabhu M
 * Created:   25 Jan 21
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function VennDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.mainParent = diagramParent;
    this.dragItemIndex = -1;
    this.dragOffset = [0, 0];
    this.dragging = false;
    this.sizeDrag = false;
    this.isRenderComplete = true;

    this.mouseUpHandler = this.mouseUpHandler.bind(this);
    this.mouseDownHandler = this.mouseDownHandler.bind(this);
    this.mouseMoveHandler = this.mouseMoveHandler.bind(this);
    this.diagramParent.parentElement.setAttribute("data-allowdefaultanimation", "true");
}

VennDiagram.prototype = Object.create(SimpleLinearDiagram.prototype);
VennDiagram.prototype.constructor = VennDiagram;

VennDiagram.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    let centerNodeStyle = this.nodeProps.centerNodeStyle || "";
    pattenDiv.className = "clsVennDiagramHolder " + centerNodeStyle;
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    this.diagramParent.appendChild(pattenDiv);

    let gap = DiagramNodeUtils.getGapForMathSymbols(this.nodeProps, nodeCount, this.diagramParent);
    pattenDiv.style.setProperty("--awardContentHeight", 200 - nodeCount > this.adjustValue.length ? this.adjustValue[6] + "px" : this.adjustValue[nodeCount] + "px");

    pattenDiv.style.setProperty("--nodeWidth", "calc(1/" + nodeCount + "*100% - (1 - 1/" + nodeCount + ")*" + gap + "px)");
    pattenDiv.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    pattenDiv.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    pattenDiv.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    pattenDiv.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    pattenDiv.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");

    this.updateImageRatio();
    this.createNodeInstances(nodeCount, pattenDiv);

    this.setNodeAnimation();
    if (!this.diagramData.nodes[0].position || (this.diagramData.nodes[0].position && !this.diagramData.nodes[0].position.width)) {
        // this.setDefaultLayout();
        this.arrangeNodes({ value: nodeCount.toString() });
    }
    this.setCenterPosition();
    let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    if (lastDiv) this.updatePropsCallBack(lastDiv.id);
};

VennDiagram.prototype.updateEvents = function () {
    SimpleLinearDiagram.prototype.updateEvents.call(this);
    this.eventManagerXY.addEvent(this.mainParent, "mousedown", this.mouseDownHandler);
    this.eventManagerXY.addEvent(this.mainParent, "mouseup", this.mouseUpHandler);
    this.eventManagerXY.addEvent(this.mainParent, "mousemove", this.mouseMoveHandler);
    this.eventManagerXY.addEvent(window, "mouseup", this.mouseUpHandler);
};

VennDiagram.prototype.addNode = function (nodeJSON, index, isFromUndo = false) {
    this.isRenderComplete = false;
    SimpleLinearDiagram.prototype.addNode.call(this, nodeJSON, index, isFromUndo);
    let newNode = this.arrDiagramNode[this.arrDiagramNode.length - 1];
    newNode.parentNode.parentElement.style.left = this.diagramParent.clientWidth - 300 + "px";
    newNode.parentNode.parentElement.style.top = "0px";
    newNode.parentNode.parentElement.setAttribute("data-x", this.diagramParent.clientWidth - 300);
    newNode.parentNode.parentElement.setAttribute("data-y", 0);
    this.isRenderComplete = true;
    this.diagramRenderComplete();

    setTimeout(() => {
        this.setNodeAnimation(true);
        this.setCenterPosition();
    }, 0);
    if (newNode) {
        // let node = this.arrDiagramNode.reduce(function (prev, current) {
        //     let pEnd = prev.parentNode.parentElement.offsetLeft + prev.parentNode.parentElement.clientWidth;
        //     let cEnd = current.parentNode.parentElement.offsetLeft + current.parentNode.parentElement.clientWidth;
        //     return pEnd > cEnd ? prev : current;
        // });
        // let previousNode = node;
        // if (previousNode) {
        //     let previousParent = previousNode.parentNode.parentElement;
        //     let newParent = newNode.parentNode.parentElement;
        //     newParent.style.left = previousParent.offsetLeft + previousParent.clientWidth - 40 + "px";
        //     newParent.style.top = previousParent.style.top;
        // }
        // setTimeout(() => {
        //     this.setNodeAnimation(true);
        //     this.setCenterPosition();
        // }, 0);
    }
};

VennDiagram.prototype.diagramRenderComplete = function () {
    if (this.isRenderComplete) {
        SimpleLinearDiagram.prototype.diagramRenderComplete.call(this);
    }
};

VennDiagram.prototype.setpositionForNewNodes = function (oldCount, diagramData) {
    if (oldCount > diagramData.nodes.length) return;
    let newNodes = diagramData.nodes.filter((node, i) => i >= oldCount);
    let refNode = diagramData.nodes[oldCount - 1];
    newNodes.forEach((node, i) => {
        let x = this.diagramParent.clientWidth - parseFloat(refNode.position.width) + 50 * i;
        let y = 50 * i;
        node.position = { ...node.position, x: x, left: x, y: y, top: y };
    });
};

VennDiagram.prototype.deleteNode = function (targetIndex) {
    SimpleLinearDiagram.prototype.deleteNode.call(this, targetIndex);
    this.setCenterPosition();
};

VennDiagram.prototype.isNonLinearAsset = function () {
    return true;
};

VennDiagram.prototype.setCenterPosition = function () {
    let minX = 2000;
    let maxX = 0;
    let minY = 2000;
    let maxY = 0;

    this.arrDiagramNode.map(function (node) {
        let nodeParent = node.parentNode.parentElement;
        minX = Math.min(minX, nodeParent.offsetLeft);
        maxX = Math.max(maxX, nodeParent.offsetLeft + nodeParent.clientWidth);
        minY = Math.min(minY, nodeParent.offsetTop);
        maxY = Math.max(maxY, nodeParent.offsetTop + nodeParent.clientHeight);
    });

    let width = maxX - minX;
    let height = maxY - minY;
    let left = this.diagramParent.clientWidth / 2 - width / 2;
    let top = this.diagramParent.clientHeight / 2 - height / 2;
    let offsetLeft = left - minX;
    let offsetTop = top - minY;

    this.arrDiagramNode.map(function (node) {
        let nodeParent = node.parentNode.parentElement;
        nodeParent.style.left = nodeParent.offsetLeft + offsetLeft + "px";
        nodeParent.style.top = nodeParent.offsetTop + offsetTop + "px";
        nodeParent.setAttribute("data-x", nodeParent.offsetLeft + offsetLeft);
        nodeParent.setAttribute("data-y", nodeParent.offsetTop + offsetTop);
    });

    // this.updatePropsCallBack(this.arrDiagramNode[this.arrDiagramNode.length-1].parentNode.id);
};

VennDiagram.prototype.setNodeAnimation = function (isAnimatable = false) {
    this.arrDiagramNode.map(function (node) {
        node.parentNode.parentElement.style.transition = isAnimatable ? "all 0.3s" : "unset";
    });
};

VennDiagram.prototype.checkForNodeInterSection = function () {
    this.arrDiagramNode.map(
        function (node, i) {
            let nodeParent = node.parentNode.parentElement;
            this.arrDiagramNode.map(
                function (cnode, j) {
                    let cNodeParent = cnode.parentNode.parentElement;
                    if (i != j) this.checkInterSection(node, cnode);
                }.bind(this)
            );
        }.bind(this)
    );
};

VennDiagram.prototype.checkInterSection = function (node1, node2) {
    let np1 = node1.parentNode.parentElement;
    let np2 = node2.parentNode.parentElement;

    let c1 = { x: np1.offsetLeft + np1.clientWidth / 2, y: np1.offsetTop + np1.clientHeight / 2 };
    let c2 = { x: np2.offsetLeft + np2.clientWidth / 2, y: np2.offsetTop + np2.clientHeight / 2 };
    let r1 = np1.clientHeight / 2;
    let r2 = np2.clientHeight / 2;

    let res = this.intersection(c1.x, c1.y, r1, c2.x, c2.y, r2);
};

VennDiagram.prototype.intersection = function (x0, y0, r0, x1, y1, r1) {
    var a, dx, dy, d, h, rx, ry;
    var x2, y2;

    dx = x1 - x0;
    dy = y1 - y0;

    d = Math.sqrt(dy * dy + dx * dx);

    if (d > r0 + r1) {
        return false;
    }
    if (d < Math.abs(r0 - r1)) {
        return false;
    }

    a = (r0 * r0 - r1 * r1 + d * d) / (2.0 * d);

    x2 = x0 + (dx * a) / d;
    y2 = y0 + (dy * a) / d;

    h = Math.sqrt(r0 * r0 - a * a);

    rx = -dy * (h / d);
    ry = dx * (h / d);

    var xi = x2 + rx;
    if (isNaN(xi)) return false;
    var xi_prime = x2 - rx;
    if (isNaN(xi_prime)) return false;
    var yi = y2 + ry;
    if (isNaN(yi)) return false;
    var yi_prime = y2 - ry;
    if (isNaN(yi_prime)) return false;

    return [xi, xi_prime, yi, yi_prime];
};

VennDiagram.prototype.sizechange = function (operation) {
    var tlIndex = operation.targetid.replace(/\D/g, "");
    let targetNode = this.diagramParent.querySelector("#nodeMainParent" + tlIndex);
    if (targetNode) {
        let actualSize = (operation.value * this.diagramParent.clientHeight) / 100;
        let diffWidth = actualSize - targetNode.clientWidth;
        let size = actualSize + "px";
        targetNode.style.left = targetNode.offsetLeft - diffWidth / 2 + "px";
        targetNode.style.width = size;
        targetNode.style.height = size;
        targetNode.setAttribute("data-width", actualSize);
        targetNode.setAttribute("data-height", actualSize);
    }
    if (!this.sizeDrag) {
        this.appDispatcher?.dispatch({ type: "HIDE_SELECTOR" });
    }
    this.sizeDrag = true;
    if (!operation.dragging) {
        this.sizeDrag = false;
        setTimeout(() => {
            this.setCenterPosition();
        }, 300);
    }
};

VennDiagram.prototype.mouseDownHandler = function (event) {
    try {
        if (event.target.dataset.index) {
            this.setNodeAnimation();
            this.dragItemIndex = parseInt(event.target.dataset.index);
            let curentItem = this.arrDiagramNode[this.dragItemIndex].parentNode.parentElement;
            this.dragOffset = [curentItem.offsetLeft - event.clientX / this.slideScale, curentItem.offsetTop - event.clientY / this.slideScale];
            this.eventManagerXY.removeEvent(this.mainParent, "mousemove", this.mouseMoveHandler);
            this.eventManagerXY.addEvent(this.mainParent, "mousemove", this.mouseMoveHandler);
        }
    } catch (error) {
        console.log(error);
    }
};

VennDiagram.prototype.mouseMoveHandler = function (event) {
    if (this.dragItemIndex >= 0) {
        if (!this.dragging) this.appDispatcher?.dispatch({ type: "REMOVE_FLOATER" });
        this.dragging = true;
        let curentItem = this.arrDiagramNode[this.dragItemIndex].parentNode.parentElement;
        curentItem.style.left = event.clientX / this.slideScale + this.dragOffset[0] + "px";
        curentItem.style.top = event.clientY / this.slideScale + this.dragOffset[1] + "px";
        curentItem.style.width = curentItem.offsetWidth;
    }
    event.preventDefault();
};

VennDiagram.prototype.mouseUpHandler = function (event) {
    if (this.dragItemIndex < 0) return;
    try {
        let curentItem = this.arrDiagramNode[this.dragItemIndex].parentNode.parentElement;
        let left = parseInt(curentItem.style.left.replace("px", ""));
        let top = parseInt(curentItem.style.top.replace("px", ""));
        curentItem.setAttribute("data-x", left);
        curentItem.setAttribute("data-y", top);
        this.diagramData.nodes[this.dragItemIndex].x = left;
        this.diagramData.nodes[this.dragItemIndex].y = top;

        this.checkForNodeInterSection();
        this.setNodeAnimation(true);
        this.setCenterPosition();
        this.dragItemIndex = -1;
    } catch (error) {
        this.dragItemIndex = -1;
        console.log(error);
    }

    if (this.dragging) this.updatePropsCallBack(this.arrDiagramNode[this.arrDiagramNode.length - 1].parentNode.id);
    this.dragging = false;
};

VennDiagram.prototype.slideDimensionChange = function () {
    this.setNodeAnimation(true);
    this.setCenterPosition();
};

VennDiagram.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    let index = elTarget.dataset.index;
    let selectedNode = this.diagramParent.querySelector("#nodeMainParent" + index);
    if (selectedNode) {
        dict.sizechange = {
            visible: true,
            minvalue: (150 / this.diagramParent.clientHeight) * 100,
            maxvalue: 100,
            currentvalue: (selectedNode.clientHeight / this.diagramParent.clientHeight) * 100,
            floaterproperty: "sizechange",
        };
    }
    // dict["fontsize"] = null;
};

VennDiagram.prototype.setDefaultLayout = function () {
    this.setNodeAnimation();
    if (this.diagramData.nodes.length == 2 || this.diagramData.nodes.length == 3) {
        this.arrDiagramNode.map(
            function (node, i) {
                let nodeParent = node.parentNode.parentElement;
                if (i == 1) {
                    let previousParent = this.arrDiagramNode[i - 1].parentNode.parentElement;
                    nodeParent.style.top = previousParent.style.top;
                    nodeParent.style.left = previousParent.offsetLeft + previousParent.offsetWidth - 40 + "px";
                } else if (i == 2) {
                    let previousParent = this.arrDiagramNode[0].parentNode.parentElement;
                    nodeParent.style.top = previousParent.offsetTop - previousParent.clientHeight + 80 + "px";
                    nodeParent.style.left = previousParent.offsetLeft + previousParent.offsetWidth - nodeParent.offsetWidth / 2 - 10 + "px";
                }
            }.bind(this)
        );
    } else {
        this.arrDiagramNode.map(
            function (node, i) {
                let nodeParent = node.parentNode.parentElement;
                if (i == 1) {
                    let previousParent = this.arrDiagramNode[i - 1].parentNode.parentElement;
                    nodeParent.style.top = previousParent.style.top;
                    nodeParent.style.left = previousParent.offsetLeft + nodeParent.clientWidth - 40 + "px";
                } else if (i == 2) {
                    let previousParent = this.arrDiagramNode[i - 1].parentNode.parentElement;
                    nodeParent.style.top = previousParent.offsetTop + nodeParent.clientHeight - 40 + "px";
                    nodeParent.style.left = previousParent.offsetLeft + "px";
                } else if (i == 3) {
                    let previousParent = this.arrDiagramNode[0].parentNode.parentElement;
                    nodeParent.style.top = previousParent.offsetTop + nodeParent.clientHeight - 40 + "px";
                    nodeParent.style.left = previousParent.offsetLeft + "px";
                }
            }.bind(this)
        );
    }
};

VennDiagram.prototype.setDiagramSpecficOption = function (obj) {
    let graphicarrange = {
        visible: true,
        selectedindex: -1,
        dpsource: [
            { data: "2node", label: "2node", icon: "2_circle" },
            { data: "3node", label: "3node", icon: "3_circle" },
            { data: "4node", label: "4node", icon: "4_circle" },
            // { data: "5node", label: "5node" },
            // { data: "6node", label: "6node" }
        ],
    };
    obj.dpcontent.floatdiagramsettings.venndiagramarrange = graphicarrange;
    obj.dpcontent.floatdiagramsettings.graphicarrange = null;
};

VennDiagram.prototype.arrangeNodes = function (operation) {
    let arrangCount = parseInt(operation.value.replace(/\D/g, ""));

    let centerX = this.diagramParent.clientWidth / 2;
    let centerY = this.diagramParent.clientHeight / 2;

    let refSize = Math.min(this.diagramParent.clientWidth, this.diagramParent.clientHeight);
    let nodeSize = refSize * 0.5;

    if (arrangCount < this.arrDiagramNode.length) {
        do {
            SimpleLinearDiagram.prototype.deleteNode.call(this, this.arrDiagramNode.length - 1);
        } while (this.arrDiagramNode.length > arrangCount);
    } else if (arrangCount > this.arrDiagramNode.length) {
        do {
            SimpleLinearDiagram.prototype.addNode.call(this, this.arrDiagramNode[0].getJSONData(), this.arrDiagramNode.length + 1);
        } while (this.arrDiagramNode.length < arrangCount);
    }

    let radius = this.arrDiagramNode.length == 2 ? nodeSize / 2.5 : nodeSize / 2;
    let angleDiff = 360 / this.arrDiagramNode.length;
    this.arrDiagramNode.forEach(
        function (node, i, arr) {
            let nodeParent = node.parentNode.parentElement;
            nodeParent.style.width = nodeSize + "px";
            nodeParent.style.height = nodeParent.style.width;
            let angle = angleDiff * i;
            angle = arr.length == 2 ? angle - 90 : angle;
            angle = arr.length == 4 ? angle - 45 : angle;
            let nodeCenter = this.polarToCartesian(centerX, centerY, radius, angle);
            nodeParent.style.top = nodeCenter.y - nodeParent.clientHeight / 2 + "px";
            nodeParent.style.left = nodeCenter.x - nodeParent.clientWidth / 2 + "px";
            nodeParent.setAttribute("data-x", nodeCenter.x - nodeParent.clientWidth / 2);
            nodeParent.setAttribute("data-y", nodeCenter.y - nodeParent.clientHeight / 2);
        }.bind(this)
    );
};

VennDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable = [...new Set(mainProperties.floateroptionsdisable.concat(this.floateroptionsdisable()))];
    } else mainProperties.floateroptionsdisable = this.floateroptionsdisable();
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

VennDiagram.prototype.floateroptionsdisable = function () {
    return [
        "textposition",
        "arrowboth",
        "arrowcurved",
        "arrowbackandforth",
        "iconsize",
        "sequencetext",
        "graphicmicrochart",
        "graphiclogo",
        "graphictext",
        "graphicnumber",
        "notequal",
        "equal",
        "divide",
        "multiply",
        "minus",
        "plus",
        "animateoneatatime",
        "arrange",
        "greyscale",
        "crossout",
        "iconsize",
        "logosize",
        "numbersize",
        "secondarytext",
        "content",
        "contentoptions",
        "primarytext",
        "swap",
    ];
};

VennDiagram.prototype.polarToCartesian = function (centerX, centerY, radius, angleInDegrees) {
    var angleInRadians = ((angleInDegrees - 90) * Math.PI) / 180.0;

    return {
        x: centerX + radius * Math.cos(angleInRadians),
        y: centerY + radius * Math.sin(angleInRadians),
    };
};

//Animation related function

VennDiagram.prototype.setupAnimation = function (animationType, callback) {
    this.animationCompleteCallback = callback;
    this.animationType = animationType;
    this.animationIndex = 0;
    this.animateItemCount = 0;
    this.allAtOnceIndex = 0;
    let moodAnimationDisable = this.diagramParent.parentElement.dataset.moodanimation;
    this.animationFactor = moodAnimationDisable && moodAnimationDisable == "none" ? 0 : 1;

    if (this.animationType == "none") {
        this.diagramParent.style.opacity = 1;
        if (this.animationCompleteCallback) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
        return;
    }

    this.arrDiagramNode.map(
        function (node) {
            let nodeParent = node.parentNode.parentElement;
            this.hideNode(nodeParent, false);
        }.bind(this)
    );

    this.diagramParent.style.transition = `all ${0.3 * this.animationFactor}`;
    this.diagramParent.style.opacity = 1;

    if (animationType == "all") this.playAllAtOnce();
    else this.animationCompleteCallback?.fn?.(this.animationCompleteCallback.params);
};

VennDiagram.prototype.playNext = function (isAllAtOnce = false) {
    if (this.arrDiagramNode.length - 1 < this.animationIndex) {
        return false;
    }
    let node = this.arrDiagramNode[this.animationIndex];
    let currentNode = node.parentNode.parentElement;
    this.showNode(currentNode);
    if (node.getNodeParent().dataset.highlight && node.getNodeParent().dataset.highlight == "true") {
        this.isShowHighlight = true;
        this.highlightIndex = parseInt(node.getNodeParent().dataset.index);
    }
    this.animationIndex++;
    if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    return true;
};

VennDiagram.prototype.playPrevious = function (isAllAtOnce = false) {
    if (this.animationIndex <= 0) {
        return false;
    }
    this.animationIndex--;
    let node = this.arrDiagramNode[this.animationIndex];
    let currentNode = node.parentNode.parentElement;
    this.hideNode(currentNode);
    let highlightNode = this.arrDiagramNode[this.animationIndex - 1];
    if (highlightNode && highlightNode.getNodeParent().dataset.highlight && highlightNode.getNodeParent().dataset.highlight == "true") {
        this.isShowHighlight = true;
        this.highlightIndex = parseInt(highlightNode.getNodeParent().dataset.index);
    } else {
        this.isShowHighlight = false;
        this.highlightIndex = -1;
    }
    if (this.animationCompleteCallback && !isAllAtOnce) this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    return true;
};

VennDiagram.prototype.playAllAtOnce = function () {
    this.arrDiagramNode.forEach(
        function (node, i) {
            let nodeparent = node.parentNode.parentElement;
            setTimeout(() => {
                this.showNode(nodeparent);
            }, 0.1 * i * 1000 * this.animationFactor);
        }.bind(this)
    );
    this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    this.allAtOnceIndex += 1;
    return true;
};

VennDiagram.prototype.playAllAtOnceReverse = function () {
    this.animationCompleteCallback.fn(this.animationCompleteCallback.params);
    this.allAtOnceIndex -= 1;
    return true;
};

VennDiagram.prototype.showNode = function (nodeParent, isAnimate = true) {
    let durationFactor = isAnimate ? 1 : 0;
    let delayFactor = isAnimate ? 1 : 0;

    nodeParent.style.transition = `all ${0.3 * durationFactor * this.animationFactor}s`;
    nodeParent.style.transform = "scale(1)";
    nodeParent.style.opacity = 1;
};

VennDiagram.prototype.hideNode = function (nodeParent, isAnimate = true) {
    let durationFactor = isAnimate ? 1 : 0;
    let delayFactor = isAnimate ? 1 : 0;

    nodeParent.style.transition = `all ${0.3 * durationFactor * this.animationFactor}s`;
    nodeParent.style.transform = "scale(0.6)";
    nodeParent.style.opacity = 0;
};

/**
 * Author:    Krishnan M.
 * Created:   14 Aug 2020
 *
 **/

"use strict";

function PyramidDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    SimpleLinearVerticalDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "clsLinerDiagram pyramidDiagramSingleSide";
    this.isRenderComplete = false;
    this.shapeIndex = 0;
    this.funnelGap = 50;
    this.secContentOn = true;
    this.baseWidth = 200;
}

PyramidDiagram.prototype = Object.create(SimpleLinearVerticalDiagram.prototype);
PyramidDiagram.prototype.constructor = PyramidDiagram;

PyramidDiagram.prototype.initDiagramCreation = function () {
    this.diagramParent.innerHTML = "";
    this.arrDiagramNode = [];
    this.setMoodClassNames();
    this.diagramParent.setAttribute("parent-id", DiagramNodeUtils.uuidv4());
    this.createPatternBackGround();
};

PyramidDiagram.prototype.defaultFoucsOut = function (event) {
    let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    nodeHolder.style.setProperty("--pathanimationtime", "0s");
    LinearDiagram.prototype.defaultFoucsOut.call(this, event);
};

PyramidDiagram.prototype.createElements = function () {
    const nodeCount = this.diagramData.nodes.length;
    let pattenDiv = document.createElement("div");
    pattenDiv.className = "clsNodesHolderSvg clsShapeBgEnable";
    pattenDiv.setAttribute("id", DiagramNodeUtils.uuidv4());
    pattenDiv.setAttribute("name", "nodesHolder");
    pattenDiv.setAttribute("data-node", nodeCount + "nodes");
    pattenDiv.style.setProperty("--pathanimationtime", "0s");
    this.diagramParent.appendChild(pattenDiv);

    this.createNodeInstances(nodeCount, pattenDiv);

    let width = Math.max(this.funnelGap, this.baseWidth);
    this.createDeviceHolder(pattenDiv, width);
    this.isRenderComplete = true;
    if (this.diagramParent.dataset.issecontent) this.showHideSecContent({ value: this.diagramParent.dataset.issecontent == "true" });
    pattenDiv.style.setProperty("--pathanimationtime", "0.3s");
    this.diagramRenderComplete();
    // let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
    // if (lastDiv) this.updatePropsCallBack(lastDiv.id);
};

PyramidDiagram.prototype.recreateElementData = function (contentData = { id: "", value: "", contenttype: "image" }) {
    SimpleLinearVerticalDiagram.prototype.recreateElementData.call(this);
    let pattenDiv = this.diagramParent.querySelector("[name='nodesHolder']");
    let centerItem = new window[this.nodeProps.nodeclassName](
        pattenDiv,
        {},
        {
            content: this.centerholderdata && this.centerholderdata.value != "" ? this.centerholderdata : this.centerHolderNode && this.centerHolderNode.objData.content.value != "" ? this.centerHolderNode.objData.content : contentData,
        },
        // { content: this.centerholderdata ? this.centerholderdata  : contentData },
        this.eventManagerXY,
        0,
        "",
        this.objStyleData,
        this.appStaticURL,
        this.nodeProps,
        this.diagramParent
    );
    let outerDiv = pattenDiv.querySelector("[data-id='outerDiv']");
    if (outerDiv) outerDiv.setAttribute("data-type", "device");
    centerItem.moodData = this.moodData;
    centerItem.manifestUpdater = this.manifestUpdater;
    centerItem.appStaticURL = this.appStaticURL;
    this.centerHolderNode = centerItem;
};

PyramidDiagram.prototype.setPropertiesFromConstants = function (mainObj, constArrProperties, extraAttrib = "") {
    SimpleLinearVerticalDiagram.prototype.setPropertiesFromConstants.call(this, mainObj, constArrProperties, extraAttrib);
    let properties = this.diagramData.properties;
    this.diagramParent.setAttribute("data-shapeindex", properties.shapeindex ? properties.shapeindex : "0");
    this.diagramParent.setAttribute("data-stepped", !properties.hasOwnProperty("stepped") || (properties.hasOwnProperty("stepped") && properties["stepped"] == false) ? false : true);
    this.diagramParent.setAttribute("data-inverted", !properties.hasOwnProperty("inverted") || (properties.hasOwnProperty("inverted") && properties["inverted"] == false) ? false : true);
    this.diagramParent.setAttribute("data-isfillbg", !properties.hasOwnProperty("isfillbg") || properties["isfillbg"] == true ? true : false);
    this.diagramParent.setAttribute("data-issecontent", !properties.hasOwnProperty("issecontent") || properties["issecontent"] == true ? true : false);
    this.diagramParent.setAttribute("data-topwidth", properties.topwidth ? properties.topwidth : "100");
    this.diagramParent.setAttribute("data-basewidth", properties.basewidth ? properties.basewidth : "500");
    this.diagramParent.setAttribute("data-shapeindex", properties.shapeindex ? properties.shapeindex : "0");
    this.shapeIndex = this.diagramParent.dataset.shapeindex;
    this.funnelGap = this.diagramParent.dataset.topwidth;
    this.baseWidth = this.diagramParent.dataset.basewidth;
};

PyramidDiagram.prototype.hasProperty = function (properties, property) {
    return !properties.hasOwnProperty(property) || (properties.hasOwnProperty(property) && properties[property] == "true") ? true : false;
};

PyramidDiagram.prototype.getProperties = function (defaultproperties = {}) {
    defaultproperties = SimpleLinearVerticalDiagram.prototype.getProperties.call(this, defaultproperties);
    defaultproperties.shapeindex = parseInt(this.diagramParent.dataset.shapeindex) || 0;
    this.shapeIndex = defaultproperties.shapeindex;
    defaultproperties.stepped = this.diagramParent.dataset.hasOwnProperty("stepped") && this.diagramParent.dataset.stepped == "true" ? true : false;
    defaultproperties.inverted = this.diagramParent.dataset.hasOwnProperty("inverted") && this.diagramParent.dataset.inverted == "true" ? true : false;
    defaultproperties.isfillbg = (!this.diagramParent.dataset.hasOwnProperty("isfillbg") && this.globalMoodData?.basicgraphics?.diagramstyle == "solid") || this.diagramParent.dataset.isfillbg == "true" ? true : false;
    defaultproperties.issecontent = !this.diagramParent.dataset.hasOwnProperty("issecontent") || this.diagramParent.dataset.issecontent == "true" ? true : false;
    this.isFillBg = defaultproperties.isfillbg;
    this.secContentOn = defaultproperties.issecontent;
    this.funnelGap = this.diagramParent.dataset.topwidth || 100;
    this.baseWidth = this.diagramParent.dataset.basewidth || 500;

    let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    if (nodeHolder) {
        nodeHolder.classList.remove("clsShapeBgEnable");
        this.isFillBg ? nodeHolder.classList.add("clsShapeBgEnable") : nodeHolder.classList.remove("clsShapeBgEnable");
    }

    return defaultproperties;
};

PyramidDiagram.prototype.showHideContent = function (operation) {
    this.diagramParent.parentElement.style.setProperty("--contentdisplay", !operation.value ? "none" : "flex");
    this.diagramParent.setAttribute("data-content", operation.value);
    this.diagramData.properties.diagramcontent = operation.value;

    // this.diagramParent.parentElement.style.setProperty("--numberdisplay", operation.value ? "none" : "flex");
    // this.diagramData.properties.sequencetext = !operation.value;

    this.updateProperties(this.diagramData.properties);
    this.updateFrame();
    this.slideDimensionChange();
};

PyramidDiagram.prototype.showHideNumber = function (operation) {
    this.diagramParent.parentElement.style.setProperty("--numberdisplay", !operation.value ? "none" : "flex");
    this.diagramData.properties.sequencetext = operation.value;

    // this.diagramParent.parentElement.style.setProperty("--contentdisplay", operation.value ? "none" : "flex");
    // this.diagramParent.setAttribute("data-content", !operation.value);
    // this.diagramData.properties.diagramcontent = !operation.value;
    this.updateProperties(this.diagramData.properties);
    this.updateFrame();
    this.slideDimensionChange();
};

PyramidDiagram.prototype.slideDimensionChange = function () {
    let parentDiv = this.diagramParent.querySelector("[name='nodesHolder']");

    if (parentDiv) {
        parentDiv.style.setProperty("--pathanimationtime", "0s");
        let width = Math.max(this.funnelGap, this.baseWidth);
        this.createDeviceHolder(parentDiv, width);
        this.offDescription(false);
        setTimeout(() => {
            parentDiv.style.setProperty("--pathanimationtime", "0.6s");
        }, 1000);
    }
};

PyramidDiagram.prototype.createDeviceHolder = function (parentDiv, width) {
    let oldHolder = this.diagramParent.querySelector("[data-id='deviceHolderParent']");
    if (oldHolder && oldHolder.parentElement) oldHolder.parentElement.removeChild(oldHolder);

    let centerHolderParent = document.createElement("div");
    centerHolderParent.setAttribute("data-id", "deviceHolderParent");
    centerHolderParent.className = "pyramidholder";
    parentDiv.appendChild(centerHolderParent);
    centerHolderParent.style.width = width + "px";
    centerHolderParent.style.height = this.diagramParent.clientHeight * 0.9 + "px";

    this.updatePyramid(centerHolderParent);
};

PyramidDiagram.prototype.updatePyramid = function (centerHolderParent) {
    let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    nodeHolder.classList.remove("clsShapeBgEnable");
    this.isFillBg ? nodeHolder.classList.add("clsShapeBgEnable") : nodeHolder.classList.remove("clsShapeBgEnable");

    this.drawPyramid(centerHolderParent);

    if (this.diagramData.properties.stepped && this.diagramData.properties.inverted) {
        this.shapeIndex = 3;
    } else if (!this.diagramData.properties.stepped && !this.diagramData.properties.inverted) {
        this.shapeIndex = 0;
    } else if (this.diagramData.properties.stepped && !this.diagramData.properties.inverted) {
        this.shapeIndex = 2;
    } else if (!this.diagramData.properties.stepped && this.diagramData.properties.inverted) {
        this.shapeIndex = 1;
    }
    this.diagramParent.dataset.shapeindex = this.shapeIndex;
    this.changeShapeTo(this.shapeIndex);
    setTimeout(() => {
        this.updateFrame();
    }, 100);
};

PyramidDiagram.prototype.resizeNode = function (svgNode, alignment, position, parentDiv, deviceHolder) {
    if (position == "horizontal") {
        parentDiv.style.setProperty("width", "100%");
        let maxHeight = this.diagramParent.clientHeight * 0.5;
        let height = svgNode.clientHeight < maxHeight ? svgNode.clientHeight : maxHeight;
        let divideFactor = alignment == "alternate" ? 2 : 1;
        parentDiv.style.setProperty("--nodesMaxHeight", "calc(" + (this.diagramParent.clientHeight - height) + "px / " + divideFactor + " - 28px)");
        svgNode.style.height = height + "px";
    } else if (position == "vertical") {
        parentDiv.style.setProperty("height", "100%");
        let maxWidth = this.diagramParent.clientWidth * 0.5;
        let width = svgNode.clientWidth > maxWidth ? maxWidth : svgNode.clientWidth;
        // let divideFactor = alignment == "alternate" ? 2 : 1;
        let divideFactor = 2;
        parentDiv.style.setProperty("--nodesMaxWidth", "calc(" + (this.diagramParent.clientWidth - width) + "px / " + divideFactor + " - 28px)");
        deviceHolder.parentElement.style.width = width + "px";
    }
};

PyramidDiagram.prototype.diagramRenderComplete = function () {
    if (this.completeCallBack && this.completeCallBack.func && this.isRenderComplete) {
        LinearDiagram.prototype.diagramRenderComplete.call(this);
    }
    this.diagramParent.style.opacity = 1;
};

PyramidDiagram.prototype.addNode = function (nodeData, index, isFromUndo = false) {
    SimpleLinearVerticalDiagram.prototype.addNode.call(this, nodeData, index, isFromUndo);
    this.slideDimensionChange();
};

PyramidDiagram.prototype.deleteNode = function (targetIndex) {
    SimpleLinearVerticalDiagram.prototype.deleteNode.call(this, targetIndex);
    this.slideDimensionChange();
};

PyramidDiagram.prototype.resetHolderWidth = function () {
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    nodesHolder.style.setProperty("--iconNodePadding", this.nodeProps.iconPadding + "%");
    nodesHolder.style.setProperty("--contentNodePadding", this.nodeProps.contentNodePadding);
    nodesHolder.style.setProperty("--secondaryContentNodePadding", this.nodeProps.secondaryContentNodePadding);
    nodesHolder.style.setProperty("--iconNumberNodeWidth", this.nodeProps.iconNumberNodeWidth ? this.nodeProps.iconNumberNodeWidth : "55px");
    nodesHolder.style.setProperty("--iconNumberNodeHeight", this.nodeProps.iconNumberNodeHeight ? this.nodeProps.iconNumberNodeHeight : "55px");
};

PyramidDiagram.prototype.setHighlightPosition = function (node, parent) {
    let nodeParent = node.parentElement;
    let element = nodeParent.querySelector("[data-id='diagramContentNode']");
    if (!element || element.clientWidth == 0) element = node;
    return { element: element, alignment: "vertical" };
};

//Draw Pyramid related function

PyramidDiagram.prototype.drawPyramid = function (holderDiv) {
    let oldSvg = this.diagramParent.querySelector("[id='pyramidsvg']");
    if (oldSvg && oldSvg.parentElement) oldSvg.parentElement.removeChild(oldSvg);

    let svg = DiagramNodeUtils.createSVGElement("svg");
    DiagramNodeUtils.assignSVGNodeAttributes(svg, { class: "pyramidsvg", id: "pyramidsvg", width: holderDiv.clientWidth, height: holderDiv.clientHeight });
    holderDiv.appendChild(svg);

    let arrShapePoints = this.getTriangleShapePoints(svg, false, this.funnelGap);

    arrShapePoints.map(
        function (arrPoints, i) {
            let strD = this.getPathString(arrPoints);
            let centpoint = this.getCenter(arrPoints);
            let path = DiagramNodeUtils.createSVGElement("path");
            DiagramNodeUtils.assignSVGNodeAttributes(path, { d: strD, class: "shapepath clsMultiColorParent moodanimation", "data-animation": "itemshape", cx: centpoint.x, cy: centpoint.y });
            DiagramUtils.setCustomItemColor(path, this.arrTintArray, i, i + 1);
            svg.appendChild(path);

            let node = this.arrDiagramNode[i];
            let nodeParent = node.getNodeParent().parentElement;

            let pathRect = path.getBBox();
            let point1 = { x: pathRect.x + pathRect.width + 30, y: pathRect.y + pathRect.height };
            let point2 = { x: holderDiv.parentElement.clientWidth, y: pathRect.y + pathRect.height };
            let line = this.createLine(point1, point2);
            line.setAttribute("style", "stroke:rgba(var(--secondary-color-rgb), 1);");
            line.setAttribute("data-id", "underline" + i);
            line.setAttribute("data-animation", "itemshape");
            line.setAttribute("class", "moodanimation");

            let group = DiagramNodeUtils.createSVGElement("g");
            group.setAttribute("class", "seperator");
            group.appendChild(line);
            svg.appendChild(group);

            this.svgRectToDiv(nodeParent, path);
        }.bind(this)
    );

    this.updateFrame();
    this.diagramParent.style.setProperty("--iconnodewidth", "70%");
    this.diagramParent.style.setProperty("--iconnodeheight", "70%");
};

PyramidDiagram.prototype.updatePyramidFram = function () {
    let pyramid = this.diagramParent.querySelector("[id='pyramidsvg']");
    pyramid.parentElement.style.left = !this.secContentOn ? this.diagramParent.clientWidth / 2 - pyramid.parentElement.clientWidth / 2 + "px" : "0px";

    let arrShapePoints = []; //this.getTriangleShapePoints(pyramid, false, this.funnelGap);
    if (this.shapeIndex == 1) {
        arrShapePoints = this.getTriangleShapePoints(pyramid, true, this.funnelGap);
    } else if (this.shapeIndex == 2) {
        arrShapePoints = this.getSquareShapePoints(pyramid, false, this.funnelGap);
    } else if (this.shapeIndex == 3) {
        arrShapePoints = this.getSquareShapePoints(pyramid, true, this.funnelGap);
    } else {
        arrShapePoints = this.getTriangleShapePoints(pyramid, false, this.funnelGap);
    }
    let arrPath = pyramid.querySelectorAll("path");

    arrShapePoints.map(
        function (arrPoints, i) {
            let strD = this.getPathString(arrPoints);
            let centpoint = this.getCenter(arrPoints);
            let path = arrPath[i];
            if (path) DiagramNodeUtils.assignSVGNodeAttributes(path, { d: strD, cx: centpoint.x, cy: centpoint.y });
            else return;

            let node = this.arrDiagramNode[i];
            let nodeParent = node.getNodeParent().parentElement;

            let pathRect = path.getBBox();
            let point1 = { x: pathRect.x + pathRect.width + 30, y: pathRect.y + pathRect.height };
            let point2 = { x: this.diagramParent.clientWidth, y: pathRect.y + pathRect.height };
            let line = pyramid.querySelector("[data-id='underline" + i + "']");
            if (line) DiagramNodeUtils.assignSVGNodeAttributes(line, { x1: point1.x, y1: point1.y, x2: point2.x, y2: point2.y });

            this.svgRectToDiv(nodeParent, path);
        }.bind(this)
    );

    // this.changeShapeTo(this.shapeIndex);
};

PyramidDiagram.prototype.createLine = function (startPoint, endPoint) {
    let line = DiagramNodeUtils.createSVGElement("line");
    DiagramNodeUtils.assignSVGNodeAttributes(line, { x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y, stroke: "none", "stroke-width": 2, "data-id": "line" });
    return line;
};

PyramidDiagram.prototype.updateUnderLineFrame = function (svg) {
    let arrPath = Array.from(svg.querySelectorAll("path"));
    let nodesHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    arrPath.map(
        function (path, i) {
            let pathRect = path.getBBox();
            // if (this.diagramParent.dataset.stepped == "true" && this.diagramParent.dataset.inverted == "false") {
            //     pathRect.y = pathRect.y - pathRect.height;
            // }
            let offset = 30;
            let startPoint = { x: pathRect.x + pathRect.width + offset, y: pathRect.y + pathRect.height };
            let endPoint = { x: nodesHolder.clientWidth, y: pathRect.y + pathRect.height };
            let line = svg.querySelector("[data-id='underline" + i + "']");
            if (line) {
                DiagramNodeUtils.assignSVGNodeAttributes(line, { x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y });
            }
        }.bind(this)
    );
};

PyramidDiagram.prototype.getPolygenString = function (arrPoints) {
    let pointString = "";
    arrPoints.map((point, i) => {
        pointString = pointString + (i == 0 ? "" : " ") + point.x + "," + point.y;
    });
    return pointString;
};

PyramidDiagram.prototype.getPathString = function (arrPoints) {
    let pointString = "";
    arrPoints.map((point, i) => {
        let pathComponent = i == 0 ? "M" : "L";
        pointString = pointString + (i == 0 ? "" + pathComponent : " " + pathComponent) + point.x + "," + point.y;
    });
    return pointString + " Z";
};

PyramidDiagram.prototype.checkIntersection = function (x1, y1, x2, y2, x3, y3, x4, y4) {
    var ua,
        ub,
        denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    if (denom == 0) {
        return null;
    }
    ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
    ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
    return {
        x: x1 + ua * (x2 - x1),
        y: y1 + ua * (y2 - y1),
        seg1: ua >= 0 && ua <= 1,
        seg2: ub >= 0 && ub <= 1,
    };
};

PyramidDiagram.prototype.getTriangleShapePoints = function (svg, isInverse = false, funnelGap = 0) {
    let arrLines = Array.from(svg.querySelectorAll("[data-id='line']"));
    arrLines.map((line) => svg.removeChild(line));

    let svgRect = { x: 0, y: 0, width: svg.parentElement.offsetWidth, height: svg.parentElement.offsetHeight };
    let l1 = this.createLine({ x: svgRect.width / 2 - funnelGap / 2, y: 0 }, { x: 0, y: svgRect.height });
    let l2 = this.createLine({ x: svgRect.width / 2 + funnelGap / 2, y: 0 }, { x: svgRect.width, y: svgRect.height });

    if (isInverse) {
        l1 = this.createLine({ x: 0, y: 0 }, { x: svgRect.width / 2 - funnelGap / 2, y: svgRect.height });
        l2 = this.createLine({ x: svgRect.width, y: 0 }, { x: svgRect.width / 2 + funnelGap / 2, y: svgRect.height });
    }

    svg.appendChild(l1);
    svg.appendChild(l2);

    let count = this.arrDiagramNode.length;
    let nodeHeight = svgRect.height / count;
    let arrNodeShapePoints = [];
    for (var i = 1; i <= count; i++) {
        let arrPathPoints = [];
        let line = this.createLine({ x: 0, y: nodeHeight * i }, { x: svgRect.width, y: nodeHeight * i });
        svg.appendChild(line);

        if (i == 1) {
            arrPathPoints.push({ x: isInverse ? 0 : svgRect.width / 2 - funnelGap / 2, y: 0 });
            arrPathPoints.push({ x: isInverse ? svgRect.width : svgRect.width / 2 + funnelGap / 2, y: 0 });
            const point3 = this.checkIntersection(l2.x1.baseVal.value, l2.y1.baseVal.value, l2.x2.baseVal.value, l2.y2.baseVal.value, line.x1.baseVal.value, line.y1.baseVal.value, line.x2.baseVal.value, line.y2.baseVal.value);
            arrPathPoints.push({ x: point3.x, y: point3.y });
            const point4 = this.checkIntersection(l1.x1.baseVal.value, l1.y1.baseVal.value, l1.x2.baseVal.value, l1.y2.baseVal.value, line.x1.baseVal.value, line.y1.baseVal.value, line.x2.baseVal.value, line.y2.baseVal.value);
            arrPathPoints.push({ x: point4.x, y: point4.y });
        } else if (i > 1) {
            let arrPoints = arrNodeShapePoints[i - 2];
            arrPathPoints.push(JSON.parse(JSON.stringify(arrPoints[3])));
            arrPathPoints.push(JSON.parse(JSON.stringify(arrPoints[2])));
            const point3 = this.checkIntersection(l2.x1.baseVal.value, l2.y1.baseVal.value, l2.x2.baseVal.value, l2.y2.baseVal.value, line.x1.baseVal.value, line.y1.baseVal.value, line.x2.baseVal.value, line.y2.baseVal.value);
            arrPathPoints.push({ x: point3.x, y: point3.y });
            const point4 = this.checkIntersection(l1.x1.baseVal.value, l1.y1.baseVal.value, l1.x2.baseVal.value, l1.y2.baseVal.value, line.x1.baseVal.value, line.y1.baseVal.value, line.x2.baseVal.value, line.y2.baseVal.value);
            arrPathPoints.push({ x: point4.x, y: point4.y });
        }

        arrNodeShapePoints.push(arrPathPoints);
    }

    return arrNodeShapePoints;
};

PyramidDiagram.prototype.getSquareShapePoints = function (svg, isInverse = false, funnelGap = 0) {
    let arrLines = Array.from(svg.querySelectorAll("[data-id='line']"));
    arrLines.map((line) => svg.removeChild(line));

    let svgRect = { x: 0, y: 0, width: svg.parentElement.offsetWidth, height: svg.parentElement.offsetHeight };
    let l1 = this.createLine({ x: svgRect.width / 2 - funnelGap / 2, y: 0 }, { x: 0, y: svgRect.height });
    let l2 = this.createLine({ x: svgRect.width / 2 + funnelGap / 2, y: 0 }, { x: svgRect.width, y: svgRect.height });

    if (isInverse) {
        l1 = this.createLine({ x: 0, y: 0 }, { x: svgRect.width / 2 - funnelGap / 2, y: svgRect.height });
        l2 = this.createLine({ x: svgRect.width, y: 0 }, { x: svgRect.width / 2 + funnelGap / 2, y: svgRect.height });
    }
    // let svgRect = svg.getBoundingClientRect(); //svg.getBBox();
    // let l1 = this.createLine({ x: svgRect.width / 2, y: 0 }, { x: 0, y: svgRect.height });
    // let l2 = this.createLine({ x: svgRect.width / 2, y: 0 }, { x: svgRect.width, y: svgRect.height });

    // if (isInverse) {
    //     l1 = this.createLine({ x: 0, y: 0 }, { x: svgRect.width / 2, y: svgRect.height });
    //     l2 = this.createLine({ x: svgRect.width, y: 0 }, { x: svgRect.width / 2, y: svgRect.height });
    // }

    svg.appendChild(l1);
    svg.appendChild(l2);

    let count = this.arrDiagramNode.length;
    let nodeHeight = svgRect.height / count;
    let arrNodeShapePoints = [];
    let startValue = isInverse ? 0 : 1;
    for (var i = startValue; i <= count; i++) {
        let arrPathPoints = [];
        let line = this.createLine({ x: 0, y: nodeHeight * i }, { x: svgRect.width, y: nodeHeight * i });
        svg.appendChild(line);

        if (!isInverse) {
            const point4 = this.checkIntersection(l1.x1.baseVal.value, l1.y1.baseVal.value, l1.x2.baseVal.value, l1.y2.baseVal.value, line.x1.baseVal.value, line.y1.baseVal.value, line.x2.baseVal.value, line.y2.baseVal.value);
            arrPathPoints.push({ x: point4.x, y: point4.y - nodeHeight });

            const point3 = this.checkIntersection(l2.x1.baseVal.value, l2.y1.baseVal.value, l2.x2.baseVal.value, l2.y2.baseVal.value, line.x1.baseVal.value, line.y1.baseVal.value, line.x2.baseVal.value, line.y2.baseVal.value);
            arrPathPoints.push({ x: point3.x, y: point3.y - nodeHeight });

            arrPathPoints.push({ x: point3.x, y: point3.y });
            arrPathPoints.push({ x: point4.x, y: point4.y });
        } else {
            const point4 = this.checkIntersection(l1.x1.baseVal.value, l1.y1.baseVal.value, l1.x2.baseVal.value, l1.y2.baseVal.value, line.x1.baseVal.value, line.y1.baseVal.value, line.x2.baseVal.value, line.y2.baseVal.value);
            arrPathPoints.push({ x: point4.x, y: point4.y });

            const point3 = this.checkIntersection(l2.x1.baseVal.value, l2.y1.baseVal.value, l2.x2.baseVal.value, l2.y2.baseVal.value, line.x1.baseVal.value, line.y1.baseVal.value, line.x2.baseVal.value, line.y2.baseVal.value);
            arrPathPoints.push({ x: point3.x, y: point3.y });

            arrPathPoints.push({ x: point3.x, y: point3.y + nodeHeight });
            arrPathPoints.push({ x: point4.x, y: point4.y + nodeHeight });
        }

        arrNodeShapePoints.push(arrPathPoints);
    }

    return arrNodeShapePoints;
};

PyramidDiagram.prototype.changePathPoints = function (svg, i, d) {
    let arrSvgPath = Array.from(svg.querySelectorAll("path"));
    let path = arrSvgPath[i];
    if (path) path.setAttribute("d", d);
};

PyramidDiagram.prototype.changeShapeTo = function (index = 0) {
    let svg = this.diagramParent.querySelector("[id='pyramidsvg']");
    let arrShapePoints = this.getTriangleShapePoints(svg, false, this.funnelGap);
    if (index == 1) {
        arrShapePoints = this.getTriangleShapePoints(svg, true, this.funnelGap);
    } else if (index == 2) {
        arrShapePoints = this.getSquareShapePoints(svg, false, this.funnelGap);
    } else if (index == 3) {
        arrShapePoints = this.getSquareShapePoints(svg, true, this.funnelGap);
    }

    if (!svg) return;
    arrShapePoints.map(
        function (arrPoints, i) {
            let strD = this.getPathString(arrPoints);
            this.changePathPoints(svg, i, strD);
        }.bind(this)
    );
};

PyramidDiagram.prototype.svgRectToDiv = function (div, svg) {
    let pyHolder = this.diagramParent.querySelector("[data-id='deviceHolderParent']");
    let svgRect = svg.getBBox();
    svgRect.x = !this.secContentOn ? svgRect.x + this.diagramParent.clientWidth / 2 - pyHolder.clientWidth / 2 : svgRect.x;

    let pathPoints = this.getPointFromPath(svg);
    if (pathPoints.length > 4) pathPoints.pop();
    let centerPoint = { x: parseFloat(svg.getAttribute("cx")), y: parseFloat(svg.getAttribute("cy")) };
    let contentCenter = { x: centerPoint.x, y: centerPoint.y + pyHolder.offsetTop - div.offsetTop };

    let contentNode = div.querySelector("[data-id='diagramContentNode']");
    contentNode.style.width = svgRect.width + "px";
    contentNode.style.minWidth = svgRect.width + "px";
    contentNode.style.height = svgRect.height + "px";

    let arrContent = Array.from(contentNode.querySelectorAll("[name='iconHolder'],[name='seqTitleHolder'],[name='textTitleHolder']"));

    if (arrContent.length > 0) {
        let iconNode = arrContent[0];
        // iconNode.style.left = contentCenter.x - iconNode.clientWidth/2 + "px";
        iconNode.style.top = contentCenter.y - iconNode.clientHeight / 2 + "px";
    }

    let parentOffset = 50;
    let offsetWidth = this.diagramParent.clientWidth - parentOffset - svgRect.x;
    div.style.left = svgRect.x + "px";
    div.style.width = offsetWidth + "px";
    div.style.height = svgRect.height + "px";
    div.style.maxHeight = div.style.height;

    let secContent = div.querySelector("[name='secContentNode']");
    if (secContent) {
        // secContent.style.maxHeight = div.style.maxHeight;
        // secContent.style.overflow = "hidden";
    }
};

PyramidDiagram.prototype.updateFrame = function () {
    let svg = this.diagramParent.querySelector("[id='pyramidsvg']");
    if (!svg) return;
    let arrPath = Array.from(svg.querySelectorAll("path"));

    arrPath.map(
        function (path, i) {
            let node = this.arrDiagramNode[i];
            if (node) {
                let nodeParent = node.getNodeParent().parentElement;
                this.svgRectToDiv(nodeParent, path);
                this.updateColor(path, i, nodeParent);
            }
        }.bind(this)
    );

    if (svg && this.isFillBg) {
        svg.classList.remove("nooutline");
        svg.classList.add("nooutline");
    } else svg.classList.remove("nooutline");
    this.updateUnderLineFrame(svg);
    this.resetNodeAttributes();
    // this.updateEvents();
};

PyramidDiagram.prototype.setDiagramSpecficOption = function (obj) {
    let pyramidoption = {};
    pyramidoption.stepped = { visible: true, isOn: this.shapeIndex == 2 || this.shapeIndex == 3 };
    pyramidoption.inverse = { visible: true, isOn: this.shapeIndex == 1 || this.shapeIndex == 3 };
    pyramidoption.isfill = { visible: true, isOn: this.isFillBg };
    let topLable = this.diagramData.properties.inverted ? "Base width" : "Top width";
    let baseLable = this.diagramData.properties.inverted ? "Top width" : "Base width";
    pyramidoption.topwidth = { minValue: 0, maxValue: this.diagramParent.clientWidth * 0.8, value: this.funnelGap, property: "topwidth", data: "topwidth", lable: topLable };
    pyramidoption.basewidth = { minValue: this.diagramParent.clientWidth * 0.3, maxValue: this.diagramParent.clientWidth * 0.8, value: this.baseWidth, property: "basewidth", data: "basewidth", lable: baseLable };
    obj.dpcontent.floatdiagramsettings.pyramidoption = pyramidoption;
};

PyramidDiagram.prototype.changeShape = function (operation) {
    if (operation.property == "stepped") {
        this.diagramData.properties.stepped = operation.value;
    } else if (operation.property == "inverted") {
        this.diagramData.properties.inverted = operation.value;
    }

    if (this.diagramData.properties.stepped && this.diagramData.properties.inverted) {
        this.shapeIndex = 3;
    } else if (!this.diagramData.properties.stepped && !this.diagramData.properties.inverted) {
        this.shapeIndex = 0;
    } else if (this.diagramData.properties.stepped && !this.diagramData.properties.inverted) {
        this.shapeIndex = 2;
    } else if (!this.diagramData.properties.stepped && this.diagramData.properties.inverted) {
        this.shapeIndex = 1;
    }

    this.diagramData.properties.shapeindex = this.shapeIndex;
    this.diagramParent.dataset.shapeindex = this.shapeIndex;
    this.updateProperties(this.diagramData.properties);
    this.changeShapeTo(this.shapeIndex);
    setTimeout(() => {
        // this.updateFrame();
        this.updatePyramidFram();
    }, 500);
};

PyramidDiagram.prototype.updateColor = function (path, i, node) {
    path.classList.remove("clsAccentStroke");
    path.classList.remove("clsAccentfill");
    path.classList.add("clsAccentStroke");

    if (this.isFillBg) path.classList.add("clsAccentfill");

    // let iconNode = node.querySelector("[data-id='contenticonparent']");
    // if (iconNode) {
    //     let use = iconNode.querySelector("[id='useNode']");
    //     if (use) {
    //         use.classList.remove("clsAccentfill");
    //         use.classList.remove("clsContrastFill");
    //         use.classList.add(this.isFillBg && !this.diagramData.properties.sequencetext ? "clsContrastFill" : "clsAccentfill");
    //     }
    // }

    // let sequenceTextNode = node.querySelector("[data-id='sequenceTextNode']");
    // if (sequenceTextNode) {
    //     sequenceTextNode.classList.remove("background-color");
    //     !this.isFillBg ? sequenceTextNode.classList.remove("background-color") : sequenceTextNode.classList.add("background-color");
    //     sequenceTextNode.classList.remove("inner-color");
    //     sequenceTextNode.classList.remove("clsAccentColor");

    //     sequenceTextNode.classList.add(this.isFillBg ? "inner-color" : "clsAccentColor");
    // }
};

PyramidDiagram.prototype.updateBgColor = function (operation) {
    this.isFillBg = operation.value;
    this.diagramData.properties.isfillbg = operation.value;
    this.updateProperties(this.diagramData.properties);
    this.updateFrame();

    let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    nodeHolder.classList.remove("clsShapeBgEnable");
    this.isFillBg ? nodeHolder.classList.add("clsShapeBgEnable") : nodeHolder.classList.remove("clsShapeBgEnable");
};

PyramidDiagram.prototype.emphasize = function (emphasizeData) {
    LinearDiagram.prototype.emphasize.call(this, emphasizeData);
    this.updatePyramidEmphasize();
};

PyramidDiagram.prototype.updateEmphasize = function () {
    LinearDiagram.prototype.updateEmphasize.call(this);
    this.updatePyramidEmphasize();
};

PyramidDiagram.prototype.updatePyramidEmphasize = function () {
    let centerNode = this.diagramParent.querySelector("[id='pyramidsvg']");
    if (!centerNode) return;
    let arrPath = Array.from(centerNode.querySelectorAll("path"));
    this.arrDiagramNode.map(
        function (node, i) {
            let nodeParent = node.parentNode.parentElement;
            let path = arrPath[i];
            let emphasizeEnableClass = this.diagramData.properties.isfillbg ? "clsEmphasisEnabledBG" : "clsEmphasisEnabled";
            let emphasizeDisableClass = this.diagramData.properties.isfillbg ? "clsEmphasisDisabledBG" : "clsEmphasisDisabled";
            if (nodeParent && path && nodeParent.classList.contains("clsEmphasisEnabled")) {
                path.classList.remove(emphasizeDisableClass);
                path.classList.add(emphasizeEnableClass);
            } else if (path && nodeParent.classList.contains("clsEmphasisDisabled")) {
                path.classList.remove(emphasizeEnableClass);
                path.classList.add(emphasizeDisableClass);
            } else {
                path.classList.remove("clsEmphasisEnabledBG");
                path.classList.remove("clsEmphasisEnabled");
                path.classList.remove("clsEmphasisDisabledBG");
                path.classList.remove("clsEmphasisDisabled");
            }
        }.bind(this)
    );
};

PyramidDiagram.prototype.setHighlightPosition = function (node, parent) {
    let nodeParent = node.parentElement;
    let element = nodeParent.querySelector("[data-id='diagramContentNode']");
    if (!element || element.clientWidth == 0) element = node;

    let alignment = "vertical";
    let nodeAngle = parseInt(nodeParent.dataset.angle);
    if (nodeAngle > 0 && nodeAngle < 180) alignment = "left";
    else if (nodeAngle > 180 && nodeAngle < 360) alignment = "right";

    return { element: element, alignment: alignment };
};

PyramidDiagram.prototype.isNonLinearAsset = function () {
    return true;
};

PyramidDiagram.prototype.offDescription = function (isAmination = true) {
    let pyHolder = this.diagramParent.querySelector("[data-id='deviceHolderParent']");
    // pyHolder.style.transition = isAmination ? "all 0.3s" : "unset";
    // setTimeout(() => {
    //     pyHolder.style.transition = "unset";
    // }, 300);
    let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    if (this.secContentOn) {
        nodeHolder.classList.remove("descriptionoff");
        pyHolder.style.left = "0px";
        this.updatePyramidFram();
    } else {
        nodeHolder.classList.add("descriptionoff");
        pyHolder.style.left = this.diagramParent.clientWidth / 2 - pyHolder.clientWidth / 2 + "px";
        this.updatePyramidFram();
    }
};

PyramidDiagram.prototype.showHideSecContent = function (operation, isAmination = false) {
    this.secContentOn = operation.value;
    this.diagramParent.setAttribute("data-issecontent", this.secContentOn);
    this.offDescription(isAmination);
    if (!operation.value.dragging) {
        let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
        if (lastDiv) this.updatePropsCallBack(lastDiv.id);
    }
};

PyramidDiagram.prototype.changeTopWidth = function (operation) {
    let pyHolder = this.diagramParent.querySelector("[data-id='deviceHolderParent']");
    let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    this.funnelGap = parseInt(operation.value);
    pyHolder.style.width = Math.max(this.funnelGap, this.baseWidth) + "px";
    nodeHolder.style.setProperty("--pathanimationtime", "0s");
    this.updatePyramidFram();
    nodeHolder.style.setProperty("--pathanimationtime", "0.6s");

    if (!operation.dragging) {
        this.diagramParent.setAttribute("data-topwidth", this.funnelGap);
        let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
        if (lastDiv) this.updatePropsCallBack(lastDiv.id);
    }
};

PyramidDiagram.prototype.changeBaseWidth = function (operation) {
    let pyHolder = this.diagramParent.querySelector("[data-id='deviceHolderParent']");
    let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    this.baseWidth = parseInt(operation.value);
    // this.diagramParent.setAttribute("data-basewidth", this.baseWidth);
    pyHolder.style.width = Math.max(this.funnelGap, this.baseWidth) + "px";
    nodeHolder.style.setProperty("--pathanimationtime", "0s");
    this.updatePyramidFram();
    nodeHolder.style.setProperty("--pathanimationtime", "0.6s");

    if (!operation.dragging) {
        this.diagramParent.setAttribute("data-basewidth", this.baseWidth);
        let lastDiv = this.diagramParent.querySelector("[name='nodeparent'][data-index='" + (this.arrDiagramNode.length - 1) + "']");
        if (lastDiv) this.updatePropsCallBack(lastDiv.id);
    }
};

PyramidDiagram.prototype.getPointFromPath = function (path) {
    let d = path.getAttribute("d");
    let arrPoint = [];
    if (d) {
        let arrStrPoints = d.split("L");
        arrStrPoints.map(function (strPoint) {
            let x = strPoint.replace(/[^\d,]/g, "").split(",")[0];
            let y = strPoint.replace(/[^\d,]/g, "").split(",")[1];
            arrPoint.push({ x: parseInt(x), y: parseInt(y) });
        });
    }
    return arrPoint;
};

PyramidDiagram.prototype.getCenter = function (pts) {
    var first = pts[0],
        last = pts[pts.length - 1];
    if (first.x != last.x || first.y != last.y) pts.push(first);
    var twicearea = 0,
        x = 0,
        y = 0,
        nPts = pts.length,
        p1,
        p2,
        f;
    for (var i = 0, j = nPts - 1; i < nPts; j = i++) {
        p1 = pts[i];
        p2 = pts[j];
        f = p1.x * p2.y - p2.x * p1.y;
        twicearea += f;
        x += (p1.x + p2.x) * f;
        y += (p1.y + p2.y) * f;
    }
    f = twicearea * 3;
    return { x: parseInt(x / f), y: parseInt(y / f) };
};

PyramidDiagram.prototype.diagramPasteHandler = function (event) {
    let nodeHolder = this.diagramParent.querySelector("[name='nodesHolder']");
    nodeHolder.style.setProperty("--pathanimationtime", "0s");
    LinearDiagram.prototype.diagramPasteHandler.call(this, event);
    // event.preventDefault();
    // let strUnformattedText = (event.clipboardData || event.originalEvent.clipboardData).getData("text/plain");
    // document.execCommand("insertText", false, strUnformattedText);
};

PyramidDiagram.prototype.setupInLineFloaterOption = function (elTarget, strSelectionType, dict) {
    let centerNode = this.diagramParent.querySelector("[data-id='centerNode']");
    let isCenterChild = centerNode ? this.isChildOfParent(elTarget, centerNode) : false;

    let subNodes = this.nodeProps.supportedNodes[0];
    if ((subNodes && subNodes.subNodes && subNodes.subNodes.length <= 2) || !subNodes.subNodes) return;

    if (isCenterChild) {
        let { options, selectedindex } = this.getSeletion(this.centerNode.firstElementChild.dataset.contentType, "centerNode");
        dict.contentswap = {
            dpsource: options,
            selectedindex: selectedindex,
            floaterproperty: "contentChange",
            visible: options.length > 1 ? true : false,
        };
        elTarget.setAttribute("data-focus-parent", "centerHolderParent");
    }
};

PyramidDiagram.prototype.contentChange = function (operation) {
    LinearDiagram.prototype.contentChange.call(this, operation);
    setTimeout(() => {
        this.updatePyramidFram();
    }, 400);
};

PyramidDiagram.prototype.updateFloaterSettings = function (mainProperties) {
    SimpleLinearVerticalDiagram.prototype.updateFloaterSettings.call(this, mainProperties);
    if (mainProperties.floateroptionsdisable) {
        mainProperties.floateroptionsdisable = [...mainProperties.floateroptionsdisable, "arrange", "graphictext", "sequencetext", "iconsize"];
    } else mainProperties.floateroptionsdisable = ["arrange", "graphictext", "sequencetext", "iconsize"];
    this.diagramParent.setAttribute("data-floateroptionsdisable", mainProperties.floateroptionsdisable);
};

PyramidDiagram.prototype.initPresent = function (currentSlide, boolNoAnimation = false) {
    this.arrDiagramNode.map((node) => {
        let nodeParent = node.parentNode.parentElement;
        nodeParent.removeAttribute("data-animation");
        nodeParent.classList.remove("moodanimation");
    });
    return LinearDiagram.prototype.initPresent.call(this, currentSlide, boolNoAnimation);
};

PyramidDiagram.prototype.showHideSecondary = function (value) {
    LinearDiagram.prototype.showHideSecondary.call(this, value);
    this.showHideSecContent({ value: this.diagramData.properties.primarytext || this.diagramData.properties.secondarytext });
};

PyramidDiagram.prototype.showHidePrimary = function (value) {
    LinearDiagram.prototype.showHidePrimary.call(this, value);
    this.showHideSecContent({ value: this.diagramData.properties.primarytext || this.diagramData.properties.secondarytext });
};

/**
 * Author:    Krishnan M.
 * Created:   14 Aug 2020
 *
 **/

"use strict";

function SingleSidePyramidDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    PyramidDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
    this.diagramParent.className = "clsLinerDiagram pyramidDiagramSingleSide";
}

SingleSidePyramidDiagram.prototype = Object.create(PyramidDiagram.prototype);
SingleSidePyramidDiagram.prototype.constructor = SingleSidePyramidDiagram;

SingleSidePyramidDiagram.prototype.getTriangleShapePoints = function (svg, isInverse = false, funnelGap = 0) {
    let arrLines = Array.from(svg.querySelectorAll("[data-id='line']"));
    arrLines.map((line) => svg.removeChild(line));

    let svgRect = { x: 0, y: 0, width: svg.parentElement.offsetWidth, height: svg.parentElement.offsetHeight };
    let l1 = this.createLine({ x: 0, y: 0 }, { x: 0, y: svgRect.height });
    let l2 = this.createLine({ x: funnelGap, y: 0 }, { x: this.baseWidth, y: svgRect.height });

    if (isInverse) {
        l1 = this.createLine({ x: 0, y: 0 }, { x: 0, y: svgRect.height });
        // l2 = this.createLine({ x: svgRect.width, y: 0 }, { x: svgRect.width / 2 + funnelGap / 2, y: svgRect.height });
        l2 = this.createLine({ x: this.baseWidth, y: 0 }, { x: funnelGap, y: svgRect.height });
    }

    svg.appendChild(l1);
    svg.appendChild(l2);

    let count = this.arrDiagramNode.length;
    let nodeHeight = svgRect.height / count;
    let arrNodeShapePoints = [];
    for (var i = 1; i <= count; i++) {
        let arrPathPoints = [];
        let line = this.createLine({ x: 0, y: nodeHeight * i }, { x: svgRect.width, y: nodeHeight * i });
        svg.appendChild(line);

        if (i == 1) {
            arrPathPoints.push({ x: 0, y: 0 });
            arrPathPoints.push({ x: isInverse ? parseInt(this.baseWidth) : parseInt(funnelGap), y: 0 });
            const point3 = this.checkIntersection(
                l2.x1.baseVal.value,
                l2.y1.baseVal.value,
                l2.x2.baseVal.value,
                l2.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point3.x, y: point3.y });
            const point4 = this.checkIntersection(
                l1.x1.baseVal.value,
                l1.y1.baseVal.value,
                l1.x2.baseVal.value,
                l1.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point4.x, y: point4.y });
        } else if (i > 1) {
            let arrPoints = arrNodeShapePoints[i - 2];
            arrPathPoints.push(JSON.parse(JSON.stringify(arrPoints[3])));
            arrPathPoints.push(JSON.parse(JSON.stringify(arrPoints[2])));
            const point3 = this.checkIntersection(
                l2.x1.baseVal.value,
                l2.y1.baseVal.value,
                l2.x2.baseVal.value,
                l2.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point3.x, y: point3.y });
            const point4 = this.checkIntersection(
                l1.x1.baseVal.value,
                l1.y1.baseVal.value,
                l1.x2.baseVal.value,
                l1.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point4.x, y: point4.y });
        }

        arrNodeShapePoints.push(arrPathPoints);
    }

    return arrNodeShapePoints;
};

SingleSidePyramidDiagram.prototype.svgRectToDiv = function (div, svg) {
    let pyHolder = this.diagramParent.querySelector("[data-id='deviceHolderParent']");
    let svgRect = svg.getBBox();
    svgRect.x = !this.secContentOn ? svgRect.x + this.diagramParent.clientWidth/2 - (pyHolder.clientWidth/2) : svgRect.x;

    let pathPoints = this.getPointFromPath(svg);
    if (pathPoints.length > 4) pathPoints.pop();
    let centerPoint = {x: parseFloat(svg.getAttribute("cx")), y: parseFloat(svg.getAttribute("cy"))};
    let contentCenter = {x: centerPoint.x, y: centerPoint.y + pyHolder.offsetTop - div.offsetTop}
    
    let contentNode = div.querySelector("[data-id='diagramContentNode']");
    contentNode.style.width = svgRect.width + "px";
    contentNode.style.minWidth = svgRect.width + "px";
    contentNode.style.height = svgRect.height + "px";

    let arrContent = Array.from(contentNode.querySelectorAll("[name='iconHolder'],[name='seqTitleHolder'],[name='textTitleHolder']"));

    if (arrContent.length>0) {
        let iconNode = arrContent[0] //contentNode.querySelector("[name='iconHolder']");
        iconNode.style.left = contentCenter.x - iconNode.clientWidth/2 + "px";
        iconNode.style.top = contentCenter.y - iconNode.clientHeight/2 + "px";
    }
    
    let parentOffset = 50;
    let offsetWidth = this.diagramParent.clientWidth - parentOffset - svgRect.x;
    div.style.left = svgRect.x + "px";
    div.style.width = offsetWidth + "px";
    div.style.height = svgRect.height + "px";
    div.style.maxHeight = div.style.height + "px";
};

SingleSidePyramidDiagram.prototype.getSquareShapePoints = function (svg, isInverse = false, funnelGap = 0) {
    let arrLines = Array.from(svg.querySelectorAll("[data-id='line']"));
    arrLines.map((line) => svg.removeChild(line));

    let svgRect = { x: 0, y: 0, width: svg.parentElement.offsetWidth, height: svg.parentElement.offsetHeight };
    let l1 = this.createLine({ x: 0, y: 0 }, { x: 0, y: svgRect.height });
    let l2 = this.createLine({ x: funnelGap, y: 0 }, { x: this.baseWidth, y: svgRect.height });

    if (isInverse) {
        l1 = this.createLine({ x: 0, y: 0 }, { x: 0, y: svgRect.height });
        l2 = this.createLine({ x: this.baseWidth, y: 0 }, { x: funnelGap, y: svgRect.height });
    }

    svg.appendChild(l1);
    svg.appendChild(l2);

    let count = this.arrDiagramNode.length;
    let nodeHeight = svgRect.height / count;
    let arrNodeShapePoints = [];
    let startValue = isInverse ? 0 : 1;
    for (var i = startValue; i <= count; i++) {
        let arrPathPoints = [];
        let line = this.createLine({ x: 0, y: nodeHeight * i }, { x: svgRect.width, y: nodeHeight * i });
        svg.appendChild(line);

        if (!isInverse) {
            const point4 = this.checkIntersection(
                l1.x1.baseVal.value,
                l1.y1.baseVal.value,
                l1.x2.baseVal.value,
                l1.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point4.x, y: point4.y - nodeHeight });

            const point3 = this.checkIntersection(
                l2.x1.baseVal.value,
                l2.y1.baseVal.value,
                l2.x2.baseVal.value,
                l2.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point3.x, y: point3.y - nodeHeight });

            arrPathPoints.push({ x: point3.x, y: point3.y });
            arrPathPoints.push({ x: point4.x, y: point4.y });
        } else {
            const point4 = this.checkIntersection(
                l1.x1.baseVal.value,
                l1.y1.baseVal.value,
                l1.x2.baseVal.value,
                l1.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point4.x, y: point4.y });

            const point3 = this.checkIntersection(
                l2.x1.baseVal.value,
                l2.y1.baseVal.value,
                l2.x2.baseVal.value,
                l2.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point3.x, y: point3.y });

            arrPathPoints.push({ x: point3.x, y: point3.y + nodeHeight });
            arrPathPoints.push({ x: point4.x, y: point4.y + nodeHeight });
        }

        arrNodeShapePoints.push(arrPathPoints);
    }

    return arrNodeShapePoints;
};

SingleSidePyramidDiagram.prototype.contentChange = function (operation) {
    LinearDiagram.prototype.contentChange.call(this, operation)
    setTimeout(() => {
        this.updatePyramidFram();
    }, 300);
    
}
/**
 * Author:    Krishnan M.
 * Created:   23 feb 2021
 *
 **/

"use strict";

function FunnelDiagram(diagramParent, diagramData, nodeProps = {}, moodData = {}) {
    PyramidDiagram.call(this, diagramParent, diagramData, nodeProps, moodData);
}

FunnelDiagram.prototype = Object.create(PyramidDiagram.prototype);
FunnelDiagram.prototype.constructor = FunnelDiagram;

FunnelDiagram.prototype.getTriangleShapePoints = function (svg, isInverse = false, funnelGap = 0) {
    let arrLines = Array.from(svg.querySelectorAll("[data-id='line']"));
    arrLines.map((line) => svg.removeChild(line));

    let svgRect = { x: 0, y: 0, width: svg.parentElement.offsetWidth, height: svg.parentElement.offsetHeight };


    let l1 = this.createLine({ x: 0, y: 0 }, { x: svgRect.width / 2 - funnelGap / 2, y: svgRect.height });
    let l2 = this.createLine({ x: svgRect.width, y: 0 }, { x: svgRect.width / 2 + funnelGap / 2, y: svgRect.height });

    if (isInverse) {
        l1 = this.createLine({ x: svgRect.width / 2 - funnelGap / 2, y: 0 }, { x: 0, y: svgRect.height });
        l2 = this.createLine({ x: svgRect.width / 2 + funnelGap / 2, y: 0 }, { x: svgRect.width, y: svgRect.height });
    }

    svg.appendChild(l1);
    svg.appendChild(l2);

    let count = this.arrDiagramNode.length;
    let nodeHeight = svgRect.height / count;
    let arrNodeShapePoints = [];
    for (var i = 1; i <= count; i++) {
        let arrPathPoints = [];
        let line = this.createLine({ x: 0, y: nodeHeight * i }, { x: svgRect.width, y: nodeHeight * i });
        svg.appendChild(line);

        if (i == 1) {
            arrPathPoints.push({ x: !isInverse ? 0 : svgRect.width / 2 - funnelGap / 2, y: 0 });
            arrPathPoints.push({ x: !isInverse ? svgRect.width : svgRect.width / 2 + funnelGap / 2, y: 0 });
            const point3 = this.checkIntersection(
                l2.x1.baseVal.value,
                l2.y1.baseVal.value,
                l2.x2.baseVal.value,
                l2.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point3.x, y: point3.y });
            const point4 = this.checkIntersection(
                l1.x1.baseVal.value,
                l1.y1.baseVal.value,
                l1.x2.baseVal.value,
                l1.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point4.x, y: point4.y });
        } else if (i > 1) {
            let arrPoints = arrNodeShapePoints[i - 2];
            arrPathPoints.push(JSON.parse(JSON.stringify(arrPoints[3])));
            arrPathPoints.push(JSON.parse(JSON.stringify(arrPoints[2])));
            const point3 = this.checkIntersection(
                l2.x1.baseVal.value,
                l2.y1.baseVal.value,
                l2.x2.baseVal.value,
                l2.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point3.x, y: point3.y });
            const point4 = this.checkIntersection(
                l1.x1.baseVal.value,
                l1.y1.baseVal.value,
                l1.x2.baseVal.value,
                l1.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point4.x, y: point4.y });
        }

        arrNodeShapePoints.push(arrPathPoints);
    }

    return arrNodeShapePoints;
};

FunnelDiagram.prototype.getSquareShapePoints = function (svg, isInverse = false, funnelGap = 0) {
    let arrLines = Array.from(svg.querySelectorAll("[data-id='line']"));
    arrLines.map((line) => svg.removeChild(line));

    let svgRect = { x: 0, y: 0, width: svg.parentElement.offsetWidth, height: svg.parentElement.offsetHeight };

    let l1 = this.createLine({ x: 0, y: 0 }, { x: svgRect.width / 2 - funnelGap / 2, y: svgRect.height });
    let l2 = this.createLine({ x: svgRect.width, y: 0 }, { x: svgRect.width / 2 + funnelGap / 2, y: svgRect.height });


    if (isInverse) {
        l1 = this.createLine({ x: svgRect.width / 2 - funnelGap / 2, y: 0 }, { x: 0, y: svgRect.height });
        l2 = this.createLine({ x: svgRect.width / 2 + funnelGap / 2, y: 0 }, { x: svgRect.width, y: svgRect.height });
    }

    svg.appendChild(l1);
    svg.appendChild(l2);

    let count = this.arrDiagramNode.length;
    let nodeHeight = svgRect.height / count;
    let arrNodeShapePoints = [];
    let startValue = !isInverse ? 0 : 1;
    for (var i = startValue; i <= count; i++) {
        let arrPathPoints = [];
        let line = this.createLine({ x: 0, y: nodeHeight * i }, { x: svgRect.width, y: nodeHeight * i });
        svg.appendChild(line);

        if (isInverse) {
            const point4 = this.checkIntersection(
                l1.x1.baseVal.value,
                l1.y1.baseVal.value,
                l1.x2.baseVal.value,
                l1.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point4.x, y: point4.y - nodeHeight });

            const point3 = this.checkIntersection(
                l2.x1.baseVal.value,
                l2.y1.baseVal.value,
                l2.x2.baseVal.value,
                l2.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point3.x, y: point3.y - nodeHeight });

            arrPathPoints.push({ x: point3.x, y: point3.y });
            arrPathPoints.push({ x: point4.x, y: point4.y });
        } else {
            const point4 = this.checkIntersection(
                l1.x1.baseVal.value,
                l1.y1.baseVal.value,
                l1.x2.baseVal.value,
                l1.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point4.x, y: point4.y });

            const point3 = this.checkIntersection(
                l2.x1.baseVal.value,
                l2.y1.baseVal.value,
                l2.x2.baseVal.value,
                l2.y2.baseVal.value,
                line.x1.baseVal.value,
                line.y1.baseVal.value,
                line.x2.baseVal.value,
                line.y2.baseVal.value
            );
            arrPathPoints.push({ x: point3.x, y: point3.y });

            arrPathPoints.push({ x: point3.x, y: point3.y + nodeHeight });
            arrPathPoints.push({ x: point4.x, y: point4.y + nodeHeight });
        }

        arrNodeShapePoints.push(arrPathPoints);
    }

    return arrNodeShapePoints;
};

FunnelDiagram.prototype.setDiagramSpecficOption = function (obj) {
    let pyramidoption = {};
    pyramidoption.stepped = { visible: true, isOn: this.shapeIndex == 2 || this.shapeIndex == 3 };
    pyramidoption.inverse = { visible: true, isOn: this.shapeIndex == 1 || this.shapeIndex == 3 };
    pyramidoption.isfill = { visible: true, isOn: this.isFillBg };
    pyramidoption.isseccontent = { visible: true, isOn: this.secContentOn };
    let topLable = this.diagramData.properties.inverted ? "Base width" : "Top width";
    let baseLable = this.diagramData.properties.inverted ? "Top width" : "Base width";
    pyramidoption.topwidth = { minValue: 0, maxValue: this.diagramParent.clientWidth * 0.8, value: this.funnelGap, property: "topwidth", data: "topwidth", lable: baseLable };
    pyramidoption.basewidth = { minValue: this.diagramParent.clientWidth * 0.3, maxValue: this.diagramParent.clientWidth * 0.8, value: this.baseWidth, property: "basewidth", data: "basewidth", lable: topLable };
    obj.dpcontent.floatdiagramsettings.pyramidoption = pyramidoption;
};
