/**
 * Author:    Saravanan G
 * Created:   27.09.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function TextHighLightUtils() {}

TextHighLightUtils.prototype.constructor = TextHighLightUtils;

let _mainMoodData = null;

TextHighLightUtils.setMoodData = function (mainMoodData) {
    _mainMoodData = mainMoodData;
};

TextHighLightUtils.getMoodData = function () {
    return _mainMoodData;
};

TextHighLightUtils.uuidv4 = function () {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
        var r = (Math.random() * 16) | 0,
            v = c == "x" ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
};

TextHighLightUtils.getWindowSelection = function () {
    let selection = null;
    if (window.getSelection) {
        selection = window.getSelection();
    } else if (typeof document.selection != "undefined") {
        selection = document.selection;
    }
    return selection;
};

TextHighLightUtils.getWindowSelectionRange = function () {
    try {
        let selection = TextHighLightUtils.getWindowSelection();
        if (selection) {
            let selectedRange = selection.getRangeAt(0);
            return selectedRange;
        }
    } catch (error) {}
    return null;
};

TextHighLightUtils.getWindowNonCollapsedSelectionRange = function () {
    try {
        let selection = TextHighLightUtils.getWindowSelection();
        if (selection && !selection.isCollapsed) {
            let selectedRange = selection.getRangeAt(0);
            return selectedRange;
        }
    } catch (error) {}
    return null;
};

TextHighLightUtils.removeAllSelectionRanges = function () {
    let selection = TextHighLightUtils.getWindowSelection();
    if (selection) {
        selection.removeAllRanges();
    }
};

TextHighLightUtils.setSelectionRange = function (rangeSelection) {
    if (rangeSelection && !rangeSelection.collapsed) {
        let selection = TextHighLightUtils.getWindowSelection();
        if (selection) {
            selection.removeAllRanges();
            selection.addRange(rangeSelection);
        }
    }
};

TextHighLightUtils.getSelectedTextSpan = function (selRange) {
    let elSelectionNode = null;

    try {
        elSelectionNode = selRange.commonAncestorContainer;

        if (elSelectionNode && elSelectionNode.nodeName && elSelectionNode.nodeName === "#text" && elSelectionNode.parentNode) {
            elSelectionNode = elSelectionNode.parentNode;
        }
        if (elSelectionNode.dataset.type != "SUB_TEXT_SPAN") {
            elSelectionNode = null;
        }
    } catch (error) {
        console.log("Selected Text node error..." + error);
    }
    return elSelectionNode;
};

TextHighLightUtils.getTextHighlight = function () {
    return { regEX: /\^\^(.*?)\^\^/g, startReg: /\^\^/g, endReg: "", count: 4, className: "selectedtexthighlight", style: "TITLE_HIGHLIGHT" };
};

TextHighLightUtils.getTextBold = function () {
    return { regEX: /\*\*(.*?)\*\*/g, startReg: /\*\*/g, endReg: "", count: 4, className: "fontbold", style: "" };
};

TextHighLightUtils.getTextSubscript = function () {
    return { regEX: /\_\_(.*?)\_\_/g, startReg: /\_\_/g, endReg: "", count: 4, className: "selectedtextsubscript", style: "" };
};

TextHighLightUtils.getTextItalic = function () {
    return { regEX: /\!\!(.*?)\!\!/g, startReg: /\!\!/g, endReg: "", count: 4, className: "fontitalic", style: "" };
};

TextHighLightUtils.getTextUnderLine = function () {
    return { regEX: /\*\_(.*?)\*\_/g, startReg: /\*\_/g, endReg: "", count: 4, className: "fontunderline", style: "" };
};

TextHighLightUtils.getTextSuperScript = function () {
    return { regEX: /\`\`(.*?)\`\`/g, startReg: /\`\`/g, endReg: "", count: 4, className: "selectedtextsuperscript", style: "" };
};

TextHighLightUtils.getTextStrike = function () {
    return { regEX: /\~\~(.*?)\~\~/g, startReg: /\~\~/g, endReg: "", count: 4, className: "fontstrikethrough", style: "" };
};

TextHighLightUtils.getTextImage = function () {
    return { regEX: /\[(image)\]\((.*?)\)/gi, startReg: /\[-/g, endReg: /\]-/g, count: 0, className: "selectedtextimage", style: "", image: true };
};

TextHighLightUtils.getProfile = function () {
    return { regEX: /\[(profile)\]\((.*?)\)/gi, startReg: /\[-/g, endReg: /\]-/g, count: 0, className: "profileimage", style: "", image: true };
};

TextHighLightUtils.mention = function () {
    return { regEX: /\[(@mention)\]\[(.*?)\]/gi, startReg: /\[(@mention)\]\[/, endReg: /\]/, count: 0, className: "mentionprofile", style: "", profile: true };
};

TextHighLightUtils.getTextLink = function () {
    return { regEX: /\[(.*?)\]\((.*?)\)/gi, startReg: /\[-/g, endReg: /\]-/g, count: 0, className: "selectedtextlinkurl", style: "", link: true };
};

TextHighLightUtils.getSelectedTextColor = function () {
    return { regEX: /\{(.*?)\}\{(.*?)\}/gi, startReg: /\{-/g, endReg: /\}-/g, count: 0, className: "selectedTextColor", style: "", color: true };
};

TextHighLightUtils.checkForNestedNodes = function (element) {
    let subData = "";
    if (element.childNodes.length > 0) {
        element.childNodes.forEach((child) => {
            subData += TextHighLightUtils.convertHighLightToOutline(child, subData);
        });
    }
    return subData;
};

TextHighLightUtils.convertHighLightToOutline = function (element, htmlText = "") {
    let nodeName = element.nodeName.toLowerCase();
    let type = element.getAttribute ? element.getAttribute("data-type") : "";
    let nodeText = element.textContent ? element.textContent : element.wholeText || "";
    nodeText = nodeText.replace(/<br\s*\/?>/gi, "\n").replace(/&nbsp;/gi, " ");
    let classList = element.classList;
    let data = "";
    switch (nodeName) {
        case "#text":
            data = nodeText;
            break;
        case "br":
            data = "\n";
            break;
        case "span":
        case "p":
            if (classList.contains("selectedTextColor")) {
                let color = element.style.color;
                if (color) color = color.replace(/\s/g, "");
                color = color.replace("(", "{").replace(")", "}");
                data = "{" + nodeText + "}{" + color + "}";
            } else if (type == "SUB_TEXT_SPAN") {
                data = "^^" + TextHighLightUtils.checkForNestedNodes(element) + "^^";
            } else if (type == "@mention") {
                let link = element.querySelector("a")?.getAttribute("href") || "";
                let image = element.querySelector("img")?.getAttribute("src") || "";
                let name = element.textContent;
                data = "[@mention][(";
                let spliter = "#-";
                let divider = ",";
                if (image) {
                    data += `(${image})`;
                }
                if (name) {
                    data += `(${name})`;
                }
                if (link) {
                    data += `(${link}))]`;
                }

                console.log("data", data);
            } else {
                data = nodeText;
            }
            break;
        case "div":
            let subData = TextHighLightUtils.checkForNestedNodes(element);
            data = (element.innerHTML == "<br>" || htmlText.lastIndexOf("\n") == htmlText.length - 1 ? "" : "\n") + subData;
            break;
        case "s":
            if (type == "SUB_TEXT_SPAN") {
                data = "~~" + TextHighLightUtils.checkForNestedNodes(element) + "~~";
            }
            break;
        case "sup":
            if (type == "SUB_TEXT_SPAN") {
                data = "``" + TextHighLightUtils.checkForNestedNodes(element) + "``";
            }
            break;
        case "sub":
            if (type == "SUB_TEXT_SPAN") {
                data = "__" + TextHighLightUtils.checkForNestedNodes(element) + "__";
            }
            break;
        case "a":
            if (type == "SUB_TEXT_SPAN") {
                let link = element.getAttribute("href");
                data = "[" + nodeText + "](" + link + ")";
            }
            break;
        case "img":
            if (type == "SUB_TEXT_SPAN") {
                let link = element.getAttribute("src");
                data = +nodeText + "[image](" + link + ")";
            }
            break;
        case "i":
            // if (type == "SUB_TEXT_SPAN") {
            data = "!!" + TextHighLightUtils.checkForNestedNodes(element) + "!!";
            // }
            break;
        case "b":
            // if (type == "SUB_TEXT_SPAN") {
            data = "**" + TextHighLightUtils.checkForNestedNodes(element) + "**";
            // }
            break;
        case "u":
            // if (type == "SUB_TEXT_SPAN") {
            data = "*_" + TextHighLightUtils.checkForNestedNodes(element) + "*_";
            // }
            break;
        default:
            data = nodeText;
            break;
    }
    return data;
};

TextHighLightUtils.applyDefaultSpanProperties = function (nodeSpan, strSpanID) {
    if (nodeSpan && strSpanID && strSpanID != "") {
        nodeSpan.setAttribute("id", strSpanID);
        nodeSpan.setAttribute("data-type", "SUB_TEXT_SPAN");
        nodeSpan.setAttribute("contenteditable", true);
    }
};

TextHighLightUtils.createSpan = function (strSpanID) {
    let nodeSpan = document.createElement("p");
    TextHighLightUtils.applyDefaultSpanProperties(nodeSpan, strSpanID);
    return nodeSpan;
};

TextHighLightUtils.createSpecialNode = function (strNodeType, strSpanID) {
    let nodeSpan = document.createElement(strNodeType);
    TextHighLightUtils.applyDefaultSpanProperties(nodeSpan, strSpanID);
    return nodeSpan;
};

TextHighLightUtils.selectNodeContent = function (nodeSpan) {
    if (nodeSpan) {
        let selection = TextHighLightUtils.getWindowSelection();
        let rangeUpdate = document.createRange();
        rangeUpdate.selectNodeContents(nodeSpan);
        selection.addRange(rangeUpdate);
        return rangeUpdate;
    }
    return null;
};

TextHighLightUtils.clearAllStylesExceptLineBreak = function (nodeTextElement, rangeSelection) {
    if (nodeTextElement) {
        let arrStyleElements = nodeTextElement.querySelectorAll("[data-type=SUB_TEXT_SPAN]");

        let nodeSpan;
        if (rangeSelection) nodeSpan = TextHighLightUtils.getSelectedTextSpan(rangeSelection);

        if (arrStyleElements && arrStyleElements.length > 0) {
            const intExistingStylesLength = arrStyleElements.length;

            for (let d1 = 0; d1 < intExistingStylesLength; d1++) {
                if (!nodeSpan || nodeSpan == arrStyleElements[d1]) {
                    let nodeUnwrapSubItem = arrStyleElements[d1];
                    $(nodeUnwrapSubItem).contents().unwrap();
                }
            }
        }
    }
};

TextHighLightUtils.highlightToString = function (sourceText) {
    let htmlText = "";
    let textNode = document.createElement("div");
    textNode.innerHTML = sourceText;
    let textNodes = textNode.childNodes;
    if (textNodes.length > 0) {
        textNodes.forEach((element) => {
            htmlText += TextHighLightUtils.convertHighLightToOutline(element, htmlText);
        });
    }
    return htmlText;

    // htmlText = htmlText.replace(/<span(.|\n)*?>|<\/span(.|\n)*?>/g, "**")
    // htmlText = htmlText.replace(/<sup(.|\n)*?>|<\/sup(.|\n)*?>/g, "``")
    // htmlText = htmlText.replace(/<sub(.|\n)*?>|<\/sub(.|\n)*?>/g, "__")
    // htmlText = htmlText.replace(/<s(.|\n)*?>|<\/s(.|\n)*?>/g, "--")

    // if (htmlText.match(/<a(.|\n)*?>*?<\/a(.|\n)*?>/g)) {
    //     let linkData = htmlText.match(/<a(.|\n)*?>*?<\/a(.|\n)*?>/g)
    //     for (let j = 0; j < linkData.length; j++) {
    //         let mainTag = linkData[j];
    //         let tagNode = linkData[j].replace(/<a(.|\n)*?>/g, "[")
    //         tagNode = tagNode.replace(/<\/a(.|\n)*?>/g, "]")
    //         if (mainTag.includes("href")) {
    //             let atag = mainTag.match(/\s*href\s*=\s*(\"([^"]*\")|'[^']*'|([^'">\s]+))/g)[0];
    //             tagNode = tagNode + "(" + atag.replace(/href|=|\'|\"|\s/g, "") + ")"
    //         }
    //         htmlText = htmlText.replace(mainTag, tagNode);
    //     }
    // }

    // if (htmlText.match(/<img(.|\n)*?>/g)) {
    //     let linkData = htmlText.match(/<img(.|\n)*?>/g)
    //     for (let j = 0; j < linkData.length; j++) {
    //         let mainTag = linkData[j];
    //         let tagNode = "[image]"
    //         if (mainTag.includes("src")) {
    //             let atag = mainTag.match(/\s*src\s*=\s*(\"([^"]*\")|'[^']*'|([^'">\s]+))/g)[0];
    //             tagNode = tagNode + "(" + atag.replace(/src|=|\'|\"|\s/g, "") + ")"
    //         }
    //         htmlText = htmlText.replace(mainTag, tagNode);
    //     }
    // }
    // let domNote = document.createElement("p");
    // domNote.innerHTML = htmlText;
    //return //domNote.innerText;
};

TextHighLightUtils.updateHighlight = function (textTitle, strData, strTextElementID = "", isSpecialgraphcis = false) {
    if (textTitle && textTitle.textContent != "") {
        let arrHightLight = [
            TextHighLightUtils.getTextImage(),
            TextHighLightUtils.getProfile(),
            TextHighLightUtils.getTextHighlight(),
            TextHighLightUtils.getTextSubscript(),
            TextHighLightUtils.getTextSuperScript(),
            TextHighLightUtils.getTextStrike(),
            TextHighLightUtils.getTextLink(),
            TextHighLightUtils.getSelectedTextColor(),
            TextHighLightUtils.getTextBold(),
            TextHighLightUtils.getTextItalic(),
            TextHighLightUtils.getTextUnderLine(),
            TextHighLightUtils.mention(),
        ];
        let highLightUpdate = false;
        for (let i = 0; i < arrHightLight.length; i++) {
            const regData = arrHightLight[i];
            let mainData = strData; //.replace(/<br\s*\/?>/gi, "\n").replace(/&nbsp;/gi, " ");
            if (regData.regEX.test(mainData)) {
                textTitle.innerText = mainData.replace(regData.startReg, "").replace(regData.endReg, "");
                mainData = mainData.replace(/\{rgb\{([^}]+)\}\}/, "{rgb($1)}");
                let arrMatchedData = mainData.match(regData.regEX);
                for (let j = 0; j < arrMatchedData.length; j++) {
                    let matchedData = TextHighLightUtils.getHighLightData(arrMatchedData[j], regData);
                    if (matchedData.text.startsWith("<") && matchedData.text.endsWith(">")) {
                        textTitle.innerHTML = matchedData.text;
                    } else {
                        textTitle.innerText = matchedData.text; //.replace(/<br\s*\/?>/gi, "\n").replace(/&nbsp;/gi, " ");
                    }
                    let endIndex = matchedData.text.length;
                    let textNode = textTitle.childNodes[0];
                    let range = TextHighLightUtils.makeTextSelection(textNode, 0, endIndex);
                    TextHighLightUtils.setSelectionRange(range);
                    let nodeSpan = TextHighLightUtils.applyFormat(textTitle, regData.className, true, strTextElementID, matchedData.link, null, matchedData.color);
                    if (textTitle.dataset.index && nodeSpan) {
                        let index = textTitle.dataset.index;
                        nodeSpan.setAttribute("data-index", index);
                    }
                    if (regData.style == "TITLE_HIGHLIGHT") TextHighLightUtils.applyTextHighlightProperties(textTitle, nodeSpan);
                    TextHighLightUtils.removeAllSelectionRanges();
                    mainData = mainData.replace(matchedData.original, textTitle.innerHTML);
                }
                highLightUpdate = true;
                textTitle.innerHTML = mainData;
            }
            strData = textTitle.innerHTML;
        }
        if (!highLightUpdate && !isSpecialgraphcis) textTitle.innerText = textTitle.textContent.replace(/<br\s*\/?>/gi, "\n").replace(/&nbsp;/gi, " ");
    }
    textTitle.innerHTML = textTitle.innerHTML.replaceAll("&lt;br&gt;", "").replaceAll("&amp;nbsp;", "");
};

TextHighLightUtils.getHighLightData = function (hilightData, regData) {
    let objHighlight = { original: hilightData, text: hilightData.replace(regData.startReg, "").replace(regData.endReg, "") };
    if (regData.profile) {
        let link = objHighlight.text.match(/\((.*?)\)\)/gi)?.[0] || null;
        link = link?.replace("((", "(")?.replace("))", ")") || null;
        link = link?.match(/(\((.*?)\))/gi) || null;
        link = link?.map((item) => item.substring(1, item.length - 1) || item);
        if (!link) return objHighlight;
        objHighlight.text = "";
        objHighlight.link = link;
    } else if (regData.image) {
        let link = objHighlight.text.match(/\((.*?)\)/gi)?.[0] || null;
        if (!link) return objHighlight;
        objHighlight.text = "image";
        objHighlight.link = link.replace(/\(|\)|\s/g, "");
    } else if (regData.link) {
        let link = objHighlight.text.match(/\((.*?)\)/gi)[0] || null;
        if (!link) return objHighlight;
        objHighlight.text = objHighlight.text.match(/\[(.*?)\]/gi)[0].replace(/\[|\]|\s/g, "");
        objHighlight.link = link.replace(/\(|\)|\s/g, "");
    } else if (regData.color) {
        let color = objHighlight.text.match(/\{(.*?)\}/gi)?.[1] || null;
        if (!color) return objHighlight;
        objHighlight.text = objHighlight.text.match(/\{(.*?)\}/gi)[0].replace(/\{|\}|/g, "");
        objHighlight.color = color.replace(/\{|\}|\s/g, "");
    }
    return objHighlight;
};

TextHighLightUtils.applyFormat = function (nodeTextElement, strProperty, boolApplyStyle, strParentTextID, strHyperlinkUrl, strHighlightClassName = "", strSelectedTextColor) {
    let selection = TextHighLightUtils.getWindowSelection();
    let rangeCurrentSelection = TextHighLightUtils.getWindowNonCollapsedSelectionRange();

    if (strProperty == "mentionprofile") {
        let [image, name, link] = strHyperlinkUrl;
        let strSpanID = TextHighLightUtils.uuidv4();
        if (link) {
            let nodeSpan = TextHighLightUtils.createSpecialNode("a", strSpanID);

            if (!/^(f|ht)tps?:\/\//i.test(link)) {
                link = "https://" + link;
            }

            nodeSpan.setAttribute("href", link);
            nodeSpan.setAttribute("class", "highlightlink");
            nodeSpan.setAttribute("data-type", "@mention");

            if (image) {
                if (!/^(f|ht)tps?:\/\//i.test(image)) {
                    image = "https://" + image;
                }

                let imageNode = TextHighLightUtils.createSpecialNode("img", strSpanID + "-image");
                imageNode.setAttribute("target", "_blank");
                imageNode.setAttribute("src", image);
                imageNode.setAttribute("class", "highlightprofileimage mr-1 rounded-full inline-block max-h-full object-cover");
                imageNode.style.setProperty("height", "1em", "important");
                imageNode.style.setProperty("min-width", "1em", "important");
                imageNode.style.setProperty("width", "1em", "important");
                nodeSpan.appendChild(imageNode);
            }

            if (name) {
                let textNode = document.createTextNode(name);
                nodeSpan.appendChild(textNode);
            }

            let para = document.createElement("p");
            para.setAttribute("data-type", "@mention");
            para.style.setProperty("display", "inline-block");
            para.style.setProperty("pointer-events", "auto");
            para.appendChild(nodeSpan);
            nodeTextElement.appendChild(para);
            return para;
        }
    } else if (strProperty == "selectedtextimage" || (rangeCurrentSelection && !selection.isCollapsed)) {
        let nodeSpan = TextHighLightUtils.getSelectedTextSpan(rangeCurrentSelection);
        const boolApply = boolApplyStyle;
        let strSelectionID = null;

        if (!boolApply && nodeSpan) {
            nodeSpan = TextHighLightUtils.matchSelectedNode(nodeSpan, strProperty, strParentTextID);
            strSelectionID = nodeSpan.getAttribute("id");

            switch (strProperty) {
                case "fontoverline":
                    nodeSpan.classList.remove("selectedTextOverline");
                    break;
                case "selectedtexthighlight":
                    TextHighLightUtils.removeHighlightSpan(nodeTextElement, nodeSpan);
                    break;
                case "fontbold":
                case "fontitalic":
                case "fontunderline":
                case "fontstrikethrough":
                case "selectedtextsubscript":
                case "selectedtextsuperscript":
                case "selectedtextlinkurl":
                case "chooseslidetonavigateonclick":
                    let nodeReplacement = TextHighLightUtils.createSpan(strSelectionID);
                    nodeReplacement.innerHTML = nodeSpan.innerHTML;
                    if (nodeSpan.dataset.index) nodeReplacement.dataset.index = nodeSpan.dataset.index;
                    nodeSpan.parentNode.replaceChild(nodeReplacement, nodeSpan);
                    break;
            }
        } else if (boolApply) {
            let strSpanID = TextHighLightUtils.uuidv4();
            strSelectionID = strSpanID;
            nodeSpan = TextHighLightUtils.createSpan(strSpanID);
            switch (strProperty) {
                case "fontbold":
                    nodeSpan = TextHighLightUtils.createSpecialNode("b", strSpanID);
                    break;
                case "fontitalic":
                    nodeSpan = TextHighLightUtils.createSpecialNode("i", strSpanID);
                    break;
                case "fontunderline":
                    nodeSpan = TextHighLightUtils.createSpecialNode("u", strSpanID);
                    break;
                case "fontstrikethrough":
                    nodeSpan = TextHighLightUtils.createSpecialNode("s", strSpanID);
                    break;
                case "selectedtextsubscript":
                    nodeSpan = TextHighLightUtils.createSpecialNode("sub", strSpanID);
                    break;
                case "selectedtextsuperscript":
                    nodeSpan = TextHighLightUtils.createSpecialNode("sup", strSpanID);
                    break;
                case "fontoverline":
                    nodeSpan.setAttribute("class", "selectedTextOverline");
                    break;
                case "selectedtexthighlight":
                    let strTextHighlightClassName = "selectedTextHighlight";
                    if (strHighlightClassName && strHighlightClassName != "") {
                        strTextHighlightClassName += " " + strHighlightClassName;
                    }
                    nodeSpan.setAttribute("class", strTextHighlightClassName);
                    break;
                case "selectedtextimage":
                    nodeSpan = TextHighLightUtils.createSpecialNode("img", strSpanID);
                    nodeSpan.setAttribute("target", "_blank");
                    if (strHyperlinkUrl && strHyperlinkUrl != "") {
                        if (!/^(f|ht)tps?:\/\//i.test(strHyperlinkUrl)) {
                            strHyperlinkUrl = "https://" + strHyperlinkUrl;
                        }
                        nodeSpan.setAttribute("src", strHyperlinkUrl);
                        nodeSpan.setAttribute("class", "selectedTextImg");
                        nodeSpan.style.height = window.getComputedStyle(nodeTextElement).lineHeight + "!important";
                    }
                    break;
                case "selectedTextColor":
                case "selectedtextcolor":
                    nodeSpan.style.color = strSelectedTextColor || boolApplyStyle;
                    nodeSpan.classList.remove("selectedTextColor");
                    nodeSpan.classList.add("selectedTextColor");
                    break;
                case "profileimage":
                    nodeSpan = TextHighLightUtils.createSpecialNode("img", strSpanID);
                    nodeSpan.setAttribute("target", "_blank");
                    if (strHyperlinkUrl && strHyperlinkUrl != "") {
                        if (!/^(f|ht)tps?:\/\//i.test(strHyperlinkUrl)) {
                            strHyperlinkUrl = "https://" + strHyperlinkUrl;
                        }
                        nodeSpan.setAttribute("src", strHyperlinkUrl);
                        nodeSpan.setAttribute("class", "highlightprofileimage mr-1 pb-2 rounded-full inline-block h-24 w-24 max-h-full object-cover");
                        // nodeSpan.style.height = window.getComputedStyle(nodeTextElement).lineHeight + "!important";
                        // nodeSpan.style.width = window.getComputedStyle(nodeTextElement).lineHeight + "!important";
                        let lineHeight = parseFloat(window.getComputedStyle(nodeTextElement).lineHeight?.replace("px", "") || "20");
                        let height = parseFloat(window.getComputedStyle(nodeTextElement).height?.replace("px", "") || "20");
                        let _h = Math.max(lineHeight, height) + 10 + "px";
                        nodeSpan.style.setProperty("height", _h, "important");
                        nodeSpan.style.setProperty("min-width", _h, "important");
                        nodeSpan.style.setProperty("width", _h, "important");
                    }
                    break;
                case "selectedtextlinkurl":
                    nodeSpan = TextHighLightUtils.createSpecialNode("a", strSpanID);

                    if (strHyperlinkUrl && strHyperlinkUrl != "") {
                        if (!/^(f|ht)tps?:\/\//i.test(strHyperlinkUrl)) {
                            strHyperlinkUrl = "https://" + strHyperlinkUrl;
                        }
                        nodeSpan.setAttribute("href", strHyperlinkUrl);
                        nodeSpan.setAttribute("class", "selectedTextHyperlink");
                    }
                    break;
                case "selectedtextlinkslide":
                    nodeSpan.setAttribute("class", "selectedTextSlideHyperlink");
                    nodeSpan.setAttribute("data-navigate-to-slide-on-click", strHyperlinkUrl);
                    break;
            }

            if (nodeSpan) {
                if (rangeCurrentSelection?.commonAncestorContainer?.tagName == "UL" || rangeCurrentSelection?.endContainer?.tagName == "LI") {
                    if (rangeCurrentSelection?.startContainer?.parentElement && rangeCurrentSelection.startContainer.parentElement.tagName == "LI") {
                        let extractedtext = rangeCurrentSelection.startContainer;
                        let li = rangeCurrentSelection.startContainer.parentElement;
                        let div = li.querySelector("div");
                        li.innerHTML = "";
                        if (div) li.appendChild(div);
                        if (nodeSpan) {
                            nodeSpan.innerText = extractedtext.textContent;
                            li.appendChild(nodeSpan);
                        }
                    }
                } else {
                    let childs = rangeCurrentSelection.extractContents().childNodes;
                    childs.forEach((element) => {
                        if (element.textContent == "") element.remove();
                        else nodeSpan.appendChild(element.cloneNode(true));
                    });
                    rangeCurrentSelection.insertNode(nodeSpan);
                }
            }
        }

        TextHighLightUtils.removeEmptySpans(nodeTextElement);
        return nodeSpan;
    }
    return null;
};

TextHighLightUtils.matchSelectedNode = function (nodeTarget, strProperty, strParentRefID) {
    if (nodeTarget && strProperty && strProperty != "") {
        const strFloatProp = strProperty;
        const strRemoveNodeName = nodeTarget.nodeName;
        const arrClassList = nodeTarget && nodeTarget.classList ? nodeTarget.classList : null;
        const intClassLength = arrClassList ? arrClassList.length : 0;

        for (let c1 = 0; c1 < intClassLength; c1++) {
            const strClassName = arrClassList[c1];

            switch (strClassName) {
                case "selectedTextOverline":
                    if (strFloatProp === "fontoverline") {
                        return nodeTarget;
                    }
                    break;
                case "selectedTextHighlight":
                    if (strFloatProp === "selectedtexthighlight") {
                        return nodeTarget;
                    }
                    break;
                case "selectedTextHyperlink":
                    if (strFloatProp === "selectedtextlinkurl") {
                        return nodeTarget;
                    }
                    break;
                case "selectedTextSlideHyperlink":
                    if (strFloatProp === "selectedtextlinkurl" || strFloatProp === "chooseslidetonavigateonclick") {
                        return nodeTarget;
                    }
                    break;
            }
        }

        switch (strRemoveNodeName) {
            case "B":
                if (strFloatProp === "fontbold") {
                    return nodeTarget;
                }
                break;
            case "I":
                if (strFloatProp === "fontitalic") {
                    return nodeTarget;
                }
                break;
            case "U":
                if (strFloatProp === "fontunderline") {
                    return nodeTarget;
                }
                break;
            case "S":
                if (strFloatProp === "fontstrikethrough") {
                    return nodeTarget;
                }
                break;
            case "SUB":
                if (strFloatProp === "selectedtextsubscript") {
                    return nodeTarget;
                }
                break;
            case "SUP":
                if (strFloatProp === "selectedtextsuperscript") {
                    return nodeTarget;
                }
                break;
            case "A":
                if (strFloatProp === "selectedtextlinkurl") {
                    return nodeTarget;
                }
                break;
        }

        if (nodeTarget.parentNode) {
            const nodeTargetParent = nodeTarget.parentNode;
            const strParentNodeID = nodeTargetParent.getAttribute("id");

            if (strParentRefID && strParentRefID != "" && strParentNodeID === strParentRefID) {
                return nodeTarget;
            }
            return TextHighLightUtils.matchSelectedNode(nodeTargetParent, strProperty, strParentRefID);
        } else {
            return nodeTarget;
        }
    }
};

TextHighLightUtils.removeHighlightSpan = function (nodeTextElement, nodeSpan) {
    let nodeReplacement = document.createElement("removediv");
    nodeReplacement.innerHTML = nodeSpan.innerHTML;
    if (nodeSpan.dataset.index) nodeReplacement.dataset.index = nodeSpan.dataset.index;
    if (nodeSpan.parentElement.id == "spandiv") {
        nodeSpan.parentElement.parentElement.replaceChild(nodeReplacement, nodeSpan.parentElement);
    } else {
        nodeSpan.parentElement.replaceChild(nodeReplacement, nodeSpan);
    }
    // let strText = nodeTextElement.innerHTML;
    // strText = strText.replace(/<removediv>/g, "removediv");
    // strText = strText.replace(/<\/removediv>/g, "removediv");

    // let result = strText.split("removediv");
    // let innerHtmlText = "";
    // let isSpan = false;
    // for (let i22 = 0; i22 < result.length; i22++) {
    //     innerHtmlText += result[i22];
    // }
    if (nodeReplacement && nodeReplacement.parentElement) {
        if (nodeReplacement.parentElement.getElementsByTagName("removediv").length > 0) nodeReplacement.parentElement.getElementsByTagName("removediv")[0].removeAttribute("data-index");
        nodeReplacement.parentElement.innerHTML = nodeReplacement.parentElement.innerHTML.replace(/<removediv>|<\/removediv>/g, "");
    }
};

TextHighLightUtils.removeEmptySpans = function (nodeTextElement) {
    if (nodeTextElement) {
        let spanElements = nodeTextElement.getElementsByTagName("span");

        if (spanElements) {
            for (let i1 = 0; i1 < spanElements.length; i1++) {
                let nodeSpan = spanElements[i1];

                if (nodeSpan && nodeSpan.textContent.trim() === "") {
                    nodeSpan.parentNode.removeChild(nodeSpan);
                }
            }
        }
    }
};

TextHighLightUtils.attachFocusOutEventListeners = function (elTextElement, fnCallbackSelectionHandler, fnCallbackPasteHandler = null, fnKeyDownHandler = null) {
    if (elTextElement) {
        if (fnKeyDownHandler) {
            elTextElement.addEventListener("keydown", fnKeyDownHandler);
        }
        if (fnCallbackSelectionHandler) {
            elTextElement.addEventListener("keyup", fnCallbackSelectionHandler);
            elTextElement.addEventListener("mouseup", fnCallbackSelectionHandler);
        }
        if (fnCallbackPasteHandler) {
            elTextElement.addEventListener("paste", fnCallbackPasteHandler);
        }
    }
};

TextHighLightUtils.detachFocusOutEventListeners = function (elTextElement, fnCallbackSelectionHandler, fnCallbackPasteHandler = null, fnKeyDownHandler = null) {
    if (elTextElement) {
        if (fnKeyDownHandler) {
            elTextElement.removeEventListener("keydown", fnKeyDownHandler);
        }
        if (fnCallbackSelectionHandler) {
            elTextElement.removeEventListener("keyup", fnCallbackSelectionHandler);
            elTextElement.removeEventListener("mouseup", fnCallbackSelectionHandler);
        }
        if (fnCallbackPasteHandler) {
            elTextElement.removeEventListener("paste", fnCallbackPasteHandler);
        }
    }
};

TextHighLightUtils.stopEventFlow = function (event) {
    if (event) {
        event.preventDefault();

        if (event.stopPropagation) {
            event.stopPropagation();
        } else if (window.event) {
            window.event.cancelBubble = true;
        }
    }
};

TextHighLightUtils.preventTextEditShortcuts = function (event) {
    if (event) {
        const keyCode = event.which || event.keyCode;
        if (event.ctrlKey && (keyCode === 66 || keyCode === 73)) {
            TextHighLightUtils.stopEventFlow(event);
        }
    }
};

TextHighLightUtils.makeTextSelection = function (textNode, start, length) {
    if (document.selection) {
        //Code for IE and few other
        document.selection.empty();
        let div = document.body.createTextRange();
        div.moveToElementText(textNode);
        div.setEndPoint("EndToEnd", div);
        div.moveStart("character", start);
        if (length + start > textNode.innerHTML.length) length = textNode.innerHTML.length - start;
        div.moveEnd("character", -(textNode.innerHTML.length - start - length));
        div.select();
        return div;
    } else {
        //code for FF and few other
        if (textNode) {
            window.getSelection().removeAllRanges();
            while (textNode.hasChildNodes()) textNode = textNode.childNodes[0];
            let divRange = document.createRange();
            divRange.setStart(textNode, start);
            if (start + length > textNode.length) length = textNode.length - start;
            divRange.setEnd(textNode, start + length);
            window.getSelection().addRange(divRange);
            return divRange;
        }
    }
};

TextHighLightUtils.getTextNodeProperties = function (nodeTextElement) {
    if (nodeTextElement && nodeTextElement.dataset) {
        return nodeTextElement.dataset;
    }
    return null;
};

TextHighLightUtils.applyTextNodeDatasetProperties = function (nodeTextElement, objDataSet, arrFontClasses, slide) {
    if (nodeTextElement && nodeTextElement.style && objDataSet) {
        // const strTextTransform = objDataSet.hasOwnProperty("textTransform") ? objDataSet.textTransform : "";
        // const strFontSize = objDataSet.hasOwnProperty("fontSize") ? objDataSet.fontSize : "";
        // const strBGOpacity = objDataSet.hasOwnProperty("bgopacity") ? objDataSet.bgopacity : "";
        // const strBGClass = objDataSet.hasOwnProperty("background") ? objDataSet.background : "";
        // const strCharSpace = objDataSet.hasOwnProperty("letterSpacing") ? objDataSet.letterSpacing : "";

        if (objDataSet.hasOwnProperty("textTransform") && objDataSet.textTransform != "") {
            nodeTextElement.setAttribute("data-text-transform", objDataSet.textTransform);
            nodeTextElement.style.setProperty("text-transform", objDataSet.textTransform, "important");
        }

        if (objDataSet.hasOwnProperty("letterSpacing") && objDataSet.letterSpacing != "") {
            nodeTextElement.setAttribute("data-letterspacing", objDataSet.letterSpacing);
            nodeTextElement.style.setProperty("letter-spacing", objDataSet.letterSpacing, "important");
        }

        if (objDataSet.hasOwnProperty("letterspacing") && objDataSet.letterspacing != "") {
            nodeTextElement.setAttribute("data-letterspacing", objDataSet.letterspacing);
            nodeTextElement.style.setProperty("letter-spacing", objDataSet.letterspacing, "important");
        }

        // if (objDataSet.hasOwnProperty("fontSize") && objDataSet.fontSize != "") {
        //     nodeTextElement.setAttribute("data-user-font-size", "1");
        //     nodeTextElement.setAttribute("data-font-size", objDataSet.fontSize);
        //     nodeTextElement.style.setProperty("font-size", objDataSet.fontSize, "important");
        // }
        if (objDataSet.hasOwnProperty("customfontclass") && objDataSet.customfontclass != "") {
            TextHighLightUtils.removeFontClassName(nodeTextElement, arrFontClasses);
            nodeTextElement.setAttribute("data-customfontsize", "true");
            nodeTextElement.setAttribute("data-customfontclass", objDataSet.customfontclass);
            nodeTextElement.classList.add(objDataSet.customfontclass);
        }

        if (objDataSet.hasOwnProperty("column")) {
            let ColumnCountValue = objDataSet.column;
            nodeTextElement.setAttribute("columnType", "column-" + ColumnCountValue);
            nodeTextElement.style.columnCount = ColumnCountValue;
            nodeTextElement.classList.add("columnCount");
        }

        if (objDataSet.hasOwnProperty("fontsize") && objDataSet.fontsize != "") {
            TextHighLightUtils.removeFontClassName(nodeTextElement, arrFontClasses);
            nodeTextElement.setAttribute("data-customfontsize", "true");
            nodeTextElement.setAttribute("data-fontsize", objDataSet.fontsize);
            nodeTextElement.classList.add(objDataSet.fontsize);
        }

        if (objDataSet.hasOwnProperty("userbg") && objDataSet.userbg != "") {
            nodeTextElement.setAttribute("data-userbg", objDataSet.userbg);
        }
        if (objDataSet.hasOwnProperty("bgopacity") && objDataSet.bgopacity != "") {
            nodeTextElement.setAttribute("data-bgopacity", objDataSet.bgopacity);
        }
        if (objDataSet.hasOwnProperty("textposition") && slide) {
            slide.setAttribute("data-textposition", objDataSet.textposition);
        }
    }
};

TextHighLightUtils.removeFontClassName = function (targetNode, fontClassList) {
    let arrFontClassNames = fontClassList;
    if (arrFontClassNames) {
        for (let i = 0; i < arrFontClassNames.length; i++) {
            targetNode.classList.remove(arrFontClassNames[i]);
        }
    }
};

TextHighLightUtils.applyTextHighlightProperties = function (nodeTextElement, nodeSpan) {
    let objDataSet;
    let highlightType = "smalltext";
    let strHighlightClassName = "TITLE_HIGHLIGHT";
    if (nodeTextElement.id == "SUBTITLE" || nodeTextElement.id == "TEXTBOX" || nodeTextElement.id.includes("secondaryText") || nodeTextElement.id.includes("textNode") || nodeTextElement.id.includes("sgSubTitleNode") || nodeTextElement.id.includes("subText")) {
        strHighlightClassName = "SUBTITLE_HIGHLIGHT";
    } else if (nodeTextElement.id == "SLIDE_LABEL" || nodeTextElement.id.includes("sgTitleLabelNode") || nodeTextElement.id.includes("textLabel")) {
        strHighlightClassName = "SLIDE_LABEL_HIGHLIGHT";
    }
    if (nodeSpan) {
        nodeSpan.setAttribute("data-highlightanimation", "animate");
    }
    let moodMainData = TextHighLightUtils.getMoodData();
    let layoutproperties = moodMainData && moodMainData.layoutproperties ? moodMainData.layoutproperties : null;
    if (layoutproperties && layoutproperties.hasOwnProperty("texthighlightproperties")) {
        if (layoutproperties.texthighlightproperties) {
            objDataSet = layoutproperties.texthighlightproperties;

            let isBgNotFill = nodeTextElement && nodeTextElement.hasAttribute("isBgFill") ? nodeTextElement.getAttribute("isBgFill") : "false";
            if (nodeTextElement.id == "TITLE" || nodeTextElement.id.includes("primaryText") || nodeTextElement.id.includes("diagramTitle") || ((nodeTextElement.id.includes("sgTitleNode") || nodeTextElement.id.includes("sgAuthorNameNode")) && isBgNotFill == "false")) {
                objDataSet = objDataSet.bigtext;
                nodeTextElement.setAttribute("data-supportedtexthighlight", "bigtext");
                highlightType = "bigtext";
            } else if (
                nodeTextElement.id == "SUBTITLE" ||
                nodeTextElement.id == "SLIDE_LABEL" ||
                nodeTextElement.id == "TEXTBOX" ||
                nodeTextElement.id.includes("secondaryText") ||
                nodeTextElement.id.includes("labeltext") ||
                nodeTextElement.id.includes("textNode") ||
                nodeTextElement.id.includes("textLabel") ||
                nodeTextElement.id.includes("subText") ||
                nodeTextElement.id.includes("sgSubTitleNode") ||
                nodeTextElement.id.includes("sgTitleLabelNode") ||
                isBgNotFill == "true"
            ) {
                objDataSet = objDataSet.smalltext;
                nodeTextElement.setAttribute("data-supportedtexthighlight", "smalltext");
                if (isBgNotFill == "true") strHighlightClassName = "SUBTITLE_HIGHLIGHT";
            }
        }
    }
    if (nodeSpan && nodeSpan.style && objDataSet) {
        nodeSpan.removeAttribute("data-highlight-type");
        let fixedFontColor = "false";
        if (objDataSet.hasOwnProperty("fixedfontcolor") && objDataSet.fixedfontcolor == "true") {
            fixedFontColor = "true";
        }
        nodeSpan.setAttribute("data-fixed-font-color", fixedFontColor);
        if (objDataSet.hasOwnProperty("align") && objDataSet.align != "") {
            nodeSpan.setAttribute("data-align", objBackground.align);
        }
        if (objDataSet.hasOwnProperty("background") && objDataSet.background != "") {
            let objBackground = objDataSet.background;
            if (objBackground.hasOwnProperty("show") && objBackground.show != "" && objBackground.show) {
                nodeSpan.removeAttribute("class");
                nodeSpan.classList.add("selectedTextHighlight");
                nodeSpan.classList.add("highlightbg");
                let strColor = objBackground.color ? objBackground.color : "";
                nodeSpan.classList.add("animatehighlightbg" + strColor);
                if (objBackground.hasOwnProperty("color") && objBackground.color != "") nodeSpan.setAttribute("data-color", objBackground.color);
            } else {
                nodeSpan.classList.add(strHighlightClassName);
            }
            nodeSpan.setAttribute("data-highlight-type", "background");
        }
        if (objDataSet.hasOwnProperty("backgroundbottomborder") && objDataSet.backgroundbottomborder != "") {
            let objBackground = objDataSet.backgroundbottomborder;
            if (objBackground.hasOwnProperty("show") && objBackground.show != "" && objBackground.show) {
                nodeSpan.removeAttribute("class");
                nodeSpan.classList.add("selectedTextHighlight");
                nodeSpan.classList.add("highlightbgbottomborder");
                let strColor = objBackground.color ? objBackground.color : "";
                nodeSpan.classList.add("animatehighlightbgbottomborder" + strColor);
                if (objBackground.hasOwnProperty("color") && objBackground.color != "") nodeSpan.setAttribute("data-color", objBackground.color);
            } else {
                nodeSpan.classList.add(strHighlightClassName);
            }
            nodeSpan.setAttribute("data-highlight-type", "backgroundbottomborder");
        } else {
            nodeSpan.classList.add(strHighlightClassName);
        }
        if (objDataSet.hasOwnProperty("pattern") && objDataSet.pattern != "" && patternPath && patternPath != "") {
            nodeSpan.classList.add("highlightpattern");
            var parser = new DOMParser();
            var xmlPatternSvg = parser.parseFromString(patternPath, "image/svg+xml").documentElement;
            let styleData = window.getComputedStyle(nodeSpan);
            let color = styleData.getPropertyValue("color");
            xmlPatternSvg.setAttribute("fill", color);
            let xmlData = new XMLSerializer().serializeToString(xmlPatternSvg);
            var base64Data = window.btoa(xmlData);
            nodeSpan.style.backgroundImage = "url(" + "data:image/svg+xml;base64," + base64Data + ")";
        }
        if (objDataSet.hasOwnProperty("border") && objDataSet.border != "") {
            let objBorder = objDataSet.border;
            nodeSpan.style.setProperty("display", "inline-flex");
            nodeSpan.classList.add("highlightborder");
            nodeSpan.classList.add("animatehighlightborder");
            /* if (objBorder.hasOwnProperty("width") && objBorder.width != "") {
                nodeSpan.style.setProperty("border-top", objBorder.width[0]);
                nodeSpan.style.setProperty("border-right", objBorder.width[1]);
                nodeSpan.style.setProperty("border-bottom", objBorder.width[2]);
                nodeSpan.style.setProperty("border-left", objBorder.width[3]);
            }
            if (objBorder.hasOwnProperty("style") && objBorder.style != "") nodeSpan.style.setProperty("border-style", objBorder.style); */
            nodeSpan.setAttribute("data-highlight-type", "border");
        }
        if (objDataSet.hasOwnProperty("gradientborder") && objDataSet.gradientborder != "") {
            let objGradientBorder = objDataSet.gradientborder;
            nodeSpan.classList.add("highlightgradientborder");
            nodeSpan.classList.add("animatehighlightgradientborder");
            nodeSpan.style.setProperty("background-size", objGradientBorder.size, "important");
            nodeSpan.style.setProperty("background-position", objGradientBorder.position, "important");
            nodeSpan.style.setProperty("background-image", objGradientBorder.bgcolor, "important");
            nodeSpan.setAttribute("data-highlight-type", "gradientborder");
        }
        if (objDataSet.hasOwnProperty("font") && objDataSet.font != "") {
            let objFont = objDataSet.font;
            let finalStyle = window.getComputedStyle(nodeTextElement, null);
            let fontSize = finalStyle["fontSize"];
            if (objFont.hasOwnProperty("size") && objFont.size != "") {
                if (objFont.size.includes("+")) fontSize = Number(fontSize.split("px")[0]) + Number(objFont.size.split("+")[1]);
                else if (objFont.size.includes("-")) fontSize = Number(fontSize.split("px")[0]) - Number(objFont.size.split("-")[1]);
                nodeSpan.style.setProperty("font-size", fontSize + "px");
            }
            if (objFont.hasOwnProperty("weight") && objFont.weight != "") nodeSpan.style.setProperty("font-weight", objFont.weight);
            if (objFont.hasOwnProperty("style") && objFont.style != "") {
                //nodeSpan.style.setProperty("font-style", objFont.style);
                nodeSpan.classList.add(highlightType == "bigtext" ? "hl1" : "hl2");
                nodeSpan.style.setProperty("font-size", fontSize);
                // nodeSpan.style.setProperty("padding-right", "10px");
            }
            if (objFont.hasOwnProperty("stretch") && objFont.stretch != "") nodeSpan.style.setProperty("font-stretch", objFont.stretch);
            if (objFont.hasOwnProperty("lineheight") && objFont.lineheight != "") nodeSpan.style.setProperty("line-height", objFont.lineheight);
            if (objFont.hasOwnProperty("letterspacing") && objFont.letterspacing != "") nodeSpan.style.setProperty("letter-spacing", objFont.letterspacing);
            if (objFont.hasOwnProperty("texttransform") && objFont.texttransform != "") nodeSpan.style.setProperty("text-transform", objFont.texttransform);
            if (objFont.hasOwnProperty("textdecoration") && objFont.textdecoration != "") {
                nodeSpan.style.setProperty("display", "inline-flex");
                nodeSpan.classList.add("highlightline");
                nodeSpan.classList.add("animatehighlightline");
            }
            nodeSpan.setAttribute("data-highlight-type", "font");
        }
        if (objDataSet.hasOwnProperty("annotate") && objDataSet.annotate != "") {
            nodeSpan.classList.add("animatehighlightbg");
            nodeSpan.classList.remove(strHighlightClassName);
            nodeSpan.style.backgroundImage = "none";
            nodeSpan.setAttribute("annotate", objDataSet.annotate);
            var annotation = annotate(nodeSpan, { type: objDataSet.annotate, color: "var(--item" + 1 + "-color)", padding: 15 });
            annotation._svg.id = nodeSpan.id;
            annotation._svg.style.left = nodeSpan.offsetLeft;
            /* annotation._svg.style.width = nodeSpan.offsetWidth;
            annotation._svg.style.height = nodeSpan.offsetHeight; */
            annotation.animate = false;
            annotation.multiline = true;
            annotation.rects();
            annotation.hide();
            annotation.show();
            nodeSpan.setAttribute("data-highlight-type", "annotate");
        }
    } else if (nodeSpan) {
        nodeSpan.classList.add(strHighlightClassName);
    }
};

TextHighLightUtils.createHighlightColor = function (strProperty = null, targetNode, moodsData) {
    let colorStyle = "";
    let index = moodsData?.layoutproperties?.texthighlightproperties?.hdcolorindex || 0;

    if (targetNode) {
        if (targetNode.getAttribute("data-highlight-color-index")) {
            index = parseInt(targetNode.getAttribute("data-highlight-color-index")) + 1;
        }
        switch (strProperty) {
            case "hdtextcolor_theme1":
                colorStyle = "accent1";
                index = 0;
                break;
            case "hdtextcolor_theme2":
                colorStyle = "accent2";
                index = 1;
                break;
            case "hdtextcolor_theme3":
                colorStyle = "accent3";
                index = 2;
                break;
            case "hdtextcolor_theme4":
                colorStyle = "accent4";
                index = 3;
                break;
            case "hdtextcolor_theme5":
                colorStyle = "accent5";
                index = 4;
                break;
            case "hdtextcolor_theme6":
                colorStyle = "accent6";
                index = 5;
                break;
            case "hdtextcolor_theme7":
                colorStyle = "accent7";
                index = 6;
                break;
            case "hdtextcolor_gradient1":
                colorStyle = "gradient1";
                index = 0;
                break;
            case "hdtextcolor_gradient2":
                colorStyle = "gradient2";
                index = 1;
                break;
            case "hdtextcolor_gradient3":
                colorStyle = "gradient3";
                index = 2;
                break;
            case "hdtextcolor_gradient4":
                colorStyle = "gradient4";
                index = 3;
                break;
            case "hdtextcolor_gradient5":
                colorStyle = "gradient5";
                index = 4;
                break;
            case "hdtextcolor_gradient6":
                colorStyle = "gradient6";
                index = 5;
                break;
            case "hdtextcolor_gradient7":
                colorStyle = "gradient7";
                index = 6;
                break;
            default:
                colorStyle = "accent" + index;
                if (index != 0) index -= 1;
                break;
        }
        targetNode.setAttribute("data-highlight-color-index", index);
        let highlightNodes = targetNode.querySelectorAll(".selectedTextHighlight");
        for (let i1 = 0; i1 < highlightNodes.length; i1++) {
            if (moodsData?.layoutproperties?.texthighlightproperties?.hascolorchange == "true") {
                highlightNodes[i1].setAttribute("data-hdcolor", colorStyle);
                targetNode.setAttribute("enablehighlight", "true");
            } else {
                highlightNodes[i1].removeAttribute("data-hdcolor");
                targetNode.removeAttribute("data-highlight-color-index");
                targetNode.removeAttribute("enablehighlight");
            }
        }
    }
};

/**
 * Author:    Saravanan G
 * Created:   27.09.2019
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function ExportUtils() {}

ExportUtils.prototype.constructor = ExportUtils;

ExportUtils.setSlideWidthHeight = function (width, height) {
    this.slideWidth = width || 1280;
    this.slideHeight = height || 720;
};

ExportUtils.getCropStyle = function (contentNode) {
    let objStyle = {};
    objStyle.x = contentNode.style.getPropertyValue("x");
    objStyle.y = contentNode.style.getPropertyValue("y");
    objStyle.left = contentNode.style.getPropertyValue("left");
    objStyle.width = contentNode.style.getPropertyValue("width");
    objStyle.height = contentNode.style.getPropertyValue("height");
    objStyle.right = contentNode.style.getPropertyValue("right");
    objStyle.top = contentNode.style.getPropertyValue("top");
    objStyle.bottom = contentNode.style.getPropertyValue("bottom");
    objStyle.opacity = parseFloat(contentNode.style.getPropertyValue("opacity"));
    objStyle.transform = contentNode.style.getPropertyValue("transform");
    objStyle["object-fit"] = contentNode.style.getPropertyValue("object-fit");
    if (objStyle["object-fit"] == "" && window.getComputedStyle(contentNode).objectFit != "") objStyle["object-fit"] = window.getComputedStyle(contentNode).objectFit;
    return objStyle;
};

ExportUtils.getImageData = function (image, contentNode, parentID, name = "IMAGE", staticServerURL) {
    let objData = { type: "image", name: name, description: "getImageData - Image with clip" };
    let path =
        image.tagName.toLowerCase() == "video"
            ? image.hasAttribute("poster")
                ? image.getAttribute("poster")
                : ""
            : name == "medialink" && image.hasAttribute("data-medialink-thumb-url")
            ? image.getAttribute("data-medialink-thumb-url")
            : image.hasAttribute("data-medialink-thumb-url")
            ? image.getAttribute("data-medialink-thumb-url")
            : image.src;
    let imageStyle = window.getComputedStyle(image);
    let bgImage = image.style.backgroundImage ? image.style.backgroundImage : imageStyle.backgroundImage;
    if (!path && bgImage) {
        if (bgImage.includes("url(")) bgImage = bgImage.replace('url("', "").replace('")', "");
        path = bgImage;
        objData.type = "drawing";
    }
    path = DiagramUtils.checkAppStaticUrl(path, staticServerURL);

    objData.path = path;
    if (window.isOrigamiPPTX) {
        objData.imagesize = { width: image.offsetWidth, height: image.offsetHeight };
        let type = image.dataset.type || image.dataset.nodetype || null;
        if (type) objData.imagetype = type.toLowerCase().includes("logo") ? "logo" : "image";
        if (image.dataset.width || image.dataset.height) objData.imagefit = true;
    }

    if (objData.path && objData.path.includes(".mp4") && contentNode && contentNode.hasAttribute("poster")) objData.path = contentNode.getAttribute("poster");
    if (contentNode.id == parentID) objData.coords = ExportUtils.getCoords(image, parentID);
    else objData.coords = ExportUtils.getCoords(contentNode, parentID);

    let parentStyle = window.getComputedStyle(image.parentElement);
    if (!isNaN(parseFloat(parentStyle.borderWidth)) && parseFloat(parentStyle.borderWidth) > 0) {
        let arrCoords = objData.coords.split(" ");
        objData.coords = [parseFloat(arrCoords[0]) + parseFloat(parentStyle.borderWidth), parseFloat(arrCoords[1]) + parseFloat(parentStyle.borderWidth), arrCoords[2], arrCoords[3]].join(" ");
    }

    objData.coords = [objData.coords.split(" ")[0], objData.coords.split(" ")[1], contentNode.clientWidth, contentNode.clientHeight].join(" ");

    // objData.style = ExportUtils.getCustomComputedStyle(image, objData);
    objData["inner-style"] = ExportUtils.getCustomComputedStyle(image, objData, false);
    ExportUtils.updateBufferStyle(objData, parentStyle, image.parentElement, "buffer-style", true);
    delete objData["buffer-style"]["border-width"];
    delete objData["buffer-style"]["border-style"];
    delete objData["buffer-style"]["border-color"];
    delete objData["buffer-style"]["outline-width"];
    delete objData["buffer-style"]["outline-style"];
    delete objData["buffer-style"]["outline-color"];

    ExportUtils.setTransfromOriginForImage(objData);

    if (image.hasAttribute("data-medialink-thumb-url")) objData["inner-style"]["object-fit"] = "cover";

    // if (styleData["opacity"] && styleData["opacity"] != "" && styleData["opacity"] != "1" && styleData["opacity"] != "0") {
    //     objData.style.opacity = parseFloat(styleData["opacity"]);
    //     objData.style.alpha = objData.opacity;
    //     objData.opacity = parseFloat(styleData["opacity"]);
    //     objData.alpha = objData.opacity;
    // }
    // let trans = window.getComputedStyle(image).transform;
    // if (trans && trans != "matrix(1, 0, 0, 1, 0, 0)" && (objData.style["background-image"]?.includes("url(") || trans?.includes("scale(") || trans?.includes("matrix("))) {
    //     if (trans.includes("matrix") || (trans.includes("translate") && trans != "translate(0px, 0px)")) objData.promote = false;
    // }
    if (image.hasAttribute("data-fit") && image.getAttribute("data-fit") == "false" && image.id.includes("textFallImage")) {
        objData.coords = objData.coords.split(" ")[0] + " " + (image.id.includes("textFallImage") ? image.offsetTop : objData.coords.split(" ")[1]) + " " + image.clientHeight + " " + image.clientHeight;
        objData["inner-style"]["top"] = "0px";
        objData["inner-style"]["left"] = "0px";
    }
    ExportUtils.updateImageClip(image.parentElement, objData);
    // ExportUtils.updateBorderRadiusFromParent(image.parentElement, objData);
    objData.crop = ExportUtils.getCropStyle(image);
    if (objData["buffer-style"]?.["transform"] == "matrix(1, 0, 0, 0, 0, 0)") objData.coords = "0 0 0 0";

    let coords = objData.coords.split(" ");
    if (parseFloat(coords[0]) > this.slideWidth || parseFloat(coords[1]) > this.slideHeight) objData.coords = "0 0 0 0";

    // Added for carousel image stack
    // if (image?.parentElement?.parentElement?.parentElement?.id?.includes("commonImageParent")) objData["inner-style"]["transform-origin"] = "left top";

    if (name == "medialink" && !objData.crop.width && !objData.crop.height) {
        objData.crop.width = "100%";
        objData.crop.height = "100%";
        objData.crop.left = "0px";
        objData.crop.top = "0px";
    }
    coords = objData.coords.split(" ");
    if (parseFloat(coords[0]) > this.slideWidth || parseFloat(coords[1]) > this.slideHeight) objData.coords = "0 0 0 0";
    if (objData["inner-style"].width == "2560px" && objData["inner-style"].height == "1440px" && objData["inner-style"].transform == "scale(0.5)") {
        objData["inner-style"].width = this.slideWidth + "px";
        objData["inner-style"].height = this.slideHeight + "px";
        delete objData["inner-style"].transform;
        objData.crop.width = this.slideWidth + "px";
        objData.crop.height = this.slideHeight + "px";
        delete objData.crop.transform;
    }
    objData.crop = ExportUtils.removeEmptyItems(objData.crop);
    return objData;
};

ExportUtils.defaultBufferStyle = function (objData, styleNode, coords, element) {
    objData["buffer-style"] = {
        width: coords.w + "px",
        height: coords.h + "px",
        position: "absolute",
        overflow: "hidden",
        left: "0px",
        top: "0px",
    };

    let outlineWidth = styleNode.outlineWidth;
    let borderWidth = styleNode.borderWidth;
    if (!isNaN(parseFloat(outlineWidth))) {
        borderWidth = !isNaN(parseFloat(outlineWidth)) ? parseFloat(borderWidth) : parseFloat(0);
        let coordsData = objData.coords.split(" ");
        // objData["buffer-style"]["left"] = parseFloat(objData["buffer-style"]["left"]) - parseFloat(outlineWidth) / 2 + "px";
        // objData["buffer-style"]["top"] = parseFloat(objData["buffer-style"]["top"]) - parseFloat(outlineWidth) / 2 + "px";
        // objData["buffer-style"]["width"] = parseFloat(objData["buffer-style"]["width"]) + parseFloat(outlineWidth) * 2 + parseFloat(borderWidth) * 2 + "px";
        // objData["buffer-style"]["height"] = parseFloat(objData["buffer-style"]["height"]) + parseFloat(outlineWidth) * 2 + parseFloat(borderWidth) * 2 + "px";
        // coordsData[0] = parseFloat(coordsData[0]) - parseFloat(outlineWidth) / 2 - parseFloat(borderWidth) / 2;
        // coordsData[1] = parseFloat(coordsData[1]) - parseFloat(outlineWidth) / 2 - parseFloat(borderWidth) / 2;
        coordsData[2] = parseFloat(coordsData[2]) + parseFloat(outlineWidth) * 2;
        coordsData[3] = parseFloat(coordsData[3]) + parseFloat(outlineWidth) * 2;
        objData.coords = coordsData.join(" ");

        objData["buffer-style"]["width"] = element.clientWidth + "px";
        objData["buffer-style"]["height"] = element.clientHeight + "px";
    }
};
ExportUtils.updateBufferStyle = function (objData, parentStyle, element, type, isImage = false) {
    ExportUtils.updateStyleData(objData, parentStyle, null, type);
    objData[type].position = parentStyle.position;
    objData[type].overflow = parentStyle.overflow;
    objData[type]["box-sizing"] = parentStyle.boxSizing;
    objData[type].width = element.clientWidth + "px";
    objData[type].height = element.clientHeight + "px";

    if (!isImage) {
        let elementStyle = window.getComputedStyle(element);
        let outlineWidth = elementStyle.outlineWidth;
        let borderWidth = !isNaN(parseFloat(elementStyle.borderWidth)) ? elementStyle.borderWidth : 0;
        if (!isNaN(parseFloat(outlineWidth))) {
            let coordsData = objData.coords.split(" ");
            coordsData[0] = parseFloat(coordsData[0]) - parseFloat(outlineWidth);
            coordsData[1] = parseFloat(coordsData[1]) - parseFloat(outlineWidth);
            coordsData[2] = (element.clientWidth == 0 ? element.offsetWidth : element.clientWidth) + parseFloat(outlineWidth) * 2 + (!isNaN(parseFloat(borderWidth)) ? parseFloat(borderWidth) * 2 : 0);
            coordsData[3] = (element.clientHeight == 0 ? element.offsetHeight : element.clientHeight) + parseFloat(outlineWidth) * 2 + (!isNaN(parseFloat(borderWidth)) ? parseFloat(borderWidth) * 2 : 0);
            objData.coords = coordsData.join(" ");
            objData[type]["left"] = parseFloat(outlineWidth) + "px";
            objData[type]["top"] = parseFloat(outlineWidth) + "px";
        }
        if (!isNaN(parseFloat(borderWidth))) {
            objData[type]["width"] = element.clientWidth + parseFloat(borderWidth) * 2 + "px";
            objData[type]["height"] = element.clientHeight + parseFloat(borderWidth) * 2 + "px";
        }
    }
    if (type == "buffer-style" && (!objData[type].transform || !objData[type].transform == "" || !objData[type].transform == "none" || !objData[type].transform == "unset" || !objData[type].transform == "scale(1)")) {
        let parentNodeStyle = window.getComputedStyle(element.parentElement);
        if ((!parentNodeStyle.transform || parentNodeStyle.transform == "" || parentNodeStyle.transform == "none" || parentNodeStyle.transform == "unset" || parentNodeStyle.transform == "scale(1)" || parentNodeStyle.transform == "matrix(1, 0, 0, 1, 0, 0)") && element.parentElement.parentElement)
            parentNodeStyle = window.getComputedStyle(element.parentElement.parentElement);
        let matrixValue = this.updateTransformData(parentNodeStyle);
        if (matrixValue) {
            objData[type].transform = matrixValue;
            objData[type]["transform-origin"] = "left top";
        }
    }
};

ExportUtils.updateImageClip = function (parentElement, objData) {
    let cpStyle = window.getComputedStyle(parentElement);
    if ((cpStyle && (!cpStyle["clipPath"] || (cpStyle["clipPath"] && cpStyle["clipPath"] == "none"))) || (cpStyle["clipPath"] && cpStyle["clipPath"] == "unset")) cpStyle = window.getComputedStyle(parentElement.parentElement);
    let parentClip = parentElement && parentElement.parentElement ? parentElement.parentElement.style.clipPath : "";
    let isClipEmpty = cpStyle["clipPath"] == "none" || cpStyle["clipPath"] == "unset" || cpStyle["clipPath"] == "" || !cpStyle["clipPath"];
    if ((parentElement && (parentClip == "" || parentClip == "unset") && isClipEmpty && !cpStyle["clipPath"]?.includes("#")) || (parentElement.id.includes("coverParent") && (!cpStyle["clipPath"] || cpStyle["clipPath"] == "none"))) {
        if (parentElement.style.clipPath && !parentElement.parentElement.style.clipPath) parentElement = parentElement;
        else parentElement = parentElement.parentElement;
        cpStyle = window.getComputedStyle(parentElement);
    }
    if (cpStyle && cpStyle["clipPath"]) {
        let pathName = cpStyle["clipPath"].replace('url("#', "").replace('")', "");
        let clipPath = document.querySelector("clipPath[id='" + pathName + "']");
        if (clipPath) {
            let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            let g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            for (let c = 0; c < clipPath.children.length; c++) {
                g.appendChild(clipPath.children[c].cloneNode(true));
            }
            svg.appendChild(g);
            let xmlData = new XMLSerializer().serializeToString(svg);
            let mainSVG = ExportUtils.getParentNodeByName("svg", clipPath);
            if (mainSVG) {
                objData.svgmask = window.btoa(new XMLSerializer().serializeToString(mainSVG));
            }
            objData.mask = window.btoa(xmlData);
            if (clipPath.children.length > 0) {
                let arrPath = clipPath.parentElement.parentElement.getAttribute("path").split("/");
                let pathLength = arrPath.length;
                objData.gsmaskid = clipPath.children[0].getAttribute("id");
                let arrDevicePaths = ["photographic", "professional", "outline", "clay", "frame", "modern", "outline"];
                let isMatched = false;
                for (let a = 0; a < arrDevicePaths.length; a++) {
                    if (arrPath[pathLength - 2].includes(arrDevicePaths[a])) isMatched = true;
                }

                let prefixPath = arrPath[pathLength - 2] && isMatched ? arrPath[pathLength - 2] + "-" : "";
                objData.maskid = prefixPath + arrPath[pathLength - 1].replace(".svg", "");
                let arrCoords = objData.coords.split(" ");
                let rectBox = clipPath.children[0].getBBox();
                objData.maskcoords = [rectBox.x + parseFloat(arrCoords[0]), rectBox.y + parseFloat(arrCoords[1]), rectBox.width - rectBox.x / 2, rectBox.height].toString().replace(/,/g, " ");
                objData.maskcoords = objData.coords;
                objData.coords = objData.maskcoords;
            }
            if (objData.style?.transform?.includes("matrix")) {
                try {
                    let coords = objData.coords.split(" ");
                    let tranformVal = objData.style.transform;
                    let transformX = tranformVal.split(",")[0].replace("matrix(", "").trim();
                    let transformY = tranformVal.split(",")[3].trim();
                    let oldW = parseFloat(coords[2]);
                    let oldH = parseFloat(coords[3]);
                    coords[2] = parseFloat(coords[2]) * parseFloat(transformX);
                    coords[3] = parseFloat(coords[3]) * parseFloat(transformY);
                    coords[0] = parseFloat(coords[0]) + (oldW - parseFloat(coords[2])) / 2;
                    coords[1] = parseFloat(coords[1]) + (oldH - parseFloat(coords[3])) / 2;
                    objData.style.transform = "unset";
                    objData.coords = coords.join(" ");
                } catch (error) {
                    console.log("SG - Image clip coords change error  - ", error);
                }
            }
        }
    }
};

ExportUtils.getParentNodeByName = function (nodeName, element) {
    if (!element) {
        console.log("element is null", element);
        return;
    }
    let parentNode = element.parentElement;
    while (parentNode && parentNode.nodeName.toLowerCase() != nodeName) {
        parentNode = parentNode.parentElement;
    }
    return parentNode;
};

ExportUtils.getCustomComputedStyle = function (nodeItem, objData, takeParentStyle = true) {
    let style = {};
    if (nodeItem && nodeItem.style) {
        let styleData = nodeItem.style;
        let computeStyle = window.getComputedStyle(nodeItem);
        const keys = Object.keys(styleData);
        keys.forEach((element) => {
            let intValue = parseInt(element);
            let keyValue = styleData[element];
            if (intValue != NaN && intValue > -1) {
                let finalVal = computeStyle[keyValue] != styleData[styleData[element]] ? computeStyle[keyValue] : styleData[styleData[element]];
                if (styleData[element] == "transform") {
                    let matrixValue = this.updateTransformData(computeStyle);
                    if (matrixValue) style["transform"] = matrixValue;
                    else style[styleData[element]] = finalVal;
                } else style[styleData[element]] = finalVal;
            } else return style;
        });
        if (!style["width"]) style["width"] = computeStyle.width;
        if (!style["height"]) style["height"] = computeStyle.height;
    }

    let nodeStyle = window.getComputedStyle(nodeItem);
    let nodeParent = takeParentStyle ? nodeItem.parentElement : null;
    let parentNodeStyle = nodeParent ? window.getComputedStyle(nodeParent) : null;
    if (nodeItem.tagName.toLowerCase() == "img") {
        if (nodeItem.hasAttribute("data-fit") && nodeItem.getAttribute("data-fit") == "false") style["position"] = nodeStyle.position;
        else style["position"] = window.getComputedStyle(nodeItem).position;
    }
    if (nodeItem && nodeStyle["-webkit-mask-image"] != "none" && nodeStyle["-webkit-mask-image"] != "unset" && nodeStyle["-webkit-mask-image"] != "") {
        style["-webkit-mask-image"] = nodeStyle["-webkit-mask-image"];
        style["-webkit-mask-size"] = nodeStyle["-webkit-mask-size"] || "100%";
        style["-webkit-mask-position"] = nodeStyle["-webkit-mask-position"] || "center";
        style["-webkit-mask-repeat"] = nodeStyle["-webkit-mask-repeat"] || "no-repeat";
    } else if (nodeParent) {
        if (parentNodeStyle["-webkit-mask-image"] != "none" && parentNodeStyle["-webkit-mask-image"] != "unset" && parentNodeStyle["-webkit-mask-image"] != "") {
            style["-webkit-mask-image"] = parentNodeStyle["-webkit-mask-image"];
            style["-webkit-mask-size"] = parentNodeStyle["-webkit-mask-size"] || "100%";
            style["-webkit-mask-position"] = parentNodeStyle["-webkit-mask-position"] || "center";
            style["-webkit-mask-repeat"] = parentNodeStyle["-webkit-mask-repeat"] || "no-repeat";
        }
    }
    if (nodeStyle["box-shadow"] && nodeStyle["box-shadow"] != "" && nodeStyle["box-shadow"] != "none" && nodeStyle["box-shadow"] != "unset") {
        objData.shadow = nodeStyle["box-shadow"];
    } else if (parentNodeStyle && parentNodeStyle["box-shadow"] && parentNodeStyle["box-shadow"] != "" && parentNodeStyle["box-shadow"] != "none" && parentNodeStyle["box-shadow"] != "unset") {
        objData.shadow = parentNodeStyle["box-shadow"];
    }
    if (nodeItem && nodeStyle.objectFit) style["object-fit"] = nodeStyle.objectFit;
    if (nodeItem && nodeStyle.filter) style["filter"] = nodeStyle.filter;
    if (nodeItem && nodeStyle.clipPath) style["clip-path"] = nodeStyle.clipPath;
    if ((!style["clip-path"] && nodeParent) || (style["clip-path"] == "none" && nodeItem && nodeParent && window.getComputedStyle(nodeParent).clipPath)) style["clip-path"] = window.getComputedStyle(nodeParent).clipPath;

    // BG color not taken in some times from style so checking it here
    if (nodeStyle["background-color"] && nodeStyle["background-color"] != "" && nodeStyle["background-color"] != undefined && nodeStyle["background-color"] != "none" && nodeStyle["background-color"] != "transparent" && !style["background-color"]) {
        style["background-color"] = nodeStyle["background-color"];
    }

    let isSlideParent = nodeParent?.hasAttribute("data-type") && nodeParent?.getAttribute("data-type") == "SLIDE";
    if (!isSlideParent) isSlideParent = nodeParent?.parentElement?.hasAttribute("data-type") && nodeParent?.parentElement?.getAttribute("data-type") == "SLIDE";
    if (!isSlideParent && (!style["transform"] || style["transform"] == "scale(1)" || style["transform"] == "" || style["transform"] == "none") && nodeParent) {
        let parentStyle = window.getComputedStyle(nodeParent.parentElement);
        style["transform"] = parentStyle.transform;
        let matrixValue = this.updateTransformData(parentStyle);
        if (matrixValue) style["transform"] = matrixValue;
        style["transform-origin"] = nodeParent.parentElement.style.transformOrigin;
        if ((!style["transform"] || style["transform"] == "scale(1)" || style["transform"] == "" || style["transform"] == "none") && nodeParent.parentElement) {
            parentStyle = window.getComputedStyle(nodeParent.parentElement.parentElement);
            style["transform"] = parentStyle.transform;
            matrixValue = this.updateTransformData(parentStyle);
            if (matrixValue) style["transform"] = matrixValue;
            style["transform-origin"] = nodeParent.parentElement.style.transformOrigin;
        }
    }
    if (style["transform-origin-x"] == "" && style["transform-origin-y"] == "" && style["transform-origin-z"] == "") {
        let to = window.getComputedStyle(nodeItem)["-webkit-transform-origin"];
        style["transform-origin"] = to;
        delete style["transform-origin-x"];
        delete style["transform-origin-y"];
        delete style["transform-origin-z"];
    }
    style = ExportUtils.removeEmptyItems(style);
    return style;
};

ExportUtils.updateTransformData = function (computedStyle, style) {
    if (computedStyle) {
        const transformValue = computedStyle.transform || computedStyle.webkitTransform;
        if (transformValue == "none" || transformValue == "" || transformValue == "unset") return;
        if (transformValue == "matrix(-1, 0, 0, 1, 0, 0)" || transformValue == "matrix(1, 0, 0, -1, 0, 0)") return transformValue;
        let values = transformValue.match(/-?[\d.]+/g);
        var a = parseFloat(values[0]);
        var b = parseFloat(values[1]);
        var c = parseFloat(values[2]);
        var d = parseFloat(values[3]);

        if (((a == 1 && b == 0 && d == 1 && c != 0 && c != 1) || (a == 1 && c == 0 && d == 1 && b != 0 && b != 1)) && style) {
            style["transform-origin"] = "left top";
            style["origincheck"] = "true";
            return transformValue;
        }

        var scaleX = Math.sqrt(a * a + b * b);
        var scaleY = Math.sqrt(c * c + d * d);
        var rotationInRadians = Math.atan2(b, a);
        var rotationInDegrees = rotationInRadians * (180 / Math.PI);
        if (rotationInDegrees == 0) {
            scaleX = parseFloat(values[0]);
            var scaleY = parseFloat(values[3]);
        }

        // Get the matrix as a string for use in CSS
        let matrixValue = "scaleX(" + scaleX + ")" + " scaleY(" + scaleY + ")" + (rotationInDegrees ? " rotate(" + rotationInDegrees + "deg)" : "");
        return matrixValue;
    } else null;
};

ExportUtils.getChildSVGData = function (iconNode, parentNode, parentID, name = "IMAGE", svgDefsLocal, mainSVG, staticServerURL) {
    iconNode.classList.add("pptxnoanimation");
    let objData = { type: "image", name: name, description: "getSVGData - Plain SVG without use node" };
    let svgNode = iconNode.cloneNode(true);
    if (svgDefsLocal) svgNode.appendChild(svgDefsLocal.cloneNode(true));

    try {
        let iconStyleValue = window.getComputedStyle(iconNode);
        svgNode.style.setProperty("--icon-color", iconStyleValue.getPropertyValue("--icon-color").trim());
        svgNode.style.setProperty("--icon-color-rgb", iconStyleValue.getPropertyValue("--icon-color-rgb").trim());
        svgNode.style.setProperty("--icon-opacity", iconStyleValue.getPropertyValue("--icon-opacity").trim());
        svgNode.style.setProperty("--icondual1-opacity", iconStyleValue.getPropertyValue("--icondual1-opacity").trim());
        svgNode.style.setProperty("--icondual1-color-rgb", iconStyleValue.getPropertyValue("--icondual1-color-rgb").trim());
        svgNode.style.setProperty("--iconsec-color-rgb", iconStyleValue.getPropertyValue("--iconsec-color-rgb").trim());
    } catch (error) {}

    let arrSVGNodes = iconNode.querySelectorAll("circle,ellipse,line,path,polygon,polyline,rect,stop,text,div");
    let arrCloneSVGNodes = svgNode.querySelectorAll("circle,ellipse,line,path,polygon,polyline,rect,stop,text,div");

    let arrPointNodes = iconNode.querySelectorAll("[id*='-point']");
    let arrClonePointNodes = svgNode.querySelectorAll("[id*='-point']");

    for (let a = 0; a < arrClonePointNodes.length; a++) {
        let styleNode = window.getComputedStyle(arrPointNodes[a]);
        if (styleNode["filter"] != "" && styleNode["filter"] != "none" && styleNode["filter"] != "unset") {
            arrClonePointNodes[a].setAttribute("filter", styleNode["filter"]);
            arrClonePointNodes[a].style.filter = styleNode["filter"];
        }
    }

    if (arrSVGNodes.length > 0) {
        for (let i = 0; i < arrSVGNodes.length; i++) {
            let style = window.getComputedStyle(arrSVGNodes[i]);
            let isElemenetNotVisible = style["display"] == "none" || arrSVGNodes[i].style.display == "none" || style.visibility == "hidden";
            if (arrSVGNodes[i].tagName == "DIV") {
                arrCloneSVGNodes[i].style.color = style.color;
                arrCloneSVGNodes[i].style.backgroundColor = style.backgroundColor;
                arrCloneSVGNodes[i].style.fontSize = style.fontSize;
                arrCloneSVGNodes[i].style.fontFamily = style.fontFamily;
                arrCloneSVGNodes[i].style.fontWeight = style.fontWeight;
                arrCloneSVGNodes[i].style.fontStyle = style.fontStyle;
                arrCloneSVGNodes[i].style.textAlign = style.textAlign;
                arrCloneSVGNodes[i].style.textDecoration = style.textDecoration;
                arrCloneSVGNodes[i].style.textTransform = style.textTransform;
                arrCloneSVGNodes[i].style.lineHeight = style.lineHeight;
                arrCloneSVGNodes[i].style.letterSpacing = style.letterSpacing;
                arrCloneSVGNodes[i].style.padding = style.padding;
                arrCloneSVGNodes[i].style.margin = style.margin;
                arrCloneSVGNodes[i].style.border = style.border;
                arrCloneSVGNodes[i].style.borderRadius = style.borderRadius;
                arrCloneSVGNodes[i].style.boxShadow = style.boxShadow;
                arrCloneSVGNodes[i].style.textShadow = style.textShadow;
                arrCloneSVGNodes[i].style.textOverflow = style.textOverflow;
                arrCloneSVGNodes[i].style.overflow = style.overflow;
                arrCloneSVGNodes[i].style.opacity = style.opacity;
            } else {
                if (style.visibility == "hidden") arrCloneSVGNodes[i].style.visibility = "hidden";
                if (arrSVGNodes[i].parentElement.tagName != "symbol") {
                    arrCloneSVGNodes[i].setAttribute("fill", isElemenetNotVisible ? "none" : style["fill"]);
                    arrCloneSVGNodes[i].style.setProperty("fill", isElemenetNotVisible ? "none" : style["fill"]);
                    arrCloneSVGNodes[i].setAttribute("stroke", isElemenetNotVisible ? "none" : style["stroke"]);
                    if (arrCloneSVGNodes[i].hasAttribute("fill") && arrCloneSVGNodes[i].getAttribute("fill") != "none" && !isElemenetNotVisible) arrCloneSVGNodes[i].style.fill = style["fill"];
                    if (arrCloneSVGNodes[i].hasAttribute("stroke") && arrCloneSVGNodes[i].getAttribute("stroke") != "none" && !isElemenetNotVisible) arrCloneSVGNodes[i].style.stroke = style["stroke"];
                    if (style["filter"] != "" && style["filter"] != "none" && style["filter"] != "unset") {
                        arrCloneSVGNodes[i].setAttribute("filter", style["filter"]);
                        arrCloneSVGNodes[i].style.filter = style["filter"];
                    }
                    arrCloneSVGNodes[i].setAttribute("fill-opacity", style["fill-opacity"]);
                    arrCloneSVGNodes[i].setAttribute("opacity", isElemenetNotVisible ? 0 : style["opacity"]);
                    arrCloneSVGNodes[i].setAttribute("stroke-opacity", isElemenetNotVisible ? 0 : style["stroke-opacity"]);
                    if (!isElemenetNotVisible) {
                        arrCloneSVGNodes[i].setAttribute("r", style["r"]);
                        arrCloneSVGNodes[i].style["r"] = style["r"];
                        arrCloneSVGNodes[i].setAttribute("stroke-width", style["stroke-width"]);
                        arrCloneSVGNodes[i].style["stroke-width"] = style["stroke-width"];
                        arrCloneSVGNodes[i].style["stop-color"] = style["stop-color"];
                        arrCloneSVGNodes[i].style["stop-opacity"] = style["stop-opacity"];
                    }
                }
            }
            if (arrSVGNodes[i].parentElement.tagName != "symbol") {
                arrCloneSVGNodes[i].setAttribute("width", isElemenetNotVisible ? 0 : style["width"]);
                arrCloneSVGNodes[i].setAttribute("height", isElemenetNotVisible ? 0 : style["height"]);
            } else {
                let pID = arrSVGNodes[i].parentElement.id.replace("-shape");
                let arrUseNode = parentNode.querySelectorAll("use[*|href='#" + pID + "']");
                if (arrUseNode && !isElemenetNotVisible) {
                    for (let a = 0; a < arrUseNode.length; a++) {
                        let useNode = arrUseNode[a];
                        let useStyle = window.getComputedStyle(useNode);
                        let hasFill = arrCloneSVGNodes[i].hasAttribute("fill");
                        let hasStroke = arrCloneSVGNodes[i].hasAttribute("stroke");
                        if (!hasFill || (hasFill && arrCloneSVGNodes[i].getAttribute("fill") == "")) arrCloneSVGNodes[i].setAttribute("fill", useStyle["fill"]);
                        if (!hasStroke || (hasStroke && arrCloneSVGNodes[i].getAttribute("stroke") == "")) arrCloneSVGNodes[i].setAttribute("stroke", useStyle["stroke"]);
                    }
                }
            }
            if (arrSVGNodes[i].parentElement.tagName != "symbol") {
                if (style["stroke-dasharray"]) arrCloneSVGNodes[i].setAttribute("stroke-dasharray", style["stroke-dasharray"]);
                arrCloneSVGNodes[i].setAttribute("stroke-width", isElemenetNotVisible ? 0 : style["stroke-width"]);
                if (style["stroke-linejoin"]) arrCloneSVGNodes[i].setAttribute("stroke-linejoin", style["stroke-linejoin"]);
                if (style["stroke-linecap"]) arrCloneSVGNodes[i].setAttribute("stroke-linecap", style["stroke-linecap"]);
                if (style["stop-color"]) arrCloneSVGNodes[i].setAttribute("stop-color", style["stop-color"]);
                if (style["transform"] && style["transform"] != "none") arrCloneSVGNodes[i].setAttribute("transform", style["transform"]);
            }
        }
    }

    let finalArray = svgNode.querySelectorAll("[*|href*='#'],[*|href*='assets/'],[marker-start*='url'],[marker-end*='url'],[stroke*='url']");
    for (let a = 0; a < finalArray.length; a++) {
        for (let b = 0; b < 4; b++) {
            let attri = b == 0 ? "xlink:href" : b == 1 ? "marker-start" : b == 3 ? "stroke" : "marker-end";
            if (finalArray[a].hasAttribute(attri)) {
                let hrefId = finalArray[a].getAttribute(attri).replace("url(#", "").replace('url("#', "").replace('")', "").replace(")", "").replace("#", "");
                let hrefNode = svgNode.querySelector("[id='" + hrefId + "']");
                if (!hrefNode && document.getElementById(hrefId)) {
                    let cloningNode = document.getElementById(hrefId);
                    let clonnedNode = cloningNode.cloneNode(true);

                    let isUseNode = finalArray[a].tagName.toLowerCase() == "use";
                    let useStyle = window.getComputedStyle(isUseNode ? finalArray[a] : cloningNode);
                    if (isUseNode) {
                        // let hRef = finalArray[a].getAttribute("xlink:href");
                        // let foundedNode = parentNode.querySelector("[*|href*='" + hRef + "']");
                        // if (foundedNode) {
                        //     let foundedNodeStyle = window.getComputedStyle(foundedNode);
                        //     clonnedNode.setAttribute("fill", foundedNodeStyle.fill);
                        //     clonnedNode.setAttribute("stroke", foundedNodeStyle.stroke);
                        // }
                    } else {
                        if (useStyle["fill"] != "rgb(0, 0, 0)") clonnedNode.setAttribute("fill", useStyle["fill"]);
                        if (useStyle["stroke"] != "rgb(0, 0, 0)") clonnedNode.setAttribute("stroke", useStyle["stroke"]);

                        let arrSVGNodes = cloningNode.querySelectorAll("circle,ellipse,line,path,polygon,polyline,rect,stop,text");
                        let arrCloneSVGNodes = clonnedNode.querySelectorAll("circle,ellipse,line,path,polygon,polyline,rect,stop,text");
                        if (arrSVGNodes.length > 0) {
                            for (let i = 0; i < arrSVGNodes.length; i++) {
                                let style = window.getComputedStyle(arrSVGNodes[i]);
                                let isElemenetNotVisible = style["display"] == "none" || arrSVGNodes[i].style.display == "none" || style.visibility == "hidden";
                                if (style.visibility == "hidden") arrCloneSVGNodes[i].style.visibility = "hidden";
                                if (arrSVGNodes[i].parentElement.tagName != "symbol") {
                                    arrCloneSVGNodes[i].setAttribute("fill", isElemenetNotVisible ? "none" : style["fill"]);
                                    arrCloneSVGNodes[i].setAttribute("stroke", isElemenetNotVisible ? "none" : style["stroke"]);
                                    if (arrCloneSVGNodes[i].hasAttribute("fill") && arrCloneSVGNodes[i].getAttribute("fill") != "none" && !isElemenetNotVisible) arrCloneSVGNodes[i].style.fill = style["fill"];
                                    if (arrCloneSVGNodes[i].hasAttribute("stroke") && arrCloneSVGNodes[i].getAttribute("stroke") != "none" && !isElemenetNotVisible) arrCloneSVGNodes[i].style.stroke = style["stroke"];
                                    if (style["filter"] != "" && style["filter"] != "none" && style["filter"] != "unset") arrCloneSVGNodes[i].setAttribute("filter", style["filter"]);
                                    arrCloneSVGNodes[i].setAttribute("fill-opacity", style["fill-opacity"]);
                                    arrCloneSVGNodes[i].setAttribute("opacity", isElemenetNotVisible ? 0 : style["opacity"]);
                                    arrCloneSVGNodes[i].setAttribute("stroke-opacity", isElemenetNotVisible ? 0 : style["stroke-opacity"]);
                                    if (!isElemenetNotVisible) {
                                        arrCloneSVGNodes[i].setAttribute("r", style["r"]);
                                        arrCloneSVGNodes[i].style["r"] = style["r"];
                                        arrCloneSVGNodes[i].setAttribute("stroke-width", style["stroke-width"]);
                                        arrCloneSVGNodes[i].style["stroke-width"] = style["stroke-width"];
                                        arrCloneSVGNodes[i].style["stop-color"] = style["stop-color"];
                                        arrCloneSVGNodes[i].style["stop-opacity"] = style["stop-opacity"];
                                    }
                                }
                                if (arrSVGNodes[i].parentElement.tagName != "symbol") {
                                    arrCloneSVGNodes[i].setAttribute("width", isElemenetNotVisible ? 0 : style["width"]);
                                    arrCloneSVGNodes[i].setAttribute("height", isElemenetNotVisible ? 0 : style["height"]);
                                } else {
                                    let pID = arrSVGNodes[i].parentElement.id.replace("-shape");
                                    let arrUseNode = parentNode.querySelectorAll("use[*|href='#" + pID + "']");
                                    if (arrUseNode && !isElemenetNotVisible) {
                                        for (let a = 0; a < arrUseNode.length; a++) {
                                            let useNode = arrUseNode[a];
                                            let useStyle = window.getComputedStyle(useNode);
                                            let hasFill = arrCloneSVGNodes[i].hasAttribute("fill");
                                            let hasStroke = arrCloneSVGNodes[i].hasAttribute("stroke");
                                            if (!hasFill || (hasFill && arrCloneSVGNodes[i].getAttribute("fill") == "")) arrCloneSVGNodes[i].setAttribute("fill", useStyle["fill"]);
                                            if (!hasStroke || (hasStroke && arrCloneSVGNodes[i].getAttribute("stroke") == "")) arrCloneSVGNodes[i].setAttribute("stroke", useStyle["stroke"]);
                                        }
                                    }
                                }
                                if (arrSVGNodes[i].parentElement.tagName != "symbol") {
                                    if (style["stroke-dasharray"]) arrCloneSVGNodes[i].setAttribute("stroke-dasharray", style["stroke-dasharray"]);
                                    arrCloneSVGNodes[i].setAttribute("stroke-width", isElemenetNotVisible ? 0 : style["stroke-width"]);
                                    if (style["stroke-linejoin"]) arrCloneSVGNodes[i].setAttribute("stroke-linejoin", style["stroke-linejoin"]);
                                    if (style["stroke-linecap"]) arrCloneSVGNodes[i].setAttribute("stroke-linecap", style["stroke-linecap"]);
                                    if (style["stop-color"]) arrCloneSVGNodes[i].setAttribute("stop-color", style["stop-color"]);
                                    if (style["transform"] && style["transform"] != "none") arrCloneSVGNodes[i].setAttribute("transform", style["transform"]);
                                }
                            }
                        }
                    }

                    for (let c = 0; c < cloningNode.children.length; c++) {
                        useStyle = window.getComputedStyle(cloningNode.children[c]);
                        let fillValue = useStyle["fill"];
                        let strokeValue = useStyle["stroke"];
                        if (fillValue == "none" && finalArray[a].style.fill != "none") fillValue = finalArray[a].style.fill;
                        if (strokeValue == "none" && finalArray[a].style.stroke != "none") strokeValue = finalArray[a].style.stroke;
                        if (fillValue != "rgb(0, 0, 0)") clonnedNode.children[c].setAttribute("fill", fillValue);
                        if (strokeValue != "rgb(0, 0, 0)" && strokeValue != "none" && fillValue == "none") clonnedNode.children[c].setAttribute("stroke", strokeValue);
                    }
                    if (svgNode.getElementsByTagName("defs").length == 0) svgNode.appendChild(document.createElement("defs"));
                    svgNode.getElementsByTagName("defs")[0].appendChild(clonnedNode);
                }
            }
        }
    }

    let arrImageNodesG = iconNode.querySelectorAll("image");
    let arrCloneImageNodesG = svgNode.querySelectorAll("image");
    if (staticServerURL && arrImageNodesG.length > 0) {
        for (let i = 0; i < arrImageNodesG.length; i++) {
            if (arrImageNodesG[i].hasAttribute("xlink:href") && !arrImageNodesG[i].getAttribute("xlink:href").includes(staticServerURL) && !arrImageNodesG[i].getAttribute("xlink:href").startsWith("http")) arrCloneImageNodesG[i].setAttribute("xlink:href", staticServerURL + arrImageNodesG[i].getAttribute("xlink:href"));
        }
    }

    let coords = ExportUtils.getCoordsXY(parentNode, parentID, iconNode);
    try {
        if (iconNode.parentElement?.getAttribute("type") == "lottie" && iconNode.parentElement?.hasAttribute("path") && window.isOrigamiPPTX) {
            coords.width = iconNode.parentElement.offsetWidth;
            coords.height = iconNode.parentElement.offsetHeight;
        } else {
            coords.width = iconNode.width?.baseVal?.value || 0;
            coords.height = iconNode.height?.baseVal?.value || 0;
        }
    } catch (error) {
        coords.width = 0;
        coords.height = 0;
    }

    let bbox = null;
    try {
        if (iconNode?.parentElement?.id?.includes("nodeBackgound") && iconNode?.dataset?.id?.includes("bgsvgNode")) {
            bbox = iconNode.getBBox();
        }
    } catch (error) {}

    if (bbox?.width && bbox?.height) {
        coords.width = bbox.width;
        coords.height = bbox.height;
    }

    try {
        let f = navigator.userAgent.search("Firefox");
        if (f > -1) {
            let iconStyle = window.getComputedStyle(iconNode);
            let iconW = parseFloat(iconStyle.width);
            let iconH = parseFloat(iconStyle.height);
            coords.width = !isNaN(iconW) && iconW > 0 ? iconW : iconNode.parentElement.offsetWidth;
            coords.height = !isNaN(iconH) && iconH > 0 ? iconH : iconNode.parentElement.offsetHeight;
        }
    } catch (error) {}

    svgNode.style.width = coords.width + "px";
    svgNode.style.height = coords.height + "px";

    svgNode.removeAttribute("data-node-graphic-text");
    let xmlData = new XMLSerializer().serializeToString(svgNode);

    if (coords.width == 0 && parentNode && iconNode.width?.baseVal?.valueAsString?.includes("%")) coords.width = parentNode.offsetWidth;
    if (coords.height == 0 && parentNode && iconNode.height?.baseVal?.valueAsString?.includes("%")) coords.height = parentNode.offsetHeight;

    if (coords.x >= this.slideWidth) coords.width = 0;
    if (coords.y >= this.slideHeight) coords.height = 0;
    objData.coords = [coords.x, coords.y, coords.width, coords.height].toString().replace(/,/g, " ");
    try {
        objData.svg = window.btoa(xmlData);
    } catch (error) {
        console.log("SG - IMPORTANT - XML parse error while Export", error);
        return null;
    }
    let parentNodeStyle = window.getComputedStyle(parentNode);
    let iconStyle = window.getComputedStyle(iconNode);
    ExportUtils.updateMiniStyleData(objData, parentNodeStyle, false, iconStyle, null, "inner-style");
    objData["inner-style"]["width"] = coords.width + "px";
    objData["inner-style"]["height"] = coords.height + "px";

    delete objData["inner-style"]["-webkit-mask-image"];
    delete objData["inner-style"]["-webkit-mask-position"];
    delete objData["inner-style"]["-webkit-mask-repeat"];
    delete objData["inner-style"]["-webkit-mask-size"];

    let centerSymbol = iconNode?.querySelector("[data-name='center']");
    if (centerSymbol) objData.nineScale = "true";

    objData["buffer-style"] = {
        width: coords.width + "px",
        height: coords.height + "px",
        position: "absolute",
        overflow: "hidden",
    };

    let type = "buffer-style";
    if (!objData[type].transform || !objData[type].transform == "" || !objData[type].transform == "none" || !objData[type].transform == "unset" || !objData[type].transform == "scale(1)") {
        let parentNodeStyle = window.getComputedStyle(parentNode);
        let isShapePoint = parentNode.parentElement.getAttribute("data-id") == "shapepoint";
        if ((!parentNodeStyle.transform || parentNodeStyle.transform == "" || parentNodeStyle.transform == "none" || parentNodeStyle.transform == "unset" || parentNodeStyle.transform == "scale(1)" || parentNodeStyle.transform == "matrix(1, 0, 0, 1, 0, 0)") && parentNode.parentElement && !isShapePoint)
            parentNodeStyle = window.getComputedStyle(parentNode.parentElement);
        let matrixValue = this.updateTransformData(parentNodeStyle);
        if (matrixValue) {
            objData[type].transform = matrixValue;
            let halfValX = parseFloat(objData["buffer-style"].width) / 2;
            let halfValY = parseFloat(objData["buffer-style"].height) / 2;
            let isCenterX = parentNodeStyle.transformOrigin.split(" ").includes(halfValX + "px");
            let isCenterY = parentNodeStyle.transformOrigin.split(" ").includes(halfValY + "px");
            let isScaled = false;
            const regex = /scaleX\(([^)]+)\) scaleY\(([^)]+)\)/;
            const matches = objData["buffer-style"].transform?.includes("scaleX") ? objData["buffer-style"].transform.match(regex) : objData["inner-style"].transform?.includes("scaleX") ? objData["inner-style"].transform?.match(regex) : null;
            if (matches) {
                const scaleXValue = parseFloat(matches[1]);
                const scaleYValue = parseFloat(matches[2]);
                isScaled = scaleYValue.toFixed(2) != 1.0 && scaleXValue.toFixed(2) != 1.0;
                let arrCoords = objData.coords.split(" ");
                if (scaleXValue != 1 && scaleXValue > 0) {
                    arrCoords[2] = parseFloat(arrCoords[2]) * scaleXValue;
                    // objData.coords = arrCoords.join(" ");
                    // objData["buffer-style"]["width"] = arrCoords[2] + "px";
                }
                if (scaleYValue != 1 && scaleYValue > 0) {
                    arrCoords[3] = parseFloat(arrCoords[3]) * scaleYValue;
                    // objData.coords = arrCoords.join(" ");
                    // objData["buffer-style"]["height"] = arrCoords[3] + "px";
                }
            }
            if (!isScaled && (isCenterX || isCenterY)) objData[type]["transform-origin"] = "center";
            else objData[type]["transform-origin"] = "left top";
            // } else {
            //     const regex = /scaleX\(([^)]+)\) scaleY\(([^)]+)\)/;
            //     const matches = objData["inner-style"]?.transform?.includes("scaleX") ? objData["inner-style"].transform.match(regex) : null;
            //     if (matches) {
            //         const scaleXValue = parseFloat(matches[1]);
            //         const scaleYValue = parseFloat(matches[2]);
            //         let arrCoords = objData.coords.split(" ");
            //         if (scaleXValue != 1 && scaleXValue > 0) {
            //             arrCoords[2] = parseFloat(arrCoords[2]) * scaleXValue;
            //             objData.coords = arrCoords.join(" ");
            //             objData["buffer-style"]["width"] = arrCoords[2] + "px";
            //             objData["inner-style"]["width"] = arrCoords[2] + "px";
            //             delete objData["inner-style"].transform;
            //         }
            //         if (scaleYValue != 1 && scaleYValue > 0) {
            //             arrCoords[3] = parseFloat(arrCoords[3]) * scaleYValue;
            //             objData.coords = arrCoords.join(" ");
            //             objData["buffer-style"]["height"] = arrCoords[3] + "px";
            //             objData["inner-style"]["height"] = arrCoords[3] + "px";
            //             delete objData["inner-style"].transform;
            //         }
            //     }
        }
    }
    if (objData["buffer-style"]["transform"] == objData["inner-style"]["transform"]) delete objData["buffer-style"]["transform"];

    if (mainSVG) {
        let svgIconStyle = window.getComputedStyle(mainSVG);
        if (svgIconStyle["filter"] && svgIconStyle["filter"] != undefined) objData["inner-style"]["filter"] = svgIconStyle["filter"];
        if (objData["inner-style"]?.["filter"] == "none") delete objData["inner-style"]["filter"];
    }
    if (objData["inner-style"]?.["transform"] == "matrix(1, 0, 0, 0, 0, 0)") objData.coords = "0 0 0 0";
    let arrCoords = objData.coords.split(" ");
    if (parseFloat(arrCoords[0]) + parseFloat(arrCoords[2]) <= 0 || parseFloat(arrCoords[1]) + parseFloat(arrCoords[3]) <= 0 || parseFloat(arrCoords[0]) > this.slideWidth || parseFloat(arrCoords[1]) > this.slideHeight) return null;

    if (iconNode.parentElement?.getAttribute("type") == "lottie" && iconNode.parentElement?.hasAttribute("path") && window.isOrigamiPPTX) {
        objData.type = "lottie";
        objData.path = iconNode.parentElement?.getAttribute("path");
        objData.bufferStyle = { transform: "scale(1) rotate(0deg)" };
    }

    return objData;
};

ExportUtils.setTransfromOriginForImage = function (objData) {
    try {
        let halfValX = parseFloat(objData["buffer-style"].width) / 2;
        let halfValY = parseFloat(objData["buffer-style"].height) / 2;
        let transOrigin = objData["inner-style"].transformOrigin || objData["inner-style"]["transform-origin"] || "left top";
        let isCenterX = transOrigin.split(" ").includes(halfValX + "px");
        let isCenterY = transOrigin.split(" ").includes(halfValY + "px");
        let isScaled = false;
        const regex = /scaleX\(([^)]+)\) scaleY\(([^)]+)\)/;
        const matches = objData["inner-style"].transform.includes("scaleX") ? objData["inner-style"].transform.match(regex) : null;
        if (matches) {
            const scaleXValue = parseFloat(matches[1]);
            const scaleYValue = parseFloat(matches[2]);
            isScaled = scaleYValue.toFixed(2) != 1.0 && scaleXValue.toFixed(2) != 1.0;
        }
        if (!isScaled && (isCenterX || isCenterY)) objData["inner-style"]["transform-origin"] = "center";
        else if (objData["inner-style"]["transform-origin"]?.includes("px")) objData["inner-style"]["transform-origin"] = objData["inner-style"]["transform-origin"];
        else objData["inner-style"]["transform-origin"] = "left top";
    } catch (error) {}
};

ExportUtils.getIconWithUseData = function (iconNode, parentNode, parentID, name = "IMAGE", iconPadding) {
    let mainSVG = iconNode.cloneNode(true);
    let allUses = mainSVG.querySelectorAll("use");
    allUses.forEach((useNode) => {
        let usePath = useNode.getAttribute("xlink:href");
        if (usePath) {
            let useMainNode = document.getElementById(usePath.replace("#", "").cloneNode(true));
            console.log(useMainNode);
        } else {
            console.log(useNode);
        }
    });

    let objData = { type: "image", name: name, description: "getIconData -applyIconColor - ICON SVG with use node" };

    ExportUtils.applyIconColor(styleData, cloneUseNode, actualUseNode, useNode);
    let xmlData = new XMLSerializer().serializeToString(cloneUseNode);
    let coords = ExportUtils.getCoordsXY(iconNode.parentElement, parentID);
    coords.width = iconNode.width.baseVal.value;
    coords.height = iconNode.height.baseVal.value;
    coords.x = coords.x + (iconNode.parentElement.offsetWidth - iconNode.width.baseVal.value) / 2;
    coords.y = coords.y + (iconNode.parentElement.offsetHeight - iconNode.height.baseVal.value) / 2;
    objData.coords = [coords.x, coords.y, coords.width, coords.height].toString().replace(/,/g, " ");
    objData.svg = window.btoa(xmlData);
    ExportUtils.updateMiniStyleData(objData, styleData);
    return objData;
};

ExportUtils.applyIconColor = function (styleData, clonedUseNode, actualUseNode, useNode) {
    let arrIllus = clonedUseNode.querySelectorAll("[class='illustration1'],[class='illustration2'],[class='illustration3'],[class='illustration4']");
    if (arrIllus.length > 0) {
        let objColor = {};
        objColor.illustration1 = DiagramNodeUtils.hexToRGB(styleData.getPropertyValue("--item1-color").replace(/\s/g, "")) || { r: 255, g: 255, b: 255 };
        objColor.illustration2 = DiagramNodeUtils.hexToRGB(styleData.getPropertyValue("--secondary-color").replace(/\s/g, "")) || { r: 255, g: 255, b: 255 };
        objColor.illustration3 = DiagramNodeUtils.hexToRGB(styleData.getPropertyValue("--contrast-color").replace(/\s/g, "")) || { r: 255, g: 255, b: 255 };
        objColor.illustration4 = DiagramNodeUtils.hexToRGB(styleData.getPropertyValue("--bg-color").replace(/\s/g, "")) || { r: 255, g: 255, b: 255 };
        for (let i = 0; i < arrIllus.length; i++) {
            let className = arrIllus[i].getAttribute("class");
            let colorItems = objColor[className];
            let illusColor = "rgb(" + colorItems.r + "," + colorItems.g + "," + colorItems.b + ")";
            if (!!colorItems.a) {
                illusColor = "rgba(" + colorItems.r + "," + colorItems.g + "," + colorItems.b + "," + colorItems.a + ")";
            }
            arrIllus[i].setAttribute("fill", illusColor);
        }
    } else {
        let className = useNode.className.baseVal;

        let colorValue = DiagramNodeUtils.hexToRGB(styleData.getPropertyValue("--icon-color").replace(/\s/g, "")) || { r: 255, g: 255, b: 255 };
        let opacity = styleData.getPropertyValue("--icon-opacity").replace(/\s/g, "");
        let icon2Color = "rgb(" + colorValue.r + "," + colorValue.g + "," + colorValue.b + ")";
        if (opacity && opacity != "" && opacity != "0" && opacity != 0) {
            icon2Color = "rgba(" + colorValue.r + "," + colorValue.g + "," + colorValue.b + "," + opacity + ")";
        }

        let arrDefault = clonedUseNode.querySelectorAll("path,rect,circle,polygon");
        let defaultFill = styleData["fill"];
        for (let i = 0; i < arrDefault.length; i++) {
            let pathItem = arrDefault[i];
            let fillNone = pathItem.getAttribute("fill") == "none";
            let strokeNone = pathItem.getAttribute("stroke") == "none";
            if (fillNone && !strokeNone) {
                pathItem.setAttribute("stroke", defaultFill);
            } else if (!fillNone && strokeNone) {
                pathItem.setAttribute("fill", defaultFill);
            }
        }

        let icon1Color = styleData.getPropertyValue("fill");
        let arrIcon1Path = className.includes("accent") ? actualUseNode.querySelectorAll("[class='icon2']") : actualUseNode.querySelectorAll("[class='icon1']");
        let arrIcon2Path = className.includes("accent") ? actualUseNode.querySelectorAll("[class='icon1']") : actualUseNode.querySelectorAll("[class='icon2']");

        for (let i = 0; i < arrIcon1Path.length; i++) {
            let pathItem = arrIcon1Path[i];
            let fillNone = pathItem.getAttribute("fill") == "none";
            let strokeNone = pathItem.getAttribute("stroke") == "none";
            if (fillNone && !strokeNone) {
                pathItem.setAttribute("stroke", icon1Color);
            } else if (!fillNone && strokeNone) {
                pathItem.setAttribute("fill", icon1Color);
            }
        }

        for (let j = 0; j < arrIcon2Path.length; j++) {
            let pathItem = arrIcon2Path[j];
            let fillNone = pathItem.getAttribute("fill") == "none";
            let strokeNone = pathItem.getAttribute("stroke") == "none";
            if (fillNone && !strokeNone) {
                pathItem.setAttribute("stroke", icon2Color);
            } else if (!fillNone && strokeNone) {
                pathItem.setAttribute("fill", icon2Color);
            }
        }
    }
};

ExportUtils.getRectValue = function (contentNode, parentID, objName, arrElements, istextBg = false) {
    if (!contentNode || window.getComputedStyle(contentNode).opacity == 0 || window.getComputedStyle(contentNode).opacity == 0) return;
    let objData = { type: "drawing", description: "Rect Drawing", name: objName || "Rect", "drawing-type": "rect" };
    let styleData = window.getComputedStyle(contentNode);
    try {
        objData.coords = ExportUtils.getCoords(contentNode, parentID, false);
        objData.zindex = styleData.zIndex || 0;

        ExportUtils.updateBufferStyle(objData, styleData, contentNode, "inner-style");

        // update coords if border-width is present
        let bw = objData["inner-style"]?.["border-width"] || 0;
        bw = parseFloat(bw);
        if (!isNaN(bw) && bw > 0) {
            let arrCoords = objData.coords.split(" ");
            arrCoords[3] = parseFloat(arrCoords[3]) + bw;
            objData.coords = arrCoords.join(" ");
        }

        let parentNodeStyle = window.getComputedStyle(contentNode.parentElement);
        let matrix3D = styleData.transform?.includes("matrix3d") ? styleData.transform : parentNodeStyle.transform?.includes("matrix3d") ? parentNodeStyle.transform : null;
        // updating parent's mask image to inner style
        if (!objData["inner-style"]["-webkit-mask-image"]) {
            let maskValue = parentNodeStyle["-webkit-mask-image"];
            if (maskValue && maskValue != "none" && maskValue != "unset") {
                objData["inner-style"]["-webkit-mask-image"] = maskValue;
                objData["inner-style"]["-webkit-mask-size"] = parentNodeStyle["-webkit-mask-size"];
                objData["inner-style"]["-webkit-mask-repeat"] = parentNodeStyle["-webkit-mask-repeat"];
                objData["inner-style"]["-webkit-mask-position"] = parentNodeStyle["-webkit-mask-position"];
            }
        }
        // Border-radius from parent if not available in child
        if (!objData["inner-style"]["border-radius"]) {
            let borderRadius = parentNodeStyle["border-radius"];
            if (borderRadius && borderRadius != "none" && borderRadius != "unset") {
                objData["inner-style"]["border-radius"] = borderRadius;
            }
        }

        if (!objData["inner-style"]["-webkit-mask-image"]) {
            let maskValue = parentNodeStyle["-webkit-mask-image"];
            if (maskValue && maskValue != "none" && maskValue != "unset") {
                objData["inner-style"]["-webkit-mask-image"] = maskValue;
                objData["inner-style"]["-webkit-mask-size"] = parentNodeStyle["-webkit-mask-size"];
                objData["inner-style"]["-webkit-mask-repeat"] = parentNodeStyle["-webkit-mask-repeat"];
                objData["inner-style"]["-webkit-mask-position"] = parentNodeStyle["-webkit-mask-position"];
            }
        }

        objData["buffer-style"] = {
            width: "100%",
            height: "100%",
            position: "absolute",
            overflow: "hidden",
            left: "0px",
            top: "0px",
        };
        if (parentNodeStyle?.overflow == "visible") objData["buffer-style"]["overflow"] = parentNodeStyle.overflow;

        if (objData["inner-style"]["background-image"]?.includes("gradient")) {
            delete objData["inner-style"]["background"];
            if (window.isOrigamiPPTX) objData.colorlock = "true";
        }

        let type = "buffer-style";
        if (!objData[type].transform || !objData[type].transform == "" || !objData[type].transform == "none" || !objData[type].transform == "unset" || !objData[type].transform == "scale(1)") {
            if ((!parentNodeStyle.transform || parentNodeStyle.transform == "" || parentNodeStyle.transform == "none" || parentNodeStyle.transform == "unset" || parentNodeStyle.transform == "scale(1)" || parentNodeStyle.transform == "matrix(1, 0, 0, 1, 0, 0)") && contentNode.parentElement.parentElement)
                parentNodeStyle = window.getComputedStyle(contentNode.parentElement.parentElement);
            let matrixValue = this.updateTransformData(parentNodeStyle);
            if (matrixValue) {
                objData[type].transform = matrixValue;
                objData[type]["transform-origin"] = "left top";
            }
        }
        if (objData["buffer-style"]["transform"] == objData["inner-style"]["transform"]) delete objData["buffer-style"]["transform"];

        if (!objData["buffer-style"]["transform"]) {
            objData["buffer-style"]["transform"] = objData["inner-style"]["transform"];
            objData["buffer-style"]["transform-origin"] = objData["inner-style"]["transform-origin"];
            delete objData["inner-style"]["transform"];
            delete objData["inner-style"]["transform-origin"];
        }
        if (matrix3D) objData["buffer-style"]["transform"] = matrix3D;

        // ExportUtils.updateStyleData(objData, styleData, contentNode, "inner-style");
        // let coordsVal = objData.coords.split(" ");
        // ExportUtils.defaultBufferStyle(objData, styleData, { w: contentNode.offsetWidth, h: contentNode.offsetHeight }, contentNode);
    } catch (error) {
        console.log(error);
    }
    let safariBFcheck = styleData["-webkit-backdrop-filter"] != "none" && styleData["-webkit-backdrop-filter"] != "" && styleData["-webkit-backdrop-filter"] != "unset";
    if (safariBFcheck && styleData["backdrop-filter"] != "none" && styleData["backdrop-filter"] != "" && styleData["backdrop-filter"] != "unset") {
        if (objData["inner-style"]?.["background-color"]) {
            let bgC = objData["inner-style"]?.["background-color"];
            if (!bgC.includes("rgba(0, 0, 0, 0)")) {
                if (bgC.includes("rgba")) {
                    let rgbaValues = bgC.replace("rgba(", "").replace(")", "").split(",");
                    let newRgbaValue = "rgba(" + rgbaValues[0] + "," + rgbaValues[1] + "," + rgbaValues[2] + ",0.8)";
                    objData["inner-style"]["background-color"] = newRgbaValue;
                    objData["inner-style"]["background"] = newRgbaValue;
                } else if (bgC.includes("rgb")) {
                    let rgbValues = bgC.replace("rgb(", "").replace(")", "").split(",");
                    let newRgbaValue = "rgba(" + rgbValues[0] + "," + rgbValues[1] + "," + rgbValues[2] + ",0.8)";
                    objData["inner-style"]["background-color"] = newRgbaValue;
                    objData["inner-style"]["background"] = newRgbaValue;
                } else {
                    objData.opacity = 0.8;
                    objData.alpha = objData.opacity;
                }
            }
        }
    }
    if (objData.alpha != undefined && objData.alpha != null) {
        delete objData["inner-style"]["opacity"];
        delete objData["inner-style"]["alpha"];
    }
    if (objData["inner-style"]?.["transform"] == "matrix(1, 0, 0, 0, 0, 0)") objData.coords = "0 0 0 0";
    if (istextBg) {
        let hasBg = objData["inner-style"]["background-image"] && objData["inner-style"]["background-image"]?.includes("gradient");
        let textClip = styleData["-webkit-background-clip"] == "text" || styleData["background-clip"] == "text";
        if (hasBg && textClip) objData.coords = [0, 0, 0, 0].join(" ");
    }
    if (contentNode?.id == "TITLE" && contentNode.children.length > 0 && contentNode.querySelector("[class*='TITLEBG']")) {
        let titleBg = contentNode.querySelector("[class*='TITLEBG']");
        if (titleBg && window.getComputedStyle(titleBg).backgroundImage.includes("gradient")) {
            objData.coords = [0, 0, 0, 0].join(" ");
        }
    }
    objData["inner-style"] = ExportUtils.removeEmptyItems(objData["inner-style"]);
    if (objData["inner-style"]?.["border-width"] == "0px 1px 1px") {
        objData["inner-style"]["border-width"] = "1px";
        if (objData["inner-style"].height == "1px") {
            objData["inner-style"].height = "2px";
            objData.coords = objData.coords.replace(" 1", " 2");
        }
    }
    let arrCoords = objData.coords.split(" ");
    if (parseFloat(arrCoords[0]) + parseFloat(arrCoords[2]) <= 0 || parseFloat(arrCoords[1]) + parseFloat(arrCoords[3]) <= 0 || parseFloat(arrCoords[0]) > this.slideWidth || parseFloat(arrCoords[1]) > this.slideHeight) return null;
    ExportUtils.addStyleElement(arrElements, objData);
    return objData;
};

ExportUtils.updateStyleData = function (objData, styleData, contentNode, key = "style") {
    let takeparentStyle = key == "buffer-style" ? false : true;
    let style = {};
    if (styleData["box-shadow"] && styleData["box-shadow"] != "" && styleData["box-shadow"] != undefined) objData.shadow = styleData["box-shadow"];
    if (styleData["display"] && styleData["display"] != undefined) style["display"] = styleData["display"];
    if (style["display"] == "table-cell" || style["display"] == "table-row") style["display"] = "flex";
    if (styleData["border-radius"] && styleData["border-radius"] != "" && styleData["border-radius"] != undefined) {
        style["border-radius"] = styleData["border-radius"];
    } else if (contentNode && takeparentStyle) {
        let parentStyle = window.getComputedStyle(contentNode.parentElement).borderRadius;
        if (!!parentStyle) style["border-radius"] = parentStyle;
    }
    let hasBorder = styleData["border-width"] && styleData["border-width"] != "" && styleData["border-width"] != undefined && styleData["border-width"] != "0px";
    let hasOutline = styleData["outline-width"] && styleData["outline-width"] != "" && styleData["outline-width"] != undefined && styleData["outline-width"] != "0px";
    if (styleData["border-width"] && styleData["border-width"] != "" && styleData["border-width"] != undefined && styleData["border-width"] != "0px") {
        style["border-width"] = styleData["border-width"];
    }
    if (hasBorder && styleData["border-style"] && styleData["border-style"] != "" && styleData["border-style"] != undefined) {
        style["border-style"] = styleData["border-style"];
        if (style["border-style"].includes(" ") && style["border-style"].includes("solid")) style["border-style"] = "solid";
        else if (style["border-style"].includes(" ") && style["border-style"].includes("dashed")) style["border-style"] = "dashed";
        else if (style["border-style"].includes(" ") && style["border-style"].includes("dotted")) style["border-style"] = "dotted";
    }
    if (hasBorder && styleData["border-color"] && styleData["border-color"] != "" && styleData["border-color"] != undefined) {
        style["border-color"] = styleData["border-color"];
    }
    if (hasOutline && styleData["outline-width"] && styleData["outline-width"] != "" && styleData["outline-width"] != undefined && styleData["outline-width"] != "0px") {
        style["outline-width"] = styleData["outline-width"];
    }
    if (hasOutline && styleData["outline-style"] && styleData["outline-style"] != "" && styleData["outline-style"] != undefined) {
        style["outline-style"] = styleData["outline-style"];
    }
    if (hasOutline && styleData["outline-color"] && styleData["outline-color"] != "" && styleData["outline-color"] != undefined) {
        style["outline-color"] = styleData["outline-color"];
    }
    if (styleData["background-image"] && styleData["background-image"] != "" && styleData["background-image"] != undefined) {
        style["background-image"] = styleData["background-image"];
    }
    if (styleData["background-color"] && styleData["background-color"] != "" && styleData["background-color"] != undefined) {
        style["background-color"] = styleData["background-color"];
    }
    if (styleData["background"] && styleData["background"] != "" && styleData["background"] != undefined) {
        style["background"] = styleData["background"];
    }
    if (styleData["background-image"] && styleData["background-image"] != "" && styleData["background-image"] != undefined && styleData["background-image"].includes("gradient")) {
        style["background"] = styleData["background-image"];
    }
    if (styleData["background-size"] && styleData["background-size"] != "" && styleData["background-size"] != undefined) {
        style["background-size"] = styleData["background-size"];
    }
    if (styleData["background-position"] && styleData["background-position"] != "" && styleData["background-position"] != undefined) {
        style["background-position"] = styleData["background-position"];
    }
    if (styleData["transform"] && styleData["transform"] != "" && styleData["transform"] != undefined) {
        style["transform"] = styleData["transform"];
        let matrixValue = this.updateTransformData(styleData, style);
        if (matrixValue) style["transform"] = matrixValue;
    }
    if (!style["origincheck"] && styleData["transform-origin"] && styleData["transform-origin"] != undefined && styleData["transform-origin"] != "none" && styleData["transform-origin"] != "") {
        style["transform-origin"] = styleData["transform-origin"];
    }
    delete style["origincheck"];
    if ((styleData["transform"] == "none" || styleData["transform"] == "" || styleData["transform"] == "unset") && contentNode?.parentElement) {
        let pStyle = window.getComputedStyle(contentNode.parentElement);
        style["transform"] = pStyle["transform"];
        style["transform-origin"] = "left top";
        let matrixValue = this.updateTransformData(pStyle);
        if (matrixValue) style["transform"] = matrixValue;
    }
    if (styleData["filter"] && styleData["filter"] != "" && styleData["filter"] != undefined) {
        style["filter"] = styleData["filter"];
    }
    if (styleData["clip-path"] && styleData["clip-path"] != "" && styleData["clip-path"] != undefined) {
        style["clip-path"] = styleData["clip-path"];
    }
    if (styleData["opacity"] && styleData["opacity"] != "" && styleData["opacity"] != "0" && styleData["opacity"] != 0) {
        let opacityVal = styleData ? styleData["opacity"] : 1;
        if (contentNode?.parentElement && takeparentStyle) {
            let parentStyle = window.getComputedStyle(contentNode.parentElement);
            if ((opacityVal == 1 || opacityVal == "1") && !isNaN(parseFloat(parentStyle["opacity"])) && parseFloat(parentStyle["opacity"]) != 1) opacityVal = parseFloat(parentStyle["opacity"]);
        }
        if (opacityVal != 1 && opacityVal != "1") {
            style.opacity = opacityVal;
            style.alpha = opacityVal;
            objData.opacity = opacityVal;
            objData.alpha = objData.opacity;
        }
    }
    if (styleData["backdrop-filter"] && styleData["backdrop-filter"] != "" && styleData["backdrop-filter"] != undefined) {
        style["backdrop-filter"] = styleData["backdrop-filter"];
    }
    if (styleData["-webkit-mask-image"]) {
        style["-webkit-mask-image"] = styleData["-webkit-mask-image"];
        style["-webkit-mask-size"] = styleData["-webkit-mask-size"] || "100%";
        style["-webkit-mask-position"] = styleData["-webkit-mask-position"] || "center";
        style["-webkit-mask-repeat"] = styleData["-webkit-mask-repeat"] || "no-repeat";
    }
    style = ExportUtils.removeEmptyItems(style);
    objData[key] = style;
};

ExportUtils.updateMiniStyleData = function (objData, styleData, takeParentStyle = true, childStyle = null, element = null, key = "style") {
    let style = {};
    if (styleData["box-shadow"] && styleData["box-shadow"] != "" && styleData["box-shadow"] != undefined) {
        style["box-shadow"] = styleData["box-shadow"];
        objData.shadow = styleData["box-shadow"];
    }
    if (styleData["display"] && styleData["display"] != undefined) {
        style["display"] = styleData["display"];
    }
    if (style["display"] == "table-cell" || style["display"] == "table-row") style["display"] = "flex";
    if (takeParentStyle) {
        if (styleData["transform-origin"] && styleData["transform-origin"] != undefined) style["transform-origin"] = styleData["transform-origin"];
        if (styleData["transform"] && styleData["transform"] != undefined) {
            style["transform"] = styleData["transform"];
            let matrixValue = this.updateTransformData(styleData);
            if (matrixValue) style["transform"] = matrixValue;
            if (style["transform"] == "none" && childStyle) {
                if (childStyle["transform-origin"] && childStyle["transform-origin"] != undefined) style["transform-origin"] = childStyle["transform-origin"];
                if (childStyle["transform"] && childStyle["transform"] != undefined) {
                    style["transform"] = childStyle["transform"];
                    let matrixValue = this.updateTransformData(styleData);
                    if (matrixValue) style["transform"] = matrixValue;
                }
            }
        }
    } else if (childStyle) {
        if (childStyle["transform-origin"] && childStyle["transform-origin"] != undefined) style["transform-origin"] = childStyle["transform-origin"];
        if (childStyle["transform"] && childStyle["transform"] != undefined) {
            style["transform"] = childStyle["transform"];
            let matrixValue = this.updateTransformData(childStyle);
            if (matrixValue) style["transform"] = matrixValue;
        }
    }
    if (styleData["filter"] && styleData["filter"] != undefined) {
        style["filter"] = styleData["filter"];
    }
    if (styleData["text-shadow"] && styleData["text-shadow"] != undefined && styleData["text-shadow"] != "none") {
        style["text-shadow"] = styleData["text-shadow"];
    }
    if (styleData["-webkit-mask-image"]) {
        style["-webkit-mask-image"] = styleData["-webkit-mask-image"];
        style["-webkit-mask-size"] = styleData["-webkit-mask-size"] || "100%";
        style["-webkit-mask-position"] = styleData["-webkit-mask-position"] || "center";
        style["-webkit-mask-repeat"] = styleData["-webkit-mask-repeat"] || "no-repeat";
    }

    style = ExportUtils.removeEmptyItems(style);
    let opacityVal = childStyle ? childStyle["opacity"] : 1;
    if ((opacityVal == 1 || opacityVal == "1") && !isNaN(parseFloat(styleData["opacity"])) && parseFloat(styleData["opacity"]) != 1) opacityVal = parseFloat(styleData["opacity"]);
    if (element?.parentElement) {
        let parentStyle = window.getComputedStyle(element.parentElement);
        if ((opacityVal == 1 || opacityVal == "1") && !isNaN(parseFloat(parentStyle["opacity"])) && parseFloat(parentStyle["opacity"]) != 1) opacityVal = parseFloat(parentStyle["opacity"]);
    }
    if (opacityVal != 1 && opacityVal != "1") {
        objData.opacity = opacityVal;
        objData.alpha = opacityVal;
    }
    style = ExportUtils.removeEmptyItems(style);
    objData[key] = style;
};

ExportUtils.removeEmptyItems = function (style) {
    if (!style) return style;
    if (style["pointer-events"]) delete style["pointer-events"];
    if (style["transform"] == "none" || style["transform"] == "scale(1)" || style["transform"] == "") delete style["transform"];
    if (style["style"] == "normal") delete style["style"];

    if (style["left"] == "unset" || style["left"] == "" || style["left"] == "0%") delete style["left"];
    if (style["top"] == "unset" || style["top"] == "" || style["top"] == "0%") delete style["top"];
    if (style["right"] == "unset" || style["right"] == "" || style["right"] == "0%") delete style["right"];
    if (style["bottom"] == "unset" || style["bottom"] == "" || style["bottom"] == "0%") delete style["bottom"];

    if (style["margin-left"] == "unset" || style["margin-left"] == "" || style["margin-left"] == "0px" || style["margin-left"] == "0%") delete style["margin-left"];
    if (style["margin-top"] == "unset" || style["margin-top"] == "" || style["margin-top"] == "0px" || style["margin-top"] == "0%") delete style["margin-top"];
    if (style["margin-right"] == "unset" || style["margin-right"] == "" || style["margin-right"] == "0px" || style["margin-right"] == "0%") delete style["margin-right"];
    if (style["margin-bottom"] == "unset" || style["margin-bottom"] == "" || style["margin-bottom"] == "0px" || style["margin-bottom"] == "0%") delete style["margin-bottom"];

    if (style["padding-left"] == "unset" || style["padding-left"] == "" || style["padding-left"] == "0px" || style["padding-left"] == "0%") delete style["padding-left"];
    if (style["padding-top"] == "unset" || style["padding-top"] == "" || style["padding-top"] == "0px" || style["padding-top"] == "0%") delete style["padding-top"];
    if (style["padding-right"] == "unset" || style["padding-right"] == "" || style["padding-right"] == "0px" || style["padding-right"] == "0%") delete style["padding-right"];
    if (style["padding-bottom"] == "unset" || style["padding-bottom"] == "" || style["padding-bottom"] == "0px" || style["padding-bottom"] == "0%") delete style["padding-bottom"];

    if (style["box-shadow"] == "none") delete style["box-shadow"];
    if (style["x"] == "0px" || style["x"] == "0%") delete style["x"];
    if (style["y"] == "0px" || style["y"] == "0%") delete style["y"];
    if (style["filter"] == "none") delete style["filter"];
    if (style["clip-path"] == "none") delete style["clip-path"];
    if (style["transform-origin"] == "") delete style["transform-origin"];
    if (style["background-image"] == "none") delete style["background-image"];
    if (style["background-size"] == "auto") delete style["background-size"];
    if (style["background-position"] == "0% 0%") delete style["background-position"];
    if (style["column-count"] == "auto") delete style["column-count"];
    if (style["stretch"] == "100%") delete style["stretch"];
    if (style["opacity"] == "1" || style["opacity"] == null) delete style["opacity"];
    if (style["alpha"] == "1" || style["alpha"] == null) delete style["alpha"];
    if (style["backdrop-filter"] == "none") delete style["backdrop-filter"];
    if (style["border-radius"] == "0px") delete style["border-radius"];
    if (style["-webkit-mask-image"] == "none") {
        delete style["-webkit-mask-image"];
        delete style["-webkit-mask-position"];
        delete style["-webkit-mask-repeat"];
        delete style["-webkit-mask-size"];
    }
    if (style["transition-duration"] == "0s") {
        delete style["transition-duration"];
        delete style["transition-timing-function"];
        delete style["transition-delay"];
        delete style["transition-property"];
    }
    return style;
};

ExportUtils.getCoords = function (contentNode, parentID, isText) {
    let x = ExportUtils.calculatePosition(contentNode, parentID, "offsetLeft");
    let y = ExportUtils.calculatePosition(contentNode, parentID, "offsetTop");

    let moodParentDiv = document.getElementById("PPTXContainer");
    if (moodParentDiv && moodParentDiv?.querySelector("[id='" + parentID + "']")) {
        let slideDom = moodParentDiv.querySelector("[id='" + parentID + "']");
        let parentRect = slideDom.getBoundingClientRect();
        let childRect = contentNode.getBoundingClientRect();
        let parentTop = parentRect.top;
        let childTop = childRect.top;
        let parentLeft = parentRect.left;
        let childLeft = childRect.left;

        let computedStyle = window.getComputedStyle(contentNode);
        const transformValue = computedStyle.transform || computedStyle.webkitTransform;
        if (transformValue != "none" && transformValue != "" && transformValue != "unset") {
            let values = transformValue.match(/-?[\d.]+/g);
            var a = parseFloat(values[0]);
            var b = parseFloat(values[1]);

            var rotationInRadians = Math.atan2(b, a);
            var rotationInDegrees = rotationInRadians * (180 / Math.PI);
            if (rotationInDegrees == 0) {
                x = childLeft - parentLeft;
                y = childTop - parentTop;
            }
        } else {
            x = childLeft - parentLeft;
            y = childTop - parentTop;
        }
    }

    let w = contentNode.offsetWidth;
    let h = contentNode.offsetHeight;
    if (isText) {
        if (!window.isOrigamiPPTX) {
            if (!contentNode?.id?.includes("sgNumberTextNode")) w = w + 11.5;
            else if (contentNode?.id?.includes("sgNumberTextNode")) w = w + 10;
            x = x - 5;
        }
        if (contentNode.parentElement.offsetHeight != 0 && contentNode.offsetHeight > 0) h = contentNode.offsetHeight > contentNode.parentElement.offsetHeight ? contentNode.parentElement.offsetHeight : contentNode.offsetHeight + 1;
        if (w != 6) {
            let padding = ExportUtils.getPadding(contentNode);
            if (padding && padding.paddingLeft) {
                x = parseFloat(x) + parseFloat(padding.paddingLeft);
                w = parseFloat(w) - parseFloat(padding.paddingLeft) - parseFloat(padding.paddingRight);
            }
            if (padding && padding.paddingTop) {
                y = parseFloat(y) + parseFloat(padding.paddingTop);
                h = parseFloat(h) - parseFloat(padding.paddingTop) - parseFloat(padding.paddingBottom);
            }
        }
    }
    ExportUtils.outLineSizeUpdate(contentNode, x, y, w, h);
    if (x >= this.slideWidth) w = 0;
    if (y >= this.slideHeight) h = 0;
    return [x, y, w, h].toString().replace(/,/g, " ");
};

ExportUtils.outLineSizeUpdate = function (contentNode, x, y, w, h) {
    if (contentNode) {
        let outlineWidth = window.getComputedStyle(contentNode).outlineWidth;
        if (!isNaN(parseFloat(outlineWidth))) {
            x = parseFloat(x) - parseFloat(outlineWidth) / 2;
            y = parseFloat(y) - parseFloat(outlineWidth) / 2;
            w = parseFloat(w) + parseFloat(outlineWidth) * 2;
            h = parseFloat(h) + parseFloat(outlineWidth) * 2;
        }
    }
};

ExportUtils.getPadding = function (element) {
    let objPadding = { paddingLeft: 0, paddingRight: 0, paddingTop: 0, paddingBottom: 0 };
    if (element) {
        let elementStyle = window.getComputedStyle(element);
        objPadding.paddingLeft = elementStyle.paddingLeft;
        objPadding.paddingRight = elementStyle.paddingRight;
        objPadding.paddingTop = elementStyle.paddingTop;
        objPadding.paddingBottom = elementStyle.paddingBottom;
    }
    return objPadding;
};

ExportUtils.getCoordsXY = function (contentNode, parentID, iconNode) {
    let x = ExportUtils.calculatePosition(contentNode, parentID, "offsetLeft");
    let y = ExportUtils.calculatePosition(contentNode, parentID, "offsetTop");

    let svgNode = iconNode ? iconNode : contentNode;
    let moodParentDiv = document.getElementById("PPTXContainer");
    if (moodParentDiv && moodParentDiv?.querySelector("[id='" + parentID + "']")) {
        let slideDom = moodParentDiv.querySelector("[id='" + parentID + "']");
        let parentRect = slideDom.getBoundingClientRect();
        let childRect = svgNode.getBoundingClientRect();
        let parentTop = parentRect.top;
        let childTop = childRect.top;
        let parentLeft = parentRect.left;
        let childLeft = childRect.left;

        let computedStyle = window.getComputedStyle(contentNode);
        let transformValue = computedStyle.transform || computedStyle.webkitTransform;
        if (transformValue == "none" || transformValue == "" || transformValue == "unset") {
            computedStyle = window.getComputedStyle(svgNode);
            transformValue = computedStyle.transform || computedStyle.webkitTransform;
        }
        if (transformValue != "none" && transformValue != "" && transformValue != "unset") {
            let values = transformValue.match(/-?[\d.]+/g);
            var a = parseFloat(values[0]);
            var b = parseFloat(values[1]);

            var rotationInRadians = Math.atan2(b, a);
            var rotationInDegrees = rotationInRadians * (180 / Math.PI);
            if (rotationInDegrees == 0) {
                x = childLeft - parentLeft;
                y = childTop - parentTop;
            }
        } else {
            x = childLeft - parentLeft;
            y = childTop - parentTop;
        }
    }

    return { x: x, y: y };
};

ExportUtils.calculatePosition = function (objElement, mainParentID, strOffset) {
    let iOffset = 0;
    if (objElement.offsetParent) {
        do {
            iOffset += objElement[strOffset];
            objElement = objElement.offsetParent;
        } while (objElement && objElement.id != mainParentID);
    }
    return iOffset;
};

ExportUtils.getRandomNumber = function rand() {
    let randomNum = Math.random() * (500 - 400) + 400;
    return Math.round(randomNum);
};

ExportUtils.getMetaData = function (node, parentID) {
    let objData = {};
    if (node && (node != "" || (node.tagName.toLowerCase() == "a" && node.textContent != "")) && node.style) {
        let prompt = node.getAttribute("data-prompt-text") || "";
        let index = node.getAttribute("data-index") || ExportUtils.getRandomNumber();
        let cssStyle = window.getComputedStyle(node);
        objData.type = "text";
        objData.zindex = cssStyle.zIndex || 0;
        objData.name = prompt + "-" + index;
        objData.text = node.textContent == "" ? prompt : node.textContent;
        if (window.isOrigamiPPTX) objData.innerHTML = node.innerHTML;
        let newString = TextHighLightUtils.highlightToString(node.innerHTML);
        if (newString) objData.text = newString;
        if (node.querySelector("[id*='quillicon']")) {
            let iconNode = node.querySelector("[id*='quillicon']");
            objData.text = objData.text.replace(iconNode.textContent, "");
        }
        if (objData.text?.includes("\u000b")) objData.text = objData.text.replaceAll("\u000b", "");

        let isText = node.tagName.toLowerCase() == "td" ? false : true;
        let textIndent = cssStyle["text-indent"] ? parseFloat(cssStyle["text-indent"].replace("px", "")) : 0;
        let extraSpace = 0;
        if (textIndent > 0) {
            let dummyNode = node.cloneNode(true);
            dummyNode.innerHTML = "i";
            dummyNode.style.textIndent = "0px";
            dummyNode.style.position = "absolute";
            dummyNode.style.width = "auto";
            dummyNode.style.opacity = "0";
            node.parentElement.appendChild(dummyNode);
            let ow = parseFloat(window.getComputedStyle(dummyNode).width).toFixed(2);
            console.log(ow);
            node.parentElement.removeChild(dummyNode);
            extraSpace = parseInt(textIndent / parseFloat(ow)) + 2;
        }
        for (let i = 0; i < extraSpace; i++) objData.text = " " + objData.text;
        objData.coords = ExportUtils.getCoords(node, parentID, isText);
        let listNode = node.querySelector("[data-id='secondaryTextItem'");
        if (listNode) {
            cssStyle = window.getComputedStyle(listNode);
            objData.halign = cssStyle["text-align"] == "end" || cssStyle["text-align"] == "right" ? "right" : cssStyle["text-align"] == "center" ? "center" : "left";
        }
        ExportUtils.updateFontStyleData(objData, cssStyle, listNode ? listNode : node);
        ExportUtils.updateMiniStyleData(objData, cssStyle, true, null, node);
        if (window.isOrigamiPPTX) {
            objData["font"]["justify-content"] = cssStyle["justify-content"];
            objData["font"]["align-items"] = cssStyle["align-items"];
        }

        if (window.isOrigamiPPTX && objData["transform"]) {
            objData.style ? (objData.style["transform"] = objData["transform"]) : (objData.style = { transform: objData["transform"] });
        }

        try {
            if (objData.transform?.includes("rotate(") && objData["transform-origin"] == "center") {
                objData.transform = objData.transform.replace("scaleX(1) ", "").replace("scaleY(1) ", "").trim();
                var rotateRegex = /rotate\(([-+]?\d*\.?\d+)(deg)?\)/;
                var transMatch = objData.transform.match(rotateRegex);
                if (transMatch) {
                    var rotateAngle = parseFloat(transMatch[1]);
                    if (rotateAngle != 0) {
                        let arrCoords = objData.coords.split(" ");
                        let width = parseFloat(arrCoords[2]);
                        let height = parseFloat(arrCoords[3]);
                        let rotateLeft = -width / 2 + height / 2;
                        let rotateTop = -height / 2 + width / 2;
                        arrCoords[0] = parseFloat(arrCoords[0]) + rotateLeft;
                        arrCoords[1] = parseFloat(arrCoords[1]) + rotateTop;
                        arrCoords[2] = parseFloat(arrCoords[2]) + 3;
                        arrCoords[3] = parseFloat(arrCoords[3]) + 3;
                        objData.coords = arrCoords.toString().replace(/,/g, " ");
                    }
                } else {
                    console.log("No rotate angle found");
                }
            }
        } catch (error) {}

        const match = cssStyle["color"].match(/[\d\.]+/g);
        if (match?.[3] && !isNaN(parseFloat(match[3])) && parseFloat(match[3]) > 0 && parseFloat(match[3]) <= 1) {
            console.log(match[3]);
            objData.opacity = match[3];
            objData.alpha = match[3];
        }

        if (objData.font && objData.font["text-transform"] == "uppercase") objData.text = objData.text.toUpperCase();
        if (objData.font && objData.font["text-transform"] == "lowercase") objData.text = objData.text.toLowerCase();
        if (objData.style?.["transform"] == "matrix(1, 0, 0, 0, 0, 0)") objData.coords = "0 0 0 0";
        if (window.getComputedStyle(node).backgroundImage.includes("gradient")) {
            const rgbPattern = /rgb\(([^)]+)\)/;
            const match = rgbPattern.exec(objData.font["background-image"]);
            delete objData.style.background;
            delete objData.style.backgroundImage;
            delete objData.style["background-image"];
            delete objData.font.background;
            delete objData.font.backgroundImage;
            delete objData.font["background-image"];
            delete objData.font["background-clip"];
            delete objData.font["-webkit-background-clip"];
            delete objData.font["-webkit-text-fill-color"];
            if (objData["foreground-color"] == "rgba(0, 0, 0, 0)") objData["foreground-color"] = match[0];
            if (objData.font["color"] == "rgba(0, 0, 0, 0)") objData.font["color"] = match[0];
        }
        objData.font = ExportUtils.removeEmptyItems(objData.font);

        let arrCoords = objData.coords.split(" ");
        if ((parseFloat(arrCoords[0]) + parseFloat(arrCoords[2]) <= 0 || parseFloat(arrCoords[1]) + parseFloat(arrCoords[3]) <= 0 || parseFloat(arrCoords[0]) > this.slideWidth || parseFloat(arrCoords[1]) > this.slideHeight) && objData.transform == "none") return null;
    }
    return objData;
};

ExportUtils.getPsudoRect = function (arrElements, parentNode, parentID, psudoItem = ":after", nodeParentStyle, objCallback) {
    if (parentNode && parentNode.offsetHeight == 0 && parentNode.offsetWidth == 0) return;
    let cssStyle = window.getComputedStyle(parentNode, psudoItem);
    let objData = { type: "drawing", description: "pseudo Rect Drawing", "drawing-type": "rect", name: "PSudoRect" };
    objData.coords = ExportUtils.getCoords(parentNode, parentID, false);
    objData.name = psudoItem;
    let coords = objData.coords.split(" ");

    let parentPaddingL = 0;
    let parentPaddingT = 0;
    let isListEle = parentNode.parentElement.tagName.toLowerCase() == "ul" || parentNode.parentElement.tagName.toLowerCase() == "ol";
    if (isListEle) {
        let parentStyle = window.getComputedStyle(parentNode.parentElement);
        parentPaddingL = !isNaN(parseFloat(parentStyle.paddingLeft.replace("px", ""))) ? parseFloat(parentStyle.paddingLeft.replace("px", "")) : 0;
        parentPaddingT = !isNaN(parseFloat(parentStyle.paddingTop.replace("px", ""))) ? parseFloat(parentStyle.paddingTop.replace("px", "")) : 0;
    }

    let doCheckExtraValues = true;
    if (parentNode.tagName.toLowerCase() == "li" && isListEle && parentNode.parentElement.parentElement.tagName.toLowerCase() == "div") doCheckExtraValues = false;

    coords[0] = parseFloat(coords[0]) + parseFloat(cssStyle["margin-left"]) + parseFloat(cssStyle["left"].includes("px") ? cssStyle["left"] : 0) - parentPaddingL;
    coords[1] = parseFloat(coords[1]) + parseFloat(cssStyle["margin-top"]) + (doCheckExtraValues ? parseFloat(cssStyle["top"].includes("px") ? cssStyle["top"] : 0) : 0) - parentPaddingT;
    let addNode = true;
    if (coords[0] > this.slideWidth) addNode = false;
    if (coords[1] > this.slideHeight) addNode = false;
    if (addNode && coords.length == 4 && psudoItem == "::marker") {
        // Marker number list text adding
        let objOldData = { psudoItem: psudoItem, coords: coords, parentPaddingL: parentPaddingL, parentPaddingT: parentPaddingT };
        objCallback.markerCallback(parentNode, parentID, arrElements, cssStyle, nodeParentStyle, objOldData);
    }
    if (addNode && coords.length == 4 && cssStyle.getPropertyValue("content") != "none") {
        coords[2] = isNaN(parseFloat(cssStyle.width.replace("px"))) ? 0 : parseFloat(cssStyle.width.replace("px"));
        coords[3] = isNaN(parseFloat(cssStyle.height.replace("px"))) ? 0 : parseFloat(cssStyle.height.replace("px"));
        objData.coords = coords.toString().replace(/,/g, " ");
        ExportUtils.updateStyleData(objData, cssStyle, null, "inner-style");
        let borderWidth = objData["inner-style"]["border-width"] ? parseFloat(objData["inner-style"]["border-width"].replace("px", "")) : 0;
        if (isNaN(parseFloat(borderWidth))) borderWidth = 0;
        objData["inner-style"]["width"] = coords[2] - borderWidth * 2 + "px";
        objData["inner-style"]["height"] = coords[3] - borderWidth * 2 + "px";

        objData["buffer-style"] = {
            width: coords[2] + "px",
            height: coords[3] + "px",
            position: "absolute",
            overflow: "hidden",
        };
        if (!objData["buffer-style"]["transform"]) {
            objData["buffer-style"]["transform"] = objData["inner-style"]["transform"];
            objData["buffer-style"]["transform-origin"] = objData["inner-style"]["transform-origin"];
            delete objData["inner-style"]["transform"];
            delete objData["inner-style"]["transform-origin"];
        }

        // Before/after basic styles adding
        objCallback.callback(arrElements, objData, parentNode, nodeParentStyle);

        let contentValue = cssStyle.content.replaceAll('"', "");
        if (contentValue != "" && psudoItem != "::marker") {
            // Before/after content adding
            let objOldData = { psudoItem: psudoItem, coords: coords, contentValue: contentValue };
            objCallback.psudoContentCallback(parentNode, parentID, arrElements, cssStyle, nodeParentStyle, objOldData);
        }
    }
};

ExportUtils.updateFontStyleData = function (objData, cssStyle, node) {
    let objFontData = {};
    let fontsize = cssStyle.getPropertyValue("font-size");
    let lineHeight = cssStyle.getPropertyValue("line-height");
    objFontData["face"] = cssStyle.getPropertyValue("font-family").replace(/\"/g, "");
    try {
        if (cssStyle.getPropertyValue("--alternate-font-family")?.trim()?.length > 0) objFontData["face"] = cssStyle.getPropertyValue("--alternate-font-family").replace(/^"|"$/g, "");
    } catch (error) {}
    objFontData["size"] = fontsize ? fontsize.replace("px", "") : "0";
    objFontData["weight"] = cssStyle.getPropertyValue("font-weight");
    if (cssStyle.getPropertyValue("line-height") != "normal") objFontData["line-height"] = lineHeight ? lineHeight.replace("px", "") : "normal";
    if (cssStyle.getPropertyValue("column-count")) objFontData["column-count"] = cssStyle.getPropertyValue("column-count");
    if (cssStyle.getPropertyValue("letter-spacing") != "normal") objFontData["letter-spacing"] = cssStyle.getPropertyValue("letter-spacing");
    objFontData["style"] = cssStyle.getPropertyValue("font-style");
    objFontData["stretch"] = cssStyle.getPropertyValue("font-stretch");
    objFontData["color"] = cssStyle.getPropertyValue("color");
    objFontData["background"] = cssStyle.getPropertyValue("background");
    if (cssStyle["background-image"] && cssStyle["background-image"] != "" && cssStyle["background-image"] != undefined) objFontData["background-image"] = cssStyle["background-image"];
    if (cssStyle["background-clip"] && cssStyle["background-clip"] != "" && cssStyle["background-clip"] != undefined) objFontData["background-clip"] = cssStyle["background-clip"];
    if (cssStyle["-webkit-background-clip"] && cssStyle["-webkit-background-clip"] != "" && cssStyle["-webkit-background-clip"] != undefined) objFontData["-webkit-background-clip"] = cssStyle["-webkit-background-clip"];
    if (!window.isOrigamiPPTX && cssStyle["-webkit-text-fill-color"] && cssStyle["-webkit-text-fill-color"] != "" && cssStyle["-webkit-text-fill-color"] != undefined) objFontData["-webkit-text-fill-color"] = cssStyle["-webkit-text-fill-color"];
    if (!window.isOrigamiPPTX && cssStyle["text-fill-color"] && cssStyle["text-fill-color"] != "" && cssStyle["text-fill-color"] != undefined) objFontData["text-fill-color"] = cssStyle["text-fill-color"];

    objFontData["display"] = cssStyle.getPropertyValue("display");
    if (objFontData["display"] == "table-cell" || objFontData["display"] == "table-row") objFontData["display"] = "flex";
    if (cssStyle.getPropertyValue("text-transform") && cssStyle.getPropertyValue("text-transform") != "none") objFontData["text-transform"] = cssStyle.getPropertyValue("text-transform");
    objData["shadow"] = cssStyle.getPropertyValue("text-shadow");
    if (objData["shadow"] == "none") delete objData["shadow"];
    objData["foreground-color"] = cssStyle.getPropertyValue("color");
    objData.halign = cssStyle["text-align"] == "end" || cssStyle["text-align"] == "right" ? "right" : cssStyle["text-align"] == "center" ? "center" : "left";

    objData.anchor = "top";
    if (cssStyle["display"] == "flex" && ((cssStyle["flex-direction"] == "row" && cssStyle["align-items"] == "center") || (cssStyle["flex-direction"] == "column" && cssStyle["justify-content"] == "center"))) objData.anchor = "center";

    if (cssStyle["align-self"] == "center" && cssStyle["align-items"] == "center") objData.halign = "center";
    objData.font = objFontData;
    //Text Transform properties creation
    if (cssStyle["writing-mode"] && cssStyle["writing-mode"] == "vertical-rl") {
        let deg = cssStyle["transform"] == "rotate(180deg)" || cssStyle["transform"].replaceAll(" ", "") == "matrix(-1,0,0,-1,0,0)" ? "-90deg" : "90deg";
        objData.transform = "rotate(" + deg + ")";
        let arrPositionData = objData.coords.split(" ");
        if (arrPositionData.length == 4) {
            let newX = parseFloat(arrPositionData[0]) + (-parseFloat(arrPositionData[3]) / 2 + parseFloat(arrPositionData[2]) / 2);
            let newY = parseFloat(arrPositionData[1]) + (parseFloat(arrPositionData[3]) / 2 - parseFloat(arrPositionData[2]) / 2);
            objData.coords = newX + " " + newY + " " + parseFloat(arrPositionData[3]) + " " + parseFloat(arrPositionData[2]);
        }
    } else if (node) {
        let parentStyle = window.getComputedStyle(node);
        objData["transform"] = parentStyle.transform;
        let matrixValue = this.updateTransformData(parentStyle);
        if (matrixValue) objData["transform"] = matrixValue;
        objData["transform-origin"] = node.style.transformOrigin;
        if ((!objData["transform"] || objData["transform"] == "scale(1)" || objData["transform"] == "" || objData["transform"] == "unset" || objData["transform"] == "none") && node.parentElement) {
            parentStyle = window.getComputedStyle(node.parentElement);
            objData["transform"] = parentStyle.transform;
            matrixValue = this.updateTransformData(parentStyle);
            if (matrixValue) {
                objData["transform"] = matrixValue;
                objData["transform-origin"] = node.parentElement.style.transformOrigin || "left top";
            }
        }
    }
};

ExportUtils.getCurrentRotation = function (el) {
    var st = window.getComputedStyle(el, null);
    var tm = st.getPropertyValue("-webkit-transform") || st.getPropertyValue("-moz-transform") || st.getPropertyValue("-ms-transform") || st.getPropertyValue("-o-transform") || st.getPropertyValue("transform") || "none";
    if (tm != "none") {
        var values = tm.split("(")[1].split(")")[0].split(",");
        var angle = Math.round(Math.atan2(values[1], values[0]) * (180 / Math.PI));
        return angle < 0 ? angle + 360 : angle;
    }
    return 0;
};

ExportUtils.addStyleElement = function (arrElements, objData) {
    if (arrElements && objData) {
        let styleValue = objData.style ? objData.style : objData["inner-style"];

        let coords = objData.coords ? objData.coords.split(" ") : [];
        let hasProperCoords = objData.coords == "0 0 0 0" ? false : coords.length == 4 && parseFloat(coords[2] + "") > 0 && parseFloat(coords[3] + "") > 0;

        let hasInvisibleLayer = styleValue && styleValue.background && styleValue.background.replace(/\s/g, "").includes("rgba(0,0,0,0)") && !styleValue.background.replace(/\s/g, "").includes("-gradient") && !styleValue.background.replace(/\s/g, "").includes("url");

        if (!hasInvisibleLayer && styleValue.backgroundColor?.includes("rgb") && !styleValue.background?.includes("gradient") && !styleValue.backgroundImage?.includes("gradient")) hasInvisibleLayer = styleValue.backgroundColor?.replace(/\s/g, "")?.includes("rgba(0,0,0,0)");

        if (!hasInvisibleLayer && styleValue["background-color"]?.includes("rgb") && !styleValue["background"]?.includes("gradient") && !styleValue["background-image"]?.includes("gradient") && !styleValue["background-image"]?.includes("url"))
            hasInvisibleLayer = styleValue["background-color"]?.replace(/\s/g, "")?.includes("rgba(0,0,0,0)");

        if (hasInvisibleLayer && styleValue["border-color"]?.includes("rgb")) hasInvisibleLayer = styleValue["border-color"]?.replace(/\s/g, "")?.includes("rgba(0,0,0,0)");

        if (hasInvisibleLayer && styleValue["outline-color"]?.includes("rgb")) hasInvisibleLayer = styleValue["border-color"]?.replace(/\s/g, "")?.includes("rgba(0,0,0,0)");

        let isCorrectImage = objData.type == "image" && objData.path && objData.src != "" && objData.src != "none";
        if (hasInvisibleLayer && isCorrectImage) hasInvisibleLayer = false;

        let hasEmptyOutline = (styleValue && styleValue["outline-width"] == "0px") || (styleValue && !styleValue["outline-width"]);
        let hasEmptyBorder = (styleValue && styleValue["border-width"] == "0px") || (styleValue && !styleValue["border-width"]);
        let hasEmptyShadow = (styleValue && styleValue["box-shadow"] == "none") || (styleValue && !styleValue["box-shadow"]);

        if (hasEmptyShadow && objData.shadow && objData.shadow != "" && objData.shadow != "none") hasEmptyShadow = false;

        let hasDiaplayNone = styleValue && styleValue.display && styleValue.display.includes("none");

        if ((hasInvisibleLayer && hasEmptyBorder && hasEmptyOutline && hasEmptyShadow) || hasDiaplayNone || !hasProperCoords) return;
        arrElements.push(objData);
    }
};

/**
 * Author:    Bala Krishnan K.
 * Created:   01.06.2021
 *
 * (c) Copyright by Bala K.
 **/

"use strict";

function CustomCalendar(mainParent, appStaticURL = "") {
    this.mainParent = mainParent;
    this.appStaticURL = appStaticURL;
    this.calendarData = mainParent.dataset.calendardata ? JSON.parse(mainParent.dataset.calendardata) : {};
    this.moodName = "";
    this.isTempSlide = false;
    this.mainParent.className = "commonallmoodcalendar moodanimation";
    this.defaultProps = {
        istitle: (mainParent.dataset.istitle && mainParent.dataset.istitle == "true") || false,
        displayview: mainParent.dataset.displayview || "dayGridMonth",
        currentdate: this.getDate(),
    };
    this.objProperties = JSON.parse(JSON.stringify(this.defaultProps));
}

CustomCalendar.prototype.constructor = CustomCalendar;

CustomCalendar.prototype.initCreation = function () {
    this.createCalendarInstance();
    this.calendar.render();
    this.updateStyles();
    this.updatePropsCallBack();
    return this.calendar;
};

CustomCalendar.prototype.setMoodClassNames = function () {
    if (this.moodName != "") {
        this.mainParent.classList.add("common" + this.moodName + "calendar");
        this.mainParent.classList.add(this.moodName + "calendar");
    }
};

CustomCalendar.prototype.updateStyles = function () {
    let title = this.mainParent.querySelector(".fc-toolbar-title");
    title.classList.add("h7");
    let arrWeek = this.mainParent.querySelectorAll(".fc-col-header-cell-cushion");
    arrWeek.forEach((element) => {
        element.classList.add("h9");
    });
    let arrNumber = this.mainParent.querySelectorAll(".fc-daygrid-day-number");
    arrNumber.forEach((element) => {
        element.classList.add("p7");
    });
};

CustomCalendar.prototype.getDate = function () {
    var today = new Date();
    var dd = String(today.getDate()).padStart(2, "0");
    var mm = String(today.getMonth() + 1).padStart(2, "0"); //January is 0!
    var yyyy = today.getFullYear();

    return yyyy + "-" + mm + "-" + dd;
};

CustomCalendar.prototype.createCalendarInstance = function () {
    // let arrDate = this.objProperties.currentdate ? this.objProperties.currentdate.split("-") : this.defaultProps.currentdate.split("-");
    let arrDate = this.objProperties.currentdate.split("-");
    this.calendar = new FullCalendar.Calendar(this.mainParent, {
        initialView: this.objProperties.displayview || "dayGridMonth",
        timeZone: "local",
        height: "100%",
        contentHeight: "100%",
        // width: "100%",
        // aspectRatio: 1.78,
        // initialDate: new Date(2018, 8, 1),
        initialDate: new Date(parseInt(arrDate[0]), parseInt(arrDate[1]) - 1, parseInt(arrDate[2])),
        headerToolbar: {
            // left: "prev,next today datepickerButton",
            left: "",
            center: "title",
            right: "",
            // right: "dayGridMonth,timeGridWeek,timeGridDay",
        },
        navLinks: false, // can click day/week names to navigate views
        editable: true,
        eventLimit: true,
        selectable: true,
        events: this.calendarData && this.calendarData.events ? this.calendarData.events : [],
    });
    // let headerToolbar = this.mainParent.querySelector(".fc-header-toolbar");
    // if (headerToolbar) headerToolbar.style.display = this.objProperties.istitle ? "flex" : "none";
    this.mainParent.style.setProperty("--calendartitledisplay", this.objProperties.istitle ? "flex" : "none");
    if (this.appmode.toLowerCase() != "present") {
        this.calendar.on("dateClick", this.addEventCallBackFunc.bind(this));
        this.calendar.on("eventClick", this.eventClickHandlerFunc.bind(this));
    }
    this.calendar.on("windowResize", this.windowResizeHandler.bind(this));
    this.calendar.on("eventChange", this.changeHandler.bind(this));
    // this.changeView("timeGridWeek");
    this.setMoodClassNames();
    return this.calendar;
};

CustomCalendar.prototype.reCreateCalendarInstance = function () {
    this.calendarData = this.getCalendarData();
    this.objProperties = this.getProperties();
    this.createCalendarInstance();
    this.updateSize();
    // calendar.objProperties = calendar.getProperties();
    this.calendar.render();
};

CustomCalendar.prototype.addEventCallBackFunc = function (event) {
    if (this.addEventCallBack && this.addEventCallBack.func && !this.isTempSlide) {
        this.addEventCallBack.params = event;
        this.addEventCallBack.func(event);
    }
};

CustomCalendar.prototype.eventClickHandlerFunc = function (info) {
    if (this.editEventCallBack && this.editEventCallBack.func && !this.isTempSlide) {
        this.editEventCallBack.params = info.event;
        this.editEventCallBack.func(info.event);
    }
};

CustomCalendar.prototype.dateClickHandler = function (data) {
    let event = this.addEventCallBack.params;
    event.title = data.updatedLabel;
    this.calendar.gotoDate(event.date);
    this.calendar.addEvent(event);
    // this.calendar.addEvent({
    //     title: data.updatedLabel,
    //     start: event.start,
    //     end: event.end,
    //     allDay: event.allDay,
    // });
    this.calendar.unselect();
    this.updateCalendarData();
};

CustomCalendar.prototype.eventClickHandler = function (data) {
    let event = this.editEventCallBack.params;
    event.setProp("title", data.updatedLabel);
    // this.calendar.gotoDate(event.date);
    // this.calendar.render();
    // Remove Event
    // event.remove();
    this.calendar.unselect();
    this.updateCalendarData();
};

CustomCalendar.prototype.changeHandler = function (info) {
    this.updateCalendarData();
};

CustomCalendar.prototype.windowResizeHandler = function (info) {
    // this.calendar.setHeight(this.mainParent.clientHeight);
    // this.calendar.setWidth(this.mainParent.clientWidth);
    // this.calendar.render();
};

CustomCalendar.prototype.updateCalendarData = function () {
    this.calendarData.events = this.getEvents();
    this.setCalendarData();
    this.updatePropsCallBack();
    return this.calendarData;
};

CustomCalendar.prototype.getEvents = function () {
    let arrEvents = this.calendar.getEvents();
    let arrMatrix = [];
    arrEvents.forEach((element) => {
        arrMatrix.push({
            id: element.id,
            title: element.title,
            start: element.start,
            end: element.end,
            allDay: element.allDay,
            extendedProps: element.extendedProps,
        });
    });
    return arrMatrix;
};

CustomCalendar.prototype.updateSize = function () {
    if (this.calendar) {
        this.calendar.updateSize();
        // $("#calendar").width(750).css({'margin-left': 'auto','margin-right': 'auto'});
        // this.calendar.render();
    }
    // if (this.calendar) this.calendar.trigger("resize");
};

CustomCalendar.prototype.updatePropsCallBack = function (targetid) {
    if (this.updateCallBack && this.updateCallBack.func && !this.isTempSlide) {
        this.updateCallBack.func(this.updateCallBack.params, targetid);
    }
};

CustomCalendar.prototype.navigateToDate = function (year, month, day) {
    this.calendar.gotoDate(new Date(parseInt(year), parseInt(month) - 1, parseInt(day)));
    this.objProperties.currentdate = year + "-" + month + "-" + day;
    this.setProperties();
    this.calendar.render();
    this.updatePropsCallBack();
};

CustomCalendar.prototype.changeView = function (viewName = "dayGridMonth") {
    this.calendar.changeView(viewName);
    this.objProperties.displayview = viewName;
    this.setProperties();
    this.calendar.render();
    this.updatePropsCallBack();
};

CustomCalendar.prototype.toggleTitle = function (isvisible = true) {
    // let headerToolbar = this.mainParent.querySelector(".fc-header-toolbar");
    // if (headerToolbar) headerToolbar.style.display = isvisible ? "flex" : "none";
    this.mainParent.style.setProperty("--calendartitledisplay", isvisible ? "flex" : "none");
    this.objProperties.istitle = isvisible;
    this.setProperties();
    this.calendar.updateSize();
    // this.calendar.render();
    this.updatePropsCallBack();
};

CustomCalendar.prototype.getProperties = function () {
    let properties = {};
    for (var property in this.objProperties) {
        // if (this.mainParent.hasAttribute("data-" + property)) {
        properties[property] = this.mainParent.getAttribute("data-" + property) || this.defaultProps[property];
        if (property.startsWith("is")) properties[property] = properties[property] == "true" || this.defaultProps[property];
        // }
    }
    return properties;
};

CustomCalendar.prototype.setProperties = function () {
    for (var property in this.objProperties) {
        this.mainParent.setAttribute("data-" + property, this.objProperties[property]);
    }
};

CustomCalendar.prototype.setCalendarData = function () {
    this.mainParent.setAttribute("data-calendardata", JSON.stringify(this.calendarData));
};

CustomCalendar.prototype.getCalendarData = function () {
    let calendarDataAttrib = this.mainParent.getAttribute("data-calendardata");
    this.calendarData = calendarDataAttrib && calendarDataAttrib != "" ? JSON.parse(calendarDataAttrib) : {};
    return this.calendarData;
};

// CustomCalendar.prototype.getOutlineMatrix = function () {
//     return {
//         calenderdata: this.calendarData,
//         properties: this.objProperties && Object.keys(this.objProperties).length != 0 ? this.objProperties : this.defaultProps,
//     };
// };

// CustomCalendar.prototype.initCalendarCreationOutline = function (outlineData) {
//     this.calendarData = (outlineData && outlineData.calenderdata) || {};
//     this.setCalendarData();
//     this.objProperties = outlineData && outlineData.properties && Object.keys(outlineData.properties).length != 0 ? outlineData.properties : this.defaultProps;
//     this.setProperties();
// };

// if (objPropData.property && objPropData.property == "DATE_PICK") {
//     let splitDate = objPropData.value.split("-");
//     calendar.navigateToDate(splitDate[0], splitDate[1], splitDate[2]);
// } else if (objPropData.property && objPropData.property == "DISPLAY_VIEW") {
//     calendar.changeView(objPropData.value);
// } else if (objPropData.property && objPropData.property == "CALENDAR_TITLE") {
//     calendar.toggleTitle(objPropData.value);
// }

CustomCalendar.prototype.getOldPropertyValue = function (property, newValueObj) {
    let valueObj = {};
    let properties = this.objProperties && Object.keys(this.objProperties).length != 0 ? this.objProperties : this.defaultProps;
    switch (property) {
        case "ADD_EVENT":
        case "EDIT_EVENT":
            valueObj = JSON.parse(JSON.stringify(newValueObj));
            break;
        case "DISPLAY_VIEW":
            valueObj = JSON.parse(JSON.stringify(newValueObj));
            valueObj.value = properties.displayview;
            break;
        case "CALENDAR_TITLE":
            valueObj = JSON.parse(JSON.stringify(newValueObj));
            valueObj.value = !newValueObj.value;
            break;
        case "DATE_PICK":
            valueObj = JSON.parse(JSON.stringify(newValueObj));
            valueObj.value = properties.currentdate;
            break;
    }
    return valueObj;
};

CustomCalendar.prototype.setOperationProperty = function (property, valueObj, diagramParent, diagramInstance) {
    switch (property) {
        case "ADD_EVENT":
            this.dateClickHandler(valueObj);
            break;
        case "EDIT_EVENT":
            this.eventClickHandler(valueObj);
            break;
        case "DISPLAY_VIEW":
            this.changeView(valueObj.value);
            break;
        case "CALENDAR_TITLE":
            this.toggleTitle(valueObj.value);
            break;
        case "DATE_PICK":
            try {
                if (valueObj.value && valueObj.value != "") {
                    let splitDate = valueObj.value.split("-");
                    this.navigateToDate(splitDate[0], splitDate[1], splitDate[2]);
                }
            } catch (error) {
                console.log("invalid date", error);
            }
            break;
    }
};

/**
 * Author:    Bala Krishnan K.
 * Created:   23.02.2021
 *
 * (c) Copyright by Bala K.
 **/

"use strict";

function AuthorStyleGroup(nodeProps, nodeData, index, objFontData, diagramParent, appStaticURL = "", properties) {
    this.nodeProps = nodeProps;
    this.nodeData = nodeData || {};
    this.index = index;
    this.objFontData = objFontData;
    this.diagramParent = diagramParent;
    this.appStaticURL = appStaticURL;
    this.properties = properties;
}

AuthorStyleGroup.prototype.constructor = AuthorStyleGroup;

AuthorStyleGroup.prototype.createAuthorStyle = function (mainParent, authorNodeObj) {
    let authorDiv = document.createElement("div");
    DiagramNodeUtils.assignAttributes(authorDiv, { class: "clsAuthorStyle", id: "authorStyle" + this.index, name: "authorStyle", "data-index": this.index });
    mainParent.appendChild(authorDiv);
    DiagramUtils.addClassesFromMenu(authorNodeObj.objClass, authorDiv);

    let intCount = authorNodeObj.subNodes.length;
    for (let i = 0; i < intCount; i++) {
        let nodeObj = authorNodeObj.subNodes[i];
        let nodeParent = this.createNodes(nodeObj, authorDiv);
        if (nodeObj.subNodes && nodeParent) {
            this.createNestedNodes(nodeObj.subNodes, nodeParent);
        }
    }
};

AuthorStyleGroup.prototype.createNestedNodes = function (subNodes, nodeParentToInsert, objDataSec) {
    for (let j = 0; j < subNodes.length; j++) {
        let nodeObj = subNodes[j];
        let nodeParent = this.createNodes(nodeObj, nodeParentToInsert, objDataSec);
        if (nodeObj.subNodes && nodeParent) {
            this.createNestedNodes(nodeObj.subNodes, nodeParent, objDataSec);
        }
    }
};

AuthorStyleGroup.prototype.createNodes = function (nodeObj, nodeParent) {
    let name = nodeObj.name;
    switch (name) {
        case "authorImageHolder":
            return this.createAuthorImageNode(nodeParent, this.nodeData.image, nodeObj);
        case "authorGroup":
            return this.createAuthorGroup(nodeParent, nodeObj);
        case "authorNameHolder":
            return this.createAuthorName(nodeParent, this.nodeData.name, nodeObj);
        case "authorDesHolder":
            return this.createAuthorDesignation(nodeParent, this.nodeData.designation, nodeObj);
        default:
            break;
    }
};

AuthorStyleGroup.prototype.createAuthorImageNode = function (parentNode, nodeData, nodeObj) {
    nodeData = DiagramCreateUtil.checkDefaultData(this.diagramParent, nodeData, "image", this.appStaticURL);
    let imageHolder = DiagramCreateUtil.createImageNode(parentNode, nodeData, "authorImageHolder", this.index, "authorImage", [], null, null, null, nodeObj, this.appStaticURL);
    if (this.properties.authorimage) this.diagramParent.parentElement.style.setProperty("--authorstyleimagedisplay", "flex");
    else this.diagramParent.parentElement.style.setProperty("--authorstyleimagedisplay", "none");
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, imageHolder);
    imageHolder.classList.add("moodanimation");
    imageHolder.setAttribute("data-animation", "item");
    return imageHolder;
};

AuthorStyleGroup.prototype.createAuthorGroup = function (mainParent, nodeObj) {
    let nodeParent = document.createElement("div");
    DiagramNodeUtils.assignAttributes(nodeParent, {
        class: "clsAuthorGroup",
        id: "authorGroup" + this.index,
        "data-index": this.index,
        "data-type": "authorGroup",
        name: "authorGroup",
    });
    mainParent.appendChild(nodeParent);

    if (nodeObj.colorClass) nodeParent.classList.add(DiagramUtils.createColorClass(nodeObj.colorClass));
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, nodeParent);

    // let bgNodeDiv = document.createElement("div");
    // nodeParent.appendChild(bgNodeDiv);
    // DiagramNodeUtils.assignAttributes(bgNodeDiv, {
    //     class: "clsSecContentBackgound moodanimation clsNodeAccentbg",
    //     "data-animation": "nodebg",
    //     "data-index": this.index,
    //     id: "authorGroupBackgound" + this.index,
    //     name: "authorGroupBackgound",
    // });

    return nodeParent;
};

AuthorStyleGroup.prototype.createAuthorName = function (parentNode, nodeData, nodeObj) {
    let titleHolder = document.createElement("div");
    DiagramNodeUtils.assignAttributes(titleHolder, {
        class: "clsAuthorName",
        "data-index": this.index,
        name: "authorNameHolder",
        "data-dck-selector": true,
        id: "authorNameHolder" + this.index,
    });
    parentNode.appendChild(titleHolder);
    const value = nodeData && nodeData.value ? nodeData.value : "";
    let fontSize = DiagramNodeUtils.getFontSize("authorName", nodeObj, this.objFontData.authorNameFontSize, this.properties);
    let titleNode = DiagramCreateUtil.createLabel(
        this.index,
        "clsPrimaryTextColor " + fontSize + " moodanimation ",
        "authorName",
        this.diagramParent && this.diagramParent.dataset && this.diagramParent.dataset.nodename && this.diagramParent.dataset.nodename.includes("-team") ? "Name" : nodeObj.prompt ? nodeObj.prompt : "Author name",
        value,
        "nodeGroup"
    );
    DiagramNodeUtils.assignAttributes(titleNode, {
        id: "authorName" + this.index,
        "data-type": "authorName",
        "data-animation": "primarytext",
        "data-highlight-event": "true",
        "original-fontclass": fontSize,
        "original-fontbase": fontSize.split("")[0],
        "original-fontnumber": fontSize.split("")[1],
    });

    titleHolder.appendChild(titleNode);
    DiagramUtils.applyTextNodeProperties(titleNode, value, nodeObj, this.properties, this.globalMoodData, Constants.Value.authorNameColor, nodeData);

    if (this.properties.authorname) this.diagramParent.parentElement.style.setProperty("--authorstylenamedisplay", "flex");
    else this.diagramParent.parentElement.style.setProperty("--authorstylenamedisplay", "none");
    return titleHolder;
};

AuthorStyleGroup.prototype.createAuthorDesignation = function (bgDiv, nodeData, nodeObj) {
    let titleHolder = document.createElement("div");
    titleHolder.className = "clsAuthorDes";
    DiagramNodeUtils.assignAttributes(titleHolder, {
        "data-index": this.index,
        name: "authorDesHolder",
        "data-dck-selector": true,
        id: "authorDesHolder" + this.index,
    });
    bgDiv.appendChild(titleHolder);

    const value = nodeData && nodeData.value ? nodeData.value : "";
    const hasFontResize = this.properties.fontresize && this.properties.fontresize.authorDes && this.properties.fontresize.authorDes != "auto";
    const fontSize = hasFontResize ? this.properties.fontresize.authorDes : nodeObj.fontClass || this.objFontData.authorDesFontSize;
    let titleNode = DiagramCreateUtil.createLabel(
        this.index,
        "clsSecondaryTextColor " + fontSize + " moodanimation ",
        "authorDes",
        this.diagramParent && this.diagramParent.dataset && this.diagramParent.dataset.nodename && this.diagramParent.dataset.nodename.includes("-team") ? "Designation" : nodeObj.prompt ? nodeObj.prompt : "Author designation",
        value,
        "nodeGroup"
    );
    DiagramNodeUtils.assignAttributes(titleNode, {
        id: "authorDes" + this.index,
        "data-animation": "secondarytext",
        "data-type": "authorDes",
        "data-highlight-event": "true",
        "original-fontclass": fontSize,
        "original-fontbase": fontSize.split("")[0],
        "original-fontnumber": fontSize.split("")[1],
    });
    titleHolder.appendChild(titleNode);
    DiagramUtils.applyTextNodeProperties(titleNode, value, nodeObj, this.properties, this.globalMoodData, Constants.Value.authorDesignationColor, nodeData);
    if (this.properties.authordes) this.diagramParent.parentElement.style.setProperty("--authorstyledesdisplay", "flex");
    else this.diagramParent.parentElement.style.setProperty("--authorstyledesdisplay", "none");

    return titleHolder;
};

AuthorStyleGroup.prototype.getAuthorData = function (nodeParent) {
    let nodeData = {};
    let authorStyle = nodeParent.querySelector("[id*='authorStyle']");
    if (!authorStyle) return;
    let authorName = nodeParent.querySelector("[name='authorName']");
    if (authorName) nodeData.name = { type: "text", ...DiagramCreateUtil.getTextProps(authorName), value: authorName.innerHTML && authorName.innerHTML != "" ? TextHighLightUtils.highlightToString(authorName.innerHTML) : "" };
    let authorDes = nodeParent.querySelector("[name='authorDes']");
    if (authorDes) nodeData.designation = { type: "text", ...DiagramCreateUtil.getTextProps(authorDes), value: authorDes.innerHTML && authorDes.innerHTML != "" ? TextHighLightUtils.highlightToString(authorDes.innerHTML) : "" };
    let authorDescription = nodeParent.querySelector("[name='secondaryText']");
    if (authorDescription) nodeData.description = { type: "text", ...DiagramCreateUtil.getTextProps(authorDescription), value: authorDescription.innerHTML && authorDescription.innerHTML != "" ? TextHighLightUtils.highlightToString(authorDescription.innerHTML) : "" };
    let authorImageHolder = nodeParent.querySelector("[name='authorImageHolder']") || nodeParent.querySelector("[data-authorimage='true']");
    if (authorImageHolder) {
        let authorImage = authorImageHolder.querySelector("[id*='imageNode']");
        nodeData.image = { type: "image", value: authorImage.src, contenttype: "image" };
    }
    return nodeData;
};

AuthorStyleGroup.prototype.getTextProps = function (node) {
    return PlainDiagramNodeBase.prototype.getTextProps.call(this, node);
};

// MultiAuthorStyleGroup

AuthorStyleGroup.prototype.createMultiAuthorStyle = function (mainParent, authorNodeObj) {
    let authorDiv = document.createElement("div");
    DiagramNodeUtils.assignAttributes(authorDiv, { class: "clsAuthorStyle", id: "authorStyle" + this.index, name: "authorStyle", "data-index": this.index });
    mainParent.appendChild(authorDiv);
    if (authorNodeObj.subNodes) this.createMultiNodes(authorNodeObj.subNodes, authorDiv);
};

AuthorStyleGroup.prototype.createMultiNodes = function (nodeObj, nodeParent) {
    if (nodeObj["authorImageHolder"]) this.createAuthorImageNode(nodeParent, nodeObj["authorImageHolder"]);
    if (nodeObj["authorGroup"]) {
        let authorGroup = this.createAuthorGroup(nodeParent, nodeObj["authorGroup"]);
        this.createMultiNestedNodes(nodeObj["authorGroup"], authorGroup);
    }
    if (nodeObj["authorNameHolder"]) this.createAuthorName(nodeParent, nodeObj["authorNameHolder"], nodeObj["authorNameHolder"]);
    if (nodeObj["authorDesHolder"]) this.createAuthorDesignation(nodeParent, nodeObj["authorDesHolder"], nodeObj["authorDesHolder"]);
};

AuthorStyleGroup.prototype.createMultiNestedNodes = function (nodeObj, nodeParentToInsert, objDataSec) {
    let subNodes = nodeObj.subNodes;
    if (subNodes) this.createMultiNodes(subNodes, nodeParentToInsert, objDataSec);
};

AuthorStyleGroup.prototype.getJSONData = function () {};

// Author node for multicontent
function AuthorStyleGroupMultiNode(nodeProps, nodeData, index, objFontData, diagramParent, appStaticURL = "", properties, nodeParent) {
    AuthorStyleGroup.call(this, nodeProps, nodeData, index, objFontData, diagramParent, appStaticURL, properties);
    this.nodeParent = nodeParent;
    this.nodeParent.setAttribute("data-authorclass", nodeData.parentclass);
}

AuthorStyleGroupMultiNode.prototype = Object.create(AuthorStyleGroup.prototype);
AuthorStyleGroupMultiNode.prototype.constructor = AuthorStyleGroupMultiNode;

AuthorStyleGroupMultiNode.prototype.createAuthorImageNode = function (parentNode, nodeData) {
    nodeData = DiagramCreateUtil.checkDefaultData(this.diagramParent, nodeData, "image", this.appStaticURL);
    let imageHolder = DiagramCreateUtil.createImageNode(parentNode, nodeData, "authorImageHolder", this.index, "authorImage", [], null, null, null, {}, this.appStaticURL);
    // if (this.properties.authorimage) this.diagramParent.parentElement.style.setProperty("--authorstyleimagedisplay", "flex");
    // else this.diagramParent.parentElement.style.setProperty("--authorstyleimagedisplay", "none");
    this.diagramParent?.setAttribute("data-authorimage", "true");
    return imageHolder;
};

AuthorStyleGroupMultiNode.prototype.createAuthorName = function (parentNode, nodeData, nodeObj) {
    let titleHolder = document.createElement("div");
    DiagramNodeUtils.assignAttributes(titleHolder, {
        class: "clsAuthorName",
        "data-index": this.index,
        name: "authorNameHolder",
        "data-dck-selector": true,
        id: "authorNameHolder" + this.index,
    });
    parentNode.appendChild(titleHolder);
    const value = nodeData && nodeData.value ? nodeData.value : "";
    const hasFontResize = this.properties.fontresize && this.properties.fontresize.authorName && this.properties.fontresize.authorName != "auto";
    const fontSize = hasFontResize ? this.properties.fontresize.authorName : nodeObj.fontClass || this.objFontData.authorNameFontSize;
    let titleNode = DiagramCreateUtil.createLabel(
        this.index,
        "clsPrimaryTextColor " + fontSize + " moodanimation ",
        "authorName",
        this.diagramParent && this.diagramParent.dataset && this.diagramParent.dataset.nodename && this.diagramParent.dataset.nodename.includes("-team") ? "Name" : nodeObj.prompt ? nodeObj.prompt : "Author name",
        value,
        "nodeGroup"
    );
    DiagramNodeUtils.assignAttributes(titleNode, {
        id: "authorName" + this.index,
        "data-type": "authorName",
        "data-animation": "primarytext",
        "data-highlight-event": "true",
        "original-fontclass": fontSize,
        "original-fontbase": fontSize.split("")[0],
        "original-fontnumber": fontSize.split("")[1],
    });

    titleHolder.appendChild(titleNode);
    DiagramUtils.applyTextNodeProperties(titleNode, value, nodeObj, this.properties, this.globalMoodData, Constants.Value.authorNameColor, nodeData);
    this.diagramParent?.setAttribute("data-authorname", "true");
    return titleHolder;
};

AuthorStyleGroupMultiNode.prototype.createAuthorDesignation = function (bgDiv, nodeData, nodeObj) {
    let titleHolder = document.createElement("div");
    titleHolder.className = "clsAuthorDes";
    DiagramNodeUtils.assignAttributes(titleHolder, {
        "data-index": this.index,
        name: "authorDesHolder",
        "data-dck-selector": true,
        id: "authorDesHolder" + this.index,
    });
    bgDiv.appendChild(titleHolder);

    const value = nodeData && nodeData.value ? nodeData.value : "";
    const hasFontResize = this.properties.fontresize && this.properties.fontresize.authorDes && this.properties.fontresize.authorDes != "auto";
    const fontSize = hasFontResize ? this.properties.fontresize.authorDes : nodeObj.fontClass || this.objFontData.authorDesFontSize;
    let titleNode = DiagramCreateUtil.createLabel(
        this.index,
        "clsSecondaryTextColor " + fontSize + " moodanimation ",
        "authorDes",
        this.diagramParent && this.diagramParent.dataset && this.diagramParent.dataset.nodename && this.diagramParent.dataset.nodename.includes("-team") ? "Designation" : nodeObj.prompt ? nodeObj.prompt : "Author designation",
        value,
        "nodeGroup"
    );
    DiagramNodeUtils.assignAttributes(titleNode, {
        id: "authorDes" + this.index,
        "data-animation": "secondarytext",
        "data-type": "authorDes",
        "data-highlight-event": "true",
        "original-fontclass": fontSize,
        "original-fontbase": fontSize.split("")[0],
        "original-fontnumber": fontSize.split("")[1],
    });
    titleHolder.appendChild(titleNode);

    DiagramUtils.applyTextNodeProperties(titleNode, value, nodeObj, this.properties, this.globalMoodData, Constants.Value.authorDesignationColor, nodeData);
    this.diagramParent?.setAttribute("data-authordes", "true");
    return titleHolder;
};

/**
 * Author:    Bala Krishnan K.
 * Created:   02.03.2021
 *
 * (c) Copyright by Bala K.
 **/

"use strict";

function NumberToggleStyleGroup(nodeProps, nodeData, index, objFontData, nodeObj, appStaticURL = "") {
    this.nodeProps = nodeProps;
    this.nodeData = nodeData || {};
    this.index = index;
    this.objFontData = objFontData;
    this.nodeObj = nodeObj;
    this.disableSign = nodeObj ? nodeObj.disableSign : false;
    this.appStaticURL = appStaticURL;
}

NumberToggleStyleGroup.prototype.constructor = NumberToggleStyleGroup;

NumberToggleStyleGroup.prototype.createNumberToggleStyle = function (mainParent, numberToggleNodeObj) {
    this.disableSign = numberToggleNodeObj.disableSign;
    let numberToggleDiv = document.createElement("div");
    DiagramNodeUtils.assignAttributes(numberToggleDiv, { class: "clsNumberToggleStyle", id: "numberToggleStyle" + this.index, name: "numberToggleStyle", "data-index": this.index });
    mainParent.appendChild(numberToggleDiv);
    let toggleGroup = this.createNumberToggleGroup(numberToggleDiv, numberToggleNodeObj);
    this.createNumberToggle(toggleGroup, this.nodeData.ischecked, numberToggleNodeObj);
    this.createNumberToggleName(toggleGroup, this.nodeData.name, numberToggleNodeObj);
    this.createNumberToggleDescription(numberToggleDiv, this.nodeData.description, numberToggleNodeObj);
    return numberToggleDiv;
};

NumberToggleStyleGroup.prototype.createNumberToggle = function (bgDiv, nodeDataToggle, nodeObj) {
    let contentParentNode = document.createElement("div");
    contentParentNode.className = "checkbox moodanimation";
    contentParentNode.setAttribute("data-id", "checklistNode");
    contentParentNode.setAttribute("data-animation", "item");
    contentParentNode.setAttribute("data-index", this.index);
    bgDiv.setAttribute("data-content-type", "checklist");
    contentParentNode.setAttribute("data-checkbox-event", "true");
    contentParentNode.setAttribute("data-checkedClass", "clsToggleNumberEnable");
    // this.properties.contenttype = "checklist";
    let checkmark = document.createElement("div");
    checkmark.setAttribute("data-id", "checkmark");

    // let ischecked = this.objData && this.objData.nodeproperties && this.objData.nodeproperties.ischecked;
    // let ischecked = false;
    // nodeData.ischecked = false;
    checkmark.setAttribute("data-ischecked", nodeDataToggle);
    contentParentNode.setAttribute("data-ischecked", nodeDataToggle);
    checkmark.className = "checkmark";
    contentParentNode.appendChild(checkmark);
    let checkmarksvg = DiagramNodeUtils.createSVGElement("svg");
    checkmarksvg.innerHTML =
        '<svg id="tick-main" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48"><polygon points="20.3 31.8 14.2 25.8 16.3 23.7 20.3 27.6 31.7 16.2 33.8 18.3 20.3 31.8" stroke="none" /></svg>';
    checkmarksvg.setAttribute("class", "checkmarksvg");
    checkmarksvg.setAttribute("data-id", "checkmarksvg");
    checkmark.appendChild(checkmarksvg);

    if (nodeObj.toggleenablesvg) {
        let objAssets = { id: nodeObj.toggleenablesvg, value: this.appStaticURL + "genericassets/shapes/" + nodeObj.toggleenablesvg + ".svg" };
        DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body)
            .then((svgData) => {
                checkmarksvg.innerHTML = svgData.data;
                checkmarksvg.style.display = nodeDataToggle ? "flex" : "none";
            })
            .catch((error) => {
                console.log("SVG asset load fail - " + error);
            });
    }

    if (nodeObj.toggledisablesvg) {
        let objAssets = { id: nodeObj.toggledisablesvg, value: this.appStaticURL + "genericassets/shapes/" + nodeObj.toggledisablesvg + ".svg" };
        DiagramAssetLoader.oneTimeDownload(objAssets, true, document.body)
            .then((svgData) => {
                let uncheckmarksvg = DiagramNodeUtils.createSVGElement("svg");
                uncheckmarksvg.innerHTML = svgData.data;
                uncheckmarksvg.setAttribute("class", "uncheckmarksvg");
                uncheckmarksvg.setAttribute("data-id", "uncheckmarksvg");
                uncheckmarksvg.style.display = nodeDataToggle ? "none" : "flex";
                checkmark.appendChild(uncheckmarksvg);
            })
            .catch((error) => {
                console.log("SVG asset load fail - " + error);
            });
    }

    bgDiv.appendChild(contentParentNode);
    return contentParentNode;
};

NumberToggleStyleGroup.prototype.createNumberToggleGroup = function (mainParent, nodeObj) {
    let nodeParent = document.createElement("div");
    DiagramNodeUtils.assignAttributes(nodeParent, {
        class: "clsNumberToggleGroup",
        id: "numberToggleGroup" + this.index,
        "data-index": this.index,
        name: "numberToggleGroup",
    });
    mainParent.appendChild(nodeParent);

    if (nodeObj.colorClass) nodeParent.classList.add(DiagramUtils.createColorClass(nodeObj.colorClass));
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, nodeParent);

    let bgNodeDiv = document.createElement("div");
    nodeParent.appendChild(bgNodeDiv);
    DiagramNodeUtils.assignAttributes(bgNodeDiv, {
        class: "clsNumberToggleGroupBackgound moodanimation clsNodeAccentbg",
        "data-animation": "nodebg",
        "data-index": this.index,
        id: "numberToggleGroupBackgound" + this.index,
        name: "numberToggleGroupBackgound",
    });

    return nodeParent;
};

NumberToggleStyleGroup.prototype.createNumberToggleName = function (parentNode, nodeData, nodeObj) {
    let titleHolder = document.createElement("div");
    parentNode.appendChild(titleHolder);
    DiagramNodeUtils.assignAttributes(titleHolder, {
        "data-index": this.index,
        name: "numberToggleNameHolder",
        id: "numberToggleNameHolder" + this.index,
        "data-dck-selector": true,
        class: "clsNumberToggleNameHolder",
    });
    let arrValues = [256.11, 245.78, 286.11, 285.78, 277.11, 248.78];
    const value = nodeData && nodeData.value ? nodeData.value : arrValues[this.index] || 256.11;
    let titleNode = DiagramCreateUtil.createLabel(
        this.index,
        "clsNumberToggle " + (nodeObj.fontClass || this.objFontData.numberToggleFontSize),
        "numberToggleName",
        Constants.Value.valueTextPrompt,
        value,
        "nodeGroup"
    );
    titleHolder.appendChild(titleNode);
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, titleHolder);
    DiagramNodeUtils.assignAttributes(titleNode, { "data-index": this.index, id: "numberToggleName" + this.index });
    DiagramUtils.restrictMaxLines(titleNode);
    return titleHolder;
};

NumberToggleStyleGroup.prototype.createNumberToggleDescription = function (parentNode, nodeData, nodeObj) {
    let titleHolder = document.createElement("div");
    parentNode.appendChild(titleHolder);
    DiagramNodeUtils.assignAttributes(titleHolder, {
        "data-index": this.index,
        name: "numberToggleDescHolder",
        id: "numberToggleDescHolder" + this.index,
        "data-dck-selector": true,
        class: "clsNumberToggleDescHolder",
    });
    const value = nodeData && nodeData.value ? nodeData.value : "USD";
    let titleNode = DiagramCreateUtil.createLabel(
        this.index,
        "clsNumberToggleDesc " + (nodeObj.fontClass || this.objFontData.numberToggleDesFontSize),
        "numberToggleDesc",
        "Caption",
        value,
        "nodeGroup"
    );
    titleHolder.appendChild(titleNode);
    DiagramUtils.addClassesFromMenu(nodeObj.objClass, titleHolder);
    DiagramNodeUtils.assignAttributes(titleNode, { "data-index": this.index, id: "numberToggleDesc" + this.index });
    DiagramUtils.restrictMaxLines(titleNode);
    return titleHolder;
};

NumberToggleStyleGroup.prototype.getNumberToggleData = function (mainParent) {
    let nodeData = {};
    let numberToggleStyle = mainParent.querySelector("[id*='numberToggleStyle']");
    if (!numberToggleStyle) return;
    let numberToggleName = numberToggleStyle.querySelector("[name='numberToggleName']");
    if (numberToggleName) nodeData.name = { type: "text", value: numberToggleName.innerHTML };
    let numberToggleDes = numberToggleStyle.querySelector("[name='numberToggleDesc']");
    if (numberToggleDes) nodeData.description = { type: "text", value: numberToggleDes.innerHTML };
    let checklistNode = numberToggleStyle.querySelector("[data-id='checklistNode']");
    if (checklistNode) nodeData.ischecked = checklistNode.dataset.ischecked && checklistNode.dataset.ischecked == "true";
    // let numberToggleImage = numberToggleStyle.querySelector("[id*='imageNode']");
    // if (numberToggleImage) nodeData.numberToggleImage = { type: "image", value: numberToggleImage.src, contenttype: "image" };
    return nodeData;
};

NumberToggleStyleGroup.prototype.updateNumberToggleNode = function (parentNode) {
    let checklistNode = parentNode.querySelector("[data-id='checklistNode']");
    if (checklistNode) {
        let checkedClass = "clsToggleNumberEnable";
        let ischecked = checklistNode.dataset.ischecked && checklistNode.dataset.ischecked == "true";
        let checkmarksvg = parentNode.querySelector("[data-id='checkmarksvg']");
        let uncheckmarksvg = parentNode.querySelector("[data-id='uncheckmarksvg']");

        if (ischecked) {
            parentNode.parentElement.classList.add(checkedClass);
        } else {
            parentNode.parentElement.classList.remove(checkedClass);
        }

        if (checkmarksvg) {
            checkmarksvg.style.display = ischecked ? "flex" : "none";
        }

        if (uncheckmarksvg) {
            uncheckmarksvg.style.display = ischecked ? "none" : "flex";
        }
    }
};

NumberToggleStyleGroup.prototype.updateNumberToggleNodeForSign = function (checklistTextNode, parentNode) {
    let checklistNode = parentNode.querySelector("[data-id='checklistNode']");
    if (checklistNode && checklistTextNode.id.includes("numberToggleName")) {
        let checkedClass = "clsToggleNumberEnable";
        let sign = Math.sign(checklistTextNode.innerText);
        let checkmarksvg = parentNode.querySelector("[data-id='checkmarksvg']");
        let uncheckmarksvg = parentNode.querySelector("[data-id='uncheckmarksvg']");
        let ischecked = false;
        let gDataFormatter = eval("new " + "DataFormatUtil" + "()");
        var regex = new RegExp(",", "gi");
        let str = checklistTextNode.innerText.replace(regex, "").replace(/\s/g, "");
        let objFormatted = gDataFormatter.formatCurrency({ input: str });
        if (objFormatted && objFormatted.value && objFormatted.validData) {
            let valueSystem = objFormatted.valueSystem ? (objFormatted.valueSystem % 1 != 0 ? objFormatted.valueSystem.toFixed(1) : objFormatted.valueSystem) : objFormatted.value.toLocaleString();
            sign = Math.sign(objFormatted.currencyValueNormalized);
            str = objFormatted.prefix + (objFormatted.currencysymbol || "") + valueSystem + (objFormatted.currencySystem || "") + objFormatted.suffix;
            checklistTextNode.innerText = str;
        }
        if (checklistTextNode.innerText.startsWith("-")) {
            sign = -1;
        }
        if (sign == -1) {
            parentNode.classList.remove(checkedClass);
            checklistNode.setAttribute("data-ischecked", "false");
            ischecked = false;
        } else {
            parentNode.classList.add(checkedClass);
            checklistNode.setAttribute("data-ischecked", "true");
            ischecked = true;
        }

        if (checkmarksvg) {
            checkmarksvg.style.display = ischecked ? "flex" : "none";
        }

        if (uncheckmarksvg) {
            uncheckmarksvg.style.display = ischecked ? "none" : "flex";
        }
    }
};

function DataFormatUtil() {
    var STR_CURRENY = "\\$|\\xA2-\\xA5\\u058F\\u060B\\u09F2\\u09F3\\u09FB\\u0AF1\\u0BF9\\u0E3F\\u17DB\\u20A0-\\u20BD\\uA838\\uFDFC\\uFE69\\uFF04\\uFFE0\\uFFE1";
    var STR_CURRENY_SYSTEM = "million|mn|m|billion|bn|b|trillion|tn|t|thousand|k";
    var STR_REGEX_MONTH = "(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|(nov|dec)(?:ember)?)";
    var STR_REGEX_DAYS = "((mon|tues|wed(nes)?|thur(s)?|fri|sat(ur)?|sun)(day)?)";
    var STR_REGEX_YEAR = "(([1-3]{1}[0-9]{1})\\d{2}|(')?([0-9][0-9]))";
    var STR_REGEX_SEPERATOR = "(\\s)?(\\s|\\-|,|\\.|=)?(\\s)?";
    var STR_REGEX_EARNINGS = "((q|quarter)(\\s)?[1-9]|[1-9])";
    var STR_REGEX_MONTH_DATE = "(" + STR_REGEX_MONTH + "(\\s|,|\\-)?([0-9]|[0-3][0-9])\\b)";
    var STR_REGEX_DATE_MONTH = "(([0-9]|[0-3][0-9])(\\s|,|\\-)?" + STR_REGEX_MONTH + ")";
    var STR_REGEX_SIMPLE_DATE = "([1-3]{1}[0-9]{1})" + STR_REGEX_SEPERATOR + "(1[0-2]|[0-9]|0[1-9])" + STR_REGEX_SEPERATOR + "\\b(([1-3]{1}[0-9]{1})?\\d{2})\\b$";
    var STR_REGEX_SIMPLE_DATE_YEAR = "\\b(([1-3]{1}[0-9]{1})?\\d{2})\\b" + STR_REGEX_SEPERATOR + "([1-3]{1}[0-9]{1})" + STR_REGEX_SEPERATOR + "(1[0-2]|[0-9]|0[1-9])$";

    let monthRegEX = new RegExp("\\b^" + STR_REGEX_MONTH + "\\b", "i");
    let datMonthRegEX = new RegExp("\\b" + STR_REGEX_DATE_MONTH + "\\b", "i");
    let simeplDateRegEX = new RegExp(STR_REGEX_SIMPLE_DATE, "i");
    let simeplDateRegEXYearStart = new RegExp(STR_REGEX_SIMPLE_DATE_YEAR, "i");
    let updateDateFormat = new RegExp(
        "^(((3[01]|[12][0-9]|[1-9]|0[1-9])[/-\\s])?(\\b(?:jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|(nov|dec)(?:ember)?)\\b)([/-\\s]([1-3]{1}[0-9]{1})\\d{2})?)|((3[01]|[12][0-9]|[1-9]|0[1-9])[/-\\s](1[0-2]|[0-9]|0[1-9])[/-\\s]\\b([1-3]{1}[0-9]{1})\\d{2}\\b)$",
        "ig"
    );
    let yearFormat = new RegExp("^\\b([1-3]{1}[0-9]{1})\\d{2}|([0-9][0-9])\\b", "g");

    let daysRegEX = new RegExp(STR_REGEX_DAYS, "i");
    let erningRegEX = new RegExp(STR_REGEX_EARNINGS, "i");
    let monthDateRegEX = new RegExp(STR_REGEX_MONTH_DATE, "i");
    let yearMonthDateYearRegEX = new RegExp("^(" + STR_REGEX_DAYS + "(\\-|,|\\s)(\\s)?" + STR_REGEX_MONTH_DATE + STR_REGEX_SEPERATOR + STR_REGEX_YEAR + "\\b)", "i");
    let monthYearRegEX = new RegExp("^(" + STR_REGEX_MONTH + STR_REGEX_SEPERATOR + STR_REGEX_YEAR + "\\b)", "i");
    let monthDateYearRegEX = new RegExp("^(" + STR_REGEX_MONTH_DATE + STR_REGEX_SEPERATOR + STR_REGEX_YEAR + "\\b)", "i");
    let earningYearRegEX = new RegExp("^(" + STR_REGEX_EARNINGS + STR_REGEX_SEPERATOR + STR_REGEX_YEAR + "\\b)", "i");

    function getNumberForMonth(month) {
        let numMonth = "janfebmaraprmayjunjulaugsepoctnovdec".indexOf(month.toLowerCase()) / 3 + 1;
        return numMonth < 10 ? "0" + numMonth : numMonth + "";
    }

    DataFormatUtil.prototype.checkValueInString = function (strValue) {
        let checkValue = new RegExp("(\\s|^)([" + STR_CURRENY + "\\%])?\\s?\\d+\\s?([" + STR_CURRENY + "\\%])?\\s", "gi");
        return strValue.match(checkValue);
    };

    DataFormatUtil.prototype.checkDate = function (strValue) {
        let boolDate = updateDateFormat.test(strValue.toLowerCase());
        let boolYear = yearFormat.test(strValue.toLowerCase());
        let type = boolDate || boolYear;
        if (type) {
            let format = boolDate ? updateDateFormat : yearFormat;
            let arrMatch = strValue.match(format);
            if (arrMatch && arrMatch.length > 0) {
                return boolYear ? (arrMatch[0].length == 4 ? arrMatch[0] : "") : arrMatch[0];
            }
        } else {
            return "";
        }
    };

    DataFormatUtil.prototype.format = function (arrInput, callBack) {
        //let arrInput = [strDate];
        let arrUpdated = [];
        let arrUpdatedShort = [];
        let forceShot = true;
        let process = false;
        if (arrInput.length > 0) {
            for (var i = 0; i < arrInput.length; i++) {
                let strValue = arrInput[i];
                let shortValue = strValue;
                if (yearMonthDateYearRegEX.test(strValue.toLowerCase())) {
                    process = true;
                    let year = strValue
                        .toLowerCase()
                        .replace(monthDateRegEX, "")
                        .replace(/[^0-9]/g, "");
                    let day = strValue
                        .replace(year, "")
                        .replace(monthRegEX, "")
                        .replace(/[^a-zA-Z]/g, "");

                    let monthMatch = strValue.match(new RegExp(STR_REGEX_MONTH, "ig"));
                    let month = monthMatch && monthMatch.length > 0 ? monthMatch[0] : strValue;

                    let monthSmall = month.substring(0, Math.min(3, month.length));
                    let value = strValue
                        .replace(monthRegEX, "")
                        .replace(year, "")
                        .replace(day, "")
                        .replace(/[^0-9]/g, "");
                    value = value.length == 1 ? "0" + value : value;
                    day = day.substring(0, Math.min(3, day.length));
                    strValue = day + ", " + value + "-" + monthSmall + "-" + (year.length > 2 ? year.substring(year.length - 2, year.length) : year);
                    shortValue = i == 0 && !forceShot ? strValue : day + ", " + value + "-" + getNumberForMonth(monthSmall) + "-" + (year.length > 2 ? year.substring(year.length - 2, year.length) : year);
                } else if (monthDateYearRegEX.test(strValue.toLowerCase())) {
                    process = true;
                    let year = strValue.toLowerCase().replace(monthDateRegEX, "");
                    let month = strValue.replace(year, "").replace(/[^a-zA-Z]/g, "");
                    let monthSmall = month.substring(0, Math.min(3, month.length));
                    let value = strValue
                        .replace(monthRegEX, "")
                        .replace(year, "")
                        .replace(/[^0-9]/g, "");
                    value = value.length == 1 ? "0" + value : value;

                    strValue = value + "-" + monthSmall + "-" + (year.length > 2 ? year.substring(year.length - 2, year.length) : year);
                    shortValue = i == 0 && !forceShot ? strValue : value + "-" + getNumberForMonth(monthSmall) + "-" + (year.length > 2 ? year.substring(year.length - 2, year.length) : year);
                } else if (earningYearRegEX.test(strValue)) {
                    process = true;
                    let year = strValue.toLowerCase().replace(erningRegEX, "");
                    let value = strValue
                        .replace(/quarter|Quarter|q|Q/, "")
                        .replace(year, "")
                        .replace(/[^0-9]/g, "");
                    strValue = "Q" + value + " '" + (year.length > 2 ? year.substring(year.length - 2, year.length) : year);
                    shortValue = strValue;
                } else if (monthYearRegEX.test(strValue)) {
                    process = true;
                    let year = strValue.replace(monthRegEX, "");
                    let month = strValue.replace(year, "").replace(/[^a-zA-Z]/g, "");
                    let monthSmall = month.substring(0, Math.min(3, month.length));
                    year = year.replace(/[^0-9]/g, "");
                    strValue = monthSmall + "-" + (year.length > 2 ? year.substring(year.length - 2, year.length) : year);
                    shortValue = i == 0 && !forceShot ? strValue : month.substring(0, Math.min(1, month.length));
                    shortValue = shortValue + "-" + (year.length > 2 ? year.substring(year.length - 2, year.length) : year);
                } else if (datMonthRegEX.test(strValue)) {
                    process = true;
                    let month = strValue.replace(/[^a-zA-Z]/g, "");
                    let monthSmall = month.substring(0, Math.min(3, month.length));
                    let value = strValue.replace(monthRegEX, "").replace(/[^0-9]/g, "");
                    strValue = value + "-" + monthSmall;
                    shortValue = strValue;
                } else if (monthRegEX.test(strValue)) {
                    process = true;
                    strValue = strValue.substring(0, Math.min(3, strValue.length));
                    shortValue = i == 0 && !forceShot ? strValue : strValue.substring(0, Math.min(1, strValue.length));
                } else if (daysRegEX.test(strValue)) {
                    process = true;
                    strValue = strValue.replace(/day|Day|DAY/, "");
                    shortValue = i == 0 && !forceShot ? strValue : strValue.substring(0, Math.min(1, strValue.length));
                } else if (simeplDateRegEX.test(strValue) || simeplDateRegEXYearStart.test(strValue)) {
                    process = true;
                    let isYearEnd = !simeplDateRegEXYearStart.test(strValue);
                    let arrSplit = strValue.split(/(\-|\s)/);
                    let arrDateData = [];
                    for (let d1 = 0; d1 < arrSplit.length; d1++) {
                        if (arrSplit[d1].replace(/(\-|\s)/g, "") != "") {
                            arrDateData.push(parseInt(arrSplit[d1]));
                        }
                    }
                    let year = isYearEnd ? arrDateData[arrDateData.length - 1] : arrDateData[0];
                    let month = arrDateData[1] - 1;
                    let day = !isYearEnd ? arrDateData[arrDateData.length - 1] : arrDateData[0];

                    const date = new Date(year, month, day); // 2009-11-10
                    const monthPrint = date.toLocaleString("en-us", { month: "long" });

                    strValue = day + " " + monthPrint + " " + year;
                    shortValue = strValue;
                }

                arrUpdated.push(strValue);
                arrUpdatedShort.push(shortValue);
            }
        }
        let result = { normal: arrInput, full: arrUpdated, short: arrUpdatedShort, processed: process };
        if (callBack) callBack(result);
        else return result;
    };

    DataFormatUtil.prototype.formatString = function (strData, callBack) {
        let ogData = strData;
        let bracketRegEX = new RegExp("\\(([^)]+)\\)", "g");
        let onlyBracket = strData.match(bracketRegEX, "g");
        let withOutBracket = strData.replace(bracketRegEX, "");
        var currency = "(" + STR_CURRENY_SYSTEM + "|" + STR_CURRENY + ")|(\brs|inr|usd\b)";
        var STR_REGEX_DAYS = "(\\s)(\\(?)(" + currency + "\\s?)?([0-9]+((\\.|,)[0-9]{1,6})?)(\\s?" + currency + "?)%?(\\))?(\\s+)?\\b";
        let currencyRegEX = new RegExp(STR_REGEX_DAYS, "gmi");

        let mainValue = [];
        let valueFromBracket = false;
        let bracketValue = [];

        if (onlyBracket && onlyBracket.length > 0) {
            let bracketRemoved = onlyBracket[0].replace(/\(|\)/g, "");
            if (currencyRegEX.test(bracketRemoved)) {
                bracketValue = bracketRemoved.match(currencyRegEX);
            }
        }

        if (currencyRegEX.test(withOutBracket) || currencyRegEX.test(" " + withOutBracket)) {
            let value = withOutBracket.match(currencyRegEX);
            mainValue = value ? value : (" " + withOutBracket).match(currencyRegEX);
        } else {
            valueFromBracket = true;
            mainValue = bracketValue;
        }

        let result = {};
        if (mainValue && mainValue.length > 0) {
            result.value = mainValue[0];
            result.input = mainValue[0];
            result.valueFromBracket = valueFromBracket;
            result.bracket = onlyBracket;
            result.bracketValue = bracketValue.length > 0 ? bracketValue[0] : "";
            this.formatCurrency(result);
        } else {
            result.value = "";
            result.valueFromBracket = false;
            result.bracket = "";
            result.bracketValue = "";
        }
        result.input = ogData;
        result.date = this.checkDate(ogData);

        if (callBack) callBack(result);
        else return result;
    };

    //Get the string and check its has valid number with decimal , if has any suffix like currecny system is there like million normalize the value and add the currecny system
    //if suffix is like user use same value in normlize and add suffix

    //All will work with decimal too

    //$ 10 Users -- Normalize ==> 10 --> currecny--> $ --> suffix ---> users
    //$ 10 K -- Normalize ==> 10000 --> currecny--> $ --> suffix ---> K --> Currency system -> k
    //10 -- Normalize ==> 10 --> currecny--> "" --> suffix ---> "" --> Currency system -> ""
    //somedata 10 K -- Normalize ==> 10000 --> currecny--> k --> suffix ---> "k" --> Currency system -> ""  prefix -> somedata
    //1sdfs12 -> invalis try to give 12(big number) as normalize

    //"dfadsf asdfas 43.4.5 $%#$%#".split(/[^0-9\.]+/)

    DataFormatUtil.prototype.formatCurrency = function (formatDetection, callBack) {
        let symbols = "[" + STR_CURRENY + "]|(\brs|inr|usd\b)";
        let currencyShort = "(" + STR_CURRENY_SYSTEM + ")\\b";
        let currencySuffix = "(((\\d)|(\\s)|(\\b))(" + STR_CURRENY_SYSTEM + "))\\b";

        let strData = formatDetection.input;
        //^(0|[1-9]\d*)(\.\d+)?$

        let regExCurrencySystem = new RegExp(currencyShort, "gmi");
        let regExCurrencySymbol = new RegExp(symbols, "gmi");
        let regExCurrencySuffix = new RegExp(currencySuffix, "gmi");

        let arrMatchValue = strData.match(/((\d+|\d)(\.|\,)?(\d+|\d)?)/g);
        let isValidData = arrMatchValue?.length == 1;
        if (arrMatchValue && !isNaN(parseFloat(arrMatchValue[0].replace(/\,/g, ""))) && arrMatchValue.length > 1) {
            let stingdata = "";
            for (let i1 = 0; i1 < arrMatchValue.length; i1++) {
                if (!isNaN(parseFloat(arrMatchValue[i1].replace(/\,/g, "")))) {
                    stingdata += arrMatchValue[i1];
                    isValidData = true;
                } else {
                    isValidData = false;
                    stingdata = "";
                    break;
                }
            }
            if (stingdata) {
                let tempValue = stingdata.match(/((\d+|\d)(\.|\,)?(\d+|\d)?)/g);
                if (tempValue && tempValue.length == 1) {
                    arrMatchValue = [tempValue[0]];
                } else {
                    arrMatchValue = [stingdata];
                }
            }
        }
        if (arrMatchValue && arrMatchValue.length > 0 && !isNaN(parseFloat(arrMatchValue[0].replace(/\,/g, ""))) && isValidData) {
            let currencyValue = arrMatchValue[0].replace(/,/g, "");
            let arrPrefixSuffix = strData.includes(arrMatchValue[0]) ? strData.split(arrMatchValue[0]) : [];
            if (arrPrefixSuffix.length > 0) {
                formatDetection.validData = true;
                let strSuffix = "";
                if (arrPrefixSuffix.length > 1) {
                    strSuffix = arrPrefixSuffix[1];
                }

                let valueData = this.currencyValuetoCurrencySystem(currencyValue);
                formatDetection.valueSystemDecimal = valueData.value.toFixed(2);
                formatDetection.valueSystem = valueData.value;
                formatDetection.currencySystem = valueData.currency;
                formatDetection.currencySystemShort = valueData.currency;
                formatDetection.prefix = "";
                formatDetection.suffix = "";
                formatDetection.currencysymbol = "";
                formatDetection.value = currencyValue;
                formatDetection.currencyValueNormalized = currencyValue;

                let validateCurrencySymbol = regExCurrencySymbol.test(strData);
                let validateCurrencySystem = regExCurrencySuffix.test(strSuffix);
                if (validateCurrencySystem) {
                    formatDetection.iscurrency = true;
                    formatDetection.currencySystem = strSuffix.match(regExCurrencySystem)[0];
                    formatDetection.currencySystemShort = this.shortFormCurrencySystem(formatDetection.currencySystem);
                    let valuePrefix = arrPrefixSuffix[1].split(formatDetection.currencySystem);
                    formatDetection.suffix = valuePrefix.length > 1 ? valuePrefix[1] : "";
                    formatDetection.currencyValueNormalized = currencyValue * this.convertWordToNumber(formatDetection.currencySystem);
                    formatDetection.currencyValueString = this.convertNumberToWords(formatDetection.currencyValueNormalized);
                } else if (strSuffix != "") {
                    formatDetection.suffix = arrPrefixSuffix[1];
                }

                if (validateCurrencySymbol) {
                    formatDetection.currencysymbol = strData.match(regExCurrencySymbol)[0];
                    formatDetection.prefix = arrPrefixSuffix[0];
                } else if (arrPrefixSuffix && arrPrefixSuffix.length > 0 && arrPrefixSuffix[0].trim() == "-") {
                    formatDetection.valueSystem = -1 * formatDetection.valueSystem;
                    formatDetection.value = -+"" + formatDetection.value;
                    formatDetection.currencyValueNormalized = -1 * (formatDetection.currencyValueNormalized || formatDetection.valueSystem);
                } else if (arrPrefixSuffix && arrPrefixSuffix.length > 0) {
                    formatDetection.prefix = arrPrefixSuffix[0];
                }

                formatDetection.prefix = formatDetection.prefix.replace(formatDetection.currencysymbol, "");
                formatDetection.prefix = formatDetection.prefix.replace(currencyValue, "");
                formatDetection.suffix = formatDetection.suffix.replace(currencyValue, "");
                formatDetection.suffix = formatDetection.suffix.replace(formatDetection.currencysymbol, "");
            } else {
                formatDetection.validData = false;
            }
        } else {
            formatDetection.validData = false;
        }
        return formatDetection;
    };

    DataFormatUtil.prototype.convertNumberToWords = function (amountValue, callBack) {
        let amount = amountValue < 0 ? -1 * amountValue : amountValue;
        var words = new Array();
        words[0] = "";
        words[1] = "One";
        words[2] = "Two";
        words[3] = "Three";
        words[4] = "Four";
        words[5] = "Five";
        words[6] = "Six";
        words[7] = "Seven";
        words[8] = "Eight";
        words[9] = "Nine";
        words[10] = "Ten";
        words[11] = "Eleven";
        words[12] = "Twelve";
        words[13] = "Thirteen";
        words[14] = "Fourteen";
        words[15] = "Fifteen";
        words[16] = "Sixteen";
        words[17] = "Seventeen";
        words[18] = "Eighteen";
        words[19] = "Nineteen";
        words[20] = "Twenty";
        words[30] = "Thirty";
        words[40] = "Forty";
        words[50] = "Fifty";
        words[60] = "Sixty";
        words[70] = "Seventy";
        words[80] = "Eighty";
        words[90] = "Ninety";
        amount = amount.toString();
        var atemp = amount.split(".");
        var number = atemp[0].split(",").join("");
        var n_length = number.length;
        var words_string = "";
        if (n_length <= 9) {
            var n_array = new Array(0, 0, 0, 0, 0, 0, 0, 0, 0);
            var received_n_array = new Array();
            for (var i = 0; i < n_length; i++) {
                received_n_array[i] = number.substr(i, 1);
            }
            for (var i = 9 - n_length, j = 0; i < 9; i++, j++) {
                n_array[i] = received_n_array[j];
            }
            for (var i = 0, j = 1; i < 9; i++, j++) {
                if (i == 0 || i == 2 || i == 4 || i == 7) {
                    if (n_array[i] == 1) {
                        n_array[j] = 10 + parseInt(n_array[j]);
                        n_array[i] = 0;
                    }
                }
            }
            let value = "";
            for (var i = 0; i < 9; i++) {
                if (i == 0 || i == 2 || i == 4 || i == 7) {
                    value = n_array[i] * 10;
                } else {
                    value = n_array[i];
                }
                if (value != 0) {
                    words_string += words[value] + " ";
                }
                if ((i == 1 && value != 0) || (i == 0 && value != 0 && n_array[i + 1] == 0)) {
                    words_string += "Crores ";
                }
                if ((i == 3 && value != 0) || (i == 2 && value != 0 && n_array[i + 1] == 0)) {
                    words_string += "Lakhs ";
                }
                if ((i == 5 && value != 0) || (i == 4 && value != 0 && n_array[i + 1] == 0)) {
                    words_string += "Thousand ";
                }
                if (i == 6 && value != 0 && n_array[i + 1] != 0 && n_array[i + 2] != 0) {
                    words_string += "Hundred and ";
                } else if (i == 6 && value != 0) {
                    words_string += "Hundred ";
                }
            }
            words_string = words_string.split("  ").join(" ");
        }
        return words_string;
    };

    DataFormatUtil.prototype.currencyValuetoCurrencySystem = function (value) {
        let absValue = Math.abs(Number(value));
        if (absValue >= 1.0e9) {
            return { value: absValue / 1.0e9, currency: this.shortFormCurrencySystem("b") };
        } else if (absValue >= 1.0e6) {
            return { value: absValue / 1.0e6, currency: this.shortFormCurrencySystem("m") };
        } else if (absValue >= 1.0e3) {
            return { value: absValue / 1.0e3, currency: this.shortFormCurrencySystem("k") };
        } else {
            return { value: absValue, currency: "" };
        }
    };

    DataFormatUtil.prototype.convertWordToNumber = function (strData) {
        if (/\bmillion|mn|m\b/i.test(strData)) {
            return 1000000;
        } else if (/\bbillion|bn|b\b/i.test(strData)) {
            return 1000000000;
        } else if (/\btrillion|tn|t\b/i.test(strData)) {
            return 1000000000000;
        } else if (/\bthousand|k\b/i.test(strData)) {
            return 1000;
        }
        return 1;
    };

    DataFormatUtil.prototype.shortFormCurrencySystem = function (strData) {
        if (/\bmillion|mn|m\b/i.test(strData)) {
            return "Mn";
        } else if (/\bbillion|bn|b\b/i.test(strData)) {
            return "Bn";
        } else if (/\btrillion|tn|t\b/i.test(strData)) {
            return "Tn";
        } else if (/\bcrores|k\b/i.test(strData)) {
            return "K";
        } else if (/\blakh|lakhs|l|lks|lh\b/i.test(strData)) {
            return "L";
        }
        return 1;
    };
}

/**
 * Author:    Bala Krishnan K
 * Created:   17.11.2023
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function AISearchUtils() {}

AISearchUtils.prototype.constructor = AISearchUtils;

// objSearch = {text: ["search text1","search text2"], type: "icon", style: "solid","imgtype":"nodes"}
AISearchUtils.searchIcon = function (appBaseURL, objSearch, searchCallBack, extraAttribs = {}, searchFailureCallBack) {
    let searchText = encodeURIComponent(JSON.stringify(objSearch.text));
    let strURL = appBaseURL + "getSingleIconOrImage?type=" + objSearch.type + "&search=" + searchText;
    if (objSearch.style) strURL = strURL + "&style=" + objSearch.style;
    if (objSearch.imgtype) strURL = strURL + "&img_type=" + objSearch.imgtype;

    let xhr = new XMLHttpRequest();
    xhr.open("GET", strURL.trim());
    xhr.onload = () => {
        try {
            let objResponse = JSON.parse(xhr.responseText);
            if (objResponse && objResponse.status == 0) {
                searchCallBack?.(objResponse, extraAttribs, searchFailureCallBack);
            } else {
                searchFailureCallBack?.(objResponse);
            }
        } catch (e) {
            searchFailureCallBack?.(e);
            console.log("Error in Applying AI Search : " + e);
        }
    };
    xhr.onerror = (e) => {
        searchFailureCallBack?.(e);
        console.log("Fetch Error in AI Search" + e);
    };
    xhr.send();
};

/**
 * Author:    BalaKrishnan K.
 * Created:   22.11.2023
 *
 * (c) Copyright by Gs.
 **/

"use strict";

function CommonImageUtils() {}

CommonImageUtils.updateImageBounds = function (imageNode, properties, scaleFacetor = 1) {
    if (imageNode && imageNode.parentElement) {
        let position = DiagramNodeUtils.getOffsetLeftTop(imageNode.parentElement);
        imageNode.setAttribute("data-x", position.x / scaleFacetor);
        imageNode.setAttribute("data-y", position.y / scaleFacetor);
        imageNode.setAttribute("data-width", imageNode.parentElement.clientWidth * scaleFacetor);
        imageNode.setAttribute("data-height", imageNode.parentElement.clientHeight * scaleFacetor);
        CommonImageUtils.updateImageReSize(imageNode, properties);
    }
};

// params - (originalImageNode, properties = { filltype="fitcanvas/fillcanvas", containerwidth = 1000px ,containerheight = 1000px ,islogofit: true/false, contenttype: "image/logo" }, callback, callbackparam)
CommonImageUtils.updateImageReSize = function (originalImageNode, properties, callback, callbackparam) {
    let imageDataSet = originalImageNode.dataset;
    if (imageDataSet && (parseInt(imageDataSet.height) == 0 || parseInt(imageDataSet.width) == 0)) return;
    if (originalImageNode.complete) CommonImageUtils.updateImageReSizeAfterLoad(originalImageNode, properties, callback, callbackparam);
    else if (originalImageNode) {
        try {
            originalImageNode.onload = function () {
                CommonImageUtils.updateImageReSizeAfterLoad(originalImageNode, properties, callback, callbackparam);
            };
            const imgSrc = originalImageNode.src;
            originalImageNode.src = imgSrc;
        } catch (error) {
            if (callback) callback(callbackparam);
        }
    }
};

// params - (originalImageNode, properties = { filltype="fitcanvas/fillcanvas", containerwidth = 1000px ,containerheight = 1000px ,islogofit: true/false, contenttype: "image/logo" }, callback, callbackparam)
CommonImageUtils.updateImageReSizeAfterLoad = function (originalImageNode, properties, callback, callbackparam) {
    let imageDataSet = originalImageNode.dataset;
    if (imageDataSet && !properties?.filltype && (parseInt(imageDataSet.height) == 0 || parseInt(imageDataSet.width) == 0 || (originalImageNode.dataset.style && originalImageNode.style.cssText && originalImageNode.style.cssText != ""))) return;
    const numContainerW = properties?.containerwidth ? properties?.containerwidth : originalImageNode.parentElement ? originalImageNode.parentElement.offsetWidth : 1;
    const numContainerH = properties?.containerheight ? properties?.containerheight : originalImageNode.parentElement ? originalImageNode.parentElement.offsetHeight : 1;
    let hasLogo = properties?.contenttype == "logo" && properties?.islogofit ? properties.islogofit : "false";
    let imageFit = properties?.isimagefit;
    CommonImageUtils.resetImageStyle(originalImageNode);
    if (originalImageNode.dataset.hasinternalflip == "true") {
        originalImageNode.style.transform = "scale(1) scaleX(-1)";
    }
    if (originalImageNode.parentNode && originalImageNode.parentNode.dataset.horflipvalue) {
        originalImageNode.style.transform = "scale(1) scaleX(" + originalImageNode.parentNode.dataset.horflipvalue + ")";
    }
    let imageDimensionRatio = originalImageNode.width / originalImageNode.height;
    let canvasDimensionRatio = numContainerW / numContainerH;

    let filltype = properties?.filltype || (hasLogo != "false" || imageFit ? "fitcanvas" : "fillcanvas");
    let contentNode = originalImageNode?.parentElement?.parentElement;
    let isContentNode = contentNode && contentNode.getAttribute("name") && contentNode.getAttribute("name") == "contentNode";
    if (imageDimensionRatio < canvasDimensionRatio || (hasLogo != "false" && imageDimensionRatio == canvasDimensionRatio)) {
        if (filltype == "fitcanvas") CommonImageUtils.fitHeight(originalImageNode, numContainerW);
        else CommonImageUtils.fitWidth(originalImageNode, numContainerH);
    } else if (imageDimensionRatio > canvasDimensionRatio) {
        if (filltype == "fitcanvas") CommonImageUtils.fitWidth(originalImageNode, numContainerH);
        else CommonImageUtils.fitHeight(originalImageNode, numContainerW);
    } else {
        originalImageNode.style.setProperty("width", "100%");
        originalImageNode.style.setProperty("height", "auto");
        originalImageNode.style.setProperty("left", "0");
        originalImageNode.style.setProperty("margin", "unset");
        originalImageNode.style.setProperty("top", "0");
    }

    let imageCropAlign = properties?.graphicData?.alignment || originalImageNode?.dataset?.imagecropalignment;
    if (originalImageNode && imageCropAlign && imageCropAlign == "bottom" && hasLogo != "center") {
        originalImageNode.style.setProperty("top", "unset");
        originalImageNode.style.setProperty("bottom", "0px");
        originalImageNode.style.setProperty("margin", "auto");
        if (isContentNode) {
            contentNode.style.justifyContent = "center";
            contentNode.style.alignItems = "flex-end";
        }
    }

    if (originalImageNode && imageCropAlign && imageCropAlign == "center") {
        originalImageNode.style.setProperty("top", "0px");
        originalImageNode.style.setProperty("bottom", "0px");
        originalImageNode.style.setProperty("margin", "auto");
        if (isContentNode) {
            contentNode.style.justifyContent = "center";
            contentNode.style.alignItems = "center";
        }
    }

    if (originalImageNode && imageCropAlign && imageCropAlign == "right") {
        originalImageNode.style.setProperty("right", "0px");
        originalImageNode.style.setProperty("left", "unset");
        originalImageNode.style.setProperty("margin", "auto");
        if (isContentNode) {
            contentNode.style.justifyContent = "flex-end";
            contentNode.style.alignItems = "center";
        }
    }

    if (originalImageNode && imageCropAlign && imageCropAlign == "left") {
        originalImageNode.style.setProperty("right", "unset");
        originalImageNode.style.setProperty("left", "0px");
        originalImageNode.style.setProperty("margin", "auto");
        if (isContentNode) {
            contentNode.style.justifyContent = "flex-start";
            contentNode.style.alignItems = "center";
        }
    }
    if (originalImageNode && imageCropAlign && imageCropAlign == "rightbottom") {
        originalImageNode.style.setProperty("right", "0px");
        originalImageNode.style.setProperty("left", "unset");
        originalImageNode.style.setProperty("top", "unset");
        originalImageNode.style.setProperty("bottom", "0px");
        originalImageNode.style.setProperty("margin", "auto");
        if (isContentNode) {
            contentNode.style.justifyContent = "flex-end";
            contentNode.style.alignItems = "flex-end";
        }
    }

    if (originalImageNode && imageCropAlign && imageCropAlign == "leftbottom") {
        originalImageNode.style.setProperty("right", "unset");
        originalImageNode.style.setProperty("left", "0px");
        originalImageNode.style.setProperty("top", "unset");
        originalImageNode.style.setProperty("bottom", "0px");
        originalImageNode.style.setProperty("margin", "auto");
        if (isContentNode) {
            contentNode.style.justifyContent = "flex-start";
            contentNode.style.alignItems = "flex-end";
        }
    }

    if (originalImageNode && imageCropAlign && imageCropAlign == "righttop") {
        originalImageNode.style.setProperty("right", "0px");
        originalImageNode.style.setProperty("left", "unset");
        originalImageNode.style.setProperty("top", "0px");
        originalImageNode.style.setProperty("bottom", "unset");
        originalImageNode.style.setProperty("margin", "auto");
        if (isContentNode) {
            contentNode.style.justifyContent = "flex-end";
            contentNode.style.alignItems = "flex-start";
        }
    }

    if (originalImageNode && imageCropAlign && imageCropAlign == "lefttop") {
        originalImageNode.style.setProperty("right", "unset");
        originalImageNode.style.setProperty("left", "0px");
        originalImageNode.style.setProperty("top", "0px");
        originalImageNode.style.setProperty("bottom", "unset");
        originalImageNode.style.setProperty("margin", "auto");
        if (isContentNode) {
            contentNode.style.justifyContent = "flex-start";
            contentNode.style.alignItems = "flex-start";
        }
    }
    if (originalImageNode && imageCropAlign && imageCropAlign == "top") {
        originalImageNode.style.setProperty("top", "0px");
        originalImageNode.style.setProperty("bottom", "unset");
        originalImageNode.style.setProperty("margin", "auto");
        if (isContentNode) {
            contentNode.style.justifyContent = "center";
            contentNode.style.alignItems = "flex-start";
        }
    }
    if (originalImageNode?.parentNode) {
        originalImageNode.parentNode.dataset.orginalwidth = originalImageNode.width;
        originalImageNode.parentNode.dataset.orginalheight = originalImageNode.height;
        originalImageNode.parentNode.dataset.containerwidth = numContainerW;
        originalImageNode.parentNode.dataset.containerheight = numContainerH;
    }
    if (!properties || !properties?.isSpecialgraphcis) originalImageNode?.setAttribute("data-csstext", originalImageNode.style.cssText);
    callback?.(callbackparam);
};

CommonImageUtils.fitHeight = function (originalImageNode, numContainerW) {
    originalImageNode.style.setProperty("height", "100%");
    originalImageNode.style.setProperty("width", "auto");
    originalImageNode.style.setProperty("margin", "unset");
    originalImageNode.style.setProperty("top", "0");
    originalImageNode.style.setProperty("left", (numContainerW - originalImageNode.width) / 2 / (numContainerW / 100) + "%");
};

CommonImageUtils.fitWidth = function (originalImageNode, numContainerH) {
    originalImageNode.style.setProperty("width", "100%");
    originalImageNode.style.setProperty("height", "auto");
    originalImageNode.style.setProperty("left", "0");
    originalImageNode.style.setProperty("margin", "unset");
    originalImageNode.style.setProperty("top", (numContainerH - originalImageNode.height) / 2 / (numContainerH / 100) + "%");
};

CommonImageUtils.resetImageStyle = function (originalImageNode) {
    originalImageNode.style.removeProperty("min-width");
    originalImageNode.style.removeProperty("min-height");
    originalImageNode.style.removeProperty("max-width");
    originalImageNode.style.removeProperty("max-height");
    originalImageNode.style.removeProperty("filter");

    originalImageNode.style.setProperty("width", "auto");
    originalImageNode.style.setProperty("height", "auto");
    originalImageNode.style.setProperty("margin", "auto");
    originalImageNode.style.setProperty("position", "absolute");
    originalImageNode.style.setProperty("left", "unset");
    originalImageNode.style.setProperty("right", "unset");
    originalImageNode.style.setProperty("top", "unset");
    originalImageNode.style.setProperty("bottom", "unset");
    originalImageNode.style.setProperty("x", "0");
    originalImageNode.style.setProperty("y", "0");
    originalImageNode.style.setProperty("transform", "scale(1)");
    originalImageNode.style.setProperty("object-fit", "unset");
};

// Origami Image fit
CommonImageUtils.updateImageReSizeOrigami = function (imgSize, parentSize, properties = {}) {
    let holderRatio = parentSize.width / parentSize.height;
    let imageRatio = imgSize.width / imgSize.height;

    if (holderRatio > imageRatio) {
        //fit width
        let wRatio = parentSize.width / imgSize.width;
        let nWidth = imgSize.width * wRatio;
        let nHeight = imgSize.height * wRatio;
        imgSize.width = nWidth;
        imgSize.height = nHeight;
    } else if (holderRatio < imageRatio) {
        //fit height
        let hRatio = parentSize.height / imgSize.height;
        let nWidth = imgSize.width * hRatio;
        let nHeight = imgSize.height * hRatio;
        imgSize.width = nWidth;
        imgSize.height = nHeight;
    }

    const numContainerW = parentSize.width;
    const numContainerH = parentSize.height;
    let hasLogo = properties?.contenttype == "logo" && properties?.islogofit ? properties.islogofit : "false";
    let imageFit = properties?.isimagefit;

    let imageDimensionRatio = imgSize.width / imgSize.height;
    let canvasDimensionRatio = numContainerW / numContainerH;

    let filltype = properties?.filltype || (hasLogo != "false" || imageFit ? "fitcanvas" : "fillcanvas");
    if (imageDimensionRatio < canvasDimensionRatio || (hasLogo != "false" && imageDimensionRatio == canvasDimensionRatio)) {
        if (filltype == "fitcanvas") return fitHeightOrigami(imgSize, numContainerW);
        else return fitWidthOrigami(imgSize, numContainerH);
    } else if (imageDimensionRatio > canvasDimensionRatio) {
        if (filltype == "fitcanvas") return fitWidthOrigami(imgSize, numContainerH);
        else return fitHeightOrigami(imgSize, numContainerW);
    } else
        return {
            width: "100%",
            height: "100%",
            left: 0,
            top: 0,
            margin: "auto",
        };

    function fitHeightOrigami(originalImageNode, numContainerW) {
        return {
            width: "auto",
            height: "100%",
            left: (numContainerW - originalImageNode.width) / 2 / (numContainerW / 100) + "%",
            top: 0,
            margin: "unset",
        };
    }

    function fitWidthOrigami(originalImageNode, numContainerH) {
        return {
            width: "100%",
            height: "auto",
            left: 0,
            top: (numContainerH - originalImageNode.height) / 2 / (numContainerH / 100) + "%",
            margin: "unset",
        };
    }
};
